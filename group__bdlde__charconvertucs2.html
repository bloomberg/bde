<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlde_charconvertucs2 Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlde_charconvertucs2<br/>
<small>
[<a class="el" href="group__bdlde.html">Package bdlde</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide efficient conversions between UTF-8 and UCS-2 encodings.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlde.html">bdlde</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">History and Motivation</a> <ul>
<li>
<a href="#3.1.1">Usage</a> </li>
<li>
<a href="#3.1.2">Example 1: C-Style Interface</a> </li>
<li>
<a href="#3.1.3">Example 2: C-Style Round-Trip</a> </li>
<li>
<a href="#3.1.4">Example 3: C++-Style Interface</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide efficient conversions between UTF-8 and UCS-2 encodings. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbdlde_1_1CharConvertUcs2.html">bdlde::CharConvertUcs2</a> </td><td>namespace for conversions between UTF-8 and UCS-2  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a suite of pure procedures supporting the <em>fast</em> conversion of <em>valid</em> UTF-8 encoded "C" strings to <em>valid</em> UCS-2 16-bit character arrays and vice versa. In order to provide the fastest possible implementation, some error checking is deliberately omitted, and the input strings are required to be null-terminated; however, all C-style functions will honor <code>strlcpy</code> semantics and null-terminate any output buffer having a non-zero length. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="history_and_motivation"></a> <a class="anchor" id="description.history_and_motivation"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>History and Motivation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>UTF-8 is a character encoding that allows 32-bit character sets like Unicode to be represented using null-terminated (8-bit) byte strings (NTBS), while allowing "standard ASCII" strings to be used "as-is". Note that UTF-8 is described in detail in RFC 2279 (<a href="http://tools.ietf.org/html/rfc2279">http://tools.ietf.org/html/rfc2279</a>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>UCS-2 is a 16-bit character encoding with no support for "higher-order" character encodings. UCS-2 is equivalent to UTF-16 in the Basic Multilingual Plane (BMP) of Unicode (the first 65536 character points, excluding the "surrogate code points" U+D800-U+DFFF, which do not map to Unicode characters). If the characters being represented are within the BMP, then UCS-2 can be thought of as "the Windows encoding" for international characters. Historically, UCS-2 was the only "wide char" representation for Windows versions prior to Windows 2000. UTF-16 was adopted instead for Windows 2000, and has been used ever since. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Most conversion routines strive for correctness at the cost of performance. The <code>glib</code> conversion routines are <em>much</em> slower than the functions implemented here because the <code>glib</code> functions first compute the number of output characters required, allocate the memory for them, and then perform the conversion, validating the input characters. The C-style methods of <code><a class="el" href="structbdlde_1_1CharConvertUcs2.html">bdlde::CharConvertUcs2</a></code>, on the other hand, assume that the user-provided output buffer is wide enough, make a "best effort" to convert into it, and return an error code if not enough space was provided. The C++-style methods are more forgiving, since the output <code>bsl::string</code> or <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;unsigned short&gt;</code> is resized as needed. No attempt is made to validate whether the character codes correspond to valid Unicode code points, nor is validation performed to check for overlong UTF-8 encodings (where characters that could be expressed in one octet are encoded using two octets). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="history_and_motivation.usage"></a> <a class="anchor" id="description.history_and_motivation.usage"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_c-style_interface"></a> <a class="anchor" id="history_and_motivation.example_1~3A_c-style_interface"></a> <a class="anchor" id="description.history_and_motivation.example_1~3A_c-style_interface"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="history_and_motivation.example_1"></a> <a class="anchor" id="description.history_and_motivation.example_1"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: C-Style Interface: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippet of code illustrates a typical use of the <code><a class="el" href="structbdlde_1_1CharConvertUcs2.html">bdlde::CharConvertUcs2</a></code> struct's C-style utility functions, converting a simple UTF-8 string to UCS-2. <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> testCFunction1()
 {
     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> buffer[256];  <span class="comment">// arbitrary &quot;wide-enough&quot; size</span>
     bsl::size_t    buffSize = <span class="keyword">sizeof</span> buffer / <span class="keyword">sizeof</span> *buffer;
     bsl::size_t    charsWritten;

     <span class="keywordtype">int</span> retVal =
               BloombergLP::bdlde::CharConvertUcs2::utf8ToUcs2(buffer,
                                                              buffSize,
                                                              <span class="stringliteral">&quot;Hello&quot;</span>,
                                                              &amp;charsWritten);

     assert( 0  == retVal);
     assert(<span class="charliteral">&#39;H&#39;</span> == buffer[0]);
     assert(<span class="charliteral">&#39;e&#39;</span> == buffer[1]);
     assert(<span class="charliteral">&#39;l&#39;</span> == buffer[2]);
     assert(<span class="charliteral">&#39;l&#39;</span> == buffer[3]);
     assert(<span class="charliteral">&#39;o&#39;</span> == buffer[4]);
     assert( 0  == buffer[5]);
     assert( 6  == charsWritten);
 }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_c-style_round-trip"></a> <a class="anchor" id="history_and_motivation.example_2~3A_c-style_round-trip"></a> <a class="anchor" id="description.history_and_motivation.example_2~3A_c-style_round-trip"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="history_and_motivation.example_2"></a> <a class="anchor" id="description.history_and_motivation.example_2"></a> <a class="anchor" id="3.1.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: C-Style Round-Trip: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippet of code illustrates another typical use of the <code><a class="el" href="structbdlde_1_1CharConvertUcs2.html">bdlde::CharConvertUcs2</a></code> struct's C-style utility functions, converting a simple UTF-8 string to UCS-2, then converting the UCS-2 back and making sure the round-trip conversion results in the input. <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> testCFunction2()
 {
     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> buffer[256];  <span class="comment">// arbitrary &quot;wide-enough&quot; size</span>
     bsl::size_t    buffSize = <span class="keyword">sizeof</span> buffer / <span class="keyword">sizeof</span> *buffer;
     bsl::size_t    charsWritten;

     <span class="comment">// &quot;&amp;Eacute;cole&quot;, the French word for School.  &#39;&amp;Eacute;&#39; is the HTML</span>
     <span class="comment">// entity equivalent to &quot;Unicode-E WITH ACUTE, LATIN CAPITAL LETTER&quot;.</span>
     <span class="keywordtype">int</span> retVal =
           BloombergLP::bdlde::CharConvertUcs2::utf8ToUcs2(buffer,
                                                          buffSize,
                                                          <span class="stringliteral">&quot;\xc3\x89&quot;</span> <span class="stringliteral">&quot;cole&quot;</span>,
                                                          &amp;charsWritten);

     assert( 0   == retVal);
     assert(0xc9 == buffer[0]); <span class="comment">// Unicode-E WITH ACUTE, LATIN CAPITAL LETTER</span>
     assert(<span class="charliteral">&#39;c&#39;</span>  == buffer[1]);
     assert(<span class="charliteral">&#39;o&#39;</span>  == buffer[2]);
     assert(<span class="charliteral">&#39;l&#39;</span>  == buffer[3]);
     assert(<span class="charliteral">&#39;e&#39;</span>  == buffer[4]);
     assert( 0   == buffer[5]);
     assert( 6   == charsWritten);

     <span class="keywordtype">char</span>           buffer2[256];  <span class="comment">// arbitrary &quot;wide-enough&quot; size</span>
     bsl::size_t    buffer2Size  = <span class="keyword">sizeof</span> buffer2 / <span class="keyword">sizeof</span> *buffer2;
     bsl::size_t    bytesWritten = 0;

     <span class="comment">// Reversing the conversion returns the original string:</span>
     retVal =
           BloombergLP::bdlde::CharConvertUcs2::ucs2ToUtf8(buffer2,
                                                          buffer2Size,
                                                          buffer,
                                                          &amp;charsWritten,
                                                          &amp;bytesWritten);

     assert( 0 == retVal);
     assert( 0 == bsl::strcmp(buffer2, <span class="stringliteral">&quot;\xc3\x89&quot;</span> <span class="stringliteral">&quot;cole&quot;</span>));

     <span class="comment">// 6 characters written, but 7 bytes, since the first character takes 2</span>
     <span class="comment">// octets.</span>

     assert( 6 == charsWritten);
     assert( 7 == bytesWritten);
 }
</pre></div><br/>
<br/>
 In this example, a UTF-8 input string is converted then passed to another function, which expects a UCS-2 buffer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a utility <em>strlen</em> replacement for UCS-2: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> wideStrlen(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> *str)
 {
     <span class="keywordtype">int</span> len = 0;

     <span class="keywordflow">while</span> (*str++) {
         ++len;
     }

     <span class="keywordflow">return</span> len;
 }
</pre></div><br/>
<br/>
 Now, some arbitrary function that calls <code>wideStrlen</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> functionRequiringUcs2(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> *str, bsl::size_t strLen)
 {
     <span class="comment">// Would probably do something more reasonable here.</span>

     assert(wideStrlen(str) + 1 == strLen);
 }
</pre></div><br/>
<br/>
 Finally, we can take some UTF-8 as an input and call <code>functionRequiringUcs2</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> processUtf8(<span class="keyword">const</span> <span class="keywordtype">char</span> *strU8)
 {
     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> buffer[1024];  <span class="comment">// some &quot;large enough&quot; size</span>
     bsl::size_t    buffSize     = <span class="keyword">sizeof</span> buffer / <span class="keyword">sizeof</span> *buffer;
     bsl::size_t    charsWritten = 0;

     <span class="keywordtype">int</span> result =
               BloombergLP::bdlde::CharConvertUcs2::utf8ToUcs2(buffer,
                                                              buffSize,
                                                              strU8,
                                                              &amp;charsWritten);

     <span class="keywordflow">if</span> (0 == result) {
         functionRequiringUcs2(buffer, charsWritten);
     }
 }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_c++-style_interface"></a> <a class="anchor" id="history_and_motivation.example_3~3A_c++-style_interface"></a> <a class="anchor" id="description.history_and_motivation.example_3~3A_c++-style_interface"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="history_and_motivation.example_3"></a> <a class="anchor" id="description.history_and_motivation.example_3"></a> <a class="anchor" id="3.1.4"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: C++-Style Interface: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippet of code illustrates a typical use of the <code><a class="el" href="structbdlde_1_1CharConvertUcs2.html">bdlde::CharConvertUcs2</a></code> struct's C++-style utility functions, converting a simple UTF-8 string to UCS-2. <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> loadUCS2Hello(<a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;unsigned short&gt;</a> *result)
 {
     <span class="keywordtype">int</span> retVal =
               BloombergLP::bdlde::CharConvertUcs2::utf8ToUcs2(result,
                                                              <span class="stringliteral">&quot;Hello&quot;</span>);

     assert( 0  == retVal);
     assert(<span class="charliteral">&#39;H&#39;</span> == (*result)[0]);
     assert(<span class="charliteral">&#39;e&#39;</span> == (*result)[1]);
     assert(<span class="charliteral">&#39;l&#39;</span> == (*result)[2]);
     assert(<span class="charliteral">&#39;l&#39;</span> == (*result)[3]);
     assert(<span class="charliteral">&#39;o&#39;</span> == (*result)[4]);
     assert( 0  == (*result)[5]);
     assert( 6  == result-&gt;<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>());
 }
</pre></div><br/>
<br/>
 The following snippet of code illustrates another typical use of the <code><a class="el" href="structbdlde_1_1CharConvertUcs2.html">bdlde::CharConvertUcs2</a></code> struct's C++-style utility functions, first converting from UTF-8 to UCS-2, and then converting back to make sure the round trip returns the same value. <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> checkCppRoundTrip()
 {
     <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;unsigned short&gt;</a> result;

     <span class="comment">// &quot;&amp;Eacute;cole&quot;, the French word for School.  &amp;Eacute; is the HTML</span>
     <span class="comment">// entity corresponding to &quot;Unicode-E WITH ACUTE, LATIN CAPITAL LETTER&quot;.</span>
     <span class="keywordtype">int</span> retVal =
           BloombergLP::bdlde::CharConvertUcs2::utf8ToUcs2(&amp;result,
                                                          <span class="stringliteral">&quot;\xc3\x89&quot;</span> <span class="stringliteral">&quot;cole&quot;</span>);

     assert( 0   == retVal);
     assert(0xc9 == result[0]); <span class="comment">// Unicode-E WITH ACUTE, LATIN CAPITAL LETTER</span>
     assert(<span class="charliteral">&#39;c&#39;</span>  == result[1]);
     assert(<span class="charliteral">&#39;o&#39;</span>  == result[2]);
     assert(<span class="charliteral">&#39;l&#39;</span>  == result[3]);
     assert(<span class="charliteral">&#39;e&#39;</span>  == result[4]);
     assert( 0   == result[5]);
     assert( 6   == result.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>());

     <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>    result2;
     bsl::size_t    charsWritten = 0;

     <span class="comment">// Reversing the conversion returns the original string:</span>
     retVal =
           BloombergLP::bdlde::CharConvertUcs2::ucs2ToUtf8(&amp;result2,
                                                          &amp;result.<a class="code" href="group__bslstl__vector.html#ga547e809dc68789a250cd367760601d78">front</a>(),
                                                          &amp;charsWritten);

     assert( 0 == retVal);
     assert( result2 == <span class="stringliteral">&quot;\xc3\x89&quot;</span> <span class="stringliteral">&quot;cole&quot;</span>);

     <span class="comment">// 6 characters written (including the null-terminator), and 6 bytes,</span>
     <span class="comment">// since the first character takes 2 octets and the null-terminator is</span>
     <span class="comment">// not counted in &quot;length()&quot;.</span>
     assert( 6 == charsWritten);
     assert( 6 == result2.length());
 }
</pre></div><br/>
<br/>
 In this example, a UTF-8 input string is converted then returned. <br/>
<br/>
<div class="fragment"><pre class="fragment"> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;unsigned short&gt;</a> processUtf8(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; strU8)
 {
     <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;unsigned short&gt;</a> result;

     <span class="keywordtype">int</span> retCode =
               BloombergLP::bdlde::CharConvertUcs2::utf8ToUcs2(&amp;result,
                                                              strU8.<a class="code" href="group__bslstl__string.html#gacef38ff51dcfc556fa13dda42a2665df">c_str</a>());

     <span class="keywordflow">return</span> result;
 }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:43 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
