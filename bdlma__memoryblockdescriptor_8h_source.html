<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlma_memoryblockdescriptor.h                                      -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLMA_MEMORYBLOCKDESCRIPTOR
#define INCLUDED_BDLMA_MEMORYBLOCKDESCRIPTOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a class describing a block of memory.
//
//@CLASSES:
//  bdlma::MemoryBlockDescriptor: describes a block of memory
//
//@SEE_ALSO: bdema_protectablememoryblockdispenser
//
//@DESCRIPTION: This component defines an in-core value-semantic class for
// describing a block of memory, namely &#39;bdlma::MemoryBlockDescriptor&#39;.  Each
// descriptor object contains the address of the block of memory and the size
// of the block.  The distinguished &quot;null&quot; descriptor contains an address and a
// size that are both 0.
//
///Usage
///-----
// This example demonstrates how to create and test the state of a
// &#39;bdlma::MemoryBlockDescriptor&#39;.
//..
//   char buffer[100];
//
//   bdlma::MemoryBlockDescriptor a(buffer, sizeof buffer);
//                               assert(!a.isNull());
//                               assert(buffer         == a.address());
//                               assert(sizeof buffer  == a.size());
//
//   bdlma::MemoryBlockDescriptor b;
//                               assert( b.isNull());
//                               assert(0              == b.address());
//                               assert(0              == b.size());
//                               assert(a              != b);
//
//   b = a;
//                               assert(!b.isNull());
//                               assert(buffer         == b.address());
//                               assert(sizeof buffer  == b.size());
//                               assert(a              == b);
//
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

namespace BloombergLP {
namespace bdlma {

                       // ===========================
                       // class MemoryBlockDescriptor
                       // ===========================

class MemoryBlockDescriptor {
    // This is an in-core value-semantic class describing the size and address
    // of a block of memory.  A null block descriptor is defined as a
    // descriptor having an address and size of 0.  The behavior is undefined
    // for a descriptor whose address is 0, but whose size if not also 0.

  public:
    // PUBLIC TYPES
    typedef bsls::Types::size_type size_type;  // type for block size

  private:
    // DATA
    void      *d_address_p;  // address of the memory block
    size_type  d_size;       // size of the block

  public:
    // CREATORS
    MemoryBlockDescriptor();
        // Create a memory block descriptor having an address and size of 0.

    MemoryBlockDescriptor(void *address, size_type size);
        // Create a memory block descriptor having the specified &#39;address&#39; and
        // &#39;size&#39;.  The behavior is undefined if &#39;address&#39; is 0 but &#39;size&#39; is
        // not also 0.

    MemoryBlockDescriptor(const MemoryBlockDescriptor&amp; original);
        // Create a memory block descriptor having the same value as the
        // specified &#39;original&#39; descriptor.  Two descriptors have the same
        // value if and only if they have the same address and size.

    // ~MemoryBlockDescriptor();
        // Destroy this memory block descriptor.  Note that this trivial
        // destructor is generated by the compiler.

    // MANIPULATORS
    MemoryBlockDescriptor&amp; operator=(const MemoryBlockDescriptor&amp; rhs);
        // Assign to this memory block descriptor the value of the specified
        // &#39;rhs&#39; descriptor and return a reference to this modifiable
        // descriptor.

    void setAddressAndSize(void *address, size_type size);
        // Set the address and size of the memory block described by this
        // object to the specified &#39;address&#39; and
        // &#39;size.  The behavior is undefined if &#39;address&#39; is 0 but &#39;size&#39; is
        // not also 0.

    // ACCESSORS
    bool isNull() const;
        // Return &#39;true&#39; if this memory block descriptor describes a null
        // memory block and &#39;false&#39; otherwise.  A null memory block has an
        // address and size of 0.

    void *address() const;
        // Return the address of the modifiable memory block described by this
        // object, or 0 if this is a null descriptor.

    size_type size() const;
        // Return the size of the memory block described by this object.

    void print() const;
        // Format the attributes of this memory block descriptor to &#39;stdout&#39; in
        // some reasonable (single-line) format.
};

// FREE OPERATORS
bool operator==(const MemoryBlockDescriptor&amp; lhs,
                const MemoryBlockDescriptor&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; memory block descriptors
    // have the same value and &#39;false&#39; otherwise.  Two descriptors have the
    // same value if and only if they have the same address and size.

bool operator!=(const MemoryBlockDescriptor&amp; lhs,
                const MemoryBlockDescriptor&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; memory block descriptors
    // do not have the same value and &#39;false&#39; otherwise.  Two descriptors
    // differ in value if they differ in either their address or size.

// ============================================================================
//                             INLINE DEFINITIONS
// ============================================================================

                       // ---------------------------
                       // class MemoryBlockDescriptor
                       // ---------------------------

// CREATORS
inline
MemoryBlockDescriptor::MemoryBlockDescriptor()
: d_address_p(0)
, d_size(0)
{
}

inline
MemoryBlockDescriptor::MemoryBlockDescriptor(void      *address,
                                             size_type  size)
: d_address_p(address)
, d_size(size)
{
    BSLS_ASSERT_SAFE(address || 0 == size);
}

inline
MemoryBlockDescriptor::MemoryBlockDescriptor(
                                         const MemoryBlockDescriptor&amp; original)
: d_address_p(original.d_address_p)
, d_size(original.d_size)
{
}

// MANIPULATORS
inline
MemoryBlockDescriptor&amp; MemoryBlockDescriptor::operator=(
                                              const MemoryBlockDescriptor&amp; rhs)
{
    d_address_p = rhs.d_address_p;
    d_size      = rhs.d_size;

    return *this;
}

inline
void MemoryBlockDescriptor::setAddressAndSize(void *address, size_type size)
{
    BSLS_ASSERT_SAFE(address || 0 == size);

    d_address_p = address;
    d_size      = size;
}

// ACCESSORS
inline
void *MemoryBlockDescriptor::address() const
{
    return d_address_p;
}

inline
MemoryBlockDescriptor::size_type
MemoryBlockDescriptor::size() const
{
    return d_size;
}

inline
bool MemoryBlockDescriptor::isNull() const
{
    return 0 == d_address_p;
}

}  // close package namespace

// FREE OPERATORS
inline
bool bdlma::operator==(const MemoryBlockDescriptor&amp; lhs,
                       const MemoryBlockDescriptor&amp; rhs)
{
    return lhs.address() == rhs.address() &amp;&amp; lhs.size() == rhs.size();
}

inline
bool bdlma::operator!=(const MemoryBlockDescriptor&amp; lhs,
                       const MemoryBlockDescriptor&amp; rhs)
{
    return !(lhs == rhs);
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
