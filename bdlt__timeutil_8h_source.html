<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlt_timeutil.h                                                    -*-C++-*-
#ifndef INCLUDED_BDLT_TIMEUTIL
#define INCLUDED_BDLT_TIMEUTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide common non-primitive operations on &#39;bdlt::Time&#39;.
//
//@CLASSES:
//  bdlt::TimeUtil: namespace for static functions operating on &#39;bdlt::Time&#39;
//
//@SEE_ALSO: bdlt_time
//
//@DESCRIPTION: This component provides non-primitive operations on
// &#39;bdlt::Time&#39; objects.  In particular, the &#39;bdlt::TimeUtil&#39; namespace defined
// in this component provides conversions among &#39;bdlt::Time&#39; values and their
// corresponding non-negative integral values (e.g., &#39;convertFromHHMM&#39;,
// &#39;convertToHHMMSSmmm&#39;), and methods to validate such integral values (e.g.,
// &#39;isValidHHMMSS&#39;) before passing them to the corresponding &quot;convertFrom&quot;
// method.
//
///Usage
///------
// Following are examples illustrating basic use of this component.
//
///Example 1
///- - - - -
// First, we demonstrate how to use &#39;bdlt::TimeUtil&#39; to
// convert from an integer representation of time in &quot;HHMMSSmmm&quot; format to a
// &#39;bdlt::Time&#39;.  Our first time will be around 3:45 pm.
//..
//  //      format: HHMMSSmmm
//  int timeValue = 154502789;
//
//  bdlt::Time result = bdlt::TimeUtil::convertFromHHMMSSmmm(timeValue);
//
//  bsl::cout &lt;&lt; result &lt;&lt; bsl::endl;
//..
// The code above produces the following on &#39;stdout&#39;:
//..
//  15:45:02.789
//..
// Then, we demonstrate a different time, 3:32:24.832 am.  Note that we do not
// lead the integer value with &#39;0&#39;:
//..
//  //  format: HHMMSSmmm
//  timeValue =  33224832;      // Do not start with leading &#39;0&#39; as that would
//                              // make the value octal and incorrect.
//
//  result = bdlt::TimeUtil::convertFromHHMMSSmmm(timeValue);
//
//  bsl::cout &lt;&lt; result &lt;&lt; bsl::endl;
//..
// The code above produces the following on &#39;stdout&#39;:
//..
//  03:32:24.832
//..
// Now, we demonstrate how &#39;bdlt::TimeUtil&#39; provides methods that can be used
// to validate integral time values before passing them to the various
// &quot;convert&quot; methods.  For example:
//..
//  assert( bdlt::TimeUtil::isValidHHMMSSmmm(timeValue));
//..
// Finally, we demonstrate catching an invalid time value, 12:61:02.789 pm:
//..
//  //         format: HHMMSSmmm
//  int badTimeValue = 126102789;
//
//  assert(!bdlt::TimeUtil::isValidHHMMSSmmm(badTimeValue));
//..
//
///Example 2
///- - - - -
// The following snippet of code demonstrates how to use &#39;bdlt::TimeUtil&#39; to
// convert from a &#39;bdlt::Time&#39; to an integer representation of time in &quot;HHMM&quot;,
// &quot;HHMMSS&quot;, and &quot;HHMMSSmmm&quot; formats:
//..
//  bdlt::Time time(12, 45, 2, 789);
//  int        timeHHMM      = bdlt::TimeUtil::convertToHHMM(time);
//  int        timeHHMMSS    = bdlt::TimeUtil::convertToHHMMSS(time);
//  int        timeHHMMSSmmm = bdlt::TimeUtil::convertToHHMMSSmmm(time);
//
//  bsl::cout &lt;&lt; &quot;Time in HHMM:      &quot; &lt;&lt; timeHHMM      &lt;&lt; bsl::endl;
//  bsl::cout &lt;&lt; &quot;Time in HHMMSS:    &quot; &lt;&lt; timeHHMMSS    &lt;&lt; bsl::endl;
//  bsl::cout &lt;&lt; &quot;Time in HHMMSSmmm: &quot; &lt;&lt; timeHHMMSSmmm &lt;&lt; bsl::endl;
//..
// The code above produces the following on &#39;stdout&#39;:
//..
//  Time in HHMM:      1245
//  Time in HHMMSS:    124502
//  Time in HHMMSSmmm: 124502789
//..
// Note that the millisecond and/or second fields of &#39;bdlt::Time&#39; are ignored
// depending on the conversion method that is called.

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLT_TIME
#include &lt;bdlt_time.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

namespace BloombergLP {
namespace bdlt {

                                // ===============
                                // struct TimeUtil
                                // ===============

struct TimeUtil {
    // This &#39;struct&#39; provides a namespace for common non-primitive procedures
    // that operate on &#39;Time&#39; objects.  These methods are alias-safe and
    // exception-neutral.

  private:
    // PRIVATE TYPES
    enum {
        k_HHMMSSMMM_HH_FACTOR = 10000000,
        k_HHMMSSMMM_MM_FACTOR =   100000,
        k_HHMMSSMMM_SS_FACTOR =     1000,

        k_HHMMSS_HH_FACTOR    =    10000,
        k_HHMMSS_MM_FACTOR    =      100,

        k_HHMM_HH_FACTOR      =      100
    };

  public:
    // CLASS METHODS
    static Time convertFromHHMM(int timeValue);
        // Return the &#39;bdlt::Time&#39; value corresponding to the specified
        // &#39;timeValue&#39;, where &#39;timeValue&#39; is a non-negative integer that, when
        // expressed in decimal notation, contains exactly four digits
        // (counting leading zeros, if any): two digits for the hour and two
        // digits for the minute.  For example, 309 is converted to
        // &#39;Time(3, 9)&#39; (03:09:00.000).  More formally, &#39;timeValue&#39; is
        // interpreted as:
        //..
        //  hour * 100 + minute
        //..
        // The behavior is undefined unless &#39;timeValue&#39; represents a valid time
        // in the allowable range for &#39;bdlt::Time&#39;
        // (00:00:00.000 - 23:59:00.000, and 24:00:00.000).

    static Time convertFromHHMMSS(int timeValue);
        // Return the &#39;bdlt::Time&#39; value corresponding to the specified
        // &#39;timeValue&#39;, where &#39;timeValue&#39; is a non-negative integer that, when
        // expressed in decimal notation, contains exactly six digits (counting
        // leading zeros, if any): two digits for the hour, two digits for the
        // minute, and two digits for the second.  For example, 30907 is
        // converted to &#39;Time(3, 9, 7)&#39; (03:09:07.000).  More formally,
        // &#39;timeValue&#39; is interpreted as:
        //..
        //  hour * 10000 + minute * 100 + second
        //..
        // The behavior is undefined unless &#39;timeValue&#39; represents a valid time
        // in the allowable range for &#39;bdlt::Time&#39;
        // (00:00:00.000 - 23:59:59.000, and 24:00:00.000).

    static Time convertFromHHMMSSmmm(int timeValue);
        // Return the &#39;bdlt::Time&#39; value corresponding to the specified
        // &#39;timeValue&#39;, where &#39;timeValue&#39; is a non-negative integer that, when
        // expressed in decimal notation, contains exactly nine digits
        // (counting leading zeros, if any): two digits for the hour, two
        // digits for the minute, two digits for the second, and three digits
        // for the millisecond.  For example, 30907056 is converted to
        // &#39;Time(3, 9, 7, 56)&#39; (03:09:07.056).  More formally, &#39;timeValue&#39; is
        // interpreted as:
        //..
        //  hour * 10000000 + minute * 100000 + second * 1000 + millisecond
        //..
        // The behavior is undefined unless &#39;timeValue&#39; represents a valid time
        // in the allowable range for &#39;bdlt::Time&#39;
        // (00:00:00.000 - 23:59:59.999, and 24:00:00.000).

    static int convertToHHMM(const Time&amp; value);
        // Return the non-negative integer representing the same time as the
        // specified &#39;value&#39; that, when expressed in decimal notation, contains
        // exactly four digits (counting leading zeros, if any): two digits for
        // the hour and two digits for the minute.  For example,
        // &#39;Time(3, 9, sec, ms)&#39;, where &#39;0 &lt;= sec &lt; 60&#39; and &#39;0 &lt;= ms &lt; 1000&#39;,
        // is converted to 309.  More formally, this method returns:
        //..
        //  value.hour() * 100 + value.minute()
        //..

    static int convertToHHMMSS(const Time&amp; value);
        // Return the non-negative integer representing the same time as the
        // specified &#39;value&#39; that, when expressed in decimal notation, contains
        // exactly six digits (counting leading zeros, if any): two digits for
        // the hour, two digits for the minute, and two digits for the second.
        // For example, &#39;Time(3, 9, 7, ms)&#39;, where &#39;0 &lt;= ms &lt; 1000&#39;, is
        // converted to 30907.  More formally, this method returns:
        //..
        //  value.hour() * 10000 + value.minute() * 100 + value.second()
        //..

    static int convertToHHMMSSmmm(const Time&amp; value);
        // Return the non-negative integer representing the same time as the
        // specified &#39;value&#39; that, when expressed in decimal notation, contains
        // exactly nine digits (counting leading zeros, if any): two digits for
        // the hour, two digits for the minute, two digits for the second, and
        // three digits for the millisecond.  For example, &#39;Time(3, 9, 7, 56)&#39;
        // is converted to 30907056.  More formally, this method returns:
        //..
        //  value.hour() * 10000000 + value.minute() * 100000
        //                          + value.second() * 1000
        //                          + value.millisecond()
        //..

    static bool isValidHHMM(int timeValue);
        // Return &#39;true&#39; if the specified &#39;timeValue&#39; is a non-negative integer
        // that represents a valid four-digit time value suitable for passing
        // to &#39;convertFromHHMM&#39;, and &#39;false&#39; otherwise.  &#39;timeValue&#39; is a valid
        // four-digit time value if, when expressed in decimal notation, it
        // contains exactly four digits (counting leading zeros, if any): two
        // digits for the hour and two digits for the minute, where either
        // &#39;0 &lt;= hour &lt; 24&#39; and &#39;0 &lt;= minute &lt; 60&#39;, or &#39;2400 == timeValue&#39;.

    static bool isValidHHMMSS(int timeValue);
        // Return &#39;true&#39; if the specified &#39;timeValue&#39; is a non-negative integer
        // that represents a valid six-digit time value suitable for passing to
        // &#39;convertFromHHMMSS&#39;, and &#39;false&#39; otherwise.  &#39;timeValue&#39; is a valid
        // six-digit time value if, when expressed in decimal notation, it
        // contains exactly six digits (counting leading zeros, if any): two
        // digits for the hour, two digits for the minute, and two digits for
        // the second, where either &#39;0 &lt;= hour &lt; 24&#39;, &#39;0 &lt;= minute &lt; 60&#39;, and
        // &#39;0 &lt;= second &lt; 60&#39;, or &#39;240000 == timeValue&#39;.

    static bool isValidHHMMSSmmm(int timeValue);
        // Return &#39;true&#39; if the specified &#39;timeValue&#39; is a non-negative integer
        // that represents a valid nine-digit time value suitable for passing
        // to &#39;convertFromHHMMSSmmm&#39;, and &#39;false&#39; otherwise.  &#39;timeValue&#39; is a
        // valid nine-digit time value if, when expressed in decimal notation,
        // it contains exactly nine digits (counting leading zeros, if any):
        // two digits for the hour, two digits for the minute, two digits for
        // the second, and three digits for the millisecond, where either
        // &#39;0 &lt;= hour &lt; 24&#39;, &#39;0 &lt;= minute &lt; 60&#39;, &#39;0 &lt;= second &lt; 60&#39;, and
        // &#39;0 &lt;= millisecond &lt; 1000&#39;, or &#39;240000000 == timeValue&#39;.
};

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

                               // ---------------
                               // struct TimeUtil
                               // ---------------

                              // -----------------
                              // Level-0 Functions
                              // -----------------

// CLASS METHODS
inline
bool TimeUtil::isValidHHMM(int timeValue)
{
    return Time::isValid(timeValue / k_HHMM_HH_FACTOR,
                         timeValue % k_HHMM_HH_FACTOR);
}

inline
bool TimeUtil::isValidHHMMSS(int timeValue)
{
    return Time::isValid(timeValue / k_HHMMSS_HH_FACTOR,
                        (timeValue % k_HHMMSS_HH_FACTOR) / k_HHMMSS_MM_FACTOR,
                         timeValue % k_HHMMSS_MM_FACTOR);
}

inline
bool TimeUtil::isValidHHMMSSmmm(int timeValue)
{
    return Time::isValid(
                    timeValue / k_HHMMSSMMM_HH_FACTOR,
                   (timeValue % k_HHMMSSMMM_HH_FACTOR) / k_HHMMSSMMM_MM_FACTOR,
                   (timeValue % k_HHMMSSMMM_MM_FACTOR) / k_HHMMSSMMM_SS_FACTOR,
                    timeValue % k_HHMMSSMMM_SS_FACTOR);
}

                            // -------------------
                            // All Other Functions
                            // -------------------

inline
Time TimeUtil::convertFromHHMM(int timeValue)
{
    BSLS_ASSERT_SAFE(TimeUtil::isValidHHMM(timeValue));

    return Time(timeValue / k_HHMM_HH_FACTOR,
                timeValue % k_HHMM_HH_FACTOR);
}

inline
Time TimeUtil::convertFromHHMMSS(int timeValue)
{
    BSLS_ASSERT_SAFE(TimeUtil::isValidHHMMSS(timeValue));

    return Time(timeValue / k_HHMMSS_HH_FACTOR,
               (timeValue % k_HHMMSS_HH_FACTOR) / k_HHMMSS_MM_FACTOR,
                timeValue % k_HHMMSS_MM_FACTOR);
}

inline
Time TimeUtil::convertFromHHMMSSmmm(int timeValue)
{
    BSLS_ASSERT_SAFE(TimeUtil::isValidHHMMSSmmm(timeValue));

    return Time(timeValue / k_HHMMSSMMM_HH_FACTOR,
               (timeValue % k_HHMMSSMMM_HH_FACTOR) / k_HHMMSSMMM_MM_FACTOR,
               (timeValue % k_HHMMSSMMM_MM_FACTOR) / k_HHMMSSMMM_SS_FACTOR,
                timeValue % k_HHMMSSMMM_SS_FACTOR);
}

inline
int TimeUtil::convertToHHMM(const Time&amp; value)
{
    return value.hour() * k_HHMM_HH_FACTOR + value.minute();
}

inline
int TimeUtil::convertToHHMMSS(const Time&amp; value)
{
    return value.hour()   * k_HHMMSS_HH_FACTOR
         + value.minute() * k_HHMMSS_MM_FACTOR
         + value.second();
}

inline
int TimeUtil::convertToHHMMSSmmm(const Time&amp; value)
{
    return value.hour()   * k_HHMMSSMMM_HH_FACTOR
         + value.minute() * k_HHMMSSMMM_MM_FACTOR
         + value.second() * k_HHMMSSMMM_SS_FACTOR
         + value.millisecond();
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
