<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlde_quotedprintableencoder Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlde_quotedprintableencoder<br/>
<small>
[<a class="el" href="group__bdlde.html">Package bdlde</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide automata converting to and from Quoted-Printable encodings.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlde.html">bdlde</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Quoted-Printable Encoding</a> <ul>
<li>
<a href="#3.1.1">General 8-Bit Representation</a> </li>
<li>
<a href="#3.1.2">Literal Representation</a> </li>
<li>
<a href="#3.1.3">Whitespace</a> </li>
<li>
<a href="#3.1.4">Line Breaks</a> </li>
<li>
<a href="#3.1.5">Soft Line Breaks</a> </li>
<li>
<a href="#3.1.6">Example 1</a> </li>
<li>
<a href="#3.1.7">Example 2</a> </li>
</ul>
</li>
<li>
<a href="#3.2">Quoted-Printable Decoding</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Encoding</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide automata converting to and from Quoted-Printable encodings. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlde_1_1QuotedPrintableEncoder.html">bdlde::QuotedPrintableEncoder</a> </td><td>automaton for Quoted-Printable encoding  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><code><a class="el" href="classbdlde_1_1QuotedPrintableDecoder.html">bdlde::QuotedPrintableDecoder</a></code> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a class that can be used to encode byte sequences of arbitrary length into the Quoted Printable representation described in Section 6.7 "Quoted-Printable Content Transfer Encoding" of RFC 2045, "Multipurpose Internet Mail Extensions (MIME) Part One: Format of
 Internet Message Bodies." </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Each instance of the encoder retains the state of the conversion from one supplied input to the next, enabling the processing of segmented input -- i.e., processing resumes where it left off with the next invocation on new input. Instance methods are provided for the encoder to (1) assert the end of input, (2) determine whether the input so far is currently acceptable, and (3) indicate whether a non-recoverable error has occurred. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="quoted-printable_encoding"></a> <a class="anchor" id="description.quoted-printable_encoding"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Quoted-Printable Encoding: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This encoding scheme is suitable for encoding arbitrary data consisting primarily of printable text characters. Additionally, this scheme seeks to preserve the integrity of the byte stream during transfer by making it difficult for any intermediate interpreting software in the path of the transfer to disruptively change its content (e.g., because of trailing whitespace and line breaks). For binary data, Base64 encoding may be a more appropriate scheme (see <code>bdede_base64</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The data stream is processed one byte at a time from left to right as follows: </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="general_8-bit_representation"></a> <a class="anchor" id="quoted-printable_encoding.general_8-bit_representation"></a> <a class="anchor" id="description.quoted-printable_encoding.general_8-bit_representation"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>General 8-Bit Representation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Any 8-bit input character, except a CR or LF, <em>may</em> be represented by an "=" followed by a 2-digit hexadecimal representation of its ASCII value. Only uppercase hexadecimal digits are allowed. For example, the letter <code>n</code> can be encoded into <code>=6E</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="literal_representation"></a> <a class="anchor" id="quoted-printable_encoding.literal_representation"></a> <a class="anchor" id="description.quoted-printable_encoding.literal_representation"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Literal Representation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Characters with decimal values in the range [33..126], with the exception of 61 (<code>=</code>), <em>may</em> be represented literally as they appear before encoding. Hence, in addition to [0-9][a-z][A-Z], the following characters may propagate to the encoded stream unchanged. <br/>
<br/>
<div class="fragment"><pre class="fragment"> [!<span class="stringliteral">&quot;#$%&amp;&#39;()*+,-./:;&lt;&gt;?@[\]^_`{|}~]</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="whitespace"></a> <a class="anchor" id="quoted-printable_encoding.whitespace"></a> <a class="anchor" id="description.quoted-printable_encoding.whitespace"></a> <a class="anchor" id="3.1.3"></a> </dd></dl>
<dl class="user"><dt><b>Whitespace: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Space and tab <em>may</em> be represented literally, unless they appear at the end of an encoded line, in which case they must be followed by a <code>=</code> character serving as a soft line break (see rule #5), or they must be encoded according to rule #1. It follows that any trailing whitespace encountered in a Quoted-Printable body must necessarily be added by intermediate transport agents and must be deleted during decoding. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="line_breaks"></a> <a class="anchor" id="quoted-printable_encoding.line_breaks"></a> <a class="anchor" id="description.quoted-printable_encoding.line_breaks"></a> <a class="anchor" id="3.1.4"></a> </dd></dl>
<dl class="user"><dt><b>Line Breaks: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A line break must be represented in the Quoted-Printable encoding as in rule number 1, i.e., LF -&gt; =0A; CR -&gt; =0D. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="soft_line_breaks"></a> <a class="anchor" id="quoted-printable_encoding.soft_line_breaks"></a> <a class="anchor" id="description.quoted-printable_encoding.soft_line_breaks"></a> <a class="anchor" id="3.1.5"></a> </dd></dl>
<dl class="user"><dt><b>Soft Line Breaks: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Encoded lines are required to be no longer than 76 characters in this encoding scheme. Soft line breaks in the form of an <code>=</code> sign placed at the end of an encoded line are used to break up longer lines, either necessarily when the number of encoded characters, including any <code>=</code> characters but not counting the trailing CRLF, reaches the limit of 76, or at the user's discretion -- e.g., during manual encoding. Soft line breaks are to be removed during decoding as they are not part of the original content. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The Quoted-Printable encoding scheme allows one or two forms of encoding depending on the value of the character to be encoded as well as its location with respect to the end of line. When both forms are permissible, the choice is discretionary. For example, the word <code>From</code> is often used as a message separator in the standard UNIX mail folder format. To reduce the chance of a message getting broken, a sentence such as "From point A
 to ..." is often best encoded as "=46rom point A to ...", although "From
 point A to ..." is also a valid encoding. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This implementation by default prefers literal encoding to Quoted-Printable encoding. In the case of a space or tab character happening at the end of an encoded line, if there is more input to follow, a soft line break is inserted; otherwise, the last line of encoding should be terminated with the Quoted Printable encoding of space or tab (a line break is both redundant and contrived). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In situations where it is desirable to specify certain characters to be encoded to their numeric form, the encoder in this implementation also offers a means to specify these characters through the first parameter to the following constructor <br/>
<br/>
<div class="fragment"><pre class="fragment">   <a class="code" href="classbdlde_1_1QuotedPrintableEncoder.html">bdlde::QuotedPrintableEncoder</a>(
      <span class="keyword">const</span> <span class="keywordtype">char</span> *extraCharsToEncode,
      <a class="code" href="classbdlde_1_1QuotedPrintableEncoder.html#a97597d58c5fa884f5d40eaa682adffc3">bdlde::QuotedPrintableEncoder::LineBreakMode</a> lineBreakMode
                        = bdlde::QuotedPrintableEncoder::BDEDE_CRLF_MODE,
      <span class="keywordtype">int</span> maxLineLength =
                         bdlde::QuotedPrintableEncoder::DEFAULT_MAX_LINELEN);
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following examples demonstrate the above rules per the design choices made for this implementation. Note that there is a hard line break at the 77th character position, immediately after "dozing". </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="quoted-printable_encoding.example_1"></a> <a class="anchor" id="description.quoted-printable_encoding.example_1"></a> <a class="anchor" id="3.1.6"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Data: <br/>
<br/>
<div class="fragment"><pre class="fragment"> From point A to point B, the distance is 1245.56 miles.  Driving at a dozing
 speed of 15mph, it will take 2 hours to complete the trip.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Encoding: <br/>
<br/>
<div class="fragment"><pre class="fragment"> =46rom point A to point B, the distance is 1245.56 miles.  Driving at a doz=
 ing=0D=0A speed of 15mph, =
 it will take 2 hours=
 to complete the trip.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2"></a> <a class="anchor" id="quoted-printable_encoding.example_2"></a> <a class="anchor" id="description.quoted-printable_encoding.example_2"></a> <a class="anchor" id="3.1.7"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Data: <br/>
<br/>
<div class="fragment"><pre class="fragment"> Hello, world.
</pre></div><br/>
<br/>
 (The last line of input ends with a whitespace.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Encoding: <br/>
<br/>
<div class="fragment"><pre class="fragment"> Hello, world.=20
</pre></div><br/>
<br/>
 (In this case, a Quoted Printable is preferred to soft line break as there should only be one encoded line.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The above encoding is acceptable, although it is by no means unique. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="quoted-printable_decoding"></a> <a class="anchor" id="description.quoted-printable_decoding"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Quoted-Printable Decoding: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>(In the following, all rules mentioned refer to those listed in the encoder section above.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The decoding process for this encoding scheme involves: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
transforming any encoded character triplets back into their original representation (rule #1 and rule #4).  </li>
<li>
literally writing out characters that have not been changed (rule #2).  </li>
<li>
deleting any trailing whitespace at the end of an encoded line (rule #3).  </li>
<li>
removing the soft line breaks including the <code>=</code> prefix (i.e., concatenating broken sentences) (rule #5).  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The standard imposes a maximum of 76 characters exclusive of CRLF; however, the decoder implemented in this component will handle lines of arbitrary length. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The decoder also provides support for two error-reporting modes, configurable at construction: the strict mode and the relaxed mode. A strict-mode decoder stops decoding at the first offending character encountered, while a relaxed-mode decoder continues decoding to the end of the input, allowing straight pass-through of character sets that cannot be interpreted. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_encoding"></a> <a class="anchor" id="usage.example_1~3A_encoding"></a> <a class="anchor" id="description.usage.example_1~3A_encoding"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Encoding: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example shows how to use a <code><a class="el" href="classbdlde_1_1QuotedPrintableEncoder.html">bdlde::QuotedPrintableEncoder</a></code> object to implement a function, <code>streamconverter</code>, that reads text from a <code>bsl::istream</code>, encodes that text in Quoted-Printable representation, and write928s the encoded text to a <code>bsl::ostream</code>. <code>streamconverter</code> returns 0 on success, and a negative value if the input data could not be successfully encoded or if there is an I/O error. <br/>
<br/>
<div class="fragment"><pre class="fragment"> streamconverter.h                    -*-C++-*-

 <span class="keywordtype">int</span> streamconverter(bsl::ostream&amp; os, bsl::istream&amp; is);
 Read the entire contents of the specified input stream <span class="stringliteral">&#39;is&#39;</span>, convert
 the input plain text to quoted-printable encoding, and write the
 encoded text to the specified output stream <span class="stringliteral">&#39;os&#39;</span>.  Return 0 on
 success, and a negative value otherwise.
</pre></div><br/>
<br/>
 We will use fixed-sized input and output buffers in the implementation, but, because of the flexibility of <code>bsl::istream</code> and the output-buffer monitoring functionality of <code>QuotedPrintableEncoder</code>, the fixed buffer sizes do <em>not</em> limit the quantity of data that can be read, encoded, or written to the output stream. The implementation file is as follows. <br/>
<br/>
<div class="fragment"><pre class="fragment"> streamconverter.cpp                  -*-C++-*-

<span class="preprocessor"> #include &lt;streamconverter.h&gt;</span>

<span class="preprocessor"> #include &lt;<a class="code" href="bdlde__quotedprintableencoder_8h.html" title="Provide automata converting to and from Quoted-Printable encodings.">bdlde_quotedprintableencoder.h</a>&gt;</span>

 <span class="keyword">namespace </span>BloombergLP {

 <span class="keywordtype">int</span> streamconverter(bsl::ostream&amp; os, bsl::istream&amp; is)
 {
     <span class="keyword">enum</span> {
         SUCCESS      =  0,
         ENCODE_ERROR = -1,
         IO_ERROR     = -2
     };
</pre></div><br/>
<br/>
 We declare a <code><a class="el" href="classbdlde_1_1QuotedPrintableEncoder.html">bdlde::QuotedPrintableEncoder</a></code> object <code>converter</code>, which will encode the input data. Note that various internal buffers and cursors are used as needed without further comment. We read as much data as is available from the user-supplied input stream <code>is</code> <em>or</em> as much as will fit in <code>inputBuffer</code> before beginning conversion. <br/>
<br/>
<div class="fragment"><pre class="fragment">     <a class="code" href="classbdlde_1_1QuotedPrintableEncoder.html">bdlde::QuotedPrintableEncoder</a> converter;

     <span class="keyword">const</span> <span class="keywordtype">int</span> INBUFFER_SIZE  = 1 &lt;&lt; 10;
     <span class="keyword">const</span> <span class="keywordtype">int</span> OUTBUFFER_SIZE = 1 &lt;&lt; 10;

     <span class="keywordtype">char</span> inputBuffer[INBUFFER_SIZE];
     <span class="keywordtype">char</span> outputBuffer[OUTBUFFER_SIZE];

     <span class="keywordtype">char</span> *output    = outputBuffer;
     <span class="keywordtype">char</span> *outputEnd = outputBuffer + <span class="keyword">sizeof</span> outputBuffer;

     <span class="keywordflow">while</span> (is.good()) {  <span class="comment">// input stream not exhausted</span>

         is.read(inputBuffer, <span class="keyword">sizeof</span> inputBuffer);
</pre></div><br/>
<br/>
 With <code>inputBuffer</code> now populated, we'll use <code>converter</code> in an inner <code>while</code> loop to encode the input and write the encoded data to <code>outputBuffer</code> (via the <code>output</code> cursor'). Note that if the call to <code>converter.convert</code> fails, our function terminates with a negative status. <br/>
<br/>
<div class="fragment"><pre class="fragment">         <span class="keyword">const</span> <span class="keywordtype">char</span> *input    = inputBuffer;
         <span class="keyword">const</span> <span class="keywordtype">char</span> *inputEnd = input + is.gcount();

         <span class="keywordflow">while</span> (input &lt; inputEnd) { <span class="comment">// input encoding not complete</span>

             <span class="keywordtype">int</span> numOut;
             <span class="keywordtype">int</span> numIn;

             <span class="keywordtype">int</span> status = converter.<a class="code" href="classbdlde_1_1QuotedPrintableEncoder.html#aacfe62dcd0a8acb7fca70898df66fc9f">convert</a>(output, &amp;numOut, &amp;numIn,
                                            input,   inputEnd,
                                            outputEnd - output);
             <span class="keywordflow">if</span> (status &lt; 0) {
                 <span class="keywordflow">return</span> ENCODE_ERROR;                               <span class="comment">// RETURN</span>
             }
</pre></div><br/>
<br/>
 If the call to <code>converter.convert</code> returns successfully, we'll see if the output buffer is full, and if so, write its contents to the user-supplied output stream <code>os</code>. Note how we use the values of <code>numOut</code> and <code>numIn</code> generated by <code>convert</code> to update the relevant cursors. <br/>
<br/>
<div class="fragment"><pre class="fragment">             output += numOut;
             input  += numIn;

             <span class="keywordflow">if</span> (output == outputEnd) {  <span class="comment">// output buffer full; write data</span>
                 os.write (outputBuffer, <span class="keyword">sizeof</span> outputBuffer);
                 <span class="keywordflow">if</span> (os.fail()) {
                     <span class="keywordflow">return</span> IO_ERROR;                               <span class="comment">// RETURN</span>
                 }
                 output = outputBuffer;
             }
         }
     }
</pre></div><br/>
<br/>
 We have now exited both the input and the "encode" loops. <code>converter</code> may still hold encoded output characters, and so we call <code>converter.endConvert</code> to emit any retained output. To guarantee correct behavior, we call this method in an infinite loop, because it is possible that the retained output can fill the output buffer. In that case, we solve the problem by writing the contents of the output buffer to <code>os</code> within the loop. The most likely case, however, is that <code>endConvert</code> will return 0, in which case we exit the loop and write any data remaining in <code>outputBuffer</code> to <code>os</code>. As above, if <code>endConvert</code> fails, we exit the function with a negative return status. <br/>
<br/>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span> (;;) {

         <span class="keywordtype">int</span> more =
                   converter.<a class="code" href="classbdlde_1_1QuotedPrintableEncoder.html#a17be781404b44ad0fa6ba19b3dd0f1fd">endConvert</a>(output, &amp;numOut, outputEnd - output);
         <span class="keywordflow">if</span> (more &lt; 0) {
             <span class="keywordflow">return</span> ENCODE_ERROR;                                   <span class="comment">// RETURN</span>
         }

         output += numOut;

         <span class="keywordflow">if</span> (!more) { <span class="comment">// no more output</span>
             <span class="keywordflow">break</span>;
         }

         assert (output == outputEnd);  <span class="comment">// output buffer is full</span>

         os.write (outputBuffer, <span class="keyword">sizeof</span> outputBuffer);  <span class="comment">// write buffer</span>
         <span class="keywordflow">if</span> (os.fail()) {
             <span class="keywordflow">return</span> IO_ERROR;                                       <span class="comment">// RETURN</span>
         }
         output = outputBuffer;
     }

     <span class="keywordflow">if</span> (output &gt; outputBuffer) { <span class="comment">// still data in output buffer; write it</span>
 all
         os.write(outputBuffer, output - outputBuffer);
     }

     <span class="keywordflow">return</span> is.eof() &amp;&amp; os.good() ? SUCCESS : IO_ERROR;
 }

 } <span class="comment">// Close namespace BloombergLP</span>
</pre></div><br/>
<br/>
 For ease of reading, we repeat the full content of the <code>streamconverter.cpp</code> file without interruption. <br/>
<br/>
<div class="fragment"><pre class="fragment"> streamconverter.cpp                  -*-C++-*-

<span class="preprocessor"> #include &lt;streamconverter.h&gt;</span>

<span class="preprocessor"> #include &lt;<a class="code" href="bdlde__quotedprintableencoder_8h.html" title="Provide automata converting to and from Quoted-Printable encodings.">bdlde_quotedprintableencoder.h</a>&gt;</span>

 <span class="keyword">namespace </span>BloombergLP {

 <span class="keywordtype">int</span> streamconverter(bsl::ostream&amp; os, bsl::istream&amp; is)
 {
     <span class="keyword">enum</span> {
         SUCCESS      =  0,
         ENCODE_ERROR = -1,
         IO_ERROR     = -2
     };

     <a class="code" href="classbdlde_1_1QuotedPrintableEncoder.html">bdlde::QuotedPrintableEncoder</a> converter;

     <span class="keyword">const</span> <span class="keywordtype">int</span> INBUFFER_SIZE  = 1 &lt;&lt; 10;
     <span class="keyword">const</span> <span class="keywordtype">int</span> OUTBUFFER_SIZE = 1 &lt;&lt; 10;

     <span class="keywordtype">char</span> inputBuffer[INBUFFER_SIZE];
     <span class="keywordtype">char</span> outputBuffer[OUTBUFFER_SIZE];

     <span class="keywordtype">char</span> *output    = outputBuffer;
     <span class="keywordtype">char</span> *outputEnd = outputBuffer + <span class="keyword">sizeof</span> outputBuffer;

     <span class="keywordflow">while</span> (is.good()) {  <span class="comment">// input stream not exhausted</span>

         is.read(inputBuffer, <span class="keyword">sizeof</span> inputBuffer);

         <span class="keyword">const</span> <span class="keywordtype">char</span> *input    = inputBuffer;
         <span class="keyword">const</span> <span class="keywordtype">char</span> *inputEnd = input + is.gcount();

         <span class="keywordflow">while</span> (input &lt; inputEnd) { <span class="comment">// input encoding not complete</span>

             <span class="keywordtype">int</span> numOut;
             <span class="keywordtype">int</span> numIn;

             <span class="keywordtype">int</span> status = converter.<a class="code" href="classbdlde_1_1QuotedPrintableEncoder.html#aacfe62dcd0a8acb7fca70898df66fc9f">convert</a>(output, &amp;numOut, &amp;numIn,
                                            input,   inputEnd,
                                            outputEnd - output);
             <span class="keywordflow">if</span> (status &lt; 0) {
                 <span class="keywordflow">return</span> ENCODE_ERROR;                               <span class="comment">// RETURN</span>
             }

             output += numOut;
             input  += numIn;

             <span class="keywordflow">if</span> (output == outputEnd) {  <span class="comment">// output buffer full; write data</span>
                 os.write(outputBuffer, <span class="keyword">sizeof</span> outputBuffer);
                 <span class="keywordflow">if</span> (os.fail()) {
                     <span class="keywordflow">return</span> IO_ERROR;                               <span class="comment">// RETURN</span>
                 }
                 output = outputBuffer;
             }
         }
     }

     <span class="keywordflow">for</span> (;;) {

         <span class="keywordtype">int</span> more =
                   converter.<a class="code" href="classbdlde_1_1QuotedPrintableEncoder.html#a17be781404b44ad0fa6ba19b3dd0f1fd">endConvert</a>(output, &amp;numOut, outputEnd - output);
         <span class="keywordflow">if</span> (more &lt; 0) {
             <span class="keywordflow">return</span> ENCODE_ERROR;                                   <span class="comment">// RETURN</span>
         }

         output += numOut;

         <span class="keywordflow">if</span> (!more) { <span class="comment">// no more output</span>
             <span class="keywordflow">break</span>;
         }

         assert (output == outputEnd);  <span class="comment">// output buffer is full</span>

         os.write (outputBuffer, <span class="keyword">sizeof</span> outputBuffer);  <span class="comment">// write buffer</span>
         <span class="keywordflow">if</span> (os.fail()) {
             <span class="keywordflow">return</span> IO_ERROR;                                       <span class="comment">// RETURN</span>
         }
         output = outputBuffer;
     }

     <span class="keywordflow">if</span> (output &gt; outputBuffer) {
         os.write (outputBuffer, output - outputBuffer);
     }

     <span class="keywordflow">return</span> is.eof() &amp;&amp; os.good() ? SUCCESS : IO_ERROR;
 }

 } <span class="comment">// Close namespace BloombergLP</span>
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:43 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
