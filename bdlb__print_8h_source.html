<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlb_print.h                                                       -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLB_PRINT
#define INCLUDED_BDLB_PRINT

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide platform-independent stream utilities.
//
//@CLASSES:
//  bdlb::Print: namespace for procedures on streams
//  bdlb::PrintStringHexDumper: create/print hex buffers, multi-line
//  bdlb::PrintStringSingleLineHexDumper: create/print hex buffers, single line
//
//@DESCRIPTION: This component provides a namespace, &#39;bdlb::Print&#39;, containing
// utility functions for formatting data to &#39;bsl::ostream&#39; objects.  These
// functions provide several variations of hexadecimal format, allow
// platform-independent representation of &#39;void *&#39; pointers, and can help with
// the indentation of hierarchical data.
//
// This component also provides two helper classes,
// &#39;bdlb::PrintStringHexDumper&#39; and &#39;bdlb::PrintStringSingleLineHexDumper&#39;,
// that define &#39;operator&lt;&lt;&#39; so they can be used in chains of &#39;&lt;&lt;&#39; operations.
// The &#39;bdlb::PrintStringHexDumper&#39; class produces formatted, possibly
// multi-line output, whereas the &#39;bdlb::PrintStringSingleLineHexDumper&#39; class
// produces a simple sequence of hexidecimal digits (and no newline).
//
///&#39;xxd&#39;-Compatible &#39;hexDump&#39;
/// - - - - - - - - - - - - -
// The output generated by the &#39;hexDump&#39; functions is not &#39;xxd&#39;-compatible (see
// &#39;http://gd.tuwien.ac.at/linuxcommand.org/man_pages/xxd1.html&#39;).  The
// following perl script is provided that will convert &#39;hexDump&#39; output into
// &#39;xxd&#39;-compatible form.  Run the script with a file containing the &#39;hexDump&#39;
// output as the first argument.
//..
//  #!/usr/bin/perl -w
//
//  use strict;
//
//  my $num = 0;
//  while (&lt;&gt;) {
//      next if (!$_);
//      my $str = $_;
//      next if !($str =~ s/^[^:]*?:\s*//);
//      my $h = sprintf(&quot;%08X&quot;,$num);
//      $str =~ s/(\S{4})([\S\W]{4})\s?([\S\W]{4})([\S\W]{4})\s?([\S\W]{4})?
//            ([\S\W]{4})?\s?([\S\W]{4})?([\S\W]{4})?/$1 $2 $3 $4 $5 $6 $7 $8/;
//      $str =~ s/\s \|([^|]+)\|.*$/ $1/;
//      print &quot;$h: &quot;;
//      print $str;
//      $num = $num + 16;
//  }
//..
//
///Usage
///-----
// In this section we show intended usage of this component.
//
///Example 1: Using &#39;printPtr&#39;
///- - - - - - - - - - - - - -
// The default output produced from pointer values is non-standard across
// vendor platforms.  The &#39;printPtr&#39; method addresses this inconsistency by
// always producing a consistent format for a given pointer size:
//..
//  const void *a = reinterpret_cast&lt;void *&gt;(0x0);
//  const void *b = reinterpret_cast&lt;void *&gt;(0xf2ff);
//  const void *c = reinterpret_cast&lt;void *&gt;(0x0123);
//  const void *d = reinterpret_cast&lt;void *&gt;(0xf1f2abc9);
//
//  bsl::ostringstream out1;
//
//  bdlb::Print::printPtr(out1, a); out1 &lt;&lt; endl;
//  bdlb::Print::printPtr(out1, b); out1 &lt;&lt; endl;
//  bdlb::Print::printPtr(out1, c); out1 &lt;&lt; endl;
//  bdlb::Print::printPtr(out1, d); out1 &lt;&lt; endl;
//
//  assert(&quot;0&quot;        &quot;\n&quot;
//         &quot;f2ff&quot;     &quot;\n&quot;
//         &quot;123&quot;      &quot;\n&quot;
//         &quot;f1f2abc9&quot; &quot;\n&quot; == out1.str());
//..
//
///Example 2: Using the Helper Classes
///- - - - - - - - - - - - - - - - - -
// The two helper classes allow users to stream a hexadecimal representation
// of a sequence of bytes into an output stream.
//
// The &#39;bdlb::PrintStringHexDumper&#39; provides a formatted, possibly multi-line
// representation:
//..
//  char buf[] = &quot;abcdefghijklmnopqrstuvwxyz&quot;;
//
//  bsl::ostringstream out2a;
//  out2a &lt;&lt; bdlb::PrintStringHexDumper(buf, sizeof buf);
//
//  assert(
//     &quot;     0:   61626364 65666768 696A6B6C 6D6E6F70     |abcdefghijklmnop|\n&quot;
//     &quot;    16:   71727374 75767778 797A00                |qrstuvwxyz.     |\n&quot;
//      == out2a.str());
//
//  bsl::ostringstream out2b;
//  out2b &lt;&lt; bdlb::PrintStringSingleLineHexDumper(buf, sizeof buf);
//..
// The &#39;bdlb::PrintStringSingleLineHexDumper&#39; provides a simple, single-line
// representation.
//..
//  assert(&quot;6162636465666768696A6B6C6D6E6F707172737475767778797A00&quot;
//      == out2b.str());
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSL_OSTREAM
#include &lt;bsl_ostream.h&gt;
#endif

#ifndef INCLUDED_BSL_UTILITY
#include &lt;bsl_utility.h&gt;
#endif

namespace BloombergLP {
namespace bdlb {
                                // ============
                                // struct Print
                                // ============

struct Print {
    // Provide a namespace for the interface to a suite of procedural stream
    // operations.

    // CLASS METHODS
    static bsl::ostream&amp; indent(bsl::ostream&amp; stream,
                                int           level,
                                int           spacesPerLevel = 4);
        // Emit to the specified output &#39;stream&#39; the number of spaces (i.e.,
        // &#39;\b&#39;) specified by absolute value of the product of the specified
        // &#39;level&#39; and &#39;spacesPerLevel&#39;.  Return a reference providing
        // modifiable access to &#39;stream&#39;.  If the &#39;level&#39; is negative, this
        // function has no effect.

    static bsl::ostream&amp; newlineAndIndent(bsl::ostream&amp; stream,
                                          int           level,
                                          int           spacesPerLevel = 4);
        // Emit to the specified &#39;stream&#39; a newline (&#39;\n&#39;) followed by the
        // number of spaces (&#39;\b&#39;) equal to the absolute value of the specified
        // &#39;level&#39; and &#39;spacesPerLevel&#39; or, if &#39;spacesPerLevel&#39; is negative,
        // emit a single space (and *no* newline).  Return a reference
        // providing modifiable access to &#39;stream&#39;.

    static void printPtr(bsl::ostream&amp; stream, const void *value);
        // Print to the specified &#39;stream&#39; the specified pointer &#39;value&#39; in a
        // standard format.  The output is in hexadecimal format with a maximum
        // length of &#39;2 * sizeof(void *)&#39;.  The output does not have leading
        // zeros and is not preceded by &#39;0x&#39;.  The hexadecimal digits (&#39;a&#39; to
        // &#39;f&#39;, inclusive) are expressed in lower case.

    static bsl::ostream&amp; printString(bsl::ostream&amp;  stream,
                                     const char    *string,
                                     int            length,
                                     bool           escapeBackSlash = false);
        // Print to the specified &#39;stream&#39; the specified &#39;string&#39; of the
        // specified &#39;length&#39; and return a reference providing modifiable
        // access to &#39;stream&#39;.  If the optionally specified &#39;escapeBackSlash&#39;
        // flag is &#39;true&#39;, then all occurrences of the backslash character
        // (&#39;\&#39;) in the &#39;string&#39; are escaped (i.e., expanded to &quot;\\&quot;) when
        // written to the &#39;stream&#39;.  Note that non-printable characters in
        // &#39;string&#39; will be printed in their hexadecimal representation
        // (&#39;\xHH&#39;).  If &#39;stream&#39; is not valid on entry, this operation has no
        // effect.  The behavior is undefined unless &#39;0 &lt;= length&#39;.

    static bsl::ostream&amp; hexDump(bsl::ostream&amp;  stream,
                                 const char    *buffer,
                                 int            length);
        // Print in hexadecimal format the contents of the specified &#39;buffer&#39;
        // of the specified &#39;length&#39; to the specified &#39;stream&#39;, and return a
        // reference providing modifiable access to &#39;stream&#39;.  The behavior is
        // undefined unless &#39;0 &lt;= length&#39;.

    static bsl::ostream&amp; hexDump(bsl::ostream&amp;                  stream,
                                 bsl::pair&lt;const char *, int &gt; *buffers,
                                 int                            numBuffers);
        // Print to the specified &#39;stream&#39; the specified &#39;numBuffers&#39; buffers
        // supplied by specified &#39;buffers&#39; in a hexadecimal representation (16
        // chars per line) followed by the ASCII representation.  Return a
        // reference providing modifiable access to &#39;stream&#39;.  The array of
        // buffers are supplied as a &#39;bsl::pair&lt;const char*, int&gt; *&#39; where the
        // first element is a pointer to the data, and the second element is
        // the length of the buffer.  The behavior is undefined unless
        // &#39;0 &lt;= numBuffers&#39;.  Note that the contents of the buffers are
        // concatenated and boundaries between buffers are not demarcated.

    template &lt;class INPUT_ITERATOR&gt;
    static bsl::ostream&amp; singleLineHexDump(bsl::ostream&amp;  stream,
                                           INPUT_ITERATOR begin,
                                           INPUT_ITERATOR end);
        // Print to the specified &#39;stream&#39; the uppercase hex encoding of the
        // byte sequence defined by the specified &#39;begin&#39; and &#39;end&#39; iterators
        // of the parameterized &#39;INPUT_ITERATOR&#39; type, and return a reference
        // providing modifiable access to &#39;stream&#39;.  Note that &#39;INPUT_ITERATOR&#39;
        // need not be random-access, i.e., it need support only increment
        // (&#39;++&#39;) and equality comparison (&#39;==&#39;).  See the non-template version
        // of this function if insulation and/or code bloat are a concern.

    static bsl::ostream&amp; singleLineHexDump(bsl::ostream&amp;  stream,
                                           const char    *begin,
                                           const char    *end);
        // Print to the specified &#39;stream&#39; the uppercase hex encoding of the
        // byte sequence defined by the specified &#39;begin&#39; and &#39;end&#39; iterators
        // into the specified &#39;stream&#39;, and return a reference providing
        // modifiable access to &#39;stream&#39;.  This function insulates clients from
        // its implementation, but unlike the member template version (above),
        // requires random access iterators of type &#39;const char *&#39;.  The
        // behavior is undefined unless both &#39;begin&#39; and &#39;end&#39; refer to the
        // same block of contiguous memory, and &#39;begin &lt;= end&#39;.

    static bsl::ostream&amp; singleLineHexDump(bsl::ostream&amp;  stream,
                                           const char    *buffer,
                                           int            length);
        // Print to the specified &#39;stream&#39; the contents of the specified
        // &#39;buffer&#39; having the specified &#39;length&#39; on a single line, and return
        // a reference to the modifiable &#39;stream&#39;.  The behavior is undefined
        // unless &#39;0 &lt;= length&#39;.
};

                        // ===========================
                        // struct PrintStringHexDumper
                        // ===========================

struct PrintStringHexDumper {
    // Utility for hex dumping a blob to standard output streams.  This class
    // has &#39;operator&lt;&lt;&#39; defined for it, so it can be used as follows:
    //..
    //  bsl::vector&lt;char&gt; blob;
    //  blob.resize(1024);
    //
    //  // ... fill up the blob with some data ...
    //
    //  bsl::cout &lt;&lt; PrintStringHexDumper(blob.data(), blob.size())
    //            &lt;&lt; bsl::endl;
    //..

    // DATA
    const char *d_data_p;
    int         d_length;

    // CREATORS
    PrintStringHexDumper(const char *data, int length);
        // Create a &#39;PrintStringHexDumper&#39; object that can insert to an output
        // stream a formated (possibly multi-lined) hexadecimal representation
        // the specified &#39;data&#39; of the specified &#39;length&#39;.
};

// FREE OPERATORS
inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;               stream,
                         const PrintStringHexDumper&amp; rhs);
    // Hex dump the data referenced by the specified &#39;rhs&#39; to the specified
    // &#39;stream&#39;.

                   // =====================================
                   // struct PrintStringSingleLineHexDumper
                   // =====================================

struct PrintStringSingleLineHexDumper {
    // Utility for hex dumping a string with no extra formatting to standard
    // output streams.  This class has &#39;operator&lt;&lt;&#39; defined for it, so it can
    // be used as follows:
    //..
    //  bsl::string str;
    //
    //  // ... fill up the str with some data ...
    //
    //  bsl::cout
    //         &lt;&lt; PrintStringSingleLineHexDumper(str.c_str(), str.size())
    //         &lt;&lt; bsl::endl;
    //..

    // DATA
    const char *d_data_p;
    int         d_length;

    // CREATORS
    PrintStringSingleLineHexDumper(const char *data, int length);
        // Create a &#39;PrintStringSingleLineHexDumper&#39; object that can insert to
        // an output stream a single-line hexadecimal representation the
        // specified &#39;data&#39; of the specified &#39;length&#39;.
};

// FREE OPERATORS
inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                         stream,
                         const PrintStringSingleLineHexDumper&amp; rhs);
    // Hex dump the data referenced by the specified &#39;rhs&#39; to the specified
    // &#39;stream&#39;.

// ============================================================================
//                        INLINE DEFINITIONS
// ============================================================================

                        // ------------
                        // struct Print
                        // ------------

// CLASS METHODS
template &lt;class INPUT_ITERATOR&gt;
bsl::ostream&amp; Print::singleLineHexDump(bsl::ostream&amp;  stream,
                                       INPUT_ITERATOR begin,
                                       INPUT_ITERATOR end)
{
    enum { k_LOCAL_BUF_SIZE = 512 };
    static const char HEX[] = &quot;0123456789ABCDEF&quot;;

    char buf[k_LOCAL_BUF_SIZE];

    unsigned int offset = 0;

    for (; begin != end; ++begin) {

        if (offset &gt;= (k_LOCAL_BUF_SIZE - 1)) {
             stream.write(buf, offset);
             offset = 0;
        }

        const unsigned char c = *begin;

        buf[offset++] = HEX[(c &gt;&gt; 4) &amp; 0xF];
        buf[offset++] = HEX[c        &amp; 0xF];
    }

    if (offset != 0) {
        stream.write(buf, offset);
    }

    return stream;
}

inline
bsl::ostream&amp; Print::singleLineHexDump(bsl::ostream&amp;  stream,
                                       const char    *buffer,
                                       int            length)
{
    BSLS_ASSERT_SAFE(buffer);
    BSLS_ASSERT_SAFE(0 &lt;= length);

    return singleLineHexDump(stream, buffer, buffer + length);
}

                        // ---------------------------
                        // struct PrintStringHexDumper
                        // ---------------------------

// CREATORS
inline
PrintStringHexDumper::PrintStringHexDumper(const char *data,
                                           int         length)
: d_data_p(data)
, d_length(length)
{
    BSLS_ASSERT_SAFE(data);
    BSLS_ASSERT_SAFE(0 &lt;= length);

}
}  // close package namespace

// FREE OPERATORS
inline
bsl::ostream&amp; bdlb::operator&lt;&lt;(bsl::ostream&amp;               stream,
                               const PrintStringHexDumper&amp; rhs)
{
    return Print::hexDump(stream, rhs.d_data_p, rhs.d_length);
}

namespace bdlb {
                        // -------------------------------------
                        // struct PrintStringSingleLineHexDumper
                        // -------------------------------------

// CREATORS
inline
PrintStringSingleLineHexDumper::PrintStringSingleLineHexDumper(
                                                            const char *data,
                                                            int         length)
: d_data_p(data)
, d_length(length)
{
    BSLS_ASSERT_SAFE(data);
    BSLS_ASSERT_SAFE(0 &lt;= length);
}
}  // close package namespace

// FREE OPERATORS
inline
bsl::ostream&amp; bdlb::operator&lt;&lt;(bsl::ostream&amp;                         stream,
                               const PrintStringSingleLineHexDumper&amp; rhs)
{
    return Print::singleLineHexDump(stream, rhs.d_data_p, rhs.d_length);
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
