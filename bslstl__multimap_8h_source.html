<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslstl_multimap.h                                                  -*-C++-*-
#ifndef INCLUDED_BSLSTL_MULTIMAP
#define INCLUDED_BSLSTL_MULTIMAP

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an STL-compliant multimap class.
//
//@CLASSES:
//   bsl::multimap: STL-compatible multimap template
//
//@SEE_ALSO: bslstl_map, bslstl_multiset
//
//@DESCRIPTION: This component defines a single class template &#39;bsl::multimap&#39;,
// implementing the standard container holding an ordered sequence of key-value
// pairs (possibly having duplicate keys), and presenting a mapping from the
// keys (of a template parameter type, &#39;KEY&#39;) to their associated values (of
// another template parameter type, &#39;VALUE&#39;).
//
// An instantiation of &#39;multimap&#39; is an allocator-aware, value-semantic type
// whose salient attributes are its size (number of key-value pairs) and the
// ordered sequence of key-value pairs the multimap contains.  If &#39;multimap&#39; is
// instantiated with either a key type or mapped-value type that is not itself
// value-semantic, then it will not retain all of its value-semantic qualities.
// In particular, if a either the key or value type cannot be tested for
// equality, then a &#39;multimap&#39; containing that type cannot be tested for
// equality.  It is even possible to instantiate &#39;multimap&#39; with a key or
// mapped-value type that does not have a copy-constructor, in which case the
// &#39;multimap&#39; will not be copyable.
//
// A &#39;multimap&#39; meets the requirements of an associative container with
// bidirectional iterators in the C++11 standard [23.2.4].  The &#39;multimap&#39;
// implemented here adheres to the C++11 standard, except that it does not have
// interfaces that take rvalue references, &#39;initializer_lists&#39;, &#39;emplace&#39;, or
// operations taking a variadic number of template parameters.  Note that
// excluded C++11 features are those that require (or are greatly simplified
// by) C++11 compiler support.
//
///Requirements on &#39;KEY&#39; and &#39;VALUE&#39;
///---------------------------------
// A &#39;multimap&#39; is a fully &quot;Value-Semantic Type&quot; (see {&#39;bsldoc_glossary&#39;}) only
// if the supplied &#39;KEY&#39; and &#39;VALUE&#39; template parameters are themselves fully
// value-semantic.  It is possible to instantiate a &#39;multimap&#39; with &#39;KEY&#39; and
// &#39;VALUE&#39; parameter arguments that do not provide a full set of value-semantic
// operations, but then some methods of the container may not be instantiable.
// The following terminology, adopted from the C++11 standard, is used in the
// function documentation of &#39;multimap&#39; to describe a function&#39;s requirements
// for the &#39;KEY&#39; and &#39;VALUE&#39; template parameters.  These terms are also defined
// in section [17.6.3.1] of the C++11 standard.  Note that, in the context of a
// &#39;multimap&#39; instantiation, the requirements apply specifically to the
// multimap&#39;s entry type, &#39;value_type&#39;, which is an alias for &#39;bsl::pair&lt;KEY,
// VALUE&gt;&#39;.
//
//: &quot;default-constructible&quot;: The type provides a default constructor.
//:
//: &quot;copy-constructible&quot;: The type provides a copy constructor.
//:
//: &quot;equality-comparable&quot;: The type provides an equality-comparison operator
//:     that defines an equivalence relationship and is both reflexive and
//:     transitive.
//:
//: &quot;less-than-comparable&quot;: The type provides a less-than operator, which
//:     defines a strict weak ordering relation on values of the type.
//
///Memory Allocation
///-----------------
// The type supplied as a multimap&#39;s &#39;ALLOCATOR&#39; template parameter determines
// how that multimap will allocate memory.  The &#39;multimap&#39; template supports
// allocators meeting the requirements of the C++11 standard [17.6.3.5], in
// addition it supports scoped-allocators derived from the &#39;bslma::Allocator&#39;
// memory allocation protocol.  Clients intending to use &#39;bslma&#39; style
// allocators should use the template&#39;s default &#39;ALLOCATOR&#39; type: The default
// type for the &#39;ALLOCATOR&#39; template parameter, &#39;bsl::allocator&#39;, provides a
// C++11 standard-compatible adapter for a &#39;bslma::Allocator&#39; object.
//
///&#39;bslma&#39;-Style Allocators
/// - - - - - - - - - - - -
// If the (template parameter) type &#39;ALLOCATOR&#39; of an &#39;multimap&#39; instantiation&#39;
// is &#39;bsl::allocator&#39;, then objects of that multimap type will conform to the
// standard behavior of a &#39;bslma&#39;-allocator-enabled type.  Such a multimap
// accepts an optional &#39;bslma::Allocator&#39; argument at construction.  If the
// address of a &#39;bslma::Allocator&#39; object is explicitly supplied at
// construction, it is used to supply memory for the &#39;multimap&#39; throughout its
// lifetime; otherwise, the multimap will use the default allocator installed
// at the time of the multimap&#39;s construction (see &#39;bslma_default&#39;).  In
// addition to directly allocating memory from the indicated
// &#39;bslma::Allocator&#39;, a multimap supplies that allocator&#39;s address to the
// constructors of contained objects of the (template parameter) types &#39;KEY&#39;
// and &#39;VALUE&#39;, if respectively, the types define the
// &#39;bslma::UsesBslmaAllocator&#39; trait.
//
///Operations
///----------
// This section describes the run-time complexity of operations on instances
// of &#39;multimap&#39;:
//..
//  Legend
//  ------
//  &#39;K&#39;             - (template parameter) type &#39;KEY&#39; of the &#39;multimap&#39;
//  &#39;V&#39;             - (template parameter) type &#39;VALUE&#39; of the &#39;multimap&#39;
//  &#39;a&#39;, &#39;b&#39;        - two distinct objects of type &#39;multimap&lt;K, V&gt;&#39;
//  &#39;n&#39;, &#39;m&#39;        - number of elements in &#39;a&#39; and &#39;b&#39; respectively
//  &#39;value_type&#39;    - &#39;multimap&lt;K, V&gt;::value_type&#39;
//  &#39;c&#39;             - comparator providing an ordering for objects of type &#39;K&#39;
//  &#39;al             - an STL-style memory allocator
//  &#39;i1&#39;, &#39;i2&#39;      - two iterators defining a sequence of &#39;value_type&#39; objects
//  &#39;k&#39;             - an object of type &#39;K&#39;
//  &#39;v&#39;             - an object of type &#39;V&#39;
//  &#39;p1&#39;, &#39;p2&#39;      - two iterators belonging to &#39;a&#39;
//  distance(i1,i2) - the number of elements in the range [i1, i2)
//
//  +----------------------------------------------------+--------------------+
//  | Operation                                          | Complexity         |
//  +====================================================+====================+
//  | multimap&lt;K, V&gt; a;    (default construction)        | O[1]               |
//  | multimap&lt;K, V&gt; a(al);                              |                    |
//  | multimap&lt;K, V&gt; a(c, al);                           |                    |
//  +----------------------------------------------------+--------------------+
//  | multimap&lt;K, V&gt; a(b); (copy construction)           | O[n]               |
//  | multimap&lt;K, V&gt; a(b, al);                           |                    |
//  +----------------------------------------------------+--------------------+
//  | multimap&lt;K, V&gt; a(i1, i2);                          | O[N] if [i1, i2)   |
//  | multimap&lt;K, V&gt; a(i1, i2, al);                      | is sorted with     |
//  | multimap&lt;K, V&gt; a(i1, i2, c, al);                   | &#39;a.value_comp()&#39;,  |
//  |                                                    | O[N * log(N)]      |
//  |                                                    | otherwise, where N |
//  |                                                    | is distance(i1,i2) |
//  +----------------------------------------------------+--------------------+
//  | a.~multimap&lt;K, V&gt;(); (destruction)                 | O[n]               |
//  +----------------------------------------------------+--------------------+
//  | a = b;          (assignment)                       | O[n]               |
//  +----------------------------------------------------+--------------------+
//  | a.begin(), a.end(), a.cbegin(), a.cend(),          | O[1]               |
//  | a.rbegin(), a.rend(), a.crbegin(), a.crend()       |                    |
//  +----------------------------------------------------+--------------------+
//  | a == b, a != b                                     | O[n]               |
//  +----------------------------------------------------+--------------------+
//  | a &lt; b, a &lt;= b, a &gt; b, a &gt;= b                       | O[n]               |
//  +----------------------------------------------------+--------------------+
//  | a.swap(b), swap(a,b)                               | O[1] if &#39;a&#39; and    |
//  |                                                    | &#39;b&#39; use the same   |
//  |                                                    | allocator,         |
//  |                                                    | O[n + m] otherwise |
//  +----------------------------------------------------+--------------------+
//  | a.size()                                           | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.max_size()                                       | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.empty()                                          | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | get_allocator()                                    | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.insert(value_type(k, v))                         | O[log(n)]          |
//  +----------------------------------------------------+--------------------+
//  | a.insert(p1, value_type(k, v))                     | amortized constant |
//  |                                                    | if the value is    |
//  |                                                    | inserted right     |
//  |                                                    | before p1,         |
//  |                                                    | O[log(n)]          |
//  |                                                    | otherwise          |
//  +----------------------------------------------------+--------------------+
//  | a.insert(i1, i2)                                   | O[log(N) *         |
//  |                                                    |   distance(i1,i2)] |
//  |                                                    |                    |
//  |                                                    | where N is         |
//  |                                                    | n + distance(i1,i2)|
//  +----------------------------------------------------+--------------------+
//  | a.erase(p1)                                        | amortized constant |
//  +----------------------------------------------------+--------------------+
//  | a.erase(k)                                         | O[log(n) +         |
//  |                                                    | a.count(k)]        |
//  +----------------------------------------------------+--------------------+
//  | a.erase(p1, p2)                                    | O[log(n) +         |
//  |                                                    | distance(p1, p2)]  |
//  +----------------------------------------------------+--------------------+
//  | a.erase(p1, p2)                                    | O[log(n) +         |
//  |                                                    | distance(p1, p2)]  |
//  +----------------------------------------------------+--------------------+
//  | a.clear()                                          | O[n]               |
//  +----------------------------------------------------+--------------------+
//  | a.key_comp()                                       | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.value_comp()                                     | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.find(k)                                          | O[log(n)]          |
//  +----------------------------------------------------+--------------------+
//  | a.count(k)                                         | O[log(n) +         |
//  |                                                    | a.count(k)]        |
//  +----------------------------------------------------+--------------------+
//  | a.lower_bound(k)                                   | O[log(n)]          |
//  +----------------------------------------------------+--------------------+
//  | a.upper_bound(k)                                   | O[log(n)]          |
//  +----------------------------------------------------+--------------------+
//  | a.equal_range(k)                                   | O[log(n)]          |
//  +----------------------------------------------------+--------------------+
//..
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Creating a Phone Book
/// - - - - - - - - - - - - - - - -
// In this example, we will define a class &#39;PhoneBook&#39;, that provides a mapping
// of names to phone numbers.  The &#39;PhoneBook&#39; class will be implemented using
// a &#39;bsl::multimap&#39;, and will supply manipulators, allowing a client to add or
// remove entries from the phone book, as well as accessors, allowing clients
// to efficiently lookup entries by name, and to iterate over the entries in
// the phone book in sorted order.
//
// Note that this example uses a type &#39;string&#39; that is based on the standard
// type &#39;string&#39; (see &#39;bslstl_string&#39;).  For the sake of brevity, the
// implementation of &#39;string&#39; is not explored here.
//
// First, we define an alias for a pair of &#39;string&#39; objects that we will use to
// represent names in the phone book:
//..
//  typedef bsl::pair&lt;string, string&gt; FirstAndLastName;
//      // This &#39;typedef&#39; provides an alias for a pair of &#39;string&#39; objects,
//      // whose &#39;first&#39; and &#39;second&#39; elements refer to the first and last
//      // names of a person, respectively.
//..
// Then, we define a comparison functor for &#39;FirstAndLastName&#39; objects (note
// that this comparator is required because we intend for the last name to
// take precedence over the first name in the ordering of entries maintained
// by the phone book, which differs from the behavior supplied by &#39;operator&lt;&#39;
// for &#39;pair&#39;):
//..
//  struct FirstAndLastNameLess {
//      // This &#39;struct&#39; defines an ordering on &#39;FirstAndLastName&#39; values,
//      // allowing them to be included in sorted containers such as
//      // &#39;bsl::multimap&#39;.  Note that last name (the &#39;second&#39; member of a
//      // &#39;FirstAndLastName&#39; value) takes precedence over first name in the
//      // ordering defined by this functor.
//
//      bool operator()(const FirstAndLastName&amp; lhs,
//                      const FirstAndLastName&amp; rhs) const
//          // Return &#39;true&#39; if the value of the specified &#39;lhs&#39; is less than
//          // (ordered before) the value of the specified &#39;rhs&#39;, and &#39;false&#39;
//          // otherwise.  The &#39;lhs&#39; value is considered less than the &#39;rhs&#39;
//          // value if the second value in the &#39;lhs&#39; pair (the last name) is
//          // less than the second value in the &#39;rhs&#39; pair or, if the second
//          // values are equal, if the first value in the &#39;lhs&#39; pair (the
//          // first name) is less than the first value in the &#39;rhs&#39; pair.
//      {
//          int cmp = std::strcmp(lhs.second.c_str(), rhs.second.c_str());
//          if (0 == cmp) {
//              cmp = std::strcmp(lhs.first.c_str(), rhs.first.c_str());
//          }
//          return cmp &lt; 0;
//      }
//  };
//..
// Next, we define the public interface for &#39;PhoneBook&#39;:
//..
//  class PhoneBook {
//      // This class provides a mapping of a person&#39;s name to their phone
//      // number.  Names within a &#39;Phonebook&#39; are represented using a using
//      // &#39;FirstAndLastName&#39; object, and phone numbers are represented using a
//      // &#39;bsls::Types::Uint64&#39; value.
//
//..
// Here, we create a type alias, &#39;NameToNumberMap&#39;, for a &#39;bsl::multimap&#39; that
// will serve as the data member for a &#39;PhoneBook&#39;.  A &#39;NameToNumberMap&#39; has
// keys of type &#39;FirstAndLastName&#39;, mapped-values of type
// &#39;bsls::Types::Uint64&#39;, and a comparator of type &#39;FirstAndLastNameLess&#39;.  We
// use the default &#39;ALLOCATOR&#39; template parameter as we intend to use
// &#39;PhoneBook&#39; with &#39;bslma&#39; style allocators:
//..
//      // PRIVATE TYPES
//      typedef bsl::multimap&lt;FirstAndLastName,
//                            bsls::Types::Uint64,
//                            FirstAndLastNameLess&gt; NameToNumberMap;
//          // This &#39;typedef&#39; is an alias for a mapping between names and phone
//          // numbers.
//
//      // DATA
//      NameToNumberMap d_nameToNumber;  // mapping of names to phone numbers
//
//      // FRIENDS
//      friend bool operator==(const PhoneBook&amp; lhs, const PhoneBook&amp; rhs);
//
//    public:
//      // PUBLIC TYPES
//      typedef bsls::Types::Uint64 PhoneNumber;
//          // This &#39;typedef&#39; provides an alias for the type of an unsigned
//          // integers used to represent phone-numbers in a &#39;PhoneBook&#39;.
//
//      typedef NameToNumberMap::const_iterator ConstIterator;
//          // This &#39;typedef&#39; provides an alias for the type of an iterator
//          // providing non-modifiable access to the entries in a &#39;PhoneBook&#39;.
//
//      // CREATORS
//      PhoneBook(bslma::Allocator *basicAllocator = 0);
//          // Create an empty &#39;PhoneBook&#39; object.  Optionally specify a
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//          // 0, the currently installed default allocator is used.
//
//      PhoneBook(const PhoneBook&amp;  original,
//                bslma::Allocator  *basicAllocator = 0);
//          // Create a &#39;PhoneBook&#39; object having the same value as the
//          // specified &#39;original&#39; object.  Optionally specify a
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//          // 0, the currently installed default allocator is used.
//
//      //! ~PhoneBook() = default;
//          // Destroy this object.
//
//      // MANIPULATORS
//      PhoneBook&amp; operator=(const PhoneBook&amp; rhs);
//          // Assign to this object the value of the specified &#39;rhs&#39; object,
//          // and return a reference providing modifiable access to this
//          // object.
//
//      void addEntry(const FirstAndLastName&amp; name, PhoneNumber number);
//          // Add an entry to this phone book having the specified &#39;name&#39; and
//          // &#39;number&#39;.  The behavior is undefined unless &#39;name.first&#39; and
//          // &#39;name.end&#39; are non-empty strings.
//
//      int removeEntry(const FirstAndLastName&amp; name, PhoneNumber number);
//          // Remove the entries from this phone book having the specified
//          // &#39;name&#39; and &#39;number&#39;, if they exists, and return the number of
//          // removed entries; otherwise, return 0 with no other effects.
//
//      // ACCESSORS
//      bsl::pair&lt;ConstIterator, ConstIterator&gt; lookupByName(
//                                         const FirstAndLastName&amp; name) const;
//          // Return a pair of iterators to the ordered sequence of entries
//          // held in this phone book having the specified &#39;name&#39;, where the
//          // first iterator is position at the start of the sequence, and the
//          // second is positioned one past the last entry in the sequence.
//          // If &#39;name&#39; does not exist in this phone book, then the two
//          // returned iterators will have the same value.
//
//      ConstIterator begin() const;
//          // Return an iterator providing non-modifiable access to the first
//          // entry in the ordered sequence of entries held in this phone
//          // book, or the past-the-end iterator if this phone book is empty.
//
//      ConstIterator end() const;
//          // Return an iterator providing non-modifiable access to the
//          // past-the-end entry in the ordered sequence of entries maintained
//          // by this phone book.
//
//      int numEntries() const;
//          // Return the number of entries contained in this phone book.
//  };
//..
// Then, we declare the free operators for &#39;PhoneBook&#39;:
//..
//  inline
//  bool operator==(const PhoneBook&amp; lhs, const PhoneBook&amp; rhs);
//      // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
//      // value, and &#39;false&#39; otherwise.  Two &#39;PhoneBook&#39; objects have the
//      // same value if they have the same number of entries, and each
//      // corresponding entry, in their respective ordered sequence of
//      // entries, is the same.
//
//  inline
//  bool operator!=(const PhoneBook&amp; lhs, const PhoneBook&amp; rhs);
//      // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have
//      // the same value, and &#39;false&#39; otherwise.  Two &#39;PhoneBook&#39; objects do
//      // not have the same value if they either differ in their number of
//      // contained entries, or if any of the corresponding entries, in their
//      // respective ordered sequences of entries, is not the same.
//..
// Now, we define the implementations methods of the &#39;PhoneBook&#39; class:
//..
//  // CREATORS
//  inline
//  PhoneBook::PhoneBook(bslma::Allocator *basicAllocator)
//  : d_nameToNumber(FirstAndLastNameLess(), basicAllocator)
//  {
//  }
//..
// Notice that, on construction, we pass the contained &#39;bsl::multimap&#39;
// (&#39;d_nameToNumber&#39;), a default constructed &#39;FirstAndLastNameLess&#39; object that
// it will use to perform comparisons, and the allocator supplied to
// &#39;PhoneBook&#39; at construction&#39;.
//..
//  inline
//  PhoneBook::PhoneBook(const PhoneBook&amp;   original,
//                       bslma::Allocator  *basicAllocator)
//  : d_nameToNumber(original.d_nameToNumber, basicAllocator)
//  {
//  }
//
//  // MANIPULATORS
//  inline
//  PhoneBook&amp; PhoneBook::operator=(const PhoneBook&amp; rhs)
//  {
//      d_nameToNumber = rhs.d_nameToNumber;
//      return *this;
//  }
//
//  inline
//  void PhoneBook::addEntry(const FirstAndLastName&amp; name, PhoneNumber number)
//  {
//      BSLS_ASSERT(!name.first.empty());
//      BSLS_ASSERT(!name.second.empty());
//
//      d_nameToNumber.insert(NameToNumberMap::value_type(name, number));
//  }
//
//  inline
//  int PhoneBook::removeEntry(const FirstAndLastName&amp; name,
//                             PhoneNumber             number)
//  {
//
//      bsl::pair&lt;NameToNumberMap::iterator, NameToNumberMap::iterator&gt; range =
//                                            d_nameToNumber.equal_range(name);
//
//      NameToNumberMap::iterator itr = range.first;
//      int numRemovedEntries = 0;
//
//      while (itr != range.second) {
//          if (itr-&gt;second == number) {
//              itr = d_nameToNumber.erase(itr);
//              ++numRemovedEntries;
//          }
//          else {
//              ++itr;
//          }
//      }
//
//      return numRemovedEntries;
//  }
//
//  // ACCESSORS
//  inline
//  bsl::pair&lt;PhoneBook::ConstIterator, PhoneBook::ConstIterator&gt;
//  PhoneBook::lookupByName(const FirstAndLastName&amp;  name) const
//  {
//      return d_nameToNumber.equal_range(name);
//  }
//
//  inline
//  PhoneBook::ConstIterator PhoneBook::begin() const
//  {
//      return d_nameToNumber.begin();
//  }
//
//  inline
//  PhoneBook::ConstIterator PhoneBook::end() const
//  {
//      return d_nameToNumber.end();
//  }
//
//  inline
//  int PhoneBook::numEntries() const
//  {
//      return d_nameToNumber.size();
//  }
//..
// Finally, we implement the free operators for &#39;PhoneBook&#39;:
//..
//  inline
//  bool operator==(const PhoneBook&amp; lhs, const PhoneBook&amp; rhs)
//  {
//      return lhs.d_nameToNumber == rhs.d_nameToNumber;
//  }
//
//  inline
//  bool operator!=(const PhoneBook&amp; lhs, const PhoneBook&amp; rhs)
//  {
//      return !(lhs == rhs);
//  }
//..

#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
#error &quot;include &lt;bsl_map.h&gt; instead of &lt;bslstl_multimap.h&gt; in \
BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ALLOCATOR
#include &lt;bslstl_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_MAPCOMPARATOR
#include &lt;bslstl_mapcomparator.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_PAIR
#include &lt;bslstl_pair.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_STDEXCEPTUTIL
#include &lt;bslstl_stdexceptutil.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_TREEITERATOR
#include &lt;bslstl_treeiterator.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_TREENODE
#include &lt;bslstl_treenode.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_TREENODEPOOL
#include &lt;bslstl_treenodepool.h&gt;
#endif

#ifndef INCLUDED_BSLALG_RANGECOMPARE
#include &lt;bslalg_rangecompare.h&gt;
#endif

#ifndef INCLUDED_BSLALG_RBTREEANCHOR
#include &lt;bslalg_rbtreeanchor.h&gt;
#endif

#ifndef INCLUDED_BSLALG_RBTREENODE
#include &lt;bslalg_rbtreenode.h&gt;
#endif

#ifndef INCLUDED_BSLALG_RBTREEUTIL
#include &lt;bslalg_rbtreeutil.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SWAPUTIL
#include &lt;bslalg_swaputil.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITHASSTLITERATORS
#include &lt;bslalg_typetraithasstliterators.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#include &lt;bsls_performancehint.h&gt;
#endif

#ifndef INCLUDED_FUNCTIONAL
#include &lt;functional&gt;
#define INCLUDED_FUNCTIONAL
#endif

namespace bsl {

                             // ==============
                             // class multimap
                             // ==============

template &lt;class KEY,
          class VALUE,
          class COMPARATOR  = std::less&lt;KEY&gt;,
          class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt; &gt;
class multimap {
    // This class template implements a value-semantic container type holding
    // an ordered sequence of key-value pairs having possibly duplicate keys
    // that provide a mapping from keys (of the template parameter type, &#39;KEY&#39;)
    // to their associated values (of another template parameter type,
    // &#39;VALUE&#39;).
    //
    // This class:
    //: o supports a complete set of *value-semantic* operations
    //:   o except for &#39;bdex&#39; serialization
    //: o is *exception-neutral* (agnostic except for the &#39;at&#39; method)
    //: o is *alias-safe*
    //: o is &#39;const&#39; *thread-safe*
    // For terminology see {&#39;bsldoc_glossary&#39;}.

    // PRIVATE TYPES
    typedef bsl::pair&lt;const KEY, VALUE&gt; ValueType;
        // This typedef is an alias for the type of key-value pair objects
        // maintained by this multimap.

    typedef BloombergLP::bslstl::MapComparator&lt;KEY, VALUE, COMPARATOR&gt;
                                                                    Comparator;
        // This typedef is an alias for the comparator used internally by this
        // multimap.

    typedef BloombergLP::bslstl::TreeNode&lt;ValueType&gt; Node;
        // This typedef is an alias for the type of nodes held by the tree (of
        // nodes) used to implement this multimap.

    typedef BloombergLP::bslstl::TreeNodePool&lt;ValueType, ALLOCATOR&gt;
                                                                   NodeFactory;
        // This typedef is an alias for the factory type used to create and
        // destroy &#39;Node&#39; objects.

    typedef typename bsl::allocator_traits&lt;ALLOCATOR&gt; AllocatorTraits;
        // This typedef is an alias for the allocator traits type associated
        // with this container.

    struct DataWrapper : public Comparator {
        // This struct is wrapper around the comparator and allocator data
        // members.  It takes advantage of the empty-base optimization (EBO) so
        // that if the allocator is stateless, it takes up no space.
        //
        // TBD: This struct should eventually be replaced by the use of a
        // general EBO-enabled component that provides a &#39;pair&#39;-like interface
        // or a &#39;tuple&#39;.

        NodeFactory d_pool;  // pool of &#39;Node&#39; objects

        explicit DataWrapper(const COMPARATOR&amp;  comparator,
                             const ALLOCATOR&amp;   basicAllocator);
            // Create a &#39;DataWrapper&#39; object with the specified &#39;comparator&#39;
            // and &#39;basicAllocator&#39;.
    };

    // DATA
    DataWrapper                       d_compAndAlloc;
                                               // comparator and pool of &#39;Node&#39;
                                               // objects

    BloombergLP::bslalg::RbTreeAnchor d_tree;  // balanced tree of &#39;Node&#39;
                                               // objects

  private:
    // PRIVATE MANIPULATORS
    NodeFactory&amp; nodeFactory();
        // Return a reference providing modifiable access to the
        // node-allocator for this tree.

    Comparator&amp; comparator();
        // Return a reference providing modifiable access to the comparator for
        // this tree.

    void quickSwap(multimap&amp; other);
        // Efficiently exchange the value and comparator of this object with
        // the value of the specified &#39;other&#39; object.  This method provides the
        // no-throw exception-safety guarantee.  The behavior is undefined
        // unless this object was created with the same allocator as &#39;other&#39;.

    // PRIVATE ACCESSORS
    const NodeFactory&amp; nodeFactory() const;
        // Return a reference providing non-modifiable access to the
        // node-allocator for this tree.

    const Comparator&amp; comparator() const;
        // Return a reference providing non-modifiable access to the comparator
        // for this tree.

  public:
    // PUBLIC TYPES
    typedef KEY                                        key_type;
    typedef VALUE                                      mapped_type;
    typedef bsl::pair&lt;const KEY, VALUE&gt;                value_type;
    typedef COMPARATOR                                 key_compare;
    typedef ALLOCATOR                                  allocator_type;
    typedef value_type&amp;                                reference;
    typedef const value_type&amp;                          const_reference;

    typedef typename AllocatorTraits::size_type        size_type;
    typedef typename AllocatorTraits::difference_type  difference_type;
    typedef typename AllocatorTraits::pointer          pointer;
    typedef typename AllocatorTraits::const_pointer    const_pointer;

    typedef BloombergLP::bslstl::TreeIterator&lt;value_type,
                                              Node,
                                              difference_type&gt; iterator;
    typedef BloombergLP::bslstl::TreeIterator&lt;const value_type,
                                              Node,
                                              difference_type&gt; const_iterator;

    typedef bsl::reverse_iterator&lt;iterator&gt;            reverse_iterator;
    typedef bsl::reverse_iterator&lt;const_iterator&gt;      const_reverse_iterator;

    class value_compare {
        // This nested class defines a mechanism for comparing two objects of
        // the (template parameter) type &#39;COMPARATOR&#39;.  Note that this class
        // exactly matches its definition in the C++11 standard [23.4.5.1];
        // otherwise we would have implemented it as a separate component-local
        // class.

        // FRIENDS
        friend class multimap;
      protected:
        COMPARATOR comp;  // we would not have elected to make this data
                          // member protected ourselves

        value_compare(COMPARATOR c);                                // IMPLICIT
            // Create a &#39;value_compare&#39; object that will delegate to the
            // specified &#39;comparator&#39; for comparisons.

      public:
        typedef bool result_type;
            // This &#39;typedef&#39; is an alias for the result type of a call to the
            // overload of &#39;operator()&#39; (the comparison function) provided by a
            // &#39;multimap::value_compare&#39; object.

        typedef value_type first_argument_type;
            // This &#39;typedef&#39; is an alias for the type of the first parameter
            // of the overload of &#39;operator()&#39; (the comparison function)
            // provided by a &#39;multimap::value_compare&#39; object.

        typedef value_type second_argument_type;
            // This &#39;typedef&#39; is an alias for the type of the second parameter
            // of the overload of &#39;operator()&#39; (the comparison function)
            // provided by a &#39;multimap::value_compare&#39; object.

        bool operator()(const value_type&amp; x, const value_type&amp; y) const;
            // Return &#39;true&#39; if the specified &#39;x&#39; object is ordered before the
            // specified &#39;y&#39; object, as determined by the comparator supplied
            // at construction.
    };

  public:
    // CREATORS
    explicit multimap(const COMPARATOR&amp; comparator     = COMPARATOR(),
                      const ALLOCATOR&amp;  basicAllocator = ALLOCATOR())
        // Construct an empty multimap.  Optionally specify a &#39;comparator&#39; used
        // to order key-value pairs contained in this object.  If &#39;comparator&#39;
        // is not supplied, a default-constructed object of the (template
        // parameter) type &#39;COMPARATOR&#39; is used.  Optionally specify the
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is not
        // supplied, a default-constructed object of the (template parameter)
        // type ALLOCATOR&#39; is used.  If the &#39;ALLOCATOR&#39; argument is of type
        // &#39;bsl::allocator&#39; (the default), then &#39;basicAllocator&#39;, if supplied,
        // shall be convertible to &#39;bslma::Allocator *&#39;.  If the &#39;ALLOCATOR&#39;
        // argument is of type &#39;bsl::allocator&#39; and &#39;basicAllocator&#39; is not
        // supplied, the currently installed default allocator is used to
        // supply memory.
    : d_compAndAlloc(comparator, basicAllocator)
    , d_tree()
    {
        // The implementation is placed here in the class definition to
        // workaround an AIX compiler bug, where the constructor can fail to
        // compile because it is unable to find the definition of the default
        // argument.  This occurs when a templatized class wraps around the
        // container and the comparator is defined after the new class.
    }

    explicit multimap(const ALLOCATOR&amp; basicAllocator);
        // Construct an empty multimap that will use the specified
        // &#39;basicAllocator&#39; to supply memory.  Use a default-constructed object
        // of the (template parameter) type &#39;COMPARATOR&#39; to order the key-value
        // pairs contained in this multimap.  If the template parameter
        // &#39;ALLOCATOR&#39; argument is of type &#39;bsl::allocator&#39; (the default), then
        // &#39;basicAllocator&#39; shall be convertible to &#39;bslma::Allocator *&#39;.

    multimap(const multimap&amp; original);
        // Construct a multimap having the same value as the specified
        // &#39;original&#39;.  Use a copy of &#39;original.key_comp()&#39; to order the
        // key-value pairs contained in this multimap.  Use the allocator
        // returned by &#39;bsl::allocator_traits&lt;ALLOCATOR&gt;::
        // select_on_container_copy_construction(original.allocator())&#39; to
        // allocate memory.  If the (template parameter) type &#39;ALLOCATOR&#39; is of
        // type &#39;bsl::allocator&#39; (the default), the currently installed default
        // allocator is used to supply memory.  Note that this method requires
        // that the (template parameter) types &#39;KEY&#39; and &#39;VALUE&#39; both be
        // &quot;copy-constructible&quot; (see {Requirements on &#39;KEY&#39; and &#39;VALUE&#39;}).

    multimap(const multimap&amp; original, const ALLOCATOR&amp; basicAllocator);
        // Construct a multimap having the same value as that of the specified
        // &#39;original&#39; that will use the specified &#39;basicAllocator&#39; to supply
        // memory.  Use a copy of &#39;original.key_comp()&#39; to order the key-value
        // pairs contained in this multimap.  If the template parameter
        // &#39;ALLOCATOR&#39; argument is of type &#39;bsl::allocator&#39; (the default), then
        // &#39;basicAllocator&#39; shall be convertible to &#39;bslma::Allocator *&#39;.  Note
        // that this method requires that the (template parameter) types &#39;KEY&#39;
        // and &#39;VALUE&#39; both be &quot;copy-constructible&quot; (see {Requirements on &#39;KEY&#39;
        // and &#39;VALUE&#39;}).

    template &lt;class INPUT_ITERATOR&gt;
    multimap(INPUT_ITERATOR    first,
             INPUT_ITERATOR    last,
             const COMPARATOR&amp; comparator = COMPARATOR(),
             const ALLOCATOR&amp;  basicAllocator = ALLOCATOR());
        // Construct a multimap, and insert each &#39;value_type&#39; object in the
        // sequence starting at the specified &#39;first&#39; element, and ending
        // immediately before the specified &#39;last&#39; element, ignoring those
        // pairs having a key that appears earlier in the sequence.  Optionally
        // specify a &#39;comparator&#39; used to order key-value pairs contained in
        // this object.  If &#39;comparator&#39; is not supplied, a default-constructed
        // object of the (template parameter) type &#39;COMPARATOR&#39; is used.
        // Optionally specify the &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is not supplied, a default-constructed object of
        // the (template parameter) type &#39;ALLOCATOR&#39; is used.  If the template
        // parameter &#39;ALLOCATOR&#39; argument is of type &#39;bsl::allocator&#39; (the
        // default), then &#39;basicAllocator&#39;, if supplied, shall be convertible
        // to &#39;bslma::Allocator *&#39;.  If the template parameter &#39;ALLOCATOR&#39;
        // argument is of type &#39;bsl::allocator&#39; and &#39;basicAllocator&#39; is not
        // supplied, the currently installed default allocator is used to
        // supply memory.  If the sequence &#39;first&#39; and &#39;last&#39; is ordered
        // according to the identified &#39;comparator&#39;, then this operation has
        // &#39;O[N]&#39; complexity, where &#39;N&#39; is the number of elements between
        // &#39;first&#39; and &#39;last&#39;, otherwise this operation has &#39;O[N * log(N)]&#39;
        // complexity.  The (template parameter) type &#39;INPUT_ITERATOR&#39; shall
        // meet the requirements of an input iterator defined in the C++11
        // standard [24.2.3] providing access to values of a type convertible
        // to &#39;value_type&#39;.  The behavior is undefined unless &#39;first&#39; and
        // &#39;last&#39; refer to a sequence of valid values where &#39;first&#39; is at a
        // position at or before &#39;last&#39;.  Note that this method requires that
        // the (template parameter) types &#39;KEY&#39; and &#39;VALUE&#39; both be
        // &quot;copy-constructible&quot; (see {Requirements on &#39;KEY&#39; and &#39;VALUE&#39;}).

    ~multimap();
        // Destroy this object;

    // MANIPULATORS
    multimap&amp; operator=(const multimap&amp; rhs);
        // Assign to this object the value and comparator of the specified
        // &#39;rhs&#39; object, propagate to this object the allocator of &#39;rhs&#39; if the
        // &#39;ALLOCATOR&#39; type has trait &#39;propagate_on_container_copy_assignment&#39;,
        // and return a reference providing modifiable access to this object.
        // Note that this method requires that the (template parameter) types
        // &#39;KEY&#39; and &#39;VALUE&#39; both be &quot;copy-constructible&quot; (see {Requirements on
        // &#39;KEY&#39; and &#39;VALUE&#39;}).

    iterator begin();
        // Return an iterator providing modifiable access to the first
        // &#39;value_type&#39; object in the ordered sequence of &#39;value_type&#39; objects
        // maintained by this multimap, or the &#39;end&#39; iterator if this multimap
        // is empty.

    iterator end();
        // Return an iterator providing modifiable access to the past-the-end
        // element in the ordered sequence of &#39;value_type&#39; objects maintained
        // by this multimap.

    reverse_iterator rbegin();
        // Return a reverse iterator providing modifiable access to the last
        // &#39;value_type&#39; object in the ordered sequence of &#39;value_type&#39; objects
        // maintained by this multimap, or &#39;rend&#39; if this multimap is empty.

    reverse_iterator rend();
        // Return a reverse iterator providing modifiable access to the
        // prior-to-the-beginning element in the ordered sequence of
        // &#39;value_type&#39; objects maintained by this multimap.

    iterator insert(const value_type&amp; value);
        // Insert the specified &#39;value&#39; into this multimap.  If a range
        // containing elements equivalent to &#39;value&#39; already exist, insert
        // &#39;value&#39; at the end of that range.  Return an iterator referring to
        // the newly inserted &#39;value_type&#39; object.  Note that this method
        // requires that the (template parameter) types &#39;KEY&#39; and &#39;VALUE&#39; both
        // be &quot;copy-constructible&quot; (see {Requirements on &#39;KEY&#39; and &#39;VALUE&#39;}).

    iterator insert(const_iterator hint, const value_type&amp; value);
        // Insert the specified &#39;value&#39; into this multimap as close as possible
        // to the position just prior to the specified &#39;hint&#39; (in amortized
        // constant time if the &#39;hint&#39; is a valid immediate successor to the
        // key of &#39;value&#39;).  If &#39;hint&#39; is not a valid immediate successor to
        // the key of &#39;value&#39;, this operation has &#39;O[log(N)]&#39; complexity, where
        // &#39;N&#39; is the size of this multimap.  The behavior is undefined unless
        // &#39;hint&#39; is a valid iterator into this multimap.  Note that this
        // method requires that the (template parameter) types &#39;KEY&#39; and
        // &#39;VALUE&#39; both be &quot;copy-constructible&quot; (see {Requirements on &#39;KEY&#39; and
        // &#39;VALUE&#39;}).

    template &lt;class INPUT_ITERATOR&gt;
    void insert(INPUT_ITERATOR first, INPUT_ITERATOR last);
        // Insert into this multimap the value of each &#39;value_type&#39; object in
        // the range starting at the specified &#39;first&#39; iterator and ending
        // immediately before the specified &#39;last&#39; iterator.  The (template
        // parameter) type &#39;INPUT_ITERATOR&#39; shall meet the requirements of an
        // input iterator defined in the C++11 standard [24.2.3] providing
        // access to values of a type convertible to &#39;value_type&#39;.  The
        // behavior is undefined unless &#39;first&#39; and &#39;last&#39; refer to a sequence
        // of valid values where &#39;first&#39; is at a position at or before &#39;last&#39;.
        // Note that this method requires that the (template parameter) types
        // &#39;KEY&#39; and &#39;VALUE&#39; both be &quot;copy-constructible&quot; (see {Requirements on
        // &#39;KEY&#39; and &#39;VALUE&#39;}).

    iterator erase(const_iterator position);
        // Remove from this multimap the &#39;value_type&#39; object at the specified
        // &#39;position&#39;, and return an iterator referring to the element
        // immediately following the removed element, or to the past-the-end
        // position if the removed element was the last element in the sequence
        // of elements maintained by this multimap.  The behavior is undefined
        // unless &#39;position&#39; refers to a &#39;value_type&#39; object in this multimap.

    size_type erase(const key_type&amp; key);
        // Remote from this multimap all &#39;value_type&#39; objects having the
        // specified &#39;key&#39;, if they exist, and return the number of erased
        // objects; otherwise, if there is no &#39;value_type&#39; objects having
        // &#39;key&#39;, return 0 with no other effect.

    iterator erase(const_iterator first, const_iterator last);
        // Remove from this multimap the &#39;value_type&#39; objects starting at the
        // specified &#39;first&#39; position up to, but including the specified &#39;last&#39;
        // position, and return &#39;last&#39;.  The behavior is undefined unless
        // &#39;first&#39; and &#39;last&#39; either refer to elements in this multimap or are
        // the &#39;end&#39; iterator, and the &#39;first&#39; position is at or before the
        // &#39;last&#39; position in the ordered sequence provided by this container.

    void swap(multimap&amp; other);
        // Exchange the value of this object as well as its comparator with
        // those of the specified &#39;other&#39; object.  Additionally, if
        // &#39;bslstl::AllocatorTraits&lt;ALLOCATOR&gt;::propagate_on_container_swap&#39; is
        // &#39;true&#39;, then exchange the allocator of this object with that of the
        // &#39;other&#39; object, and do not modify either allocator otherwise.  This
        // method provides the no-throw exception-safety guarantee and
        // guarantees &#39;O[1]&#39; complexity.  The behavior is undefined unless
        // either this object was created with the same allocator as &#39;other&#39; or
        // &#39;propagate_on_container_swap&#39; is &#39;true&#39;.

    void clear();
        // Remove all entries from this multimap.  Note that the multimap is
        // empty after this call, but allocated memory may be retained for
        // future use.

    iterator find(const key_type&amp; key);
        // Return an iterator providing modifiable access to the first
        // &#39;value_type&#39; object having the specified &#39;key&#39; in ordered sequence
        // maintained by this multimap, if such an object exists; otherwise,
        // return the past-the-end (&#39;end&#39;) iterator.

    iterator lower_bound(const key_type&amp; key);
        // Return an iterator providing modifiable access to the first (i.e.,
        // ordered least) &#39;value_type&#39; object in this multimap whose key is
        // greater-than or equal-to the specified &#39;key&#39;, and the past-the-end
        // iterator if this multimap does not contain a &#39;value_type&#39; object
        // whose key is greater-than or equal-to &#39;key&#39;.  Note that this
        // function returns the *first* position before which a &#39;value_type&#39;
        // object having &#39;key&#39; could be inserted into the ordered sequence
        // maintained by this multimap, while preserving its ordering.

    iterator upper_bound(const key_type&amp; key);
        // Return an iterator providing modifiable access to the first (i.e.,
        // ordered least) &#39;value_type&#39; object in this multimap whose key is
        // greater than the specified &#39;key&#39;, and the past-the-end iterator if
        // this multimap does not contain a &#39;value_type&#39; object whose key is
        // greater-than &#39;key&#39;.  Note that this function returns the *last*
        // position before which a &#39;value_type&#39; object having &#39;key&#39; could be
        // inserted into the ordered sequence maintained by this multimap,
        // while preserving its ordering.

    bsl::pair&lt;iterator,iterator&gt; equal_range(const key_type&amp; key);
        // Return a pair of iterators providing modifiable access to the
        // sequence of &#39;value_type&#39; objects in this multimap having the
        // specified &#39;key&#39;, where the the first iterator is positioned at the
        // start of the sequence, and the second is positioned one past the end
        // of the sequence.  The first returned iterator will be
        // &#39;lower_bound(key)&#39;; the second returned iterator will be
        // &#39;upper_bound(key)&#39;; and, if this multimap contains no &#39;value_type&#39;
        // objects having &#39;key&#39;, then the two returned iterators will have the
        // same value.

    // ACCESSORS
    allocator_type get_allocator() const;
        // Return (a copy of) the allocator used for memory allocation by this
        // multimap.

    const_iterator begin() const;
        // Return an iterator providing non-modifiable access to the first
        // &#39;value_type&#39; object in the ordered sequence of &#39;value_type&#39; objects
        // maintained by this multimap, or the &#39;end&#39; iterator if this multimap
        // is empty.

    const_iterator end() const;
        // Return an iterator providing non-modifiable access to the
        // past-the-end element in the ordered sequence of &#39;value_type&#39; objects
        // maintained by this multimap.

    const_reverse_iterator rbegin() const;
        // Return a reverse iterator providing non-modifiable access to the
        // last &#39;value_type&#39; object in the ordered sequence of &#39;value_type&#39;
        // objects maintained by this multimap, or &#39;rend&#39; if this multimap is
        // empty.

    const_reverse_iterator rend() const;
        // Return a reverse iterator providing non-modifiable access to the
        // prior-to-the-beginning element in the ordered sequence of
        // &#39;value_type&#39; objects maintained by this multimap.

    const_iterator cbegin() const;
        // Return an iterator providing non-modifiable access to the first
        // &#39;value_type&#39; object in the ordered sequence of &#39;value_type&#39; objects
        // maintained by this multimap, or the &#39;cend&#39; iterator if this multimap
        // is empty.

    const_iterator cend() const;
        // Return an iterator providing non-modifiable access to the
        // past-the-end element in the ordered sequence of &#39;value_type&#39; objects
        // maintained by this multimap.

    const_reverse_iterator crbegin() const;
        // Return a reverse iterator providing non-modifiable access to the
        // last &#39;value_type&#39; object in the ordered sequence of &#39;value_type&#39;
        // objects maintained by this multimap, or &#39;rend&#39; if this multimap is
        // empty.

    const_reverse_iterator crend() const;
        // Return a reverse iterator providing non-modifiable access to the
        // prior-to-the-beginning element in the ordered sequence of
        // &#39;value_type&#39; objects maintained by this multimap.

    bool empty() const;
        // Return &#39;true&#39; if this multimap contains no elements, and &#39;false&#39;
        // otherwise.

    size_type size() const;
        // Return the number of elements in this multimap.

    size_type max_size() const;
        // Return a theoretical upper bound on the largest number of elements
        // that this multimap could possibly hold.  Note that there is no
        // guarantee that the multimap can successfully grow to the returned
        // size, or even close to that size without running out of resources.

    key_compare key_comp() const;
        // Return the key-comparison functor (or function pointer) used by this
        // multimap; if a comparator was supplied at construction, return its
        // value, otherwise return a default constructed &#39;key_compare&#39; object.
        // Note that this comparator compares objects of type &#39;KEY&#39;, which is
        // the key part of the &#39;value_type&#39; objects contained in this multimap.

    value_compare value_comp() const;
        // Return a functor for comparing two &#39;value_type&#39; objects by comparing
        // their respective keys using &#39;key_comp()&#39;.   Note that this
        // comparator compares objects of type &#39;value_type&#39; (i.e.,
        // &#39;bsl::pair&lt;KEY, VALUE&gt;&#39;).

    const_iterator find(const key_type&amp; key) const;
        // Return an iterator providing non-modifiable access to the first
        // &#39;value_type&#39; object having the specified &#39;key&#39; in ordered sequence
        // maintained by this multimap, if such an object exists; otherwise,
        // return the past-the-end (&#39;end&#39;) iterator.

    size_type count(const key_type&amp; key) const;
        // Return the number of &#39;value_type&#39; objects within this multimap
        // having the specified &#39;key&#39;.

    const_iterator lower_bound(const key_type&amp; key) const;
        // Return an iterator providing non-modifiable access to the first
        // (i.e., ordered least) &#39;value_type&#39; object in this multimap whose key
        // is greater-than or equal-to the specified &#39;key&#39;, and the
        // past-the-end iterator if this multimap does not contain a
        // &#39;value_type&#39; object whose key is greater-than or equal-to &#39;key&#39;.
        // Note that this function returns the *first* position before which a
        // &#39;value_type&#39; object having &#39;key&#39; could be inserted into the ordered
        // sequence maintained by this multimap, while preserving its ordering.

    const_iterator upper_bound(const key_type&amp; key) const;
        // Return an iterator providing non-modifiable access to the first
        // (i.e., ordered least) &#39;value_type&#39; object in this multimap whose key
        // is greater than the specified &#39;key&#39;, and the past-the-end iterator
        // if this multimap does not contain a &#39;value_type&#39; object whose key is
        // greater-than &#39;key&#39;.  Note that this function returns the *last*
        // position before which a &#39;value_type&#39; object having &#39;key&#39; could be
        // inserted into the ordered sequence maintained by this multimap,
        // while preserving its ordering.

    bsl::pair&lt;const_iterator,const_iterator&gt; equal_range(
                                                    const key_type&amp; key) const;
        // Return a pair of iterators providing non-modifiable access to the
        // sequence of &#39;value_type&#39; objects in this multimap having the
        // specified &#39;key&#39;, where the the first iterator is positioned at the
        // start of the sequence, and the second is positioned one past the end
        // of the sequence.  The first returned iterator will be
        // &#39;lower_bound(key)&#39;; the second returned iterator will be
        // &#39;upper_bound(key)&#39;; and, if this multimap contains no &#39;value_type&#39;
        // objects having &#39;key&#39;, then the two returned iterators will have the
        // same value.

    // NOT IMPLEMENTED
        // The following methods are defined by the C++11 standard, but they
        // are not implemented as they require some level of C++11 compiler
        // support not currently available on all supported platforms.

    //  multimap(multimap&lt;KEY,VALUE,COMPARATOR,ALLOCATOR&gt;&amp;&amp; original);

    //  multimap(multimap&amp;&amp;, const ALLOCATOR&amp;);

    //  multimap(initializer_list&lt;value_type&gt;,
    //           const COMPARATOR&amp; = COMPARATOR(),
    //           const ALLOCATOR&amp; = ALLOCATOR());

    //  multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp;
    //  operator=(multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp;&amp; rhs);


    //  multimap&amp; operator=(initializer_list&lt;value_type&gt;);

    //  template &lt;class... Args&gt; pair&lt;iterator, bool&gt; emplace(Args&amp;&amp;... args);

    //  template &lt;class... Args&gt; iterator emplace_hint(const_iterator position,
    //                                                 Args&amp;&amp;... args);

    //  template &lt;class P&gt; iterator insert(P&amp;&amp; value);

    //  template &lt;class P&gt;
    //  iterator insert(const_iterator position, P&amp;&amp;);

    //  void insert(initializer_list&lt;value_type&gt;);
};

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
bool operator==(const multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; lhs,
                const multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;multimap&#39; objects have the same
    // value if they have the same number of key-value pairs, and each
    // key-value pair that is contained in one of the objects is also contained
    // in the other object.  Note that this method requires that the (template
    // parameter) types &#39;KEY&#39; and &#39;VALUE&#39; both be &quot;equality-comparable&quot; (see
    // {Requirements on &#39;KEY&#39; and &#39;VALUE&#39;}).

template &lt;class KEY,  class VALUE,  class COMPARATOR,  class ALLOCATOR&gt;
bool operator!=(const multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; lhs,
                const multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same value, and &#39;false&#39; otherwise.  Two &#39;multimap&#39; objects do not have
    // the same value if they do not have the same number of key-value pairs,
    // or some key-value pair that is contained in one of the objects is not
    // also contained in the other object.  Note that this method requires that
    // the (template parameter) types &#39;KEY&#39; and &#39;VALUE&#39; types both be
    // &quot;equality-comparable&quot; (see {Requirements on &#39;KEY&#39; and &#39;VALUE&#39;}).

template &lt;class KEY,  class VALUE,  class COMPARATOR,  class ALLOCATOR&gt;
bool operator&lt;(const multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; lhs,
               const multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; value is less than the specified
    // &#39;rhs&#39; value, and &#39;false&#39; otherwise.  A multimap, &#39;lhs&#39;, has a value that
    // is less than that of &#39;rhs&#39;, if, for the first non-equal corresponding
    // key-value pairs in their respective sequences, the &#39;lhs&#39; key-value pair
    // is less than the &#39;rhs&#39; pair, or, if the keys of all of their
    // corresponding key-value pairs compare equal, &#39;lhs&#39; has fewer key-value
    // pairs than &#39;rhs&#39;.  Note that this method requires that the (template
    // parameter) types &#39;KEY&#39; and &#39;VALUE&#39; types both be &quot;less-than-comparable&quot;
    // (see {Requirements on &#39;KEY&#39; and &#39;VALUE&#39;}).

template &lt;class KEY,  class VALUE,  class COMPARATOR,  class ALLOCATOR&gt;
bool operator&gt;(const multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; lhs,
               const multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; value is greater than the specified
    // &#39;rhs&#39; value, and &#39;false&#39; otherwise.  A multimap, &#39;lhs&#39;, has a value that
    // is greater than that of &#39;rhs&#39;, if, for the first non-equal corresponding
    // key-value pairs in their respective sequences, the &#39;lhs&#39; key-value pair
    // is greater than the &#39;rhs&#39; pair, or, if the keys of all of their
    // corresponding key-value pairs compare equal, &#39;lhs&#39; has more key-value
    // pairs than &#39;rhs&#39;.  Note that this method requires that the (template
    // parameter) types &#39;KEY&#39; and &#39;VALUE&#39; both be &quot;less-than-comparable&quot; (see
    // {Requirements on &#39;KEY&#39; and &#39;VALUE&#39;}).

template &lt;class KEY,  class VALUE,  class COMPARATOR,  class ALLOCATOR&gt;
bool operator&lt;=(const multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; lhs,
                const multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; value is less-than or equal-to the
    // specified &#39;rhs&#39; value, and &#39;false&#39; otherwise.  A multimap, &#39;lhs&#39;, has a
    // value that is less-than or equal-to that of &#39;rhs&#39;, if, for the first
    // non-equal corresponding key-value pairs in their respective sequences,
    // the &#39;lhs&#39; key-value pair is less than the &#39;rhs&#39; pair, or, if the keys of
    // all of their corresponding key-value pairs compare equal, &#39;lhs&#39; has
    // less-than or equal number of key-value pairs as &#39;rhs&#39;.  Note that this
    // method requires that the (template parameter) types &#39;KEY&#39; and &#39;VALUE&#39;
    // both be &quot;less-than-comparable&quot; (see {Requirements on &#39;KEY&#39; and
    // &#39;VALUE&#39;}).

template &lt;class KEY,  class VALUE,  class COMPARATOR,  class ALLOCATOR&gt;
bool operator&gt;=(const multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; lhs,
                const multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; value is greater-than or equal-to
    // the specified &#39;rhs&#39; value, and &#39;false&#39; otherwise.  A multimap, &#39;lhs&#39;,
    // has a value that is greater-than or equal-to that of &#39;rhs&#39;, if, for the
    // first non-equal corresponding key-value pairs in their respective
    // sequences, the &#39;lhs&#39; key-value pair is greater than the &#39;rhs&#39; pair, or,
    // if the keys of all of their corresponding key-value pairs compare equal,
    // &#39;lhs&#39; has greater-than or equal number of key-value pairs as &#39;rhs&#39;.
    // Note that this method requires that the (template parameter) types &#39;KEY&#39;
    // and &#39;VALUE&#39; types both be &quot;less-than-comparable&quot; (see {Requirements on
    // &#39;KEY&#39; and &#39;VALUE&#39;}).

template &lt;class KEY,  class VALUE,  class COMPARATOR,  class ALLOCATOR&gt;
void swap(multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; a,
          multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; b);
    // Swap both the value and the comparator of the specified &#39;a&#39; object with
    // the value and comparator of the specified &#39;b&#39; object.  Additionally, if
    // &#39;bslstl::AllocatorTraits&lt;ALLOCATOR&gt;::propagate_on_container_swap&#39; is
    // &#39;true&#39;, then exchange the allocator of &#39;a&#39; with that of &#39;b&#39;, and do not
    // modify either allocator otherwise.  This method provides the no-throw
    // exception-safety guarantee and guarantees &#39;O[1]&#39; complexity.  The
    // behavior is undefined unless either this object was created with the
    // same allocator as &#39;other&#39; or &#39;propagate_on_container_swap&#39; is &#39;true&#39;.

// ============================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ============================================================================

                             // -----------------
                             // class DataWrapper
                             // -----------------

// CREATORS
template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::DataWrapper::DataWrapper(
                                              const COMPARATOR&amp; comparator,
                                              const ALLOCATOR&amp;  basicAllocator)
: ::bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::Comparator(comparator)
, d_pool(basicAllocator)
{
}

                             // -----------------------------
                             // class multimap::value_compare
                             // -----------------------------

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::value_compare::value_compare(
                                                                  COMPARATOR c)
: comp(c)
{
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
bool multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::value_compare::operator()(
                                                     const value_type&amp; x,
                                                     const value_type&amp; y) const
{
    return comp(x.first, y.first);
}

                             // --------------
                             // class multimap
                             // --------------

// PRIVATE MANIPULATORS
template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::NodeFactory&amp;
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::nodeFactory()
{
    return d_compAndAlloc.d_pool;
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::Comparator&amp;
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::comparator()
{
    return d_compAndAlloc;
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
void multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::quickSwap(multimap&amp; other)
{
    BloombergLP::bslalg::RbTreeUtil::swap(&amp;d_tree, &amp;other.d_tree);
    nodeFactory().swap(other.nodeFactory());

    // Work around to avoid the 1-byte swap problem on AIX for an empty class
    // under empty-base optimization.

    if (sizeof(NodeFactory) != sizeof(DataWrapper)) {
        comparator().swap(other.comparator());
    }
}

// PRIVATE ACCESSORS
template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
const typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::NodeFactory&amp;
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::nodeFactory() const
{
    return d_compAndAlloc.d_pool;
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
const typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::Comparator&amp;
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::comparator() const
{
    return d_compAndAlloc;
}

// CREATORS
template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
template &lt;class INPUT_ITERATOR&gt;
inline
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::multimap(
                                              INPUT_ITERATOR    first,
                                              INPUT_ITERATOR    last,
                                              const COMPARATOR&amp; comparator,
                                              const ALLOCATOR&amp;  basicAllocator)
: d_compAndAlloc(comparator, basicAllocator)
, d_tree()
{
    if (first != last) {
        BloombergLP::bslalg::RbTreeUtilTreeProctor&lt;NodeFactory&gt; proctor(
                                                               &amp;d_tree,
                                                               &amp;nodeFactory());

        // The following loop guarantees amortized linear time to insert an
        // ordered sequence of values (as required by the standard).   If the
        // values are in sorted order, we are guaranteed the next node can be
        // inserted as the right child of the previous node, and can call
        // &#39;insertAt&#39; without &#39;findUniqueInsertLocation&#39;.

        insert(*first);
        BloombergLP::bslalg::RbTreeNode *prevNode = d_tree.rootNode();
        while (++first != last) {
            // The values are not in order, so insert them normally.

            const value_type&amp; value = *first;
            if (this-&gt;comparator()(value.first, *prevNode)) {
                insert(value);
                insert(++first, last);
                break;
            }
            BloombergLP::bslalg::RbTreeNode *node = nodeFactory().createNode(
                                                                        value);
            BloombergLP::bslalg::RbTreeUtil::insertAt(&amp;d_tree,
                                                      prevNode,
                                                      false,
                                                      node);
            prevNode = node;
        }
        proctor.release();
    }
}


template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::multimap(const multimap&amp; original)
: d_compAndAlloc(original.comparator().keyComparator(),
                 AllocatorTraits::select_on_container_copy_construction(
                                           original.nodeFactory().allocator()))
, d_tree()
{
    if (0 &lt; original.size()) {
        nodeFactory().reserveNodes(original.size());
        BloombergLP::bslalg::RbTreeUtil::copyTree(&amp;d_tree,
                                                  original.d_tree,
                                                  &amp;nodeFactory());
    }
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::multimap(
                                               const ALLOCATOR&amp; basicAllocator)
: d_compAndAlloc(COMPARATOR(), basicAllocator)
, d_tree()
{
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::multimap(
                                               const multimap&amp;  original,
                                               const ALLOCATOR&amp; basicAllocator)
: d_compAndAlloc(original.comparator().keyComparator(), basicAllocator)
, d_tree()
{
    if (0 &lt; original.size()) {
        nodeFactory().reserveNodes(original.size());
        BloombergLP::bslalg::RbTreeUtil::copyTree(&amp;d_tree,
                                                  original.d_tree,
                                                  &amp;nodeFactory());
    }
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::~multimap()
{
    clear();
}

// MANIPULATORS
template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp;
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::operator=(const multimap&amp; rhs)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(this != &amp;rhs)) {

        if (AllocatorTraits::propagate_on_container_copy_assignment::value) {
            multimap other(rhs, rhs.nodeFactory().allocator());
            BloombergLP::bslalg::SwapUtil::swap(
                                             &amp;nodeFactory().allocator(),
                                             &amp;other.nodeFactory().allocator());
            quickSwap(other);
        }
        else {
            multimap other(rhs, nodeFactory().allocator());
            quickSwap(other);
        }
    }
    return *this;
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::begin()
{
    return iterator(d_tree.firstNode());
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::end()
{
    return iterator(d_tree.sentinel());
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::reverse_iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::rbegin()
{
    return reverse_iterator(end());
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::reverse_iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::rend()
{
    return reverse_iterator(begin());
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::insert(const value_type&amp; value)
{
    bool leftChild;
    BloombergLP::bslalg::RbTreeNode *insertLocation =
        BloombergLP::bslalg::RbTreeUtil::findInsertLocation(&amp;leftChild,
                                                            &amp;d_tree,
                                                            this-&gt;comparator(),
                                                            value.first);
    BloombergLP::bslalg::RbTreeNode *node = nodeFactory().createNode(value);
    BloombergLP::bslalg::RbTreeUtil::insertAt(&amp;d_tree,
                                              insertLocation,
                                              leftChild,
                                              node);
    return iterator(node);
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
template &lt;class INPUT_ITERATOR&gt;
inline
void multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::insert(INPUT_ITERATOR first,
                                                         INPUT_ITERATOR last)
{
    while (first != last) {
        insert(*first);
        ++first;
    }
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::insert(const_iterator    hint,
                                                    const value_type&amp; value)
{
    BloombergLP::bslalg::RbTreeNode *hintNode =
                const_cast&lt;BloombergLP::bslalg::RbTreeNode *&gt;(hint.node());
    bool leftChild;
    BloombergLP::bslalg::RbTreeNode *insertLocation =
        BloombergLP::bslalg::RbTreeUtil::findInsertLocation(&amp;leftChild,
                                                            &amp;d_tree,
                                                            this-&gt;comparator(),
                                                            value.first,
                                                            hintNode);
    BloombergLP::bslalg::RbTreeNode *node = nodeFactory().createNode(value);
    BloombergLP::bslalg::RbTreeUtil::insertAt(&amp;d_tree,
                                              insertLocation,
                                              leftChild,
                                              node);
    return iterator(node);
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::erase(const_iterator position)
{
    BSLS_ASSERT_SAFE(position != end());

    BloombergLP::bslalg::RbTreeNode *node =
                const_cast&lt;BloombergLP::bslalg::RbTreeNode *&gt;(position.node());
    BloombergLP::bslalg::RbTreeNode *result =
                                   BloombergLP::bslalg::RbTreeUtil::next(node);
    BloombergLP::bslalg::RbTreeUtil::remove(&amp;d_tree, node);
    nodeFactory().deleteNode(node);
    return iterator(result);
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::size_type
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::erase(const key_type&amp; key)
{
    size_type count = 0;
    const_iterator first = find(key);
    if (first != end()) {
        const_iterator last = upper_bound(key);
        while (first != last) {
            first = erase(first);
            ++count;
        }
    }
    return count;
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::erase(const_iterator first,
                                                   const_iterator last)
{
    while (first != last) {
        first = erase(first);
    }
    return iterator(last.node());
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
void multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::swap(multimap&amp; other)
{
    if (AllocatorTraits::propagate_on_container_swap::value) {
        BloombergLP::bslalg::SwapUtil::swap(&amp;nodeFactory().allocator(),
                                            &amp;other.nodeFactory().allocator());
        quickSwap(other);
    }
    else {
        // C++11 behavior: undefined for unequal allocators
        // BSLS_ASSERT(allocator() == other.allocator());

        // backward compatible behavior: swap with copies
        if (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(
               nodeFactory().allocator() == other.nodeFactory().allocator())) {
            quickSwap(other);
        }
        else {
            BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
            multimap thisCopy(*this, other.nodeFactory().allocator());
            multimap otherCopy(other, nodeFactory().allocator());

            quickSwap(otherCopy);
            other.quickSwap(thisCopy);
        }
    }
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
void multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::clear()
{
    BSLS_ASSERT_SAFE(d_tree.firstNode());
    if (d_tree.rootNode()) {
        BSLS_ASSERT_SAFE(0 &lt; d_tree.numNodes());
        BSLS_ASSERT_SAFE(d_tree.firstNode() != d_tree.sentinel());

        BloombergLP::bslalg::RbTreeUtil::deleteTree(&amp;d_tree, &amp;nodeFactory());
    }
#if defined(BSLS_ASSERT_SAFE_IS_ACTIVE)
    else {
        BSLS_ASSERT_SAFE(0 == d_tree.numNodes());
        BSLS_ASSERT_SAFE(d_tree.firstNode() == d_tree.sentinel());
    }
#endif
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::find(const key_type&amp; key)
{
    return iterator(BloombergLP::bslalg::RbTreeUtil::find(d_tree,
                                                          this-&gt;comparator(),
                                                          key));
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::lower_bound(const key_type&amp; key)
{
    return iterator(BloombergLP::bslalg::RbTreeUtil::lowerBound(
                                                            d_tree,
                                                            this-&gt;comparator(),
                                                            key));
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::upper_bound(const key_type&amp; key)
{
    return iterator(BloombergLP::bslalg::RbTreeUtil::upperBound(
                                                            d_tree,
                                                            this-&gt;comparator(),
                                                            key));
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
bsl::pair&lt;typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::iterator,
          typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::iterator&gt;
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::equal_range(const key_type&amp; key)
{
    iterator startIt = lower_bound(key);
    iterator endIt   = startIt;
    if (endIt != end() &amp;&amp; !comparator()(key, *endIt.node())) {
        endIt = upper_bound(key);
    }
    return bsl::pair&lt;iterator, iterator&gt;(startIt, endIt);
}

// ACCESSORS
template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::allocator_type
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::get_allocator() const
{
    return nodeFactory().allocator();
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::const_iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::begin() const
{
    return cbegin();
}


template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::const_iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::end() const
{
    return cend();
}


template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::const_reverse_iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::rbegin() const
{
    return crbegin();
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::const_reverse_iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::rend() const
{
    return crend();
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::const_iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::cbegin() const
{
    return const_iterator(d_tree.firstNode());
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::const_iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::cend() const
{
    return const_iterator(d_tree.sentinel());
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::const_reverse_iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::crbegin() const
{
    return const_reverse_iterator(end());
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::const_reverse_iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::crend() const
{
    return const_reverse_iterator(begin());
}

// capacity:
template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
bool multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::empty() const
{
    return 0 == d_tree.numNodes();
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::size_type
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::size() const
{
    return d_tree.numNodes();
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::size_type
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::max_size() const
{
    return AllocatorTraits::max_size(get_allocator());
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::key_compare
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::key_comp() const
{
    return comparator().keyComparator();
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::value_compare
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::value_comp() const
{
    return value_compare(key_comp());
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::const_iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::find(const key_type&amp; key) const
{
    return const_iterator(
       BloombergLP::bslalg::RbTreeUtil::find(d_tree, this-&gt;comparator(), key));
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE,COMPARATOR, ALLOCATOR&gt;::size_type
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::count(const key_type&amp; key) const
{
    int cnt = 0;
    const_iterator it = lower_bound(key);
    while (it != end() &amp;&amp; !comparator()(key, *it.node())) {
        ++it;
        ++cnt;
    }
    return cnt;
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::const_iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::lower_bound(
                                                     const key_type&amp; key) const
{
    return iterator(BloombergLP::bslalg::RbTreeUtil::lowerBound(
                                                            d_tree,
                                                            this-&gt;comparator(),
                                                            key));
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::const_iterator
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::upper_bound(
                                                     const key_type&amp; key) const
{
    return const_iterator(BloombergLP::bslalg::RbTreeUtil::upperBound(
                                                            d_tree,
                                                            this-&gt;comparator(),
                                                            key));
}

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
bsl::pair&lt;typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::const_iterator,
          typename multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::const_iterator&gt;
multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;::equal_range(
                                                     const key_type&amp; key) const
{
    const_iterator startIt = lower_bound(key);
    const_iterator endIt   = startIt;
    if (endIt != end() &amp;&amp; !comparator()(key, *endIt.node())) {
        endIt = upper_bound(key);
    }
    return bsl::pair&lt;const_iterator, const_iterator&gt;(startIt, endIt);
}

}  // close namespace bsl

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
inline
bool bsl::operator==(
                   const bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; lhs,
                   const bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; rhs)
{
    return BloombergLP::bslalg::RangeCompare::equal(lhs.begin(),
                                                    lhs.end(),
                                                    lhs.size(),
                                                    rhs.begin(),
                                                    rhs.end(),
                                                    rhs.size());
}

template &lt;class KEY,  class VALUE,  class COMPARATOR,  class ALLOCATOR&gt;
inline
bool bsl::operator!=(
                   const bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; lhs,
                   const bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; rhs)
{
    return !(lhs == rhs);
}

template &lt;class KEY,  class VALUE,  class COMPARATOR,  class ALLOCATOR&gt;
inline
bool bsl::operator&lt;(
                   const bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; lhs,
                   const bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; rhs)
{
    return 0 &gt; BloombergLP::bslalg::RangeCompare::lexicographical(lhs.begin(),
                                                                  lhs.end(),
                                                                  lhs.size(),
                                                                  rhs.begin(),
                                                                  rhs.end(),
                                                                  rhs.size());
}

template &lt;class KEY,  class VALUE,  class COMPARATOR,  class ALLOCATOR&gt;
inline
bool bsl::operator&gt;(
                   const bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; lhs,
                   const bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; rhs)
{
    return rhs &lt; lhs;
}

template &lt;class KEY,  class VALUE,  class COMPARATOR,  class ALLOCATOR&gt;
inline
bool bsl::operator&lt;=(
                   const bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; lhs,
                   const bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; rhs)
{
    return !(rhs &lt; lhs);
}


template &lt;class KEY,  class VALUE,  class COMPARATOR,  class ALLOCATOR&gt;
inline
bool bsl::operator&gt;=(
                   const bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; lhs,
                   const bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; rhs)
{
    return !(lhs &lt; rhs);
}

template &lt;class KEY,  class VALUE,  class COMPARATOR,  class ALLOCATOR&gt;
inline
void bsl::swap(bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; a,
               bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt;&amp; b)
{
    a.swap(b);
}

// ============================================================================
//                                TYPE TRAITS
// ============================================================================

// Type traits for STL *ordered* containers:
//: o An ordered container defines STL iterators.
//: o An ordered container uses &#39;bslma&#39; allocators if the parameterized
//:     &#39;ALLOCATOR&#39; is convertible from &#39;bslma::Allocator*&#39;.

namespace BloombergLP {

namespace bslalg {

template &lt;class KEY, class VALUE, class COMPARATOR, class ALLOCATOR&gt;
struct HasStlIterators&lt;bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt; &gt;
    : bsl::true_type
{};

}  // close namespace bslalg

namespace bslma {

template &lt;class KEY,   class VALUE, class COMPARATOR, class ALLOCATOR&gt;
struct UsesBslmaAllocator&lt;bsl::multimap&lt;KEY, VALUE, COMPARATOR, ALLOCATOR&gt; &gt;
    : bsl::is_convertible&lt;Allocator*, ALLOCATOR&gt;
{};

}  // close namespace bslma

}  // close enterprise namespace


#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
