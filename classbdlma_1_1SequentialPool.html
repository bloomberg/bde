<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlma::SequentialPool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlma.html">bdlma</a>      </li>
      <li><a class="el" href="classbdlma_1_1SequentialPool.html">bdlma::SequentialPool</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlma::SequentialPool Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlma::SequentialPool" -->
<p><code>#include &lt;<a class="el" href="bdlma__sequentialpool_8h_source.html">bdlma_sequentialpool.h</a>&gt;</code></p>

<p><a href="classbdlma_1_1SequentialPool-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#a9e303555f83bf8429e5713f699e48ac7">SequentialPool</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#ab21c4cc38b765e870dedf515cac11fc4">SequentialPool</a> (<a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#a6afe8d5c62dd6e313875b5aec4608952">SequentialPool</a> (<a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#a41a4c3e93200c0f030de47c7f2b8da83">SequentialPool</a> (<a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#ac167be6d95a57fef06a566b78e155e38">SequentialPool</a> (int initialSize, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#a44c88fa68b2784ddcc27482381fc8956">SequentialPool</a> (int initialSize, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#a3ac5f20bce2d9d60c3264ade1c82c65d">SequentialPool</a> (int initialSize, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#ae4262f6aea5dad7d10a102417ee2b8d6">SequentialPool</a> (int initialSize, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#a2af3c97c0a3288271c4cb70cc09a7c6b">SequentialPool</a> (int initialSize, int maxBufferSize, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#a6c414ccf3a50565735c1b49edcbc4a37">SequentialPool</a> (int initialSize, int maxBufferSize, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#a6a62e273e56407785e425a9bef7aa52a">SequentialPool</a> (int initialSize, int maxBufferSize, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#ac6aa847aa566ad48b36568d1e38e6115">SequentialPool</a> (int initialSize, int maxBufferSize, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#a38761f5ee52f66124b4d2da4ceec8b95">~SequentialPool</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#a579c04434bb73dd445512f11161b22da">allocate</a> (<a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a> size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#ab048257da5a57f4cc27e89eb294bd6b5">allocateAndExpand</a> (<a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a> *size)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#a873feeecd1c3b65b82b26d79302d67a8">deleteObjectRaw</a> (const TYPE *object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#a4d90a0efa766b57f06988ce9eb7e00f9">deleteObject</a> (const TYPE *object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#abfabe031af8ad173bcdb604f42dad5bb">release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#a18b0d488fe0f4bc7664fedcad55b0a4d">rewind</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#a56a831290d4f1bacccbe44bc6331c3f4">reserveCapacity</a> (int numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialPool.html#a6811148a5e1889268526a0e50b446ee7">truncate</a> (void *address, int originalSize, int newSize)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements a fast memory pool that efficiently dispenses heterogeneous blocks of memory (of varying, user-specified sizes) from a sequence of dynamically-allocated internal buffers. Memory for the internal buffers is supplied by an (optional) allocator supplied at construction; if no allocator is supplied, the currently installed default allocator is used. If an allocation exceeds the remaining free memory space in the current buffer, the pool replenishes its internal buffer with new memory to satisfy the request. This class is <em>exception</em> <em>neutral</em>: If memory cannot be allocated, the behavior is defined by the (optional) allocator specified at construction. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9e303555f83bf8429e5713f699e48ac7"></a><!-- doxytag: member="bdlma::SequentialPool::SequentialPool" ref="a9e303555f83bf8429e5713f699e48ac7" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialPool::SequentialPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab21c4cc38b765e870dedf515cac11fc4"></a><!-- doxytag: member="bdlma::SequentialPool::SequentialPool" ref="ab21c4cc38b765e870dedf515cac11fc4" args="(bsls::BlockGrowth::Strategy growthStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialPool::SequentialPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6afe8d5c62dd6e313875b5aec4608952"></a><!-- doxytag: member="bdlma::SequentialPool::SequentialPool" ref="a6afe8d5c62dd6e313875b5aec4608952" args="(bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialPool::SequentialPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a41a4c3e93200c0f030de47c7f2b8da83"></a><!-- doxytag: member="bdlma::SequentialPool::SequentialPool" ref="a41a4c3e93200c0f030de47c7f2b8da83" args="(bsls::BlockGrowth::Strategy growthStrategy, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialPool::SequentialPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a sequential pool for allocating memory blocks from a sequence of dynamically-allocated buffers. Optionally specify a <code>basicAllocator</code> used to supply memory for the dynamically-allocated buffers. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Optionally specify a <code>growthStrategy</code> used to control buffer growth. If no <code>growthStrategy</code> is specified, geometric growth is used. Optionally specify an <code>alignmentStrategy</code> used to control alignment of allocated memory blocks. If no <code>alignmentStrategy</code> is specified, natural alignment is used. An implementation-defined value is used as the initial size of the internal buffer. Note that no limit is imposed on the size of the internal buffers when geometric growth is used. Also note that when constant growth is used, the size of the internal buffers will always be the same as the implementation-defined value. </p>

</div>
</div>
<a class="anchor" id="ac167be6d95a57fef06a566b78e155e38"></a><!-- doxytag: member="bdlma::SequentialPool::SequentialPool" ref="ac167be6d95a57fef06a566b78e155e38" args="(int initialSize, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialPool::SequentialPool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a44c88fa68b2784ddcc27482381fc8956"></a><!-- doxytag: member="bdlma::SequentialPool::SequentialPool" ref="a44c88fa68b2784ddcc27482381fc8956" args="(int initialSize, bsls::BlockGrowth::Strategy growthStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialPool::SequentialPool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ac5f20bce2d9d60c3264ade1c82c65d"></a><!-- doxytag: member="bdlma::SequentialPool::SequentialPool" ref="a3ac5f20bce2d9d60c3264ade1c82c65d" args="(int initialSize, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialPool::SequentialPool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae4262f6aea5dad7d10a102417ee2b8d6"></a><!-- doxytag: member="bdlma::SequentialPool::SequentialPool" ref="ae4262f6aea5dad7d10a102417ee2b8d6" args="(int initialSize, bsls::BlockGrowth::Strategy growthStrategy, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialPool::SequentialPool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a sequential pool for allocating memory blocks from a sequence of dynamically-allocated buffers, of which the initial buffer has the specified <code>initialSize</code> (in bytes). Optionally specify a <code>basicAllocator</code> used to supply memory for the dynamically-allocated buffers. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Optionally specify a <code>growthStrategy</code> used to control buffer growth. If no <code>growthStrategy</code> is specified, geometric growth is used. Optionally specify an <code>alignmentStrategy</code> used to control alignment of allocated memory blocks. If no <code>alignmentStrategy</code> is specified, natural alignment is used. By specifying an <code>initialSize</code>, the construction of a sequential pool will incur a memory allocation. The behavior is undefined unless <code>0 &lt; initialSize</code>. Note that no limit is imposed on the size of the internal buffers when geometric growth is used. Also note that when constant growth is used, the size of the internal buffers will always be the same as <code>initialSize</code>. </p>

</div>
</div>
<a class="anchor" id="a2af3c97c0a3288271c4cb70cc09a7c6b"></a><!-- doxytag: member="bdlma::SequentialPool::SequentialPool" ref="a2af3c97c0a3288271c4cb70cc09a7c6b" args="(int initialSize, int maxBufferSize, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialPool::SequentialPool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6c414ccf3a50565735c1b49edcbc4a37"></a><!-- doxytag: member="bdlma::SequentialPool::SequentialPool" ref="a6c414ccf3a50565735c1b49edcbc4a37" args="(int initialSize, int maxBufferSize, bsls::BlockGrowth::Strategy growthStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialPool::SequentialPool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6a62e273e56407785e425a9bef7aa52a"></a><!-- doxytag: member="bdlma::SequentialPool::SequentialPool" ref="a6a62e273e56407785e425a9bef7aa52a" args="(int initialSize, int maxBufferSize, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialPool::SequentialPool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6aa847aa566ad48b36568d1e38e6115"></a><!-- doxytag: member="bdlma::SequentialPool::SequentialPool" ref="ac6aa847aa566ad48b36568d1e38e6115" args="(int initialSize, int maxBufferSize, bsls::BlockGrowth::Strategy growthStrategy, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialPool::SequentialPool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a sequential pool for allocating memory blocks from a sequence of dynamically-allocated buffers, of which the initial buffer has the specified <code>initialSize</code> (in bytes), and the internal buffer growth is limited to the specified <code>maxBufferSize</code>. Optionally specify a <code>basicAllocator</code> used to supply memory for the dynamically-allocated buffers. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Optionally specify a <code>growthStrategy</code> used to control buffer growth. If no <code>growthStrategy</code> is specified, geometric growth is used. Optionally specify an <code>alignmentStrategy</code> used to control alignment of allocated memory blocks. If no <code>alignmentStrategy</code> is specified, natural alignment is used. The behavior is undefined unless <code>0 &lt; initialSize</code> and <code>initialSize &lt;= maxBufferSize</code>. Note that when constant growth is used, the size of the internal buffers will always be the same as <code>initialSize</code>. </p>

</div>
</div>
<a class="anchor" id="a38761f5ee52f66124b4d2da4ceec8b95"></a><!-- doxytag: member="bdlma::SequentialPool::~SequentialPool" ref="a38761f5ee52f66124b4d2da4ceec8b95" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialPool::~SequentialPool </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this sequential pool. All memory allocated by this pool is released. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a579c04434bb73dd445512f11161b22da"></a><!-- doxytag: member="bdlma::SequentialPool::allocate" ref="a579c04434bb73dd445512f11161b22da" args="(bsls::Types::size_type size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bdlma::SequentialPool::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a contiguous block of memory of the specified <code>size</code> (in bytes) according to the alignment strategy specified at construction. If the allocation request exceeds the remaining free memory space in the current internal buffer, use the allocator supplied at construction to allocate a new internal buffer, then allocate memory from the new buffer. The behavior is undefined unless <code>0 &lt; size</code>. </p>

</div>
</div>
<a class="anchor" id="ab048257da5a57f4cc27e89eb294bd6b5"></a><!-- doxytag: member="bdlma::SequentialPool::allocateAndExpand" ref="ab048257da5a57f4cc27e89eb294bd6b5" args="(bsls::Types::size_type *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bdlma::SequentialPool::allocateAndExpand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a> *&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a contiguous block of memory of at least the specified <code>*size</code> (in bytes), and load the actual amount of memory allocated in <code>*size</code>. If the allocation request exceeds the remaining free memory space in the current internal buffer, use the allocator supplied at construction to allocate a new internal buffer, then allocate memory from the new buffer. The behavior is undefined unless <code>0 &lt; *size</code>. </p>

</div>
</div>
<a class="anchor" id="a873feeecd1c3b65b82b26d79302d67a8"></a><!-- doxytag: member="bdlma::SequentialPool::deleteObjectRaw" ref="a873feeecd1c3b65b82b26d79302d67a8" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::SequentialPool::deleteObjectRaw </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code>. Note that memory associated with <code>object</code> is not deallocated because there is no <code>deallocate</code> method in <code><a class="el" href="classbdlma_1_1SequentialPool.html">SequentialPool</a></code>. </p>

</div>
</div>
<a class="anchor" id="a4d90a0efa766b57f06988ce9eb7e00f9"></a><!-- doxytag: member="bdlma::SequentialPool::deleteObject" ref="a4d90a0efa766b57f06988ce9eb7e00f9" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::SequentialPool::deleteObject </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code>. Note that this method has the same effect as the <code>deleteObjectRaw</code> method (since no deallocation is involved), and exists for consistency across pools. </p>

</div>
</div>
<a class="anchor" id="abfabe031af8ad173bcdb604f42dad5bb"></a><!-- doxytag: member="bdlma::SequentialPool::release" ref="abfabe031af8ad173bcdb604f42dad5bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::SequentialPool::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release all memory allocated through this pool. The pool is reset to its default-constructed state, retaining the alignment and growth strategies, and the initial and maximum buffer sizes in effect following construction. The effect of using a pointer after this call that was obtained before this call from this object is undefined. </p>

</div>
</div>
<a class="anchor" id="a18b0d488fe0f4bc7664fedcad55b0a4d"></a><!-- doxytag: member="bdlma::SequentialPool::rewind" ref="a18b0d488fe0f4bc7664fedcad55b0a4d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::SequentialPool::rewind </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release all memory allocated through this pool. Return to the construction-time supplied allocator all but the last block obtained from it, if any, and satisfy subsequent allocations from the beginning of the remaining block, where possible. The effect of using a pointer after this call that was obtained from this object before this call is undefined. </p>

</div>
</div>
<a class="anchor" id="a56a831290d4f1bacccbe44bc6331c3f4"></a><!-- doxytag: member="bdlma::SequentialPool::reserveCapacity" ref="a56a831290d4f1bacccbe44bc6331c3f4" args="(int numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::SequentialPool::reserveCapacity </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reserve sufficient memory to satisfy allocation requests for at least the specified <code>numBytes</code> without replenishment (i.e., without dynamic allocation). This method ignores <code>maxBufferSize</code> even if it is supplied at construction. The behavior is undefined unless <code>0 &lt; numBytes</code>. Note that, due to alignment effects, it is possible that not all <code>numBytes</code> of memory will be used for allocation before triggering dynamic allocation. </p>

</div>
</div>
<a class="anchor" id="a6811148a5e1889268526a0e50b446ee7"></a><!-- doxytag: member="bdlma::SequentialPool::truncate" ref="a6811148a5e1889268526a0e50b446ee7" args="(void *address, int originalSize, int newSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlma::SequentialPool::truncate </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>originalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>newSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reduce the amount of memory allocated at the specified <code>address</code> of the specified <code>originalSize</code> (in bytes) to the specified <code>newSize</code>. Return <code>newSize</code> after truncating, or <code>originalSize</code> if the memory block at <code>address</code> cannot be truncated. This method can only <code>truncate</code> the memory block returned by the most recent <code>allocate</code> request from this memory pool, and otherwise has no effect. The behavior is undefined unless the memory at <code>address</code> was originally allocated by this memory pool, the size of the memory block at <code>address</code> is <code>originalSize</code>, <code>newSize &lt;= originalSize</code>, <code>0 &lt;= newSize</code>, and <code>release</code> was not called after allocating the memory block at <code>address</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlma__sequentialpool_8h_source.html">bdlma_sequentialpool.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:32 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
