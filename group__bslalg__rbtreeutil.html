<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslalg_rbtreeutil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslalg_rbtreeutil<br/>
<small>
[<a class="el" href="group__bslalg.html">Package bslalg</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a suite of primitive algorithms on red-black trees.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslalg.html">bslalg</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Summary</a> <ul>
<li>
<a href="#3.1.1">Navigation</a> </li>
<li>
<a href="#3.1.2">Modification</a> </li>
<li>
<a href="#3.1.3">Utility</a> </li>
<li>
<a href="#3.1.4">Testing</a> </li>
</ul>
</li>
<li>
<a href="#3.2">Well-Formed <code>RbTreeAnchor</code> Objects</a> <ul>
<li>
<a href="#3.2.1">The Sentinel Node</a> </li>
</ul>
</li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Creating and Using a Tree with <code>RbTreeUtil</code></a> </li>
<li>
<a href="#3.3.2">Example 2: Implementing a Set of Integers</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a suite of primitive algorithms on red-black trees. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbslalg_1_1RbTreeUtil.html">bslalg::RbTreeUtil</a> </td><td>namespace for red-black tree functions  </td></tr>
<tr>
<td><a class="el" href="classbslalg_1_1RbTreeUtilTreeProctor.html">bslalg::RbTreeUtilTreeProctor</a> </td><td>proctor to manage all nodes in a tree  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslalg__rbtreenode.html" title="Provide a base class for a red-black binary tree node.">Component bslalg_rbtreenode</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a variety of algorithms that operate on nodes forming a red-black binary search tree. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This implementation is adapted from Cormen, Leiserson, Rivest, "Introduction to Algorithms" [MIT Press, 1997]. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="summary"></a> <a class="anchor" id="description.summary"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Summary: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following section provides a short synopsis describing observable behavior of functions supplied in this component. See the full function-level contract for detailed description. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="navigation"></a> <a class="anchor" id="summary.navigation"></a> <a class="anchor" id="description.summary.navigation"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Navigation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following algorithms search a tree for a value, or iterate over the nodes in a tree: <br/>
<br/>
<div class="fragment"><pre class="fragment">  leftmost            Return the leftmost node.

  rightmost           Return the rightmost node.

  next                Return the next node in an in-order traversal.

  previous            Return the previous node in an in-order traversal.

  find                Find the node with the supplied value.

  lowerBound          Find the first node not less-than the supplied value.

  upperBound          Find the first node greater than the supplied value.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="modification"></a> <a class="anchor" id="summary.modification"></a> <a class="anchor" id="description.summary.modification"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Modification: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following algorithms are used in the process of manipulating the structure of a tree: <br/>
<br/>
<div class="fragment"><pre class="fragment">  copyTree            Return a deep-copy of the supplied tree.

  deleteTree          Delete all the nodes of the supplied tree.

  findInsertLocation  Find the location where a value may be inserted.

  findUniqueInsertLocation
                      Find the location where a unique value may be inserted.

  insert              Insert the supplied node into the tree.

  insertAt            Insert the supplied node at the indicated position.

  <span class="keyword">remove</span>              Remove the supplied node from the tree.

  <a class="code" href="namespacebslalg.html#aaa5e9eab8ebf1a94de3cf3db2c4d10c1">swap</a>                Swap the contents of two trees.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="utility"></a> <a class="anchor" id="summary.utility"></a> <a class="anchor" id="description.summary.utility"></a> <a class="anchor" id="3.1.3"></a> </dd></dl>
<dl class="user"><dt><b>Utility: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following algorithms are typically used when implementing higher-level algorithms (and are not generally used by clients): <br/>
<br/>
<div class="fragment"><pre class="fragment">  isLeftChild         Return <span class="stringliteral">&#39;true&#39;</span> <span class="keywordflow">if</span> the supplied node is a left child.

  isRightChild        Return <span class="stringliteral">&#39;true&#39;</span> <span class="keywordflow">if</span> the supplied node is a right child.

  rotateLeft          Perform a counter-clockwise rotation on a node.

  rotateRight         Perform a clockwise rotation on a node.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="testing"></a> <a class="anchor" id="summary.testing"></a> <a class="anchor" id="description.summary.testing"></a> <a class="anchor" id="3.1.4"></a> </dd></dl>
<dl class="user"><dt><b>Testing: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following algorithms are used for testing and debugging, and generally should not be used in production code: <br/>
<br/>
<div class="fragment"><pre class="fragment">  printTreeStructure  Print, to a file, the structure of the supplied tree.

  validateRbTree      Indicate <span class="keywordflow">if</span> a tree is a valid red-black tree.

  isWellFormed        Indicate <span class="keywordflow">if</span> the <span class="stringliteral">&#39;RbTreeAnchor&#39;</span> <span class="keywordtype">object</span> is well-formed.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="well-formed_rbtreeanchor_objects"></a> <a class="anchor" id="description.well-formed_rbtreeanchor_objects"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Well-Formed RbTreeAnchor Objects: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Many of the algorithms defined in this component operate over a complete tree of nodes, rather than a (possible) subtree referred to through a pointer to a node. These operations refer to a complete tree through a <code>RbTreeAnchor</code> object, which maintains references to the first, root, and sentinel nodes for the tree, as well as a count of the number of nodes in the tree. <code>RbTreeAnchor</code> objects supplied to <code>RbTreeUtil</code> are frequently required to meet a series of constraints that are not enforced by the <code>RbTreeAnchor</code> type itself. An <code>RbTreeAnchor</code> object meeting these constraints is said to be "well-formed", and <code>RbTreeUtil::isWellFormed</code> will return <code>true</code> for such an object. A <code>RbTreeAnchor</code> object is considered well-formed if all of the following are true: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
The root node refers to a valid red-black tree (see <code>validateRbTree</code>).  </li>
<li>
The first node refers to the leftmost node in the tree, or the sentinel node if the tree is empty.  </li>
<li>
The node count is the number of nodes in the tree (not counting the sentinel node).  </li>
<li>
The sentinel node refers to the root node as its left child, and the root node refers to the sentinel as its parent.  </li>
<li>
The root node is either 0 or is colored black.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The manipulation functions of <code>RbTreeUtil</code> guarantee that these properties are maintained for any supplied tree. Note that <code>RbTreeUtil::isWellFormed</code> has linear complexity with respect to the number of nodes in the tree, and is typically used for debugging and testing purposes only. Note also that the final condition, that the root node be either 0 or colored black, is not a canonical requirement of a red-black tree but an additional invariant enforced by the methods of <code>RbTreeUtil</code> to simplify the implementations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="the_sentinel_node"></a> <a class="anchor" id="well-formed_rbtreeanchor_objects.the_sentinel_node"></a> <a class="anchor" id="description.well-formed_rbtreeanchor_objects.the_sentinel_node"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>The Sentinel Node: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The sentinel node is <code>RbTreeNode</code> object (unique to an <code>RbTreeAnchor</code> instance) which does not have a value, and provides a fixed end-point for navigation over the tree (which is distinct from the <code>rightmost</code> node of that tree). The sentinel node will be returned by <code>next</code> if the supplied node is the rightmost node in the tree, as well as by search operations when no nodes meet the supplied search-criteria. In addition, the sentinel node may be supplied as a <code>hint</code> to <code>findInsertLocation</code> and <code>findUniqueInsertLocation</code>, as well as supplied to <code>previous</code> to obtain the rightmost node of a (non-empty) tree. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating and Using a Tree with RbTreeUtil: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates how to create a tree of integers using <code>RbTreeUtil</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a type <code>SimpleIntNode</code> that will represent a nodes in our tree of integer values. <code>SimpleIntNode</code> contains an <code>int</code> payload, and inherits from <code>RbTreeNode</code>, allowing it to be operated on by <code>RbTreeUtil</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>SimpleIntNode : <span class="keyword">public</span> RbTreeNode {
      <span class="keywordtype">int</span> d_value;
  };
</pre></div><br/>
<br/>
 Then, we define a comparison function for <code>SimpleIntNode</code> objects (note that we static-cast <code>RBTreeNode</code> objects to the actual node type, <code>SimpleIntNode</code>, for comparison purposes): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>SimpleIntNodeValueComparator {
      <span class="comment">// This class defines a comparator providing comparison operations</span>
      <span class="comment">// between &#39;SimpleIntNode&#39; objects, and &#39;int&#39; values.</span>

      <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> RbTreeNode&amp; lhs, <span class="keywordtype">int</span> rhs)<span class="keyword"> const</span>
<span class="keyword">      </span>{
          <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>SimpleIntNode&amp;<span class="keyword">&gt;</span>(lhs).d_value &lt; rhs;
      }

      <span class="keywordtype">bool</span> operator()(<span class="keywordtype">int</span> lhs, <span class="keyword">const</span> RbTreeNode&amp; rhs)<span class="keyword"> const</span>
<span class="keyword">      </span>{
          <span class="keywordflow">return</span> lhs &lt; static_cast&lt;const SimpleIntNode&amp;&gt;(rhs).d_value;
      }
  };
</pre></div><br/>
<br/>
 Next, we begin to define the example function that will build a tree of nodes holding integer values: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> createTestTreeExample()
  {
</pre></div><br/>
<br/>
 Then, within this function, we define a <code>RbTreeAnchor</code> object that will hold the root, first, last, and sentinel nodes of tree, as well a count of the number of nodes in the tree: <br/>
<br/>
<div class="fragment"><pre class="fragment">      RbTreeAnchor tree;
</pre></div><br/>
<br/>
 Next, we define an array of 5 <code>SimpleIntNode</code> objects that we will insert into the tree; in practice, nodes are more often allocated on the heap (see example 2): <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_NODES = 5;
      SimpleIntNode nodes[NUM_NODES];
</pre></div><br/>
<br/>
 Then, we assign unique values to each of the <code>nodes</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_NODES; ++i) {
          nodes[i].d_value = i;
      }
</pre></div><br/>
<br/>
 Now, for each node in the tree, we use <code>RbTreeUtil</code> to first find the location at which the node should be inserted, and then insert that node into the tree: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_NODES; ++i) {
          <span class="keywordtype">int</span> comparisonResult;
          RbTreeNode *insertLocation = RbTreeUtil::findUniqueInsertLocation(
                                              &amp;comparisonResult,
                                              &amp;tree,
                                              SimpleIntNodeValueComparator(),
                                              nodes[i].d_value);
          <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(comparisonResult);
          RbTreeUtil::insertAt(&amp;tree,
                               insertLocation,
                               comparisonResult &lt; 0,
                               &amp;nodes[i]);
      }
</pre></div><br/>
<br/>
 And verify the resulting <code>tree</code> holds 5 nodes, the first node has the value 0, and the last node has the value 4: <br/>
<br/>
<div class="fragment"><pre class="fragment">      assert(5 == tree.numNodes());
      assert(0 == static_cast&lt;SimpleIntNode *&gt;(tree.firstNode())-&gt;d_value);
      assert(4 == static_cast&lt;SimpleIntNode *&gt;(tree.lastNode())-&gt;d_value);
</pre></div><br/>
<br/>
 Finally, we use <code>RbTreeUtil</code> to iterate through the nodes of <code>tree</code>, and write the value of each node to the console: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">const</span> RbTreeNode *nodeIterator = tree.firstNode();
      <span class="keywordflow">while</span> (tree.sentinel() != nodeIterator) {
          printf(<span class="stringliteral">&quot;Node value: %d\n&quot;</span>,
                 static_cast&lt;const SimpleIntNode *&gt;(nodeIterator)-&gt;d_value);
          nodeIterator = RbTreeUtil::next(nodeIterator);
      }
  }
</pre></div><br/>
<br/>
 Notice that each of the <code>RbTreeNode</code> objects must be <code>static_cast</code> to the derived type, <code>SimpleIntNode</code>, in order to access their values. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The resulting output is displayed on the console: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Node value: 0
  Node value: 1
  Node value: 2
  Node value: 3
  Node value: 4
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Implementing a Set of Integers: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates how to use <code>RbTreeUtil</code> to implement a simple container holding a set of (unique) integer values as a red-black binary search tree. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Before defining the <code>IntSet</code> class, we need to define a series of associated helper types: <ol>
<li>
The node-type, for the nodes in the tree.  </li>
<li>
An iterator, for iterating over nodes in the tree.  </li>
<li>
A comparison functor for comparing nodes and values.  </li>
<li>
A factory for creating and destroying nodes.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a type, <code>IntSet_Node</code>, that will represent the nodes in our tree of integer values; it contains an <code>int</code> payload, and inherits from <code>RbTreeNode</code>, allowing it to be operated on by <code>RbTreeUtil</code> (note that the underscore "_" indicates that this type is a private implementation type of <code>IntSet</code>, and not for use by clients of <code>IntSet</code>): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>IntSet_Node : <span class="keyword">public</span> RbTreeNode {
      <span class="comment">// A red-black tree node containing an integer data-value.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span> d_value;  <span class="comment">// actual value represented by the node</span>

    <span class="keyword">public</span>:
      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">int</span>&amp; value() { <span class="keywordflow">return</span> d_value; }
          <span class="comment">// Return a reference providing modifiable access to the &#39;value&#39; of</span>
          <span class="comment">// this object.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_value; }
          <span class="comment">// Return a reference providing non-modifiable access to the</span>
          <span class="comment">// &#39;value&#39; of this object.</span>
  };
</pre></div><br/>
<br/>
 Then, we define a iterator over <code>IntSet_Node</code> objects. We use the <code>next</code> function of <code>RbTreeUtil</code> to increment the iterator (note that, for simplicity, this iterator is <em>not</em> a fully STL compliant iterator implementation): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>IntSetConstIterator {
      <span class="comment">// This class defines an STL-style iterator over a non-modifiable tree</span>
      <span class="comment">// of &#39;IntSet_Node&#39; objects.</span>

      <span class="comment">// DATA</span>
      <span class="keyword">const</span> RbTreeNode *d_node_p;  <span class="comment">// current location of this iterator</span>

    <span class="keyword">public</span>:
      IntSetConstIterator() : d_node_p(0) {}
          <span class="comment">// Create an iterator that does not refer to a node.</span>

      IntSetConstIterator(<span class="keyword">const</span> RbTreeNode *node) : d_node_p(node) {}
          <span class="comment">// Create an iterator referring to the specified &#39;node&#39;.</span>

  <span class="comment">//  IntSetConstIterator(const IntSetConstIterator&amp;) = default;</span>

      <span class="comment">// MANIPULATOR</span>
  <span class="comment">//  IntSetConstIterator&amp; operator=(const IntSetConstIterator&amp;) = default;</span>
</pre></div><br/>
<br/>
 Here, we implement the prefix-increment operator using the <code>next</code> function of 'RbTreeUtil: <br/>
<br/>
<div class="fragment"><pre class="fragment">      IntSetConstIterator&amp; <a class="code" href="namespacebslstl.html#a00890c2044ab22c5074a3d85283319d0">operator++</a>()
         <span class="comment">// Advance this iterator to the subsequent value it the &#39;IntSet&#39;,</span>
         <span class="comment">// and return a reference providing modifiable access to this</span>
         <span class="comment">// iterator.   The behavior is undefined unless this iterator</span>
         <span class="comment">// refers to a element in an &#39;IntSet&#39;.</span>
      {
          d_node_p = RbTreeUtil::next(d_node_p);
          <span class="keywordflow">return</span> *<span class="keyword">this</span>;
      }

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; operator*() const
          <span class="comment">// Return a reference providing non-modifiable access to the value</span>
          <span class="comment">// referred to by this iterator.</span>
      {
          <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>IntSet_Node *<span class="keyword">&gt;</span>(d_node_p)-&gt;value();
      }

      <span class="keyword">const</span> <span class="keywordtype">int</span> *operator-&gt;() const
          <span class="comment">// Return an address providing non-modifiable access to the value</span>
          <span class="comment">// referred to by this iterator.</span>
      {
          <span class="keywordflow">return</span> &amp;(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>IntSet_Node *<span class="keyword">&gt;</span>(d_node_p)-&gt;value());
      }

      <span class="keyword">const</span> IntSet_Node *nodePtr() const
          <span class="comment">// Return the address of the non-modifiable int-set node referred</span>
          <span class="comment">// to by this iterator</span>
      {
          <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>IntSet_Node *<span class="keyword">&gt;</span>(d_node_p);
      }
  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#aed5308d4f7d1542d6eeb8acedec974d3">operator==</a>(<span class="keyword">const</span> IntSetConstIterator &amp;lhs,
                  <span class="keyword">const</span> IntSetConstIterator &amp;rhs)
      <span class="comment">// Return &#39;true&#39; if the &#39;lhs&#39; and &#39;rhs&#39; objects have the same value,</span>
      <span class="comment">// and &#39;false&#39; otherwise.  Two &#39;IntSetConstIterator&#39; objects have the</span>
      <span class="comment">// same value if they refer to the same node.</span>
  {
      <span class="keywordflow">return</span> lhs.nodePtr() == rhs.nodePtr();
  }

  <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#acf8107f12ec28380f11b968856544276">operator!=</a>(<span class="keyword">const</span> IntSetConstIterator &amp;lhs,
                  <span class="keyword">const</span> IntSetConstIterator &amp;rhs)
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  Two &#39;IntSetConstIterator&#39;</span>
      <span class="comment">// objects do not have the same value if they refer to different nodes.</span>
  {
      <span class="keywordflow">return</span> lhs.nodePtr() != rhs.nodePtr();
  }
</pre></div><br/>
<br/>
 Next, we define a comparison functor for <code>IntSet_Node</code> objects, which will be supplied to <code>RbTreeUtil</code> functions that must compare nodes with values -- i.e., those with a <code>NODE_VALUE_COMPARATOR</code> template parameter (e.g., <code>find</code> and <code>findInsertLocation</code>): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>IntSet_NodeValueComparator {
      <span class="comment">// This class defines a comparator providing comparison operations</span>
      <span class="comment">// between &#39;IntSet_Node&#39; objects, and &#39;int&#39; values.</span>

      <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> RbTreeNode&amp; lhs, <span class="keywordtype">int</span> rhs)<span class="keyword"> const</span>
<span class="keyword">      </span>{
          <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>IntSet_Node&amp;<span class="keyword">&gt;</span>(lhs).value() &lt; rhs;
      }

      <span class="keywordtype">bool</span> operator()(<span class="keywordtype">int</span> lhs, <span class="keyword">const</span> RbTreeNode&amp; rhs)<span class="keyword"> const</span>
<span class="keyword">      </span>{
          <span class="keywordflow">return</span> lhs &lt; static_cast&lt;const IntSet_Node&amp;&gt;(rhs).value();
      }
  };
</pre></div><br/>
<br/>
 Notice that we static-cast <code>RbTreeNode</code> objects to the actual node type, <code>IntSet_Node</code> for comparison. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we define a factory for creating and destroying <code>IntSet_Node</code> objects. This factory provides the operations <code>createNode</code> and <code>deleteNode</code>. These operations will be used directly by our container implementation, and they are also required by <code>RbTreeUtil</code> functions taking a <code>FACTORY</code> template parameter (e.g., <code>copyTree</code> and <code>deleteTree</code>): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>IntSet_NodeFactory {
      <span class="comment">// This class defines a creator object, that when invoked, creates a</span>
      <span class="comment">// new &#39;IntSet_Node&#39; (either from a int value, or an existing</span>
      <span class="comment">// &#39;IntSet_Node&#39; object) using the allocator supplied at construction.</span>

      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;  <span class="comment">// allocator, (held, not owned)</span>

    <span class="keyword">public</span>:

      IntSet_NodeFactory(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)
      : d_allocator_p(allocator)
      {
          <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(allocator);
      }

      RbTreeNode *createNode(<span class="keywordtype">int</span> value)<span class="keyword"> const</span>
<span class="keyword">      </span>{
          IntSet_Node *newNode = <span class="keyword">new</span> (*d_allocator_p) IntSet_Node;
          newNode-&gt;value() = value;
          <span class="keywordflow">return</span> newNode;
      }

      RbTreeNode *createNode(<span class="keyword">const</span> RbTreeNode&amp; node)<span class="keyword"> const</span>
<span class="keyword">      </span>{
          IntSet_Node *newNode = <span class="keyword">new</span> (*d_allocator_p) IntSet_Node;
          newNode-&gt;value() = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>IntSet_Node&amp;<span class="keyword">&gt;</span>(node).value();
          <span class="keywordflow">return</span> newNode;
      }
      <span class="keywordtype">void</span> deleteNode(RbTreeNode *node)<span class="keyword"> const</span>
<span class="keyword">      </span>{
          d_allocator_p-&gt;deleteObject(static_cast&lt;IntSet_Node *&gt;(node));
      }

      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator()<span class="keyword"> const</span>
<span class="keyword">      </span>{
          <span class="keywordflow">return</span> d_allocator_p;
      }
  };
</pre></div><br/>
<br/>
 Then, having defined the requisite helper types, we define the public interface for our <code>IntSet</code> type. Note that for the purposes of illustrating the use of <code>RbTreeUtil</code> a number of simplifications have been made. For example, this implementation provides only a minimal set of critical operations, and it does not use the empty base-class optimization for the comparator, etc. We define the interface of <code>IntSet</code> as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>IntSet {
      <span class="comment">// This class implements a set of (unique) &#39;int&#39; values.</span>

      <span class="comment">// DATA</span>
      RbTreeAnchor           d_tree;         <span class="comment">// root, first, and last tree</span>
                                             <span class="comment">// nodes</span>

      IntSet_NodeValueComparator
                             d_comparator;   <span class="comment">// comparison functor for ints</span>

      IntSet_NodeFactory     d_nodeFactory;  <span class="comment">// factory for creating and</span>
                                             <span class="comment">// destroying nodes</span>

      <span class="comment">// FRIENDS</span>
      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#aed5308d4f7d1542d6eeb8acedec974d3">operator==</a>(<span class="keyword">const</span> IntSet&amp; lhs, <span class="keyword">const</span> IntSet&amp; rhs);

    <span class="keyword">public</span>:
      <span class="comment">// PUBLIC TYPES</span>
      <span class="keyword">typedef</span> IntSetConstIterator const_iterator;

      <span class="comment">// CREATORS</span>
      IntSet(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a empty &#39;IntSet&#39;.  Optionally specify a &#39;basicAllocator&#39;</span>
          <span class="comment">// used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently</span>
          <span class="comment">// installed default allocator is used.</span>

      IntSet(<span class="keyword">const</span> IntSet&amp; original, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;IntSet&#39; object having the same value as the specified</span>
          <span class="comment">// &#39;original&#39; object.  If &#39;basicAllocator&#39; is 0, the currently</span>
          <span class="comment">// installed default allocator is used.</span>

      ~IntSet();
          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      IntSet&amp; operator=(<span class="keyword">const</span> IntSet&amp; rhs);
          <span class="comment">// Assign to this object the value of the specified &#39;rhs&#39; object,</span>
          <span class="comment">// and return a reference providing modifiable access to this</span>
          <span class="comment">// object.</span>

      const_iterator insert(<span class="keywordtype">int</span> value);
          <span class="comment">// If the specified &#39;value&#39; is not already a member of this set,</span>
          <span class="comment">// insert it into this set, returning an iterator referring to the</span>
          <span class="comment">// newly added value, and return an iterator referring to the</span>
          <span class="comment">// existing instance of &#39;value&#39; in this set, with no other effect,</span>
          <span class="comment">// otherwise.</span>

      const_iterator erase(const_iterator iterator);
          <span class="comment">// Remove the value referred to by the specified &#39;iterator&#39; from</span>
          <span class="comment">// this set, and return an iterator referring to the value</span>
          <span class="comment">// subsequent to &#39;iterator&#39; (prior to its removal).  The behavior</span>
          <span class="comment">// is undefined unless &#39;iterator&#39; refers to a valid value in this</span>
          <span class="comment">// set.</span>

      <span class="keywordtype">void</span> clear();
          <span class="comment">// Remove all the elements from this set.</span>

      <span class="keywordtype">void</span> <a class="code" href="namespacebslalg.html#aaa5e9eab8ebf1a94de3cf3db2c4d10c1">swap</a>(IntSet&amp; other);
          <span class="comment">// Efficiently exchange the value of this object with the value of</span>
          <span class="comment">// the specified &#39;other&#39; object.</span>

      <span class="comment">// ACCESSORS</span>
      const_iterator begin() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator referring leftmost node value in this set, or</span>
          <span class="comment">// &#39;end()&#39; if this set is empty.</span>

      const_iterator end() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator referring to the value one past the</span>
          <span class="comment">// rightmost value in this set.</span>

      const_iterator find(<span class="keywordtype">int</span> value) <span class="keyword">const</span>;
          <span class="comment">// Return a iterator referring to the specified &#39;value&#39; in this</span>
          <span class="comment">// set, or &#39;end()&#39; if &#39;value&#39; is not a member of this set.</span>

      <span class="keywordtype">int</span> size() <span class="keyword">const</span>;
          <span class="comment">// Return the number of elements in this set.</span>
  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#aed5308d4f7d1542d6eeb8acedec974d3">operator==</a>(<span class="keyword">const</span> IntSet&amp; lhs, <span class="keyword">const</span> IntSet&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the &#39;lhs&#39; and &#39;rhs&#39; objects have the same value,</span>
      <span class="comment">// and &#39;false&#39; otherwise.  Two &#39;IntSet&#39; objects have the same value if</span>
      <span class="comment">// they contain the same number of elements, and if for each element</span>
      <span class="comment">// in &#39;lhs&#39; there is a corresponding element in &#39;rhs&#39; with the same</span>
      <span class="comment">// value.</span>

  <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#acf8107f12ec28380f11b968856544276">operator!=</a>(<span class="keyword">const</span> IntSet&amp; lhs, <span class="keyword">const</span> IntSet&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  Two &#39;IntSet&#39; objects do not</span>
      <span class="comment">// have the same value if they differ in the number of elements they</span>
      <span class="comment">// contain, or if for any element in &#39;lhs&#39; there is not a</span>
      <span class="comment">// corresponding element in &#39;rhs&#39; with the same value.</span>
</pre></div><br/>
<br/>
 Now, we implement the methods of <code>IntSet</code> using <code>RbTreeUtil</code> and the helper types we defined earlier: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  IntSet::IntSet(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_tree()
  , d_comparator()
  , d_nodeFactory(bslma::Default::allocator(basicAllocator))
  {
  }

  IntSet::IntSet(<span class="keyword">const</span> IntSet&amp; original, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_tree()
  , d_comparator()
  , d_nodeFactory(bslma::Default::allocator(basicAllocator))
  {
      <span class="keywordflow">if</span> (original.d_tree.rootNode()) {
          RbTreeUtil::copyTree(&amp;d_tree, original.d_tree, &amp;d_nodeFactory);
      }
  }

  IntSet::~IntSet()
  {
      clear();
  }

  <span class="comment">// MANIPULATORS</span>
  IntSet&amp; IntSet::operator=(<span class="keyword">const</span> IntSet&amp; rhs)
  {
      IntSet temp(rhs, d_nodeFactory.allocator());
      <a class="code" href="namespacebslalg.html#aaa5e9eab8ebf1a94de3cf3db2c4d10c1">swap</a>(temp);
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }
</pre></div><br/>
<br/>
 Here, we implement <code>insert</code> by using the <code>RbTreeUtil</code> algorithms <code>findUniqueInsertLocation</code> and <code>insertAt</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  IntSet::const_iterator IntSet::insert(<span class="keywordtype">int</span> value)
  {
      <span class="comment">// To insert a value into the tree, we first find the location where</span>
      <span class="comment">// the node would be added, and whether &#39;value&#39; is unique.  If &#39;value&#39;</span>
      <span class="comment">// is not unique we do not want to incur the expense of allocating</span>
      <span class="comment">// memory for a node.</span>

      <span class="keywordtype">int</span> comparisonResult;
      RbTreeNode *insertLocation =
                    RbTreeUtil::findUniqueInsertLocation(&amp;comparisonResult,
                                                         &amp;d_tree,
                                                         d_comparator,
                                                         value);
      <span class="keywordflow">if</span> (0 == comparisonResult) {
          <span class="comment">// &#39;value&#39; already exists in &#39;d_tree&#39;.</span>

          <span class="keywordflow">return</span> const_iterator(insertLocation);                    <span class="comment">// RETURN</span>
      }

      <span class="comment">// If &#39;value&#39; is unique, we create a new node and supply it to</span>
      <span class="comment">// &#39;insertAt&#39;, along with the tree location returned by</span>
      <span class="comment">// &#39;findUniqueInsertLocation&#39;.</span>

      RbTreeNode *newNode = d_nodeFactory.createNode(value);
      RbTreeUtil::insertAt(&amp;d_tree,
                           insertLocation,
                           comparisonResult &lt; 0,
                           newNode);
      <span class="keywordflow">return</span> const_iterator(newNode);
  }

  IntSet::const_iterator IntSet::erase(const_iterator iterator)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(iterator.nodePtr());
      IntSet_Node *node = <span class="keyword">const_cast&lt;</span>IntSet_Node *<span class="keyword">&gt;</span>(iterator.nodePtr());

      <span class="comment">// Before removing the node, we first find the subsequent node to which</span>
      <span class="comment">// we will return an iterator.</span>

      RbTreeNode *next = RbTreeUtil::next(node);
      RbTreeUtil::remove(&amp;d_tree, node);
      d_nodeFactory.deleteNode(node);
      <span class="keywordflow">return</span> const_iterator(next);
  }

  <span class="keywordtype">void</span> IntSet::clear()
  {
      <span class="keywordflow">if</span> (d_tree.rootNode()) {
          RbTreeUtil::deleteTree(&amp;d_tree, &amp;d_nodeFactory);
      }
  }

  <span class="keywordtype">void</span> <a class="code" href="namespacebslalg.html#aaa5e9eab8ebf1a94de3cf3db2c4d10c1">IntSet::swap</a>(IntSet&amp; other) {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(d_nodeFactory.allocator() ==
                  other.d_nodeFactory.allocator());
      <a class="code" href="namespacebslalg.html#aaa5e9eab8ebf1a94de3cf3db2c4d10c1">RbTreeUtil::swap</a>(&amp;d_tree, &amp;other.d_tree);
  }

  <span class="comment">// ACCESSORS</span>
  IntSet::const_iterator IntSet::begin()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> const_iterator(d_tree.firstNode());
  }

  IntSet::const_iterator IntSet::end()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> const_iterator(d_tree.sentinel());
  }

  IntSet::const_iterator IntSet::find(<span class="keywordtype">int</span> value)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> const_iterator(RbTreeUtil::find(d_tree, d_comparator, value));
  }

  <span class="keywordtype">int</span> IntSet::size()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_tree.numNodes();
  }
</pre></div><br/>
<br/>
 Finally, we implement the free operators on <code>IntSet</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// FREE OPERATORS</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#aed5308d4f7d1542d6eeb8acedec974d3">operator==</a>(<span class="keyword">const</span> IntSet&amp; lhs, <span class="keyword">const</span> IntSet&amp; rhs)
  {
      <span class="keywordflow">return</span> <a class="code" href="structbslalg_1_1RangeCompare.html#a7512bb3d99340d59d531bb7d0a5b4ae0">bslalg::RangeCompare::equal</a>(lhs.begin(),
                                        lhs.end(),
                                        lhs.size(),
                                        rhs.begin(),
                                        rhs.end(),
                                        rhs.size());
  }

  <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#acf8107f12ec28380f11b968856544276">operator!=</a>(<span class="keyword">const</span> IntSet&amp; lhs, <span class="keyword">const</span> IntSet&amp; rhs)
  {
      <span class="keywordflow">return</span> !(lhs == rhs);
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:41 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
