<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslstl_set Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_set<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL-compliant set class.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1set.html">bsl::set&lt; KEY, COMPARATOR, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>bsl::set&lt; KEY, COMPARATOR, ALLOCATOR &gt;::DataWrapper</b></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KEY&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga2db6189f957c2a5f0de4265215cf56ff">bsl::set::key_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KEY&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gae0dcd55ea7388ec8ded5752cc95d9e7a">bsl::set::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef COMPARATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga6ea0a7098a7d4857efc6ce9b128ccf37">bsl::set::key_compare</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef COMPARATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gacdba9bd632acbe60ba907471eed85e3e">bsl::set::value_compare</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga278ab7b41df2997c57c7de4cb2c36fbe">bsl::set::allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga2af8f60b592b186017dad97cbb87109c">bsl::set::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga235244bffb72e576087d06c9eb2d01b5">bsl::set::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorTraits::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga4cdf8a312c4d9158bae4a2e4c78431df">bsl::set::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorTraits::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga48550967a18557e281476d87fe3fd0e6">bsl::set::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorTraits::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga3cecef876f06124be9c505bfd29b4db1">bsl::set::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorTraits::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gacb32347b6b351552bfeb104dd60c640c">bsl::set::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
BloombergLP::bslstl::TreeIterator<br class="typebreak"/>
&lt; const value_type, Node, <br class="typebreak"/>
difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga2f8e9cd8d701e9b1bbcdea4cac3438a8">bsl::set::iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
BloombergLP::bslstl::TreeIterator<br class="typebreak"/>
&lt; const value_type, Node, <br class="typebreak"/>
difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga6b8f1e11518593aa25a17ac44dec29a0">bsl::set::const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gac2e33e570a360d8527a952105cb40f0b">bsl::set::reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gaa37e96e3dfe0572164845e1615ad5da4">bsl::set::const_reverse_iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga968368c5a6a5145223f668be6e0e7a43">bsl::set::DataWrapper::DataWrapper</a> (const COMPARATOR &amp;comparator, const ALLOCATOR &amp;allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga9167d8342a13068cbf1fe2791f3bfc7b">bsl::set::set</a> (const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;allocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gab65540ad4c9ffddb9343516f153d0087">bsl::set::set</a> (const ALLOCATOR &amp;allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga75231a89f6f2d0fe493036b6755229b5">bsl::set::set</a> (const set &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gac50b939ee57c46b2e2a4039086c747bd">bsl::set::set</a> (const set &amp;original, const ALLOCATOR &amp;allocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga0f6b17157e97d98728ba03e534135cb3">bsl::set::set</a> (INPUT_ITERATOR first, INPUT_ITERATOR last, const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;allocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga63683a3b20e23e9663006048d8949af7">bsl::set::~set</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">set &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gaf419d52ab15f8c1cbeb9cbbc25f31241">bsl::set::operator=</a> (const set &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga59d32154f54376aa7cdb4c086e211a85">bsl::set::begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gab180d3123dea011341881e0b40c3d3e5">bsl::set::end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga04c3b2dcf67f139692c91738e5b801af">bsl::set::rbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga8134367e82cf7e21a14220b1d4649dc8">bsl::set::rend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pair&lt; iterator, bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gac4147796e5d1fdda60e5646c4c114913">bsl::set::insert</a> (const value_type &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga9bcd0dea344685633dea8c5f05c1e156">bsl::set::insert</a> (const_iterator hint, const value_type &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gaa233985535c18c105ad1e60ecfa89bfd">bsl::set::insert</a> (INPUT_ITERATOR first, INPUT_ITERATOR last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gac0739d62f93db2d262610f9f26d3cf29">bsl::set::erase</a> (const_iterator position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga93fd4ae6a5e2cf2bdbe73077942a7e1b">bsl::set::erase</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gaf186097236f420361194a912cc27d03b">bsl::set::erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gacbb5758f822acac1009262b30158c1a8">bsl::set::swap</a> (set &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga2dc35deb977fd2df2ec6c0234c4ecf3b">bsl::set::clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga1d4dcb62ee26b65de7b2eb822c206365">bsl::set::find</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga04380ca82289b197d0ab6b8ef66b2edf">bsl::set::lower_bound</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gac940db389fc380b4fee44a7beae5df3b">bsl::set::upper_bound</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pair&lt; iterator, iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gab0397dfbb3ae6737d475c3bcd9349eb6">bsl::set::equal_range</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gada8ac5fa1be189ed2971f405b6ade58b">bsl::set::get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga2aca9577a69e7d2829d42cb4bfd56439">bsl::set::begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga5f1edd91e23ff9c9e2eb390d347817e3">bsl::set::end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gaab77d60304cb4c95e6361dbbc9cd4f53">bsl::set::rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga5511baba5908387b3652f4713645d349">bsl::set::rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga104dd9a9b6aaf21f0e8e15633373b8ad">bsl::set::cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gab123b6838099254ac81615cf1c429b41">bsl::set::cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga07c01ec5842e778169b33311ca395f8f">bsl::set::crbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga37fe01c174ed0b90cd8a5ca1b56980f2">bsl::set::crend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga6a4a224cdf8d4a463d14f39d313a73e9">bsl::set::empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga52ae060a7ee3db966f37a85a00efc611">bsl::set::size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga38b47c73229e8b6f9758fefbcd7bbbcf">bsl::set::max_size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">key_compare&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gaae1a64af26bb0c43674c732a47b33383">bsl::set::key_comp</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">value_compare&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga44b1e23b4c4b29e2fd67cd103717000e">bsl::set::value_comp</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gafaef6ddc1dd274ca146df3d6b12f2ea9">bsl::set::find</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga56543b435185f611cded5bccaf188e8c">bsl::set::count</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gabaf1d4963cc8d743420b1e1fb0f1b7c8">bsl::set::lower_bound</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gabdb10ced817bbdad3ed03106586af64c">bsl::set::upper_bound</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pair&lt; const_iterator, <br class="typebreak"/>
const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gadb9a412ca3dc2f701ce0824e286aed7b">bsl::set::equal_range</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gadc5c97041a3b7c06863fa093d37152f7">bsl::operator==</a> (const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga64f502a1498b19207f1e7812832dc833">bsl::operator!=</a> (const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gadcabb714950bc28dba72240a6a95324d">bsl::operator&lt;</a> (const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga2768d770127ea7018262726328633342">bsl::operator&gt;</a> (const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga5fad735708a2c5e2d67581a840f71f26">bsl::operator&lt;=</a> (const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#ga009ed5fb1156f5d23e0bc6a51386d986">bsl::operator&gt;=</a> (const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__set.html#gaac71b5ac0a4c5e73c7c96f14046f3e8f">bsl::swap</a> (set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;a, set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;b)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Requirements on <code>KEY</code></a> </li>
<li>
<a href="#3.2">Memory Allocation</a> <ul>
<li>
<a href="#3.2.1"><code>bslma</code>-Style Allocators</a> </li>
</ul>
</li>
<li>
<a href="#3.3">Operations</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: Creating a Holiday Calendar</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL-compliant set class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1set.html">bsl::set</a> </td><td>STL-compatible set template  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslstl__multiset.html" title="Provide an STL-compliant multiset class.">Component bslstl_multiset</a>, <a class="el" href="group__bslstl__map.html" title="Provide an STL-compliant map class.">Component bslstl_map</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a single class template <code>set</code>, implementing the standard container holding an ordered sequence of unique keys. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An instantiation of <code>set</code> is an allocator-aware, value-semantic type whose salient attributes are its size (number of keys) and the ordered sequence of keys the <code>set</code> contains. If <code>set</code> is instantiated with a key type that is not itself value-semantic, then it will not retain all of its value-semantic qualities. In particular, if the key type cannot be tested for equality, then a set containing that type cannot be tested for equality. It is even possible to instantiate <code>set</code> with a key type that does not have a copy-constructor, in which case the <code>set</code> will not be copyable. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A set meets the requirements of an associative container with bidirectional iterators in the C++ standard [23.2.4]. The <code>set</code> implemented here adheres to the C++11 standard, except that it does not have interfaces that take rvalue references, <code>initializer_lists</code>, <code>emplace</code>, or operations taking a variadic number of template parameters. Note that excluded C++11 features are those that require (or are greatly simplified by) C++11 compiler support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_on_key"></a> <a class="anchor" id="description.requirements_on_key"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Requirements on KEY: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code>set</code> is a fully <a href="group__bsldoc__glossary.html#value-semantic_type" class="glossary">Value-Semantic Type</a> (see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>) only if the supplied <code>KEY</code> template parameters is fully value-semantic. It is possible to instantiate a <code>set</code> with <code>KEY</code> parameter arguments that do not provide a full set of value-semantic operations, but then some methods of the container may not be instantiable. The following terminology, adopted from the C++11 standard, is used in the function documentation of <code>set</code> to describe a function's requirements for the <code>KEY</code> template parameter. These terms are also defined in section [17.6.3.1] of the C++11 standard. Note that, in the context of a <code>set</code> instantiation, the requirements apply specifically to the set's entry type, <code>value_type</code>, which is an alias for <code>KEY</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="default-constructible"></a> <a class="anchor" id="requirements_on_key.default-constructible"></a> <a class="anchor" id="description.requirements_on_key.default-constructible"></a> <em>default-constructible</em>: The type provides a default constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="copy-constructible"></a> <a class="anchor" id="requirements_on_key.copy-constructible"></a> <a class="anchor" id="description.requirements_on_key.copy-constructible"></a> <em>copy-constructible</em>: The type provides a copy constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="equality-comparable"></a> <a class="anchor" id="requirements_on_key.equality-comparable"></a> <a class="anchor" id="description.requirements_on_key.equality-comparable"></a> <em>equality-comparable</em>: The type provides an equality-comparison operator that defines an equivalence relationship and is both reflexive and transitive.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="less-than-comparable"></a> <a class="anchor" id="requirements_on_key.less-than-comparable"></a> <a class="anchor" id="description.requirements_on_key.less-than-comparable"></a> <em>less-than-comparable</em>: The type provides a less-than operator, which defines a strict weak ordering relation on values of the type.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_allocation"></a> <a class="anchor" id="description.memory_allocation"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The type supplied as a set's <code>ALLOCATOR</code> template parameter determines how that set will allocate memory. The <code>set</code> template supports allocators meeting the requirements of the C++11 standard [17.6.3.5], in addition it supports scoped-allocators derived from the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> memory allocation protocol. Clients intending to use <code>bslma</code> style allocators should use the template's default <code>ALLOCATOR</code> type: The default type for the <code>ALLOCATOR</code> template parameter, <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, provides a C++11 standard-compatible adapter for a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma-style_allocators"></a> <a class="anchor" id="memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="description.memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>bslma-Style Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the (template parameter) type <code>ALLOCATOR</code> of an <code>set</code> instantiation' is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, then objects of that set type will conform to the standard behavior of a <code>bslma</code>-allocator-enabled type. Such a set accepts an optional <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> argument at construction. If the address of a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object is explicitly supplied at construction, it will be used to supply memory for the set throughout its lifetime; otherwise, the set will use the default allocator installed at the time of the set's construction (see <code>bslma_default</code>). In addition to directly allocating memory from the indicated <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, a set supplies that allocator's address to the constructors of contained objects of the (template parameter) type <code>KEY</code> with the <code><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a></code> trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="operations"></a> <a class="anchor" id="description.operations"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section describes the run-time complexity of operations on instances of <code>set</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Legend
  ------
  <span class="charliteral">&#39;K&#39;</span>             - (<span class="keyword">template</span> parameter) type <span class="stringliteral">&#39;KEY&#39;</span> of the <span class="keyword">set</span>
  <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>        - two distinct objects of type <span class="stringliteral">&#39;set&lt;K&gt;&#39;</span>
  <span class="charliteral">&#39;n&#39;</span>, <span class="charliteral">&#39;m&#39;</span>        - number of elements in <span class="charliteral">&#39;a&#39;</span> and <span class="charliteral">&#39;b&#39;</span> respectively
  <span class="charliteral">&#39;c&#39;</span>             - comparator providing an ordering <span class="keywordflow">for</span> objects of type <span class="charliteral">&#39;K&#39;</span>
  <span class="stringliteral">&#39;al             - an STL-style memory allocator</span>
<span class="stringliteral">  &#39;</span>i1<span class="stringliteral">&#39;, &#39;</span>i2<span class="stringliteral">&#39;      - two iterators defining a sequence of &#39;</span>value_type<span class="stringliteral">&#39; objects</span>
<span class="stringliteral">  &#39;</span>k<span class="stringliteral">&#39;             - an object of type &#39;</span>K<span class="stringliteral">&#39;</span>
<span class="stringliteral">  &#39;</span>p1<span class="stringliteral">&#39;, &#39;</span>p2<span class="stringliteral">&#39;      - two iterators belonging to &#39;</span>a<span class="stringliteral">&#39;</span>
<span class="stringliteral">  distance(i1,i2) - the number of elements in the range [i1, i2)</span>
<span class="stringliteral"></span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | Operation                                          | Complexity         |</span>
<span class="stringliteral">  +====================================================+====================+</span>
<span class="stringliteral">  | set&lt;K&gt; a;    (default construction)                | O[1]               |</span>
<span class="stringliteral">  | set&lt;K&gt; a(al);                                      |                    |</span>
<span class="stringliteral">  | set&lt;K&gt; a(c, al);                                   |                    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | set&lt;K&gt; a(b); (copy construction)                   | O[n]               |</span>
<span class="stringliteral">  | set&lt;K&gt; a(b, al);                                   |                    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | set&lt;K&gt; a(i1, i2);                                  | O[N] if [i1, i2)   |</span>
<span class="stringliteral">  | set&lt;K&gt; a(i1, i2, al);                              | is sorted with     |</span>
<span class="stringliteral">  | set&lt;K&gt; a(i1, i2, c, al);                           | &#39;</span>a.value_comp()<span class="stringliteral">&#39;,  |</span>
<span class="stringliteral">  |                                                    | O[N * log(N)]      |</span>
<span class="stringliteral">  |                                                    | otherwise, where N |</span>
<span class="stringliteral">  |                                                    | is distance(i1,i2) |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.~set&lt;K&gt;(); (destruction)                         | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a = b;       (assignment)                          | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.begin(), a.end(), a.cbegin(), a.cend(),          | O[1]               |</span>
<span class="stringliteral">  | a.rbegin(), a.rend(), a.crbegin(), a.crend()       |                    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a == b, a != b                                     | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a &lt; b, a &lt;= b, a &gt; b, a &gt;= b                       | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.swap(b), swap(a,b)                               | O[1] if &#39;</span>a<span class="stringliteral">&#39; and    |</span>
<span class="stringliteral">  |                                                    | &#39;</span>b<span class="stringliteral">&#39; use the same   |</span>
<span class="stringliteral">  |                                                    | allocator,         |</span>
<span class="stringliteral">  |                                                    | O[n + m] otherwise |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.size()                                           | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.max_size()                                       | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.empty()                                          | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | get_allocator()                                    | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.insert(k)                                        | O[log(n)]          |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.insert(p1, k)                                    | amortized constant |</span>
<span class="stringliteral">  |                                                    | if the value is    |</span>
<span class="stringliteral">  |                                                    | inserted right     |</span>
<span class="stringliteral">  |                                                    | before p1,         |</span>
<span class="stringliteral">  |                                                    | O[log(n)]          |</span>
<span class="stringliteral">  |                                                    | otherwise          |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.insert(i1, i2)                                   | O[log(N) *         |</span>
<span class="stringliteral">  |                                                    |   distance(i1,i2)] |</span>
<span class="stringliteral">  |                                                    |                    |</span>
<span class="stringliteral">  |                                                    | where N is         |</span>
<span class="stringliteral">  |                                                    | n + distance(i1,i2)|</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(p1)                                        | amortized constant |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(k)                                         | O[log(n) +         |</span>
<span class="stringliteral">  |                                                    | a.count(k)]        |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(p1, p2)                                    | O[log(n) +         |</span>
<span class="stringliteral">  |                                                    | distance(p1, p2)]  |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(p1, p2)                                    | O[log(n) +         |</span>
<span class="stringliteral">  |                                                    | distance(p1, p2)]  |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.clear()                                          | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.key_comp()                                       | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.value_comp()                                     | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.find(k)                                          | O[log(n)]          |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.count(k)                                         | O[log(n) +         |</span>
<span class="stringliteral">  |                                                    | a.count(k)]        |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.lower_bound(k)                                   | O[log(n)]          |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.upper_bound(k)                                   | O[log(n)]          |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.equal_range(k)                                   | O[log(n)]          |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating a Holiday Calendar: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we will utilize <code><a class="el" href="classbsl_1_1set.html">bsl::set</a></code> to define and implement a class, <code>HolidayCalendar</code>, that provides a calendar that allows client to add and remove holiday dates and determine whether a particular date is a holiday. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define and implement the methods of a value-semantic type, <code>MyDate</code>, that represents a date: (Note that for brevity, we do not explicitly document the invariants of a valid date.) <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyDate {
      <span class="comment">// This class implements a value-semantic attribute class</span>
      <span class="comment">// characterizing a date according to the (Gregorian) Unix date</span>
      <span class="comment">// convention.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span> d_year;
      <span class="keywordtype">int</span> d_month;
      <span class="keywordtype">int</span> d_day;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      MyDate(<span class="keywordtype">int</span> year, <span class="keywordtype">int</span> month, <span class="keywordtype">int</span> day)
          <span class="comment">// Create a &#39;MyDate&#39; object having the value represented by the</span>
          <span class="comment">// specified &#39;year&#39;, &#39;month&#39;, and &#39;day.  The behavior is undefined</span>
          <span class="comment">// unless the value represented by &#39;year&#39;, &#39;month&#39;, and &#39;day is</span>
          <span class="comment">// valid.</span>
      : d_year(year), d_month(month), d_day(day)
      {
      }

      MyDate(<span class="keyword">const</span> MyDate&amp; original)
          <span class="comment">// Create a &#39;MyDate&#39; object having the same value as the specified</span>
          <span class="comment">// &#39;original&#39; object.</span>
      : d_year(original.d_year)
      , d_month(original.d_month)
      , d_day(original.d_day)
      {
      }

      <span class="comment">// ~MyDate() = default;</span>
          <span class="comment">// Destroy this object</span>

      <span class="comment">// MANIPULATORS</span>
      MyDate&amp; operator=(<span class="keyword">const</span> MyDate&amp; rhs)
          <span class="comment">// Assign to this object the value of the specified &#39;rhs&#39; object,</span>
          <span class="comment">// and return a reference providing modifiable access to this</span>
          <span class="comment">// object.</span>
      {
          d_year = rhs.d_year;
          d_month = rhs.d_month;
          d_day = rhs.d_day;
          <span class="keywordflow">return</span> *<span class="keyword">this</span>;
      }

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> year() const
          <span class="comment">// Return the year of this date.</span>
      {
          <span class="keywordflow">return</span> d_year;
      }

      <span class="keywordtype">int</span> month() const
          <span class="comment">// Return the month of this date.</span>
      {
          <span class="keywordflow">return</span> d_month;
      }

      <span class="keywordtype">int</span> day() const
          <span class="comment">// Return the day of this date.</span>
      {
          <span class="keywordflow">return</span> d_day;
      }

  };

  <span class="comment">// FREE FUNCTIONS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> MyDate&amp; lhs, <span class="keyword">const</span> MyDate&amp; rhs)
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same</span>
      <span class="comment">// value, and &#39;false&#39; otherwise.  Two &#39;MyDate&#39; objects have the same</span>
      <span class="comment">// value if each of their corresponding &#39;year&#39;, &#39;month&#39;, and &#39;day&#39;</span>
      <span class="comment">// attributes respective have the same value.</span>
  {
      <span class="keywordflow">return</span> lhs.year()  == rhs.year() &amp;&amp;
             lhs.month() == rhs.month() &amp;&amp;
             lhs.day()   == rhs.day();
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> MyDate&amp; lhs, <span class="keyword">const</span> MyDate&amp; rhs)
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  Two &#39;MyDate&#39; objects do not</span>
      <span class="comment">// have the same value if each of their corresponding &#39;year&#39;, &#39;month&#39;,</span>
      <span class="comment">// and &#39;day&#39; attributes respective do not have the same value.</span>
  {
      <span class="keywordflow">return</span> !(lhs == rhs);
  }
</pre></div><br/>
<br/>
 Then, we define a comparison functor for <code>MyDate</code> objects in order for them to be stored in a <code><a class="el" href="classbsl_1_1set.html">bsl::set</a></code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>MyDateLess {
      <span class="comment">// This &#39;struct&#39; defines an ordering on &#39;MyDate&#39; objects, allowing them</span>
      <span class="comment">// to be included in associative containers such as &#39;bsl::set&#39;.</span>

      <span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> MyDate&amp; lhs, <span class="keyword">const</span> MyDate&amp; rhs) <span class="keyword">const</span>
          <span class="comment">// Return &#39;true&#39; if the value of the specified &#39;lhs&#39; is less than</span>
          <span class="comment">// (ordered before) the value of the specified &#39;rhs&#39;, and &#39;false&#39;</span>
          <span class="comment">// otherwise.  The &#39;lhs&#39; value is considered less than the &#39;rhs&#39;</span>
          <span class="comment">// value if the date represented by &#39;lhs&#39; is earlier than the date</span>
          <span class="comment">// represented by &#39;rhs&#39; in time.</span>
      {
          <span class="keywordflow">if</span> (lhs.year() &lt; rhs.year()) <span class="keywordflow">return</span> <span class="keyword">true</span>;
          <span class="keywordflow">if</span> (lhs.year() == rhs.year()) {
              <span class="keywordflow">if</span> (lhs.month() &lt; rhs.month()) <span class="keywordflow">return</span> <span class="keyword">true</span>;
              <span class="keywordflow">if</span> (lhs.month() == rhs.month()) {
                  <span class="keywordflow">if</span> (lhs.day() &lt; rhs.day()) <span class="keywordflow">return</span> <span class="keyword">true</span>;
              }
          }
          <span class="keywordflow">return</span> <span class="keyword">false</span>;
      }
  };
</pre></div><br/>
<br/>
 Next, we define <code>HolidayCalendar</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>HolidayCalendar {
      <span class="comment">// This class provides a value semantic-type that allows clients to</span>
      <span class="comment">// modify and query a set of dates considered to be holidays.</span>
</pre></div><br/>
<br/>
 Here, we create a type alias, <code>DateSet</code>, for a <code><a class="el" href="classbsl_1_1set.html">bsl::set</a></code> that will serve as the data member for a <code>HolidayCalendar</code>. A <code>DateSet</code> has keys of type <code>MyDate</code>, and a comparator of type <code>MyDateLess</code>. We use the default <code>ALLOCATOR</code> template parameter as we intend to use <code>HolidayCalendar</code> with <code>bslma</code> style allocators: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// PRIVATE TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1set.html">bsl::set&lt;MyDate, MyDateLess&gt;</a> DateSet;
          <span class="comment">// This &#39;typedef&#39; is an alias for a set of &#39;MyDate&#39; objects.</span>

      <span class="comment">// DATA</span>
      DateSet d_holidayDates;  <span class="comment">// set of dates considered to be holidays</span>

    <span class="keyword">public</span>:
      <span class="comment">// PUBLIC TYPES</span>
      <span class="keyword">typedef</span> DateSet::const_iterator ConstIterator;
          <span class="comment">// This &#39;typedef&#39; provides an alias for the type of an iterator</span>
          <span class="comment">// providing non-modifiable access to holiday dates in a</span>
          <span class="comment">// &#39;HolidayCalendar&#39;.</span>

      <span class="comment">// CREATORS</span>
      HolidayCalendar(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an empty &#39;HolidayCalendar&#39; object.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      HolidayCalendar(<span class="keyword">const</span> HolidayCalendar&amp;  original,
                      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>       *basicAllocator = 0);
          <span class="comment">// Create a &#39;HolidayCalendar&#39; object having the same value as the</span>
          <span class="comment">// specified &#39;original&#39; object.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> addHolidayDate(<span class="keyword">const</span> MyDate&amp; date);
          <span class="comment">// Add the specified &#39;date&#39; as a holiday date maintained by this</span>
          <span class="comment">// calendar.  If &#39;date&#39; is already a holiday date, this method has</span>
          <span class="comment">// no effect.</span>

      <span class="keywordtype">void</span> removeHolidayDate(<span class="keyword">const</span> MyDate&amp; date);
          <span class="comment">// Remove the specify &#39;date&#39; from the set of holiday dates</span>
          <span class="comment">// maintained by this calendar.  If &#39;date&#39; is not a holiday date,</span>
          <span class="comment">// this method has no effect.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">bool</span> isHolidayDate(<span class="keyword">const</span> MyDate&amp; date) <span class="keyword">const</span>;
          <span class="comment">// Return &#39;true&#39; if the specified &#39;date&#39; is in the set of holiday</span>
          <span class="comment">// dates maintained by this calendar, and return &#39;false&#39; otherwise.</span>

      ConstIterator beginHolidayDates() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the first</span>
          <span class="comment">// date in the ordered sequence of holiday dates maintained by this</span>
          <span class="comment">// calendar.</span>

      ConstIterator endHolidayDates() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to</span>
          <span class="comment">// past-the-end date in the ordered sequence of holiday dates</span>
          <span class="comment">// maintained by this calendar.</span>
  };
</pre></div><br/>
<br/>
 Then, we declare the free operators for <code>HolidayCalendar</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> HolidayCalendar&amp; lhs, <span class="keyword">const</span> HolidayCalendar&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same</span>
      <span class="comment">// value, and &#39;false&#39; otherwise.  Two &#39;HolidayCalendar&#39; objects have</span>
      <span class="comment">// the same value if they have the same number of holiday dates, and</span>
      <span class="comment">// each corresponding holiday date, in their respective ordered</span>
      <span class="comment">// sequence of dates, is the same.</span>

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> HolidayCalendar&amp; lhs, <span class="keyword">const</span> HolidayCalendar&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  Two &#39;HolidayCalendar&#39;</span>
      <span class="comment">// objects do not have the same value if they either differ in their</span>
      <span class="comment">// number of holiday dates, or if any of the corresponding holiday</span>
      <span class="comment">// dates, in their respective ordered sequences of dates, is not the</span>
      <span class="comment">// same.</span>
</pre></div><br/>
<br/>
 Now, we define the implementations methods of the <code>HolidayCalendar</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  HolidayCalendar::HolidayCalendar(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_holidayDates(basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 Notice that, on construction, we pass the <code><a class="el" href="classbsl_1_1set.html">bsl::set</a></code> object the specified <code>bsl::Allocator</code> object. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">void</span> HolidayCalendar::addHolidayDate(<span class="keyword">const</span> MyDate&amp; date)
  {
      d_holidayDates.insert(date);
  }

  <span class="keywordtype">void</span> HolidayCalendar::removeHolidayDate(<span class="keyword">const</span> MyDate&amp; date)
  {
      d_holidayDates.erase(date);
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keywordtype">bool</span> HolidayCalendar::isHolidayDate(<span class="keyword">const</span> MyDate&amp; date)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_holidayDates.find(date) != d_holidayDates.end();
  }

  HolidayCalendar::ConstIterator HolidayCalendar::beginHolidayDates()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_holidayDates.begin();
  }

  HolidayCalendar::ConstIterator HolidayCalendar::endHolidayDates()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_holidayDates.end();
  }
</pre></div><br/>
<br/>
 Finally, we implement the free operators for <code>HolidayCalendar</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> HolidayCalendar&amp; lhs, <span class="keyword">const</span> HolidayCalendar&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.d_holidayDates == rhs.d_holidayDates;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> HolidayCalendar&amp; lhs, <span class="keyword">const</span> HolidayCalendar&amp; rhs)
  {
      <span class="keywordflow">return</span> !(lhs == rhs);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga2db6189f957c2a5f0de4265215cf56ff"></a><!-- doxytag: member="bsl::set::key_type" ref="ga2db6189f957c2a5f0de4265215cf56ff" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KEY <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::key_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae0dcd55ea7388ec8ded5752cc95d9e7a"></a><!-- doxytag: member="bsl::set::value_type" ref="gae0dcd55ea7388ec8ded5752cc95d9e7a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KEY <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6ea0a7098a7d4857efc6ce9b128ccf37"></a><!-- doxytag: member="bsl::set::key_compare" ref="ga6ea0a7098a7d4857efc6ce9b128ccf37" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef COMPARATOR <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::key_compare<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gacdba9bd632acbe60ba907471eed85e3e"></a><!-- doxytag: member="bsl::set::value_compare" ref="gacdba9bd632acbe60ba907471eed85e3e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef COMPARATOR <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::value_compare<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga278ab7b41df2997c57c7de4cb2c36fbe"></a><!-- doxytag: member="bsl::set::allocator_type" ref="ga278ab7b41df2997c57c7de4cb2c36fbe" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::allocator_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2af8f60b592b186017dad97cbb87109c"></a><!-- doxytag: member="bsl::set::reference" ref="ga2af8f60b592b186017dad97cbb87109c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_type&amp; <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga235244bffb72e576087d06c9eb2d01b5"></a><!-- doxytag: member="bsl::set::const_reference" ref="ga235244bffb72e576087d06c9eb2d01b5" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const value_type&amp; <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4cdf8a312c4d9158bae4a2e4c78431df"></a><!-- doxytag: member="bsl::set::size_type" ref="ga4cdf8a312c4d9158bae4a2e4c78431df" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::size_type <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga48550967a18557e281476d87fe3fd0e6"></a><!-- doxytag: member="bsl::set::difference_type" ref="ga48550967a18557e281476d87fe3fd0e6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::difference_type <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3cecef876f06124be9c505bfd29b4db1"></a><!-- doxytag: member="bsl::set::pointer" ref="ga3cecef876f06124be9c505bfd29b4db1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::pointer <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gacb32347b6b351552bfeb104dd60c640c"></a><!-- doxytag: member="bsl::set::const_pointer" ref="gacb32347b6b351552bfeb104dd60c640c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::const_pointer <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2f8e9cd8d701e9b1bbcdea4cac3438a8"></a><!-- doxytag: member="bsl::set::iterator" ref="ga2f8e9cd8d701e9b1bbcdea4cac3438a8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef BloombergLP::bslstl::TreeIterator&lt;const value_type, Node, difference_type&gt; <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6b8f1e11518593aa25a17ac44dec29a0"></a><!-- doxytag: member="bsl::set::const_iterator" ref="ga6b8f1e11518593aa25a17ac44dec29a0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef BloombergLP::bslstl::TreeIterator&lt;const value_type, Node, difference_type&gt; <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::const_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac2e33e570a360d8527a952105cb40f0b"></a><!-- doxytag: member="bsl::set::reverse_iterator" ref="gac2e33e570a360d8527a952105cb40f0b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;iterator&gt; <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa37e96e3dfe0572164845e1615ad5da4"></a><!-- doxytag: member="bsl::set::const_reverse_iterator" ref="gaa37e96e3dfe0572164845e1615ad5da4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;const_iterator&gt; <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::const_reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga968368c5a6a5145223f668be6e0e7a43"></a><!-- doxytag: member="bsl::set::DataWrapper::DataWrapper" ref="ga968368c5a6a5145223f668be6e0e7a43" args="(const COMPARATOR &amp;comparator, const ALLOCATOR &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::DataWrapper::DataWrapper </td>
          <td>(</td>
          <td class="paramtype">const COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>DataWrapper</code> object with the specified <code>comparator</code> and <code>allocator</code>. </p>

</div>
</div>
<a class="anchor" id="ga9167d8342a13068cbf1fe2791f3bfc7b"></a><!-- doxytag: member="bsl::set::set" ref="ga9167d8342a13068cbf1fe2791f3bfc7b" args="(const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;allocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em> = <code>COMPARATOR()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>allocator</em>&nbsp;</td><td>Construct an empty set. Optionally specify a <code>comparator</code> used to order keys contained in this object. If <code>comparator</code> is not supplied, a default-constructed object of the (template parameter) type <code>COMPARATOR</code> is used. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>ALLOCATOR</code> is used. If the <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>allocator</code>, if supplied, shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>allocator</code> is not supplied, the currently installed default allocator will be used to supply memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab65540ad4c9ffddb9343516f153d0087"></a><!-- doxytag: member="bsl::set::set" ref="gab65540ad4c9ffddb9343516f153d0087" args="(const ALLOCATOR &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an empty set that will use the specified <code>allocator</code> to supply memory. Use a default-constructed object of the (template parameter) type <code>COMPARATOR</code> to order the keys contained in this set. If the template parameter <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default) then <code>allocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. </p>

</div>
</div>
<a class="anchor" id="ga75231a89f6f2d0fe493036b6755229b5"></a><!-- doxytag: member="bsl::set::set" ref="ga75231a89f6f2d0fe493036b6755229b5" args="(const set &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a set having the same value as the specified <code>original</code>. Use a copy of <code>original.key_comp()</code> to order the keys contained in this set. Use the allocator returned by 'bslallocator_traits&lt;ALLOCATOR&gt;:: select_on_container_copy_construction(original.allocator())' to allocate memory. If the (template parameter) type <code>ALLOCATOR</code> is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), the currently installed default allocator will be used to supply memory. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__set.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__set.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gac50b939ee57c46b2e2a4039086c747bd"></a><!-- doxytag: member="bsl::set::set" ref="gac50b939ee57c46b2e2a4039086c747bd" args="(const set &amp;original, const ALLOCATOR &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a set having the same value as that of the specified <code>original</code> that will use the specified <code>allocator</code> to supply memory. Use a copy of <code>original.key_comp()</code> to order the keys contained in this set. If the template parameter <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default) then <code>allocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__set.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__set.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga0f6b17157e97d98728ba03e534135cb3"></a><!-- doxytag: member="bsl::set::set" ref="ga0f6b17157e97d98728ba03e534135cb3" args="(INPUT_ITERATOR first, INPUT_ITERATOR last, const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;allocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::set </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em> = <code>COMPARATOR()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a set, and insert each <code>value_type</code> object in the sequence starting at the specified <code>first</code> element, and ending immediately before the specified <code>last</code> element, ignoring those keys that appears earlier in the sequence. Optionally specify a <code>comparator</code> used to order keys contained in this object. If <code>comparator</code> is not supplied, a default-constructed object of the (template parameter) type <code>COMPARATOR</code> is used. Optionally specify a <code>allocator</code> used to supply memory. If <code>allocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>ALLOCATOR</code> is used. If the template parameter <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default) then <code>allocator</code>, if supplied, shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the template parameter <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>allocator</code> is not supplied, the currently installed default allocator will be used to supply memory. If the sequence <code>first</code> and <code>last</code> is ordered according to the identified <code>comparator</code> then this operation will have O[N] complexity, where N is the number of elements between <code>first</code> and <code>last</code>, otherwise this operation will have O[N * log(N)] complexity. The (template parameter) type <code>INPUT_ITERATOR</code> shall meet the requirements of an input iterator defined in the C++11 standard [24.2.3] providing access to values of a type convertible to <code>value_type</code>. The behavior is undefined unless <code>first</code> and <code>last</code> refer to a sequence of valid values where <code>first</code> is at a position at or before <code>last</code>. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__set.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__set.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga63683a3b20e23e9663006048d8949af7"></a><!-- doxytag: member="bsl::set::~set" ref="ga63683a3b20e23e9663006048d8949af7" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::~set </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="gaf419d52ab15f8c1cbeb9cbbc25f31241"></a><!-- doxytag: member="bsl::set::operator=" ref="gaf419d52ab15f8c1cbeb9cbbc25f31241" args="(const set &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">set&amp; <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value and comparator of the specified <code>rhs</code> object, propagate to this object the allocator of <code>rhs</code> if the <code>ALLOCATOR</code> type has trait <code>propagate_on_container_copy_assignment</code>, and return a reference providing modifiable access to this object. This method requires that the (template parameter) type <code>KEY</code> type be <a href="group__bslstl__set.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__set.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga59d32154f54376aa7cdb4c086e211a85"></a><!-- doxytag: member="bsl::set::begin" ref="ga59d32154f54376aa7cdb4c086e211a85" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this set, or the <code>end</code> iterator if this object is empty. </p>

</div>
</div>
<a class="anchor" id="gab180d3123dea011341881e0b40c3d3e5"></a><!-- doxytag: member="bsl::set::end" ref="gab180d3123dea011341881e0b40c3d3e5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the past-the-end element in the ordered sequence of <code>value_type</code> objects maintained by this set. </p>

</div>
</div>
<a class="anchor" id="ga04c3b2dcf67f139692c91738e5b801af"></a><!-- doxytag: member="bsl::set::rbegin" ref="ga04c3b2dcf67f139692c91738e5b801af" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing modifiable access to the last <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this set, or <code>rend</code> if this object is empty. </p>

</div>
</div>
<a class="anchor" id="ga8134367e82cf7e21a14220b1d4649dc8"></a><!-- doxytag: member="bsl::set::rend" ref="ga8134367e82cf7e21a14220b1d4649dc8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing modifiable access to the prior-to-the-beginning element in the ordered sequence of <code>value_type</code> objects maintained by this set. </p>

</div>
</div>
<a class="anchor" id="gac4147796e5d1fdda60e5646c4c114913"></a><!-- doxytag: member="bsl::set::insert" ref="gac4147796e5d1fdda60e5646c4c114913" args="(const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;iterator, bool&gt; <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__set.html#gae0dcd55ea7388ec8ded5752cc95d9e7a">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this set if the key (the <code>first</code> element) of the <code>value</code> does not already exist in this set; otherwise, if a <code>value_type</code> object the same as <code>value</code> already exists in this set, this method has no effect. Return a pair whose <code>first</code> member is an iterator referring to the (possibly newly inserted) <code>value_type</code> object in this set whose value is as that of <code>value</code>, and whose <code>second</code> member is <code>true</code> if a new value was inserted, and <code>false</code> if the value was already present. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__set.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__set.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga9bcd0dea344685633dea8c5f05c1e156"></a><!-- doxytag: member="bsl::set::insert" ref="ga9bcd0dea344685633dea8c5f05c1e156" args="(const_iterator hint, const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__set.html#ga6b8f1e11518593aa25a17ac44dec29a0">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__set.html#gae0dcd55ea7388ec8ded5752cc95d9e7a">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this set (in amortized constant time if the specified <code>hint</code> is a valid immediate successor to <code>value</code>), if the <code>value</code> does not already exist in this set; otherwise, if a <code>value_type</code> object the same as <code>value</code> already exists in this set, this method has no effect. Return an iterator referring to the (possibly newly inserted) <code>value_type</code> object that is the same as <code>value</code>. If <code>hint</code> is not a valid immediate successor to <code>value</code>, this operation will have O[log(N)] complexity, where <code>N</code> is the size of this set. The behavior is undefined unless <code>hint</code> is a valid iterator into this set. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__set.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__set.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaa233985535c18c105ad1e60ecfa89bfd"></a><!-- doxytag: member="bsl::set::insert" ref="gaa233985535c18c105ad1e60ecfa89bfd" args="(INPUT_ITERATOR first, INPUT_ITERATOR last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert into this set the value of each <code>value_type</code> object in the range starting at the specified <code>first</code> iterator and ending immediately before the specified <code>last</code> iterator, whose key is not already contained in this set. The (template parameter) type <code>INPUT_ITERATOR</code> shall meet the requirements of an input iterator defined in the C++11 standard [24.2.3] providing access to values of a type convertible to <code>value_type</code>. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__set.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__set.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gac0739d62f93db2d262610f9f26d3cf29"></a><!-- doxytag: member="bsl::set::erase" ref="gac0739d62f93db2d262610f9f26d3cf29" args="(const_iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__set.html#ga6b8f1e11518593aa25a17ac44dec29a0">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this set the <code>value_type</code> object at the specified <code>position</code>, and return an iterator referring to the element immediately following the removed element, or to the past-the-end position if the removed element was the last element in the sequence of elements maintained by this set. The behavior is undefined unless <code>position</code> refers to a <code>value_type</code> object in this set. </p>

</div>
</div>
<a class="anchor" id="ga93fd4ae6a5e2cf2bdbe73077942a7e1b"></a><!-- doxytag: member="bsl::set::erase" ref="ga93fd4ae6a5e2cf2bdbe73077942a7e1b" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__set.html#ga2db6189f957c2a5f0de4265215cf56ff">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remote from this set the specified <code>key</code>, if it exists, and return 1; otherwise, if there is no <code>value_type</code> that is the same as <code>key</code>, return 0 with no other effect. </p>

</div>
</div>
<a class="anchor" id="gaf186097236f420361194a912cc27d03b"></a><!-- doxytag: member="bsl::set::erase" ref="gaf186097236f420361194a912cc27d03b" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__set.html#ga6b8f1e11518593aa25a17ac44dec29a0">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__set.html#ga6b8f1e11518593aa25a17ac44dec29a0">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this set the <code>value_type</code> objects starting at the specified <code>first</code> position up to, but including the specified <code>last</code> position, and return <code>last</code>. The behavior is undefined unless <code>first</code> and <code>last</code> either refer to elements in this set or are the <code>end</code> iterator, and the <code>first</code> position is at or before the <code>last</code> position in the ordered sequence provided by this container. </p>

</div>
</div>
<a class="anchor" id="gacbb5758f822acac1009262b30158c1a8"></a><!-- doxytag: member="bsl::set::swap" ref="gacbb5758f822acac1009262b30158c1a8" args="(set &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1set.html">set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this object as well as its comparator with those of the specified <code>other</code> object. Additionally if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code> then exchange the allocator of this object with that of the <code>other</code> object, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee and guarantees O[1] complexity. The behavior is undefined is unless either this object was created with the same allocator as <code>other</code> or <code>propagate_on_container_swap</code> is <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="ga2dc35deb977fd2df2ec6c0234c4ecf3b"></a><!-- doxytag: member="bsl::set::clear" ref="ga2dc35deb977fd2df2ec6c0234c4ecf3b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all entries from this set. Note that the set is empty after this call, but allocated memory may be retained for future use. </p>

</div>
</div>
<a class="anchor" id="ga1d4dcb62ee26b65de7b2eb822c206365"></a><!-- doxytag: member="bsl::set::find" ref="ga1d4dcb62ee26b65de7b2eb822c206365" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__set.html#ga2db6189f957c2a5f0de4265215cf56ff">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the <code>value_type</code> object in this set that is the same as the specified <code>key</code>, if such an entry exists, and the past-the-end (<code>end</code>) iterator otherwise. </p>

</div>
</div>
<a class="anchor" id="ga04380ca82289b197d0ab6b8ef66b2edf"></a><!-- doxytag: member="bsl::set::lower_bound" ref="ga04380ca82289b197d0ab6b8ef66b2edf" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__set.html#ga2db6189f957c2a5f0de4265215cf56ff">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this set greater-than or equal-to the specified <code>key</code>, and the past-the-end iterator if this set does not contain a <code>value_type</code> greater-than or equal-to <code>key</code>. Note that this function returns the <em>first</em> position before which <code>key</code> could be inserted into the ordered sequence maintained by this set, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="gac940db389fc380b4fee44a7beae5df3b"></a><!-- doxytag: member="bsl::set::upper_bound" ref="gac940db389fc380b4fee44a7beae5df3b" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__set.html#ga2db6189f957c2a5f0de4265215cf56ff">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this set greater than the specified <code>key</code>, and the past-the-end iterator if this set does not contain a <code>value_type</code> object whose key is greater-than <code>key</code>. Note that this function returns the <em>last</em> position before which a <code>key</code> could be inserted into the ordered sequence maintained by this set, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="gab0397dfbb3ae6737d475c3bcd9349eb6"></a><!-- doxytag: member="bsl::set::equal_range" ref="gab0397dfbb3ae6737d475c3bcd9349eb6" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;iterator, iterator&gt; <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__set.html#ga2db6189f957c2a5f0de4265215cf56ff">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pair of iterators providing modifiable access to the sequence of <code>value_type</code> objects in this set the same as the specified <code>key</code>, where the the first iterator is positioned at the start of the sequence, and the second is positioned one past the end of the sequence. The first returned iterator will be <code>lower_bound(key)</code>; the second returned iterator will be <code>upper_bound(key)</code>; and, if this set contains no <code>value_type</code> objects having <code>key</code>, then the two returned iterators will have the same value. Note that since a set maintains unique keys, the range will contain at most one element. </p>

</div>
</div>
<a class="anchor" id="gada8ac5fa1be189ed2971f405b6ade58b"></a><!-- doxytag: member="bsl::set::get_allocator" ref="gada8ac5fa1be189ed2971f405b6ade58b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return (a copy of) the allocator used for memory allocation by this set. </p>

</div>
</div>
<a class="anchor" id="ga2aca9577a69e7d2829d42cb4bfd56439"></a><!-- doxytag: member="bsl::set::begin" ref="ga2aca9577a69e7d2829d42cb4bfd56439" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this set, or the <code>end</code> iterator if this set is empty. </p>

</div>
</div>
<a class="anchor" id="ga5f1edd91e23ff9c9e2eb390d347817e3"></a><!-- doxytag: member="bsl::set::end" ref="ga5f1edd91e23ff9c9e2eb390d347817e3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the past-the-end element in the ordered sequence of <code>value_type</code> objects maintained by this set. </p>

</div>
</div>
<a class="anchor" id="gaab77d60304cb4c95e6361dbbc9cd4f53"></a><!-- doxytag: member="bsl::set::rbegin" ref="gaab77d60304cb4c95e6361dbbc9cd4f53" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the last <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this set, or <code>rend</code> if this object is empty. </p>

</div>
</div>
<a class="anchor" id="ga5511baba5908387b3652f4713645d349"></a><!-- doxytag: member="bsl::set::rend" ref="ga5511baba5908387b3652f4713645d349" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the prior-to-the-beginning element in the ordered sequence of <code>value_type</code> objects maintained by this set. </p>

</div>
</div>
<a class="anchor" id="ga104dd9a9b6aaf21f0e8e15633373b8ad"></a><!-- doxytag: member="bsl::set::cbegin" ref="ga104dd9a9b6aaf21f0e8e15633373b8ad" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this set, or the <code>cend</code> iterator if this set is empty. </p>

</div>
</div>
<a class="anchor" id="gab123b6838099254ac81615cf1c429b41"></a><!-- doxytag: member="bsl::set::cend" ref="gab123b6838099254ac81615cf1c429b41" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the past-the-end element in the ordered sequence of <code>value_type</code> objects maintained by this set. </p>

</div>
</div>
<a class="anchor" id="ga07c01ec5842e778169b33311ca395f8f"></a><!-- doxytag: member="bsl::set::crbegin" ref="ga07c01ec5842e778169b33311ca395f8f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the last <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this set, or <code>crend</code> if this set is empty. </p>

</div>
</div>
<a class="anchor" id="ga37fe01c174ed0b90cd8a5ca1b56980f2"></a><!-- doxytag: member="bsl::set::crend" ref="ga37fe01c174ed0b90cd8a5ca1b56980f2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the prior-to-the-beginning element in the ordered sequence of <code>value_type</code> objects maintained by this set. </p>

</div>
</div>
<a class="anchor" id="ga6a4a224cdf8d4a463d14f39d313a73e9"></a><!-- doxytag: member="bsl::set::empty" ref="ga6a4a224cdf8d4a463d14f39d313a73e9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this set contains no elements, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga52ae060a7ee3db966f37a85a00efc611"></a><!-- doxytag: member="bsl::set::size" ref="ga52ae060a7ee3db966f37a85a00efc611" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements in this set. </p>

</div>
</div>
<a class="anchor" id="ga38b47c73229e8b6f9758fefbcd7bbbcf"></a><!-- doxytag: member="bsl::set::max_size" ref="ga38b47c73229e8b6f9758fefbcd7bbbcf" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a theoretical upper bound on the largest number of elements that this set could possibly hold. Note that there is no guarantee that the set can successfully grow to the returned size, or even close to that size without running out of resources. </p>

</div>
</div>
<a class="anchor" id="gaae1a64af26bb0c43674c732a47b33383"></a><!-- doxytag: member="bsl::set::key_comp" ref="gaae1a64af26bb0c43674c732a47b33383" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">key_compare <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the key-comparison functor (or function pointer) used by this set; if a comparator was supplied at construction, return its value, otherwise return a default constructed <code>key_compare</code> object. Note that this comparator compares objects of type <code>KEY</code>, which is the type of the <code>value_type</code> objects contained in this set. </p>

</div>
</div>
<a class="anchor" id="ga44b1e23b4c4b29e2fd67cd103717000e"></a><!-- doxytag: member="bsl::set::value_comp" ref="ga44b1e23b4c4b29e2fd67cd103717000e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_compare <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a functor for comparing two <code>value_type</code> objects using <code>key_comp()</code>. Note that since <code>value_type</code> is an alias to <code>KEY</code> for <code>set</code>, this method returns the same functor as <code>key_comp()</code>. </p>

</div>
</div>
<a class="anchor" id="gafaef6ddc1dd274ca146df3d6b12f2ea9"></a><!-- doxytag: member="bsl::set::find" ref="gafaef6ddc1dd274ca146df3d6b12f2ea9" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__set.html#ga2db6189f957c2a5f0de4265215cf56ff">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the <code>value_type</code> object in this set that is the same as the specified <code>key</code>, if such an entry exists, and the past-the-end (<code>end</code>) iterator otherwise. </p>

</div>
</div>
<a class="anchor" id="ga56543b435185f611cded5bccaf188e8c"></a><!-- doxytag: member="bsl::set::count" ref="ga56543b435185f611cded5bccaf188e8c" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__set.html#ga2db6189f957c2a5f0de4265215cf56ff">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of <code>value_type</code> objects within this set the the same as the specified <code>key</code>. Note that since a set maintains unique keys, the returned value will be either 0 or 1. </p>

</div>
</div>
<a class="anchor" id="gabaf1d4963cc8d743420b1e1fb0f1b7c8"></a><!-- doxytag: member="bsl::set::lower_bound" ref="gabaf1d4963cc8d743420b1e1fb0f1b7c8" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__set.html#ga2db6189f957c2a5f0de4265215cf56ff">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this set greater-than or equal-to the specified <code>key</code>, and the past-the-end iterator if this set does not contain a <code>value_type</code> greater-than or equal-to <code>key</code>. Note that this function returns the <em>first</em> position before which <code>key</code> could be inserted into the ordered sequence maintained by this set, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="gabdb10ced817bbdad3ed03106586af64c"></a><!-- doxytag: member="bsl::set::upper_bound" ref="gabdb10ced817bbdad3ed03106586af64c" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__set.html#ga2db6189f957c2a5f0de4265215cf56ff">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this set greater than the specified <code>key</code>, and the past-the-end iterator if this set does not contain a <code>value_type</code> object whose key is greater-than <code>key</code>. Note that this function returns the <em>last</em> position before which a <code>key</code> could be inserted into the ordered sequence maintained by this set, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="gadb9a412ca3dc2f701ce0824e286aed7b"></a><!-- doxytag: member="bsl::set::equal_range" ref="gadb9a412ca3dc2f701ce0824e286aed7b" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR  = std::less&lt;KEY&gt;, class ALLOCATOR  = allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;const_iterator, const_iterator&gt; <a class="el" href="classbsl_1_1set.html">bsl::set</a>&lt; KEY, COMPARATOR, ALLOCATOR &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__set.html#ga2db6189f957c2a5f0de4265215cf56ff">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pair of iterators providing non-modifiable access to the sequence of <code>value_type</code> objects in this set the same as the specified <code>key</code>, where the the first iterator is positioned at the start of the sequence, and the second is positioned one past the end of the sequence. The first returned iterator will be <code>lower_bound(key)</code>; the second returned iterator will be <code>upper_bound(key)</code>; and, if this set contains no <code>value_type</code> objects having <code>key</code>, then the two returned iterators will have the same value. Note that since a set maintains unique keys, the range will contain at most one element. </p>

</div>
</div>
<a class="anchor" id="gadc5c97041a3b7c06863fa093d37152f7"></a><!-- doxytag: member="bsl::operator==" ref="gadc5c97041a3b7c06863fa093d37152f7" args="(const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code>set</code> objects have the same value if they have the same number of keys, and each key that is contained in one of the objects is also contained in the other object. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__set.html#requirements_on_key.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__set.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga64f502a1498b19207f1e7812832dc833"></a><!-- doxytag: member="bsl::operator!=" ref="ga64f502a1498b19207f1e7812832dc833" args="(const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code>set</code> objects do not have the same value if they do not have the same number of keys, or some keys that is contained in one of the objects is not also contained in the other object. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__set.html#requirements_on_key.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__set.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gadcabb714950bc28dba72240a6a95324d"></a><!-- doxytag: member="bsl::operator&lt;" ref="gadcabb714950bc28dba72240a6a95324d" args="(const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is less than the specified <code>rhs</code> value, and <code>false</code> otherwise. A set, <code>lhs</code>, has a value that is less than that of <code>rhs</code>, if, for the first non-equal corresponding key in their respective sequences, the <code>lhs</code> key is less than the <code>rhs</code> key, or, if all their corresponding keys compare equal, <code>lhs</code> has fewer keys than <code>rhs</code>. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__set.html#requirements_on_key.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__set.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga2768d770127ea7018262726328633342"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga2768d770127ea7018262726328633342" args="(const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is greater than the specified <code>rhs</code> value, and <code>false</code> otherwise. A set, <code>lhs</code>, has a value that is greater than that of <code>rhs</code>, if, for the first non-equal corresponding key in their respective sequences, the <code>lhs</code> key is greater than the <code>rhs</code> key, or, if all their keys compare equal, <code>lhs</code> has more keys than <code>rhs</code>. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__set.html#requirements_on_key.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__set.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga5fad735708a2c5e2d67581a840f71f26"></a><!-- doxytag: member="bsl::operator&lt;=" ref="ga5fad735708a2c5e2d67581a840f71f26" args="(const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is less-than or equal-to the specified <code>rhs</code> value, and <code>false</code> otherwise. A set, <code>lhs</code>, has a value that is less-than or equal-to that of <code>rhs</code>, if, for the first non-equal corresponding key in their respective sequences, the <code>lhs</code> key is less than the <code>rhs</code> key, or, if all of their corresponding keys compare equal, <code>lhs</code> has less-than or equal number of keys as <code>rhs</code>. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__set.html#requirements_on_key.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__set.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga009ed5fb1156f5d23e0bc6a51386d986"></a><!-- doxytag: member="bsl::operator&gt;=" ref="ga009ed5fb1156f5d23e0bc6a51386d986" args="(const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is greater-than or equal-to the specified <code>rhs</code> value, and <code>false</code> otherwise. A set, <code>lhs</code>, has a value that is greater-than or equal-to that of <code>rhs</code>, if, for the first corresponding key in their respective sequences, the <code>lhs</code> key is greater than the <code>rhs</code> key, or, if all of their corresponding keys compare equal, <code>lhs</code> has greater-than or equal number of keys <code>rhs</code>. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__set.html#requirements_on_key.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__set.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaac71b5ac0a4c5e73c7c96f14046f3e8f"></a><!-- doxytag: member="bsl::swap" ref="gaac71b5ac0a4c5e73c7c96f14046f3e8f" args="(set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;a, set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; KEY, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap both the value and the comparator of the specified <code>a</code> object with the value and comparator of the specified <code>b</code> object. Additionally if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code> then exchange the allocator of <code>a</code> with that of <code>b</code>, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee and guarantees O[1] complexity. The behavior is undefined is unless either this object was created with the same allocator as <code>other</code> or <code>propagate_on_container_swap</code> is <code>true</code>. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:43 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
