<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslx_instreamfunctions Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslx_instreamfunctions<br/>
<small>
[<a class="el" href="group__bslx.html">Package bslx</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Facilitate uniform unexternalization of user and fundamental types.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslx.html">bslx</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Component Design, Anticipated Usage, and the BDEX Contract</a> <ul>
<li>
<a href="#3.1.1">Implementing BDEX Streaming in Value-Semantic Template Classes</a> </li>
</ul>
</li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Using <code>bslx::InStreamFunctions</code> to Unexternalize Data</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Facilitate uniform unexternalization of user and fundamental types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="namespacebslx_1_1InStreamFunctions.html">bslx::InStreamFunctions</a> </td><td>namespace for BDEX unexternalization functions  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslx__outstreamfunctions.html" title="Facilitate uniform externalization of user and fundamental types.">Component bslx_outstreamfunctions</a>, <a class="el" href="group__bslx__versionfunctions.html" title="Provide functions to return BDEX version information for types.">Component bslx_versionfunctions</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a namespace, <code><a class="el" href="namespacebslx_1_1InStreamFunctions.html">bslx::InStreamFunctions</a></code>, that facilitates uniform support for BDEX unexternalization across all BDEX-compliant user-defined types, including template types and containers, as well as those fundamental types (and <code>bsl::string</code> and <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a></code>) for which the BDEX protocol provides direct support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The namespace <code><a class="el" href="namespacebslx_1_1InStreamFunctions.html">bslx::InStreamFunctions</a></code> facilitates client unexternalization of objects in a uniform, type-independent manner. It contains the <code>bdexStreamIn</code> function that unexternalizes objects of all BDEX-compliant types. This function unexternalizes the specified <code>object</code> in the specified <code>version</code> or the <code>version</code> read from the input stream as required by the BDEX protocol. The <code>bdexStreamIn</code> function is overloaded for fundamental types, enumeration types, <code>bsl::string</code>, and <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a></code>. Note that, excluding <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a></code>, version information is never read from the stream while unexternalizing these types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>By default, objects of enumeration type are streamed in as 32-bit <code>int</code> values. Users can override this behavior by providing overloads of the <code>InStreamFunctions::bdexStreamIn</code> function in the enumeration's namespace for their enumeration types. The general form of this overload is: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebdlt.html#afc51da85db916b88828707653e987140">bdexStreamIn</a>(STREAM&amp; stream, MyEnum&amp; variable, <span class="keywordtype">int</span> version)
  {
      <span class="keyword">using</span> bslx::InStreamFunctions::bdexStreamIn;

      <span class="comment">// Code to stream in objects of &#39;MyEnum&#39; type.</span>

      <span class="keywordflow">return</span> stream;
  }
</pre></div><br/>
<br/>
 For value-semantic types that support the BDEX protocol, the free function <code>bdexStreamIn</code> calls the <code>bdexStreamIn</code> member function for that type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="component_design,_anticipated_usage,_and_the_bdex_contract"></a> <a class="anchor" id="description.component_design,_anticipated_usage,_and_the_bdex_contract"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Component Design, Anticipated Usage, and the BDEX Contract: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bslx_instreamfunctions</code> is an integral part of the BDEX unexternalization contract. The BDEX contract is at least in part "collaborative", which is to say that each developer of a given <em>kind</em> of component (e.g., a stream or a value-semantic container) must comply with the relevant portions of the contract to ensure that the "system as a whole" works for everybody. <code>bslx_instreamfunctions</code> plays several related but different roles in helping various developers to produce BDEX-compliant components. In this section we briefly highlight how and why <code>bslx_instreamfunctions</code> is helpful (or required) for these different developers. By discussing different aspects of usage, we convey the general design goals of this component, and, to a certain extent, the overall BDEX contract. See the <code>bslx</code> package-level documentation for a full specification of the BDEX contract. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="implementing_bdex_streaming_in_value-semantic_template_classes"></a> <a class="anchor" id="component_design,_anticipated_usage,_and_the_bdex_contract.implementing_bdex_streaming_in_value-semantic_template_classes"></a> <a class="anchor" id="description.component_design,_anticipated_usage,_and_the_bdex_contract.implementing_bdex_streaming_in_value-semantic_template_classes"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Implementing BDEX Streaming in Value-Semantic Template Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The author of a non-template value-semantic type has full knowledge of the details of the "value" of that type, and may choose to use the appropriate input stream <code>get</code> methods directly when implementing the required <code>bdexStreamIn</code> method for that type. However, if one or more aspects of the value are of template parameter type, then the author cannot in general know how to stream the value using the <code>get</code> methods. For example, if a type has as its value one <code>int</code> data member: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> d_value;
</pre></div><br/>
<br/>
 then the implementation of the <code>bdexStreamIn</code> method can contain: <br/>
<br/>
<div class="fragment"><pre class="fragment">  stream.getInt32(d_value);
</pre></div><br/>
<br/>
 However, if the data member is of (template parameter) <code>TYPE</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  TYPE d_value;
</pre></div><br/>
<br/>
 then the implementation of the <code>bdexStreamIn</code> method must rely on the <code><a class="el" href="namespacebslx_1_1InStreamFunctions.html">bslx::InStreamFunctions</a></code> implementation to input the value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">using</span> bslx::InStreamFunctions::bdexStreamIn;
  <a class="code" href="namespacebdlt.html#afc51da85db916b88828707653e987140">bdexStreamIn</a>(stream, d_value, 1);
</pre></div><br/>
<br/>
 This call will resolve to the correct sequence of <code>get</code> calls no matter whether <code>TYPE</code> is a fundamental type, a BDEX-compliant <code>enum</code>, or a proper BDEX-compliant class. In the latter two cases, the explicit specification of the version format (in this case, 1) guarantees the stable operation of this method whether or not <code>TYPE</code> is provided additional version formats. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_bslx~3A~3Ainstreamfunctions_to_unexternalize_data"></a> <a class="anchor" id="usage.example_1~3A_using_bslx~3A~3Ainstreamfunctions_to_unexternalize_data"></a> <a class="anchor" id="description.usage.example_1~3A_using_bslx~3A~3Ainstreamfunctions_to_unexternalize_data"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using bslx::InStreamFunctions to Unexternalize Data: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example we illustrate the primary intended use of the parameterized methods of this component, as well as a few trivial invocations just to show the syntax clearly. To accomplish this, we exhibit three separate example "components": an <code>enum</code>, a value-semantic point object, and an input stream. In all cases, the component designs are very simple, with much of the implied functionality omitted, in order to focus attention on the key aspects of the functionality of <em>this</em> component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, consider an <code>enum</code> <code>Color</code> that enumerates a set of colors: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> Color {
      RED   = 0,
      GREEN = 1,
      BLUE  = 2
  };
</pre></div><br/>
<br/>
 Next, we consider a very special-purpose point that has as a data member its color. Such a point provides an excellent opportunity for factoring, but since we are interested in highlighting BDEX streaming of various types, we will present a simple and unfactored design here. In a real-world problem, the <code>mypoint</code> component would be implemented differently. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the <code>MyPoint</code> class in this example represents its coordinates as <code>short</code> integer values; this is done to make the BDEX stream input byte pattern somewhat easier for the reader of this example to recognize when the input buffer is printed. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// mypoint.h</span>

  <span class="keyword">class </span>MyPoint {
      <span class="comment">// This class provides a geometric point having integer coordinates and</span>
      <span class="comment">// an enumerated color property.</span>

      <span class="keywordtype">short</span> d_x;      <span class="comment">// x coordinate</span>
      <span class="keywordtype">short</span> d_y;      <span class="comment">// y coordinate</span>
      Color d_color;  <span class="comment">// enumerated color property</span>

    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="comment">// ...</span>

      <span class="comment">// CREATORS</span>
      MyPoint();
          <span class="comment">// Create a default point.</span>

      MyPoint(<span class="keywordtype">short</span> x, <span class="keywordtype">short</span> y, Color color);
          <span class="comment">// Create a point having the specified &#39;x&#39; and &#39;y&#39; coordinates</span>
          <span class="comment">// and the specified &#39;color&#39;.</span>

      ~MyPoint();
          <span class="comment">// Destroy this point.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="comment">// ...</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">short</span> x() <span class="keyword">const</span>;
          <span class="comment">// Return the x coordinate of this point.</span>

      <span class="keywordtype">short</span> y() <span class="keyword">const</span>;
          <span class="comment">// Return the y coordinate of this point.</span>

      Color color() <span class="keyword">const</span>;
          <span class="comment">// Return the enumerated color of this point.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebdlt.html#afc51da85db916b88828707653e987140">bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version);
          <span class="comment">// Assign to this object the value read from the specified input</span>
          <span class="comment">// &#39;stream&#39; using the specified &#39;version&#39; format, and return a</span>
          <span class="comment">// reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this</span>
          <span class="comment">// operation has no effect.  If &#39;version&#39; is not supported, this</span>
          <span class="comment">// object is unaltered and &#39;stream&#39; is invalidated, but otherwise</span>
          <span class="comment">// unmodified.  If &#39;version&#39; is supported but &#39;stream&#39; becomes</span>
          <span class="comment">// invalid during this operation, this object has an undefined, but</span>
          <span class="comment">// valid, state.  Note that no version is read from &#39;stream&#39;.  See</span>
          <span class="comment">// the &#39;bslx&#39; package-level documentation for more information on</span>
          <span class="comment">// BDEX streaming of value-semantic types and containers.</span>
  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aa87851224efdfae6f5f519901c970262">operator==</a>(<span class="keyword">const</span> MyPoint&amp; lhs, <span class="keyword">const</span> MyPoint&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; points have the same</span>
      <span class="comment">// value, and &#39;false&#39; otherwise.  Two points have the same value if</span>
      <span class="comment">// they have the same x and y coordinates and the same color.</span>
</pre></div><br/>
<br/>
 Representative (inline) implementations of these methods are shown below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// ========================================================================</span>
  <span class="comment">//                      INLINE FUNCTION DEFINITIONS</span>
  <span class="comment">// ========================================================================</span>

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  MyPoint::MyPoint()
  {
  }

  <span class="keyword">inline</span>
  MyPoint::MyPoint(<span class="keywordtype">short</span> x, <span class="keywordtype">short</span> y, Color color)
  : d_x(x)
  , d_y(y)
  , d_color(color)
  {
  }

  <span class="keyword">inline</span>
  MyPoint::~MyPoint()
  {
  }

  <span class="comment">// ...</span>

  <span class="comment">// MANIPULATORS</span>
  <span class="comment">// ...</span>

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  Color MyPoint::color()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_color;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">short</span> MyPoint::x()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_x;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">short</span> MyPoint::y()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_y;
  }
  <span class="comment">// ...</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebdlt.html#afc51da85db916b88828707653e987140">MyPoint::bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)
  {
      <span class="keywordflow">switch</span> (version) {
        <span class="keywordflow">case</span> 1: {
          stream.getInt16(d_x);           <span class="comment">// input the x coordinate</span>
          stream.getInt16(d_y);           <span class="comment">// input the y coordinate</span>
          <span class="keywordtype">char</span> color;
          stream.getInt8(color);          <span class="comment">// input the color enum as one byte</span>
          d_color = <span class="keyword">static_cast&lt;</span>Color<span class="keyword">&gt;</span>(color);
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>: {
          stream.invalidate();
        } <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">return</span> stream;
  }

  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aa87851224efdfae6f5f519901c970262">operator==</a>(<span class="keyword">const</span> MyPoint&amp; lhs, <span class="keyword">const</span> MyPoint&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.x()     == rhs.x()
          &amp;&amp; lhs.y()     == rhs.y()
          &amp;&amp; lhs.color() == rhs.color();
  }
</pre></div><br/>
<br/>
 Then, we will implement an extremely simple input stream that supports the BDEX documentation-only protocol. For simplicity, we will use an externally managed buffer, and will only show a few methods needed for this example. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// myinstream.h</span>
  <span class="comment">// ...</span>

 <span class="keyword">class </span>MyInStream {
     <span class="comment">// This class implements a limited-size fixed-buffer input stream that</span>
     <span class="comment">// partially conforms to the BDEX protocol for input streams.  This</span>
     <span class="comment">// class is suitable for demonstration purposes only.</span>

     <span class="keyword">const</span> <span class="keywordtype">char</span> *d_buffer;  <span class="comment">// input buffer, held but not owned</span>
     <span class="keywordtype">int</span>         d_length;  <span class="comment">// length of &#39;d_buffer&#39; (bytes)</span>
     <span class="keywordtype">int</span>         d_cursor;  <span class="comment">// cursor (index into &#39;d_buffer&#39;)</span>

   <span class="keyword">public</span>:
     <span class="comment">// CREATORS</span>
     MyInStream(<span class="keyword">const</span> <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> length);
         <span class="comment">// Create an input stream using the specified &#39;buffer&#39; having the</span>
         <span class="comment">// specified &#39;length&#39; (in bytes).</span>

     ~MyInStream();
         <span class="comment">// Destroy this input byte stream.</span>

     <span class="comment">// MANIPULATORS</span>
     MyInStream&amp; getVersion(<span class="keywordtype">int</span>&amp; version);
         <span class="comment">// Consume a version value from this input stream, store that value</span>
         <span class="comment">// in the specified &#39;version&#39;, and return a reference to this</span>
         <span class="comment">// stream.  ...</span>

     MyInStream&amp; getInt32(<span class="keywordtype">int</span>&amp; value);
         <span class="comment">// Consume a 32-bit signed integer value from this input stream,</span>
         <span class="comment">// store that value in the specified &#39;value&#39;, and return a reference</span>
         <span class="comment">// to this stream.  ...</span>

     MyInStream&amp; getInt16(<span class="keywordtype">short</span>&amp; value);
         <span class="comment">// Consume a 16-bit signed integer value from this input stream,</span>
         <span class="comment">// store that value in the specified &#39;value&#39;, and return a reference</span>
         <span class="comment">// to this stream.  ...</span>

     MyInStream&amp; getInt8(<span class="keywordtype">char</span>&amp; value);
         <span class="comment">// Consume an 8-bit signed integer value from this input stream,</span>
         <span class="comment">// store that value in the specified &#39;value&#39;, and return a reference</span>
         <span class="comment">// to this stream.  ...</span>

     <span class="keywordtype">void</span> invalidate();
         <span class="comment">// Put this input stream in an invalid state.  ...</span>

     <span class="comment">// ACCESSORS</span>
     operator const void *() <span class="keyword">const</span>;
         <span class="comment">// Return a non-zero value if this stream is valid, and 0</span>
         <span class="comment">// otherwise.  An invalid stream is a stream in which insufficient</span>
         <span class="comment">// or invalid data was detected during an extraction operation.</span>
         <span class="comment">// Note that an empty stream will be valid unless an extraction</span>
         <span class="comment">// attempt or explicit invalidation causes it to be otherwise.</span>

     <span class="keywordtype">int</span> cursor() <span class="keyword">const</span>;
         <span class="comment">// Return the index of the next byte to be extracted from this</span>
         <span class="comment">// stream.</span>

     <span class="keywordtype">bool</span> isEmpty() <span class="keyword">const</span>;
          <span class="comment">// Return &#39;true&#39; if this stream is empty, and &#39;false&#39; otherwise.</span>
          <span class="comment">// Note that this function enables higher-level types to verify</span>
          <span class="comment">// that, after successfully reading all expected data, no data</span>
          <span class="comment">// remains.</span>

     <span class="keywordtype">int</span> length() <span class="keyword">const</span>;
         <span class="comment">// Return the total number of bytes stored in this stream.</span>
 };
</pre></div><br/>
<br/>
 The relevant (inline) implementations are as follows. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// ========================================================================</span>
  <span class="comment">//                      INLINE FUNCTION DEFINITIONS</span>
  <span class="comment">// ========================================================================</span>

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  MyInStream::MyInStream(<span class="keyword">const</span> <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> length)
  : d_buffer(buffer)
  , d_length(length)
  , d_cursor(0)
  {
  }

  <span class="keyword">inline</span>
  MyInStream::~MyInStream()
  {
  }

  <span class="comment">// MANIPULATORS</span>

  <span class="keyword">inline</span>
  MyInStream&amp; MyInStream::getVersion(<span class="keywordtype">int</span>&amp; value)
  {
      value = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(d_buffer[d_cursor++]);
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  MyInStream&amp; MyInStream::getInt32(<span class="keywordtype">int</span>&amp; value)
  {
      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buffer =
                           <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(d_buffer);
      value = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>((buffer[d_cursor    ] &lt;&lt; 24U) |
                               (buffer[d_cursor + 1] &lt;&lt; 16U) |
                               (buffer[d_cursor + 2] &lt;&lt;  8U) |
                               (buffer[d_cursor + 3]       ));
      d_cursor += 4;
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  MyInStream&amp; MyInStream::getInt16(<span class="keywordtype">short</span>&amp; value)
  {
      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buffer =
                           <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(d_buffer);
      value = <span class="keyword">static_cast&lt;</span><span class="keywordtype">short</span><span class="keyword">&gt;</span>((buffer[d_cursor    ] &lt;&lt;  8) |
                                 (buffer[d_cursor + 1]      ));
      d_cursor += 2;
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
   }

  <span class="keyword">inline</span>
  MyInStream&amp; MyInStream::getInt8(<span class="keywordtype">char</span>&amp; value)
  {
      value = d_buffer[d_cursor];
      d_cursor += 1;
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> MyInStream::invalidate()
  {
      d_buffer = 0;
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  MyInStream::operator const void *()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_cursor &lt;= d_length ? d_buffer : 0;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyInStream::cursor()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_cursor;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> MyInStream::isEmpty()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_cursor &gt;= d_length;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyInStream::length()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_length;
  }
</pre></div><br/>
<br/>
 Finally, use the above <code>enum</code>, point class, and input stream to illustrate <code><a class="el" href="namespacebslx_1_1InStreamFunctions.html">bslx::InStreamFunctions</a></code> functionality. This test code does not attempt to do anything more useful than reading values from a stream whose buffer was written "by hand" and confirming that the expected values were read correctly from the known byte pattern in the buffer. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">using</span> bslx::InStreamFunctions::bdexStreamIn;

  {
      <span class="keyword">const</span> <span class="keywordtype">int</span>  EXP       = 0x0A0B0C0D;
      <span class="keyword">const</span> <span class="keywordtype">char</span> buffer[4] = { 0xA, 0xB, 0xC, 0xD };  <span class="comment">// &#39;int&#39; (no version)</span>
      <span class="keywordtype">int</span>        i         = 0;

      MyInStream in1(buffer, 4);  <span class="comment">// use the one buffer</span>
      <a class="code" href="namespacebdlt.html#afc51da85db916b88828707653e987140">bdexStreamIn</a>(in1, i, 1);
      assert(in1);  assert(EXP == i);

      i = 0;                      <span class="comment">// reset &#39;i&#39;</span>
      MyInStream in2(buffer, 4);  <span class="comment">// re-use &#39;buffer (no version)</span>
      <a class="code" href="namespacebdlt.html#afc51da85db916b88828707653e987140">bdexStreamIn</a>(in2, i, 0);
      assert(in2);  assert(EXP == i);
  }

  {
      <span class="keyword">const</span> MyPoint EXP(0, -1, BLUE);
      <span class="keyword">const</span> <span class="keywordtype">char</span> buffer1[5] = { 0, 0, -1, -1, 2 };     <span class="comment">// &#39;MyPoint&#39; (no ver)</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> buffer2[6] = { 1, 0, 0, -1, -1, 2 };  <span class="comment">// version, &#39;MyPoint&#39;</span>
      MyPoint p1, p2;  <span class="comment">// two default points</span>

      MyInStream in1(buffer1, 5);  <span class="comment">// &#39;buffer1&#39; has no version byte</span>
      <a class="code" href="namespacebdlt.html#afc51da85db916b88828707653e987140">bdexStreamIn</a>(in1, p1, 1);
      assert(in1);  assert(EXP == p1);

      MyInStream in2(buffer2, 6);  <span class="comment">// &#39;buffer2&#39; *has* a version</span>
      <span class="keywordtype">int</span> version;
      in2.getVersion(version);
      assert(1 == version);
      <a class="code" href="namespacebdlt.html#afc51da85db916b88828707653e987140">bdexStreamIn</a>(in2, p2, version);
      assert(in2);  assert(EXP == p2);
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:24 for BDE Release 2.23.1 Open-Source by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
