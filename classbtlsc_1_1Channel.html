<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlsc::Channel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlsc.html">btlsc</a>      </li>
      <li><a class="el" href="classbtlsc_1_1Channel.html">btlsc::Channel</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlsc::Channel Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlsc::Channel" -->
<p><code>#include &lt;<a class="el" href="btlsc__channel_8h_source.html">btlsc_channel.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlsc::Channel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlsc_1_1Channel.png" usemap="#btlsc::Channel_map" alt=""/>
  <map id="btlsc::Channel_map" name="btlsc::Channel_map">
<area href="classbtlsc_1_1TimedChannel.html" alt="btlsc::TimedChannel" shape="rect" coords="0,56,151,80"/>
<area href="classbtlsos_1_1TcpChannel.html" alt="btlsos::TcpChannel" shape="rect" coords="161,56,312,80"/>
<area href="classbtlsos_1_1TcpTimedChannel.html" alt="btlsos::TcpTimedChannel" shape="rect" coords="0,112,151,136"/>
</map>
</div>

<p><a href="classbtlsc_1_1Channel-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#af6b506b77480deaa4c568e54fff55483">~Channel</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a7d1d3187198316fffcc8d08b7e8786a3">read</a> (char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a644cd29a99f7be2fd646d574a3a4e9d8">read</a> (int *augStatus, char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a2b26b82cfc6a061e214731bb8c1485ff">readv</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a2606f75082b4dc81a79e8ac6a9abdb7f">readv</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a0f1f507ecd97fcdf09cfea3e6db6f8a4">readRaw</a> (char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a16812cf3507d1f1c02dfccc3e28890a0">readRaw</a> (int *augStatus, char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#af67ae242a8d90cd3e1f7a646021b8b6a">readvRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#af30686c7fad7e62c4367ba62646d5e05">readvRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a25814ffdbbe699bf33af793c701f233f">bufferedRead</a> (const char **buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a8cd68049ca8edc3e80d5f36ade6aac2f">bufferedRead</a> (int *augStatus, const char **buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a3c565a7f18a2515c6d00459db5ce7374">bufferedReadRaw</a> (const char **buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#addbe8479c8251f6eade148029fddd2de">bufferedReadRaw</a> (int *augStatus, const char **buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a707d767695090653fcf137f77e934caa">write</a> (const char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a3f49d7e1fdaba60d733ffe95649a7549">write</a> (int *augStatus, const char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a0642d2cf21c570446af7f63b748b382d">writeRaw</a> (const char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#afce89ca4cbe8df392ea0fc2b7cb18134">writeRaw</a> (int *augStatus, const char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#af3be1ce9b3d03861d143b45b97132f5a">writev</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a09eba049efd10344351ff5b4622f7e0e">writev</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a3206ad8bcf977c74579538b493b25d1b">writev</a> (int *augStatus, const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a0e798cdf27aa1971e22a15039c44db8d">writev</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#abf4d5f6379e59ce8b026a78a1567c95f">writevRaw</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a44ce53caa3bab5c448a35634e3918ffa">writevRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a993810b91aa73a1ce659aa9a3cd59d93">writevRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a0223adc9241f6d19264a7e38b2f61677">writevRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#adc7cc9dfc2e802578f09dd2c0418523c">invalidate</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1Channel.html#a115e9e4d1c7e221d8b8ed7f6fe0a63d9">isInvalid</a> () const =0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class defines a protocol (pure abstract interface) for a synchronous communications channel that supports blocking read, write, and buffered read operations on a byte stream. In general, a non-negative status indicates the number of bytes read or written, while a negative status implies an unspecified error. Note that an error status of -1 indicates that the connection is <em>known</em> to have been closed by the peer. The reverse, however, is not true. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af6b506b77480deaa4c568e54fff55483"></a><!-- doxytag: member="btlsc::Channel::~Channel" ref="af6b506b77480deaa4c568e54fff55483" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual btlsc::Channel::~Channel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7d1d3187198316fffcc8d08b7e8786a3"></a><!-- doxytag: member="btlsc::Channel::read" ref="a7d1d3187198316fffcc8d08b7e8786a3" args="(char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::read </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#aa6e7d7a43e3c921e3b7994143838c8a5">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#af14f64a0aac038e0b360f8175f6cd473">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a735286c8d0703c95f0ce7b46d34fc2f6">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a644cd29a99f7be2fd646d574a3a4e9d8"></a><!-- doxytag: member="btlsc::Channel::read" ref="a644cd29a99f7be2fd646d574a3a4e9d8" args="(int *augStatus, char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::read </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into the specified <code>buffer</code> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#ab59fde4eed8bf2f5b75ed60b550b7b11">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a8c111f955cb826006df63da7f28e98dd">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a59c8d4a5dde54f787d434b6454390b07">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a2b26b82cfc6a061e214731bb8c1485ff"></a><!-- doxytag: member="btlsc::Channel::readv" ref="a2b26b82cfc6a061e214731bb8c1485ff" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::readv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#ae3295a2d86824880eeb24d1c099776f1">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#abfa86357fa769a0bddcba1928f64fe12">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ad59b39102e0c16ba67133ed01c56fd16">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a2606f75082b4dc81a79e8ac6a9abdb7f"></a><!-- doxytag: member="btlsc::Channel::readv" ref="a2606f75082b4dc81a79e8ac6a9abdb7f" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::readv </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into the specified sequence of <code>buffers</code> of the specified sequence length <code>numBuffers</code> the respective number of bytes as specified in each <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> buffer. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a partial result. Return <code>numBytes</code> (i.e., the sum of calls to <code>length</code> on the <code>numBuffers</code> <code>buffers</code>) on success, a negative value on error, and the number of bytes newly read into <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffers</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffers</code> have sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#ad432f1bf2480dfa35ce1bfe5af096971">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a3fb80978899981b358d2520b99ff4bb1">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#af7eb08a819a2467f2c35130558e65ec8">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a0f1f507ecd97fcdf09cfea3e6db6f8a4"></a><!-- doxytag: member="btlsc::Channel::readRaw" ref="a0f1f507ecd97fcdf09cfea3e6db6f8a4" args="(char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::readRaw </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#a6504f4a2919416095a920659e93d83ed">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#af1a8e0b4de4317b7f3422da87e4c1581">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#af3a53d360e6d321c27cdc779a718db64">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a16812cf3507d1f1c02dfccc3e28890a0"></a><!-- doxytag: member="btlsc::Channel::readRaw" ref="a16812cf3507d1f1c02dfccc3e28890a0" args="(int *augStatus, char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::readRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into the specified <code>buffer</code> <em>at</em> <em>most</em> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#a77dd10d5c91167f74215b4a076da2447">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#ad46f00904abce4dab21b57a5d876586d">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a17a3b84250892eb51666082bc641ce73">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="af67ae242a8d90cd3e1f7a646021b8b6a"></a><!-- doxytag: member="btlsc::Channel::readvRaw" ref="af67ae242a8d90cd3e1f7a646021b8b6a" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::readvRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#a11afd2f67cc89ab2360489daaa997275">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a8bd88f1ca5622c67613641aa50142ee4">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a759d571ee9286c1e0aa53e2ebdbe1488">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="af30686c7fad7e62c4367ba62646d5e05"></a><!-- doxytag: member="btlsc::Channel::readvRaw" ref="af30686c7fad7e62c4367ba62646d5e05" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::readvRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into the specified sequence of <code>buffers</code> of the specified sequence length <code>numBuffers</code> <em>at</em> <em>most</em> the number of bytes as the sum of length in each <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> buffer. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> (i.e., the sum of calls to <code>length</code> on the <code>numBuffers</code> <code>buffers</code>) on success, a negative value on error, and the number of bytes newly read into <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffers</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffers</code> have sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#afda9947efb6bbe61076ef27002033468">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a90bb4042fe70f09465d844602a6344d4">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a75795b4d4304bcf7330a14e704f9c39c">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a25814ffdbbe699bf33af793c701f233f"></a><!-- doxytag: member="btlsc::Channel::bufferedRead" ref="a25814ffdbbe699bf33af793c701f233f" args="(const char **buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::bufferedRead </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#a87d383bf17a44ac7792cd4a3cb49d5c2">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a8575f05723c30047d5845ceb91fa7f09">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a8eecaa9c994297962c059abf53d14385">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a8cd68049ca8edc3e80d5f36ade6aac2f"></a><!-- doxytag: member="btlsc::Channel::bufferedRead" ref="a8cd68049ca8edc3e80d5f36ade6aac2f" args="(int *augStatus, const char **buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::bufferedRead </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into a channel-supplied buffer, identified via the specified <code>buffer</code>, the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes (indicating a partial result) otherwise. Any positive return value guarantees that <code>buffer</code> will remain valid until this channel is modified. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried with some reasonable hope of success -- buffered data from a partial result remains available until consumed by subsequent read operations. A negative "status", however, indicates a permanent error (leaving <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#a06af323598ea8128962ad58c3f395541">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a1dc3bc3538b0f599e984dfd5cea462d4">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a72f72ac59fd245a2e7de7f7c50854a01">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a3c565a7f18a2515c6d00459db5ce7374"></a><!-- doxytag: member="btlsc::Channel::bufferedReadRaw" ref="a3c565a7f18a2515c6d00459db5ce7374" args="(const char **buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::bufferedReadRaw </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#a5dd4767cd340cb49fba9cd7eef322252">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a797db168d475a9a427b6fe53e744426e">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#aae5cee6d0a2819d4588d19e7df896499">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="addbe8479c8251f6eade148029fddd2de"></a><!-- doxytag: member="btlsc::Channel::bufferedReadRaw" ref="addbe8479c8251f6eade148029fddd2de" args="(int *augStatus, const char **buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::bufferedReadRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into a channel-supplied buffer, identified via the specified <code>buffer</code>, <em>at</em> <em>most</em> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes (indicating a partial result) otherwise. Any positive return value guarantees that <code>buffer</code> will remain valid until this channel is modified. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation, or a negative value if the atomic OS-level operation transmitted at least one but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried with some reasonable hope of success -- buffered data from a partial result remains available until consumed by subsequent read operations. A negative "status", however, indicates a permanent error (leaving <code>buffer</code> unset); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#af5232093e6c2db53f2df06b79e4adf49">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#af1af8f79728ddfcead83ff141af79c68">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ad86fbea8e77192280b02c7e7380269ed">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a707d767695090653fcf137f77e934caa"></a><!-- doxytag: member="btlsc::Channel::write" ref="a707d767695090653fcf137f77e934caa" args="(const char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::write </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#af4618ca1d8246c5b1b7cd80aa22c6f3e">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a7f68287fd842e2fe1703afe3ccac198b">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ab4d083426f2b0fc2e3f24b56efb0c3ee">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a3f49d7e1fdaba60d733ffe95649a7549"></a><!-- doxytag: member="btlsc::Channel::write" ref="a3f49d7e1fdaba60d733ffe95649a7549" args="(int *augStatus, const char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::write </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this channel from the specified <code>buffer</code> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#a9676b599f143bb2e557f6d2f35d87e7e">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a08d2c91daf451dba35b7c98602a2b392">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ae585e569a0d7fb45379e56e707892f2c">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a0642d2cf21c570446af7f63b748b382d"></a><!-- doxytag: member="btlsc::Channel::writeRaw" ref="a0642d2cf21c570446af7f63b748b382d" args="(const char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::writeRaw </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#ae2f0f4ee7ddc0fac11e4a4e14aed2fb1">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a4e100baaacce372a6d370642f5aafb41">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a897717b587849e0bcd99402e8dac6ed5">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="afce89ca4cbe8df392ea0fc2b7cb18134"></a><!-- doxytag: member="btlsc::Channel::writeRaw" ref="afce89ca4cbe8df392ea0fc2b7cb18134" args="(int *augStatus, const char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::writeRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> write to this channel from the specified <code>buffer</code> <em>at</em> <em>most</em> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#a18a872e47d6bed16924712c3d208b3b4">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a8a20396397f9635f5c420a8461660dfc">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a93998cf7d4b5ecc4e5a1e6ec35bf490b">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="af3be1ce9b3d03861d143b45b97132f5a"></a><!-- doxytag: member="btlsc::Channel::writev" ref="af3be1ce9b3d03861d143b45b97132f5a" args="(const btls::Ovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::writev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#abe0bcbc0fdb4df6e8ab99bea0740923a">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#af5a278f2f9ad9dca29b51eafc82bd667">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ae77fa6e093fdcf83866266c8a700d020">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a09eba049efd10344351ff5b4622f7e0e"></a><!-- doxytag: member="btlsc::Channel::writev" ref="a09eba049efd10344351ff5b4622f7e0e" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::writev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#af1e9c9795a24ffca18f6fc9d07c36760">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a3d955e8f0bc471c8a6b2a05def918484">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a00d5d3982a1e42735189a2ab29ca4087">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a3206ad8bcf977c74579538b493b25d1b"></a><!-- doxytag: member="btlsc::Channel::writev" ref="a3206ad8bcf977c74579538b493b25d1b" args="(int *augStatus, const btls::Ovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::writev </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#ac0274a4ba4cd0435ab4052d537c94256">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#aefbb4691997305b8a7fac158d510bfe2">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#aeb9ad24d386b174c7d75c5c0c5f5ab85">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a0e798cdf27aa1971e22a15039c44db8d"></a><!-- doxytag: member="btlsc::Channel::writev" ref="a0e798cdf27aa1971e22a15039c44db8d" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::writev </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this channel from the specified sequence of <code>buffers</code> of the specified sequence length <code>numBuffers</code> the respective number of bytes as specified in each <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> (or <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code>) buffer. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a partial result. Return <code>numBytes</code> (i.e., the sum of calls to <code>length</code> on the <code>numBuffers</code> <code>buffers</code>) on success, a negative value on error, and the number of bytes newly written from <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#ab91d5a34cf60e1d19d53ba916d3d4e3b">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#adfdc50bb0d1e113d342e47c1df1dd8df">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#afc322f0914cb50d6abee9f5012c49c2d">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="abf4d5f6379e59ce8b026a78a1567c95f"></a><!-- doxytag: member="btlsc::Channel::writevRaw" ref="abf4d5f6379e59ce8b026a78a1567c95f" args="(const btls::Ovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#a51902a4d7db84af44306d8500ac6c1e8">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a4f261f1b1ba076e749f9fb04c530eb8a">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a316d48748074ad888cdfdd138262ce50">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a44ce53caa3bab5c448a35634e3918ffa"></a><!-- doxytag: member="btlsc::Channel::writevRaw" ref="a44ce53caa3bab5c448a35634e3918ffa" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#ae6fbfcb75a6762ac2b15414293ce1f99">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#ad108037eb53ae5ee971000a37e28946f">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#af60db49d74a32c17089b3d57ac0050b9">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a993810b91aa73a1ce659aa9a3cd59d93"></a><!-- doxytag: member="btlsc::Channel::writevRaw" ref="a993810b91aa73a1ce659aa9a3cd59d93" args="(int *augStatus, const btls::Ovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#a218f3e7f5dcd27ed808fc5322a19446e">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a294611a7f942a05b8ca707bb25817a47">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ac40e73055d876fb403d1eb298886334b">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a0223adc9241f6d19264a7e38b2f61677"></a><!-- doxytag: member="btlsc::Channel::writevRaw" ref="a0223adc9241f6d19264a7e38b2f61677" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> write to this channel, from the specified sequence of <code>buffers</code> of the specified sequence length <code>numBuffers</code>, <em>at</em> <em>most</em> the number of bytes as the sum of the specified length in each <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> (or <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code>) buffer. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous
         events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> (i.e., the sum of calls to <code>length</code> on the <code>numBuffers</code> <code>buffers</code>) on success, a negative value on error, and the number of bytes newly written from <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#aed4f2547ec415cc0247cbd7923a554c4">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a5449aae7e38fa42c12de97870f15e80f">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a8f2ef327d11a9780586862a51b37a6f9">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="adc7cc9dfc2e802578f09dd2c0418523c"></a><!-- doxytag: member="btlsc::Channel::invalidate" ref="adc7cc9dfc2e802578f09dd2c0418523c" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlsc::Channel::invalidate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make this channel invalid; no subsequent operations can be completed successfully. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#a61020bb76979046ff1f4d1c1b20cc365">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#a29eb1f57cd9a60d4c0d64ab75e9f4394">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ae3d77d146a11a8b472d2fe9e308fe1c8">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a115e9e4d1c7e221d8b8ed7f6fe0a63d9"></a><!-- doxytag: member="btlsc::Channel::isInvalid" ref="a115e9e4d1c7e221d8b8ed7f6fe0a63d9" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::Channel::isInvalid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if this channel is invalid, and 0 otherwise. Note that once a channel is invalid, no operations can be completed successfully. Also note that a 0 return value does NOT guarantee that a subsequent I/O operation would not fail. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedChannel.html#abea62fb47ee9411dd1277106e0d57a15">btlsc::TimedChannel</a>, <a class="el" href="classbtlsos_1_1TcpChannel.html#ab6d29ea1b7ea3800cf3542ceb5e12645">btlsos::TcpChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a9173d6b4ac3106ad3f6b78641d858064">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlsc__channel_8h_source.html">btlsc_channel.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:14 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
