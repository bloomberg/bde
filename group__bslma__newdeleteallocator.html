<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslma_newdeleteallocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslma_newdeleteallocator<br/>
<small>
[<a class="el" href="group__bslma.html">Package bslma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide singleton new/delete adaptor to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide singleton new/delete adaptor to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a> </td><td>support new/delete-style allocation/deallocation  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__default.html" title="Provide utilities to set/fetch the default and global allocators.">Component bslma_default</a>, <a class="el" href="group__bslma__testallocator.html" title="Provide instrumented malloc/free allocator to track memory usage.">Component bslma_testallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a concrete allocation mechanism, <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code>, that implements the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol to provide direct access to the system-supplied (native) global <code>operator new</code> and <code>operator delete</code> functions via that pure abstract interface. <br/>
<br/>
<div class="fragment"><pre class="fragment">   ,-------------------------.
  ( <a class="code" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a> )
   `-------------------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">               |         allocator</span>
<span class="stringliteral">               |         singleton</span>
<span class="stringliteral">               |         ctor/dtor</span>
<span class="stringliteral">               V</span>
<span class="stringliteral">       ,----------------.</span>
<span class="stringliteral">      ( bslma::Allocator )</span>
<span class="stringliteral">       `----------------&#39;</span>
                       allocate
                       deallocate
</pre></div><br/>
<br/>
 The essential purpose of this component is to facilitate the default use of global <code>new</code> and <code>delete</code> in all components that accept a user-supplied allocator derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> (see <code>bslma_default</code>). Hence, the global <code>operator new</code> and <code>operator delete</code> functions are wrapped within concrete methods of a derived <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code> class. A <code>static</code> (factory) method of <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code> can be used to obtain a unique (singleton) <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code> object for the given process, and whose lifetime is guaranteed to exceed any possibility of its use. Note that the standard also requires the global <code>operator new</code> to return maximally-aligned memory, which is a stricter post condition than the natural-alignment requirement imposed by the base-class contract, or than is provided by many other concrete implementations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This class is fully thread-safe, which means that all non-creator object methods can be safely accessed concurrently (from multiple treads). The singleton <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code> can also be safely created/accessed concurrently (from multiple threads) via either the <code>static</code> <code>singleton</code> or <code>allocator</code> (factory) methods. Moreover, the underlying (native) implementation of <code>new</code> and <code>delete</code> are required by the C++ standard to ensure that concurrent access to either the virtual <code>allocate</code> and/or <code>deallocate</code> are also safe (i.e., will not not result in heap corruption). Note that this allocator therefore has stronger thread-safety guarantees than is required by the base-class contract or than is provided by many other derived concrete allocators. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The most common and proper use of <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code> is both <em>indirect</em> and <em>by</em> <em>default</em> (see <code>bslma_default</code>). For example, consider (along with its destructor) the default and copy constructors for, say, a simple container, such as <code>my_ShortArray</code>, each of which take as its final optional argument the address of a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_shortarray.h:</span>
  <span class="comment">// ...</span>
  <span class="keyword">namespace </span>bslma { <span class="keyword">class </span>Allocator; }

  <span class="keyword">class </span>my_ShortArray {
      <span class="keywordtype">short</span>            *d_array_p;     <span class="comment">// dynamically-allocated array</span>
      <span class="keywordtype">int</span>               d_capacity;    <span class="comment">// physical capacity (in elements)</span>
      <span class="keywordtype">int</span>               d_length;      <span class="comment">// logical length (in elements)</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p; <span class="comment">// memory allocator (not owned)</span>

    <span class="keyword">public</span>:
      my_ShortArray(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an empty &#39;my_shortArray&#39;.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39;</span>
          <span class="comment">// is 0, the currently installed default allocator is used.</span>

      my_ShortArray(<span class="keyword">const</span> my_ShortArray&amp;  other,
                    <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>     *basicAllocator = 0);
          <span class="comment">// Create a &#39;bslma::ShortArray&#39; having the same value as the</span>
          <span class="comment">// specified &#39;other&#39; array.  Optionally specify a &#39;basicAllocator&#39;</span>
          <span class="comment">// used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently</span>
          <span class="comment">// installed default allocator is used.</span>

      ~my_ShortArray();
          <span class="comment">// Destroy this object.</span>

     <span class="comment">// ...</span>
  };

  <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 In order to satisfy this contract, we will need a globally accessible utility (see <code>bslma_default</code>), which by default returns the singleton <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code>, but which could be configured to return some other allocator, say a <em>test</em> allocator (see <code>bslma_testallocator</code>): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_default.h:</span>
  <span class="comment">// ...</span>
  <span class="keyword">namespace </span>bslma { <span class="keyword">class </span>Allocator; }

  <span class="keyword">struct </span>my_Default {
      <span class="comment">// This class maintains a process-wide &#39;bslma::Allocator&#39; object</span>
      <span class="comment">// to be used when an allocator is needed, and not suppled explicitly.</span>
      <span class="comment">// By default, the currently installed default allocator is the unique</span>
      <span class="comment">// &#39;bslma::NewDeleteAllocator&#39; object returned by the &#39;static&#39; method,</span>
      <span class="comment">// &#39;bslma::NewDeleteAllocator::singleton()&#39;.  Note that the default</span>
      <span class="comment">// allocator will exist longer than any possibility of its use.</span>

      <span class="keyword">static</span> <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator);
          <span class="comment">// Return the address of the specified modifiable</span>
          <span class="comment">// &#39;basicAllocator&#39; or, if &#39;basicAllocator&#39; is 0, an instance of</span>
          <span class="comment">// the currently installed default &#39;bslma::Allocator&#39; object, which</span>
          <span class="comment">// will exist longer than any possibility of its use.  Note</span>
          <span class="comment">// that this function can safely be called concurrently (from</span>
          <span class="comment">// multiple threads).</span>

      <span class="keyword">static</span> <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *replace(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator);
          <span class="comment">// Replace the address of the currently installed allocator with</span>
          <span class="comment">// that of the specified modifiable &#39;basicAllocator&#39; (or if 0,</span>
          <span class="comment">// with the &quot;factory&quot; default, &#39;bslma::NewDeleteAllocator&#39;), and</span>
          <span class="comment">// return the address of the previous allocator.  The behavior is</span>
          <span class="comment">// undefined unless &#39;basicAllocator&#39; will exist longer than any</span>
          <span class="comment">// possibility of its use.  Note that this function is *not* *at*</span>
          <span class="comment">// *all* thread-safe, and should *never* be called when multiple</span>
          <span class="comment">// threads are active.</span>
  };

  <span class="comment">// my_default.cpp:</span>
  <span class="comment">// ...</span>

<span class="preprocessor">  #include &lt;my_default.h&gt;</span>

  <span class="keyword">static</span> <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *s_default_p = 0; <span class="comment">// load-time initialized</span>

  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *my_Default::allocator(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  {
      <span class="keywordflow">return</span> <a class="code" href="classbslma_1_1NewDeleteAllocator.html#a969932d0e1d15fbb2f4b6f7f03d5579e">bslma::NewDeleteAllocator::allocator</a>(s_default_p);
  }

  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *my_Default::replace(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  {
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *tmp =
                           <a class="code" href="classbslma_1_1NewDeleteAllocator.html#a969932d0e1d15fbb2f4b6f7f03d5579e">bslma::NewDeleteAllocator::allocator</a>(s_default_p);
      s_default_p = <a class="code" href="classbslma_1_1NewDeleteAllocator.html#a969932d0e1d15fbb2f4b6f7f03d5579e">bslma::NewDeleteAllocator::allocator</a>(basicAllocator);
      <span class="keywordflow">return</span> tmp;
  }
</pre></div><br/>
<br/>
 Notice that the only part of the <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code> class we used directly was its static <code>allocator</code> method, which -- in addition to safely constructing the singleton <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code> object on first access -- also automatically replaces a 0 address value with that of singleton <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code> object. From now on, we will never again need to invoke the <code>bslma_newdeleteallocator</code> component's interface directly, but instead use it through <code>my_Default</code> (see <code><a class="el" href="structbslma_1_1Default.html">bslma::Default</a></code> for what is actually used in practice). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Turning back to our <code>my_shortarray</code> example, let's now implement the two constructors using the <code>bslma_newdeleteallocator</code> component indirectly via the <code>my_default</code> component: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_shortarray.cpp:</span>
<span class="preprocessor">  #include &lt;my_shortarray.h&gt;</span>
<span class="preprocessor">  #include &lt;my_default.h&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="bsls__assert_8h.html" title="Provide build-specific, runtime-configurable assertion macros.">bsls_assert.h</a>&gt;</span>

  <span class="comment">// ...</span>

  <span class="keyword">enum</span> {
      INITIAL_CAPACITY = 0, <span class="comment">// recommended to avoid unnecessary allocations</span>
                            <span class="comment">// possibly resulting in locking and extra thread</span>
                            <span class="comment">// contention for the &#39;bslma::NewDeleteAllocator&#39;</span>

      GROW_FACTOR = 2       <span class="comment">// typical value for geometric growth</span>
  };

  <span class="comment">// ...</span>

  my_ShortArray::my_ShortArray(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_capacity(INITIAL_CAPACITY)
  , d_length(0)
  , d_allocator_p(my_Default::allocator(basicAllocator))
  {
      assert(d_allocator_p);
      d_array_p = (<span class="keywordtype">short</span> *)  <span class="comment">// no thread contention if &#39;d_capacity&#39; is 0</span>
                  d_allocator_p-&gt;allocate(d_capacity * <span class="keyword">sizeof</span> *d_array_p);
      assert(0 == d_array_p);
  }

  my_ShortArray::my_ShortArray(<span class="keyword">const</span> my_ShortArray&amp;   other,
                               <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>      *basicAllocator)
  : d_capacity(other.d_capacity)
  , d_length(other.d_length)
  , d_allocator_p(my_Default::allocator(basicAllocator))
  {
      assert(d_allocator_p);
      d_array_p = (<span class="keywordtype">short</span> *)
                  d_allocator_p-&gt;allocate(d_capacity * <span class="keyword">sizeof</span> *d_array_p);
      assert(!d_capacity == !d_array_p);
      memcpy(d_array_p, other.d_array_p, d_length * <span class="keyword">sizeof</span> *d_array_p);
  }

  my_ShortArray::~my_ShortArray()
  {
      d_allocator_p-&gt;deallocate(d_array_p); <span class="comment">// no locking if &#39;d_array_p&#39; is 0</span>
  }

 <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 When the default constructor is called, the default capacity and length are recorded in data members via the initialization list. The static function <code>allocator</code> (provided in <code>my_Default</code>) is used to assign the value of the <code>basicAllocator</code> address passed in, or if that is 0, the address of the currently installed default allocator, which by default is the singleton object of type <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code>, defined in this component. Note that since <code>INITIAL_CAPACITY</code> is 0, a default constructed object that is created using a <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code> will <em>not</em> invoke the <code>operator new</code> function, which on some platforms may needlessly acquire a lock, causing unnecessary overhead (the same potential overhead is avoided for <code>operator delete</code> whenever a 0 <code>d_array_p</code> value is deallocated in the destructor) and <code>d_allocator_p</code> refers to a <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code>. Note also that, for the copy constructor, the currently installed default allocator, and not the <code>other</code> array's allocator is used whenever <code>basicAllocator</code> is 0 or not explicitly supplied. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally note that this entire component is <em>not</em> intended for direct use by typical clients: See <code>bslma_default</code> for more information or proper usage. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:41 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
