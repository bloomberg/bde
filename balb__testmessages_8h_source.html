<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// balb_testmessages.h       -- GENERATED FILE - DO NOT EDIT --       -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALB_TESTMESSAGES
#define INCLUDED_BALB_TESTMESSAGES

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT_RCSID(baea_testmessages_h,&quot;$Id$ $CSID$&quot;)
BSLS_IDENT_PRAGMA_ONCE

//@PURPOSE: Provide value-semantic attribute classes
//
//@DESCRIPTION: This is a generated file for testing purposes and should *not*
// be used in any production code.
//
// The file is generated with the command:
//..
//  bas_codegen.pl -mmsg -Ctestmessages --noAggregateConversion &lt;backslaah&gt;
//                 test/balb_testmessages.xsd
//..
// (Sustitute &#39;\&#39; for &#39;&lt;backslash&gt;&#39; -- some compilers won&#39;t accept a backslash
// at the end of a C++ comment line).
//
// After the message component is generated, the following modifications are
// made:
//: o This @DESCRIPTION section is added.

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLAT_ATTRIBUTEINFO
#include &lt;bdlat_attributeinfo.h&gt;
#endif

#ifndef INCLUDED_BDLAT_ENUMERATORINFO
#include &lt;bdlat_enumeratorinfo.h&gt;
#endif

#ifndef INCLUDED_BDLAT_SELECTIONINFO
#include &lt;bdlat_selectioninfo.h&gt;
#endif

#ifndef INCLUDED_BDLAT_TYPETRAITS
#include &lt;bdlat_typetraits.h&gt;
#endif

#ifndef INCLUDED_BDLAT_VALUETYPEFUNCTIONS
#include &lt;bdlat_valuetypefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLT_DATETIMETZ
#include &lt;bdlt_datetimetz.h&gt;
#endif

#ifndef INCLUDED_BDLB_NULLABLEALLOCATEDVALUE
#include &lt;bdlb_nullableallocatedvalue.h&gt;
#endif

#ifndef INCLUDED_BDLB_NULLABLEVALUE
#include &lt;bdlb_nullablevalue.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include &lt;bslalg_typetraits.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_OBJECTBUFFER
#include &lt;bsls_objectbuffer.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSL_OSTREAM
#include &lt;bsl_ostream.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {

namespace balb { class CustomInt; }
namespace balb { class CustomString; }
namespace balb { class SequenceWithAnonymityChoice1; }
namespace balb { class SimpleRequest; }
namespace balb { class UnsignedSequence; }
namespace balb { class VoidSequence; }
namespace balb { class Sequence3; }
namespace balb { class Sequence5; }
namespace balb { class Sequence6; }
namespace balb { class Choice3; }
namespace balb { class SequenceWithAnonymityChoice; }
namespace balb { class Choice1; }
namespace balb { class Choice2; }
namespace balb { class Sequence4; }
namespace balb { class Sequence1; }
namespace balb { class Sequence2; }
namespace balb { class SequenceWithAnonymityChoice2; }
namespace balb { class SequenceWithAnonymity; }
namespace balb { class FeatureTestMessage; }
namespace balb { class Request; }
namespace balb { class Response; }
namespace balb {

                              // ===============
                              // class CustomInt
                              // ===============

class CustomInt {

    // INSTANCE DATA
    int d_value;

    // FRIENDS
    friend bool operator==(const CustomInt&amp; lhs, const CustomInt&amp; rhs);
    friend bool operator!=(const CustomInt&amp; lhs, const CustomInt&amp; rhs);

    // PRIVATE CLASS METHODS
    static int checkRestrictions(const int&amp; value);
        // Check if the specified &#39;value&#39; satisfies the restrictions of this
        // class (i.e., &quot;CustomInt&quot;).  Return 0 if successful (i.e., the
        // restrictions are satisfied) and non-zero otherwise.

  public:
    // TYPES
    typedef int BaseType;

    // CONSTANTS
    static const char CLASS_NAME[];

    // CREATORS
    CustomInt();
        // Create an object of type &#39;CustomInt&#39; having the default value.

    CustomInt(const CustomInt&amp; original);
        // Create an object of type &#39;CustomInt&#39; having the value of the
        // specified &#39;original&#39; object.

    explicit CustomInt(const int&amp; value);
        // Create an object of type &#39;CustomInt&#39; having the specified &#39;value&#39;.

    ~CustomInt();
        // Destroy this object.

    // MANIPULATORS
    CustomInt&amp; operator=(const CustomInt&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon
        // default construction).

    int fromInt(const int&amp; value);
        // Convert from the specified &#39;value&#39; to this type.  Return 0 if
        // successful and non-zero otherwise.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    const int&amp; toInt() const;
        // Convert this value to &#39;int&#39;.
};

// FREE OPERATORS
inline
bool operator==(const CustomInt&amp; lhs, const CustomInt&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects have
    // the same value, and &#39;false&#39; otherwise.  Two attribute objects have the
    // same value if each respective attribute has the same value.

inline
bool operator!=(const CustomInt&amp; lhs, const CustomInt&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects do not
    // have the same value, and &#39;false&#39; otherwise.  Two attribute objects do
    // not have the same value if one or more respective attributes differ in
    // values.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const CustomInt&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_CUSTOMIZEDTYPE_WITH_BITWISEMOVEABLE_TRAITS(balb::CustomInt)

namespace balb {

                             // ==================
                             // class CustomString
                             // ==================

class CustomString {

    // INSTANCE DATA
    bsl::string d_value;

    // FRIENDS
    friend bool operator==(const CustomString&amp; lhs, const CustomString&amp; rhs);
    friend bool operator!=(const CustomString&amp; lhs, const CustomString&amp; rhs);

    // PRIVATE CLASS METHODS
    static int checkRestrictions(const bsl::string&amp; value);
        // Check if the specified &#39;value&#39; satisfies the restrictions of this
        // class (i.e., &quot;CustomString&quot;).  Return 0 if successful (i.e., the
        // restrictions are satisfied) and non-zero otherwise.

  public:
    // TYPES
    typedef bsl::string BaseType;

    // CONSTANTS
    static const char CLASS_NAME[];

    // CREATORS
    explicit CustomString(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;CustomString&#39; having the default value.
        // Use the optionally specified &#39;basicAllocator&#39; to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    CustomString(const CustomString&amp;  original,
                 bslma::Allocator    *basicAllocator = 0);
        // Create an object of type &#39;CustomString&#39; having the value
        // of the specified &#39;original&#39; object.  Use the optionally specified
        // &#39;basicAllocator&#39; to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    explicit CustomString(const bsl::string&amp;  value,
                          bslma::Allocator   *basicAllocator = 0);
        // Create an object of type &#39;CustomString&#39; having the specified
        // &#39;value&#39;.  Use the optionally specified &#39;basicAllocator&#39; to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.

    ~CustomString();
        // Destroy this object.

    // MANIPULATORS
    CustomString&amp; operator=(const CustomString&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon
        // default construction).

    int fromString(const bsl::string&amp; value);
        // Convert from the specified &#39;value&#39; to this type.  Return 0 if
        // successful and non-zero otherwise.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    const bsl::string&amp; toString() const;
        // Convert this value to &#39;bsl::string&#39;.
};

// FREE OPERATORS
inline
bool operator==(const CustomString&amp; lhs, const CustomString&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects have
    // the same value, and &#39;false&#39; otherwise.  Two attribute objects have the
    // same value if each respective attribute has the same value.

inline
bool operator!=(const CustomString&amp; lhs, const CustomString&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects do not
    // have the same value, and &#39;false&#39; otherwise.  Two attribute objects do
    // not have the same value if one or more respective attributes differ in
    // values.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const CustomString&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_CUSTOMIZEDTYPE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::CustomString)

namespace balb {

                              // ================
                              // class Enumerated
                              // ================

struct Enumerated {

  public:
    // TYPES
    enum Value {
        e_NEW_YORK   = 0
      , e_NEW_JERSEY = 1
      , e_LONDON     = 2
    };

    enum {
        k_NUM_ENUMERATORS = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char *toString(Value value);
        // Return the string representation exactly matching the enumerator
        // name corresponding to the specified enumeration &#39;value&#39;.

    static int fromString(Value        *result,
                          const char   *string,
                          int           stringLength);
        // Load into the specified &#39;result&#39; the enumerator matching the
        // specified &#39;string&#39; of the specified &#39;stringLength&#39;.  Return 0 on
        // success, and a non-zero value with no effect on &#39;result&#39; otherwise
        // (i.e., &#39;string&#39; does not match any enumerator).

    static int fromString(Value              *result,
                          const bsl::string&amp;  string);
        // Load into the specified &#39;result&#39; the enumerator matching the
        // specified &#39;string&#39;.  Return 0 on success, and a non-zero value with
        // no effect on &#39;result&#39; otherwise (i.e., &#39;string&#39; does not match any
        // enumerator).

    static int fromInt(Value *result, int number);
        // Load into the specified &#39;result&#39; the enumerator matching the
        // specified &#39;number&#39;.  Return 0 on success, and a non-zero value with
        // no effect on &#39;result&#39; otherwise (i.e., &#39;number&#39; does not match any
        // enumerator).

    static bsl::ostream&amp; print(bsl::ostream&amp; stream, Value value);
        // Write to the specified &#39;stream&#39; the string representation of
        // the specified enumeration &#39;value&#39;.  Return a reference to
        // the modifiable &#39;stream&#39;.
};

// FREE OPERATORS
inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, Enumerated::Value rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(balb::Enumerated)


namespace balb {

                     // ==================================
                     // class SequenceWithAnonymityChoice1
                     // ==================================

class SequenceWithAnonymityChoice1 {

    // INSTANCE DATA
    union {
        bsls::ObjectBuffer&lt; bool &gt;         d_selection5;
        bsls::ObjectBuffer&lt; bsl::string &gt;  d_selection6;
    };

    int                                    d_selectionId;
    bslma::Allocator                      *d_allocator_p;

  public:
    // TYPES
    enum {
        e_SELECTION_ID_UNDEFINED  = -1

      , e_SELECTION_ID_SELECTION5 = 0
      , e_SELECTION_ID_SELECTION6 = 1
    };

    enum {
        k_NUM_SELECTIONS = 2
    };

    enum {
        e_SELECTION_INDEX_SELECTION5 = 0
      , e_SELECTION_INDEX_SELECTION6 = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo *lookupSelectionInfo(int id);
        // Return selection information for the selection indicated by the
        // specified &#39;id&#39; if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo *lookupSelectionInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return selection information for the selection indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the selection
        // exists, and 0 otherwise.

    // CREATORS
    explicit SequenceWithAnonymityChoice1(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;SequenceWithAnonymityChoice1&#39; having the
        // default value.  Use the optionally specified &#39;basicAllocator&#39; to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    SequenceWithAnonymityChoice1(const SequenceWithAnonymityChoice1&amp; original,
                                bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;SequenceWithAnonymityChoice1&#39; having the
        // value of the specified &#39;original&#39; object.  Use the optionally
        // specified &#39;basicAllocator&#39; to supply memory.  If &#39;basicAllocator&#39; is
        // 0, the currently installed default allocator is used.

    ~SequenceWithAnonymityChoice1();
        // Destroy this object.

    // MANIPULATORS
    SequenceWithAnonymityChoice1&amp; operator=(const SequenceWithAnonymityChoice1&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon default
        // construction).

    int makeSelection(int selectionId);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;selectionId&#39;.  Return 0 on success, and
        // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char *name, int nameLength);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;name&#39; of the specified &#39;nameLength&#39;.
        // Return 0 on success, and non-zero value otherwise (i.e., the
        // selection is not found).

    bool&amp; makeSelection5();
    bool&amp; makeSelection5(bool value);
        // Set the value of this object to be a &quot;Selection5&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection5&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection5&quot; value is used.

    bsl::string&amp; makeSelection6();
    bsl::string&amp; makeSelection6(const bsl::string&amp; value);
        // Set the value of this object to be a &quot;Selection6&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection6&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection6&quot; value is used.

    template&lt;class MANIPULATOR&gt;
    int manipulateSelection(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; on the address of the modifiable
        // selection, supplying &#39;manipulator&#39; with the corresponding selection
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if this object has a defined selection,
        // and -1 otherwise.

    bool&amp; selection5();
        // Return a reference to the modifiable &quot;Selection5&quot; selection of this
        // object if &quot;Selection5&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection5&quot; is the selection of this object.

    bsl::string&amp; selection6();
        // Return a reference to the modifiable &quot;Selection6&quot; selection of this
        // object if &quot;Selection6&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection6&quot; is the selection of this object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    int selectionId() const;
        // Return the id of the current selection if the selection is defined,
        // and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessSelection(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; on the non-modifiable selection,
        // supplying &#39;accessor&#39; with the corresponding selection information
        // structure.  Return the value returned from the invocation of
        // &#39;accessor&#39; if this object has a defined selection, and -1 otherwise.

    const bool&amp; selection5() const;
        // Return a reference to the non-modifiable &quot;Selection5&quot; selection of
        // this object if &quot;Selection5&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection5&quot; is the selection of this object.

    const bsl::string&amp; selection6() const;
        // Return a reference to the non-modifiable &quot;Selection6&quot; selection of
        // this object if &quot;Selection6&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection6&quot; is the selection of this object.

    bool isSelection5Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection5&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection6Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection6&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isUndefinedValue() const;
        // Return &#39;true&#39; if the value of this object is undefined, and &#39;false&#39;
        // otherwise.

    const char *selectionName() const;
        // Return the symbolic name of the current selection of this object.
};

// FREE OPERATORS
inline
bool operator==(const SequenceWithAnonymityChoice1&amp; lhs, const SequenceWithAnonymityChoice1&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;SequenceWithAnonymityChoice1&#39; objects have the same
    // value if either the selections in both objects have the same ids and
    // the same values, or both selections are undefined.

inline
bool operator!=(const SequenceWithAnonymityChoice1&amp; lhs, const SequenceWithAnonymityChoice1&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same values, as determined by &#39;operator==&#39;, and &#39;false&#39; otherwise.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const SequenceWithAnonymityChoice1&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::SequenceWithAnonymityChoice1)

namespace balb {

                            // ===================
                            // class SimpleRequest
                            // ===================

class SimpleRequest {

    // INSTANCE DATA
    bsl::string  d_data;
    int          d_responseLength;

  public:
    // TYPES
    enum {
        e_ATTRIBUTE_ID_DATA            = 0
      , e_ATTRIBUTE_ID_RESPONSE_LENGTH = 1
    };

    enum {
        k_NUM_ATTRIBUTES = 2
    };

    enum {
        e_ATTRIBUTE_INDEX_DATA            = 0
      , e_ATTRIBUTE_INDEX_RESPONSE_LENGTH = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo *lookupAttributeInfo(int id);
        // Return attribute information for the attribute indicated by the
        // specified &#39;id&#39; if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo *lookupAttributeInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return attribute information for the attribute indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the attribute
        // exists, and 0 otherwise.

    // CREATORS
    explicit SimpleRequest(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;SimpleRequest&#39; having the default value.
        // Use the optionally specified &#39;basicAllocator&#39; to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    SimpleRequest(const SimpleRequest&amp;  original,
                  bslma::Allocator     *basicAllocator = 0);
        // Create an object of type &#39;SimpleRequest&#39; having the value of the
        // specified &#39;original&#39; object.  Use the optionally specified
        // &#39;basicAllocator&#39; to supply memory.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.

    ~SimpleRequest();
        // Destroy this object.

    // MANIPULATORS
    SimpleRequest&amp; operator=(const SimpleRequest&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon
        // default construction).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttributes(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; sequentially on the address of
        // each (modifiable) attribute of this object, supplying &#39;manipulator&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;manipulator&#39; (i.e., the invocation that
        // terminated the sequence).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp; manipulator, int id);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;id&#39;,
        // supplying &#39;manipulator&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if &#39;id&#39; identifies an attribute of this
        // class, and -1 otherwise.

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp;  manipulator,
                            const char   *name,
                            int           nameLength);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;name&#39; of the
        // specified &#39;nameLength&#39;, supplying &#39;manipulator&#39; with the
        // corresponding attribute information structure.  Return the value
        // returned from the invocation of &#39;manipulator&#39; if &#39;name&#39; identifies
        // an attribute of this class, and -1 otherwise.

    bsl::string&amp; data();
        // Return a reference to the modifiable &quot;Data&quot; attribute of this
        // object.

    int&amp; responseLength();
        // Return a reference to the modifiable &quot;ResponseLength&quot; attribute of
        // this object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    template&lt;class ACCESSOR&gt;
    int accessAttributes(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; sequentially on each
        // (non-modifiable) attribute of this object, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;accessor&#39; (i.e., the invocation that terminated
        // the sequence).

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp; accessor, int id) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;id&#39;, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure.  Return the
        // value returned from the invocation of &#39;accessor&#39; if &#39;id&#39; identifies
        // an attribute of this class, and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp;   accessor,
                        const char *name,
                        int         nameLength) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;name&#39; of the specified
        // &#39;nameLength&#39;, supplying &#39;accessor&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;accessor&#39; if &#39;name&#39; identifies an attribute of this
        // class, and -1 otherwise.

    const bsl::string&amp; data() const;
        // Return a reference to the non-modifiable &quot;Data&quot; attribute of this
        // object.

    int responseLength() const;
        // Return a reference to the non-modifiable &quot;ResponseLength&quot; attribute
        // of this object.
};

// FREE OPERATORS
inline
bool operator==(const SimpleRequest&amp; lhs, const SimpleRequest&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects have
    // the same value, and &#39;false&#39; otherwise.  Two attribute objects have the
    // same value if each respective attribute has the same value.

inline
bool operator!=(const SimpleRequest&amp; lhs, const SimpleRequest&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects do not
    // have the same value, and &#39;false&#39; otherwise.  Two attribute objects do
    // not have the same value if one or more respective attributes differ in
    // values.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const SimpleRequest&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::SimpleRequest)

namespace balb {

                           // ======================
                           // class UnsignedSequence
                           // ======================

class UnsignedSequence {

    // INSTANCE DATA
    bsls::Types::Uint64 d_element3;
    unsigned int        d_element1;
    unsigned short      d_element2;

  public:
    // TYPES
    enum {
        e_ATTRIBUTE_ID_ELEMENT1 = 0
      , e_ATTRIBUTE_ID_ELEMENT2 = 1
      , e_ATTRIBUTE_ID_ELEMENT3 = 2
    };

    enum {
        k_NUM_ATTRIBUTES = 3
    };

    enum {
        e_ATTRIBUTE_INDEX_ELEMENT1 = 0
      , e_ATTRIBUTE_INDEX_ELEMENT2 = 1
      , e_ATTRIBUTE_INDEX_ELEMENT3 = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo *lookupAttributeInfo(int id);
        // Return attribute information for the attribute indicated by the
        // specified &#39;id&#39; if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo *lookupAttributeInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return attribute information for the attribute indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the attribute
        // exists, and 0 otherwise.

    // CREATORS
    UnsignedSequence();
        // Create an object of type &#39;UnsignedSequence&#39; having the default
        // value.

    UnsignedSequence(const UnsignedSequence&amp; original);
        // Create an object of type &#39;UnsignedSequence&#39; having the value of the
        // specified &#39;original&#39; object.

    ~UnsignedSequence();
        // Destroy this object.

    // MANIPULATORS
    UnsignedSequence&amp; operator=(const UnsignedSequence&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon
        // default construction).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttributes(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; sequentially on the address of
        // each (modifiable) attribute of this object, supplying &#39;manipulator&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;manipulator&#39; (i.e., the invocation that
        // terminated the sequence).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp; manipulator, int id);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;id&#39;,
        // supplying &#39;manipulator&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if &#39;id&#39; identifies an attribute of this
        // class, and -1 otherwise.

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp;  manipulator,
                            const char   *name,
                            int           nameLength);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;name&#39; of the
        // specified &#39;nameLength&#39;, supplying &#39;manipulator&#39; with the
        // corresponding attribute information structure.  Return the value
        // returned from the invocation of &#39;manipulator&#39; if &#39;name&#39; identifies
        // an attribute of this class, and -1 otherwise.

    unsigned int&amp; element1();
        // Return a reference to the modifiable &quot;Element1&quot; attribute of this
        // object.

    unsigned short&amp; element2();
        // Return a reference to the modifiable &quot;Element2&quot; attribute of this
        // object.

    bsls::Types::Uint64&amp; element3();
        // Return a reference to the modifiable &quot;Element3&quot; attribute of this
        // object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    template&lt;class ACCESSOR&gt;
    int accessAttributes(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; sequentially on each
        // (non-modifiable) attribute of this object, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;accessor&#39; (i.e., the invocation that terminated
        // the sequence).

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp; accessor, int id) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;id&#39;, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure.  Return the
        // value returned from the invocation of &#39;accessor&#39; if &#39;id&#39; identifies
        // an attribute of this class, and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp;   accessor,
                        const char *name,
                        int         nameLength) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;name&#39; of the specified
        // &#39;nameLength&#39;, supplying &#39;accessor&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;accessor&#39; if &#39;name&#39; identifies an attribute of this
        // class, and -1 otherwise.

    unsigned int element1() const;
        // Return a reference to the non-modifiable &quot;Element1&quot; attribute of
        // this object.

    unsigned short element2() const;
        // Return a reference to the non-modifiable &quot;Element2&quot; attribute of
        // this object.

    bsls::Types::Uint64 element3() const;
        // Return a reference to the non-modifiable &quot;Element3&quot; attribute of
        // this object.
};

// FREE OPERATORS
inline
bool operator==(const UnsignedSequence&amp; lhs, const UnsignedSequence&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects have
    // the same value, and &#39;false&#39; otherwise.  Two attribute objects have the
    // same value if each respective attribute has the same value.

inline
bool operator!=(const UnsignedSequence&amp; lhs, const UnsignedSequence&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects do not
    // have the same value, and &#39;false&#39; otherwise.  Two attribute objects do
    // not have the same value if one or more respective attributes differ in
    // values.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const UnsignedSequence&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(balb::UnsignedSequence)

namespace balb {

                             // ==================
                             // class VoidSequence
                             // ==================

class VoidSequence {

    // INSTANCE DATA

  public:
    // TYPES
    enum {
        k_NUM_ATTRIBUTES = 0
    };


    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo *lookupAttributeInfo(int id);
        // Return attribute information for the attribute indicated by the
        // specified &#39;id&#39; if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo *lookupAttributeInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return attribute information for the attribute indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the attribute
        // exists, and 0 otherwise.

    // CREATORS
    VoidSequence();
        // Create an object of type &#39;VoidSequence&#39; having the default value.

    VoidSequence(const VoidSequence&amp; original);
        // Create an object of type &#39;VoidSequence&#39; having the value of the
        // specified &#39;original&#39; object.

    ~VoidSequence();
        // Destroy this object.

    // MANIPULATORS
    VoidSequence&amp; operator=(const VoidSequence&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon
        // default construction).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttributes(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; sequentially on the address of
        // each (modifiable) attribute of this object, supplying &#39;manipulator&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;manipulator&#39; (i.e., the invocation that
        // terminated the sequence).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp; manipulator, int id);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;id&#39;,
        // supplying &#39;manipulator&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if &#39;id&#39; identifies an attribute of this
        // class, and -1 otherwise.

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp;  manipulator,
                            const char   *name,
                            int           nameLength);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;name&#39; of the
        // specified &#39;nameLength&#39;, supplying &#39;manipulator&#39; with the
        // corresponding attribute information structure.  Return the value
        // returned from the invocation of &#39;manipulator&#39; if &#39;name&#39; identifies
        // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    template&lt;class ACCESSOR&gt;
    int accessAttributes(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; sequentially on each
        // (non-modifiable) attribute of this object, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;accessor&#39; (i.e., the invocation that terminated
        // the sequence).

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp; accessor, int id) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;id&#39;, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure.  Return the
        // value returned from the invocation of &#39;accessor&#39; if &#39;id&#39; identifies
        // an attribute of this class, and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp;   accessor,
                        const char *name,
                        int         nameLength) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;name&#39; of the specified
        // &#39;nameLength&#39;, supplying &#39;accessor&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;accessor&#39; if &#39;name&#39; identifies an attribute of this
        // class, and -1 otherwise.
};

// FREE OPERATORS
inline
bool operator==(const VoidSequence&amp; lhs, const VoidSequence&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects have
    // the same value, and &#39;false&#39; otherwise.  Two attribute objects have the
    // same value if each respective attribute has the same value.

inline
bool operator!=(const VoidSequence&amp; lhs, const VoidSequence&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects do not
    // have the same value, and &#39;false&#39; otherwise.  Two attribute objects do
    // not have the same value if one or more respective attributes differ in
    // values.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const VoidSequence&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(balb::VoidSequence)

namespace balb {

                              // ===============
                              // class Sequence3
                              // ===============

class Sequence3 {

    // INSTANCE DATA
    bsl::vector&lt;bsl::string&gt;                              d_element2;
    bdlb::NullableValue&lt;bsl::string&gt;                      d_element4;
    bdlb::NullableAllocatedValue&lt;Sequence5&gt;               d_element5;
    bsl::vector&lt;bdlb::NullableValue&lt;Enumerated::Value&gt; &gt;  d_element6;
    bsl::vector&lt;Enumerated::Value&gt;                        d_element1;
    bdlb::NullableValue&lt;bool&gt;                             d_element3;

  public:
    // TYPES
    enum {
        e_ATTRIBUTE_ID_ELEMENT1 = 0
      , e_ATTRIBUTE_ID_ELEMENT2 = 1
      , e_ATTRIBUTE_ID_ELEMENT3 = 2
      , e_ATTRIBUTE_ID_ELEMENT4 = 3
      , e_ATTRIBUTE_ID_ELEMENT5 = 4
      , e_ATTRIBUTE_ID_ELEMENT6 = 5
    };

    enum {
        k_NUM_ATTRIBUTES = 6
    };

    enum {
        e_ATTRIBUTE_INDEX_ELEMENT1 = 0
      , e_ATTRIBUTE_INDEX_ELEMENT2 = 1
      , e_ATTRIBUTE_INDEX_ELEMENT3 = 2
      , e_ATTRIBUTE_INDEX_ELEMENT4 = 3
      , e_ATTRIBUTE_INDEX_ELEMENT5 = 4
      , e_ATTRIBUTE_INDEX_ELEMENT6 = 5
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo *lookupAttributeInfo(int id);
        // Return attribute information for the attribute indicated by the
        // specified &#39;id&#39; if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo *lookupAttributeInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return attribute information for the attribute indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the attribute
        // exists, and 0 otherwise.

    // CREATORS
    explicit Sequence3(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Sequence3&#39; having the default value.  Use
        // the optionally specified &#39;basicAllocator&#39; to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    Sequence3(const Sequence3&amp;  original,
              bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Sequence3&#39; having the value of the
        // specified &#39;original&#39; object.  Use the optionally specified
        // &#39;basicAllocator&#39; to supply memory.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.

    ~Sequence3();
        // Destroy this object.

    // MANIPULATORS
    Sequence3&amp; operator=(const Sequence3&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon
        // default construction).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttributes(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; sequentially on the address of
        // each (modifiable) attribute of this object, supplying &#39;manipulator&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;manipulator&#39; (i.e., the invocation that
        // terminated the sequence).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp; manipulator, int id);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;id&#39;,
        // supplying &#39;manipulator&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if &#39;id&#39; identifies an attribute of this
        // class, and -1 otherwise.

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp;  manipulator,
                            const char   *name,
                            int           nameLength);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;name&#39; of the
        // specified &#39;nameLength&#39;, supplying &#39;manipulator&#39; with the
        // corresponding attribute information structure.  Return the value
        // returned from the invocation of &#39;manipulator&#39; if &#39;name&#39; identifies
        // an attribute of this class, and -1 otherwise.

    bsl::vector&lt;Enumerated::Value&gt;&amp; element1();
        // Return a reference to the modifiable &quot;Element1&quot; attribute of this
        // object.

    bsl::vector&lt;bsl::string&gt;&amp; element2();
        // Return a reference to the modifiable &quot;Element2&quot; attribute of this
        // object.

    bdlb::NullableValue&lt;bool&gt;&amp; element3();
        // Return a reference to the modifiable &quot;Element3&quot; attribute of this
        // object.

    bdlb::NullableValue&lt;bsl::string&gt;&amp; element4();
        // Return a reference to the modifiable &quot;Element4&quot; attribute of this
        // object.

    bdlb::NullableAllocatedValue&lt;Sequence5&gt;&amp; element5();
        // Return a reference to the modifiable &quot;Element5&quot; attribute of this
        // object.

    bsl::vector&lt;bdlb::NullableValue&lt;Enumerated::Value&gt; &gt;&amp; element6();
        // Return a reference to the modifiable &quot;Element6&quot; attribute of this
        // object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    template&lt;class ACCESSOR&gt;
    int accessAttributes(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; sequentially on each
        // (non-modifiable) attribute of this object, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;accessor&#39; (i.e., the invocation that terminated
        // the sequence).

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp; accessor, int id) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;id&#39;, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure.  Return the
        // value returned from the invocation of &#39;accessor&#39; if &#39;id&#39; identifies
        // an attribute of this class, and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp;   accessor,
                        const char *name,
                        int         nameLength) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;name&#39; of the specified
        // &#39;nameLength&#39;, supplying &#39;accessor&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;accessor&#39; if &#39;name&#39; identifies an attribute of this
        // class, and -1 otherwise.

    const bsl::vector&lt;Enumerated::Value&gt;&amp; element1() const;
        // Return a reference to the non-modifiable &quot;Element1&quot; attribute of
        // this object.

    const bsl::vector&lt;bsl::string&gt;&amp; element2() const;
        // Return a reference to the non-modifiable &quot;Element2&quot; attribute of
        // this object.

    const bdlb::NullableValue&lt;bool&gt;&amp; element3() const;
        // Return a reference to the non-modifiable &quot;Element3&quot; attribute of
        // this object.

    const bdlb::NullableValue&lt;bsl::string&gt;&amp; element4() const;
        // Return a reference to the non-modifiable &quot;Element4&quot; attribute of
        // this object.

    const bdlb::NullableAllocatedValue&lt;Sequence5&gt;&amp; element5() const;
        // Return a reference to the non-modifiable &quot;Element5&quot; attribute of
        // this object.

    const bsl::vector&lt;bdlb::NullableValue&lt;Enumerated::Value&gt; &gt;&amp; element6() const;
        // Return a reference to the non-modifiable &quot;Element6&quot; attribute of
        // this object.
};

// FREE OPERATORS
inline
bool operator==(const Sequence3&amp; lhs, const Sequence3&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects have
    // the same value, and &#39;false&#39; otherwise.  Two attribute objects have the
    // same value if each respective attribute has the same value.

inline
bool operator!=(const Sequence3&amp; lhs, const Sequence3&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects do not
    // have the same value, and &#39;false&#39; otherwise.  Two attribute objects do
    // not have the same value if one or more respective attributes differ in
    // values.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Sequence3&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::Sequence3)

namespace balb {

                              // ===============
                              // class Sequence5
                              // ===============

class Sequence5 {

    // INSTANCE DATA
    bslma::Allocator                                      *d_allocator_p;
    bsl::vector&lt;bdlb::NullableValue&lt;int&gt; &gt;                 d_element5;
    bsl::vector&lt;bdlb::NullableValue&lt;double&gt; &gt;              d_element3;
    bsl::vector&lt;bdlb::NullableValue&lt;bsl::vector&lt;char&gt; &gt; &gt;  d_element4;
    bsl::vector&lt;bdlb::NullableValue&lt;bool&gt; &gt;                d_element2;
    bsl::vector&lt;bdlb::NullableValue&lt;bdlt::DatetimeTz&gt; &gt;     d_element6;
    bsl::vector&lt;bdlb::NullableAllocatedValue&lt;Sequence3&gt; &gt;  d_element7;
    Sequence3                                             *d_element1;

  public:
    // TYPES
    enum {
        e_ATTRIBUTE_ID_ELEMENT1 = 0
      , e_ATTRIBUTE_ID_ELEMENT2 = 1
      , e_ATTRIBUTE_ID_ELEMENT3 = 2
      , e_ATTRIBUTE_ID_ELEMENT4 = 3
      , e_ATTRIBUTE_ID_ELEMENT5 = 4
      , e_ATTRIBUTE_ID_ELEMENT6 = 5
      , e_ATTRIBUTE_ID_ELEMENT7 = 6
    };

    enum {
        k_NUM_ATTRIBUTES = 7
    };

    enum {
        e_ATTRIBUTE_INDEX_ELEMENT1 = 0
      , e_ATTRIBUTE_INDEX_ELEMENT2 = 1
      , e_ATTRIBUTE_INDEX_ELEMENT3 = 2
      , e_ATTRIBUTE_INDEX_ELEMENT4 = 3
      , e_ATTRIBUTE_INDEX_ELEMENT5 = 4
      , e_ATTRIBUTE_INDEX_ELEMENT6 = 5
      , e_ATTRIBUTE_INDEX_ELEMENT7 = 6
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo *lookupAttributeInfo(int id);
        // Return attribute information for the attribute indicated by the
        // specified &#39;id&#39; if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo *lookupAttributeInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return attribute information for the attribute indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the attribute
        // exists, and 0 otherwise.

    // CREATORS
    explicit Sequence5(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Sequence5&#39; having the default value.  Use
        // the optionally specified &#39;basicAllocator&#39; to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    Sequence5(const Sequence5&amp;  original,
              bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Sequence5&#39; having the value of the
        // specified &#39;original&#39; object.  Use the optionally specified
        // &#39;basicAllocator&#39; to supply memory.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.

    ~Sequence5();
        // Destroy this object.

    // MANIPULATORS
    Sequence5&amp; operator=(const Sequence5&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon
        // default construction).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttributes(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; sequentially on the address of
        // each (modifiable) attribute of this object, supplying &#39;manipulator&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;manipulator&#39; (i.e., the invocation that
        // terminated the sequence).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp; manipulator, int id);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;id&#39;,
        // supplying &#39;manipulator&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if &#39;id&#39; identifies an attribute of this
        // class, and -1 otherwise.

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp;  manipulator,
                            const char   *name,
                            int           nameLength);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;name&#39; of the
        // specified &#39;nameLength&#39;, supplying &#39;manipulator&#39; with the
        // corresponding attribute information structure.  Return the value
        // returned from the invocation of &#39;manipulator&#39; if &#39;name&#39; identifies
        // an attribute of this class, and -1 otherwise.

    Sequence3&amp; element1();
        // Return a reference to the modifiable &quot;Element1&quot; attribute of this
        // object.

    bsl::vector&lt;bdlb::NullableValue&lt;bool&gt; &gt;&amp; element2();
        // Return a reference to the modifiable &quot;Element2&quot; attribute of this
        // object.

    bsl::vector&lt;bdlb::NullableValue&lt;double&gt; &gt;&amp; element3();
        // Return a reference to the modifiable &quot;Element3&quot; attribute of this
        // object.

    bsl::vector&lt;bdlb::NullableValue&lt;bsl::vector&lt;char&gt; &gt; &gt;&amp; element4();
        // Return a reference to the modifiable &quot;Element4&quot; attribute of this
        // object.

    bsl::vector&lt;bdlb::NullableValue&lt;int&gt; &gt;&amp; element5();
        // Return a reference to the modifiable &quot;Element5&quot; attribute of this
        // object.

    bsl::vector&lt;bdlb::NullableValue&lt;bdlt::DatetimeTz&gt; &gt;&amp; element6();
        // Return a reference to the modifiable &quot;Element6&quot; attribute of this
        // object.

    bsl::vector&lt;bdlb::NullableAllocatedValue&lt;Sequence3&gt; &gt;&amp; element7();
        // Return a reference to the modifiable &quot;Element7&quot; attribute of this
        // object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    template&lt;class ACCESSOR&gt;
    int accessAttributes(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; sequentially on each
        // (non-modifiable) attribute of this object, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;accessor&#39; (i.e., the invocation that terminated
        // the sequence).

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp; accessor, int id) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;id&#39;, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure.  Return the
        // value returned from the invocation of &#39;accessor&#39; if &#39;id&#39; identifies
        // an attribute of this class, and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp;   accessor,
                        const char *name,
                        int         nameLength) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;name&#39; of the specified
        // &#39;nameLength&#39;, supplying &#39;accessor&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;accessor&#39; if &#39;name&#39; identifies an attribute of this
        // class, and -1 otherwise.

    const Sequence3&amp; element1() const;
        // Return a reference to the non-modifiable &quot;Element1&quot; attribute of
        // this object.

    const bsl::vector&lt;bdlb::NullableValue&lt;bool&gt; &gt;&amp; element2() const;
        // Return a reference to the non-modifiable &quot;Element2&quot; attribute of
        // this object.

    const bsl::vector&lt;bdlb::NullableValue&lt;double&gt; &gt;&amp; element3() const;
        // Return a reference to the non-modifiable &quot;Element3&quot; attribute of
        // this object.

    const bsl::vector&lt;bdlb::NullableValue&lt;bsl::vector&lt;char&gt; &gt; &gt;&amp; element4() const;
        // Return a reference to the non-modifiable &quot;Element4&quot; attribute of
        // this object.

    const bsl::vector&lt;bdlb::NullableValue&lt;int&gt; &gt;&amp; element5() const;
        // Return a reference to the non-modifiable &quot;Element5&quot; attribute of
        // this object.

    const bsl::vector&lt;bdlb::NullableValue&lt;bdlt::DatetimeTz&gt; &gt;&amp; element6() const;
        // Return a reference to the non-modifiable &quot;Element6&quot; attribute of
        // this object.

    const bsl::vector&lt;bdlb::NullableAllocatedValue&lt;Sequence3&gt; &gt;&amp; element7() const;
        // Return a reference to the non-modifiable &quot;Element7&quot; attribute of
        // this object.
};

// FREE OPERATORS
inline
bool operator==(const Sequence5&amp; lhs, const Sequence5&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects have
    // the same value, and &#39;false&#39; otherwise.  Two attribute objects have the
    // same value if each respective attribute has the same value.

inline
bool operator!=(const Sequence5&amp; lhs, const Sequence5&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects do not
    // have the same value, and &#39;false&#39; otherwise.  Two attribute objects do
    // not have the same value if one or more respective attributes differ in
    // values.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Sequence5&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::Sequence5)

namespace balb {

                              // ===============
                              // class Sequence6
                              // ===============

class Sequence6 {

    // INSTANCE DATA
    bsl::vector&lt;unsigned int&gt;                         d_element12;
    bsl::vector&lt;unsigned char&gt;                        d_element10;
    bsl::vector&lt;bdlb::NullableValue&lt;unsigned int&gt; &gt;   d_element15;
    bsl::vector&lt;bdlb::NullableValue&lt;unsigned char&gt; &gt;  d_element13;
    bsl::vector&lt;CustomString&gt;                         d_element11;
    bdlb::NullableValue&lt;CustomString&gt;                 d_element2;
    CustomString                                      d_element7;
    unsigned int                                      d_element4;
    bsl::vector&lt;bdlb::NullableValue&lt;CustomInt&gt; &gt;      d_element6;
    bsl::vector&lt;CustomInt&gt;                            d_element14;
    bdlb::NullableValue&lt;unsigned int&gt;                 d_element9;
    bdlb::NullableValue&lt;CustomInt&gt;                    d_element3;
    CustomInt                                         d_element8;
    unsigned char                                     d_element5;
    bdlb::NullableValue&lt;unsigned char&gt;                d_element1;

  public:
    // TYPES
    enum {
        e_ATTRIBUTE_ID_ELEMENT1  = 0
      , e_ATTRIBUTE_ID_ELEMENT2  = 1
      , e_ATTRIBUTE_ID_ELEMENT3  = 2
      , e_ATTRIBUTE_ID_ELEMENT4  = 3
      , e_ATTRIBUTE_ID_ELEMENT5  = 4
      , e_ATTRIBUTE_ID_ELEMENT6  = 5
      , e_ATTRIBUTE_ID_ELEMENT7  = 6
      , e_ATTRIBUTE_ID_ELEMENT8  = 7
      , e_ATTRIBUTE_ID_ELEMENT9  = 8
      , e_ATTRIBUTE_ID_ELEMENT10 = 9
      , e_ATTRIBUTE_ID_ELEMENT11 = 10
      , e_ATTRIBUTE_ID_ELEMENT12 = 11
      , e_ATTRIBUTE_ID_ELEMENT13 = 12
      , e_ATTRIBUTE_ID_ELEMENT14 = 13
      , e_ATTRIBUTE_ID_ELEMENT15 = 14
    };

    enum {
        k_NUM_ATTRIBUTES = 15
    };

    enum {
        e_ATTRIBUTE_INDEX_ELEMENT1  = 0
      , e_ATTRIBUTE_INDEX_ELEMENT2  = 1
      , e_ATTRIBUTE_INDEX_ELEMENT3  = 2
      , e_ATTRIBUTE_INDEX_ELEMENT4  = 3
      , e_ATTRIBUTE_INDEX_ELEMENT5  = 4
      , e_ATTRIBUTE_INDEX_ELEMENT6  = 5
      , e_ATTRIBUTE_INDEX_ELEMENT7  = 6
      , e_ATTRIBUTE_INDEX_ELEMENT8  = 7
      , e_ATTRIBUTE_INDEX_ELEMENT9  = 8
      , e_ATTRIBUTE_INDEX_ELEMENT10 = 9
      , e_ATTRIBUTE_INDEX_ELEMENT11 = 10
      , e_ATTRIBUTE_INDEX_ELEMENT12 = 11
      , e_ATTRIBUTE_INDEX_ELEMENT13 = 12
      , e_ATTRIBUTE_INDEX_ELEMENT14 = 13
      , e_ATTRIBUTE_INDEX_ELEMENT15 = 14
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo *lookupAttributeInfo(int id);
        // Return attribute information for the attribute indicated by the
        // specified &#39;id&#39; if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo *lookupAttributeInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return attribute information for the attribute indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the attribute
        // exists, and 0 otherwise.

    // CREATORS
    explicit Sequence6(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Sequence6&#39; having the default value.  Use
        // the optionally specified &#39;basicAllocator&#39; to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    Sequence6(const Sequence6&amp;  original,
              bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Sequence6&#39; having the value of the
        // specified &#39;original&#39; object.  Use the optionally specified
        // &#39;basicAllocator&#39; to supply memory.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.

    ~Sequence6();
        // Destroy this object.

    // MANIPULATORS
    Sequence6&amp; operator=(const Sequence6&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon
        // default construction).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttributes(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; sequentially on the address of
        // each (modifiable) attribute of this object, supplying &#39;manipulator&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;manipulator&#39; (i.e., the invocation that
        // terminated the sequence).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp; manipulator, int id);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;id&#39;,
        // supplying &#39;manipulator&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if &#39;id&#39; identifies an attribute of this
        // class, and -1 otherwise.

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp;  manipulator,
                            const char   *name,
                            int           nameLength);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;name&#39; of the
        // specified &#39;nameLength&#39;, supplying &#39;manipulator&#39; with the
        // corresponding attribute information structure.  Return the value
        // returned from the invocation of &#39;manipulator&#39; if &#39;name&#39; identifies
        // an attribute of this class, and -1 otherwise.

    bdlb::NullableValue&lt;unsigned char&gt;&amp; element1();
        // Return a reference to the modifiable &quot;Element1&quot; attribute of this
        // object.

    bdlb::NullableValue&lt;CustomString&gt;&amp; element2();
        // Return a reference to the modifiable &quot;Element2&quot; attribute of this
        // object.

    bdlb::NullableValue&lt;CustomInt&gt;&amp; element3();
        // Return a reference to the modifiable &quot;Element3&quot; attribute of this
        // object.

    unsigned int&amp; element4();
        // Return a reference to the modifiable &quot;Element4&quot; attribute of this
        // object.

    unsigned char&amp; element5();
        // Return a reference to the modifiable &quot;Element5&quot; attribute of this
        // object.

    bsl::vector&lt;bdlb::NullableValue&lt;CustomInt&gt; &gt;&amp; element6();
        // Return a reference to the modifiable &quot;Element6&quot; attribute of this
        // object.

    CustomString&amp; element7();
        // Return a reference to the modifiable &quot;Element7&quot; attribute of this
        // object.

    CustomInt&amp; element8();
        // Return a reference to the modifiable &quot;Element8&quot; attribute of this
        // object.

    bdlb::NullableValue&lt;unsigned int&gt;&amp; element9();
        // Return a reference to the modifiable &quot;Element9&quot; attribute of this
        // object.

    bsl::vector&lt;unsigned char&gt;&amp; element10();
        // Return a reference to the modifiable &quot;Element10&quot; attribute of this
        // object.

    bsl::vector&lt;CustomString&gt;&amp; element11();
        // Return a reference to the modifiable &quot;Element11&quot; attribute of this
        // object.

    bsl::vector&lt;unsigned int&gt;&amp; element12();
        // Return a reference to the modifiable &quot;Element12&quot; attribute of this
        // object.

    bsl::vector&lt;bdlb::NullableValue&lt;unsigned char&gt; &gt;&amp; element13();
        // Return a reference to the modifiable &quot;Element13&quot; attribute of this
        // object.

    bsl::vector&lt;CustomInt&gt;&amp; element14();
        // Return a reference to the modifiable &quot;Element14&quot; attribute of this
        // object.

    bsl::vector&lt;bdlb::NullableValue&lt;unsigned int&gt; &gt;&amp; element15();
        // Return a reference to the modifiable &quot;Element15&quot; attribute of this
        // object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    template&lt;class ACCESSOR&gt;
    int accessAttributes(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; sequentially on each
        // (non-modifiable) attribute of this object, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;accessor&#39; (i.e., the invocation that terminated
        // the sequence).

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp; accessor, int id) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;id&#39;, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure.  Return the
        // value returned from the invocation of &#39;accessor&#39; if &#39;id&#39; identifies
        // an attribute of this class, and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp;   accessor,
                        const char *name,
                        int         nameLength) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;name&#39; of the specified
        // &#39;nameLength&#39;, supplying &#39;accessor&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;accessor&#39; if &#39;name&#39; identifies an attribute of this
        // class, and -1 otherwise.

    const bdlb::NullableValue&lt;unsigned char&gt;&amp; element1() const;
        // Return a reference to the non-modifiable &quot;Element1&quot; attribute of
        // this object.

    const bdlb::NullableValue&lt;CustomString&gt;&amp; element2() const;
        // Return a reference to the non-modifiable &quot;Element2&quot; attribute of
        // this object.

    const bdlb::NullableValue&lt;CustomInt&gt;&amp; element3() const;
        // Return a reference to the non-modifiable &quot;Element3&quot; attribute of
        // this object.

    unsigned int element4() const;
        // Return a reference to the non-modifiable &quot;Element4&quot; attribute of
        // this object.

    unsigned char element5() const;
        // Return a reference to the non-modifiable &quot;Element5&quot; attribute of
        // this object.

    const bsl::vector&lt;bdlb::NullableValue&lt;CustomInt&gt; &gt;&amp; element6() const;
        // Return a reference to the non-modifiable &quot;Element6&quot; attribute of
        // this object.

    const CustomString&amp; element7() const;
        // Return a reference to the non-modifiable &quot;Element7&quot; attribute of
        // this object.

    const CustomInt&amp; element8() const;
        // Return a reference to the non-modifiable &quot;Element8&quot; attribute of
        // this object.

    const bdlb::NullableValue&lt;unsigned int&gt;&amp; element9() const;
        // Return a reference to the non-modifiable &quot;Element9&quot; attribute of
        // this object.

    const bsl::vector&lt;unsigned char&gt;&amp; element10() const;
        // Return a reference to the non-modifiable &quot;Element10&quot; attribute of
        // this object.

    const bsl::vector&lt;CustomString&gt;&amp; element11() const;
        // Return a reference to the non-modifiable &quot;Element11&quot; attribute of
        // this object.

    const bsl::vector&lt;unsigned int&gt;&amp; element12() const;
        // Return a reference to the non-modifiable &quot;Element12&quot; attribute of
        // this object.

    const bsl::vector&lt;bdlb::NullableValue&lt;unsigned char&gt; &gt;&amp; element13() const;
        // Return a reference to the non-modifiable &quot;Element13&quot; attribute of
        // this object.

    const bsl::vector&lt;CustomInt&gt;&amp; element14() const;
        // Return a reference to the non-modifiable &quot;Element14&quot; attribute of
        // this object.

    const bsl::vector&lt;bdlb::NullableValue&lt;unsigned int&gt; &gt;&amp; element15() const;
        // Return a reference to the non-modifiable &quot;Element15&quot; attribute of
        // this object.
};

// FREE OPERATORS
inline
bool operator==(const Sequence6&amp; lhs, const Sequence6&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects have
    // the same value, and &#39;false&#39; otherwise.  Two attribute objects have the
    // same value if each respective attribute has the same value.

inline
bool operator!=(const Sequence6&amp; lhs, const Sequence6&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects do not
    // have the same value, and &#39;false&#39; otherwise.  Two attribute objects do
    // not have the same value if one or more respective attributes differ in
    // values.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Sequence6&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::Sequence6)

namespace balb {

                               // =============
                               // class Choice3
                               // =============

class Choice3 {

    // INSTANCE DATA
    union {
        bsls::ObjectBuffer&lt; Sequence6 &gt;     d_selection1;
        bsls::ObjectBuffer&lt; unsigned char &gt; d_selection2;
        bsls::ObjectBuffer&lt; CustomString &gt;  d_selection3;
        bsls::ObjectBuffer&lt; CustomInt &gt;     d_selection4;
    };

    int                                     d_selectionId;
    bslma::Allocator                       *d_allocator_p;

  public:
    // TYPES
    enum {
        e_SELECTION_ID_UNDEFINED  = -1

      , e_SELECTION_ID_SELECTION1 = 0
      , e_SELECTION_ID_SELECTION2 = 1
      , e_SELECTION_ID_SELECTION3 = 2
      , e_SELECTION_ID_SELECTION4 = 3
    };

    enum {
        k_NUM_SELECTIONS = 4
    };

    enum {
        e_SELECTION_INDEX_SELECTION1 = 0
      , e_SELECTION_INDEX_SELECTION2 = 1
      , e_SELECTION_INDEX_SELECTION3 = 2
      , e_SELECTION_INDEX_SELECTION4 = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo *lookupSelectionInfo(int id);
        // Return selection information for the selection indicated by the
        // specified &#39;id&#39; if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo *lookupSelectionInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return selection information for the selection indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the selection
        // exists, and 0 otherwise.

    // CREATORS
    explicit Choice3(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Choice3&#39; having the default value.  Use
        // the optionally specified &#39;basicAllocator&#39; to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    Choice3(const Choice3&amp;  original,
           bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Choice3&#39; having the value of the specified
        // &#39;original&#39; object.  Use the optionally specified &#39;basicAllocator&#39; to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    ~Choice3();
        // Destroy this object.

    // MANIPULATORS
    Choice3&amp; operator=(const Choice3&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon default
        // construction).

    int makeSelection(int selectionId);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;selectionId&#39;.  Return 0 on success, and
        // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char *name, int nameLength);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;name&#39; of the specified &#39;nameLength&#39;.
        // Return 0 on success, and non-zero value otherwise (i.e., the
        // selection is not found).

    Sequence6&amp; makeSelection1();
    Sequence6&amp; makeSelection1(const Sequence6&amp; value);
        // Set the value of this object to be a &quot;Selection1&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection1&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection1&quot; value is used.

    unsigned char&amp; makeSelection2();
    unsigned char&amp; makeSelection2(unsigned char value);
        // Set the value of this object to be a &quot;Selection2&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection2&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection2&quot; value is used.

    CustomString&amp; makeSelection3();
    CustomString&amp; makeSelection3(const CustomString&amp; value);
        // Set the value of this object to be a &quot;Selection3&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection3&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection3&quot; value is used.

    CustomInt&amp; makeSelection4();
    CustomInt&amp; makeSelection4(const CustomInt&amp; value);
        // Set the value of this object to be a &quot;Selection4&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection4&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection4&quot; value is used.

    template&lt;class MANIPULATOR&gt;
    int manipulateSelection(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; on the address of the modifiable
        // selection, supplying &#39;manipulator&#39; with the corresponding selection
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if this object has a defined selection,
        // and -1 otherwise.

    Sequence6&amp; selection1();
        // Return a reference to the modifiable &quot;Selection1&quot; selection of this
        // object if &quot;Selection1&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection1&quot; is the selection of this object.

    unsigned char&amp; selection2();
        // Return a reference to the modifiable &quot;Selection2&quot; selection of this
        // object if &quot;Selection2&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection2&quot; is the selection of this object.

    CustomString&amp; selection3();
        // Return a reference to the modifiable &quot;Selection3&quot; selection of this
        // object if &quot;Selection3&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection3&quot; is the selection of this object.

    CustomInt&amp; selection4();
        // Return a reference to the modifiable &quot;Selection4&quot; selection of this
        // object if &quot;Selection4&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection4&quot; is the selection of this object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    int selectionId() const;
        // Return the id of the current selection if the selection is defined,
        // and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessSelection(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; on the non-modifiable selection,
        // supplying &#39;accessor&#39; with the corresponding selection information
        // structure.  Return the value returned from the invocation of
        // &#39;accessor&#39; if this object has a defined selection, and -1 otherwise.

    const Sequence6&amp; selection1() const;
        // Return a reference to the non-modifiable &quot;Selection1&quot; selection of
        // this object if &quot;Selection1&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection1&quot; is the selection of this object.

    const unsigned char&amp; selection2() const;
        // Return a reference to the non-modifiable &quot;Selection2&quot; selection of
        // this object if &quot;Selection2&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection2&quot; is the selection of this object.

    const CustomString&amp; selection3() const;
        // Return a reference to the non-modifiable &quot;Selection3&quot; selection of
        // this object if &quot;Selection3&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection3&quot; is the selection of this object.

    const CustomInt&amp; selection4() const;
        // Return a reference to the non-modifiable &quot;Selection4&quot; selection of
        // this object if &quot;Selection4&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection4&quot; is the selection of this object.

    bool isSelection1Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection1&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection2Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection2&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection3Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection3&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection4Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection4&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isUndefinedValue() const;
        // Return &#39;true&#39; if the value of this object is undefined, and &#39;false&#39;
        // otherwise.

    const char *selectionName() const;
        // Return the symbolic name of the current selection of this object.
};

// FREE OPERATORS
inline
bool operator==(const Choice3&amp; lhs, const Choice3&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;Choice3&#39; objects have the same
    // value if either the selections in both objects have the same ids and
    // the same values, or both selections are undefined.

inline
bool operator!=(const Choice3&amp; lhs, const Choice3&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same values, as determined by &#39;operator==&#39;, and &#39;false&#39; otherwise.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Choice3&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::Choice3)

namespace balb {

                     // =================================
                     // class SequenceWithAnonymityChoice
                     // =================================

class SequenceWithAnonymityChoice {

    // INSTANCE DATA
    union {
        bsls::ObjectBuffer&lt; Sequence6 &gt;     d_selection1;
        bsls::ObjectBuffer&lt; unsigned char &gt; d_selection2;
        bsls::ObjectBuffer&lt; CustomString &gt;  d_selection3;
        bsls::ObjectBuffer&lt; CustomInt &gt;     d_selection4;
    };

    int                                     d_selectionId;
    bslma::Allocator                       *d_allocator_p;

  public:
    // TYPES
    enum {
        e_SELECTION_ID_UNDEFINED  = -1

      , e_SELECTION_ID_SELECTION1 = 0
      , e_SELECTION_ID_SELECTION2 = 1
      , e_SELECTION_ID_SELECTION3 = 2
      , e_SELECTION_ID_SELECTION4 = 3
    };

    enum {
        k_NUM_SELECTIONS = 4
    };

    enum {
        e_SELECTION_INDEX_SELECTION1 = 0
      , e_SELECTION_INDEX_SELECTION2 = 1
      , e_SELECTION_INDEX_SELECTION3 = 2
      , e_SELECTION_INDEX_SELECTION4 = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo *lookupSelectionInfo(int id);
        // Return selection information for the selection indicated by the
        // specified &#39;id&#39; if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo *lookupSelectionInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return selection information for the selection indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the selection
        // exists, and 0 otherwise.

    // CREATORS
    explicit SequenceWithAnonymityChoice(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;SequenceWithAnonymityChoice&#39; having the
        // default value.  Use the optionally specified &#39;basicAllocator&#39; to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    SequenceWithAnonymityChoice(const SequenceWithAnonymityChoice&amp; original,
                               bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;SequenceWithAnonymityChoice&#39; having the
        // value of the specified &#39;original&#39; object.  Use the optionally
        // specified &#39;basicAllocator&#39; to supply memory.  If &#39;basicAllocator&#39; is
        // 0, the currently installed default allocator is used.

    ~SequenceWithAnonymityChoice();
        // Destroy this object.

    // MANIPULATORS
    SequenceWithAnonymityChoice&amp; operator=(const SequenceWithAnonymityChoice&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon default
        // construction).

    int makeSelection(int selectionId);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;selectionId&#39;.  Return 0 on success, and
        // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char *name, int nameLength);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;name&#39; of the specified &#39;nameLength&#39;.
        // Return 0 on success, and non-zero value otherwise (i.e., the
        // selection is not found).

    Sequence6&amp; makeSelection1();
    Sequence6&amp; makeSelection1(const Sequence6&amp; value);
        // Set the value of this object to be a &quot;Selection1&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection1&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection1&quot; value is used.

    unsigned char&amp; makeSelection2();
    unsigned char&amp; makeSelection2(unsigned char value);
        // Set the value of this object to be a &quot;Selection2&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection2&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection2&quot; value is used.

    CustomString&amp; makeSelection3();
    CustomString&amp; makeSelection3(const CustomString&amp; value);
        // Set the value of this object to be a &quot;Selection3&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection3&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection3&quot; value is used.

    CustomInt&amp; makeSelection4();
    CustomInt&amp; makeSelection4(const CustomInt&amp; value);
        // Set the value of this object to be a &quot;Selection4&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection4&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection4&quot; value is used.

    template&lt;class MANIPULATOR&gt;
    int manipulateSelection(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; on the address of the modifiable
        // selection, supplying &#39;manipulator&#39; with the corresponding selection
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if this object has a defined selection,
        // and -1 otherwise.

    Sequence6&amp; selection1();
        // Return a reference to the modifiable &quot;Selection1&quot; selection of this
        // object if &quot;Selection1&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection1&quot; is the selection of this object.

    unsigned char&amp; selection2();
        // Return a reference to the modifiable &quot;Selection2&quot; selection of this
        // object if &quot;Selection2&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection2&quot; is the selection of this object.

    CustomString&amp; selection3();
        // Return a reference to the modifiable &quot;Selection3&quot; selection of this
        // object if &quot;Selection3&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection3&quot; is the selection of this object.

    CustomInt&amp; selection4();
        // Return a reference to the modifiable &quot;Selection4&quot; selection of this
        // object if &quot;Selection4&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection4&quot; is the selection of this object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    int selectionId() const;
        // Return the id of the current selection if the selection is defined,
        // and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessSelection(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; on the non-modifiable selection,
        // supplying &#39;accessor&#39; with the corresponding selection information
        // structure.  Return the value returned from the invocation of
        // &#39;accessor&#39; if this object has a defined selection, and -1 otherwise.

    const Sequence6&amp; selection1() const;
        // Return a reference to the non-modifiable &quot;Selection1&quot; selection of
        // this object if &quot;Selection1&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection1&quot; is the selection of this object.

    const unsigned char&amp; selection2() const;
        // Return a reference to the non-modifiable &quot;Selection2&quot; selection of
        // this object if &quot;Selection2&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection2&quot; is the selection of this object.

    const CustomString&amp; selection3() const;
        // Return a reference to the non-modifiable &quot;Selection3&quot; selection of
        // this object if &quot;Selection3&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection3&quot; is the selection of this object.

    const CustomInt&amp; selection4() const;
        // Return a reference to the non-modifiable &quot;Selection4&quot; selection of
        // this object if &quot;Selection4&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection4&quot; is the selection of this object.

    bool isSelection1Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection1&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection2Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection2&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection3Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection3&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection4Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection4&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isUndefinedValue() const;
        // Return &#39;true&#39; if the value of this object is undefined, and &#39;false&#39;
        // otherwise.

    const char *selectionName() const;
        // Return the symbolic name of the current selection of this object.
};

// FREE OPERATORS
inline
bool operator==(const SequenceWithAnonymityChoice&amp; lhs, const SequenceWithAnonymityChoice&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;SequenceWithAnonymityChoice&#39; objects have the same
    // value if either the selections in both objects have the same ids and
    // the same values, or both selections are undefined.

inline
bool operator!=(const SequenceWithAnonymityChoice&amp; lhs, const SequenceWithAnonymityChoice&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same values, as determined by &#39;operator==&#39;, and &#39;false&#39; otherwise.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const SequenceWithAnonymityChoice&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::SequenceWithAnonymityChoice)

namespace balb {

                               // =============
                               // class Choice1
                               // =============

class Choice1 {

    // INSTANCE DATA
    union {
        bsls::ObjectBuffer&lt; int &gt;     d_selection1;
        bsls::ObjectBuffer&lt; double &gt;  d_selection2;
        Sequence4                    *d_selection3;
        Choice2                      *d_selection4;
    };

    int                               d_selectionId;
    bslma::Allocator                 *d_allocator_p;

  public:
    // TYPES
    enum {
        e_SELECTION_ID_UNDEFINED  = -1

      , e_SELECTION_ID_SELECTION1 = 0
      , e_SELECTION_ID_SELECTION2 = 1
      , e_SELECTION_ID_SELECTION3 = 2
      , e_SELECTION_ID_SELECTION4 = 3
    };

    enum {
        k_NUM_SELECTIONS = 4
    };

    enum {
        e_SELECTION_INDEX_SELECTION1 = 0
      , e_SELECTION_INDEX_SELECTION2 = 1
      , e_SELECTION_INDEX_SELECTION3 = 2
      , e_SELECTION_INDEX_SELECTION4 = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo *lookupSelectionInfo(int id);
        // Return selection information for the selection indicated by the
        // specified &#39;id&#39; if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo *lookupSelectionInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return selection information for the selection indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the selection
        // exists, and 0 otherwise.

    // CREATORS
    explicit Choice1(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Choice1&#39; having the default value.  Use
        // the optionally specified &#39;basicAllocator&#39; to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    Choice1(const Choice1&amp; original,
           bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Choice1&#39; having the value of the specified
        // &#39;original&#39; object.  Use the optionally specified &#39;basicAllocator&#39; to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    ~Choice1();
        // Destroy this object.

    // MANIPULATORS
    Choice1&amp; operator=(const Choice1&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon default
        // construction).

    int makeSelection(int selectionId);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;selectionId&#39;.  Return 0 on success, and
        // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char *name, int nameLength);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;name&#39; of the specified &#39;nameLength&#39;.
        // Return 0 on success, and non-zero value otherwise (i.e., the
        // selection is not found).

    int&amp; makeSelection1();
    int&amp; makeSelection1(int value);
        // Set the value of this object to be a &quot;Selection1&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection1&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection1&quot; value is used.

    double&amp; makeSelection2();
    double&amp; makeSelection2(double value);
        // Set the value of this object to be a &quot;Selection2&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection2&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection2&quot; value is used.

    Sequence4&amp; makeSelection3();
    Sequence4&amp; makeSelection3(const Sequence4&amp; value);
        // Set the value of this object to be a &quot;Selection3&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection3&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection3&quot; value is used.

    Choice2&amp; makeSelection4();
    Choice2&amp; makeSelection4(const Choice2&amp; value);
        // Set the value of this object to be a &quot;Selection4&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection4&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection4&quot; value is used.

    template&lt;class MANIPULATOR&gt;
    int manipulateSelection(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; on the address of the modifiable
        // selection, supplying &#39;manipulator&#39; with the corresponding selection
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if this object has a defined selection,
        // and -1 otherwise.

    int&amp; selection1();
        // Return a reference to the modifiable &quot;Selection1&quot; selection of this
        // object if &quot;Selection1&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection1&quot; is the selection of this object.

    double&amp; selection2();
        // Return a reference to the modifiable &quot;Selection2&quot; selection of this
        // object if &quot;Selection2&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection2&quot; is the selection of this object.

    Sequence4&amp; selection3();
        // Return a reference to the modifiable &quot;Selection3&quot; selection of this
        // object if &quot;Selection3&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection3&quot; is the selection of this object.

    Choice2&amp; selection4();
        // Return a reference to the modifiable &quot;Selection4&quot; selection of this
        // object if &quot;Selection4&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection4&quot; is the selection of this object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    int selectionId() const;
        // Return the id of the current selection if the selection is defined,
        // and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessSelection(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; on the non-modifiable selection,
        // supplying &#39;accessor&#39; with the corresponding selection information
        // structure.  Return the value returned from the invocation of
        // &#39;accessor&#39; if this object has a defined selection, and -1 otherwise.

    const int&amp; selection1() const;
        // Return a reference to the non-modifiable &quot;Selection1&quot; selection of
        // this object if &quot;Selection1&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection1&quot; is the selection of this object.

    const double&amp; selection2() const;
        // Return a reference to the non-modifiable &quot;Selection2&quot; selection of
        // this object if &quot;Selection2&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection2&quot; is the selection of this object.

    const Sequence4&amp; selection3() const;
        // Return a reference to the non-modifiable &quot;Selection3&quot; selection of
        // this object if &quot;Selection3&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection3&quot; is the selection of this object.

    const Choice2&amp; selection4() const;
        // Return a reference to the non-modifiable &quot;Selection4&quot; selection of
        // this object if &quot;Selection4&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection4&quot; is the selection of this object.

    bool isSelection1Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection1&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection2Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection2&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection3Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection3&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection4Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection4&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isUndefinedValue() const;
        // Return &#39;true&#39; if the value of this object is undefined, and &#39;false&#39;
        // otherwise.

    const char *selectionName() const;
        // Return the symbolic name of the current selection of this object.
};

// FREE OPERATORS
inline
bool operator==(const Choice1&amp; lhs, const Choice1&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;Choice1&#39; objects have the same
    // value if either the selections in both objects have the same ids and
    // the same values, or both selections are undefined.

inline
bool operator!=(const Choice1&amp; lhs, const Choice1&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same values, as determined by &#39;operator==&#39;, and &#39;false&#39; otherwise.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Choice1&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::Choice1)

namespace balb {

                               // =============
                               // class Choice2
                               // =============

class Choice2 {

    // INSTANCE DATA
    union {
        bsls::ObjectBuffer&lt; bool &gt;          d_selection1;
        bsls::ObjectBuffer&lt; bsl::string &gt;   d_selection2;
        Choice1                           *d_selection3;
        bsls::ObjectBuffer&lt; unsigned int &gt;  d_selection4;
    };

    int                                    d_selectionId;
    bslma::Allocator                       *d_allocator_p;

  public:
    // TYPES
    enum {
        e_SELECTION_ID_UNDEFINED  = -1

      , e_SELECTION_ID_SELECTION1 = 0
      , e_SELECTION_ID_SELECTION2 = 1
      , e_SELECTION_ID_SELECTION3 = 2
      , e_SELECTION_ID_SELECTION4 = 3
    };

    enum {
        k_NUM_SELECTIONS = 4
    };

    enum {
        e_SELECTION_INDEX_SELECTION1 = 0
      , e_SELECTION_INDEX_SELECTION2 = 1
      , e_SELECTION_INDEX_SELECTION3 = 2
      , e_SELECTION_INDEX_SELECTION4 = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo *lookupSelectionInfo(int id);
        // Return selection information for the selection indicated by the
        // specified &#39;id&#39; if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo *lookupSelectionInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return selection information for the selection indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the selection
        // exists, and 0 otherwise.

    // CREATORS
    explicit Choice2(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Choice2&#39; having the default value.  Use
        // the optionally specified &#39;basicAllocator&#39; to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    Choice2(const Choice2&amp; original,
           bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Choice2&#39; having the value of the specified
        // &#39;original&#39; object.  Use the optionally specified &#39;basicAllocator&#39; to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    ~Choice2();
        // Destroy this object.

    // MANIPULATORS
    Choice2&amp; operator=(const Choice2&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon default
        // construction).

    int makeSelection(int selectionId);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;selectionId&#39;.  Return 0 on success, and
        // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char *name, int nameLength);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;name&#39; of the specified &#39;nameLength&#39;.
        // Return 0 on success, and non-zero value otherwise (i.e., the
        // selection is not found).

    bool&amp; makeSelection1();
    bool&amp; makeSelection1(bool value);
        // Set the value of this object to be a &quot;Selection1&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection1&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection1&quot; value is used.

    bsl::string&amp; makeSelection2();
    bsl::string&amp; makeSelection2(const bsl::string&amp; value);
        // Set the value of this object to be a &quot;Selection2&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection2&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection2&quot; value is used.

    Choice1&amp; makeSelection3();
    Choice1&amp; makeSelection3(const Choice1&amp; value);
        // Set the value of this object to be a &quot;Selection3&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection3&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection3&quot; value is used.

    unsigned int&amp; makeSelection4();
    unsigned int&amp; makeSelection4(unsigned int value);
        // Set the value of this object to be a &quot;Selection4&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection4&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection4&quot; value is used.

    template&lt;class MANIPULATOR&gt;
    int manipulateSelection(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; on the address of the modifiable
        // selection, supplying &#39;manipulator&#39; with the corresponding selection
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if this object has a defined selection,
        // and -1 otherwise.

    bool&amp; selection1();
        // Return a reference to the modifiable &quot;Selection1&quot; selection of this
        // object if &quot;Selection1&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection1&quot; is the selection of this object.

    bsl::string&amp; selection2();
        // Return a reference to the modifiable &quot;Selection2&quot; selection of this
        // object if &quot;Selection2&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection2&quot; is the selection of this object.

    Choice1&amp; selection3();
        // Return a reference to the modifiable &quot;Selection3&quot; selection of this
        // object if &quot;Selection3&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection3&quot; is the selection of this object.

    unsigned int&amp; selection4();
        // Return a reference to the modifiable &quot;Selection4&quot; selection of this
        // object if &quot;Selection4&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection4&quot; is the selection of this object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    int selectionId() const;
        // Return the id of the current selection if the selection is defined,
        // and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessSelection(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; on the non-modifiable selection,
        // supplying &#39;accessor&#39; with the corresponding selection information
        // structure.  Return the value returned from the invocation of
        // &#39;accessor&#39; if this object has a defined selection, and -1 otherwise.

    const bool&amp; selection1() const;
        // Return a reference to the non-modifiable &quot;Selection1&quot; selection of
        // this object if &quot;Selection1&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection1&quot; is the selection of this object.

    const bsl::string&amp; selection2() const;
        // Return a reference to the non-modifiable &quot;Selection2&quot; selection of
        // this object if &quot;Selection2&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection2&quot; is the selection of this object.

    const Choice1&amp; selection3() const;
        // Return a reference to the non-modifiable &quot;Selection3&quot; selection of
        // this object if &quot;Selection3&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection3&quot; is the selection of this object.

    const unsigned int&amp; selection4() const;
        // Return a reference to the non-modifiable &quot;Selection4&quot; selection of
        // this object if &quot;Selection4&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection4&quot; is the selection of this object.

    bool isSelection1Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection1&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection2Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection2&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection3Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection3&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection4Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection4&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isUndefinedValue() const;
        // Return &#39;true&#39; if the value of this object is undefined, and &#39;false&#39;
        // otherwise.

    const char *selectionName() const;
        // Return the symbolic name of the current selection of this object.
};

// FREE OPERATORS
inline
bool operator==(const Choice2&amp; lhs, const Choice2&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;Choice2&#39; objects have the same
    // value if either the selections in both objects have the same ids and
    // the same values, or both selections are undefined.

inline
bool operator!=(const Choice2&amp; lhs, const Choice2&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same values, as determined by &#39;operator==&#39;, and &#39;false&#39; otherwise.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Choice2&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::Choice2)

namespace balb {

                              // ===============
                              // class Sequence4
                              // ===============

class Sequence4 {

    // INSTANCE DATA
    double                                   d_element10;
    bsl::vector&lt;int&gt;                         d_element17;
    bsl::vector&lt;double&gt;                      d_element15;
    bsl::vector&lt;char&gt;                        d_element11;
    bsl::vector&lt;bsl::vector&lt;char&gt; &gt;          d_element16;
    bsl::vector&lt;bool&gt;                        d_element14;
    bsl::vector&lt;bdlt::DatetimeTz&gt;             d_element18;
    bsl::vector&lt;Sequence3&gt;                   d_element1;
    bsl::vector&lt;CustomString&gt;                d_element19;
    bsl::vector&lt;Choice1&gt;                     d_element2;
    bsl::string                              d_element9;
    bdlb::NullableValue&lt;bsl::vector&lt;char&gt; &gt;  d_element3;
    bdlb::NullableValue&lt;bdlt::DatetimeTz&gt;     d_element5;
    bdlb::NullableValue&lt;CustomString&gt;        d_element6;
    int                                      d_element12;
    bdlb::NullableValue&lt;int&gt;                 d_element4;
    bdlb::NullableValue&lt;Enumerated::Value&gt;   d_element7;
    Enumerated::Value                        d_element13;
    bool                                     d_element8;

  public:
    // TYPES
    enum {
        e_ATTRIBUTE_ID_ELEMENT1  = 0
      , e_ATTRIBUTE_ID_ELEMENT2  = 1
      , e_ATTRIBUTE_ID_ELEMENT3  = 2
      , e_ATTRIBUTE_ID_ELEMENT4  = 3
      , e_ATTRIBUTE_ID_ELEMENT5  = 4
      , e_ATTRIBUTE_ID_ELEMENT6  = 5
      , e_ATTRIBUTE_ID_ELEMENT7  = 6
      , e_ATTRIBUTE_ID_ELEMENT8  = 7
      , e_ATTRIBUTE_ID_ELEMENT9  = 8
      , e_ATTRIBUTE_ID_ELEMENT10 = 9
      , e_ATTRIBUTE_ID_ELEMENT11 = 10
      , e_ATTRIBUTE_ID_ELEMENT12 = 11
      , e_ATTRIBUTE_ID_ELEMENT13 = 12
      , e_ATTRIBUTE_ID_ELEMENT14 = 13
      , e_ATTRIBUTE_ID_ELEMENT15 = 14
      , e_ATTRIBUTE_ID_ELEMENT16 = 15
      , e_ATTRIBUTE_ID_ELEMENT17 = 16
      , e_ATTRIBUTE_ID_ELEMENT18 = 17
      , e_ATTRIBUTE_ID_ELEMENT19 = 18
    };

    enum {
        k_NUM_ATTRIBUTES = 19
    };

    enum {
        e_ATTRIBUTE_INDEX_ELEMENT1  = 0
      , e_ATTRIBUTE_INDEX_ELEMENT2  = 1
      , e_ATTRIBUTE_INDEX_ELEMENT3  = 2
      , e_ATTRIBUTE_INDEX_ELEMENT4  = 3
      , e_ATTRIBUTE_INDEX_ELEMENT5  = 4
      , e_ATTRIBUTE_INDEX_ELEMENT6  = 5
      , e_ATTRIBUTE_INDEX_ELEMENT7  = 6
      , e_ATTRIBUTE_INDEX_ELEMENT8  = 7
      , e_ATTRIBUTE_INDEX_ELEMENT9  = 8
      , e_ATTRIBUTE_INDEX_ELEMENT10 = 9
      , e_ATTRIBUTE_INDEX_ELEMENT11 = 10
      , e_ATTRIBUTE_INDEX_ELEMENT12 = 11
      , e_ATTRIBUTE_INDEX_ELEMENT13 = 12
      , e_ATTRIBUTE_INDEX_ELEMENT14 = 13
      , e_ATTRIBUTE_INDEX_ELEMENT15 = 14
      , e_ATTRIBUTE_INDEX_ELEMENT16 = 15
      , e_ATTRIBUTE_INDEX_ELEMENT17 = 16
      , e_ATTRIBUTE_INDEX_ELEMENT18 = 17
      , e_ATTRIBUTE_INDEX_ELEMENT19 = 18
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo *lookupAttributeInfo(int id);
        // Return attribute information for the attribute indicated by the
        // specified &#39;id&#39; if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo *lookupAttributeInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return attribute information for the attribute indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the attribute
        // exists, and 0 otherwise.

    // CREATORS
    explicit Sequence4(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Sequence4&#39; having the default value.  Use
        // the optionally specified &#39;basicAllocator&#39; to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    Sequence4(const Sequence4&amp; original,
              bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Sequence4&#39; having the value of the
        // specified &#39;original&#39; object.  Use the optionally specified
        // &#39;basicAllocator&#39; to supply memory.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.

    ~Sequence4();
        // Destroy this object.

    // MANIPULATORS
    Sequence4&amp; operator=(const Sequence4&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon
        // default construction).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttributes(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; sequentially on the address of
        // each (modifiable) attribute of this object, supplying &#39;manipulator&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;manipulator&#39; (i.e., the invocation that
        // terminated the sequence).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp; manipulator, int id);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;id&#39;,
        // supplying &#39;manipulator&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if &#39;id&#39; identifies an attribute of this
        // class, and -1 otherwise.

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp;  manipulator,
                            const char   *name,
                            int           nameLength);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;name&#39; of the
        // specified &#39;nameLength&#39;, supplying &#39;manipulator&#39; with the
        // corresponding attribute information structure.  Return the value
        // returned from the invocation of &#39;manipulator&#39; if &#39;name&#39; identifies
        // an attribute of this class, and -1 otherwise.

    bsl::vector&lt;Sequence3&gt;&amp; element1();
        // Return a reference to the modifiable &quot;Element1&quot; attribute of this
        // object.

    bsl::vector&lt;Choice1&gt;&amp; element2();
        // Return a reference to the modifiable &quot;Element2&quot; attribute of this
        // object.

    bdlb::NullableValue&lt;bsl::vector&lt;char&gt; &gt;&amp; element3();
        // Return a reference to the modifiable &quot;Element3&quot; attribute of this
        // object.

    bdlb::NullableValue&lt;int&gt;&amp; element4();
        // Return a reference to the modifiable &quot;Element4&quot; attribute of this
        // object.

    bdlb::NullableValue&lt;bdlt::DatetimeTz&gt;&amp; element5();
        // Return a reference to the modifiable &quot;Element5&quot; attribute of this
        // object.

    bdlb::NullableValue&lt;CustomString&gt;&amp; element6();
        // Return a reference to the modifiable &quot;Element6&quot; attribute of this
        // object.

    bdlb::NullableValue&lt;Enumerated::Value&gt;&amp; element7();
        // Return a reference to the modifiable &quot;Element7&quot; attribute of this
        // object.

    bool&amp; element8();
        // Return a reference to the modifiable &quot;Element8&quot; attribute of this
        // object.

    bsl::string&amp; element9();
        // Return a reference to the modifiable &quot;Element9&quot; attribute of this
        // object.

    double&amp; element10();
        // Return a reference to the modifiable &quot;Element10&quot; attribute of this
        // object.

    bsl::vector&lt;char&gt;&amp; element11();
        // Return a reference to the modifiable &quot;Element11&quot; attribute of this
        // object.

    int&amp; element12();
        // Return a reference to the modifiable &quot;Element12&quot; attribute of this
        // object.

    Enumerated::Value&amp; element13();
        // Return a reference to the modifiable &quot;Element13&quot; attribute of this
        // object.

    bsl::vector&lt;bool&gt;&amp; element14();
        // Return a reference to the modifiable &quot;Element14&quot; attribute of this
        // object.

    bsl::vector&lt;double&gt;&amp; element15();
        // Return a reference to the modifiable &quot;Element15&quot; attribute of this
        // object.

    bsl::vector&lt;bsl::vector&lt;char&gt; &gt;&amp; element16();
        // Return a reference to the modifiable &quot;Element16&quot; attribute of this
        // object.

    bsl::vector&lt;int&gt;&amp; element17();
        // Return a reference to the modifiable &quot;Element17&quot; attribute of this
        // object.

    bsl::vector&lt;bdlt::DatetimeTz&gt;&amp; element18();
        // Return a reference to the modifiable &quot;Element18&quot; attribute of this
        // object.

    bsl::vector&lt;CustomString&gt;&amp; element19();
        // Return a reference to the modifiable &quot;Element19&quot; attribute of this
        // object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    template&lt;class ACCESSOR&gt;
    int accessAttributes(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; sequentially on each
        // (non-modifiable) attribute of this object, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;accessor&#39; (i.e., the invocation that terminated
        // the sequence).

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp; accessor, int id) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;id&#39;, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure.  Return the
        // value returned from the invocation of &#39;accessor&#39; if &#39;id&#39; identifies
        // an attribute of this class, and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp;   accessor,
                        const char *name,
                        int         nameLength) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;name&#39; of the specified
        // &#39;nameLength&#39;, supplying &#39;accessor&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;accessor&#39; if &#39;name&#39; identifies an attribute of this
        // class, and -1 otherwise.

    const bsl::vector&lt;Sequence3&gt;&amp; element1() const;
        // Return a reference to the non-modifiable &quot;Element1&quot; attribute of
        // this object.

    const bsl::vector&lt;Choice1&gt;&amp; element2() const;
        // Return a reference to the non-modifiable &quot;Element2&quot; attribute of
        // this object.

    const bdlb::NullableValue&lt;bsl::vector&lt;char&gt; &gt;&amp; element3() const;
        // Return a reference to the non-modifiable &quot;Element3&quot; attribute of
        // this object.

    const bdlb::NullableValue&lt;int&gt;&amp; element4() const;
        // Return a reference to the non-modifiable &quot;Element4&quot; attribute of
        // this object.

    const bdlb::NullableValue&lt;bdlt::DatetimeTz&gt;&amp; element5() const;
        // Return a reference to the non-modifiable &quot;Element5&quot; attribute of
        // this object.

    const bdlb::NullableValue&lt;CustomString&gt;&amp; element6() const;
        // Return a reference to the non-modifiable &quot;Element6&quot; attribute of
        // this object.

    const bdlb::NullableValue&lt;Enumerated::Value&gt;&amp; element7() const;
        // Return a reference to the non-modifiable &quot;Element7&quot; attribute of
        // this object.

    bool element8() const;
        // Return a reference to the non-modifiable &quot;Element8&quot; attribute of
        // this object.

    const bsl::string&amp; element9() const;
        // Return a reference to the non-modifiable &quot;Element9&quot; attribute of
        // this object.

    double element10() const;
        // Return a reference to the non-modifiable &quot;Element10&quot; attribute of
        // this object.

    const bsl::vector&lt;char&gt;&amp; element11() const;
        // Return a reference to the non-modifiable &quot;Element11&quot; attribute of
        // this object.

    int element12() const;
        // Return a reference to the non-modifiable &quot;Element12&quot; attribute of
        // this object.

    Enumerated::Value element13() const;
        // Return a reference to the non-modifiable &quot;Element13&quot; attribute of
        // this object.

    const bsl::vector&lt;bool&gt;&amp; element14() const;
        // Return a reference to the non-modifiable &quot;Element14&quot; attribute of
        // this object.

    const bsl::vector&lt;double&gt;&amp; element15() const;
        // Return a reference to the non-modifiable &quot;Element15&quot; attribute of
        // this object.

    const bsl::vector&lt;bsl::vector&lt;char&gt; &gt;&amp; element16() const;
        // Return a reference to the non-modifiable &quot;Element16&quot; attribute of
        // this object.

    const bsl::vector&lt;int&gt;&amp; element17() const;
        // Return a reference to the non-modifiable &quot;Element17&quot; attribute of
        // this object.

    const bsl::vector&lt;bdlt::DatetimeTz&gt;&amp; element18() const;
        // Return a reference to the non-modifiable &quot;Element18&quot; attribute of
        // this object.

    const bsl::vector&lt;CustomString&gt;&amp; element19() const;
        // Return a reference to the non-modifiable &quot;Element19&quot; attribute of
        // this object.
};

// FREE OPERATORS
inline
bool operator==(const Sequence4&amp; lhs, const Sequence4&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects have
    // the same value, and &#39;false&#39; otherwise.  Two attribute objects have the
    // same value if each respective attribute has the same value.

inline
bool operator!=(const Sequence4&amp; lhs, const Sequence4&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects do not
    // have the same value, and &#39;false&#39; otherwise.  Two attribute objects do
    // not have the same value if one or more respective attributes differ in
    // values.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Sequence4&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::Sequence4)

namespace balb {

                              // ===============
                              // class Sequence1
                              // ===============

class Sequence1 {

    // INSTANCE DATA
    bslma::Allocator                            *d_allocator_p;
    bsl::vector&lt;bdlb::NullableValue&lt;Choice1&gt; &gt;  d_element4;
    bsl::vector&lt;Choice3&gt;                        d_element5;
    bsl::vector&lt;Choice1&gt;                        d_element2;
    bdlb::NullableValue&lt;Choice3&gt;                d_element1;
    Choice2                                    *d_element3;

  public:
    // TYPES
    enum {
        e_ATTRIBUTE_ID_ELEMENT1 = 0
      , e_ATTRIBUTE_ID_ELEMENT2 = 1
      , e_ATTRIBUTE_ID_ELEMENT3 = 2
      , e_ATTRIBUTE_ID_ELEMENT4 = 3
      , e_ATTRIBUTE_ID_ELEMENT5 = 4
    };

    enum {
        k_NUM_ATTRIBUTES = 5
    };

    enum {
        e_ATTRIBUTE_INDEX_ELEMENT1 = 0
      , e_ATTRIBUTE_INDEX_ELEMENT2 = 1
      , e_ATTRIBUTE_INDEX_ELEMENT3 = 2
      , e_ATTRIBUTE_INDEX_ELEMENT4 = 3
      , e_ATTRIBUTE_INDEX_ELEMENT5 = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo *lookupAttributeInfo(int id);
        // Return attribute information for the attribute indicated by the
        // specified &#39;id&#39; if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo *lookupAttributeInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return attribute information for the attribute indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the attribute
        // exists, and 0 otherwise.

    // CREATORS
    explicit Sequence1(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Sequence1&#39; having the default value.  Use
        // the optionally specified &#39;basicAllocator&#39; to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    Sequence1(const Sequence1&amp; original,
              bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Sequence1&#39; having the value of the
        // specified &#39;original&#39; object.  Use the optionally specified
        // &#39;basicAllocator&#39; to supply memory.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.

    ~Sequence1();
        // Destroy this object.

    // MANIPULATORS
    Sequence1&amp; operator=(const Sequence1&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon
        // default construction).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttributes(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; sequentially on the address of
        // each (modifiable) attribute of this object, supplying &#39;manipulator&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;manipulator&#39; (i.e., the invocation that
        // terminated the sequence).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp; manipulator, int id);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;id&#39;,
        // supplying &#39;manipulator&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if &#39;id&#39; identifies an attribute of this
        // class, and -1 otherwise.

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp;  manipulator,
                            const char   *name,
                            int           nameLength);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;name&#39; of the
        // specified &#39;nameLength&#39;, supplying &#39;manipulator&#39; with the
        // corresponding attribute information structure.  Return the value
        // returned from the invocation of &#39;manipulator&#39; if &#39;name&#39; identifies
        // an attribute of this class, and -1 otherwise.

    bdlb::NullableValue&lt;Choice3&gt;&amp; element1();
        // Return a reference to the modifiable &quot;Element1&quot; attribute of this
        // object.

    bsl::vector&lt;Choice1&gt;&amp; element2();
        // Return a reference to the modifiable &quot;Element2&quot; attribute of this
        // object.

    Choice2&amp; element3();
        // Return a reference to the modifiable &quot;Element3&quot; attribute of this
        // object.

    bsl::vector&lt;bdlb::NullableValue&lt;Choice1&gt; &gt;&amp; element4();
        // Return a reference to the modifiable &quot;Element4&quot; attribute of this
        // object.

    bsl::vector&lt;Choice3&gt;&amp; element5();
        // Return a reference to the modifiable &quot;Element5&quot; attribute of this
        // object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    template&lt;class ACCESSOR&gt;
    int accessAttributes(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; sequentially on each
        // (non-modifiable) attribute of this object, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;accessor&#39; (i.e., the invocation that terminated
        // the sequence).

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp; accessor, int id) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;id&#39;, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure.  Return the
        // value returned from the invocation of &#39;accessor&#39; if &#39;id&#39; identifies
        // an attribute of this class, and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp;   accessor,
                        const char *name,
                        int         nameLength) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;name&#39; of the specified
        // &#39;nameLength&#39;, supplying &#39;accessor&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;accessor&#39; if &#39;name&#39; identifies an attribute of this
        // class, and -1 otherwise.

    const bdlb::NullableValue&lt;Choice3&gt;&amp; element1() const;
        // Return a reference to the non-modifiable &quot;Element1&quot; attribute of
        // this object.

    const bsl::vector&lt;Choice1&gt;&amp; element2() const;
        // Return a reference to the non-modifiable &quot;Element2&quot; attribute of
        // this object.

    const Choice2&amp; element3() const;
        // Return a reference to the non-modifiable &quot;Element3&quot; attribute of
        // this object.

    const bsl::vector&lt;bdlb::NullableValue&lt;Choice1&gt; &gt;&amp; element4() const;
        // Return a reference to the non-modifiable &quot;Element4&quot; attribute of
        // this object.

    const bsl::vector&lt;Choice3&gt;&amp; element5() const;
        // Return a reference to the non-modifiable &quot;Element5&quot; attribute of
        // this object.
};

// FREE OPERATORS
inline
bool operator==(const Sequence1&amp; lhs, const Sequence1&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects have
    // the same value, and &#39;false&#39; otherwise.  Two attribute objects have the
    // same value if each respective attribute has the same value.

inline
bool operator!=(const Sequence1&amp; lhs, const Sequence1&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects do not
    // have the same value, and &#39;false&#39; otherwise.  Two attribute objects do
    // not have the same value if one or more respective attributes differ in
    // values.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Sequence1&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::Sequence1)

namespace balb {

                              // ===============
                              // class Sequence2
                              // ===============

class Sequence2 {

    // INSTANCE DATA
    bdlb::NullableValue&lt;double&gt;   d_element5;
    bdlb::NullableValue&lt;Choice1&gt;  d_element4;
    bdlt::DatetimeTz               d_element3;
    CustomString                  d_element1;
    unsigned char                 d_element2;

  public:
    // TYPES
    enum {
        e_ATTRIBUTE_ID_ELEMENT1 = 0
      , e_ATTRIBUTE_ID_ELEMENT2 = 1
      , e_ATTRIBUTE_ID_ELEMENT3 = 2
      , e_ATTRIBUTE_ID_ELEMENT4 = 3
      , e_ATTRIBUTE_ID_ELEMENT5 = 4
    };

    enum {
        k_NUM_ATTRIBUTES = 5
    };

    enum {
        e_ATTRIBUTE_INDEX_ELEMENT1 = 0
      , e_ATTRIBUTE_INDEX_ELEMENT2 = 1
      , e_ATTRIBUTE_INDEX_ELEMENT3 = 2
      , e_ATTRIBUTE_INDEX_ELEMENT4 = 3
      , e_ATTRIBUTE_INDEX_ELEMENT5 = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo *lookupAttributeInfo(int id);
        // Return attribute information for the attribute indicated by the
        // specified &#39;id&#39; if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo *lookupAttributeInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return attribute information for the attribute indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the attribute
        // exists, and 0 otherwise.

    // CREATORS
    explicit Sequence2(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Sequence2&#39; having the default value.  Use
        // the optionally specified &#39;basicAllocator&#39; to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    Sequence2(const Sequence2&amp; original,
              bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Sequence2&#39; having the value of the
        // specified &#39;original&#39; object.  Use the optionally specified
        // &#39;basicAllocator&#39; to supply memory.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.

    ~Sequence2();
        // Destroy this object.

    // MANIPULATORS
    Sequence2&amp; operator=(const Sequence2&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon
        // default construction).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttributes(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; sequentially on the address of
        // each (modifiable) attribute of this object, supplying &#39;manipulator&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;manipulator&#39; (i.e., the invocation that
        // terminated the sequence).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp; manipulator, int id);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;id&#39;,
        // supplying &#39;manipulator&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if &#39;id&#39; identifies an attribute of this
        // class, and -1 otherwise.

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp;  manipulator,
                            const char   *name,
                            int           nameLength);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;name&#39; of the
        // specified &#39;nameLength&#39;, supplying &#39;manipulator&#39; with the
        // corresponding attribute information structure.  Return the value
        // returned from the invocation of &#39;manipulator&#39; if &#39;name&#39; identifies
        // an attribute of this class, and -1 otherwise.

    CustomString&amp; element1();
        // Return a reference to the modifiable &quot;Element1&quot; attribute of this
        // object.

    unsigned char&amp; element2();
        // Return a reference to the modifiable &quot;Element2&quot; attribute of this
        // object.

    bdlt::DatetimeTz&amp; element3();
        // Return a reference to the modifiable &quot;Element3&quot; attribute of this
        // object.

    bdlb::NullableValue&lt;Choice1&gt;&amp; element4();
        // Return a reference to the modifiable &quot;Element4&quot; attribute of this
        // object.

    bdlb::NullableValue&lt;double&gt;&amp; element5();
        // Return a reference to the modifiable &quot;Element5&quot; attribute of this
        // object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    template&lt;class ACCESSOR&gt;
    int accessAttributes(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; sequentially on each
        // (non-modifiable) attribute of this object, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;accessor&#39; (i.e., the invocation that terminated
        // the sequence).

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp; accessor, int id) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;id&#39;, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure.  Return the
        // value returned from the invocation of &#39;accessor&#39; if &#39;id&#39; identifies
        // an attribute of this class, and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp;   accessor,
                        const char *name,
                        int         nameLength) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;name&#39; of the specified
        // &#39;nameLength&#39;, supplying &#39;accessor&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;accessor&#39; if &#39;name&#39; identifies an attribute of this
        // class, and -1 otherwise.

    const CustomString&amp; element1() const;
        // Return a reference to the non-modifiable &quot;Element1&quot; attribute of
        // this object.

    unsigned char element2() const;
        // Return a reference to the non-modifiable &quot;Element2&quot; attribute of
        // this object.

    const bdlt::DatetimeTz&amp; element3() const;
        // Return a reference to the non-modifiable &quot;Element3&quot; attribute of
        // this object.

    const bdlb::NullableValue&lt;Choice1&gt;&amp; element4() const;
        // Return a reference to the non-modifiable &quot;Element4&quot; attribute of
        // this object.

    const bdlb::NullableValue&lt;double&gt;&amp; element5() const;
        // Return a reference to the non-modifiable &quot;Element5&quot; attribute of
        // this object.
};

// FREE OPERATORS
inline
bool operator==(const Sequence2&amp; lhs, const Sequence2&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects have
    // the same value, and &#39;false&#39; otherwise.  Two attribute objects have the
    // same value if each respective attribute has the same value.

inline
bool operator!=(const Sequence2&amp; lhs, const Sequence2&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects do not
    // have the same value, and &#39;false&#39; otherwise.  Two attribute objects do
    // not have the same value if one or more respective attributes differ in
    // values.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Sequence2&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::Sequence2)

namespace balb {

                     // ==================================
                     // class SequenceWithAnonymityChoice2
                     // ==================================

class SequenceWithAnonymityChoice2 {

    // INSTANCE DATA
    union {
        Sequence4             *d_selection7;
        Choice2               *d_selection8;
    };

    int                        d_selectionId;
    bslma::Allocator           *d_allocator_p;

  public:
    // TYPES
    enum {
        e_SELECTION_ID_UNDEFINED  = -1

      , e_SELECTION_ID_SELECTION7 = 0
      , e_SELECTION_ID_SELECTION8 = 1
    };

    enum {
        k_NUM_SELECTIONS = 2
    };

    enum {
        e_SELECTION_INDEX_SELECTION7 = 0
      , e_SELECTION_INDEX_SELECTION8 = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo *lookupSelectionInfo(int id);
        // Return selection information for the selection indicated by the
        // specified &#39;id&#39; if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo *lookupSelectionInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return selection information for the selection indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the selection
        // exists, and 0 otherwise.

    // CREATORS
    explicit SequenceWithAnonymityChoice2(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;SequenceWithAnonymityChoice2&#39; having the
        // default value.  Use the optionally specified &#39;basicAllocator&#39; to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    SequenceWithAnonymityChoice2(const SequenceWithAnonymityChoice2&amp; original,
                                bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;SequenceWithAnonymityChoice2&#39; having the
        // value of the specified &#39;original&#39; object.  Use the optionally
        // specified &#39;basicAllocator&#39; to supply memory.  If &#39;basicAllocator&#39; is
        // 0, the currently installed default allocator is used.

    ~SequenceWithAnonymityChoice2();
        // Destroy this object.

    // MANIPULATORS
    SequenceWithAnonymityChoice2&amp; operator=(const SequenceWithAnonymityChoice2&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon default
        // construction).

    int makeSelection(int selectionId);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;selectionId&#39;.  Return 0 on success, and
        // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char *name, int nameLength);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;name&#39; of the specified &#39;nameLength&#39;.
        // Return 0 on success, and non-zero value otherwise (i.e., the
        // selection is not found).

    Sequence4&amp; makeSelection7();
    Sequence4&amp; makeSelection7(const Sequence4&amp; value);
        // Set the value of this object to be a &quot;Selection7&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection7&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection7&quot; value is used.

    Choice2&amp; makeSelection8();
    Choice2&amp; makeSelection8(const Choice2&amp; value);
        // Set the value of this object to be a &quot;Selection8&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection8&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection8&quot; value is used.

    template&lt;class MANIPULATOR&gt;
    int manipulateSelection(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; on the address of the modifiable
        // selection, supplying &#39;manipulator&#39; with the corresponding selection
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if this object has a defined selection,
        // and -1 otherwise.

    Sequence4&amp; selection7();
        // Return a reference to the modifiable &quot;Selection7&quot; selection of this
        // object if &quot;Selection7&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection7&quot; is the selection of this object.

    Choice2&amp; selection8();
        // Return a reference to the modifiable &quot;Selection8&quot; selection of this
        // object if &quot;Selection8&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection8&quot; is the selection of this object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    int selectionId() const;
        // Return the id of the current selection if the selection is defined,
        // and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessSelection(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; on the non-modifiable selection,
        // supplying &#39;accessor&#39; with the corresponding selection information
        // structure.  Return the value returned from the invocation of
        // &#39;accessor&#39; if this object has a defined selection, and -1 otherwise.

    const Sequence4&amp; selection7() const;
        // Return a reference to the non-modifiable &quot;Selection7&quot; selection of
        // this object if &quot;Selection7&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection7&quot; is the selection of this object.

    const Choice2&amp; selection8() const;
        // Return a reference to the non-modifiable &quot;Selection8&quot; selection of
        // this object if &quot;Selection8&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection8&quot; is the selection of this object.

    bool isSelection7Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection7&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection8Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection8&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isUndefinedValue() const;
        // Return &#39;true&#39; if the value of this object is undefined, and &#39;false&#39;
        // otherwise.

    const char *selectionName() const;
        // Return the symbolic name of the current selection of this object.
};

// FREE OPERATORS
inline
bool operator==(const SequenceWithAnonymityChoice2&amp; lhs, const SequenceWithAnonymityChoice2&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;SequenceWithAnonymityChoice2&#39; objects have the same
    // value if either the selections in both objects have the same ids and
    // the same values, or both selections are undefined.

inline
bool operator!=(const SequenceWithAnonymityChoice2&amp; lhs, const SequenceWithAnonymityChoice2&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same values, as determined by &#39;operator==&#39;, and &#39;false&#39; otherwise.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const SequenceWithAnonymityChoice2&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::SequenceWithAnonymityChoice2)

namespace balb {

                        // ===========================
                        // class SequenceWithAnonymity
                        // ===========================

class SequenceWithAnonymity {

    // INSTANCE DATA
    bdlb::NullableValue&lt;SequenceWithAnonymityChoice2&gt;  d_choice2;
    SequenceWithAnonymityChoice1                       d_choice1;
    SequenceWithAnonymityChoice                        d_choice;
    Sequence6                                          d_element4;

  public:
    // TYPES
    enum {
        e_ATTRIBUTE_ID_CHOICE   = 0
      , e_ATTRIBUTE_ID_CHOICE1  = 1
      , e_ATTRIBUTE_ID_CHOICE2  = 2
      , e_ATTRIBUTE_ID_ELEMENT4 = 3
    };

    enum {
        k_NUM_ATTRIBUTES = 4
    };

    enum {
        e_ATTRIBUTE_INDEX_CHOICE   = 0
      , e_ATTRIBUTE_INDEX_CHOICE1  = 1
      , e_ATTRIBUTE_INDEX_CHOICE2  = 2
      , e_ATTRIBUTE_INDEX_ELEMENT4 = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo *lookupAttributeInfo(int id);
        // Return attribute information for the attribute indicated by the
        // specified &#39;id&#39; if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo *lookupAttributeInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return attribute information for the attribute indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the attribute
        // exists, and 0 otherwise.

    // CREATORS
    explicit SequenceWithAnonymity(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;SequenceWithAnonymity&#39; having the default
        // value.  Use the optionally specified &#39;basicAllocator&#39; to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.

    SequenceWithAnonymity(const SequenceWithAnonymity&amp; original,
                          bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;SequenceWithAnonymity&#39; having the value of
        // the specified &#39;original&#39; object.  Use the optionally specified
        // &#39;basicAllocator&#39; to supply memory.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.

    ~SequenceWithAnonymity();
        // Destroy this object.

    // MANIPULATORS
    SequenceWithAnonymity&amp; operator=(const SequenceWithAnonymity&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon
        // default construction).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttributes(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; sequentially on the address of
        // each (modifiable) attribute of this object, supplying &#39;manipulator&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;manipulator&#39; (i.e., the invocation that
        // terminated the sequence).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp; manipulator, int id);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;id&#39;,
        // supplying &#39;manipulator&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if &#39;id&#39; identifies an attribute of this
        // class, and -1 otherwise.

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp;  manipulator,
                            const char   *name,
                            int           nameLength);
        // Invoke the specified &#39;manipulator&#39; on the address of
        // the (modifiable) attribute indicated by the specified &#39;name&#39; of the
        // specified &#39;nameLength&#39;, supplying &#39;manipulator&#39; with the
        // corresponding attribute information structure.  Return the value
        // returned from the invocation of &#39;manipulator&#39; if &#39;name&#39; identifies
        // an attribute of this class, and -1 otherwise.

    SequenceWithAnonymityChoice&amp; choice();
        // Return a reference to the modifiable &quot;Choice&quot; attribute of this
        // object.

    SequenceWithAnonymityChoice1&amp; choice1();
        // Return a reference to the modifiable &quot;Choice1&quot; attribute of this
        // object.

    bdlb::NullableValue&lt;SequenceWithAnonymityChoice2&gt;&amp; choice2();
        // Return a reference to the modifiable &quot;Choice2&quot; attribute of this
        // object.

    Sequence6&amp; element4();
        // Return a reference to the modifiable &quot;Element4&quot; attribute of this
        // object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    template&lt;class ACCESSOR&gt;
    int accessAttributes(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; sequentially on each
        // (non-modifiable) attribute of this object, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the
        // last invocation of &#39;accessor&#39; (i.e., the invocation that terminated
        // the sequence).

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp; accessor, int id) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;id&#39;, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure.  Return the
        // value returned from the invocation of &#39;accessor&#39; if &#39;id&#39; identifies
        // an attribute of this class, and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp;   accessor,
                        const char *name,
                        int         nameLength) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute
        // of this object indicated by the specified &#39;name&#39; of the specified
        // &#39;nameLength&#39;, supplying &#39;accessor&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;accessor&#39; if &#39;name&#39; identifies an attribute of this
        // class, and -1 otherwise.

    const SequenceWithAnonymityChoice&amp; choice() const;
        // Return a reference to the non-modifiable &quot;Choice&quot; attribute of this
        // object.

    const SequenceWithAnonymityChoice1&amp; choice1() const;
        // Return a reference to the non-modifiable &quot;Choice1&quot; attribute of this
        // object.

    const bdlb::NullableValue&lt;SequenceWithAnonymityChoice2&gt;&amp; choice2() const;
        // Return a reference to the non-modifiable &quot;Choice2&quot; attribute of this
        // object.

    const Sequence6&amp; element4() const;
        // Return a reference to the non-modifiable &quot;Element4&quot; attribute of
        // this object.
};

// FREE OPERATORS
inline
bool operator==(const SequenceWithAnonymity&amp; lhs, const SequenceWithAnonymity&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects have
    // the same value, and &#39;false&#39; otherwise.  Two attribute objects have the
    // same value if each respective attribute has the same value.

inline
bool operator!=(const SequenceWithAnonymity&amp; lhs, const SequenceWithAnonymity&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects do not
    // have the same value, and &#39;false&#39; otherwise.  Two attribute objects do
    // not have the same value if one or more respective attributes differ in
    // values.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const SequenceWithAnonymity&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::SequenceWithAnonymity)

namespace balb {

                          // ========================
                          // class FeatureTestMessage
                          // ========================

class FeatureTestMessage {

    // INSTANCE DATA
    union {
        bsls::ObjectBuffer&lt; Sequence1 &gt;              d_selection1;
        bsls::ObjectBuffer&lt; bsl::vector&lt;char&gt; &gt;      d_selection2;
        bsls::ObjectBuffer&lt; Sequence2 &gt;              d_selection3;
        Sequence3                                   *d_selection4;
        bsls::ObjectBuffer&lt; bdlt::DatetimeTz &gt;        d_selection5;
        bsls::ObjectBuffer&lt; CustomString &gt;           d_selection6;
        bsls::ObjectBuffer&lt; Enumerated::Value &gt;      d_selection7;
        bsls::ObjectBuffer&lt; Choice3 &gt;                d_selection8;
        bsls::ObjectBuffer&lt; VoidSequence &gt;           d_selection9;
        bsls::ObjectBuffer&lt; UnsignedSequence &gt;       d_selection10;
        bsls::ObjectBuffer&lt; SequenceWithAnonymity &gt;  d_selection11;
    };

    int                                              d_selectionId;
    bslma::Allocator                                *d_allocator_p;

  public:
    // TYPES
    enum {
        e_SELECTION_ID_UNDEFINED   = -1

      , e_SELECTION_ID_SELECTION1  = 0
      , e_SELECTION_ID_SELECTION2  = 1
      , e_SELECTION_ID_SELECTION3  = 2
      , e_SELECTION_ID_SELECTION4  = 3
      , e_SELECTION_ID_SELECTION5  = 4
      , e_SELECTION_ID_SELECTION6  = 5
      , e_SELECTION_ID_SELECTION7  = 6
      , e_SELECTION_ID_SELECTION8  = 7
      , e_SELECTION_ID_SELECTION9  = 8
      , e_SELECTION_ID_SELECTION10 = 9
      , e_SELECTION_ID_SELECTION11 = 10
    };

    enum {
        k_NUM_SELECTIONS = 11
    };

    enum {
        e_SELECTION_INDEX_SELECTION1  = 0
      , e_SELECTION_INDEX_SELECTION2  = 1
      , e_SELECTION_INDEX_SELECTION3  = 2
      , e_SELECTION_INDEX_SELECTION4  = 3
      , e_SELECTION_INDEX_SELECTION5  = 4
      , e_SELECTION_INDEX_SELECTION6  = 5
      , e_SELECTION_INDEX_SELECTION7  = 6
      , e_SELECTION_INDEX_SELECTION8  = 7
      , e_SELECTION_INDEX_SELECTION9  = 8
      , e_SELECTION_INDEX_SELECTION10 = 9
      , e_SELECTION_INDEX_SELECTION11 = 10
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo *lookupSelectionInfo(int id);
        // Return selection information for the selection indicated by the
        // specified &#39;id&#39; if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo *lookupSelectionInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return selection information for the selection indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the selection
        // exists, and 0 otherwise.

    // CREATORS
    explicit FeatureTestMessage(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;FeatureTestMessage&#39; having the default
        // value.  Use the optionally specified &#39;basicAllocator&#39; to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.

    FeatureTestMessage(const FeatureTestMessage&amp;  original,
                       bslma::Allocator          *basicAllocator = 0);
        // Create an object of type &#39;FeatureTestMessage&#39; having the value of
        // the specified &#39;original&#39; object.  Use the optionally specified
        // &#39;basicAllocator&#39; to supply memory.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.

    ~FeatureTestMessage();
        // Destroy this object.

    // MANIPULATORS
    FeatureTestMessage&amp; operator=(const FeatureTestMessage&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon default
        // construction).

    int makeSelection(int selectionId);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;selectionId&#39;.  Return 0 on success, and
        // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char *name, int nameLength);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;name&#39; of the specified &#39;nameLength&#39;.
        // Return 0 on success, and non-zero value otherwise (i.e., the
        // selection is not found).

    Sequence1&amp; makeSelection1();
    Sequence1&amp; makeSelection1(const Sequence1&amp; value);
        // Set the value of this object to be a &quot;Selection1&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection1&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection1&quot; value is used.

    bsl::vector&lt;char&gt;&amp; makeSelection2();
    bsl::vector&lt;char&gt;&amp; makeSelection2(const bsl::vector&lt;char&gt;&amp; value);
        // Set the value of this object to be a &quot;Selection2&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection2&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection2&quot; value is used.

    Sequence2&amp; makeSelection3();
    Sequence2&amp; makeSelection3(const Sequence2&amp; value);
        // Set the value of this object to be a &quot;Selection3&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection3&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection3&quot; value is used.

    Sequence3&amp; makeSelection4();
    Sequence3&amp; makeSelection4(const Sequence3&amp; value);
        // Set the value of this object to be a &quot;Selection4&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection4&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection4&quot; value is used.

    bdlt::DatetimeTz&amp; makeSelection5();
    bdlt::DatetimeTz&amp; makeSelection5(const bdlt::DatetimeTz&amp; value);
        // Set the value of this object to be a &quot;Selection5&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection5&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection5&quot; value is used.

    CustomString&amp; makeSelection6();
    CustomString&amp; makeSelection6(const CustomString&amp; value);
        // Set the value of this object to be a &quot;Selection6&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection6&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection6&quot; value is used.

    Enumerated::Value&amp; makeSelection7();
    Enumerated::Value&amp; makeSelection7(Enumerated::Value value);
        // Set the value of this object to be a &quot;Selection7&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection7&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection7&quot; value is used.

    Choice3&amp; makeSelection8();
    Choice3&amp; makeSelection8(const Choice3&amp; value);
        // Set the value of this object to be a &quot;Selection8&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection8&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection8&quot; value is used.

    VoidSequence&amp; makeSelection9();
    VoidSequence&amp; makeSelection9(const VoidSequence&amp; value);
        // Set the value of this object to be a &quot;Selection9&quot; value.  Optionally
        // specify the &#39;value&#39; of the &quot;Selection9&quot;.  If &#39;value&#39; is not
        // specified, the default &quot;Selection9&quot; value is used.

    UnsignedSequence&amp; makeSelection10();
    UnsignedSequence&amp; makeSelection10(const UnsignedSequence&amp; value);
        // Set the value of this object to be a &quot;Selection10&quot; value.
        // Optionally specify the &#39;value&#39; of the &quot;Selection10&quot;.  If &#39;value&#39; is
        // not specified, the default &quot;Selection10&quot; value is used.

    SequenceWithAnonymity&amp; makeSelection11();
    SequenceWithAnonymity&amp; makeSelection11(const SequenceWithAnonymity&amp; value);
        // Set the value of this object to be a &quot;Selection11&quot; value.
        // Optionally specify the &#39;value&#39; of the &quot;Selection11&quot;.  If &#39;value&#39; is
        // not specified, the default &quot;Selection11&quot; value is used.

    template&lt;class MANIPULATOR&gt;
    int manipulateSelection(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; on the address of the modifiable
        // selection, supplying &#39;manipulator&#39; with the corresponding selection
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if this object has a defined selection,
        // and -1 otherwise.

    Sequence1&amp; selection1();
        // Return a reference to the modifiable &quot;Selection1&quot; selection of this
        // object if &quot;Selection1&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection1&quot; is the selection of this object.

    bsl::vector&lt;char&gt;&amp; selection2();
        // Return a reference to the modifiable &quot;Selection2&quot; selection of this
        // object if &quot;Selection2&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection2&quot; is the selection of this object.

    Sequence2&amp; selection3();
        // Return a reference to the modifiable &quot;Selection3&quot; selection of this
        // object if &quot;Selection3&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection3&quot; is the selection of this object.

    Sequence3&amp; selection4();
        // Return a reference to the modifiable &quot;Selection4&quot; selection of this
        // object if &quot;Selection4&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection4&quot; is the selection of this object.

    bdlt::DatetimeTz&amp; selection5();
        // Return a reference to the modifiable &quot;Selection5&quot; selection of this
        // object if &quot;Selection5&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection5&quot; is the selection of this object.

    CustomString&amp; selection6();
        // Return a reference to the modifiable &quot;Selection6&quot; selection of this
        // object if &quot;Selection6&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection6&quot; is the selection of this object.

    Enumerated::Value&amp; selection7();
        // Return a reference to the modifiable &quot;Selection7&quot; selection of this
        // object if &quot;Selection7&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection7&quot; is the selection of this object.

    Choice3&amp; selection8();
        // Return a reference to the modifiable &quot;Selection8&quot; selection of this
        // object if &quot;Selection8&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection8&quot; is the selection of this object.

    VoidSequence&amp; selection9();
        // Return a reference to the modifiable &quot;Selection9&quot; selection of this
        // object if &quot;Selection9&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection9&quot; is the selection of this object.

    UnsignedSequence&amp; selection10();
        // Return a reference to the modifiable &quot;Selection10&quot; selection of this
        // object if &quot;Selection10&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection10&quot; is the selection of this object.

    SequenceWithAnonymity&amp; selection11();
        // Return a reference to the modifiable &quot;Selection11&quot; selection of this
        // object if &quot;Selection11&quot; is the current selection.  The behavior is
        // undefined unless &quot;Selection11&quot; is the selection of this object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    int selectionId() const;
        // Return the id of the current selection if the selection is defined,
        // and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessSelection(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; on the non-modifiable selection,
        // supplying &#39;accessor&#39; with the corresponding selection information
        // structure.  Return the value returned from the invocation of
        // &#39;accessor&#39; if this object has a defined selection, and -1 otherwise.

    const Sequence1&amp; selection1() const;
        // Return a reference to the non-modifiable &quot;Selection1&quot; selection of
        // this object if &quot;Selection1&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection1&quot; is the selection of this object.

    const bsl::vector&lt;char&gt;&amp; selection2() const;
        // Return a reference to the non-modifiable &quot;Selection2&quot; selection of
        // this object if &quot;Selection2&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection2&quot; is the selection of this object.

    const Sequence2&amp; selection3() const;
        // Return a reference to the non-modifiable &quot;Selection3&quot; selection of
        // this object if &quot;Selection3&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection3&quot; is the selection of this object.

    const Sequence3&amp; selection4() const;
        // Return a reference to the non-modifiable &quot;Selection4&quot; selection of
        // this object if &quot;Selection4&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection4&quot; is the selection of this object.

    const bdlt::DatetimeTz&amp; selection5() const;
        // Return a reference to the non-modifiable &quot;Selection5&quot; selection of
        // this object if &quot;Selection5&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection5&quot; is the selection of this object.

    const CustomString&amp; selection6() const;
        // Return a reference to the non-modifiable &quot;Selection6&quot; selection of
        // this object if &quot;Selection6&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection6&quot; is the selection of this object.

    const Enumerated::Value&amp; selection7() const;
        // Return a reference to the non-modifiable &quot;Selection7&quot; selection of
        // this object if &quot;Selection7&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection7&quot; is the selection of this object.

    const Choice3&amp; selection8() const;
        // Return a reference to the non-modifiable &quot;Selection8&quot; selection of
        // this object if &quot;Selection8&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection8&quot; is the selection of this object.

    const VoidSequence&amp; selection9() const;
        // Return a reference to the non-modifiable &quot;Selection9&quot; selection of
        // this object if &quot;Selection9&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection9&quot; is the selection of this object.

    const UnsignedSequence&amp; selection10() const;
        // Return a reference to the non-modifiable &quot;Selection10&quot; selection of
        // this object if &quot;Selection10&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection10&quot; is the selection of this object.

    const SequenceWithAnonymity&amp; selection11() const;
        // Return a reference to the non-modifiable &quot;Selection11&quot; selection of
        // this object if &quot;Selection11&quot; is the current selection.  The behavior
        // is undefined unless &quot;Selection11&quot; is the selection of this object.

    bool isSelection1Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection1&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection2Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection2&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection3Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection3&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection4Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection4&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection5Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection5&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection6Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection6&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection7Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection7&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection8Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection8&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection9Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection9&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection10Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection10&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isSelection11Value() const;
        // Return &#39;true&#39; if the value of this object is a &quot;Selection11&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isUndefinedValue() const;
        // Return &#39;true&#39; if the value of this object is undefined, and &#39;false&#39;
        // otherwise.

    const char *selectionName() const;
        // Return the symbolic name of the current selection of this object.
};

// FREE OPERATORS
inline
bool operator==(const FeatureTestMessage&amp; lhs, const FeatureTestMessage&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;FeatureTestMessage&#39; objects have the same
    // value if either the selections in both objects have the same ids and
    // the same values, or both selections are undefined.

inline
bool operator!=(const FeatureTestMessage&amp; lhs, const FeatureTestMessage&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same values, as determined by &#39;operator==&#39;, and &#39;false&#39; otherwise.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const FeatureTestMessage&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::FeatureTestMessage)

namespace balb {

                               // =============
                               // class Request
                               // =============

class Request {

    // INSTANCE DATA
    union {
        bsls::ObjectBuffer&lt; SimpleRequest &gt;      d_simpleRequest;
        bsls::ObjectBuffer&lt; FeatureTestMessage &gt; d_featureRequest;
    };

    int                                          d_selectionId;
    bslma::Allocator                            *d_allocator_p;

  public:
    // TYPES
    enum {
        e_SELECTION_ID_UNDEFINED       = -1

      , e_SELECTION_ID_SIMPLE_REQUEST  = 0
      , e_SELECTION_ID_FEATURE_REQUEST = 1
    };

    enum {
        k_NUM_SELECTIONS = 2
    };

    enum {
        e_SELECTION_INDEX_SIMPLE_REQUEST  = 0
      , e_SELECTION_INDEX_FEATURE_REQUEST = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo *lookupSelectionInfo(int id);
        // Return selection information for the selection indicated by the
        // specified &#39;id&#39; if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo *lookupSelectionInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return selection information for the selection indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the selection
        // exists, and 0 otherwise.

    // CREATORS
    explicit Request(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Request&#39; having the default value.  Use
        // the optionally specified &#39;basicAllocator&#39; to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    Request(const Request&amp;    original,
            bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Request&#39; having the value of the specified
        // &#39;original&#39; object.  Use the optionally specified &#39;basicAllocator&#39; to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    ~Request();
        // Destroy this object.

    // MANIPULATORS
    Request&amp; operator=(const Request&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon default
        // construction).

    int makeSelection(int selectionId);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;selectionId&#39;.  Return 0 on success, and
        // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char *name, int nameLength);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;name&#39; of the specified &#39;nameLength&#39;.
        // Return 0 on success, and non-zero value otherwise (i.e., the
        // selection is not found).

    SimpleRequest&amp; makeSimpleRequest();
    SimpleRequest&amp; makeSimpleRequest(const SimpleRequest&amp; value);
        // Set the value of this object to be a &quot;SimpleRequest&quot; value.
        // Optionally specify the &#39;value&#39; of the &quot;SimpleRequest&quot;.  If &#39;value&#39;
        // is not specified, the default &quot;SimpleRequest&quot; value is used.

    FeatureTestMessage&amp; makeFeatureRequest();
    FeatureTestMessage&amp; makeFeatureRequest(const FeatureTestMessage&amp; value);
        // Set the value of this object to be a &quot;FeatureRequest&quot; value.
        // Optionally specify the &#39;value&#39; of the &quot;FeatureRequest&quot;.  If &#39;value&#39;
        // is not specified, the default &quot;FeatureRequest&quot; value is used.

    template&lt;class MANIPULATOR&gt;
    int manipulateSelection(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; on the address of the modifiable
        // selection, supplying &#39;manipulator&#39; with the corresponding selection
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if this object has a defined selection,
        // and -1 otherwise.

    SimpleRequest&amp; simpleRequest();
        // Return a reference to the modifiable &quot;SimpleRequest&quot; selection of
        // this object if &quot;SimpleRequest&quot; is the current selection.  The
        // behavior is undefined unless &quot;SimpleRequest&quot; is the selection of
        // this object.

    FeatureTestMessage&amp; featureRequest();
        // Return a reference to the modifiable &quot;FeatureRequest&quot; selection of
        // this object if &quot;FeatureRequest&quot; is the current selection.  The
        // behavior is undefined unless &quot;FeatureRequest&quot; is the selection of
        // this object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    int selectionId() const;
        // Return the id of the current selection if the selection is defined,
        // and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessSelection(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; on the non-modifiable selection,
        // supplying &#39;accessor&#39; with the corresponding selection information
        // structure.  Return the value returned from the invocation of
        // &#39;accessor&#39; if this object has a defined selection, and -1 otherwise.

    const SimpleRequest&amp; simpleRequest() const;
        // Return a reference to the non-modifiable &quot;SimpleRequest&quot; selection
        // of this object if &quot;SimpleRequest&quot; is the current selection.  The
        // behavior is undefined unless &quot;SimpleRequest&quot; is the selection of
        // this object.

    const FeatureTestMessage&amp; featureRequest() const;
        // Return a reference to the non-modifiable &quot;FeatureRequest&quot; selection
        // of this object if &quot;FeatureRequest&quot; is the current selection.  The
        // behavior is undefined unless &quot;FeatureRequest&quot; is the selection of
        // this object.

    bool isSimpleRequestValue() const;
        // Return &#39;true&#39; if the value of this object is a &quot;SimpleRequest&quot;
        // value, and return &#39;false&#39; otherwise.

    bool isFeatureRequestValue() const;
        // Return &#39;true&#39; if the value of this object is a &quot;FeatureRequest&quot;
        // value, and return &#39;false&#39; otherwise.

    bool isUndefinedValue() const;
        // Return &#39;true&#39; if the value of this object is undefined, and &#39;false&#39;
        // otherwise.

    const char *selectionName() const;
        // Return the symbolic name of the current selection of this object.
};

// FREE OPERATORS
inline
bool operator==(const Request&amp; lhs, const Request&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;Request&#39; objects have the same
    // value if either the selections in both objects have the same ids and
    // the same values, or both selections are undefined.

inline
bool operator!=(const Request&amp; lhs, const Request&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same values, as determined by &#39;operator==&#39;, and &#39;false&#39; otherwise.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Request&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::Request)

namespace balb {

                               // ==============
                               // class Response
                               // ==============

class Response {

    // INSTANCE DATA
    union {
        bsls::ObjectBuffer&lt; bsl::string &gt;        d_responseData;
        bsls::ObjectBuffer&lt; FeatureTestMessage &gt; d_featureResponse;
    };

    int                                          d_selectionId;
    bslma::Allocator                            *d_allocator_p;

  public:
    // TYPES
    enum {
        e_SELECTION_ID_UNDEFINED        = -1

      , e_SELECTION_ID_RESPONSE_DATA    = 0
      , e_SELECTION_ID_FEATURE_RESPONSE = 1
    };

    enum {
        k_NUM_SELECTIONS = 2
    };

    enum {
        e_SELECTION_INDEX_RESPONSE_DATA    = 0
      , e_SELECTION_INDEX_FEATURE_RESPONSE = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo *lookupSelectionInfo(int id);
        // Return selection information for the selection indicated by the
        // specified &#39;id&#39; if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo *lookupSelectionInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return selection information for the selection indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the selection
        // exists, and 0 otherwise.

    // CREATORS
    explicit Response(bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Response&#39; having the default value.  Use
        // the optionally specified &#39;basicAllocator&#39; to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    Response(const Response&amp;   original,
             bslma::Allocator *basicAllocator = 0);
        // Create an object of type &#39;Response&#39; having the value of the
        // specified &#39;original&#39; object.  Use the optionally specified
        // &#39;basicAllocator&#39; to supply memory.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.

    ~Response();
        // Destroy this object.

    // MANIPULATORS
    Response&amp; operator=(const Response&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    void reset();
        // Reset this object to the default value (i.e., its value upon default
        // construction).

    int makeSelection(int selectionId);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;selectionId&#39;.  Return 0 on success, and
        // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char *name, int nameLength);
        // Set the value of this object to be the default for the selection
        // indicated by the specified &#39;name&#39; of the specified &#39;nameLength&#39;.
        // Return 0 on success, and non-zero value otherwise (i.e., the
        // selection is not found).

    bsl::string&amp; makeResponseData();
    bsl::string&amp; makeResponseData(const bsl::string&amp; value);
        // Set the value of this object to be a &quot;ResponseData&quot; value.
        // Optionally specify the &#39;value&#39; of the &quot;ResponseData&quot;.  If &#39;value&#39; is
        // not specified, the default &quot;ResponseData&quot; value is used.

    FeatureTestMessage&amp; makeFeatureResponse();
    FeatureTestMessage&amp; makeFeatureResponse(const FeatureTestMessage&amp; value);
        // Set the value of this object to be a &quot;FeatureResponse&quot; value.
        // Optionally specify the &#39;value&#39; of the &quot;FeatureResponse&quot;.  If &#39;value&#39;
        // is not specified, the default &quot;FeatureResponse&quot; value is used.

    template&lt;class MANIPULATOR&gt;
    int manipulateSelection(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; on the address of the modifiable
        // selection, supplying &#39;manipulator&#39; with the corresponding selection
        // information structure.  Return the value returned from the
        // invocation of &#39;manipulator&#39; if this object has a defined selection,
        // and -1 otherwise.

    bsl::string&amp; responseData();
        // Return a reference to the modifiable &quot;ResponseData&quot; selection of
        // this object if &quot;ResponseData&quot; is the current selection.  The
        // behavior is undefined unless &quot;ResponseData&quot; is the selection of this
        // object.

    FeatureTestMessage&amp; featureResponse();
        // Return a reference to the modifiable &quot;FeatureResponse&quot; selection of
        // this object if &quot;FeatureResponse&quot; is the current selection.  The
        // behavior is undefined unless &quot;FeatureResponse&quot; is the selection of
        // this object.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    int selectionId() const;
        // Return the id of the current selection if the selection is defined,
        // and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessSelection(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; on the non-modifiable selection,
        // supplying &#39;accessor&#39; with the corresponding selection information
        // structure.  Return the value returned from the invocation of
        // &#39;accessor&#39; if this object has a defined selection, and -1 otherwise.

    const bsl::string&amp; responseData() const;
        // Return a reference to the non-modifiable &quot;ResponseData&quot; selection of
        // this object if &quot;ResponseData&quot; is the current selection.  The
        // behavior is undefined unless &quot;ResponseData&quot; is the selection of this
        // object.

    const FeatureTestMessage&amp; featureResponse() const;
        // Return a reference to the non-modifiable &quot;FeatureResponse&quot; selection
        // of this object if &quot;FeatureResponse&quot; is the current selection.  The
        // behavior is undefined unless &quot;FeatureResponse&quot; is the selection of
        // this object.

    bool isResponseDataValue() const;
        // Return &#39;true&#39; if the value of this object is a &quot;ResponseData&quot; value,
        // and return &#39;false&#39; otherwise.

    bool isFeatureResponseValue() const;
        // Return &#39;true&#39; if the value of this object is a &quot;FeatureResponse&quot;
        // value, and return &#39;false&#39; otherwise.

    bool isUndefinedValue() const;
        // Return &#39;true&#39; if the value of this object is undefined, and &#39;false&#39;
        // otherwise.

    const char *selectionName() const;
        // Return the symbolic name of the current selection of this object.
};

// FREE OPERATORS
inline
bool operator==(const Response&amp; lhs, const Response&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;Response&#39; objects have the same
    // value if either the selections in both objects have the same ids and
    // the same values, or both selections are undefined.

inline
bool operator!=(const Response&amp; lhs, const Response&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same values, as determined by &#39;operator==&#39;, and &#39;false&#39; otherwise.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Response&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(balb::Response)

namespace balb {

                             // ==================
                             // class Testmessages
                             // ==================

struct Testmessages {
    // This class serves as a place holder to reserve a type having the same
    // name as this component.  Doing so ensures that such a type cannot be
    // defined outside of this component in the current namespace.
};

}  // close package namespace

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

namespace balb {

                              // ---------------
                              // class CustomInt
                              // ---------------

// CREATORS
inline
CustomInt::CustomInt()
: d_value()
{
}

inline
CustomInt::CustomInt(const CustomInt&amp; original)
: d_value(original.d_value)
{
}

inline
CustomInt::CustomInt(const int&amp; value)
: d_value(value)
{
    BSLS_ASSERT(checkRestrictions(value) == 0);
}

inline
CustomInt::~CustomInt()
{
}

// MANIPULATORS
inline
CustomInt&amp; CustomInt::operator=(const CustomInt&amp; rhs)
{
    d_value = rhs.d_value;
    return *this;
}

inline
void CustomInt::reset()
{
    bdlat_ValueTypeFunctions::reset(&amp;d_value);
}

inline
int CustomInt::fromInt(const int&amp; value)
{
    int ret = checkRestrictions(value);
    if (0 == ret) {
        d_value = value;
    }

    return ret;
}

// ACCESSORS
inline
bsl::ostream&amp; CustomInt::print(bsl::ostream&amp; stream,
                               int           level,
                               int           spacesPerLevel) const
{
    return bdlb::PrintMethods::print(stream, d_value, level, spacesPerLevel);
}

inline
const int&amp; CustomInt::toInt() const
{
    return d_value;
}



                             // ------------------
                             // class CustomString
                             // ------------------

// CREATORS
inline
CustomString::CustomString(bslma::Allocator *basicAllocator)
: d_value(basicAllocator)
{
}

inline
CustomString::CustomString(const CustomString&amp;  original,
                           bslma::Allocator    *basicAllocator)
: d_value(original.d_value, basicAllocator)
{
}

inline
CustomString::CustomString(const bsl::string&amp;  value,
                           bslma::Allocator   *basicAllocator)
: d_value(value, basicAllocator)
{
    BSLS_ASSERT(checkRestrictions(value) == 0);
}

inline
CustomString::~CustomString()
{
}

// MANIPULATORS
inline
CustomString&amp; CustomString::operator=(const CustomString&amp; rhs)
{
    d_value = rhs.d_value;
    return *this;
}

inline
void CustomString::reset()
{
    bdlat_ValueTypeFunctions::reset(&amp;d_value);
}

inline
int CustomString::fromString(const bsl::string&amp; value)
{
    int ret = checkRestrictions(value);
    if (0 == ret) {
        d_value = value;
    }

    return ret;
}

// ACCESSORS
inline
bsl::ostream&amp; CustomString::print(bsl::ostream&amp; stream,
                                 int           level,
                                 int           spacesPerLevel) const
{
    return bdlb::PrintMethods::print(stream, d_value, level, spacesPerLevel);
}

inline
const bsl::string&amp; CustomString::toString() const
{
    return d_value;
}



                              // ----------------
                              // class Enumerated
                              // ----------------

// CLASS METHODS
inline
int Enumerated::fromString(Value *result, const bsl::string&amp; string)
{
    return fromString(result, string.c_str(), string.length());
}

inline
bsl::ostream&amp; Enumerated::print(bsl::ostream&amp;      stream,
                                 Enumerated::Value value)
{
    return stream &lt;&lt; toString(value);
}



                     // ----------------------------------
                     // class SequenceWithAnonymityChoice1
                     // ----------------------------------

// CREATORS
inline
SequenceWithAnonymityChoice1::SequenceWithAnonymityChoice1(bslma::Allocator *basicAllocator)
: d_selectionId(e_SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline
SequenceWithAnonymityChoice1::~SequenceWithAnonymityChoice1()
{
    reset();
}

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int SequenceWithAnonymityChoice1::manipulateSelection(MANIPULATOR&amp; manipulator)
{
    switch (d_selectionId) {
      case SequenceWithAnonymityChoice1::e_SELECTION_ID_SELECTION5:
        return manipulator(&amp;d_selection5.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION5]);
      case SequenceWithAnonymityChoice1::e_SELECTION_ID_SELECTION6:
        return manipulator(&amp;d_selection6.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION6]);
      default:
        BSLS_ASSERT(SequenceWithAnonymityChoice1::e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
bool&amp; SequenceWithAnonymityChoice1::selection5()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION5 == d_selectionId);
    return d_selection5.object();
}

inline
bsl::string&amp; SequenceWithAnonymityChoice1::selection6()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION6 == d_selectionId);
    return d_selection6.object();
}

// ACCESSORS
inline
int SequenceWithAnonymityChoice1::selectionId() const
{
    return d_selectionId;
}

template &lt;class ACCESSOR&gt;
int SequenceWithAnonymityChoice1::accessSelection(ACCESSOR&amp; accessor) const
{
    switch (d_selectionId) {
      case e_SELECTION_ID_SELECTION5:
        return accessor(d_selection5.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION5]);
      case e_SELECTION_ID_SELECTION6:
        return accessor(d_selection6.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION6]);
      default:
        BSLS_ASSERT(e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
const bool&amp; SequenceWithAnonymityChoice1::selection5() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION5 == d_selectionId);
    return d_selection5.object();
}

inline
const bsl::string&amp; SequenceWithAnonymityChoice1::selection6() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION6 == d_selectionId);
    return d_selection6.object();
}

inline
bool SequenceWithAnonymityChoice1::isSelection5Value() const
{
    return e_SELECTION_ID_SELECTION5 == d_selectionId;
}

inline
bool SequenceWithAnonymityChoice1::isSelection6Value() const
{
    return e_SELECTION_ID_SELECTION6 == d_selectionId;
}

inline
bool SequenceWithAnonymityChoice1::isUndefinedValue() const
{
    return e_SELECTION_ID_UNDEFINED == d_selectionId;
}


                            // -------------------
                            // class SimpleRequest
                            // -------------------

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int SimpleRequest::manipulateAttributes(MANIPULATOR&amp; manipulator)
{
    int ret;

    ret = manipulator(&amp;d_data, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_DATA]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_responseLength, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_RESPONSE_LENGTH]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class MANIPULATOR&gt;
int SimpleRequest::manipulateAttribute(MANIPULATOR&amp; manipulator, int id)
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_DATA: {
        return manipulator(&amp;d_data, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_DATA]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_RESPONSE_LENGTH: {
        return manipulator(&amp;d_responseLength, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_RESPONSE_LENGTH]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class MANIPULATOR&gt;
int SimpleRequest::manipulateAttribute(
        MANIPULATOR&amp;  manipulator,
        const char   *name,
        int           nameLength)
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
           lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
        return k_NOT_FOUND;                                           // RETURN
    }

    return manipulateAttribute(manipulator, attributeInfo-&gt;d_id);
}

inline
bsl::string&amp; SimpleRequest::data()
{
    return d_data;
}

inline
int&amp; SimpleRequest::responseLength()
{
    return d_responseLength;
}

// ACCESSORS
template &lt;class ACCESSOR&gt;
int SimpleRequest::accessAttributes(ACCESSOR&amp; accessor) const
{
    int ret;

    ret = accessor(d_data, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_DATA]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_responseLength, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_RESPONSE_LENGTH]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class ACCESSOR&gt;
int SimpleRequest::accessAttribute(ACCESSOR&amp; accessor, int id) const
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_DATA: {
        return accessor(d_data, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_DATA]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_RESPONSE_LENGTH: {
        return accessor(d_responseLength, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_RESPONSE_LENGTH]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class ACCESSOR&gt;
int SimpleRequest::accessAttribute(
        ACCESSOR&amp;   accessor,
        const char *name,
        int         nameLength) const
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
          lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
       return k_NOT_FOUND;                                            // RETURN
    }

    return accessAttribute(accessor, attributeInfo-&gt;d_id);
}

inline
const bsl::string&amp; SimpleRequest::data() const
{
    return d_data;
}

inline
int SimpleRequest::responseLength() const
{
    return d_responseLength;
}



                           // ----------------------
                           // class UnsignedSequence
                           // ----------------------

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int UnsignedSequence::manipulateAttributes(MANIPULATOR&amp; manipulator)
{
    int ret;

    ret = manipulator(&amp;d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class MANIPULATOR&gt;
int UnsignedSequence::manipulateAttribute(MANIPULATOR&amp; manipulator, int id)
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_ELEMENT1: {
        return manipulator(&amp;d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT2: {
        return manipulator(&amp;d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT3: {
        return manipulator(&amp;d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class MANIPULATOR&gt;
int UnsignedSequence::manipulateAttribute(
        MANIPULATOR&amp;  manipulator,
        const char   *name,
        int           nameLength)
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
           lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
        return k_NOT_FOUND;                                           // RETURN
    }

    return manipulateAttribute(manipulator, attributeInfo-&gt;d_id);
}

inline
unsigned int&amp; UnsignedSequence::element1()
{
    return d_element1;
}

inline
unsigned short&amp; UnsignedSequence::element2()
{
    return d_element2;
}

inline
bsls::Types::Uint64&amp; UnsignedSequence::element3()
{
    return d_element3;
}

// ACCESSORS
template &lt;class ACCESSOR&gt;
int UnsignedSequence::accessAttributes(ACCESSOR&amp; accessor) const
{
    int ret;

    ret = accessor(d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class ACCESSOR&gt;
int UnsignedSequence::accessAttribute(ACCESSOR&amp; accessor, int id) const
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_ELEMENT1: {
        return accessor(d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT2: {
        return accessor(d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT3: {
        return accessor(d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class ACCESSOR&gt;
int UnsignedSequence::accessAttribute(
        ACCESSOR&amp;   accessor,
        const char *name,
        int         nameLength) const
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
          lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
       return k_NOT_FOUND;                                            // RETURN
    }

    return accessAttribute(accessor, attributeInfo-&gt;d_id);
}

inline
unsigned int UnsignedSequence::element1() const
{
    return d_element1;
}

inline
unsigned short UnsignedSequence::element2() const
{
    return d_element2;
}

inline
bsls::Types::Uint64 UnsignedSequence::element3() const
{
    return d_element3;
}



                             // ------------------
                             // class VoidSequence
                             // ------------------

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int VoidSequence::manipulateAttributes(MANIPULATOR&amp; /*manipulator*/)
{
    int ret = 0;

    return ret;
}

template &lt;class MANIPULATOR&gt;
int VoidSequence::manipulateAttribute(MANIPULATOR&amp; /*manipulator*/, int id)
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      default:
        return k_NOT_FOUND;
    }
}

template &lt;class MANIPULATOR&gt;
int VoidSequence::manipulateAttribute(
        MANIPULATOR&amp;  manipulator,
        const char   *name,
        int           nameLength)
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
           lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
        return k_NOT_FOUND;                                           // RETURN
    }

    return manipulateAttribute(manipulator, attributeInfo-&gt;d_id);
}

// ACCESSORS
template &lt;class ACCESSOR&gt;
int VoidSequence::accessAttributes(ACCESSOR&amp; /*accessor*/) const
{
    int ret = 0;

    return ret;
}

template &lt;class ACCESSOR&gt;
int VoidSequence::accessAttribute(ACCESSOR&amp; /*accessor*/, int id) const
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      default:
        return k_NOT_FOUND;
    }
}

template &lt;class ACCESSOR&gt;
int VoidSequence::accessAttribute(
        ACCESSOR&amp;   accessor,
        const char *name,
        int         nameLength) const
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
          lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
       return k_NOT_FOUND;                                            // RETURN
    }

    return accessAttribute(accessor, attributeInfo-&gt;d_id);
}



                              // ---------------
                              // class Sequence3
                              // ---------------

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int Sequence3::manipulateAttributes(MANIPULATOR&amp; manipulator)
{
    int ret;

    ret = manipulator(&amp;d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class MANIPULATOR&gt;
int Sequence3::manipulateAttribute(MANIPULATOR&amp; manipulator, int id)
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_ELEMENT1: {
        return manipulator(&amp;d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT2: {
        return manipulator(&amp;d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT3: {
        return manipulator(&amp;d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT4: {
        return manipulator(&amp;d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT5: {
        return manipulator(&amp;d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT6: {
        return manipulator(&amp;d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class MANIPULATOR&gt;
int Sequence3::manipulateAttribute(
        MANIPULATOR&amp;  manipulator,
        const char   *name,
        int           nameLength)
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
           lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
        return k_NOT_FOUND;                                           // RETURN
    }

    return manipulateAttribute(manipulator, attributeInfo-&gt;d_id);
}

inline
bsl::vector&lt;Enumerated::Value&gt;&amp; Sequence3::element1()
{
    return d_element1;
}

inline
bsl::vector&lt;bsl::string&gt;&amp; Sequence3::element2()
{
    return d_element2;
}

inline
bdlb::NullableValue&lt;bool&gt;&amp; Sequence3::element3()
{
    return d_element3;
}

inline
bdlb::NullableValue&lt;bsl::string&gt;&amp; Sequence3::element4()
{
    return d_element4;
}

inline
bdlb::NullableAllocatedValue&lt;Sequence5&gt;&amp; Sequence3::element5()
{
    return d_element5;
}

inline
bsl::vector&lt;bdlb::NullableValue&lt;Enumerated::Value&gt; &gt;&amp; Sequence3::element6()
{
    return d_element6;
}

// ACCESSORS
template &lt;class ACCESSOR&gt;
int Sequence3::accessAttributes(ACCESSOR&amp; accessor) const
{
    int ret;

    ret = accessor(d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class ACCESSOR&gt;
int Sequence3::accessAttribute(ACCESSOR&amp; accessor, int id) const
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_ELEMENT1: {
        return accessor(d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT2: {
        return accessor(d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT3: {
        return accessor(d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT4: {
        return accessor(d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT5: {
        return accessor(d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT6: {
        return accessor(d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class ACCESSOR&gt;
int Sequence3::accessAttribute(
        ACCESSOR&amp;   accessor,
        const char *name,
        int         nameLength) const
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
          lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
       return k_NOT_FOUND;                                            // RETURN
    }

    return accessAttribute(accessor, attributeInfo-&gt;d_id);
}

inline
const bsl::vector&lt;Enumerated::Value&gt;&amp; Sequence3::element1() const
{
    return d_element1;
}

inline
const bsl::vector&lt;bsl::string&gt;&amp; Sequence3::element2() const
{
    return d_element2;
}

inline
const bdlb::NullableValue&lt;bool&gt;&amp; Sequence3::element3() const
{
    return d_element3;
}

inline
const bdlb::NullableValue&lt;bsl::string&gt;&amp; Sequence3::element4() const
{
    return d_element4;
}

inline
const bdlb::NullableAllocatedValue&lt;Sequence5&gt;&amp; Sequence3::element5() const
{
    return d_element5;
}

inline
const bsl::vector&lt;bdlb::NullableValue&lt;Enumerated::Value&gt; &gt;&amp; Sequence3::element6() const
{
    return d_element6;
}



                              // ---------------
                              // class Sequence5
                              // ---------------

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int Sequence5::manipulateAttributes(MANIPULATOR&amp; manipulator)
{
    int ret;

    ret = manipulator(d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element7, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT7]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class MANIPULATOR&gt;
int Sequence5::manipulateAttribute(MANIPULATOR&amp; manipulator, int id)
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_ELEMENT1: {
        return manipulator(d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT2: {
        return manipulator(&amp;d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT3: {
        return manipulator(&amp;d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT4: {
        return manipulator(&amp;d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT5: {
        return manipulator(&amp;d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT6: {
        return manipulator(&amp;d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT7: {
        return manipulator(&amp;d_element7, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT7]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class MANIPULATOR&gt;
int Sequence5::manipulateAttribute(
        MANIPULATOR&amp;  manipulator,
        const char   *name,
        int           nameLength)
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
           lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
        return k_NOT_FOUND;                                           // RETURN
    }

    return manipulateAttribute(manipulator, attributeInfo-&gt;d_id);
}

inline
Sequence3&amp; Sequence5::element1()
{
    return *d_element1;
}

inline
bsl::vector&lt;bdlb::NullableValue&lt;bool&gt; &gt;&amp; Sequence5::element2()
{
    return d_element2;
}

inline
bsl::vector&lt;bdlb::NullableValue&lt;double&gt; &gt;&amp; Sequence5::element3()
{
    return d_element3;
}

inline
bsl::vector&lt;bdlb::NullableValue&lt;bsl::vector&lt;char&gt; &gt; &gt;&amp; Sequence5::element4()
{
    return d_element4;
}

inline
bsl::vector&lt;bdlb::NullableValue&lt;int&gt; &gt;&amp; Sequence5::element5()
{
    return d_element5;
}

inline
bsl::vector&lt;bdlb::NullableValue&lt;bdlt::DatetimeTz&gt; &gt;&amp; Sequence5::element6()
{
    return d_element6;
}

inline
bsl::vector&lt;bdlb::NullableAllocatedValue&lt;Sequence3&gt; &gt;&amp; Sequence5::element7()
{
    return d_element7;
}

// ACCESSORS
template &lt;class ACCESSOR&gt;
int Sequence5::accessAttributes(ACCESSOR&amp; accessor) const
{
    int ret;

    ret = accessor(*d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element7, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT7]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class ACCESSOR&gt;
int Sequence5::accessAttribute(ACCESSOR&amp; accessor, int id) const
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_ELEMENT1: {
        return accessor(*d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT2: {
        return accessor(d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT3: {
        return accessor(d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT4: {
        return accessor(d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT5: {
        return accessor(d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT6: {
        return accessor(d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT7: {
        return accessor(d_element7, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT7]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class ACCESSOR&gt;
int Sequence5::accessAttribute(
        ACCESSOR&amp;   accessor,
        const char *name,
        int         nameLength) const
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
          lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
       return k_NOT_FOUND;                                            // RETURN
    }

    return accessAttribute(accessor, attributeInfo-&gt;d_id);
}

inline
const Sequence3&amp; Sequence5::element1() const
{
    return *d_element1;
}

inline
const bsl::vector&lt;bdlb::NullableValue&lt;bool&gt; &gt;&amp; Sequence5::element2() const
{
    return d_element2;
}

inline
const bsl::vector&lt;bdlb::NullableValue&lt;double&gt; &gt;&amp; Sequence5::element3() const
{
    return d_element3;
}

inline
const bsl::vector&lt;bdlb::NullableValue&lt;bsl::vector&lt;char&gt; &gt; &gt;&amp; Sequence5::element4() const
{
    return d_element4;
}

inline
const bsl::vector&lt;bdlb::NullableValue&lt;int&gt; &gt;&amp; Sequence5::element5() const
{
    return d_element5;
}

inline
const bsl::vector&lt;bdlb::NullableValue&lt;bdlt::DatetimeTz&gt; &gt;&amp; Sequence5::element6() const
{
    return d_element6;
}

inline
const bsl::vector&lt;bdlb::NullableAllocatedValue&lt;Sequence3&gt; &gt;&amp; Sequence5::element7() const
{
    return d_element7;
}



                              // ---------------
                              // class Sequence6
                              // ---------------

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int Sequence6::manipulateAttributes(MANIPULATOR&amp; manipulator)
{
    int ret;

    ret = manipulator(&amp;d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element7, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT7]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element8, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT8]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element9, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT9]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element10, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT10]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element11, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT11]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element12, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT12]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element13, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT13]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element14, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT14]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element15, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT15]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class MANIPULATOR&gt;
int Sequence6::manipulateAttribute(MANIPULATOR&amp; manipulator, int id)
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_ELEMENT1: {
        return manipulator(&amp;d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT2: {
        return manipulator(&amp;d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT3: {
        return manipulator(&amp;d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT4: {
        return manipulator(&amp;d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT5: {
        return manipulator(&amp;d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT6: {
        return manipulator(&amp;d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT7: {
        return manipulator(&amp;d_element7, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT7]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT8: {
        return manipulator(&amp;d_element8, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT8]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT9: {
        return manipulator(&amp;d_element9, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT9]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT10: {
        return manipulator(&amp;d_element10, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT10]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT11: {
        return manipulator(&amp;d_element11, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT11]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT12: {
        return manipulator(&amp;d_element12, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT12]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT13: {
        return manipulator(&amp;d_element13, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT13]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT14: {
        return manipulator(&amp;d_element14, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT14]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT15: {
        return manipulator(&amp;d_element15, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT15]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class MANIPULATOR&gt;
int Sequence6::manipulateAttribute(
        MANIPULATOR&amp;  manipulator,
        const char   *name,
        int           nameLength)
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
           lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
        return k_NOT_FOUND;                                           // RETURN
    }

    return manipulateAttribute(manipulator, attributeInfo-&gt;d_id);
}

inline
bdlb::NullableValue&lt;unsigned char&gt;&amp; Sequence6::element1()
{
    return d_element1;
}

inline
bdlb::NullableValue&lt;CustomString&gt;&amp; Sequence6::element2()
{
    return d_element2;
}

inline
bdlb::NullableValue&lt;CustomInt&gt;&amp; Sequence6::element3()
{
    return d_element3;
}

inline
unsigned int&amp; Sequence6::element4()
{
    return d_element4;
}

inline
unsigned char&amp; Sequence6::element5()
{
    return d_element5;
}

inline
bsl::vector&lt;bdlb::NullableValue&lt;CustomInt&gt; &gt;&amp; Sequence6::element6()
{
    return d_element6;
}

inline
CustomString&amp; Sequence6::element7()
{
    return d_element7;
}

inline
CustomInt&amp; Sequence6::element8()
{
    return d_element8;
}

inline
bdlb::NullableValue&lt;unsigned int&gt;&amp; Sequence6::element9()
{
    return d_element9;
}

inline
bsl::vector&lt;unsigned char&gt;&amp; Sequence6::element10()
{
    return d_element10;
}

inline
bsl::vector&lt;CustomString&gt;&amp; Sequence6::element11()
{
    return d_element11;
}

inline
bsl::vector&lt;unsigned int&gt;&amp; Sequence6::element12()
{
    return d_element12;
}

inline
bsl::vector&lt;bdlb::NullableValue&lt;unsigned char&gt; &gt;&amp; Sequence6::element13()
{
    return d_element13;
}

inline
bsl::vector&lt;CustomInt&gt;&amp; Sequence6::element14()
{
    return d_element14;
}

inline
bsl::vector&lt;bdlb::NullableValue&lt;unsigned int&gt; &gt;&amp; Sequence6::element15()
{
    return d_element15;
}

// ACCESSORS
template &lt;class ACCESSOR&gt;
int Sequence6::accessAttributes(ACCESSOR&amp; accessor) const
{
    int ret;

    ret = accessor(d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element7, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT7]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element8, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT8]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element9, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT9]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element10, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT10]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element11, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT11]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element12, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT12]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element13, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT13]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element14, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT14]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element15, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT15]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class ACCESSOR&gt;
int Sequence6::accessAttribute(ACCESSOR&amp; accessor, int id) const
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_ELEMENT1: {
        return accessor(d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT2: {
        return accessor(d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT3: {
        return accessor(d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT4: {
        return accessor(d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT5: {
        return accessor(d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT6: {
        return accessor(d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT7: {
        return accessor(d_element7, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT7]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT8: {
        return accessor(d_element8, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT8]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT9: {
        return accessor(d_element9, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT9]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT10: {
        return accessor(d_element10, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT10]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT11: {
        return accessor(d_element11, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT11]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT12: {
        return accessor(d_element12, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT12]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT13: {
        return accessor(d_element13, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT13]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT14: {
        return accessor(d_element14, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT14]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT15: {
        return accessor(d_element15, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT15]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class ACCESSOR&gt;
int Sequence6::accessAttribute(
        ACCESSOR&amp;   accessor,
        const char *name,
        int         nameLength) const
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
          lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
       return k_NOT_FOUND;                                            // RETURN
    }

    return accessAttribute(accessor, attributeInfo-&gt;d_id);
}

inline
const bdlb::NullableValue&lt;unsigned char&gt;&amp; Sequence6::element1() const
{
    return d_element1;
}

inline
const bdlb::NullableValue&lt;CustomString&gt;&amp; Sequence6::element2() const
{
    return d_element2;
}

inline
const bdlb::NullableValue&lt;CustomInt&gt;&amp; Sequence6::element3() const
{
    return d_element3;
}

inline
unsigned int Sequence6::element4() const
{
    return d_element4;
}

inline
unsigned char Sequence6::element5() const
{
    return d_element5;
}

inline
const bsl::vector&lt;bdlb::NullableValue&lt;CustomInt&gt; &gt;&amp; Sequence6::element6() const
{
    return d_element6;
}

inline
const CustomString&amp; Sequence6::element7() const
{
    return d_element7;
}

inline
const CustomInt&amp; Sequence6::element8() const
{
    return d_element8;
}

inline
const bdlb::NullableValue&lt;unsigned int&gt;&amp; Sequence6::element9() const
{
    return d_element9;
}

inline
const bsl::vector&lt;unsigned char&gt;&amp; Sequence6::element10() const
{
    return d_element10;
}

inline
const bsl::vector&lt;CustomString&gt;&amp; Sequence6::element11() const
{
    return d_element11;
}

inline
const bsl::vector&lt;unsigned int&gt;&amp; Sequence6::element12() const
{
    return d_element12;
}

inline
const bsl::vector&lt;bdlb::NullableValue&lt;unsigned char&gt; &gt;&amp; Sequence6::element13() const
{
    return d_element13;
}

inline
const bsl::vector&lt;CustomInt&gt;&amp; Sequence6::element14() const
{
    return d_element14;
}

inline
const bsl::vector&lt;bdlb::NullableValue&lt;unsigned int&gt; &gt;&amp; Sequence6::element15() const
{
    return d_element15;
}



                               // -------------
                               // class Choice3
                               // -------------

// CREATORS
inline
Choice3::Choice3(bslma::Allocator *basicAllocator)
: d_selectionId(e_SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline
Choice3::~Choice3()
{
    reset();
}

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int Choice3::manipulateSelection(MANIPULATOR&amp; manipulator)
{
    switch (d_selectionId) {
      case Choice3::e_SELECTION_ID_SELECTION1:
        return manipulator(&amp;d_selection1.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION1]);
      case Choice3::e_SELECTION_ID_SELECTION2:
        return manipulator(&amp;d_selection2.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION2]);
      case Choice3::e_SELECTION_ID_SELECTION3:
        return manipulator(&amp;d_selection3.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION3]);
      case Choice3::e_SELECTION_ID_SELECTION4:
        return manipulator(&amp;d_selection4.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION4]);
      default:
        BSLS_ASSERT(Choice3::e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
Sequence6&amp; Choice3::selection1()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION1 == d_selectionId);
    return d_selection1.object();
}

inline
unsigned char&amp; Choice3::selection2()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION2 == d_selectionId);
    return d_selection2.object();
}

inline
CustomString&amp; Choice3::selection3()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION3 == d_selectionId);
    return d_selection3.object();
}

inline
CustomInt&amp; Choice3::selection4()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION4 == d_selectionId);
    return d_selection4.object();
}

// ACCESSORS
inline
int Choice3::selectionId() const
{
    return d_selectionId;
}

template &lt;class ACCESSOR&gt;
int Choice3::accessSelection(ACCESSOR&amp; accessor) const
{
    switch (d_selectionId) {
      case e_SELECTION_ID_SELECTION1:
        return accessor(d_selection1.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION1]);
      case e_SELECTION_ID_SELECTION2:
        return accessor(d_selection2.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION2]);
      case e_SELECTION_ID_SELECTION3:
        return accessor(d_selection3.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION3]);
      case e_SELECTION_ID_SELECTION4:
        return accessor(d_selection4.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION4]);
      default:
        BSLS_ASSERT(e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
const Sequence6&amp; Choice3::selection1() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION1 == d_selectionId);
    return d_selection1.object();
}

inline
const unsigned char&amp; Choice3::selection2() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION2 == d_selectionId);
    return d_selection2.object();
}

inline
const CustomString&amp; Choice3::selection3() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION3 == d_selectionId);
    return d_selection3.object();
}

inline
const CustomInt&amp; Choice3::selection4() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION4 == d_selectionId);
    return d_selection4.object();
}

inline
bool Choice3::isSelection1Value() const
{
    return e_SELECTION_ID_SELECTION1 == d_selectionId;
}

inline
bool Choice3::isSelection2Value() const
{
    return e_SELECTION_ID_SELECTION2 == d_selectionId;
}

inline
bool Choice3::isSelection3Value() const
{
    return e_SELECTION_ID_SELECTION3 == d_selectionId;
}

inline
bool Choice3::isSelection4Value() const
{
    return e_SELECTION_ID_SELECTION4 == d_selectionId;
}

inline
bool Choice3::isUndefinedValue() const
{
    return e_SELECTION_ID_UNDEFINED == d_selectionId;
}


                     // ---------------------------------
                     // class SequenceWithAnonymityChoice
                     // ---------------------------------

// CREATORS
inline
SequenceWithAnonymityChoice::SequenceWithAnonymityChoice(bslma::Allocator *basicAllocator)
: d_selectionId(e_SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline
SequenceWithAnonymityChoice::~SequenceWithAnonymityChoice()
{
    reset();
}

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int SequenceWithAnonymityChoice::manipulateSelection(MANIPULATOR&amp; manipulator)
{
    switch (d_selectionId) {
      case SequenceWithAnonymityChoice::e_SELECTION_ID_SELECTION1:
        return manipulator(&amp;d_selection1.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION1]);
      case SequenceWithAnonymityChoice::e_SELECTION_ID_SELECTION2:
        return manipulator(&amp;d_selection2.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION2]);
      case SequenceWithAnonymityChoice::e_SELECTION_ID_SELECTION3:
        return manipulator(&amp;d_selection3.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION3]);
      case SequenceWithAnonymityChoice::e_SELECTION_ID_SELECTION4:
        return manipulator(&amp;d_selection4.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION4]);
      default:
        BSLS_ASSERT(SequenceWithAnonymityChoice::e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
Sequence6&amp; SequenceWithAnonymityChoice::selection1()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION1 == d_selectionId);
    return d_selection1.object();
}

inline
unsigned char&amp; SequenceWithAnonymityChoice::selection2()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION2 == d_selectionId);
    return d_selection2.object();
}

inline
CustomString&amp; SequenceWithAnonymityChoice::selection3()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION3 == d_selectionId);
    return d_selection3.object();
}

inline
CustomInt&amp; SequenceWithAnonymityChoice::selection4()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION4 == d_selectionId);
    return d_selection4.object();
}

// ACCESSORS
inline
int SequenceWithAnonymityChoice::selectionId() const
{
    return d_selectionId;
}

template &lt;class ACCESSOR&gt;
int SequenceWithAnonymityChoice::accessSelection(ACCESSOR&amp; accessor) const
{
    switch (d_selectionId) {
      case e_SELECTION_ID_SELECTION1:
        return accessor(d_selection1.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION1]);
      case e_SELECTION_ID_SELECTION2:
        return accessor(d_selection2.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION2]);
      case e_SELECTION_ID_SELECTION3:
        return accessor(d_selection3.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION3]);
      case e_SELECTION_ID_SELECTION4:
        return accessor(d_selection4.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION4]);
      default:
        BSLS_ASSERT(e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
const Sequence6&amp; SequenceWithAnonymityChoice::selection1() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION1 == d_selectionId);
    return d_selection1.object();
}

inline
const unsigned char&amp; SequenceWithAnonymityChoice::selection2() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION2 == d_selectionId);
    return d_selection2.object();
}

inline
const CustomString&amp; SequenceWithAnonymityChoice::selection3() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION3 == d_selectionId);
    return d_selection3.object();
}

inline
const CustomInt&amp; SequenceWithAnonymityChoice::selection4() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION4 == d_selectionId);
    return d_selection4.object();
}

inline
bool SequenceWithAnonymityChoice::isSelection1Value() const
{
    return e_SELECTION_ID_SELECTION1 == d_selectionId;
}

inline
bool SequenceWithAnonymityChoice::isSelection2Value() const
{
    return e_SELECTION_ID_SELECTION2 == d_selectionId;
}

inline
bool SequenceWithAnonymityChoice::isSelection3Value() const
{
    return e_SELECTION_ID_SELECTION3 == d_selectionId;
}

inline
bool SequenceWithAnonymityChoice::isSelection4Value() const
{
    return e_SELECTION_ID_SELECTION4 == d_selectionId;
}

inline
bool SequenceWithAnonymityChoice::isUndefinedValue() const
{
    return e_SELECTION_ID_UNDEFINED == d_selectionId;
}


                               // -------------
                               // class Choice1
                               // -------------

// CREATORS
inline
Choice1::Choice1(bslma::Allocator *basicAllocator)
: d_selectionId(e_SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline
Choice1::~Choice1()
{
    reset();
}

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int Choice1::manipulateSelection(MANIPULATOR&amp; manipulator)
{
    switch (d_selectionId) {
      case Choice1::e_SELECTION_ID_SELECTION1:
        return manipulator(&amp;d_selection1.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION1]);
      case Choice1::e_SELECTION_ID_SELECTION2:
        return manipulator(&amp;d_selection2.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION2]);
      case Choice1::e_SELECTION_ID_SELECTION3:
        return manipulator(d_selection3,
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION3]);
      case Choice1::e_SELECTION_ID_SELECTION4:
        return manipulator(d_selection4,
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION4]);
      default:
        BSLS_ASSERT(Choice1::e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
int&amp; Choice1::selection1()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION1 == d_selectionId);
    return d_selection1.object();
}

inline
double&amp; Choice1::selection2()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION2 == d_selectionId);
    return d_selection2.object();
}

inline
Sequence4&amp; Choice1::selection3()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION3 == d_selectionId);
    return *d_selection3;
}

inline
Choice2&amp; Choice1::selection4()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION4 == d_selectionId);
    return *d_selection4;
}

// ACCESSORS
inline
int Choice1::selectionId() const
{
    return d_selectionId;
}

template &lt;class ACCESSOR&gt;
int Choice1::accessSelection(ACCESSOR&amp; accessor) const
{
    switch (d_selectionId) {
      case e_SELECTION_ID_SELECTION1:
        return accessor(d_selection1.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION1]);
      case e_SELECTION_ID_SELECTION2:
        return accessor(d_selection2.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION2]);
      case e_SELECTION_ID_SELECTION3:
        return accessor(*d_selection3,
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION3]);
      case e_SELECTION_ID_SELECTION4:
        return accessor(*d_selection4,
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION4]);
      default:
        BSLS_ASSERT(e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
const int&amp; Choice1::selection1() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION1 == d_selectionId);
    return d_selection1.object();
}

inline
const double&amp; Choice1::selection2() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION2 == d_selectionId);
    return d_selection2.object();
}

inline
const Sequence4&amp; Choice1::selection3() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION3 == d_selectionId);
    return *d_selection3;
}

inline
const Choice2&amp; Choice1::selection4() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION4 == d_selectionId);
    return *d_selection4;
}

inline
bool Choice1::isSelection1Value() const
{
    return e_SELECTION_ID_SELECTION1 == d_selectionId;
}

inline
bool Choice1::isSelection2Value() const
{
    return e_SELECTION_ID_SELECTION2 == d_selectionId;
}

inline
bool Choice1::isSelection3Value() const
{
    return e_SELECTION_ID_SELECTION3 == d_selectionId;
}

inline
bool Choice1::isSelection4Value() const
{
    return e_SELECTION_ID_SELECTION4 == d_selectionId;
}

inline
bool Choice1::isUndefinedValue() const
{
    return e_SELECTION_ID_UNDEFINED == d_selectionId;
}


                               // -------------
                               // class Choice2
                               // -------------

// CREATORS
inline
Choice2::Choice2(bslma::Allocator *basicAllocator)
: d_selectionId(e_SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline
Choice2::~Choice2()
{
    reset();
}

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int Choice2::manipulateSelection(MANIPULATOR&amp; manipulator)
{
    switch (d_selectionId) {
      case Choice2::e_SELECTION_ID_SELECTION1:
        return manipulator(&amp;d_selection1.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION1]);
      case Choice2::e_SELECTION_ID_SELECTION2:
        return manipulator(&amp;d_selection2.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION2]);
      case Choice2::e_SELECTION_ID_SELECTION3:
        return manipulator(d_selection3,
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION3]);
      case Choice2::e_SELECTION_ID_SELECTION4:
        return manipulator(&amp;d_selection4.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION4]);
      default:
        BSLS_ASSERT(Choice2::e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
bool&amp; Choice2::selection1()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION1 == d_selectionId);
    return d_selection1.object();
}

inline
bsl::string&amp; Choice2::selection2()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION2 == d_selectionId);
    return d_selection2.object();
}

inline
Choice1&amp; Choice2::selection3()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION3 == d_selectionId);
    return *d_selection3;
}

inline
unsigned int&amp; Choice2::selection4()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION4 == d_selectionId);
    return d_selection4.object();
}

// ACCESSORS
inline
int Choice2::selectionId() const
{
    return d_selectionId;
}

template &lt;class ACCESSOR&gt;
int Choice2::accessSelection(ACCESSOR&amp; accessor) const
{
    switch (d_selectionId) {
      case e_SELECTION_ID_SELECTION1:
        return accessor(d_selection1.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION1]);
      case e_SELECTION_ID_SELECTION2:
        return accessor(d_selection2.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION2]);
      case e_SELECTION_ID_SELECTION3:
        return accessor(*d_selection3,
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION3]);
      case e_SELECTION_ID_SELECTION4:
        return accessor(d_selection4.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION4]);
      default:
        BSLS_ASSERT(e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
const bool&amp; Choice2::selection1() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION1 == d_selectionId);
    return d_selection1.object();
}

inline
const bsl::string&amp; Choice2::selection2() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION2 == d_selectionId);
    return d_selection2.object();
}

inline
const Choice1&amp; Choice2::selection3() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION3 == d_selectionId);
    return *d_selection3;
}

inline
const unsigned int&amp; Choice2::selection4() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION4 == d_selectionId);
    return d_selection4.object();
}

inline
bool Choice2::isSelection1Value() const
{
    return e_SELECTION_ID_SELECTION1 == d_selectionId;
}

inline
bool Choice2::isSelection2Value() const
{
    return e_SELECTION_ID_SELECTION2 == d_selectionId;
}

inline
bool Choice2::isSelection3Value() const
{
    return e_SELECTION_ID_SELECTION3 == d_selectionId;
}

inline
bool Choice2::isSelection4Value() const
{
    return e_SELECTION_ID_SELECTION4 == d_selectionId;
}

inline
bool Choice2::isUndefinedValue() const
{
    return e_SELECTION_ID_UNDEFINED == d_selectionId;
}


                              // ---------------
                              // class Sequence4
                              // ---------------

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int Sequence4::manipulateAttributes(MANIPULATOR&amp; manipulator)
{
    int ret;

    ret = manipulator(&amp;d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element7, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT7]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element8, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT8]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element9, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT9]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element10, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT10]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element11, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT11]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element12, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT12]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element13, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT13]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element14, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT14]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element15, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT15]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element16, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT16]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element17, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT17]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element18, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT18]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element19, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT19]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class MANIPULATOR&gt;
int Sequence4::manipulateAttribute(MANIPULATOR&amp; manipulator, int id)
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_ELEMENT1: {
        return manipulator(&amp;d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT2: {
        return manipulator(&amp;d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT3: {
        return manipulator(&amp;d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT4: {
        return manipulator(&amp;d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT5: {
        return manipulator(&amp;d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT6: {
        return manipulator(&amp;d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT7: {
        return manipulator(&amp;d_element7, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT7]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT8: {
        return manipulator(&amp;d_element8, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT8]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT9: {
        return manipulator(&amp;d_element9, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT9]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT10: {
        return manipulator(&amp;d_element10, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT10]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT11: {
        return manipulator(&amp;d_element11, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT11]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT12: {
        return manipulator(&amp;d_element12, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT12]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT13: {
        return manipulator(&amp;d_element13, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT13]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT14: {
        return manipulator(&amp;d_element14, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT14]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT15: {
        return manipulator(&amp;d_element15, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT15]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT16: {
        return manipulator(&amp;d_element16, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT16]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT17: {
        return manipulator(&amp;d_element17, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT17]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT18: {
        return manipulator(&amp;d_element18, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT18]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT19: {
        return manipulator(&amp;d_element19, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT19]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class MANIPULATOR&gt;
int Sequence4::manipulateAttribute(
        MANIPULATOR&amp;  manipulator,
        const char   *name,
        int           nameLength)
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
           lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
        return k_NOT_FOUND;                                           // RETURN
    }

    return manipulateAttribute(manipulator, attributeInfo-&gt;d_id);
}

inline
bsl::vector&lt;Sequence3&gt;&amp; Sequence4::element1()
{
    return d_element1;
}

inline
bsl::vector&lt;Choice1&gt;&amp; Sequence4::element2()
{
    return d_element2;
}

inline
bdlb::NullableValue&lt;bsl::vector&lt;char&gt; &gt;&amp; Sequence4::element3()
{
    return d_element3;
}

inline
bdlb::NullableValue&lt;int&gt;&amp; Sequence4::element4()
{
    return d_element4;
}

inline
bdlb::NullableValue&lt;bdlt::DatetimeTz&gt;&amp; Sequence4::element5()
{
    return d_element5;
}

inline
bdlb::NullableValue&lt;CustomString&gt;&amp; Sequence4::element6()
{
    return d_element6;
}

inline
bdlb::NullableValue&lt;Enumerated::Value&gt;&amp; Sequence4::element7()
{
    return d_element7;
}

inline
bool&amp; Sequence4::element8()
{
    return d_element8;
}

inline
bsl::string&amp; Sequence4::element9()
{
    return d_element9;
}

inline
double&amp; Sequence4::element10()
{
    return d_element10;
}

inline
bsl::vector&lt;char&gt;&amp; Sequence4::element11()
{
    return d_element11;
}

inline
int&amp; Sequence4::element12()
{
    return d_element12;
}

inline
Enumerated::Value&amp; Sequence4::element13()
{
    return d_element13;
}

inline
bsl::vector&lt;bool&gt;&amp; Sequence4::element14()
{
    return d_element14;
}

inline
bsl::vector&lt;double&gt;&amp; Sequence4::element15()
{
    return d_element15;
}

inline
bsl::vector&lt;bsl::vector&lt;char&gt; &gt;&amp; Sequence4::element16()
{
    return d_element16;
}

inline
bsl::vector&lt;int&gt;&amp; Sequence4::element17()
{
    return d_element17;
}

inline
bsl::vector&lt;bdlt::DatetimeTz&gt;&amp; Sequence4::element18()
{
    return d_element18;
}

inline
bsl::vector&lt;CustomString&gt;&amp; Sequence4::element19()
{
    return d_element19;
}

// ACCESSORS
template &lt;class ACCESSOR&gt;
int Sequence4::accessAttributes(ACCESSOR&amp; accessor) const
{
    int ret;

    ret = accessor(d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element7, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT7]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element8, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT8]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element9, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT9]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element10, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT10]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element11, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT11]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element12, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT12]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element13, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT13]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element14, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT14]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element15, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT15]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element16, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT16]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element17, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT17]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element18, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT18]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element19, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT19]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class ACCESSOR&gt;
int Sequence4::accessAttribute(ACCESSOR&amp; accessor, int id) const
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_ELEMENT1: {
        return accessor(d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT2: {
        return accessor(d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT3: {
        return accessor(d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT4: {
        return accessor(d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT5: {
        return accessor(d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT6: {
        return accessor(d_element6, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT6]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT7: {
        return accessor(d_element7, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT7]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT8: {
        return accessor(d_element8, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT8]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT9: {
        return accessor(d_element9, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT9]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT10: {
        return accessor(d_element10, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT10]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT11: {
        return accessor(d_element11, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT11]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT12: {
        return accessor(d_element12, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT12]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT13: {
        return accessor(d_element13, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT13]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT14: {
        return accessor(d_element14, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT14]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT15: {
        return accessor(d_element15, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT15]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT16: {
        return accessor(d_element16, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT16]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT17: {
        return accessor(d_element17, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT17]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT18: {
        return accessor(d_element18, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT18]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT19: {
        return accessor(d_element19, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT19]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class ACCESSOR&gt;
int Sequence4::accessAttribute(
        ACCESSOR&amp;   accessor,
        const char *name,
        int         nameLength) const
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
          lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
       return k_NOT_FOUND;                                            // RETURN
    }

    return accessAttribute(accessor, attributeInfo-&gt;d_id);
}

inline
const bsl::vector&lt;Sequence3&gt;&amp; Sequence4::element1() const
{
    return d_element1;
}

inline
const bsl::vector&lt;Choice1&gt;&amp; Sequence4::element2() const
{
    return d_element2;
}

inline
const bdlb::NullableValue&lt;bsl::vector&lt;char&gt; &gt;&amp; Sequence4::element3() const
{
    return d_element3;
}

inline
const bdlb::NullableValue&lt;int&gt;&amp; Sequence4::element4() const
{
    return d_element4;
}

inline
const bdlb::NullableValue&lt;bdlt::DatetimeTz&gt;&amp; Sequence4::element5() const
{
    return d_element5;
}

inline
const bdlb::NullableValue&lt;CustomString&gt;&amp; Sequence4::element6() const
{
    return d_element6;
}

inline
const bdlb::NullableValue&lt;Enumerated::Value&gt;&amp; Sequence4::element7() const
{
    return d_element7;
}

inline
bool Sequence4::element8() const
{
    return d_element8;
}

inline
const bsl::string&amp; Sequence4::element9() const
{
    return d_element9;
}

inline
double Sequence4::element10() const
{
    return d_element10;
}

inline
const bsl::vector&lt;char&gt;&amp; Sequence4::element11() const
{
    return d_element11;
}

inline
int Sequence4::element12() const
{
    return d_element12;
}

inline
Enumerated::Value Sequence4::element13() const
{
    return d_element13;
}

inline
const bsl::vector&lt;bool&gt;&amp; Sequence4::element14() const
{
    return d_element14;
}

inline
const bsl::vector&lt;double&gt;&amp; Sequence4::element15() const
{
    return d_element15;
}

inline
const bsl::vector&lt;bsl::vector&lt;char&gt; &gt;&amp; Sequence4::element16() const
{
    return d_element16;
}

inline
const bsl::vector&lt;int&gt;&amp; Sequence4::element17() const
{
    return d_element17;
}

inline
const bsl::vector&lt;bdlt::DatetimeTz&gt;&amp; Sequence4::element18() const
{
    return d_element18;
}

inline
const bsl::vector&lt;CustomString&gt;&amp; Sequence4::element19() const
{
    return d_element19;
}



                              // ---------------
                              // class Sequence1
                              // ---------------

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int Sequence1::manipulateAttributes(MANIPULATOR&amp; manipulator)
{
    int ret;

    ret = manipulator(&amp;d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class MANIPULATOR&gt;
int Sequence1::manipulateAttribute(MANIPULATOR&amp; manipulator, int id)
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_ELEMENT1: {
        return manipulator(&amp;d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT2: {
        return manipulator(&amp;d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT3: {
        return manipulator(d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT4: {
        return manipulator(&amp;d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT5: {
        return manipulator(&amp;d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class MANIPULATOR&gt;
int Sequence1::manipulateAttribute(
        MANIPULATOR&amp;  manipulator,
        const char   *name,
        int           nameLength)
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
           lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
        return k_NOT_FOUND;                                           // RETURN
    }

    return manipulateAttribute(manipulator, attributeInfo-&gt;d_id);
}

inline
bdlb::NullableValue&lt;Choice3&gt;&amp; Sequence1::element1()
{
    return d_element1;
}

inline
bsl::vector&lt;Choice1&gt;&amp; Sequence1::element2()
{
    return d_element2;
}

inline
Choice2&amp; Sequence1::element3()
{
    return *d_element3;
}

inline
bsl::vector&lt;bdlb::NullableValue&lt;Choice1&gt; &gt;&amp; Sequence1::element4()
{
    return d_element4;
}

inline
bsl::vector&lt;Choice3&gt;&amp; Sequence1::element5()
{
    return d_element5;
}

// ACCESSORS
template &lt;class ACCESSOR&gt;
int Sequence1::accessAttributes(ACCESSOR&amp; accessor) const
{
    int ret;

    ret = accessor(d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(*d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class ACCESSOR&gt;
int Sequence1::accessAttribute(ACCESSOR&amp; accessor, int id) const
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_ELEMENT1: {
        return accessor(d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT2: {
        return accessor(d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT3: {
        return accessor(*d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT4: {
        return accessor(d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT5: {
        return accessor(d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class ACCESSOR&gt;
int Sequence1::accessAttribute(
        ACCESSOR&amp;   accessor,
        const char *name,
        int         nameLength) const
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
          lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
       return k_NOT_FOUND;                                            // RETURN
    }

    return accessAttribute(accessor, attributeInfo-&gt;d_id);
}

inline
const bdlb::NullableValue&lt;Choice3&gt;&amp; Sequence1::element1() const
{
    return d_element1;
}

inline
const bsl::vector&lt;Choice1&gt;&amp; Sequence1::element2() const
{
    return d_element2;
}

inline
const Choice2&amp; Sequence1::element3() const
{
    return *d_element3;
}

inline
const bsl::vector&lt;bdlb::NullableValue&lt;Choice1&gt; &gt;&amp; Sequence1::element4() const
{
    return d_element4;
}

inline
const bsl::vector&lt;Choice3&gt;&amp; Sequence1::element5() const
{
    return d_element5;
}



                              // ---------------
                              // class Sequence2
                              // ---------------

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int Sequence2::manipulateAttributes(MANIPULATOR&amp; manipulator)
{
    int ret;

    ret = manipulator(&amp;d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class MANIPULATOR&gt;
int Sequence2::manipulateAttribute(MANIPULATOR&amp; manipulator, int id)
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_ELEMENT1: {
        return manipulator(&amp;d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT2: {
        return manipulator(&amp;d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT3: {
        return manipulator(&amp;d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT4: {
        return manipulator(&amp;d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT5: {
        return manipulator(&amp;d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class MANIPULATOR&gt;
int Sequence2::manipulateAttribute(
        MANIPULATOR&amp;  manipulator,
        const char   *name,
        int           nameLength)
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
           lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
        return k_NOT_FOUND;                                           // RETURN
    }

    return manipulateAttribute(manipulator, attributeInfo-&gt;d_id);
}

inline
CustomString&amp; Sequence2::element1()
{
    return d_element1;
}

inline
unsigned char&amp; Sequence2::element2()
{
    return d_element2;
}

inline
bdlt::DatetimeTz&amp; Sequence2::element3()
{
    return d_element3;
}

inline
bdlb::NullableValue&lt;Choice1&gt;&amp; Sequence2::element4()
{
    return d_element4;
}

inline
bdlb::NullableValue&lt;double&gt;&amp; Sequence2::element5()
{
    return d_element5;
}

// ACCESSORS
template &lt;class ACCESSOR&gt;
int Sequence2::accessAttributes(ACCESSOR&amp; accessor) const
{
    int ret;

    ret = accessor(d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class ACCESSOR&gt;
int Sequence2::accessAttribute(ACCESSOR&amp; accessor, int id) const
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_ELEMENT1: {
        return accessor(d_element1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT2: {
        return accessor(d_element2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT3: {
        return accessor(d_element3, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT3]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT4: {
        return accessor(d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT5: {
        return accessor(d_element5, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT5]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class ACCESSOR&gt;
int Sequence2::accessAttribute(
        ACCESSOR&amp;   accessor,
        const char *name,
        int         nameLength) const
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
          lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
       return k_NOT_FOUND;                                            // RETURN
    }

    return accessAttribute(accessor, attributeInfo-&gt;d_id);
}

inline
const CustomString&amp; Sequence2::element1() const
{
    return d_element1;
}

inline
unsigned char Sequence2::element2() const
{
    return d_element2;
}

inline
const bdlt::DatetimeTz&amp; Sequence2::element3() const
{
    return d_element3;
}

inline
const bdlb::NullableValue&lt;Choice1&gt;&amp; Sequence2::element4() const
{
    return d_element4;
}

inline
const bdlb::NullableValue&lt;double&gt;&amp; Sequence2::element5() const
{
    return d_element5;
}



                     // ----------------------------------
                     // class SequenceWithAnonymityChoice2
                     // ----------------------------------

// CREATORS
inline
SequenceWithAnonymityChoice2::SequenceWithAnonymityChoice2(bslma::Allocator *basicAllocator)
: d_selectionId(e_SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline
SequenceWithAnonymityChoice2::~SequenceWithAnonymityChoice2()
{
    reset();
}

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int SequenceWithAnonymityChoice2::manipulateSelection(MANIPULATOR&amp; manipulator)
{
    switch (d_selectionId) {
      case SequenceWithAnonymityChoice2::e_SELECTION_ID_SELECTION7:
        return manipulator(d_selection7,
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION7]);
      case SequenceWithAnonymityChoice2::e_SELECTION_ID_SELECTION8:
        return manipulator(d_selection8,
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION8]);
      default:
        BSLS_ASSERT(SequenceWithAnonymityChoice2::e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
Sequence4&amp; SequenceWithAnonymityChoice2::selection7()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION7 == d_selectionId);
    return *d_selection7;
}

inline
Choice2&amp; SequenceWithAnonymityChoice2::selection8()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION8 == d_selectionId);
    return *d_selection8;
}

// ACCESSORS
inline
int SequenceWithAnonymityChoice2::selectionId() const
{
    return d_selectionId;
}

template &lt;class ACCESSOR&gt;
int SequenceWithAnonymityChoice2::accessSelection(ACCESSOR&amp; accessor) const
{
    switch (d_selectionId) {
      case e_SELECTION_ID_SELECTION7:
        return accessor(*d_selection7,
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION7]);
      case e_SELECTION_ID_SELECTION8:
        return accessor(*d_selection8,
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION8]);
      default:
        BSLS_ASSERT(e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
const Sequence4&amp; SequenceWithAnonymityChoice2::selection7() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION7 == d_selectionId);
    return *d_selection7;
}

inline
const Choice2&amp; SequenceWithAnonymityChoice2::selection8() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION8 == d_selectionId);
    return *d_selection8;
}

inline
bool SequenceWithAnonymityChoice2::isSelection7Value() const
{
    return e_SELECTION_ID_SELECTION7 == d_selectionId;
}

inline
bool SequenceWithAnonymityChoice2::isSelection8Value() const
{
    return e_SELECTION_ID_SELECTION8 == d_selectionId;
}

inline
bool SequenceWithAnonymityChoice2::isUndefinedValue() const
{
    return e_SELECTION_ID_UNDEFINED == d_selectionId;
}


                        // ---------------------------
                        // class SequenceWithAnonymity
                        // ---------------------------

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int SequenceWithAnonymity::manipulateAttributes(MANIPULATOR&amp; manipulator)
{
    int ret;

    ret = manipulator(&amp;d_choice, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_choice1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_CHOICE1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_choice2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_CHOICE2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class MANIPULATOR&gt;
int SequenceWithAnonymity::manipulateAttribute(MANIPULATOR&amp; manipulator, int id)
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_CHOICE: {
        return manipulator(&amp;d_choice, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_CHOICE]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_CHOICE1: {
        return manipulator(&amp;d_choice1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_CHOICE1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_CHOICE2: {
        return manipulator(&amp;d_choice2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_CHOICE2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT4: {
        return manipulator(&amp;d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class MANIPULATOR&gt;
int SequenceWithAnonymity::manipulateAttribute(
        MANIPULATOR&amp;  manipulator,
        const char   *name,
        int           nameLength)
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
           lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
        return k_NOT_FOUND;                                           // RETURN
    }

    return manipulateAttribute(manipulator, attributeInfo-&gt;d_id);
}

inline
SequenceWithAnonymityChoice&amp; SequenceWithAnonymity::choice()
{
    return d_choice;
}

inline
SequenceWithAnonymityChoice1&amp; SequenceWithAnonymity::choice1()
{
    return d_choice1;
}

inline
bdlb::NullableValue&lt;SequenceWithAnonymityChoice2&gt;&amp; SequenceWithAnonymity::choice2()
{
    return d_choice2;
}

inline
Sequence6&amp; SequenceWithAnonymity::element4()
{
    return d_element4;
}

// ACCESSORS
template &lt;class ACCESSOR&gt;
int SequenceWithAnonymity::accessAttributes(ACCESSOR&amp; accessor) const
{
    int ret;

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_choice1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_CHOICE1]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_choice2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_CHOICE2]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class ACCESSOR&gt;
int SequenceWithAnonymity::accessAttribute(ACCESSOR&amp; accessor, int id) const
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_CHOICE]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_CHOICE1: {
        return accessor(d_choice1, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_CHOICE1]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_CHOICE2: {
        return accessor(d_choice2, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_CHOICE2]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_ELEMENT4: {
        return accessor(d_element4, ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_ELEMENT4]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;                                           // RETURN
    }
}

template &lt;class ACCESSOR&gt;
int SequenceWithAnonymity::accessAttribute(
        ACCESSOR&amp;   accessor,
        const char *name,
        int         nameLength) const
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo =
          lookupAttributeInfo(name, nameLength);
    if (0 == attributeInfo) {
       return k_NOT_FOUND;                                            // RETURN
    }

    return accessAttribute(accessor, attributeInfo-&gt;d_id);
}

inline
const SequenceWithAnonymityChoice&amp; SequenceWithAnonymity::choice() const
{
    return d_choice;
}

inline
const SequenceWithAnonymityChoice1&amp; SequenceWithAnonymity::choice1() const
{
    return d_choice1;
}

inline
const bdlb::NullableValue&lt;SequenceWithAnonymityChoice2&gt;&amp; SequenceWithAnonymity::choice2() const
{
    return d_choice2;
}

inline
const Sequence6&amp; SequenceWithAnonymity::element4() const
{
    return d_element4;
}



                          // ------------------------
                          // class FeatureTestMessage
                          // ------------------------

// CREATORS
inline
FeatureTestMessage::FeatureTestMessage(bslma::Allocator *basicAllocator)
: d_selectionId(e_SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline
FeatureTestMessage::~FeatureTestMessage()
{
    reset();
}

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int FeatureTestMessage::manipulateSelection(MANIPULATOR&amp; manipulator)
{
    switch (d_selectionId) {
      case FeatureTestMessage::e_SELECTION_ID_SELECTION1:
        return manipulator(&amp;d_selection1.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION1]);
      case FeatureTestMessage::e_SELECTION_ID_SELECTION2:
        return manipulator(&amp;d_selection2.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION2]);
      case FeatureTestMessage::e_SELECTION_ID_SELECTION3:
        return manipulator(&amp;d_selection3.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION3]);
      case FeatureTestMessage::e_SELECTION_ID_SELECTION4:
        return manipulator(d_selection4,
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION4]);
      case FeatureTestMessage::e_SELECTION_ID_SELECTION5:
        return manipulator(&amp;d_selection5.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION5]);
      case FeatureTestMessage::e_SELECTION_ID_SELECTION6:
        return manipulator(&amp;d_selection6.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION6]);
      case FeatureTestMessage::e_SELECTION_ID_SELECTION7:
        return manipulator(&amp;d_selection7.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION7]);
      case FeatureTestMessage::e_SELECTION_ID_SELECTION8:
        return manipulator(&amp;d_selection8.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION8]);
      case FeatureTestMessage::e_SELECTION_ID_SELECTION9:
        return manipulator(&amp;d_selection9.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION9]);
      case FeatureTestMessage::e_SELECTION_ID_SELECTION10:
        return manipulator(&amp;d_selection10.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION10]);
      case FeatureTestMessage::e_SELECTION_ID_SELECTION11:
        return manipulator(&amp;d_selection11.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION11]);
      default:
        BSLS_ASSERT(FeatureTestMessage::e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
Sequence1&amp; FeatureTestMessage::selection1()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION1 == d_selectionId);
    return d_selection1.object();
}

inline
bsl::vector&lt;char&gt;&amp; FeatureTestMessage::selection2()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION2 == d_selectionId);
    return d_selection2.object();
}

inline
Sequence2&amp; FeatureTestMessage::selection3()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION3 == d_selectionId);
    return d_selection3.object();
}

inline
Sequence3&amp; FeatureTestMessage::selection4()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION4 == d_selectionId);
    return *d_selection4;
}

inline
bdlt::DatetimeTz&amp; FeatureTestMessage::selection5()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION5 == d_selectionId);
    return d_selection5.object();
}

inline
CustomString&amp; FeatureTestMessage::selection6()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION6 == d_selectionId);
    return d_selection6.object();
}

inline
Enumerated::Value&amp; FeatureTestMessage::selection7()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION7 == d_selectionId);
    return d_selection7.object();
}

inline
Choice3&amp; FeatureTestMessage::selection8()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION8 == d_selectionId);
    return d_selection8.object();
}

inline
VoidSequence&amp; FeatureTestMessage::selection9()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION9 == d_selectionId);
    return d_selection9.object();
}

inline
UnsignedSequence&amp; FeatureTestMessage::selection10()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION10 == d_selectionId);
    return d_selection10.object();
}

inline
SequenceWithAnonymity&amp; FeatureTestMessage::selection11()
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION11 == d_selectionId);
    return d_selection11.object();
}

// ACCESSORS
inline
int FeatureTestMessage::selectionId() const
{
    return d_selectionId;
}

template &lt;class ACCESSOR&gt;
int FeatureTestMessage::accessSelection(ACCESSOR&amp; accessor) const
{
    switch (d_selectionId) {
      case e_SELECTION_ID_SELECTION1:
        return accessor(d_selection1.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION1]);
      case e_SELECTION_ID_SELECTION2:
        return accessor(d_selection2.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION2]);
      case e_SELECTION_ID_SELECTION3:
        return accessor(d_selection3.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION3]);
      case e_SELECTION_ID_SELECTION4:
        return accessor(*d_selection4,
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION4]);
      case e_SELECTION_ID_SELECTION5:
        return accessor(d_selection5.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION5]);
      case e_SELECTION_ID_SELECTION6:
        return accessor(d_selection6.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION6]);
      case e_SELECTION_ID_SELECTION7:
        return accessor(d_selection7.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION7]);
      case e_SELECTION_ID_SELECTION8:
        return accessor(d_selection8.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION8]);
      case e_SELECTION_ID_SELECTION9:
        return accessor(d_selection9.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION9]);
      case e_SELECTION_ID_SELECTION10:
        return accessor(d_selection10.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION10]);
      case e_SELECTION_ID_SELECTION11:
        return accessor(d_selection11.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SELECTION11]);
      default:
        BSLS_ASSERT(e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
const Sequence1&amp; FeatureTestMessage::selection1() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION1 == d_selectionId);
    return d_selection1.object();
}

inline
const bsl::vector&lt;char&gt;&amp; FeatureTestMessage::selection2() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION2 == d_selectionId);
    return d_selection2.object();
}

inline
const Sequence2&amp; FeatureTestMessage::selection3() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION3 == d_selectionId);
    return d_selection3.object();
}

inline
const Sequence3&amp; FeatureTestMessage::selection4() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION4 == d_selectionId);
    return *d_selection4;
}

inline
const bdlt::DatetimeTz&amp; FeatureTestMessage::selection5() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION5 == d_selectionId);
    return d_selection5.object();
}

inline
const CustomString&amp; FeatureTestMessage::selection6() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION6 == d_selectionId);
    return d_selection6.object();
}

inline
const Enumerated::Value&amp; FeatureTestMessage::selection7() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION7 == d_selectionId);
    return d_selection7.object();
}

inline
const Choice3&amp; FeatureTestMessage::selection8() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION8 == d_selectionId);
    return d_selection8.object();
}

inline
const VoidSequence&amp; FeatureTestMessage::selection9() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION9 == d_selectionId);
    return d_selection9.object();
}

inline
const UnsignedSequence&amp; FeatureTestMessage::selection10() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION10 == d_selectionId);
    return d_selection10.object();
}

inline
const SequenceWithAnonymity&amp; FeatureTestMessage::selection11() const
{
    BSLS_ASSERT(e_SELECTION_ID_SELECTION11 == d_selectionId);
    return d_selection11.object();
}

inline
bool FeatureTestMessage::isSelection1Value() const
{
    return e_SELECTION_ID_SELECTION1 == d_selectionId;
}

inline
bool FeatureTestMessage::isSelection2Value() const
{
    return e_SELECTION_ID_SELECTION2 == d_selectionId;
}

inline
bool FeatureTestMessage::isSelection3Value() const
{
    return e_SELECTION_ID_SELECTION3 == d_selectionId;
}

inline
bool FeatureTestMessage::isSelection4Value() const
{
    return e_SELECTION_ID_SELECTION4 == d_selectionId;
}

inline
bool FeatureTestMessage::isSelection5Value() const
{
    return e_SELECTION_ID_SELECTION5 == d_selectionId;
}

inline
bool FeatureTestMessage::isSelection6Value() const
{
    return e_SELECTION_ID_SELECTION6 == d_selectionId;
}

inline
bool FeatureTestMessage::isSelection7Value() const
{
    return e_SELECTION_ID_SELECTION7 == d_selectionId;
}

inline
bool FeatureTestMessage::isSelection8Value() const
{
    return e_SELECTION_ID_SELECTION8 == d_selectionId;
}

inline
bool FeatureTestMessage::isSelection9Value() const
{
    return e_SELECTION_ID_SELECTION9 == d_selectionId;
}

inline
bool FeatureTestMessage::isSelection10Value() const
{
    return e_SELECTION_ID_SELECTION10 == d_selectionId;
}

inline
bool FeatureTestMessage::isSelection11Value() const
{
    return e_SELECTION_ID_SELECTION11 == d_selectionId;
}

inline
bool FeatureTestMessage::isUndefinedValue() const
{
    return e_SELECTION_ID_UNDEFINED == d_selectionId;
}


                               // -------------
                               // class Request
                               // -------------

// CREATORS
inline
Request::Request(bslma::Allocator *basicAllocator)
: d_selectionId(e_SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline
Request::~Request()
{
    reset();
}

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int Request::manipulateSelection(MANIPULATOR&amp; manipulator)
{
    switch (d_selectionId) {
      case Request::e_SELECTION_ID_SIMPLE_REQUEST:
        return manipulator(&amp;d_simpleRequest.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SIMPLE_REQUEST]);
      case Request::e_SELECTION_ID_FEATURE_REQUEST:
        return manipulator(&amp;d_featureRequest.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_FEATURE_REQUEST]);
      default:
        BSLS_ASSERT(Request::e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
SimpleRequest&amp; Request::simpleRequest()
{
    BSLS_ASSERT(e_SELECTION_ID_SIMPLE_REQUEST == d_selectionId);
    return d_simpleRequest.object();
}

inline
FeatureTestMessage&amp; Request::featureRequest()
{
    BSLS_ASSERT(e_SELECTION_ID_FEATURE_REQUEST == d_selectionId);
    return d_featureRequest.object();
}

// ACCESSORS
inline
int Request::selectionId() const
{
    return d_selectionId;
}

template &lt;class ACCESSOR&gt;
int Request::accessSelection(ACCESSOR&amp; accessor) const
{
    switch (d_selectionId) {
      case e_SELECTION_ID_SIMPLE_REQUEST:
        return accessor(d_simpleRequest.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_SIMPLE_REQUEST]);
      case e_SELECTION_ID_FEATURE_REQUEST:
        return accessor(d_featureRequest.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_FEATURE_REQUEST]);
      default:
        BSLS_ASSERT(e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
const SimpleRequest&amp; Request::simpleRequest() const
{
    BSLS_ASSERT(e_SELECTION_ID_SIMPLE_REQUEST == d_selectionId);
    return d_simpleRequest.object();
}

inline
const FeatureTestMessage&amp; Request::featureRequest() const
{
    BSLS_ASSERT(e_SELECTION_ID_FEATURE_REQUEST == d_selectionId);
    return d_featureRequest.object();
}

inline
bool Request::isSimpleRequestValue() const
{
    return e_SELECTION_ID_SIMPLE_REQUEST == d_selectionId;
}

inline
bool Request::isFeatureRequestValue() const
{
    return e_SELECTION_ID_FEATURE_REQUEST == d_selectionId;
}

inline
bool Request::isUndefinedValue() const
{
    return e_SELECTION_ID_UNDEFINED == d_selectionId;
}


                               // --------------
                               // class Response
                               // --------------

// CREATORS
inline
Response::Response(bslma::Allocator *basicAllocator)
: d_selectionId(e_SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline
Response::~Response()
{
    reset();
}

// MANIPULATORS
template &lt;class MANIPULATOR&gt;
int Response::manipulateSelection(MANIPULATOR&amp; manipulator)
{
    switch (d_selectionId) {
      case Response::e_SELECTION_ID_RESPONSE_DATA:
        return manipulator(&amp;d_responseData.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_RESPONSE_DATA]);
      case Response::e_SELECTION_ID_FEATURE_RESPONSE:
        return manipulator(&amp;d_featureResponse.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_FEATURE_RESPONSE]);
      default:
        BSLS_ASSERT(Response::e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
bsl::string&amp; Response::responseData()
{
    BSLS_ASSERT(e_SELECTION_ID_RESPONSE_DATA == d_selectionId);
    return d_responseData.object();
}

inline
FeatureTestMessage&amp; Response::featureResponse()
{
    BSLS_ASSERT(e_SELECTION_ID_FEATURE_RESPONSE == d_selectionId);
    return d_featureResponse.object();
}

// ACCESSORS
inline
int Response::selectionId() const
{
    return d_selectionId;
}

template &lt;class ACCESSOR&gt;
int Response::accessSelection(ACCESSOR&amp; accessor) const
{
    switch (d_selectionId) {
      case e_SELECTION_ID_RESPONSE_DATA:
        return accessor(d_responseData.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_RESPONSE_DATA]);
      case e_SELECTION_ID_FEATURE_RESPONSE:
        return accessor(d_featureResponse.object(),
                SELECTION_INFO_ARRAY[e_SELECTION_INDEX_FEATURE_RESPONSE]);
      default:
        BSLS_ASSERT(e_SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;                                                    // RETURN
    }
}

inline
const bsl::string&amp; Response::responseData() const
{
    BSLS_ASSERT(e_SELECTION_ID_RESPONSE_DATA == d_selectionId);
    return d_responseData.object();
}

inline
const FeatureTestMessage&amp; Response::featureResponse() const
{
    BSLS_ASSERT(e_SELECTION_ID_FEATURE_RESPONSE == d_selectionId);
    return d_featureResponse.object();
}

inline
bool Response::isResponseDataValue() const
{
    return e_SELECTION_ID_RESPONSE_DATA == d_selectionId;
}

inline
bool Response::isFeatureResponseValue() const
{
    return e_SELECTION_ID_FEATURE_RESPONSE == d_selectionId;
}

inline
bool Response::isUndefinedValue() const
{
    return e_SELECTION_ID_UNDEFINED == d_selectionId;
}
}  // close package namespace

// FREE FUNCTIONS

inline
bool balb::operator==(
        const balb::CustomInt&amp; lhs,
        const balb::CustomInt&amp; rhs)
{
    return lhs.d_value == rhs.d_value;
}

inline
bool balb::operator!=(
        const balb::CustomInt&amp; lhs,
        const balb::CustomInt&amp; rhs)
{
    return lhs.d_value != rhs.d_value;
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::CustomInt&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::CustomString&amp; lhs,
        const balb::CustomString&amp; rhs)
{
    return lhs.d_value == rhs.d_value;
}

inline
bool balb::operator!=(
        const balb::CustomString&amp; lhs,
        const balb::CustomString&amp; rhs)
{
    return lhs.d_value != rhs.d_value;
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::CustomString&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        balb::Enumerated::Value rhs)
{
    return balb::Enumerated::print(stream, rhs);
}


inline
bool balb::operator==(
        const balb::SequenceWithAnonymityChoice1&amp; lhs,
        const balb::SequenceWithAnonymityChoice1&amp; rhs)
{
    typedef balb::SequenceWithAnonymityChoice1 Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
          case Class::e_SELECTION_ID_SELECTION5:
            return lhs.selection5() == rhs.selection5();
          case Class::e_SELECTION_ID_SELECTION6:
            return lhs.selection6() == rhs.selection6();
          default:
            BSLS_ASSERT(Class::e_SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;                                              // RETURN
        }
    }
    else {
        return false;                                                 // RETURN
   }
}

inline
bool balb::operator!=(
        const balb::SequenceWithAnonymityChoice1&amp; lhs,
        const balb::SequenceWithAnonymityChoice1&amp; rhs)
{
    return !(lhs == rhs);
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::SequenceWithAnonymityChoice1&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::SimpleRequest&amp; lhs,
        const balb::SimpleRequest&amp; rhs)
{
    return  lhs.data() == rhs.data()
         &amp;&amp; lhs.responseLength() == rhs.responseLength();
}

inline
bool balb::operator!=(
        const balb::SimpleRequest&amp; lhs,
        const balb::SimpleRequest&amp; rhs)
{
    return  lhs.data() != rhs.data()
         || lhs.responseLength() != rhs.responseLength();
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::SimpleRequest&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::UnsignedSequence&amp; lhs,
        const balb::UnsignedSequence&amp; rhs)
{
    return  lhs.element1() == rhs.element1()
         &amp;&amp; lhs.element2() == rhs.element2()
         &amp;&amp; lhs.element3() == rhs.element3();
}

inline
bool balb::operator!=(
        const balb::UnsignedSequence&amp; lhs,
        const balb::UnsignedSequence&amp; rhs)
{
    return  lhs.element1() != rhs.element1()
         || lhs.element2() != rhs.element2()
         || lhs.element3() != rhs.element3();
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::UnsignedSequence&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::VoidSequence&amp;,
        const balb::VoidSequence&amp;)
{
    return true;
}

inline
bool balb::operator!=(
        const balb::VoidSequence&amp;,
        const balb::VoidSequence&amp;)
{
    return false;
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::VoidSequence&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::Sequence3&amp; lhs,
        const balb::Sequence3&amp; rhs)
{
    return  lhs.element1() == rhs.element1()
         &amp;&amp; lhs.element2() == rhs.element2()
         &amp;&amp; lhs.element3() == rhs.element3()
         &amp;&amp; lhs.element4() == rhs.element4()
         &amp;&amp; lhs.element5() == rhs.element5()
         &amp;&amp; lhs.element6() == rhs.element6();
}

inline
bool balb::operator!=(
        const balb::Sequence3&amp; lhs,
        const balb::Sequence3&amp; rhs)
{
    return  lhs.element1() != rhs.element1()
         || lhs.element2() != rhs.element2()
         || lhs.element3() != rhs.element3()
         || lhs.element4() != rhs.element4()
         || lhs.element5() != rhs.element5()
         || lhs.element6() != rhs.element6();
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::Sequence3&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::Sequence5&amp; lhs,
        const balb::Sequence5&amp; rhs)
{
    return  lhs.element1() == rhs.element1()
         &amp;&amp; lhs.element2() == rhs.element2()
         &amp;&amp; lhs.element3() == rhs.element3()
         &amp;&amp; lhs.element4() == rhs.element4()
         &amp;&amp; lhs.element5() == rhs.element5()
         &amp;&amp; lhs.element6() == rhs.element6()
         &amp;&amp; lhs.element7() == rhs.element7();
}

inline
bool balb::operator!=(
        const balb::Sequence5&amp; lhs,
        const balb::Sequence5&amp; rhs)
{
    return  lhs.element1() != rhs.element1()
         || lhs.element2() != rhs.element2()
         || lhs.element3() != rhs.element3()
         || lhs.element4() != rhs.element4()
         || lhs.element5() != rhs.element5()
         || lhs.element6() != rhs.element6()
         || lhs.element7() != rhs.element7();
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::Sequence5&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::Sequence6&amp; lhs,
        const balb::Sequence6&amp; rhs)
{
    return  lhs.element1() == rhs.element1()
         &amp;&amp; lhs.element2() == rhs.element2()
         &amp;&amp; lhs.element3() == rhs.element3()
         &amp;&amp; lhs.element4() == rhs.element4()
         &amp;&amp; lhs.element5() == rhs.element5()
         &amp;&amp; lhs.element6() == rhs.element6()
         &amp;&amp; lhs.element7() == rhs.element7()
         &amp;&amp; lhs.element8() == rhs.element8()
         &amp;&amp; lhs.element9() == rhs.element9()
         &amp;&amp; lhs.element10() == rhs.element10()
         &amp;&amp; lhs.element11() == rhs.element11()
         &amp;&amp; lhs.element12() == rhs.element12()
         &amp;&amp; lhs.element13() == rhs.element13()
         &amp;&amp; lhs.element14() == rhs.element14()
         &amp;&amp; lhs.element15() == rhs.element15();
}

inline
bool balb::operator!=(
        const balb::Sequence6&amp; lhs,
        const balb::Sequence6&amp; rhs)
{
    return  lhs.element1() != rhs.element1()
         || lhs.element2() != rhs.element2()
         || lhs.element3() != rhs.element3()
         || lhs.element4() != rhs.element4()
         || lhs.element5() != rhs.element5()
         || lhs.element6() != rhs.element6()
         || lhs.element7() != rhs.element7()
         || lhs.element8() != rhs.element8()
         || lhs.element9() != rhs.element9()
         || lhs.element10() != rhs.element10()
         || lhs.element11() != rhs.element11()
         || lhs.element12() != rhs.element12()
         || lhs.element13() != rhs.element13()
         || lhs.element14() != rhs.element14()
         || lhs.element15() != rhs.element15();
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::Sequence6&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::Choice3&amp; lhs,
        const balb::Choice3&amp; rhs)
{
    typedef balb::Choice3 Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
          case Class::e_SELECTION_ID_SELECTION1:
            return lhs.selection1() == rhs.selection1();
          case Class::e_SELECTION_ID_SELECTION2:
            return lhs.selection2() == rhs.selection2();
          case Class::e_SELECTION_ID_SELECTION3:
            return lhs.selection3() == rhs.selection3();
          case Class::e_SELECTION_ID_SELECTION4:
            return lhs.selection4() == rhs.selection4();
          default:
            BSLS_ASSERT(Class::e_SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;                                              // RETURN
        }
    }
    else {
        return false;                                                 // RETURN
   }
}

inline
bool balb::operator!=(
        const balb::Choice3&amp; lhs,
        const balb::Choice3&amp; rhs)
{
    return !(lhs == rhs);
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::Choice3&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::SequenceWithAnonymityChoice&amp; lhs,
        const balb::SequenceWithAnonymityChoice&amp; rhs)
{
    typedef balb::SequenceWithAnonymityChoice Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
          case Class::e_SELECTION_ID_SELECTION1:
            return lhs.selection1() == rhs.selection1();
          case Class::e_SELECTION_ID_SELECTION2:
            return lhs.selection2() == rhs.selection2();
          case Class::e_SELECTION_ID_SELECTION3:
            return lhs.selection3() == rhs.selection3();
          case Class::e_SELECTION_ID_SELECTION4:
            return lhs.selection4() == rhs.selection4();
          default:
            BSLS_ASSERT(Class::e_SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;                                              // RETURN
        }
    }
    else {
        return false;                                                 // RETURN
   }
}

inline
bool balb::operator!=(
        const balb::SequenceWithAnonymityChoice&amp; lhs,
        const balb::SequenceWithAnonymityChoice&amp; rhs)
{
    return !(lhs == rhs);
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::SequenceWithAnonymityChoice&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::Choice1&amp; lhs,
        const balb::Choice1&amp; rhs)
{
    typedef balb::Choice1 Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
          case Class::e_SELECTION_ID_SELECTION1:
            return lhs.selection1() == rhs.selection1();
          case Class::e_SELECTION_ID_SELECTION2:
            return lhs.selection2() == rhs.selection2();
          case Class::e_SELECTION_ID_SELECTION3:
            return lhs.selection3() == rhs.selection3();
          case Class::e_SELECTION_ID_SELECTION4:
            return lhs.selection4() == rhs.selection4();
          default:
            BSLS_ASSERT(Class::e_SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;                                              // RETURN
        }
    }
    else {
        return false;                                                 // RETURN
   }
}

inline
bool balb::operator!=(
        const balb::Choice1&amp; lhs,
        const balb::Choice1&amp; rhs)
{
    return !(lhs == rhs);
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::Choice1&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::Choice2&amp; lhs,
        const balb::Choice2&amp; rhs)
{
    typedef balb::Choice2 Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
          case Class::e_SELECTION_ID_SELECTION1:
            return lhs.selection1() == rhs.selection1();
          case Class::e_SELECTION_ID_SELECTION2:
            return lhs.selection2() == rhs.selection2();
          case Class::e_SELECTION_ID_SELECTION3:
            return lhs.selection3() == rhs.selection3();
          case Class::e_SELECTION_ID_SELECTION4:
            return lhs.selection4() == rhs.selection4();
          default:
            BSLS_ASSERT(Class::e_SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;                                              // RETURN
        }
    }
    else {
        return false;                                                 // RETURN
   }
}

inline
bool balb::operator!=(
        const balb::Choice2&amp; lhs,
        const balb::Choice2&amp; rhs)
{
    return !(lhs == rhs);
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::Choice2&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::Sequence4&amp; lhs,
        const balb::Sequence4&amp; rhs)
{
    return  lhs.element1() == rhs.element1()
         &amp;&amp; lhs.element2() == rhs.element2()
         &amp;&amp; lhs.element3() == rhs.element3()
         &amp;&amp; lhs.element4() == rhs.element4()
         &amp;&amp; lhs.element5() == rhs.element5()
         &amp;&amp; lhs.element6() == rhs.element6()
         &amp;&amp; lhs.element7() == rhs.element7()
         &amp;&amp; lhs.element8() == rhs.element8()
         &amp;&amp; lhs.element9() == rhs.element9()
         &amp;&amp; lhs.element10() == rhs.element10()
         &amp;&amp; lhs.element11() == rhs.element11()
         &amp;&amp; lhs.element12() == rhs.element12()
         &amp;&amp; lhs.element13() == rhs.element13()
         &amp;&amp; lhs.element14() == rhs.element14()
         &amp;&amp; lhs.element15() == rhs.element15()
         &amp;&amp; lhs.element16() == rhs.element16()
         &amp;&amp; lhs.element17() == rhs.element17()
         &amp;&amp; lhs.element18() == rhs.element18()
         &amp;&amp; lhs.element19() == rhs.element19();
}

inline
bool balb::operator!=(
        const balb::Sequence4&amp; lhs,
        const balb::Sequence4&amp; rhs)
{
    return  lhs.element1() != rhs.element1()
         || lhs.element2() != rhs.element2()
         || lhs.element3() != rhs.element3()
         || lhs.element4() != rhs.element4()
         || lhs.element5() != rhs.element5()
         || lhs.element6() != rhs.element6()
         || lhs.element7() != rhs.element7()
         || lhs.element8() != rhs.element8()
         || lhs.element9() != rhs.element9()
         || lhs.element10() != rhs.element10()
         || lhs.element11() != rhs.element11()
         || lhs.element12() != rhs.element12()
         || lhs.element13() != rhs.element13()
         || lhs.element14() != rhs.element14()
         || lhs.element15() != rhs.element15()
         || lhs.element16() != rhs.element16()
         || lhs.element17() != rhs.element17()
         || lhs.element18() != rhs.element18()
         || lhs.element19() != rhs.element19();
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::Sequence4&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::Sequence1&amp; lhs,
        const balb::Sequence1&amp; rhs)
{
    return  lhs.element1() == rhs.element1()
         &amp;&amp; lhs.element2() == rhs.element2()
         &amp;&amp; lhs.element3() == rhs.element3()
         &amp;&amp; lhs.element4() == rhs.element4()
         &amp;&amp; lhs.element5() == rhs.element5();
}

inline
bool balb::operator!=(
        const balb::Sequence1&amp; lhs,
        const balb::Sequence1&amp; rhs)
{
    return  lhs.element1() != rhs.element1()
         || lhs.element2() != rhs.element2()
         || lhs.element3() != rhs.element3()
         || lhs.element4() != rhs.element4()
         || lhs.element5() != rhs.element5();
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::Sequence1&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::Sequence2&amp; lhs,
        const balb::Sequence2&amp; rhs)
{
    return  lhs.element1() == rhs.element1()
         &amp;&amp; lhs.element2() == rhs.element2()
         &amp;&amp; lhs.element3() == rhs.element3()
         &amp;&amp; lhs.element4() == rhs.element4()
         &amp;&amp; lhs.element5() == rhs.element5();
}

inline
bool balb::operator!=(
        const balb::Sequence2&amp; lhs,
        const balb::Sequence2&amp; rhs)
{
    return  lhs.element1() != rhs.element1()
         || lhs.element2() != rhs.element2()
         || lhs.element3() != rhs.element3()
         || lhs.element4() != rhs.element4()
         || lhs.element5() != rhs.element5();
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::Sequence2&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::SequenceWithAnonymityChoice2&amp; lhs,
        const balb::SequenceWithAnonymityChoice2&amp; rhs)
{
    typedef balb::SequenceWithAnonymityChoice2 Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
          case Class::e_SELECTION_ID_SELECTION7:
            return lhs.selection7() == rhs.selection7();
          case Class::e_SELECTION_ID_SELECTION8:
            return lhs.selection8() == rhs.selection8();
          default:
            BSLS_ASSERT(Class::e_SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;                                              // RETURN
        }
    }
    else {
        return false;                                                 // RETURN
   }
}

inline
bool balb::operator!=(
        const balb::SequenceWithAnonymityChoice2&amp; lhs,
        const balb::SequenceWithAnonymityChoice2&amp; rhs)
{
    return !(lhs == rhs);
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::SequenceWithAnonymityChoice2&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::SequenceWithAnonymity&amp; lhs,
        const balb::SequenceWithAnonymity&amp; rhs)
{
    return  lhs.choice() == rhs.choice()
         &amp;&amp; lhs.choice1() == rhs.choice1()
         &amp;&amp; lhs.choice2() == rhs.choice2()
         &amp;&amp; lhs.element4() == rhs.element4();
}

inline
bool balb::operator!=(
        const balb::SequenceWithAnonymity&amp; lhs,
        const balb::SequenceWithAnonymity&amp; rhs)
{
    return  lhs.choice() != rhs.choice()
         || lhs.choice1() != rhs.choice1()
         || lhs.choice2() != rhs.choice2()
         || lhs.element4() != rhs.element4();
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::SequenceWithAnonymity&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::FeatureTestMessage&amp; lhs,
        const balb::FeatureTestMessage&amp; rhs)
{
    typedef balb::FeatureTestMessage Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
          case Class::e_SELECTION_ID_SELECTION1:
            return lhs.selection1() == rhs.selection1();
          case Class::e_SELECTION_ID_SELECTION2:
            return lhs.selection2() == rhs.selection2();
          case Class::e_SELECTION_ID_SELECTION3:
            return lhs.selection3() == rhs.selection3();
          case Class::e_SELECTION_ID_SELECTION4:
            return lhs.selection4() == rhs.selection4();
          case Class::e_SELECTION_ID_SELECTION5:
            return lhs.selection5() == rhs.selection5();
          case Class::e_SELECTION_ID_SELECTION6:
            return lhs.selection6() == rhs.selection6();
          case Class::e_SELECTION_ID_SELECTION7:
            return lhs.selection7() == rhs.selection7();
          case Class::e_SELECTION_ID_SELECTION8:
            return lhs.selection8() == rhs.selection8();
          case Class::e_SELECTION_ID_SELECTION9:
            return lhs.selection9() == rhs.selection9();
          case Class::e_SELECTION_ID_SELECTION10:
            return lhs.selection10() == rhs.selection10();
          case Class::e_SELECTION_ID_SELECTION11:
            return lhs.selection11() == rhs.selection11();
          default:
            BSLS_ASSERT(Class::e_SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;                                              // RETURN
        }
    }
    else {
        return false;                                                 // RETURN
   }
}

inline
bool balb::operator!=(
        const balb::FeatureTestMessage&amp; lhs,
        const balb::FeatureTestMessage&amp; rhs)
{
    return !(lhs == rhs);
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::FeatureTestMessage&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::Request&amp; lhs,
        const balb::Request&amp; rhs)
{
    typedef balb::Request Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
          case Class::e_SELECTION_ID_SIMPLE_REQUEST:
            return lhs.simpleRequest() == rhs.simpleRequest();
          case Class::e_SELECTION_ID_FEATURE_REQUEST:
            return lhs.featureRequest() == rhs.featureRequest();
          default:
            BSLS_ASSERT(Class::e_SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;                                              // RETURN
        }
    }
    else {
        return false;                                                 // RETURN
   }
}

inline
bool balb::operator!=(
        const balb::Request&amp; lhs,
        const balb::Request&amp; rhs)
{
    return !(lhs == rhs);
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::Request&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}


inline
bool balb::operator==(
        const balb::Response&amp; lhs,
        const balb::Response&amp; rhs)
{
    typedef balb::Response Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
          case Class::e_SELECTION_ID_RESPONSE_DATA:
            return lhs.responseData() == rhs.responseData();
          case Class::e_SELECTION_ID_FEATURE_RESPONSE:
            return lhs.featureResponse() == rhs.featureResponse();
          default:
            BSLS_ASSERT(Class::e_SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;                                              // RETURN
        }
    }
    else {
        return false;                                                 // RETURN
   }
}

inline
bool balb::operator!=(
        const balb::Response&amp; lhs,
        const balb::Response&amp; rhs)
{
    return !(lhs == rhs);
}

inline
bsl::ostream&amp; balb::operator&lt;&lt;(
        bsl::ostream&amp; stream,
        const balb::Response&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}

}  // close enterprise namespace
#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
