<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// ball_defaultattributecontainer.h                                   -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALL_DEFAULTATTRIBUTECONTAINER
#define INCLUDED_BALL_DEFAULTATTRIBUTECONTAINER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a default container for storing attribute name/value pairs.
//
//@CLASSES:
//  ball::DefaultAttributeContainer: a collection of unique attributes
//
//@SEE_ALSO: ball_attributecontainer
//
//@DESCRIPTION: This component provides a default implementation of the
// &#39;ball::AttributeContainer&#39; protocol, &#39;ball::DefaultAttributeContainer&#39;
// providing an &#39;unordered_set&#39;-based container of &#39;ball::Attribute&#39; values.
// Each attribute within the default attribute container holds a
// (case-sensitive) name and a value, which may be an &#39;int&#39;, a 64-bit integer,
// or a &#39;bsl::string&#39;.
//
///Thread Safety
///-------------
// &#39;ball::DefaultAttributeContainer&#39; is *const* *thread-safe*, meaning that
// accessors may be invoked concurrently from different threads, but it is not
// safe to access or modify a &#39;ball::DefaultAttributeContainer&#39; in one thread
// while another thread modifies the same object.
//
///Usage
///-----
// The following code snippets illustrate the basic usage of a
// &#39;ball::DefaultAttributeContainer&#39;.  A &#39;ball::DefaultAttributeContainer&#39;
// initially has no attributes when created by the default constructor:
//..
//    ball::DefaultAttributeContainer attributeContainer;
//..
// Let&#39;s now create some attributes and add them to the attribute map:
//..
//    ball::Attribute a1(&quot;uuid&quot;, 1111);
//    ball::Attribute a2(&quot;sid&quot;, &quot;111-1&quot;);
//    assert(true == attributeContainer.addAttribute(a1));
//    assert(true == attributeContainer.addAttribute(a2));
//..
// New attributes with a name that already exists in the map can be added, as
// long as they have a different value:
//..
//    ball::Attribute a3(&quot;uuid&quot;, 2222);
//    ball::Attribute a4(&quot;sid&quot;, &quot;222-2&quot;);
//    assert(true == attributeContainer.addAttribute(a3));
//    assert(true == attributeContainer.addAttribute(a4));
//..
// But attributes having the same name and value cannot be added:
//..
//    ball::Attribute a5(&quot;uuid&quot;, 1111);                 // same as &#39;a1&#39;
//    assert(false == attributeContainer.addAttribute(a5));
//..
// Note that the attribute name is case-sensitive:
//..
//    ball::Attribute a6(&quot;UUID&quot;, 1111);
//    assert(true == attributeContainer.addAttribute(a6));
//..
// Existing attributes can be looked up by the &#39;hasValue&#39; method:
//..
//    assert(true == defaultattributecontainer.hasValue(a1));
//    assert(true == defaultattributecontainer.hasValue(a2));
//    assert(true == defaultattributecontainer.hasValue(a3));
//    assert(true == defaultattributecontainer.hasValue(a4));
//    assert(true == defaultattributecontainer.hasValue(a5));
//    assert(true == defaultattributecontainer.hasValue(a6));
//..
// Or removed by the &#39;removeAttribute&#39; method:
//..
//    defaultattributecontainer.removeAttribute(a1);
//    assert(false == attributeContainer.hasValue(a1));
//..
// Finally, the &#39;ball::DefaultAttributeContainer&#39; class provides an iterator:
//..
//    ball::DefaultAttributeContainer::const_iterator iter =
//                                                  attributeContainer.begin();
//    for ( ; iter != attributeContainer.end(); ++iter ) {
//        bsl::cout &lt;&lt; *iter &lt;&lt; bsl::endl;
//    }
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BALL_ATTRIBUTE
#include &lt;ball_attribute.h&gt;
#endif

#ifndef INCLUDED_BALL_ATTRIBUTECONTAINER
#include &lt;ball_attributecontainer.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSL_FUNCTIONAL
#include &lt;bsl_functional.h&gt;
#endif

#ifndef INCLUDED_BSL_UNORDERED_SET
#include &lt;bsl_unordered_set.h&gt;
#endif

namespace BloombergLP {

namespace ball {
                    // ===============================
                    // class DefaultAttributeContainer
                    // ===============================

class DefaultAttributeContainer : public AttributeContainer {
    // A &#39;DefaultAttributeContainer&#39; object contains a collection of (unique)
    // attributes values.

    // PRIVATE TYPES
    struct AttributeHash
        // A hash functor for &#39;Attribute&#39;
    {
      private:
        static int s_hashtableSize;  // default hashtable size for which the
                                     // hash value is calculated
      public:
        int operator()(const Attribute&amp; attribute) const
            // Return the hash value of the specified &#39;attribute&#39;.
        {
            return Attribute::hash(attribute, s_hashtableSize);
        }
    };

    // CLASS DATA
    static int                   s_initialSize;   // initial size of the
                                                  // attribute map

    // DATA
    bsl::unordered_set&lt;Attribute, AttributeHash&gt;
                                 d_attributeSet;  // hash table that stores
                                                  // all the attributes
                                                  // managed by this object

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(DefaultAttributeContainer,
                                   bslma::UsesBslmaAllocator);

    // TYPES
    typedef bsl::unordered_set&lt;Attribute, AttributeHash&gt;::const_iterator
                                 const_iterator;  // type of iterator for
                                                  // iterating through the
                                                  // non-modifiable attributes
                                                  // managed by this object

    // CREATORS
    explicit DefaultAttributeContainer(bslma::Allocator *basicAllocator = 0);
        // Create an empty &#39;DefaultAttributeContainer&#39; object.  Optionally
        // specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator
        // will be used.

    DefaultAttributeContainer(
                    const DefaultAttributeContainer&amp;  original,
                    bslma::Allocator                 *basicAllocator = 0);
        // Create a &#39;DefaultAttributeContainer&#39; object having the same value as
        // the specified &#39;original&#39; object.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator will be used.

    virtual ~DefaultAttributeContainer();
        // Destroy this object.

    // MANIPULATORS
    DefaultAttributeContainer&amp; operator=(
                                    const DefaultAttributeContainer&amp; rhs);
        // Assign the value of the specified &#39;rhs&#39; object to this object.

    bool addAttribute(const Attribute&amp; value);
        // Add an attribute having the specified &#39;value&#39; to this object.
        // Return &#39;true&#39; on success and &#39;false&#39; if an attribute having the
        // same &#39;value&#39; already exists in this object.

    bool removeAttribute(const Attribute&amp; value);
        // Remove the attribute having the specified &#39;value&#39; from this object.
        // Return the &#39;true&#39; on success and &#39;false&#39; if the attribute having the
        // &#39;value&#39; does not exist in this object.

    void removeAllAttributes();
        // Remove every attribute in this attribute set.

    // ACCESSORS
    int numAttributes() const;
        // Return the number of attributes managed by this object.

    virtual bool hasValue(const Attribute&amp; value) const;
        // Return &#39;true&#39; if the attribute having specified &#39;value&#39; exists in
        // this object, and &#39;false&#39; otherwise.

    const_iterator begin() const;
        // Return an iterator pointing at the beginning of the (unordered)
        // sequence of attributes managed by this map, or &#39;end()&#39; if
        // &#39;numAttributes()&#39; is 0.

    const_iterator end() const;
        // Return an iterator pointing at one past the end of the map.

    virtual bsl::ostream&amp; print(bsl::ostream&amp; stream,
                                int           level = 0,
                                int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // (absolute value of) the optionally specified indentation &#39;level&#39;
        // and return a reference to &#39;stream&#39;.  If &#39;level&#39; is specified,
        // optionally specify &#39;spacesPerLevel&#39;, the number of spaces per
        // indentation level for this and all of its nested objects.  If
        // &#39;level&#39; is negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, format the entire output on one line,
        // suppressing all but the initial indentation (as governed by
        // &#39;level&#39;).  If &#39;stream&#39; is not valid on entry, this operation has no
        // effect.
};

// FREE OPERATORS
bool operator==(const DefaultAttributeContainer&amp; lhs,
                const DefaultAttributeContainer&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;DefaultAttributeContainer&#39; objects
    // have the same value if they contain the same number of (unique)
    // attributes, and every attribute that appears in one object also appears
    // in the other.

bool operator!=(const DefaultAttributeContainer&amp; lhs,
                const DefaultAttributeContainer&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same value, and &#39;false&#39; otherwise.  Two &#39;DefaultAttributeContainer&#39;
    // objects do not have the same value if they contain differing numbers of
    // attributes or if there is at least one attribute that appears in one
    // object, but not in the other.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                    output,
                         const DefaultAttributeContainer&amp; attributeContainer);
    // Write the value of the specified &#39;attributeContainer&#39; to the specified
    // &#39;output&#39; stream in some single-line, human readable format.  Return the
    // &#39;output&#39; stream.

// ============================================================================
//                              INLINE DEFINITIONS
// ============================================================================

                    // -------------------------------
                    // class DefaultAttributeContainer
                    // -------------------------------

// CREATORS
inline
DefaultAttributeContainer::DefaultAttributeContainer(
                                              bslma::Allocator *basicAllocator)
: d_attributeSet(s_initialSize,                    // initial size
                 AttributeHash(),                  // hash functor
                 bsl::equal_to&lt;Attribute&gt;(),       // equal functor
                 basicAllocator)
{
}

inline
DefaultAttributeContainer::DefaultAttributeContainer(
                            const DefaultAttributeContainer&amp;  original,
                            bslma::Allocator                 *basicAllocator)
: d_attributeSet(original.d_attributeSet, basicAllocator)
{
}

inline
DefaultAttributeContainer::~DefaultAttributeContainer()
{
}

// MANIPULATORS
inline
bool DefaultAttributeContainer::addAttribute(const Attribute&amp; value)
{
    return d_attributeSet.insert(value).second;
}

inline
bool DefaultAttributeContainer::removeAttribute(const Attribute&amp; value)
{
    return d_attributeSet.erase(value) != 0;
}

inline
void DefaultAttributeContainer::removeAllAttributes()
{
    d_attributeSet.clear();
}

// ACCESSORS
inline
int DefaultAttributeContainer::numAttributes() const
{
    return static_cast&lt;int&gt;(d_attributeSet.size());
}

inline
DefaultAttributeContainer::const_iterator
DefaultAttributeContainer::begin() const
{
    return d_attributeSet.begin();
}

inline
DefaultAttributeContainer::const_iterator
DefaultAttributeContainer::end() const
{
    return d_attributeSet.end();
}
}  // close package namespace

// FREE OPERATORS
inline
bsl::ostream&amp; ball::operator&lt;&lt;(
                           bsl::ostream&amp;                    output,
                           const DefaultAttributeContainer&amp; attributeContainer)
{
    return attributeContainer.print(output, 0, -1);
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
