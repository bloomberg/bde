<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: Class bslma::TestAllocator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslma.html">bslma</a>      </li>
      <li><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslma::TestAllocator Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslma::TestAllocator" --><!-- doxytag: inherits="bslma::Allocator" -->
<p><code>#include &lt;<a class="el" href="bslma__testallocator_8h_source.html">bslma_testallocator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bslma::TestAllocator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbslma_1_1TestAllocator.png" usemap="#bslma::TestAllocator_map" alt=""/>
  <map id="bslma::TestAllocator_map" name="bslma::TestAllocator_map">
<area href="classbslma_1_1Allocator.html" alt="bslma::Allocator" shape="rect" coords="0,0,124,24"/>
</map>
</div>

<p><a href="classbslma_1_1TestAllocator-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbsls_1_1Types.html#a6f54590881ef3285caf09a9ec4498046">bsls::Types::size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a13a69799592672990a79e447dce335f0">TestAllocator</a> (<a class="el" href="classbslma_1_1Allocator.html">Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a00d188c75c26265b6cf504df568198c3">TestAllocator</a> (const char *name, <a class="el" href="classbslma_1_1Allocator.html">Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#ab317948acea00e734975db3f737a6a78">TestAllocator</a> (bool verboseFlag, <a class="el" href="classbslma_1_1Allocator.html">Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a5bd24d56b10a1da378a3b913c14dd2ea">TestAllocator</a> (const char *name, bool verboseFlag, <a class="el" href="classbslma_1_1Allocator.html">Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a886cbc4af40c9dfcf8da71dc8b2b6984">~TestAllocator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#adadeba443e1ea37730a9cf936a600e56">allocate</a> (<a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a> size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#aa3d86f105cc1a797cfa5ad9e2bbf6825">deallocate</a> (void *address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a1409cd5b5331de783338541349844845">setAllocationLimit</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> limit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#ab558d4e20e4a93c43ea86a4f6cf71042">setNoAbort</a> (bool flagValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a9bfba3816fa253aa84007338caf42b95">setQuiet</a> (bool flagValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#abaa077259dcb16401f578e07190bca70">setVerbose</a> (bool flagValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a681f647df326755248ced9b9d3612f93">allocationLimit</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#aca235922bee2332a08e7eac17f053115">isNoAbort</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#ac4fa6f66cf7fc8c1a37f9f9598574ac4">isQuiet</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a1d4ffcc29782d76674dfec27632f1f72">isVerbose</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a1783bf44ce14fee602c77f156f5afb56">lastAllocatedAddress</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#ad7b0a579964e322107270e7cfbaae16e">lastAllocatedNumBytes</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a5c2ed85eb2f00233910a3c38a50d0c05">lastDeallocatedAddress</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a2c83258221990a0dd52efb9d5e9ee0b5">lastDeallocatedNumBytes</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#ae7a9b088affd3d36f13c1bebce049c3e">name</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a464a6bc3f5125e8b0d303efbd339afec">numAllocations</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#af33e8b7b63178f9f1c62f55cd9da1273">numBlocksInUse</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a41291992de42a9f5d7fa09c122aa7ef9">numBlocksMax</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a3694f1fba1d42900072d508ad79dbd37">numBlocksTotal</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#adc39da49e35940d8b8bddc7cd2933116">numBoundsErrors</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a55ecf964b4e4c5d0795cd4aaf3029be3">numBytesInUse</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#af2d1d3784de378c207cf12c71d92b338">numBytesMax</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a4e75ec898fdab7a4f209d599600f304a">numBytesTotal</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#ad5ded5e63fce92413f6c8fe1d0c55cbd">numDeallocations</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#af283f8d8facf0bdfc98f193d06918985">numMismatches</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a86fb90ca67fd81a3ae834e7077206d66">print</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1TestAllocator.html#a2c56491341aaea7ee13246940bc5eaf8">status</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a0e51fc2d107684523cc66bf65293dc37">deleteObject</a> (const TYPE *object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#abeccfe6cfd8205faf528a8e12f97aebe">deleteObjectRaw</a> (const TYPE *object)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a404c0ae3c51f8122a6ca3a62aba8dbf1">throwBadAlloc</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class defines a concrete "test" allocator mechanism that implements the <code><a class="el" href="classbslma_1_1Allocator.html">Allocator</a></code> protocol, and provides instrumentation to track (1) the number of blocks/bytes currently in use, (2) the maximum number of blocks/bytes that have been outstanding at any one time, and (3) the cumulative number of blocks/bytes that have ever been allocated by this test allocator object. The accumulated statistics are based solely on the number of bytes requested. Additional testing facilities include allocation limits, verbosity modes, status, and automated report printing.</p>
<p>Note that, unlike many other allocators, this allocator does DOES NOT rely on the currently installed default allocator (see <code>bslma_default</code>) at all, but instead -- by default -- uses <code><a class="el" href="classbslma_1_1MallocFreeAllocator.html">MallocFreeAllocator</a></code> singleton, which in turn calls the C Standard Library functions <code>malloc</code> and <code>free</code> as needed. Clients may, however, override this allocator by supplying (at construction) any other allocator implementing the <code><a class="el" href="classbslma_1_1Allocator.html">Allocator</a></code> protocol. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a07cd3ddf3fba145a0469a4e867047287"></a><!-- doxytag: member="bslma::TestAllocator::size_type" ref="a07cd3ddf3fba145a0469a4e867047287" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbsls_1_1Types.html#a6f54590881ef3285caf09a9ec4498046">bsls::Types::size_type</a> <a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">bslma::Allocator::size_type</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>TBD change to unsigned? </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a13a69799592672990a79e447dce335f0"></a><!-- doxytag: member="bslma::TestAllocator::TestAllocator" ref="a13a69799592672990a79e447dce335f0" args="(Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslma::TestAllocator::TestAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a00d188c75c26265b6cf504df568198c3"></a><!-- doxytag: member="bslma::TestAllocator::TestAllocator" ref="a00d188c75c26265b6cf504df568198c3" args="(const char *name, Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslma::TestAllocator::TestAllocator </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab317948acea00e734975db3f737a6a78"></a><!-- doxytag: member="bslma::TestAllocator::TestAllocator" ref="ab317948acea00e734975db3f737a6a78" args="(bool verboseFlag, Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslma::TestAllocator::TestAllocator </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>verboseFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5bd24d56b10a1da378a3b913c14dd2ea"></a><!-- doxytag: member="bslma::TestAllocator::TestAllocator" ref="a5bd24d56b10a1da378a3b913c14dd2ea" args="(const char *name, bool verboseFlag, Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslma::TestAllocator::TestAllocator </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>verboseFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an instrumented "test" allocator. Optionally specify a <code>name</code> (associated with this object) to be included in diagnostic messages written to <code>stdout</code>, thereby distinguishing this test allocator from others that might be used in the same program. If <code>name</code> is 0 (or not specified), no distinguishing name is incorporated in diagnostics. Optionally specify a <code>verboseFlag</code> indicating whether this test allocator should automatically report all allocation/deallocation events to <code>stdout</code> and print accumulated statistics on destruction. If <code>verboseFlag</code> is <code>false</code> (or not specified), allocation/deallocation and summary messages will not be written automatically. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the <code><a class="el" href="classbslma_1_1MallocFreeAllocator.html">MallocFreeAllocator</a></code> singleton is used. </p>

</div>
</div>
<a class="anchor" id="a886cbc4af40c9dfcf8da71dc8b2b6984"></a><!-- doxytag: member="bslma::TestAllocator::~TestAllocator" ref="a886cbc4af40c9dfcf8da71dc8b2b6984" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslma::TestAllocator::~TestAllocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this allocator. In verbose mode, print all contained state values of this allocator object to <code>stdout</code>. Except in quiet mode, automatically report any memory leaks or mismatched deallocations to <code>stdout</code>. Abort if either <code>numBlocksInUse</code> or <code>numBytesInUse</code> return non-zero unless in no-abort mode or quiet mode. Note that, in all cases, destroying this object has no effect on outstanding memory blocks allocated from this test allocator (and may result in memory leaks -- e.g., if the (default) <code><a class="el" href="classbslma_1_1MallocFreeAllocator.html">MallocFreeAllocator</a></code> singleton was used). </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="adadeba443e1ea37730a9cf936a600e56"></a><!-- doxytag: member="bslma::TestAllocator::allocate" ref="adadeba443e1ea37730a9cf936a600e56" args="(size_type size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bslma::TestAllocator::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a newly-allocated block of memory of the specified positive <code>size</code> (in bytes). If <code>size</code> is 0, a null pointer is returned with no other effect (e.g., on allocation/deallocation statistics). Otherwise, invoke the <code>allocate</code> method of the allocator supplied at construction, increment the number of currently (and cumulatively) allocated blocks and increase the number of currently allocated bytes by <code>size</code>. Update all other fields accordingly. </p>

<p>Implements <a class="el" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">bslma::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="aa3d86f105cc1a797cfa5ad9e2bbf6825"></a><!-- doxytag: member="bslma::TestAllocator::deallocate" ref="aa3d86f105cc1a797cfa5ad9e2bbf6825" args="(void *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::TestAllocator::deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the memory block at the specified <code>address</code> back to this allocator. If <code>address</code> is 0, this function has no effect (e.g., on allocation/deallocation statistics). Otherwise, if the memory at <code>address</code> is consistent with being allocated from this test allocator, decrement the number of currently allocated blocks, and decrease the number of currently allocated bytes by the size (in bytes) originally requested for this block. Although technically undefined behavior, if the memory can be determined not to have been allocated from this test allocator, increment the number of mismatches, and -- unless in quiet mode -- immediately report the details of the mismatch to <code>stdout</code> (e.g., as an <code>std::hex</code> memory dump) and abort. </p>

<p>Implements <a class="el" href="classbslma_1_1Allocator.html#a5ff7b0468394849d6824be024f272968">bslma::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a1409cd5b5331de783338541349844845"></a><!-- doxytag: member="bslma::TestAllocator::setAllocationLimit" ref="a1409cd5b5331de783338541349844845" args="(bsls::Types::Int64 limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::TestAllocator::setAllocationLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td>
          <td class="paramname"> <em>limit</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the number of valid allocation requests before an exception is to be thrown for this allocator to the specified <code>limit</code>. If <code>limit</code> is less than 0, no exception is to be thrown. By default, no exception is scheduled. </p>

</div>
</div>
<a class="anchor" id="ab558d4e20e4a93c43ea86a4f6cf71042"></a><!-- doxytag: member="bslma::TestAllocator::setNoAbort" ref="ab558d4e20e4a93c43ea86a4f6cf71042" args="(bool flagValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::TestAllocator::setNoAbort </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>flagValue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the no-abort mode for this test allocator to the specified (boolean) <code>flagValue</code>. <code>If flagValue</code> is <code>true</code>, aborting on fatal errors is suppressed, and the functions simply return. Diagnostics are not affected. Note that this function is provided primarily to enable visual testing of bizarre error messages in this component. </p>

</div>
</div>
<a class="anchor" id="a9bfba3816fa253aa84007338caf42b95"></a><!-- doxytag: member="bslma::TestAllocator::setQuiet" ref="a9bfba3816fa253aa84007338caf42b95" args="(bool flagValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::TestAllocator::setQuiet </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>flagValue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the quiet mode for this test allocator to the specified (boolean) <code>flagValue</code>. If <code>flagValue</code> is <code>true</code>, mismatched allocation, overrun/underrun errors, and memory leak messages will not be displayed to <code>stdout</code> and the process will not abort as a result of such conditions. Note that the default mode is <em>not</em> quiet. Also note that this function is provided primarily to enable testing of this component; in quiet mode, situations that would otherwise abort will just quietly increment the <code>numMismatches</code> and/or <code>numBoundsErrors</code> counters. </p>

</div>
</div>
<a class="anchor" id="abaa077259dcb16401f578e07190bca70"></a><!-- doxytag: member="bslma::TestAllocator::setVerbose" ref="abaa077259dcb16401f578e07190bca70" args="(bool flagValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::TestAllocator::setVerbose </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>flagValue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the verbose mode for this test allocator to the specified (boolean) <code>flagValue</code>. If <code>flagValue</code> is <code>true</code>, all allocation/deallocation events will be reported automatically on <code>stdout</code>, as will accumulated statistics upon destruction of this object. Note that the default mode is <em>not</em> verbose. </p>

</div>
</div>
<a class="anchor" id="a681f647df326755248ced9b9d3612f93"></a><!-- doxytag: member="bslma::TestAllocator::allocationLimit" ref="a681f647df326755248ced9b9d3612f93" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> bslma::TestAllocator::allocationLimit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current number of allocation requests left before an exception is thrown. A negative value indicated that no exception is scheduled. </p>

</div>
</div>
<a class="anchor" id="aca235922bee2332a08e7eac17f053115"></a><!-- doxytag: member="bslma::TestAllocator::isNoAbort" ref="aca235922bee2332a08e7eac17f053115" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bslma::TestAllocator::isNoAbort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this allocator is currently in no-abort mode, and <code>false</code> otherwise. In no-abort mode all diagnostic messages are printed, but all aborts are replaced by return statements. Note that quiet mode implies no-abort mode. </p>

</div>
</div>
<a class="anchor" id="ac4fa6f66cf7fc8c1a37f9f9598574ac4"></a><!-- doxytag: member="bslma::TestAllocator::isQuiet" ref="ac4fa6f66cf7fc8c1a37f9f9598574ac4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bslma::TestAllocator::isQuiet </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this allocator is currently in quiet mode, and <code>false</code> otherwise. In quiet mode, messages about mismatched deallocations, overrun/underrun errors, and memory leaks will be not displayed to <code>stdout</code> and will not cause the program to abort. </p>

</div>
</div>
<a class="anchor" id="a1d4ffcc29782d76674dfec27632f1f72"></a><!-- doxytag: member="bslma::TestAllocator::isVerbose" ref="a1d4ffcc29782d76674dfec27632f1f72" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bslma::TestAllocator::isVerbose </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this allocator is currently in verbose mode, and <code>false</code> otherwise. In verbose mode, all allocation/deallocation events will be reported on <code>stdout</code>, as will summary statistics upon destruction of this object. </p>

</div>
</div>
<a class="anchor" id="a1783bf44ce14fee602c77f156f5afb56"></a><!-- doxytag: member="bslma::TestAllocator::lastAllocatedAddress" ref="a1783bf44ce14fee602c77f156f5afb56" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bslma::TestAllocator::lastAllocatedAddress </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the allocated memory address of the most recent memory request. Return 0 if the request was invalid (e.g., allocate non- positive number of bytes). </p>

</div>
</div>
<a class="anchor" id="ad7b0a579964e322107270e7cfbaae16e"></a><!-- doxytag: member="bslma::TestAllocator::lastAllocatedNumBytes" ref="ad7b0a579964e322107270e7cfbaae16e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a> bslma::TestAllocator::lastAllocatedNumBytes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of bytes of the most recent memory request. Note that this number is always recorded regardless of the validity of the request. </p>

</div>
</div>
<a class="anchor" id="a5c2ed85eb2f00233910a3c38a50d0c05"></a><!-- doxytag: member="bslma::TestAllocator::lastDeallocatedAddress" ref="a5c2ed85eb2f00233910a3c38a50d0c05" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bslma::TestAllocator::lastDeallocatedAddress </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the memory address of the last memory deallocation request. Note that the address is always recorded regardless of the validity of the request. </p>

</div>
</div>
<a class="anchor" id="a2c83258221990a0dd52efb9d5e9ee0b5"></a><!-- doxytag: member="bslma::TestAllocator::lastDeallocatedNumBytes" ref="a2c83258221990a0dd52efb9d5e9ee0b5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a> bslma::TestAllocator::lastDeallocatedNumBytes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of bytes of the most recent memory deallocation request. Return 0 if the request was invalid (e.g., deallocating memory not allocated through this allocator). </p>

</div>
</div>
<a class="anchor" id="ae7a9b088affd3d36f13c1bebce049c3e"></a><!-- doxytag: member="bslma::TestAllocator::name" ref="ae7a9b088affd3d36f13c1bebce049c3e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* bslma::TestAllocator::name </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the name of this test allocator, or 0 if no name was specified at construction. </p>

</div>
</div>
<a class="anchor" id="a464a6bc3f5125e8b0d303efbd339afec"></a><!-- doxytag: member="bslma::TestAllocator::numAllocations" ref="a464a6bc3f5125e8b0d303efbd339afec" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> bslma::TestAllocator::numAllocations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the cumulative number of allocation requests. Note that this number is incremented for every <code>allocate</code> invocation, regardless of the validity of the request. </p>

</div>
</div>
<a class="anchor" id="af33e8b7b63178f9f1c62f55cd9da1273"></a><!-- doxytag: member="bslma::TestAllocator::numBlocksInUse" ref="af33e8b7b63178f9f1c62f55cd9da1273" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> bslma::TestAllocator::numBlocksInUse </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of blocks currently allocated from this object. Note that <code><a class="el" href="classbslma_1_1TestAllocator.html#af33e8b7b63178f9f1c62f55cd9da1273">numBlocksInUse()</a> &lt;= <a class="el" href="classbslma_1_1TestAllocator.html#a41291992de42a9f5d7fa09c122aa7ef9">numBlocksMax()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a41291992de42a9f5d7fa09c122aa7ef9"></a><!-- doxytag: member="bslma::TestAllocator::numBlocksMax" ref="a41291992de42a9f5d7fa09c122aa7ef9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> bslma::TestAllocator::numBlocksMax </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum number of blocks ever allocated from this object at any one time. Note that <code><a class="el" href="classbslma_1_1TestAllocator.html#af33e8b7b63178f9f1c62f55cd9da1273">numBlocksInUse()</a> &lt;= <a class="el" href="classbslma_1_1TestAllocator.html#a41291992de42a9f5d7fa09c122aa7ef9">numBlocksMax()</a> &lt;= <a class="el" href="classbslma_1_1TestAllocator.html#a3694f1fba1d42900072d508ad79dbd37">numBlocksTotal()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a3694f1fba1d42900072d508ad79dbd37"></a><!-- doxytag: member="bslma::TestAllocator::numBlocksTotal" ref="a3694f1fba1d42900072d508ad79dbd37" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> bslma::TestAllocator::numBlocksTotal </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the cumulative number of blocks ever allocated from this object. Note that <code><a class="el" href="classbslma_1_1TestAllocator.html#a41291992de42a9f5d7fa09c122aa7ef9">numBlocksMax()</a> &lt;= <a class="el" href="classbslma_1_1TestAllocator.html#a3694f1fba1d42900072d508ad79dbd37">numBlocksTotal()</a></code>. </p>

</div>
</div>
<a class="anchor" id="adc39da49e35940d8b8bddc7cd2933116"></a><!-- doxytag: member="bslma::TestAllocator::numBoundsErrors" ref="adc39da49e35940d8b8bddc7cd2933116" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> bslma::TestAllocator::numBoundsErrors </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of times memory deallocations have detected that pad areas at the front or back of the user segment had been overwritten. </p>

</div>
</div>
<a class="anchor" id="a55ecf964b4e4c5d0795cd4aaf3029be3"></a><!-- doxytag: member="bslma::TestAllocator::numBytesInUse" ref="a55ecf964b4e4c5d0795cd4aaf3029be3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> bslma::TestAllocator::numBytesInUse </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of bytes currently allocated from this object. Note that <code><a class="el" href="classbslma_1_1TestAllocator.html#a55ecf964b4e4c5d0795cd4aaf3029be3">numBytesInUse()</a> &lt;= <a class="el" href="classbslma_1_1TestAllocator.html#af2d1d3784de378c207cf12c71d92b338">numBytesMax()</a></code>. </p>

</div>
</div>
<a class="anchor" id="af2d1d3784de378c207cf12c71d92b338"></a><!-- doxytag: member="bslma::TestAllocator::numBytesMax" ref="af2d1d3784de378c207cf12c71d92b338" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> bslma::TestAllocator::numBytesMax </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum number of bytes ever allocated from this object at any one time. Note that <code><a class="el" href="classbslma_1_1TestAllocator.html#a55ecf964b4e4c5d0795cd4aaf3029be3">numBytesInUse()</a> &lt;= <a class="el" href="classbslma_1_1TestAllocator.html#af2d1d3784de378c207cf12c71d92b338">numBytesMax()</a> &lt;= <a class="el" href="classbslma_1_1TestAllocator.html#a4e75ec898fdab7a4f209d599600f304a">numBytesTotal()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a4e75ec898fdab7a4f209d599600f304a"></a><!-- doxytag: member="bslma::TestAllocator::numBytesTotal" ref="a4e75ec898fdab7a4f209d599600f304a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> bslma::TestAllocator::numBytesTotal </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the cumulative number of bytes ever allocated from this object. Note that <code><a class="el" href="classbslma_1_1TestAllocator.html#af2d1d3784de378c207cf12c71d92b338">numBytesMax()</a> &lt;= <a class="el" href="classbslma_1_1TestAllocator.html#a4e75ec898fdab7a4f209d599600f304a">numBytesTotal()</a></code>. </p>

</div>
</div>
<a class="anchor" id="ad5ded5e63fce92413f6c8fe1d0c55cbd"></a><!-- doxytag: member="bslma::TestAllocator::numDeallocations" ref="ad5ded5e63fce92413f6c8fe1d0c55cbd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> bslma::TestAllocator::numDeallocations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the cumulative number of deallocation requests. Note that this number is incremented for every <code>deallocate</code> invocation, regardless of the validity of the request. </p>

</div>
</div>
<a class="anchor" id="af283f8d8facf0bdfc98f193d06918985"></a><!-- doxytag: member="bslma::TestAllocator::numMismatches" ref="af283f8d8facf0bdfc98f193d06918985" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> bslma::TestAllocator::numMismatches </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of mismatched memory deallocations that have occurred since this object was created. A memory deallocation is <em>mismatched</em> if that memory was not allocated directly from this allocator. </p>

</div>
</div>
<a class="anchor" id="a86fb90ca67fd81a3ae834e7077206d66"></a><!-- doxytag: member="bslma::TestAllocator::print" ref="a86fb90ca67fd81a3ae834e7077206d66" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::TestAllocator::print </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the accumulated state information held in this allocator to <code>stdout</code> in some reasonable (multi-line) format. </p>

</div>
</div>
<a class="anchor" id="a2c56491341aaea7ee13246940bc5eaf8"></a><!-- doxytag: member="bslma::TestAllocator::status" ref="a2c56491341aaea7ee13246940bc5eaf8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bslma::TestAllocator::status </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 0 on success, and non-zero otherwise: If there have been any mismatched memory deallocations or over/under runs, return the number of such errors that have occurred as a positive number, if the number of blocks and bytes are not both 0, return an arbitrary negative number; else return 0. Note that this function is used to define the criteria for an abort at destruction if quiet mode has not been set. </p>

</div>
</div>
<a class="anchor" id="a404c0ae3c51f8122a6ca3a62aba8dbf1"></a><!-- doxytag: member="bslma::TestAllocator::throwBadAlloc" ref="a404c0ae3c51f8122a6ca3a62aba8dbf1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslma::Allocator::throwBadAlloc </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>TBD does this belong here? </p>

</div>
</div>
<a class="anchor" id="a0e51fc2d107684523cc66bf65293dc37"></a><!-- doxytag: member="bslma::TestAllocator::deleteObject" ref="a0e51fc2d107684523cc66bf65293dc37" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslma::Allocator::deleteObject </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> based on its dynamic type and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is a null pointer. The behavior is undefined unless <code>object</code>, when cast appropriately to <code>void *</code>, was allocated using this allocator and has not already been deallocated. Note that <code>dynamic_cast&lt;void *&gt;(object)</code> is applied if <code>TYPE</code> is polymorphic, and <code>static_cast&lt;void *&gt;(object)</code> is applied otherwise. </p>

</div>
</div>
<a class="anchor" id="abeccfe6cfd8205faf528a8e12f97aebe"></a><!-- doxytag: member="bslma::TestAllocator::deleteObjectRaw" ref="abeccfe6cfd8205faf528a8e12f97aebe" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslma::Allocator::deleteObjectRaw </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is a null pointer. The behavior is undefined unless <code>object</code> was allocated using this allocator, is <b>not</b> a secondary base class pointer -- i.e., the address is (numerically) the same as when it was originally dispensed by this allocator, and has not already been deallocated. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslma__testallocator_8h_source.html">bslma_testallocator.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:53 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
