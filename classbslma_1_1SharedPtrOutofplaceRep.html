<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Class bslma::SharedPtrOutofplaceRep</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslma.html">bslma</a>      </li>
      <li><a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html">bslma::SharedPtrOutofplaceRep&lt; TYPE, DELETER &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslma::SharedPtrOutofplaceRep&lt; TYPE, DELETER &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslma::SharedPtrOutofplaceRep" --><!-- doxytag: inherits="bslma::SharedPtrRep" -->
<p><code>#include &lt;<a class="el" href="bslma__sharedptroutofplacerep_8h_source.html">bslma_sharedptroutofplacerep.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bslma::SharedPtrOutofplaceRep&lt; TYPE, DELETER &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbslma_1_1SharedPtrOutofplaceRep.png" usemap="#bslma::SharedPtrOutofplaceRep&lt; TYPE, DELETER &gt;_map" alt=""/>
  <map id="bslma::SharedPtrOutofplaceRep&lt; TYPE, DELETER &gt;_map" name="bslma::SharedPtrOutofplaceRep&lt; TYPE, DELETER &gt;_map">
<area href="classbslma_1_1SharedPtrRep.html" alt="bslma::SharedPtrRep" shape="rect" coords="0,0,311,24"/>
</map>
</div>

<p><a href="classbslma_1_1SharedPtrOutofplaceRep-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html#ac03bfbb61095d48b0f2b7941cf40d773">disposeObject</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html#a5c683c98e6fdae4d535817a485f32557">disposeRep</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html#a4121bb477fd23c4a1abf5ac501cfd911">getDeleter</a> (const std::type_info &amp;type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html#a86a222a4b8d5bed5599f5443bca4198e">originalPtr</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html#a068ed64318ce1aad177b34cf704708b5">ptr</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#afae38768206afcee65656679fe8b8fea">acquireRef</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#aa94fa844a2bf8be733631a2791edb325">acquireWeakRef</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#a90e082cbd9cd1bf48958ed3e7c2be3b3">releaseRef</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#a51f0354415b31690a01ea69a838680f1">releaseWeakRef</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#a3aee0a92abc9accab03c14100150a1c1">resetCountsRaw</a> (int numSharedReferences, int numWeakReferences)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#a2316b2cd2fa8879d0e44b01a4ab91960">tryAcquireRef</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#a98240123b6422c2ef197a52c68f1083c">hasUniqueOwner</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#a80f93135b7154364119d3f725d957b70">numReferences</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#ab8da02bf77e7c766ee7b8fd45b79f320">numWeakReferences</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html">SharedPtrOutofplaceRep</a><br class="typebreak"/>
&lt; TYPE, DELETER &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html#ad5ae9567401857afc6073f7dc3905ab6">makeOutofplaceRep</a> (TYPE *ptr, const DELETER &amp;deleter, <a class="el" href="classbslma_1_1Allocator.html">Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#a9d4813d43e457fb13dceefdbca5a6661">managedPtrDeleter</a> (void *, void *rep)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE, class DELETER&gt;<br/>
 class bslma::SharedPtrOutofplaceRep&lt; TYPE, DELETER &gt;</h3>

<p>This class provides a concrete implementation of the <code><a class="el" href="classbslma_1_1SharedPtrRep.html">SharedPtrRep</a></code> protocol for out-of-place instances of the parameterized <code>TYPE</code>. Upon destruction of this object, the parameterized <code>DELETER</code> type is invoked on the pointer to the shared object. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad5ae9567401857afc6073f7dc3905ab6"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::makeOutofplaceRep" ref="ad5ae9567401857afc6073f7dc3905ab6" args="(TYPE *ptr, const DELETER &amp;deleter, Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class DELETER&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html">SharedPtrOutofplaceRep</a>&lt;TYPE, DELETER&gt;* <a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html">bslma::SharedPtrOutofplaceRep</a>&lt; TYPE, DELETER &gt;::makeOutofplaceRep </td>
          <td>(</td>
          <td class="paramtype">TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DELETER &amp;&nbsp;</td>
          <td class="paramname"> <em>deleter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a newly created <code><a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html">SharedPtrOutofplaceRep</a></code> object that manages the lifetime of the specified <code>ptr</code>, using the specified <code>deleter</code> to destroy <code>ptr</code>. Optionally, specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Note that the parameterized <code>DELETER</code> type will be used to deallocate the memory pointed to by <code>ptr</code>. </p>

</div>
</div>
<a class="anchor" id="ac03bfbb61095d48b0f2b7941cf40d773"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::disposeObject" ref="ac03bfbb61095d48b0f2b7941cf40d773" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class DELETER&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html">bslma::SharedPtrOutofplaceRep</a>&lt; TYPE, DELETER &gt;::disposeObject </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the object being referred to by this representation. This method is automatically invoked by <code>releaseRef</code> when the number of shared references reaches zero and should not be explicitly invoked otherwise. </p>

<p>Implements <a class="el" href="classbslma_1_1SharedPtrRep.html#ac41472460d942cf114a59f24b3d5655f">bslma::SharedPtrRep</a>.</p>

</div>
</div>
<a class="anchor" id="a5c683c98e6fdae4d535817a485f32557"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::disposeRep" ref="a5c683c98e6fdae4d535817a485f32557" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class DELETER&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html">bslma::SharedPtrOutofplaceRep</a>&lt; TYPE, DELETER &gt;::disposeRep </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this representation object and deallocate the associated memory. This method is automatically invoked by <code>releaseRef</code> and <code>releaseWeakRef</code> when the number of weak references and the number of shared references both reach zero and should not be explicitly invoked otherwise. The behavior is undefined unless <code>disposeObject</code> has already been called for this representation. Note that this <code>disposeRep</code> method effectively serves as the representation object's destructor. </p>

<p>Implements <a class="el" href="classbslma_1_1SharedPtrRep.html#ad80928f0b7b63b0e1631428e561e610f">bslma::SharedPtrRep</a>.</p>

</div>
</div>
<a class="anchor" id="a4121bb477fd23c4a1abf5ac501cfd911"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::getDeleter" ref="a4121bb477fd23c4a1abf5ac501cfd911" args="(const std::type_info &amp;type)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class DELETER&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void* <a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html">bslma::SharedPtrOutofplaceRep</a>&lt; TYPE, DELETER &gt;::getDeleter </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pointer to the deleter stored by the derived representation (if any) if the deleter has the same type as that described by the specified <code>type</code>, and a null pointer otherwise. </p>

<p>Implements <a class="el" href="classbslma_1_1SharedPtrRep.html#a050197382203058fbecd774e633c0831">bslma::SharedPtrRep</a>.</p>

</div>
</div>
<a class="anchor" id="a86a222a4b8d5bed5599f5443bca4198e"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::originalPtr" ref="a86a222a4b8d5bed5599f5443bca4198e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class DELETER&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void* <a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html">bslma::SharedPtrOutofplaceRep</a>&lt; TYPE, DELETER &gt;::originalPtr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the (untyped) address of the modifiable shared object to which this object refers. </p>

<p>Implements <a class="el" href="classbslma_1_1SharedPtrRep.html#a71f48f2e5027c0a6619aed26e1e7b582">bslma::SharedPtrRep</a>.</p>

</div>
</div>
<a class="anchor" id="a068ed64318ce1aad177b34cf704708b5"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::ptr" ref="a068ed64318ce1aad177b34cf704708b5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE, class DELETER&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE* <a class="el" href="classbslma_1_1SharedPtrOutofplaceRep.html">bslma::SharedPtrOutofplaceRep</a>&lt; TYPE, DELETER &gt;::ptr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the modifiable shared object to which this object refers. </p>

</div>
</div>
<a class="anchor" id="a9d4813d43e457fb13dceefdbca5a6661"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::managedPtrDeleter" ref="a9d4813d43e457fb13dceefdbca5a6661" args="(void *, void *rep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslma::SharedPtrRep::managedPtrDeleter </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>rep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the shared reference to an object held by the <code><a class="el" href="classbslma_1_1SharedPtrRep.html">SharedPtrRep</a></code> object which is pointed to be by specified <code>rep</code>. The behavior is undefined unless <code>rep</code> points to an object whose complete type publicly and unambiguously derives from <code><a class="el" href="classbslma_1_1SharedPtrRep.html">SharedPtrRep</a></code>. Note that the first argument is ignored. Also note that this function serves as the managed ptr deleter when converting a <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> to a <code><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a></code>. </p>

</div>
</div>
<a class="anchor" id="afae38768206afcee65656679fe8b8fea"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::acquireRef" ref="afae38768206afcee65656679fe8b8fea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::SharedPtrRep::acquireRef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Atomically acquire a shared reference to the shared object referred to by this representation. The behavior is undefined unless <code>0 &lt; <a class="el" href="classbslma_1_1SharedPtrRep.html#a80f93135b7154364119d3f725d957b70">numReferences()</a></code>. </p>

</div>
</div>
<a class="anchor" id="aa94fa844a2bf8be733631a2791edb325"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::acquireWeakRef" ref="aa94fa844a2bf8be733631a2791edb325" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::SharedPtrRep::acquireWeakRef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Atomically acquire a weak reference to the shared object referred to by this representation. The behavior is undefined unless <code>0 &lt; <a class="el" href="classbslma_1_1SharedPtrRep.html#ab8da02bf77e7c766ee7b8fd45b79f320">numWeakReferences()</a> || 0 &lt; <a class="el" href="classbslma_1_1SharedPtrRep.html#a80f93135b7154364119d3f725d957b70">numReferences()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a90e082cbd9cd1bf48958ed3e7c2be3b3"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::releaseRef" ref="a90e082cbd9cd1bf48958ed3e7c2be3b3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::SharedPtrRep::releaseRef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Atomically release a shared reference to the shared object referred to by this representation, disposing of the shared object if all the shared references to that object are released, and disposing of this representation if all (shared and weak) references to that object are released. The behavior is undefined unless <code>0 &lt; <a class="el" href="classbslma_1_1SharedPtrRep.html#a80f93135b7154364119d3f725d957b70">numReferences()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a51f0354415b31690a01ea69a838680f1"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::releaseWeakRef" ref="a51f0354415b31690a01ea69a838680f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::SharedPtrRep::releaseWeakRef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Atomically release a weak reference to the shared object referred to by this representation, disposing of this representation if all (shared and weak) references to the shared object are released. The behavior is undefined unless <code>0 &lt; <a class="el" href="classbslma_1_1SharedPtrRep.html#ab8da02bf77e7c766ee7b8fd45b79f320">numWeakReferences()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a3aee0a92abc9accab03c14100150a1c1"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::resetCountsRaw" ref="a3aee0a92abc9accab03c14100150a1c1" args="(int numSharedReferences, int numWeakReferences)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::SharedPtrRep::resetCountsRaw </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numSharedReferences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numWeakReferences</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the number of shared references and the number of weak references stored by this representation to the specified <code>numSharedReferences</code> and <code>numWeakReferences</code> respectively. This function is <em>not</em> thread-safe and users must ensure that they serialize access to the <code><a class="el" href="classbslma_1_1SharedPtrRep.html">SharedPtrRep</a></code> object when calling this function. Note that this function updates the counts, but does not dispose of the representation or the object irrespective of the values of <code>numSharedReferences</code> and <code>numWeakReferences</code>. </p>

</div>
</div>
<a class="anchor" id="a2316b2cd2fa8879d0e44b01a4ab91960"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::tryAcquireRef" ref="a2316b2cd2fa8879d0e44b01a4ab91960" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bslma::SharedPtrRep::tryAcquireRef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Atomically acquire a shared reference to the shared object referred to by this representation, if the number of shared references is greater than 0, and do nothing otherwise. Return <code>true</code> if the acquire succeeds, and <code>false</code> otherwise. The behavior is undefined unless <code>0 &lt; <a class="el" href="classbslma_1_1SharedPtrRep.html#ab8da02bf77e7c766ee7b8fd45b79f320">numWeakReferences()</a> || 0 &lt; <a class="el" href="classbslma_1_1SharedPtrRep.html#a80f93135b7154364119d3f725d957b70">numReferences()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a98240123b6422c2ef197a52c68f1083c"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::hasUniqueOwner" ref="a98240123b6422c2ef197a52c68f1083c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bslma::SharedPtrRep::hasUniqueOwner </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if there is only one shared reference and no weak references to the object referred to by this representation, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a80f93135b7154364119d3f725d957b70"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::numReferences" ref="a80f93135b7154364119d3f725d957b70" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bslma::SharedPtrRep::numReferences </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "snapshot" of the current number of shared references to the shared object referred to by this representation object. </p>

</div>
</div>
<a class="anchor" id="ab8da02bf77e7c766ee7b8fd45b79f320"></a><!-- doxytag: member="bslma::SharedPtrOutofplaceRep::numWeakReferences" ref="ab8da02bf77e7c766ee7b8fd45b79f320" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bslma::SharedPtrRep::numWeakReferences </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "snapshot" of the current number of weak references to the shared object referred to by this representation object. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslma__sharedptroutofplacerep_8h_source.html">bslma_sharedptroutofplacerep.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:34 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
