<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslstl_priorityqueue.h                                             -*-C++-*-
#ifndef INCLUDED_BSLSTL_PRIORITYQUEUE
#define INCLUDED_BSLSTL_PRIORITYQUEUE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)


//@PURPOSE: Provide container adapter class template &#39;priority_queue&#39;.
//
//@CLASSES:
//   bslstl::priority_queue: template of highest-priority-first data structure
//
//@SEE_ALSO: bslstl_queue, bslstl_stack
//
//@DESCRIPTION: This component defines a class template, &#39;bsl::priority_queue&#39;,
// holding a container (of a parameterized type &#39;CONTAINER&#39; containing elements
// of another parameterized type &#39;VALUE&#39;), and adapting it to provide
// highest-priority-first priority queue data structure.  The component takes a
// third parameterized type &#39;COMPARATOR&#39; for customized priorities comparison
// between two elements.
//
// An instantiation of &#39;priority_queue&#39; is an allocator-aware, value-semantic
// type whose salient attributes are its size (number of held elements) and the
// sorted sequence of values (of held elements).  If &#39;priority_queue&#39; is
// instantiated with a parameterized type &#39;VALUE&#39; that is not itself
// value-semantic, then it will not retain all of its value-semantic qualities.
// A &#39;priority_queue&#39; cannot be tested for equality, but its parameterized type
// &#39;VALUE&#39; must be able to be tested for comparing less by its parameterized
// type &#39;COMPARATOR&#39;.
//
// &#39;priority_queue&#39; meets the requirements of a container adapter in the C++
// standard [23.6].  The &#39;priority_queue&#39; implemented here adheres to the C++11
// standard, except that it does not have methods that take rvalue references
// and &#39;initializer_lists&#39;.  Note that excluded C++11 features are those that
// require C++11 compiler support.
//
///Memory Allocation
///-----------------
// The type supplied as &#39;ALLOCATOR&#39; template parameter in some of
// &#39;priority_queue&#39; constructors determines how the held container (of
// parameterized &#39;CONTAINER&#39;) will allocate memory.  A &#39;priority_queue&#39;
// supports allocators meeting the requirements of the C++11 standard
// [17.6.3.5] as long as the held container does.  In addition it supports
// scoped-allocators derived from the &#39;bslma_Allocator&#39; memory allocation
// protocol.  Clients intending to use &#39;bslma&#39; style allocators should use
// &#39;bsl::allocator&#39; as the &#39;ALLOCATOR&#39; template parameter,  providing a C++11
// standard-compatible adapter for a &#39;bslma_Allocator&#39; object.
//
///Operations
///----------
// The C++11 standard [23.6.4] declares any container type supporting
// operations &#39;front&#39;, &#39;push_back&#39;, and &#39;pop_back&#39; can be used to instantiate
// the parameterized type &#39;CONTAINER&#39;.  Below is a list of public methods of
// &#39;priority_queue&#39; class that are effectively implementationed based on
// corresponding operations in the held container (referenced as &#39;c&#39;).
//  +--------------------------------------+---------------------------+
//  | Public methods in &#39;priority_queue&#39;   | Operation in &#39;CONTAINER&#39;  |
//  +======================================+===========================+
//  | void push(const value_type&amp; value);  | c.push_back(value);       |
//  | void pop();                          | c.pop_back();             |
//  +--------------------------------------+---------------------------+
//  | bool empty() const;                  | c.empty();                |
//  | size_type size() const;              | c.size();                 |
//  | const_reference top() const;         | c.front();                |
//  +--------------------------------------+---------------------------+
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Task Scheduler
///- - - - - - - - - - - - -
// In this example, we will use the &#39;bsl::priority_queue&#39; class to implement a
// task scheduler that schedules a group of tasks based on their designated
// priorities.
//
// Suppose we want to write a background process that runs tasks needed by
// foreground applications.  Each task has a task id, a priority, and a
// function pointer that can be invoked by the background process.  This
// background process has two threads: one thread (receiving thread) receives
// requests from other applications, passing required tasks to a task
// scheduler; the other thread (processing thread) runs the task scheduler,
// executing the tasks one-by-one from higher to lower priorities.  To
// implement this functionality, we can use &#39;bsl::priority_queue&#39; in the task
// scheduler to buffer received, but as yet unprocessed, tasks.  The task
// scheduler adds newly received tasks into the priority queue in the receiving
// thread, and extracts tasks from the the priority queue for execution
// according to their priorities in the processing thread.
//
// First, we define a &#39;TaskFunction&#39; type:
//..
//  typedef void (*TaskFunction)(int, int, int);
//..
// Then, we define a &#39;Task&#39; class, which contains a task id, a &#39;TaskFunction&#39;
// object and an associated task priority:
//..
//  class Task
//      // This class represents a task that has an integer task id, a task
//      // function, and an integer priority.  The smaller the numerical value
//      // of a priority, the higher the priority.
//  {
//    private:
//      // DATA
//      int          d_taskId;          // task id
//
//      TaskFunction d_taskFunction_p;  // task function
//
//      int          d_priority;        // priority of the task
//
//    public:
//      // CREATORS
//      explicit Task(int taskId, TaskFunction taskFunction, int priority);
//          // Create a &#39;Task&#39; object having the specified &#39;taskId&#39;, the
//          // specified &#39;d_taskFunction_p&#39;, and the specified &#39;priority&#39;.
//
//      // ACCESSORS
//      int getId() const;
//          // Return the contained task id.
//
//      int getPriority() const;
//          // Return the priority of the task.
//
//      TaskFunction getFunction() const;
//          // Return the contained task function object.
//  };
//
//  // CREATORS
//  Task::Task(int taskId, TaskFunction taskFunction, int priority)
//  : d_taskId(taskId)
//  , d_taskFunction_p(taskFunction)
//  , d_priority(priority)
//  {
//  }
//
//  // ACCESSORS
//  inline
//  int Task::getId() const
//  {
//      return d_taskId;
//  }
//
//  inline
//  int Task::getPriority() const
//  {
//      return d_priority;
//  }
//
//  inline
//  TaskFunction Task::getFunction() const
//  {
//      return d_taskFunction_p;
//  }
//..
// Next, we define a functor to compare the priorities of two &#39;Task&#39; objects:
//..
//  struct TaskComparator {
//      // This &#39;struct&#39; defines an ordering on &#39;Task&#39; objects, allowing them
//      // to be included in sorted data structures such as
//      // &#39;bsl::priority_queue&#39;.
//
//      bool operator()(const Task&amp; lhs, const Task&amp; rhs) const
//          // Return &#39;true&#39; if the priority of the specified &#39;lhs&#39; is
//          // numerically less than that of the specified &#39;rhs&#39;, and &#39;false&#39;
//          // otherwise.  Note that the smaller the value returned by the
//          // &#39;Task::getPriority&#39; method, the higher the priority.
//      {
//          return lhs.getPriority() &gt; rhs.getPriority();
//      }
//  };
//..
// Then, we define a &#39;TaskScheduler&#39; class that provides methods to hold and
// schedule unprocessed tasks:
//..
//  class TaskScheduler {
//      // This class holds and schedules tasks to execute.
//..
// Here, we define a private data member that is an instantiation of
// &#39;bsl::priority_queue&#39;, which uses &#39;Task&#39; for its &#39;VALUE&#39; (template
// parameter) type, &#39;bsl::vector&lt;Task&gt;&#39; for its &#39;CONTAINER&#39; (template
// parameter) type, and &#39;TaskComparator&#39; for its &#39;COMPARATOR&#39; (template
// parameter) type:
//..
//      // DATA
//      bsl::priority_queue&lt;Task,
//                          bsl::vector&lt;Task&gt;,
//                          TaskComparator&gt;
//            d_taskPriorityQueue;  // priority queue holding unprocessed tasks
//
//      // ...
//
//    public:
//      // CREATORS
//      explicit TaskScheduler(bslma::Allocator *basicAllocator = 0);
//          // Create a &#39;TaskScheduler&#39; object.  Optionally specify a
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//          // 0, the currently installed default allocator is used.
//
//      // MANIPULATORS
//      void addTask(int taskId, TaskFunction taskFunction, int priority);
//          // Enqueue the specified &#39;task&#39; having the specified &#39;priority&#39;
//          // onto this scheduler.
//
//      void processTasks(int verbose);
//          // Dequeue the task having the highest priority in this scheduler,
//          // and call its task function by passing in the specified &#39;verbose&#39;
//          // flag.
//  };
//..
// Next, we implement the &#39;TaskScheduler&#39; constructor:
//..
//  TaskScheduler::TaskScheduler(bslma::Allocator *basicAllocator)
//  : d_taskPriorityQueue(basicAllocator)
//  {
//  }
//..
// Notice that we pass to the contained &#39;d_taskPriorityQueue&#39; object the
// &#39;bslma::Allocator&#39; supplied to the &#39;TaskScheduler&#39; at construction.
//
// Then, we implement the &#39;addTask&#39; method, which constructs a &#39;Task&#39; object
// and adds it into the priority queue:
//..
//  void TaskScheduler::addTask(int taskId,
//                              TaskFunction taskFunction,
//                              int priority)
//  {
//      // ... (some synchronization)
//
//      d_taskPriorityQueue.push(Task(taskId, taskFunction, priority));
//
//      // ...
//  }
//..
// Next, we implement the &#39;processTasks&#39; method, which extracts tasks from the
// priority queue in order of descending priorities, and executes them:
//..
//  void TaskScheduler::processTasks(int verbose)
//  {
//      // ... (some synchronization)
//
//      while (!d_taskPriorityQueue.empty()) {
//          const Task&amp; task = d_taskPriorityQueue.top();
//          TaskFunction taskFunction = task.getFunction();
//          if (taskFunction) {
//              taskFunction(task.getId(), task.getPriority(), verbose);
//          }
//          d_taskPriorityQueue.pop();
//      }
//
//      // ...
//  }
//..
// Note that the &#39;top&#39; method always returns the &#39;Task&#39; object having the
// highest priority in the priority queue.
//
// Then, we define two task functions:
//..
//  void taskFunction1(int taskId, int priority, int verbose)
//  {
//      if (verbose) {
//          printf(&quot;Executing task %d (priority = %d) in &#39;taskFunction1&#39;.\n&quot;,
//                 taskId,
//                 priority);
//      }
//  }
//
//  void taskFunction2(int taskId, int priority, int verbose)
//  {
//      if (verbose) {
//          printf(&quot;Executing task %d (priority = %d) in &#39;taskFunction2&#39;.\n&quot;,
//                 taskId,
//                 priority);
//      }
//  }
//..
// Next, we create a global &#39;TaskScheduler&#39; object:
//..
//  TaskScheduler taskScheduler;
//..
// Now, we call the &#39;addTask&#39; method of &#39;taskScheduler&#39; in the receiving
// thread:
//..
//  // (in receiving thread)
//  // ...
//
//  taskScheduler.addTask(1, taskFunction1, 50);
//
//  // ...
//
//  taskScheduler.addTask(2, taskFunction1, 99);
//
//  // ...
//
//  taskScheduler.addTask(3, taskFunction2, 4);
//
//  // ...
//..
// Finally, we call the &#39;processTasks&#39; method of &#39;taskScheduler&#39; in the
// processing thread:
//..
//  // (in processing thread)
//  // ...
//
//  taskScheduler.processTasks(veryVerbose);
//
//  // ...
//..

#ifndef INCLUDED_BSLSTL_ALLOCATOR
#include &lt;bslstl_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_VECTOR
#include &lt;bslstl_vector.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SWAPUTIL
#include &lt;bslalg_swaputil.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ENABLEIF
#include &lt;bslmf_enableif.h&gt;
#endif

#ifndef INCLUDED_FUNCTIONAL
#include &lt;functional&gt;
#define INCLUDED_FUNCTIONAL
#endif

namespace BloombergLP {

namespace bslstl {

template &lt;class CONTAINER, class ALLOCATOR&gt;
struct PriorityQueue_HasAllocatorType {
  private:
    typedef char YesType;
    struct NoType { char a[2]; };

  public:
    template &lt;typename TYPE&gt;
    static YesType match(const typename TYPE::allocator_type *);
    template &lt;typename TYPE&gt;
    static NoType match(...);

    enum { VALUE = (sizeof(YesType) == sizeof(match&lt;CONTAINER&gt;(0))) };
};

}  // close package namespace

}  // close enterprise namespace

namespace bsl {

                         // ====================
                         // class priority_queue
                         // ====================

template &lt;class VALUE,
          class CONTAINER  = vector&lt;VALUE&gt;,
          class COMPARATOR = native_std::less&lt;typename CONTAINER::value_type&gt; &gt;
class priority_queue
    // This class is a value-semantic class template, adapting a container of
    // the parameterized &#39;CONTAINER&#39; type that holds elements of the
    // parameterized &#39;VALUE&#39; type, to provides a highest-priority-first
    // priority queue data structure, where the priorities of elements are
    // compared by a comparator of the parameterized &#39;COMPARATOR&#39; type.  The
    // container object held by a &#39;priority_queue&#39; class object is referenced
    // as &#39;c&#39; in the following documentation.
{
  protected:
    // DATA
    CONTAINER c;        // container for elements in the &#39;priority_queue&#39;,
                        // protected as required by the C++11 Standard
    COMPARATOR comp;    // comparator that defines the priority order of
                        // elements in the &#39;priority_queue&#39;

  public:
    // PUBLIC TYPES
    typedef typename CONTAINER::value_type      value_type;
    typedef typename CONTAINER::reference       reference;
    typedef typename CONTAINER::const_reference const_reference;
    typedef typename CONTAINER::size_type       size_type;
    typedef          CONTAINER                  container_type;

    // CREATORS
    priority_queue(const COMPARATOR&amp; comparator,
                   const CONTAINER&amp;  container);
        // Create a priority queue, adapting the specified &#39;container&#39; of the
        // (template parameter) type &#39;CONTAINER&#39;, and having the specified
        // &#39;comparator&#39; of the (template parameter) type &#39;COMPARATOR&#39; to order
        // priorities of elements held in &#39;container&#39;.

    explicit priority_queue();
        // Create an empty priority queue, adapting a default-constructed
        // container of the (template parameter) type &#39;CONTAINER&#39;.  Use a
        // default-constructed comparator of the (template parameter) type
        // &#39;COMPARATOR&#39; to order priorities of elements.

    explicit priority_queue(const COMPARATOR&amp; comparator);
        // Create an empty priority queue, adapting a default-constructed
        // container of the parameterized &#39;CONTAINER&#39; type, and having the
        // specified &#39;comparator&#39; of the (template parameter) type &#39;COMPARATOR&#39;
        // to order priorities of elements in &#39;container&#39;.

    template &lt;class INPUT_ITERATOR&gt;
    priority_queue(INPUT_ITERATOR first,
                   INPUT_ITERATOR last);
        // Create a priority queue, adapting a default-constructed container of
        // the (template parameter) type &#39;CONTAINER&#39;, and inserting into the
        // container a sequence of &#39;value_type&#39; elements that starts at the
        // specified &#39;first&#39; and ends immediately before the specified &#39;last&#39;.
        // Use a default-constructed comparator of the parameterized
        // &#39;COMPARATOR&#39; type to order the priorities of elements.

    template &lt;class INPUT_ITERATOR&gt;
    priority_queue(INPUT_ITERATOR    first,
                   INPUT_ITERATOR    last,
                   const COMPARATOR&amp; comparator,
                   const CONTAINER&amp;  container);
        // Create a priority queue, adapting the specified &#39;container&#39;, having
        // the specified &#39;comparator&#39; to order the priorities of elements,
        // including those originally existed in &#39;container&#39;, and those
        // inserted into the &#39;container&#39; from a sequence of &#39;value_type&#39;
        // elements starting at the specified &#39;first&#39;, and ending immediately
        // before the specified &#39;last&#39;.

    priority_queue(const priority_queue&amp; original);
        // Create a priority queue having the same value as the specified
        // &#39;original&#39;.  Use the comparator from &#39;original&#39; to order the
        // priorities of elements.

    template &lt;class ALLOCATOR&gt;
    explicit priority_queue(
                           const ALLOCATOR&amp; allocator,
                           typename enable_if&lt;
                           BloombergLP::bslstl::PriorityQueue_HasAllocatorType&lt;
                                               CONTAINER,
                                               ALLOCATOR&gt;::VALUE&gt;::type * = 0);
        // Create an empty priority queue that adapts a default-constructed
        // container of the parameterized &#39;CONTAINER&#39; type and will use the
        // specified &#39;allocator&#39; to supply memory.  Use a default-constructed
        // comparator of the parameterized &#39;COMPARATOR&#39; type to order the
        // priorities of elements.  Note that the &#39;ALLOCATOR&#39; parameter type
        // has to be convertible to the allocator of the &#39;CONTAINER&#39; parameter
        // type, &#39;CONTAINER::allocator_type&#39;.  Otherwise this constructor is
        // disabled.

    template &lt;class ALLOCATOR&gt;
    priority_queue(const COMPARATOR&amp; comparator,
                   const ALLOCATOR&amp; allocator,
                   typename enable_if&lt;
                           BloombergLP::bslstl::PriorityQueue_HasAllocatorType&lt;
                                               CONTAINER,
                                               ALLOCATOR&gt;::VALUE&gt;::type * = 0);
        // Create an empty priority queue that adapts a default-constructed
        // container of the parameterized &#39;CONTAINER&#39;type and will use the
        // specified &#39;allocator&#39; to supply memory, and the specified
        // &#39;comparator&#39; to order priorities of elements in a
        // default-constructed container of the parameterized &#39;CONTAINER&#39; type.
        // Note that the &#39;ALLOCATOR&#39; parameter type has to be convertible to
        // the allocator of the &#39;CONTAINER&#39; parameter type,
        // &#39;CONTAINER::allocator_type&#39;.  Otherwise this constructor is
        // disabled.

    template &lt;class ALLOCATOR&gt;
    priority_queue(const COMPARATOR&amp; comparator,
                   const CONTAINER&amp;  container,
                   const ALLOCATOR&amp;  allocator,
                   typename enable_if&lt;
                           BloombergLP::bslstl::PriorityQueue_HasAllocatorType&lt;
                                               CONTAINER,
                                               ALLOCATOR&gt;::VALUE&gt;::type * = 0);
        // Create a priority queue that will use the specified &#39;allocator&#39; to
        // supply memory, and the specified &#39;comparator&#39; to order priorities of
        // elements in the specified &#39;container&#39;.  Note that the &#39;ALLOCATOR&#39;
        // parameter type has to be convertible to the allocator of the
        // &#39;CONTAINER&#39; parameter type, &#39;CONTAINER::allocator_type&#39;.  Otherwise
        // this constructor is disabled.

    template &lt;class ALLOCATOR&gt;
    priority_queue(const priority_queue&amp; original,
                   const ALLOCATOR&amp; allocator,
                   typename enable_if&lt;
                           BloombergLP::bslstl::PriorityQueue_HasAllocatorType&lt;
                                               CONTAINER,
                                               ALLOCATOR&gt;::VALUE&gt;::type * = 0);
        // Create a priority queue having the same value as the specified
        // &#39;original&#39; that will use the specified &#39;allocator&#39; to supply memory.
        // Use the comparator from &#39;original&#39; to order the priorities of
        // elements.  Note that the &#39;ALLOCATOR&#39; parameter type has to be
        // convertible to the allocator of the &#39;CONTAINER&#39; parameter type,
        // &#39;CONTAINER::allocator_type&#39;.  Otherwise this constructor is
        // disabled.

    // MANIPULATORS
    void push(const value_type&amp; value);
        // Insert a new element having the specified priority &#39;value&#39; into this
        // &#39;priority_queue&#39; object.  In effect, performs &#39;c.push_back(value);&#39;.

    void pop();
        // Remove the top element from this &#39;priority_queue&#39; object that has
        // the highest priority.  In effect, performs &#39;c.pop();&#39;.  The behavior
        // is undefined if there is currently no elements in this object.

    void swap(priority_queue&amp; other);
        // Efficiently exchange the value of this object with the value of the
        // specified &#39;other&#39; object.  In effect, performs
        // &#39;using bsl::swap; swap(c, other.c);&#39;.

    // ACCESSORS
    bool empty() const;
        // Return &#39;true&#39; if this &#39;priority_queue&#39; object contains no elements,
        // and &#39;false&#39; otherwise.  In effect, performs &#39;return c.empty();&#39;.

    size_type size() const;
        // Return the number of elements in this &#39;priority_queue&#39; object.  In
        // effect, performs &#39;return c.size()&#39;.

    const_reference top() const;
        // Return the immutable element having the highest priority in this
        // &#39;priority_queue&#39; object.  In effect, performs &#39;return c.front()&#39;.
        // The behavior is undefined if there is currently no elements in this
        // object.
};

// FREE FUNCTIONS

template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
void swap(priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;&amp; lhs,
          priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;&amp; rhs);

// ===========================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ===========================================================================

                         // --------------------
                         // class priority_queue
                         // --------------------

// CREATORS
template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
inline
priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::priority_queue(
                                                  const COMPARATOR&amp; comparator,
                                                  const CONTAINER&amp;  container)
: c(container)
, comp(comparator)
{
    native_std::make_heap(c.begin(), c.end(), comp);
}

template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
inline
priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::priority_queue()
{
}

template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
inline
priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::priority_queue(
                                                  const COMPARATOR&amp; comparator)
: comp(comparator)
{
}

template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
template &lt;class INPUT_ITERATOR&gt;
inline
priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::priority_queue(
                                                       INPUT_ITERATOR    first,
                                                       INPUT_ITERATOR    last)
{
    c.insert(c.end(), first, last);
    native_std::make_heap(c.begin(), c.end(), comp);
}

template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
template &lt;class INPUT_ITERATOR&gt;
inline
priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::priority_queue(
                                                  INPUT_ITERATOR    first,
                                                  INPUT_ITERATOR    last,
                                                  const COMPARATOR&amp; comparator,
                                                  const CONTAINER&amp;  container)
: c(container)
, comp(comparator)
{
    c.insert(c.end(), first, last);
    native_std::make_heap(c.begin(), c.end(), comp);
}

template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
inline
priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::priority_queue(
                                                const priority_queue&amp; original)
: c(original.c)
, comp(original.comp)
{
}

template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
template &lt;class ALLOCATOR&gt;
inline
priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::priority_queue(
                           const ALLOCATOR&amp; allocator,
                           typename enable_if&lt;
                           BloombergLP::bslstl::PriorityQueue_HasAllocatorType&lt;
                                                    CONTAINER,
                                                    ALLOCATOR&gt;::VALUE&gt;::type *)
: c(allocator)
, comp(COMPARATOR())
{
}

template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
template &lt;class ALLOCATOR&gt;
inline
priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::priority_queue(
                           const COMPARATOR&amp; comparator,
                           const ALLOCATOR&amp;  allocator,
                           typename enable_if&lt;
                           BloombergLP::bslstl::PriorityQueue_HasAllocatorType&lt;
                                                    CONTAINER,
                                                    ALLOCATOR&gt;::VALUE&gt;::type *)
: c(allocator)
, comp(comparator)
{
}

template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
template &lt;class ALLOCATOR&gt;
inline
priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::priority_queue(
                           const COMPARATOR&amp; comparator,
                           const CONTAINER&amp;  container,
                           const ALLOCATOR&amp;  allocator,
                           typename enable_if&lt;
                           BloombergLP::bslstl::PriorityQueue_HasAllocatorType&lt;
                                                    CONTAINER,
                                                    ALLOCATOR&gt;::VALUE&gt;::type *)
: c(container, allocator)
, comp(comparator)
{
    native_std::make_heap(c.begin(), c.end(), comp);
}


template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
template &lt;class ALLOCATOR&gt;
inline
priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::priority_queue(
                           const priority_queue&amp; original,
                           const ALLOCATOR&amp;      allocator,
                           typename enable_if&lt;
                           BloombergLP::bslstl::PriorityQueue_HasAllocatorType&lt;
                                                    CONTAINER,
                                                    ALLOCATOR&gt;::VALUE&gt;::type *)
: c(original.c, allocator)
, comp(original.comp)
{
}


// MANIPULATORS
template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
inline
void priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::push(
                                                       const value_type&amp; value)
{
    c.push_back(value);
    native_std::push_heap(c.begin(), c.end(), comp);
}

template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
inline
void priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::pop()
{
    native_std::pop_heap(c.begin(), c.end(), comp);
    c.pop_back();
}

template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
inline
void priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::swap(priority_queue&amp; other)
{
    BloombergLP::bslalg::SwapUtil::swap(&amp;c   , &amp;other.c   );
    BloombergLP::bslalg::SwapUtil::swap(&amp;comp, &amp;other.comp);
}

// ACCESSORS
template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
inline
bool priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::empty() const
{
    return c.empty();
}

template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
inline
typename priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::size_type
priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::size() const
{
    return c.size();
}

template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
inline
typename priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::const_reference
priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;::top() const
{
    return c.front();
}

// FREE FUNCTIONS
template &lt;class VALUE, class CONTAINER, class COMPARATOR&gt;
void swap(priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;&amp; lhs,
          priority_queue&lt;VALUE, CONTAINER, COMPARATOR&gt;&amp; rhs)
{
    lhs.swap(rhs);
}

}  // close namespace bsl

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
