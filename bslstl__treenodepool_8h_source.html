<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslstl_treenodepool.h                                              -*-C++-*-
#ifndef INCLUDED_BSLSTL_TREENODEPOOL
#define INCLUDED_BSLSTL_TREENODEPOOL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide efficient creation of nodes used in tree-based container.
//
//@CLASSES:
//   bslstl::TreeNodePool: memory manager to allocate tree nodes
//
//@SEE_ALSO: bslstl_simplepool
//
//@DESCRIPTION: This component implements a mechanism that creates and deletes
// &#39;bslstl::TreeNode&#39; objects for the parameterized &#39;VALUE&#39; type for use in a
// tree-based container.
//
// A &#39;bslstl::TreeNodePool&#39; contains a memory pool provided by the
// &#39;bslstl_simplepool&#39; component to provide memory for the nodes (see
// &#39;bslstl_simplepool&#39;).  When the pool is empty, a number of memory blocks is
// allocated and added to the pool, where each block is large enough to contain
// a &#39;bslstl::TreeNode&#39;.  The first allocation contains one memory block.
// Subsequent allocations double the number of memory blocks of the previous
// allocation up to an implementation defined maximum number of blocks.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Creating a &#39;IntSet&#39; Container
/// - - - - - - - - - - - - - - - - - - - -
// This example demonstrates how to create a container type, &#39;IntSet&#39; using
// &#39;bslalg::RbTreeUtil&#39;.
//
// First, we define a comparison functor for comparing a
// &#39;bslstl::RbTreeNode&lt;int&gt;&#39; object and an &#39;int&#39; value.  This functor conforms
// to the requirements of &#39;bslalg::RbTreeUtil&#39;:
//..
//  struct IntNodeComparator {
//      // This class defines a comparator providing comparison operations
//      // between &#39;bslstl::TreeNode&lt;int&gt;&#39; objects, and &#39;int&#39; values.
//
//    private:
//      // PRIVATE TYPES
//      typedef bslstl::TreeNode&lt;int&gt; Node;
//          // Alias for a node type containing an &#39;int&#39; value.
//
//    public:
//      // CLASS METHODS
//      bool operator()(const bslalg::RbTreeNode&amp; lhs, int rhs) const
//      {
//          return static_cast&lt;const Node&amp;&gt;(lhs).value() &lt; rhs;
//      }
//
//      bool operator()(int lhs, const bslalg::RbTreeNode&amp; rhs) const
//      {
//          return lhs &lt; static_cast&lt;const Node&amp;&gt;(rhs).value();
//      }
//  };
//..
// Then, we define the public interface of &#39;IntSet&#39;.  Note that it contains a
// &#39;TreeNodePool&#39; that will be used by &#39;bslalg::RbTreeUtil&#39; as a &#39;FACTORY&#39; to
// create and delete nodes.  Also note that a number of simplifications have
// been made for the purpose of illustration.  For example, this implementation
// provides only a minimal set of critical operations, and it does not use the
// empty base-class optimization for the comparator.
//..
//  template &lt;class ALLOCATOR = bsl::allocator&lt;int&gt; &gt;
//  class IntSet {
//      // This class implements a set of (unique) &#39;int&#39; values.
//
//      // PRIVATE TYPES
//      typedef bslstl::TreeNodePool&lt;int, ALLOCATOR&gt; TreeNodePool;
//
//      // DATA
//      bslalg::RbTreeAnchor d_tree;      // tree of node objects
//      TreeNodePool         d_nodePool;  // allocator for node objects
//
//      // NOT IMPLEMENTED
//      IntSet(const IntSet&amp;);
//      IntSet&amp; operator=(const IntSet&amp;);
//
//    public:
//      // CREATORS
//      IntSet(const ALLOCATOR&amp; allocator = ALLOCATOR());
//          // Create an empty set.  Optionally specify an &#39;allocator&#39; used to
//          // supply memory.  If &#39;allocator&#39; is not specified, a default
//          // constructed &#39;ALLOCATOR&#39; object is used.
//
//      //! ~IntSet() = 0;
//          // Destroy this object.
//
//      // MANIPULATORS
//      void insert(int value);
//          // Insert the specified &#39;value&#39; into this set.
//
//      bool remove(int value);
//          // If &#39;value&#39; is a member of this set, then remove it from the set
//          // and return &#39;true&#39;.  Otherwise, return &#39;false&#39; with no effect.
//
//      // ACCESSORS
//      bool isElement(int value) const;
//          // Return &#39;true&#39; if the specified &#39;value&#39; is a member of this set,
//          // and &#39;false&#39; otherwise.
//
//      int numElements() const;
//          // Return the number of elements in this set.
//  };
//..
// Now, we implement the methods of &#39;IntSet&#39; using &#39;RbTreeUtil&#39;.
//..
//  // CREATORS
//  template &lt;class ALLOCATOR&gt;
//  inline
//  IntSet&lt;ALLOCATOR&gt;::IntSet(const ALLOCATOR&amp; allocator)
//  : d_tree()
//  , d_nodePool(allocator)
//  {
//  }
//
//  // MANIPULATORS
//  template &lt;class ALLOCATOR&gt;
//  void IntSet&lt;ALLOCATOR&gt;::insert(int value)
//  {
//      int comparisonResult;
//      bslalg::RbTreeNode *parent =
//          bslalg::RbTreeUtil::findUniqueInsertLocation(&amp;comparisonResult,
//                                                       &amp;d_tree,
//                                                       IntNodeComparator(),
//                                                       value);
//..
// Here we use the &#39;TreeNodePool&#39; object, &#39;d_nodePool&#39;, to create the node that
// was inserted into the set.
//..
//      if (0 != comparisonResult) {
//          bslalg::RbTreeNode *node = d_nodePool.createNode(value);
//          bslalg::RbTreeUtil::insertAt(&amp;d_tree,
//                                       parent,
//                                       comparisonResult &lt; 0,
//                                       node);
//      }
//  }
//
//  template &lt;class ALLOCATOR&gt;
//  bool IntSet&lt;ALLOCATOR&gt;::remove(int value)
//  {
//      bslalg::RbTreeNode *node =
//                bslalg::RbTreeUtil::find(d_tree, IntNodeComparator(), value);
//..
// Here we use the &#39;TreeNodePool&#39; object, &#39;d_nodePool&#39;, to delete a node that
// was removed from the set.
//..
//      if (node) {
//          bslalg::RbTreeUtil::remove(&amp;d_tree, node);
//          d_nodePool.deleteNode(node);
//      }
//      return node;
//  }
//
//  // ACCESSORS
//  template &lt;class ALLOCATOR&gt;
//  inline
//  bool IntSet&lt;ALLOCATOR&gt;::isElement(int value) const
//  {
//      return bslalg::RbTreeUtil::find(d_tree, IntNodeComparator(), value);
//  }
//
//  template &lt;class ALLOCATOR&gt;
//  inline
//  int IntSet&lt;ALLOCATOR&gt;::numElements() const
//  {
//      return d_tree.numNodes();
//  }
//..
// Finally, we create a sample &#39;IntSet&#39; object and insert 3 values into the
// &#39;IntSet&#39;.  We verify the attributes of the &#39;Set&#39; before and after each
// insertion.
//..
//  bslma::TestAllocator defaultAllocator(&quot;defaultAllocator&quot;);
//  bslma::DefaultAllocatorGuard defaultGuard(&amp;defaultAllocator);
//
//  bslma::TestAllocator objectAllocator(&quot;objectAllocator&quot;);
//
//  IntSet&lt;bsl::allocator&lt;int&gt; &gt; set(&amp;objectAllocator);
//  assert(0 == defaultAllocator.numBytesInUse());
//  assert(0 == objectAllocator.numBytesInUse());
//  assert(0 == set.numElements());
//
//  set.insert(1);
//  assert(set.isElement(1));
//  assert(1 == set.numElements());
//
//  set.insert(1);
//  assert(set.isElement(1));
//  assert(1 == set.numElements());
//
//  set.insert(2);
//  assert(set.isElement(1));
//  assert(set.isElement(2));
//  assert(2 == set.numElements());
//
//  assert(0 == defaultAllocator.numBytesInUse());
//  assert(0 &lt;  objectAllocator.numBytesInUse());
//..

// Prevent &#39;bslstl&#39; headers from being included directly in &#39;BSL_OVERRIDES_STD&#39;
// mode.  Doing so is unsupported, and is likely to cause compilation errors.
#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
#error &quot;&lt;bslstl_treenodepool.h&gt; header can&#39;t be included directly in \
BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLALG_RBTREENODE
#include &lt;bslalg_rbtreenode.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEALLOCATORPROCTOR
#include &lt;bslma_deallocatorproctor.h&gt;
#endif

#ifndef INCLUDED_BSLS_UTIL
#include &lt;bsls_util.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ALLOCATORTRAITS
#include &lt;bslstl_allocatortraits.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_SIMPLEPOOL
#include &lt;bslstl_simplepool.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_TREENODE
#include &lt;bslstl_treenode.h&gt;
#endif

namespace BloombergLP {
namespace bslstl {

                       // ==================
                       // class TreeNodePool
                       // ==================

template &lt;class VALUE, class ALLOCATOR&gt;
class TreeNodePool {
    // This class provides methods for creating and deleting nodes using the
    // appropriate allocator-traits of the parameterized &#39;ALLOCATOR&#39;.  This
    // type is intended to be used as a private base-class for a node-based
    // container, in order to take advantage of the empty-base-class
    // optimization in the case where the base-class has 0 size (as may the
    // case if the parameterized &#39;ALLOCATOR&#39; is not a &#39;bslma::Allocator&#39;).

    typedef SimplePool&lt;TreeNode&lt;VALUE&gt;, ALLOCATOR&gt; Pool;
        // Alias for the memory pool allocator.

    typedef typename Pool::AllocatorTraits         AllocatorTraits;
        // Alias for the allocator traits defined by &#39;SimplePool&#39;.

    // DATA
    Pool d_pool;  // pool for allocating memory

  private:
    // NOT IMPLEMENTED
    TreeNodePool&amp; operator=(const TreeNodePool&amp;);
    TreeNodePool(const TreeNodePool&amp;);

  public:
    // PUBLIC TYPE
    typedef typename Pool::AllocatorType AllocatorType;
        // Alias for the allocator type defined by &#39;SimplePool&#39;.

  public:
    // CREATORS
    explicit TreeNodePool(const ALLOCATOR&amp; allocator);
        // Create a node-allocator that will use the specified &#39;allocator&#39; to
        // supply memory for allocated node objects.

    // MANIPULATORS
    AllocatorType&amp; allocator();
        // Return a reference providing modifiable access to the rebound
        // allocator traits for the node-type.  Note that this operation
        // returns a base-class (&#39;NodeAlloc&#39;) reference to this object.

    bslalg::RbTreeNode *createNode();
        // Allocate a node object having a default constructed &#39;VALUE&#39;.

    bslalg::RbTreeNode *createNode(const bslalg::RbTreeNode&amp; original);
        // Allocate a node object having a copy-constructed &#39;VALUE&#39; of
        // &#39;value()&#39; of the specified &#39;original&#39;.  The behavior is undefined
        // unless &#39;original&#39; refers to a &#39;TreeNode&lt;VALUE&gt;&#39;.

    bslalg::RbTreeNode *createNode(const VALUE&amp; value);
        // Allocate a node object having the specified &#39;value&#39;.  This operation
        // will copy-construct &#39;value&#39; into the value of the returned node.

    void deleteNode(bslalg::RbTreeNode *node);
        // Destroy the &#39;VALUE&#39; value of the specified &#39;node&#39; and return the
        // memory footprint of &#39;node&#39; to this pool for potential reuse.  The
        // behavior is undefined unless &#39;node&#39; refers to a &#39;TreeNode&lt;VALUE&gt;&#39;.

    void reserveNodes(std::size_t numNodes);
        // Reserve memory from this pool to satisfy memory requests for at
        // least the specified &#39;numBlocks&#39; before the pool replenishes.  The
        // behavior is undefined unless &#39;0 &lt; numBlocks&#39;.

    void swap(TreeNodePool&lt;VALUE, ALLOCATOR&gt;&amp; other);
        // Efficiently exchange the management of nodes of this object and
        // the specified &#39;other&#39; object.  The behavior is undefined unless the
        // underlying mechanisms of &#39;allocator()&#39; refers to the same allocator.

    // ACCESSORS
    const AllocatorType&amp; allocator() const;
        // Return a reference providing non-modifiable access to the rebound
        // allocator traits for the node-type.  Note that this operation
        // returns a base-class (&#39;NodeAlloc&#39;) reference to this object.

};

// ===========================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ===========================================================================

// CREATORS
template &lt;class VALUE, class ALLOCATOR&gt;
inline
TreeNodePool&lt;VALUE, ALLOCATOR&gt;::TreeNodePool(const ALLOCATOR&amp; allocator)
: d_pool(allocator)
{
}

// MANIPULATORS
template &lt;class VALUE, class ALLOCATOR&gt;
inline
typename SimplePool&lt;TreeNode&lt;VALUE&gt;, ALLOCATOR&gt;::AllocatorType&amp;
TreeNodePool&lt;VALUE, ALLOCATOR&gt;::allocator()
{
    return d_pool.allocator();
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
bslalg::RbTreeNode *TreeNodePool&lt;VALUE, ALLOCATOR&gt;::createNode()
{
    TreeNode&lt;VALUE&gt; *node = d_pool.allocate();
    bslma::DeallocatorProctor&lt;Pool&gt; proctor(node, &amp;d_pool);

    AllocatorTraits::construct(allocator(),
                               BSLS_UTIL_ADDRESSOF(node-&gt;value()));

    proctor.release();
    return node;
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
bslalg::RbTreeNode *TreeNodePool&lt;VALUE, ALLOCATOR&gt;::createNode(
                                                            const VALUE&amp; value)
{
    TreeNode&lt;VALUE&gt; *node = d_pool.allocate();
    bslma::DeallocatorProctor&lt;Pool&gt; proctor(node, &amp;d_pool);

    AllocatorTraits::construct(allocator(),
                               BSLS_UTIL_ADDRESSOF(node-&gt;value()),
                               value);
    proctor.release();
    return node;
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
bslalg::RbTreeNode *TreeNodePool&lt;VALUE, ALLOCATOR&gt;::createNode(
                                            const bslalg::RbTreeNode&amp; original)
{
    return createNode(static_cast&lt;const TreeNode&lt;VALUE&gt;&amp;&gt;(original).value());
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
void TreeNodePool&lt;VALUE, ALLOCATOR&gt;::deleteNode(bslalg::RbTreeNode *node)
{
    BSLS_ASSERT(node);

    TreeNode&lt;VALUE&gt; *treeNode = static_cast&lt;TreeNode&lt;VALUE&gt; *&gt;(node);
    AllocatorTraits::destroy(allocator(),
                             BSLS_UTIL_ADDRESSOF(treeNode-&gt;value()));
    d_pool.deallocate(treeNode);
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
void TreeNodePool&lt;VALUE, ALLOCATOR&gt;::reserveNodes(std::size_t numNodes)
{
    BSLS_ASSERT_SAFE(0 &lt; numNodes);

    d_pool.reserve(numNodes);
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
void TreeNodePool&lt;VALUE, ALLOCATOR&gt;::swap(
                                         TreeNodePool&lt;VALUE, ALLOCATOR&gt;&amp; other)
{
    BSLS_ASSERT_SAFE(allocator() == other.allocator());

    d_pool.swap(other.d_pool);
}

// ACCESSORS
template &lt;class VALUE, class ALLOCATOR&gt;
inline
const typename SimplePool&lt;TreeNode&lt;VALUE&gt;, ALLOCATOR&gt;::AllocatorType&amp;
TreeNodePool&lt;VALUE, ALLOCATOR&gt;::allocator() const
{
    return d_pool.allocator();
}

}  // close namespace bslstl
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
