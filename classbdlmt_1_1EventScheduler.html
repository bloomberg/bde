<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlmt::EventScheduler</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlmt.html">bdlmt</a>      </li>
      <li><a class="el" href="classbdlmt_1_1EventScheduler.html">bdlmt::EventScheduler</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>bdlmt::EventScheduler Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlmt::EventScheduler" -->
<p><code>#include &lt;<a class="el" href="bdlmt__eventscheduler_8h_source.html">bdlmt_eventscheduler.h</a>&gt;</code></p>

<p><a href="classbdlmt_1_1EventScheduler-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlmt_1_1EventScheduler_1_1RecurringEvent.html">RecurringEvent</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbdlmt_1_1EventSchedulerEventHandle.html">EventSchedulerEventHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a609ac40d0a24c6879d1a1b634ee1da1a">EventHandle</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classbdlmt_1_1EventSchedulerRecurringEventHandle.html">EventSchedulerRecurringEventHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a81a0afce3a640891107eb95b09c2c7a7">RecurringEventHandle</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(const <br class="typebreak"/>
bsl::function&lt; void()&gt; &amp;)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#adcf206fa823ec6b5cc59e95e5838b100">Dispatcher</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a130db63abaad279a2ffd0982dd0858d1">BSLALG_DECLARE_NESTED_TRAITS</a> (<a class="el" href="classbdlmt_1_1EventScheduler.html">EventScheduler</a>, <a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a5960c39f357afffb9de1357a97479904">EventScheduler</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#abcfa46a7097331c23d2e55c2150b97f6">EventScheduler</a> (<a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56b">bsls::SystemClockType::Enum</a> clockType, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a69f254fe71e1527c66f09d2ff444b486">EventScheduler</a> (const <a class="el" href="classbdlmt_1_1EventScheduler.html#adcf206fa823ec6b5cc59e95e5838b100">Dispatcher</a> &amp;dispatcherFunctor, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a218267f51a49bb7918160fcd05b51e67">EventScheduler</a> (const <a class="el" href="classbdlmt_1_1EventScheduler.html#adcf206fa823ec6b5cc59e95e5838b100">Dispatcher</a> &amp;dispatcherFunctor, <a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56b">bsls::SystemClockType::Enum</a> clockType, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#aabfeb0f4c16947faf8ad4af51fd18e8e">~EventScheduler</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a584187b2bf71edea18e189da3d4b7147">cancelAllEvents</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a8941b084aa8c26c162f31ca8be75610b">cancelAllEventsAndWait</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a670cb4c64466a2b1dc9693565f0ba57c">cancelEvent</a> (const <a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a24ad2331998482c8aa46b43553518008">cancelEvent</a> (const <a class="el" href="structbdlmt_1_1EventScheduler_1_1RecurringEvent.html">RecurringEvent</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a3530eb53febf86af25f3b219dc0631c2">cancelEvent</a> (<a class="el" href="classbdlmt_1_1EventSchedulerEventHandle.html">EventHandle</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a15e35eee296fdb7be3b7e4267ccb40c6">cancelEvent</a> (<a class="el" href="classbdlmt_1_1EventSchedulerRecurringEventHandle.html">RecurringEventHandle</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a1843f98fcfbe54610cabbcecdc641dbf">cancelEventAndWait</a> (const <a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a741152533746b9a3160e1cbf40b57539">cancelEventAndWait</a> (const <a class="el" href="structbdlmt_1_1EventScheduler_1_1RecurringEvent.html">RecurringEvent</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#aacf0b05bd0b2d564e5c0bea65b7be181">cancelEventAndWait</a> (<a class="el" href="classbdlmt_1_1EventSchedulerEventHandle.html">EventHandle</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a8185e39c7efda9c45dae444d80b4751b">cancelEventAndWait</a> (<a class="el" href="classbdlmt_1_1EventSchedulerRecurringEventHandle.html">RecurringEventHandle</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a60680eb894a0ed2ce5fb5b8a701b6ae8">releaseEventRaw</a> (<a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#adaf3b9de585505959bbe6ae5e5f37bf1">releaseEventRaw</a> (<a class="el" href="structbdlmt_1_1EventScheduler_1_1RecurringEvent.html">RecurringEvent</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a389ac13862a38a463f870b991f333010">rescheduleEvent</a> (const <a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a> *handle, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;newTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#abc421286159e3bcb0de3820136e01b8f">rescheduleEventAndWait</a> (const <a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a> *handle, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;newTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#ad2c46403b2dc62cdf8a93fcecc0334b6">scheduleEvent</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;time, const bsl::function&lt; void()&gt; &amp;callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#aed45235387c115410d25fceb67f9f8ca">scheduleEvent</a> (<a class="el" href="classbdlmt_1_1EventSchedulerEventHandle.html">EventHandle</a> *event, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;time, const bsl::function&lt; void()&gt; &amp;callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a6f7af0c9d34957c367ec0d98fbc14b57">scheduleEventRaw</a> (<a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a> **event, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;time, const bsl::function&lt; void()&gt; &amp;callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a451b3459cdab4b9c22a736a480ec06bc">scheduleRecurringEvent</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;interval, const bsl::function&lt; void()&gt; &amp;callback, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;startTime=<a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(0))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a8f407611c786e605621213c62aae31de">scheduleRecurringEvent</a> (<a class="el" href="classbdlmt_1_1EventSchedulerRecurringEventHandle.html">RecurringEventHandle</a> *event, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;interval, const bsl::function&lt; void()&gt; &amp;callback, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;startTime=<a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(0))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#aaf4f0a4718f77414e9aad01273d1276f">scheduleRecurringEventRaw</a> (<a class="el" href="structbdlmt_1_1EventScheduler_1_1RecurringEvent.html">RecurringEvent</a> **event, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;interval, const bsl::function&lt; void()&gt; &amp;callback, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;startTime=<a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(0))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a9948ecb3c4308017c17ea9cfb03e7743">start</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a5fbdf1eed7218c9503f52de87d7b6722">start</a> (const <a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> &amp;threadAttributes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a6c97f4ab147de04cdd5aea2f74347075">stop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#aa4191a78b1160df174d811ad3075bf70">addEventRefRaw</a> (<a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a> *handle) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbdlmt_1_1EventScheduler_1_1RecurringEvent.html">RecurringEvent</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a79b81545a30801e6f8a9e0ab5a6d866f">addRecurringEventRefRaw</a> (<a class="el" href="structbdlmt_1_1EventScheduler_1_1RecurringEvent.html">RecurringEvent</a> *handle) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a351b43d56044a16a714ca1f9bf6765d5">numEvents</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a8968b60d0227c7c0bb9f274da425a9e2">numRecurringEvents</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a12ff9225669b90df2b1b0e8d1d815ea7">EventSchedulerEventHandle</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1EventScheduler.html#a2cbd057ae3bf27e9724bb8433c2271fb">EventSchedulerRecurringEventHandle</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides a thread-safe event scheduler that executes callbacks in a separate "dispatcher thread." <code>start</code> must be invoked to start dispatching the callbacks. <code>stop</code> pauses the dispatching of the callbacks without removing the pending events. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a609ac40d0a24c6879d1a1b634ee1da1a"></a><!-- doxytag: member="bdlmt::EventScheduler::EventHandle" ref="a609ac40d0a24c6879d1a1b634ee1da1a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbdlmt_1_1EventSchedulerEventHandle.html">EventSchedulerEventHandle</a> <a class="el" href="classbdlmt_1_1EventSchedulerEventHandle.html">bdlmt::EventScheduler::EventHandle</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a81a0afce3a640891107eb95b09c2c7a7"></a><!-- doxytag: member="bdlmt::EventScheduler::RecurringEventHandle" ref="a81a0afce3a640891107eb95b09c2c7a7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbdlmt_1_1EventSchedulerRecurringEventHandle.html">EventSchedulerRecurringEventHandle</a> <a class="el" href="classbdlmt_1_1EventSchedulerRecurringEventHandle.html">bdlmt::EventScheduler::RecurringEventHandle</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adcf206fa823ec6b5cc59e95e5838b100"></a><!-- doxytag: member="bdlmt::EventScheduler::Dispatcher" ref="adcf206fa823ec6b5cc59e95e5838b100" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(const bsl::function&lt;void()&gt;&amp;)&gt; <a class="el" href="classbdlmt_1_1EventScheduler.html#adcf206fa823ec6b5cc59e95e5838b100">bdlmt::EventScheduler::Dispatcher</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines a type alias for the dispatcher functor type. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5960c39f357afffb9de1357a97479904"></a><!-- doxytag: member="bdlmt::EventScheduler::EventScheduler" ref="a5960c39f357afffb9de1357a97479904" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::EventScheduler::EventScheduler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an event scheduler using the default dispatcher functor (see the "The dispatcher thread and the dispatcher functor" section in component-level doc) and use the realtime clock epoch for all time intervals (see <a href="group__bdlmt__eventscheduler.html#supported_clock-types" class="el">Supported Clock-Types</a> in the component documentation). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="abcfa46a7097331c23d2e55c2150b97f6"></a><!-- doxytag: member="bdlmt::EventScheduler::EventScheduler" ref="abcfa46a7097331c23d2e55c2150b97f6" args="(bsls::SystemClockType::Enum clockType, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::EventScheduler::EventScheduler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56b">bsls::SystemClockType::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>clockType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an event scheduler using the default dispatcher functor (see the "The dispatcher thread and the dispatcher functor" section in component-level doc) and use the specified <code>clockType</code> to indicate the epoch used for all time intervals (see <a href="group__bdlmt__eventscheduler.html#supported_clock-types" class="el">Supported Clock-Types</a> in the component documentation). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a69f254fe71e1527c66f09d2ff444b486"></a><!-- doxytag: member="bdlmt::EventScheduler::EventScheduler" ref="a69f254fe71e1527c66f09d2ff444b486" args="(const Dispatcher &amp;dispatcherFunctor, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::EventScheduler::EventScheduler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlmt_1_1EventScheduler.html#adcf206fa823ec6b5cc59e95e5838b100">Dispatcher</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dispatcherFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an event scheduler using the specified <code>dispatcherFunctor</code> (see "The dispatcher thread and the dispatcher functor" section in component-level doc) and use the realtime clock epoch for all time intervals (see <a href="group__bdlmt__eventscheduler.html#supported_clock-types" class="el">Supported Clock-Types</a> in the component documentation). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a218267f51a49bb7918160fcd05b51e67"></a><!-- doxytag: member="bdlmt::EventScheduler::EventScheduler" ref="a218267f51a49bb7918160fcd05b51e67" args="(const Dispatcher &amp;dispatcherFunctor, bsls::SystemClockType::Enum clockType, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::EventScheduler::EventScheduler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlmt_1_1EventScheduler.html#adcf206fa823ec6b5cc59e95e5838b100">Dispatcher</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dispatcherFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56b">bsls::SystemClockType::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>clockType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an event scheduler using the specified <code>dispatcherFunctor</code> (see "The dispatcher thread and the dispatcher functor" section in component-level doc) and use the specified <code>clockType</code> to indicate the epoch used for all time intervals (see <a href="group__bdlmt__eventscheduler.html#supported_clock-types" class="el">Supported Clock-Types</a> in the component documentation). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="aabfeb0f4c16947faf8ad4af51fd18e8e"></a><!-- doxytag: member="bdlmt::EventScheduler::~EventScheduler" ref="aabfeb0f4c16947faf8ad4af51fd18e8e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::EventScheduler::~EventScheduler </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Discard all unprocessed events and destroy this object. The behavior is undefined unless the scheduler is stopped. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a130db63abaad279a2ffd0982dd0858d1"></a><!-- doxytag: member="bdlmt::EventScheduler::BSLALG_DECLARE_NESTED_TRAITS" ref="a130db63abaad279a2ffd0982dd0858d1" args="(EventScheduler, bslalg::TypeTraitUsesBslmaAllocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::EventScheduler::BSLALG_DECLARE_NESTED_TRAITS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1EventScheduler.html">EventScheduler</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a584187b2bf71edea18e189da3d4b7147"></a><!-- doxytag: member="bdlmt::EventScheduler::cancelAllEvents" ref="a584187b2bf71edea18e189da3d4b7147" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::EventScheduler::cancelAllEvents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel all recurring and one-time events scheduled in this <a class="el" href="classbdlmt_1_1EventScheduler.html">EventScheduler</a>. </p>

</div>
</div>
<a class="anchor" id="a8941b084aa8c26c162f31ca8be75610b"></a><!-- doxytag: member="bdlmt::EventScheduler::cancelAllEventsAndWait" ref="a8941b084aa8c26c162f31ca8be75610b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::EventScheduler::cancelAllEventsAndWait </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel all recurring and one-time events scheduled in this <a class="el" href="classbdlmt_1_1EventScheduler.html">EventScheduler</a>. Block until all events have either been cancelled or dispatched before this call returns. The behavior is undefined if this method is invoked from the dispatcher thread. </p>

</div>
</div>
<a class="anchor" id="a670cb4c64466a2b1dc9693565f0ba57c"></a><!-- doxytag: member="bdlmt::EventScheduler::cancelEvent" ref="a670cb4c64466a2b1dc9693565f0ba57c" args="(const Event *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::EventScheduler::cancelEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a24ad2331998482c8aa46b43553518008"></a><!-- doxytag: member="bdlmt::EventScheduler::cancelEvent" ref="a24ad2331998482c8aa46b43553518008" args="(const RecurringEvent *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::EventScheduler::cancelEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdlmt_1_1EventScheduler_1_1RecurringEvent.html">RecurringEvent</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel the event having the specified <code>handle</code>. Return 0 on successful cancellation, and a non-zero value if the <code>handle</code> is invalid <em>or</em> if the event has already been dispatched or canceled. </p>

</div>
</div>
<a class="anchor" id="a3530eb53febf86af25f3b219dc0631c2"></a><!-- doxytag: member="bdlmt::EventScheduler::cancelEvent" ref="a3530eb53febf86af25f3b219dc0631c2" args="(EventHandle *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::EventScheduler::cancelEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1EventSchedulerEventHandle.html">EventHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a15e35eee296fdb7be3b7e4267ccb40c6"></a><!-- doxytag: member="bdlmt::EventScheduler::cancelEvent" ref="a15e35eee296fdb7be3b7e4267ccb40c6" args="(RecurringEventHandle *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::EventScheduler::cancelEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1EventSchedulerRecurringEventHandle.html">RecurringEventHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel the event having the specified <code>handle</code> and release the handle. Return 0 on successful cancellation, and a non-zero value if the <code>handle</code> is invalid <em>or</em> if the event has already been dispatched or canceled. Note that <code>handle</code> is released whether this call is successful or not. </p>

</div>
</div>
<a class="anchor" id="a1843f98fcfbe54610cabbcecdc641dbf"></a><!-- doxytag: member="bdlmt::EventScheduler::cancelEventAndWait" ref="a1843f98fcfbe54610cabbcecdc641dbf" args="(const Event *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::EventScheduler::cancelEventAndWait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a741152533746b9a3160e1cbf40b57539"></a><!-- doxytag: member="bdlmt::EventScheduler::cancelEventAndWait" ref="a741152533746b9a3160e1cbf40b57539" args="(const RecurringEvent *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::EventScheduler::cancelEventAndWait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdlmt_1_1EventScheduler_1_1RecurringEvent.html">RecurringEvent</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel the event having the specified <code>handle</code>. Block until the event having <code>handle</code> (if it is valid) is either successfully canceled or dispatched before the call returns. Return 0 on successful cancellation, and a non-zero value if <code>handle</code> is invalid <em>or</em> if the event has already been dispatched or canceled. The behavior is undefined if this method is invoked from the dispatcher thread. Note that if the event is being executed when this method is invoked, this method will block until it is completed and then return a nonzero value. </p>

</div>
</div>
<a class="anchor" id="aacf0b05bd0b2d564e5c0bea65b7be181"></a><!-- doxytag: member="bdlmt::EventScheduler::cancelEventAndWait" ref="aacf0b05bd0b2d564e5c0bea65b7be181" args="(EventHandle *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::EventScheduler::cancelEventAndWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1EventSchedulerEventHandle.html">EventHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8185e39c7efda9c45dae444d80b4751b"></a><!-- doxytag: member="bdlmt::EventScheduler::cancelEventAndWait" ref="a8185e39c7efda9c45dae444d80b4751b" args="(RecurringEventHandle *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::EventScheduler::cancelEventAndWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1EventSchedulerRecurringEventHandle.html">RecurringEventHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel the event having the specified <code>handle</code> and release <code>*handle</code>. Block until the event having <code>handle</code> (if it is valid) is either successfully canceled or dispatched before the call returns. Return 0 on successful cancellation, and a non-zero value if <code>handle</code> is invalid <em>or</em> if the event has already been dispatched or canceled. The behavior is undefined if this method is invoked from the dispatcher thread. Note that if the event is being executed when this method is invoked, this method will block until it is completed and then return a nonzero value. Also note that it is guaranteed that <code>*handle</code> will be released whether this call is successful or not. </p>

</div>
</div>
<a class="anchor" id="a60680eb894a0ed2ce5fb5b8a701b6ae8"></a><!-- doxytag: member="bdlmt::EventScheduler::releaseEventRaw" ref="a60680eb894a0ed2ce5fb5b8a701b6ae8" args="(Event *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::EventScheduler::releaseEventRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adaf3b9de585505959bbe6ae5e5f37bf1"></a><!-- doxytag: member="bdlmt::EventScheduler::releaseEventRaw" ref="adaf3b9de585505959bbe6ae5e5f37bf1" args="(RecurringEvent *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::EventScheduler::releaseEventRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdlmt_1_1EventScheduler_1_1RecurringEvent.html">RecurringEvent</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the specified <code>handle</code>. Every handle reference added by <code>scheduleEventRaw</code>, <code>addEventRefRaw</code>, <code>scheduleRecurringEventRaw</code>, or <code>addRecurringEventRefRaw</code> must be released using this method to avoid leaking resources. The behavior is undefined if the value of <code>handle</code> is used for any purpose after being released. </p>

</div>
</div>
<a class="anchor" id="a389ac13862a38a463f870b991f333010"></a><!-- doxytag: member="bdlmt::EventScheduler::rescheduleEvent" ref="a389ac13862a38a463f870b991f333010" args="(const Event *handle, const bsls::TimeInterval &amp;newTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::EventScheduler::rescheduleEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>newTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reschedule the event referred to by the specified <code>handle</code> at the specified <code>newTime</code>. Return 0 on successful reschedule, and a non-zero value if the <code>handle</code> is invalid <em>or</em> if the event has already been dispatched. The <code>newTime</code> is an absolute time represented as an interval from some epoch, which is detemined by the clock indicated at construction (see <a href="group__Supported Clock-Types.html" class="el"><code>Supported Clock-Types</code></a> in the component documentation). </p>

</div>
</div>
<a class="anchor" id="abc421286159e3bcb0de3820136e01b8f"></a><!-- doxytag: member="bdlmt::EventScheduler::rescheduleEventAndWait" ref="abc421286159e3bcb0de3820136e01b8f" args="(const Event *handle, const bsls::TimeInterval &amp;newTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::EventScheduler::rescheduleEventAndWait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>newTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reschedule the event referred to by the specified <code>handle</code> at the specified <code>newTime</code>. Block until the event having <code>handle</code> (if it is valid) is either successfully rescheduled or dispatched before the call returns. Return 0 on successful reschedule, and a non-zero value if <code>handle</code> is invalid <em>or</em> if the event has already been dispatched. The <code>newTime</code> is an absolute time represented as an interval from some epoch, which is detemined by the clock indicated at construction (see <a href="group__bdlmt__eventscheduler.html#supported_clock-types" class="el">Supported Clock-Types</a> in the component documentation). The behavior is undefined if this method is invoked from the dispatcher thread. </p>

</div>
</div>
<a class="anchor" id="ad2c46403b2dc62cdf8a93fcecc0334b6"></a><!-- doxytag: member="bdlmt::EventScheduler::scheduleEvent" ref="ad2c46403b2dc62cdf8a93fcecc0334b6" args="(const bsls::TimeInterval &amp;time, const bsl::function&lt; void()&gt; &amp;callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::EventScheduler::scheduleEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::function&lt; void()&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aed45235387c115410d25fceb67f9f8ca"></a><!-- doxytag: member="bdlmt::EventScheduler::scheduleEvent" ref="aed45235387c115410d25fceb67f9f8ca" args="(EventHandle *event, const bsls::TimeInterval &amp;time, const bsl::function&lt; void()&gt; &amp;callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::EventScheduler::scheduleEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1EventSchedulerEventHandle.html">EventHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::function&lt; void()&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Schedule the specified <code>callback</code> to be dispatched at the specified <code>time</code>. Load into the optionally specified <code>event</code> a handle that can be used to cancel the event (by invoking <code>cancelEvent</code>). The <code>time</code> is an absolute time represented as an interval from some epoch, which is detemined by the clock indicated at construction (see <a href="group__Supported Clock-Types.html" class="el"><code>Supported Clock-Types</code></a> in the component documentation). Note that <code>time</code> may be in the past, in which case the event will be executed as soon as possible. </p>

</div>
</div>
<a class="anchor" id="a6f7af0c9d34957c367ec0d98fbc14b57"></a><!-- doxytag: member="bdlmt::EventScheduler::scheduleEventRaw" ref="a6f7af0c9d34957c367ec0d98fbc14b57" args="(Event **event, const bsls::TimeInterval &amp;time, const bsl::function&lt; void()&gt; &amp;callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::EventScheduler::scheduleEventRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a> **&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::function&lt; void()&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Schedule the specified <code>callback</code> to be dispatched at the specified <code>time</code>. Load into the specified <code>event</code> pointer a handle that can be used to cancel the event (by invoking <code>cancelEvent</code>). The <code>time</code> is an absolute time represented as an interval from some epoch, which is detemined by the clock indicated at construction (see <a href="group__Supported Clock-Types.html" class="el"><code>Supported Clock-Types</code></a> in the component documentation). The <code>event</code> pointer must be released by invoking <code>releaseEventRaw</code> when it is no longer needed. </p>

</div>
</div>
<a class="anchor" id="a451b3459cdab4b9c22a736a480ec06bc"></a><!-- doxytag: member="bdlmt::EventScheduler::scheduleRecurringEvent" ref="a451b3459cdab4b9c22a736a480ec06bc" args="(const bsls::TimeInterval &amp;interval, const bsl::function&lt; void()&gt; &amp;callback, const bsls::TimeInterval &amp;startTime=bsls::TimeInterval(0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::EventScheduler::scheduleRecurringEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::function&lt; void()&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>startTime</em> = <code><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8f407611c786e605621213c62aae31de"></a><!-- doxytag: member="bdlmt::EventScheduler::scheduleRecurringEvent" ref="a8f407611c786e605621213c62aae31de" args="(RecurringEventHandle *event, const bsls::TimeInterval &amp;interval, const bsl::function&lt; void()&gt; &amp;callback, const bsls::TimeInterval &amp;startTime=bsls::TimeInterval(0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::EventScheduler::scheduleRecurringEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1EventSchedulerRecurringEventHandle.html">RecurringEventHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::function&lt; void()&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>startTime</em> = <code><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Schedule a recurring event that invokes the specified <code>callback</code> at every specified <code>interval</code>, with the first event dispatched at the optionally specified <code>startTime</code>. If <code>startTime</code> is not specified, the first event is dispatched at one <code>interval</code> from now. Load into the optionally specified <code>event</code> a handle that can be used to cancel the event (by invoking <code>cancelEvent</code>). The <code>startTime</code> is an absolute time represented as an interval from some epoch, which is detemined by the clock indicated at construction (see <a href="group__bdlmt__eventscheduler.html#supported_clock-types" class="el">Supported Clock-Types</a> in the component documentation). The behavior is undefined if <code>interval</code> is exactly 0 seconds. </p>

</div>
</div>
<a class="anchor" id="aaf4f0a4718f77414e9aad01273d1276f"></a><!-- doxytag: member="bdlmt::EventScheduler::scheduleRecurringEventRaw" ref="aaf4f0a4718f77414e9aad01273d1276f" args="(RecurringEvent **event, const bsls::TimeInterval &amp;interval, const bsl::function&lt; void()&gt; &amp;callback, const bsls::TimeInterval &amp;startTime=bsls::TimeInterval(0))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::EventScheduler::scheduleRecurringEventRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdlmt_1_1EventScheduler_1_1RecurringEvent.html">RecurringEvent</a> **&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::function&lt; void()&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>startTime</em> = <code><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(0)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Schedule a recurring event that invokes the specified <code>callback</code> at every specified <code>interval</code>, with the first event dispatched at the optionally specified <code>startTime</code>. If <code>startTime</code> is not specified, the first event is dispatched at one <code>interval</code> from now. Load into the specified <code>event</code> pointer a handle that can be used to cancel the event (by invoking <code>cancelEvent</code>). The <code>startTime</code> is an absolute time represented as an interval from some epoch, which is detemined by the clock indicated at construction (see <a href="group__bdlmt__eventscheduler.html#supported_clock-types" class="el">Supported Clock-Types</a> in the component documentation). The <code>event</code> pointer must be released by invoking <code>releaseEventRaw</code> when it is no longer needed. The behavior is undefined if <code>interval</code> is exactly 0 seconds. </p>

</div>
</div>
<a class="anchor" id="a9948ecb3c4308017c17ea9cfb03e7743"></a><!-- doxytag: member="bdlmt::EventScheduler::start" ref="a9948ecb3c4308017c17ea9cfb03e7743" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::EventScheduler::start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin dispatching events on this scheduler. The dispatcher thread will have default attributes. Return 0 on success, and a non-zero value otherwise. If this scheduler is already started then return 0 with no effect. The scheduler must be stopped by invoking <code>stop</code> before it is destroyed. Note that any events scheduled in the past will be dispatched immediately upon starting. </p>

</div>
</div>
<a class="anchor" id="a5fbdf1eed7218c9503f52de87d7b6722"></a><!-- doxytag: member="bdlmt::EventScheduler::start" ref="a5fbdf1eed7218c9503f52de87d7b6722" args="(const bslmt::ThreadAttributes &amp;threadAttributes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::EventScheduler::start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>threadAttributes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin dispatching events on this scheduler, using the specified <code>threadAttributes</code> for the dispatcher thread, except the DETACHED attribute will always be overridden to be joinable. Return 0 on success, and a non-zero value otherwise. If this scheduler is already started then return 0 with no effect. The scheduler must be stopped by invoking <code>stop</code> before it is destroyed. Note that any events scheduled in the past will be dispatched immediately upon starting. </p>

</div>
</div>
<a class="anchor" id="a6c97f4ab147de04cdd5aea2f74347075"></a><!-- doxytag: member="bdlmt::EventScheduler::stop" ref="a6c97f4ab147de04cdd5aea2f74347075" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::EventScheduler::stop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>End the dispatching of events on this scheduler (but do not remove any pending events), and wait for any (one) currently executing event to complete. If the scheduler is already stopped then this method has no effect. This scheduler can be restarted by invoking <code>start</code>. The behavior is undefined if this method is invoked from the dispatcher thread. </p>

</div>
</div>
<a class="anchor" id="aa4191a78b1160df174d811ad3075bf70"></a><!-- doxytag: member="bdlmt::EventScheduler::addEventRefRaw" ref="aa4191a78b1160df174d811ad3075bf70" args="(Event *handle) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a>* bdlmt::EventScheduler::addEventRefRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdlmt_1_1EventScheduler_1_1Event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increment the reference count for the event referred to by the specified <code>handle</code> and return <code>handle</code>. There must be a corresponding call to <code>releaseEventRaw</code> when the reference is no longer needed. </p>

</div>
</div>
<a class="anchor" id="a79b81545a30801e6f8a9e0ab5a6d866f"></a><!-- doxytag: member="bdlmt::EventScheduler::addRecurringEventRefRaw" ref="a79b81545a30801e6f8a9e0ab5a6d866f" args="(RecurringEvent *handle) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbdlmt_1_1EventScheduler_1_1RecurringEvent.html">RecurringEvent</a>* bdlmt::EventScheduler::addRecurringEventRefRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdlmt_1_1EventScheduler_1_1RecurringEvent.html">RecurringEvent</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increment the reference count for the recurring event referred to by the specified <code>handle</code> and return <code>handle</code>. There must be a corresponding call to <code>releaseEventRaw</code> when the reference is no longer needed. </p>

</div>
</div>
<a class="anchor" id="a351b43d56044a16a714ca1f9bf6765d5"></a><!-- doxytag: member="bdlmt::EventScheduler::numEvents" ref="a351b43d56044a16a714ca1f9bf6765d5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::EventScheduler::numEvents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of pending and executing one-time events in this scheduler. </p>

</div>
</div>
<a class="anchor" id="a8968b60d0227c7c0bb9f274da425a9e2"></a><!-- doxytag: member="bdlmt::EventScheduler::numRecurringEvents" ref="a8968b60d0227c7c0bb9f274da425a9e2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::EventScheduler::numRecurringEvents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of recurring events registered with this scheduler. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a12ff9225669b90df2b1b0e8d1d815ea7"></a><!-- doxytag: member="bdlmt::EventScheduler::EventSchedulerEventHandle" ref="a12ff9225669b90df2b1b0e8d1d815ea7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classbdlmt_1_1EventSchedulerEventHandle.html">EventSchedulerEventHandle</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2cbd057ae3bf27e9724bb8433c2271fb"></a><!-- doxytag: member="bdlmt::EventScheduler::EventSchedulerRecurringEventHandle" ref="a2cbd057ae3bf27e9724bb8433c2271fb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classbdlmt_1_1EventSchedulerRecurringEventHandle.html">EventSchedulerRecurringEventHandle</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlmt__eventscheduler_8h_source.html">bdlmt_eventscheduler.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:46 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
