<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslstl_simplepool.h                                                -*-C++-*-
#ifndef INCLUDED_BSLSTL_SIMPLEPOOL
#define INCLUDED_BSLSTL_SIMPLEPOOL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide efficient allocation of memory blocks for a specific type.
//
//@CLASSES:
//  bslstl::SimplePool: memory manager that allocates memory blocks for a type
//
//@SEE_ALSO: bslstl_treenodepool, bdema_pool
//
//@DESCRIPTION: This component implements a memory pool, &#39;bslstl::SimplePool&#39;,
// that allocates and manages memory blocks of for a parameterized type.  A
// &#39;bslstl::SimplePool&#39; object maintains an internal linked list of
// free memory blocks, and dispenses one block for each &#39;allocate&#39; method
// invocation.  When a memory block is deallocated, it is returned to the free
// list for potential reuse.
//
// Whenever the linked list of free memory blocks is depleted,
// &#39;bslstl::SimplePool&#39; replenishes the list by first allocating a large,
// contiguous &quot;chunk&quot; of memory, then splitting the chunk into multiple memory
// blocks each having the &#39;sizeof&#39; the simple pool&#39;s parameterized type.  A
// chunk and its constituent memory blocks can be depicted visually:
//..
//     +-----+--- memory blocks of uniform size for parameterized type
//     |     |
//   ----- ----- ------------
//  |     |     |     ...    |
//   =====^=====^============
//
//   \___________ __________/
//               V
//           a &quot;chunk&quot;
//..
// This pool implementation is simple because its allocation strategy is not
// configurable.  The size of a chunk starts from 1 memory block, and doubles
// each time a chunk is allocated up to an implementation defined maximum
// number of blocks.
//
///Comparison with &#39;bdema_Pool&#39;
///----------------------------
// There are a few differences between &#39;bslstl::SimplePool&#39; and &#39;bdema_Pool&#39;:
//: 1 &#39;bslstl::SimplePool&#39; is parameterized on both allocator and type, which
//:   improve performance and memory usage in exchange for increase in code
//:   size.
//:
//: 2 &#39;bslstl::SimplePool&#39; uses the allocator through the use of
//:   &#39;bsl::allocator_traits&#39; (which is generally not relevant to non-container
//:   type.
//:
//: 3 &#39;bslstl::SimplePool&#39; is less configurable in order to achieve abstraction
//:   of allocation and improvement in performance.
//
// Clients are encouraged to use &#39;bdema_Pool&#39; as &#39;bslstl::SimplePool&#39; is
// designed for node-based STL containers, and its pooling behavior may change
// according to the needs of those containers.
//
///Usage
///-----
// This section illustrates intended use for this component.
//
///Example 1: Creating a Node-Based Stack
/// - - - - - - - - - - - - - - - - - - -
// Suppose that we want to implement a stack with a linked list.  It is
// expensive to allocate memory every time a node is inserted.  Therefore, we
// can use &#39;SimplePool&#39; to efficiently manage the memory for the list.
//
// First, we define the class that implements the stack:
//..
//  template &lt;class ALLOCATOR = bsl::allocator&lt;int&gt; &gt;
//  class my_Stack {
//      // This class defines a node-based stack of integers.
//
//      // PRIVATE TYPES
//      struct Node {
//          // This &#39;struct&#39; implements a link data structure containing a
//          // value and a pointer to the next node.
//
//          int   d_value;   // payload value
//          Node *d_next_p;  // pointer to the next node
//      };
//
//      typedef bslstl::SimplePool&lt;Node, ALLOCATOR&gt; Pool;
//          // Alias for memory pool.
//
//    private:
//      // DATA
//      Node *d_head_p;  // pointer to the first node
//      int   d_size;    // size of the stack
//      Pool  d_pool;    // memory manager for the stack
//
//    public:
//      // CREATORS
//      my_Stack(const ALLOCATOR&amp; allocator = ALLOCATOR());
//          // Create an empty &#39;my_Stack&#39; object.  Optionally specify a
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//          // 0, the currently installed default allocator is used.
//
//      // MANIPULATORS
//      void push(int value);
//          // Insert an element with the specified value to the top of this
//          // stack.
//
//      void pop();
//          // Remove the top element from this stack.  The behavior is
//          // undefined unless &#39;1 &lt;= size()&#39;.
//
//      // ACCESSORS
//      int top();
//          // Return the value of the element on the top of this stack.  The
//          // behavior is undefined unless &#39;1 &lt;= size()&#39;.
//
//      std::size_t size();
//          // Return the number of elements in this stack.
//  };
//..
// Now, we define the implementation of the stack.  Notice how
// &#39;bslstl::SimplePool&#39; is used to allocate memory in &#39;push&#39; and deallocate
// memory in &#39;pop&#39;:
//..
//  // CREATORS
//  template &lt;class ALLOCATOR&gt;
//  my_Stack&lt;ALLOCATOR&gt;::my_Stack(const ALLOCATOR&amp; allocator)
//  : d_head_p(0)
//  , d_size(0)
//  , d_pool(allocator)
//  {
//  }
//
//  // MANIPULATORS
//  template &lt;class ALLOCATOR&gt;
//  void my_Stack&lt;ALLOCATOR&gt;::push(int value)
//  {
//      Node *newNode = d_pool.allocate();
//
//      newNode-&gt;d_value = value;
//      newNode-&gt;d_next_p = d_head_p;
//      d_head_p = newNode;
//
//      ++d_size;
//  }
//
//  template &lt;class ALLOCATOR&gt;
//  void my_Stack&lt;ALLOCATOR&gt;::pop()
//  {
//      BSLS_ASSERT(0 != size());
//
//      Node *n = d_head_p;
//      d_head_p = d_head_p-&gt;d_next_p;
//      d_pool.deallocate(n);
//      --d_size;
//  }
//
//  // ACCESSORS
//  template &lt;class ALLOCATOR&gt;
//  int my_Stack&lt;ALLOCATOR&gt;::top()
//  {
//      BSLS_ASSERT(0 != size());
//
//      return d_head_p-&gt;d_value;
//  }
//
//  template &lt;class ALLOCATOR&gt;
//  std::size_t my_Stack&lt;ALLOCATOR&gt;::size()
//  {
//      return d_size;
//  }
//..
// Finally, we test our stack by pushing and popping some elements:
//..
//  my_Stack stack;
//  stack.push(1);
//  stack.push(2);
//  stack.push(3);
//  stack.push(4);
//  stack.push(5);
//  assert(5 == stack.size());
//
//  assert(5 == stack.top());
//  stack.pop();
//  assert(4 == stack.top());
//  stack.pop();
//  assert(3 == stack.top());
//  stack.pop();
//  assert(2 == stack.top());
//  stack.pop();
//  assert(1 == stack.top());
//  stack.pop();
//  assert(0 == stack.size());
//..

// Prevent &#39;bslstl&#39; headers from being included directly in &#39;BSL_OVERRIDES_STD&#39;
// mode.  Doing so is unsupported, and is likely to cause compilation errors.
#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
#error &quot;&lt;bslstl_simplepool.h&gt; header can&#39;t be included directly in \
BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ALLOCATORTRAITS
#include &lt;bslstl_allocatortraits.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENTFROMTYPE
#include &lt;bsls_alignmentfromtype.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENTUTIL
#include &lt;bsls_alignmentutil.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_ALGORITHM
#include &lt;algorithm&gt;       // &#39;std::swap&#39;
#define INCLUDED_ALGORITHM
#endif

namespace BloombergLP {
namespace bslstl {

                       // ======================
                       // struct SimplePool_Type
                       // ======================

template &lt;class ALLOCATOR&gt;
struct SimplePool_Type {
    // For use only by &#39;bslstl::SimplePool&#39;.  This &#39;struct&#39; provides a
    // namespace for a set of types used to define the base-class of a
    // &#39;SimplePool&#39;.  The parameterized &#39;ALLOCATOR&#39; is bound to
    // &#39;MaxAlignedType&#39; to ensure the allocated memory is maximally aligned.

    typedef typename bsl::allocator_traits&lt;ALLOCATOR&gt;::template
            rebind_traits&lt;bsls::AlignmentUtil::MaxAlignedType&gt; AllocatorTraits;
        // Alias for the allocator traits rebound to allocate
        // &#39;bsls::AlignmentUtil::MaxAlignedType&#39;.

    typedef typename AllocatorTraits::allocator_type AllocatorType;
        // Alias for the allocator type for
        // &#39;bsls::AlignmentUtil::MaxAlignedType&#39;.
};

                       // ================
                       // class SimplePool
                       // ================

template &lt;class VALUE, class ALLOCATOR&gt;
class SimplePool : public SimplePool_Type&lt;ALLOCATOR&gt;::AllocatorType {
    // This class provides methods for creating and deleting nodes using the
    // appropriate allocator-traits of the parameterized &#39;ALLOCATOR&#39;.
    // This type is intended to be used as a private base-class for a
    // node-based container, in order to take advantage of the
    // empty-base-class optimization in the case where the base-class has 0
    // size (as may the case if the parameterized &#39;ALLOCATOR&#39; is not a
    // &#39;bslma::Allocator&#39;).

    // PRIVATE TYPES
    typedef SimplePool_Type&lt;ALLOCATOR&gt; Types;

    union Block {
        // This &#39;union&#39; implements a link data structure with the size no
        // smaller than &#39;VALUE&#39; that stores the address of the next link.
        // It is used to implement the internal linked list of free memory
        // blocks.

        Block *d_next_p;                    // pointer to the next block

        char   d_size[sizeof(VALUE)];       // make a block has the size of at
                                            // least &#39;VALUE&#39;

        typename bsls::AlignmentFromType&lt;VALUE&gt;::Type d_alignment;
                                            // ensure proper alignment
    };

    union Chunk {
        // This &#39;union&#39; prepends to the beginning of each managed block of
        // allocated memory, implementing a singly-linked list of managed
        // chunks, and thereby enabling constant-time additions to the list of
        // chunks.

        Chunk *d_next_p;  // pointer to next Chunk

        typename bsls::AlignmentFromType&lt;Block&gt;::Type d_alignment;
                          // ensure each block is correctly aligned
    };

  private:
    // DATA
    Chunk *d_chunkList_p;     // linked list of &quot;chunks&quot; of memory

    Block *d_freeList_p;      // linked list of free memory blocks

    int    d_blocksPerChunk;  // current chunk size (in blocks-per-chunk)

  private:
    // NOT IMPLEMENTED
    SimplePool&amp; operator=(const SimplePool&amp;);
    SimplePool(const SimplePool&amp;);

  private:
    // PRIVATE MANIPULATORS
    Block *allocateChunk(std::size_t size);
        // Allocate a chunk of memory with at least the specified &#39;size&#39; number
        // of usable bytes and add the chunk to the chunk list.  Return the
        // address of the usable portion of the memory.

    void replenish();
        // Dynamically allocate a new chunk using the pool&#39;s underlying growth
        // strategy, and use the chunk to replenish the free memory list of
        // this pool.

  public:
    // TYPES
    typedef VALUE ValueType;
        // Alias for the parameterized type &#39;VALUE&#39;.

    typedef typename Types::AllocatorType AllocatorType;
        // Alias for the allocator type for a
        // &#39;bsls::AlignmentUtil::MaxAlignedType&#39;.

    typedef typename Types::AllocatorTraits AllocatorTraits;
        // Alias for the allocator traits for the parameterized
        // &#39;ALLOCATOR&#39;.

  public:
    // CREATORS
    explicit SimplePool(const ALLOCATOR&amp; allocator);
        // Create a memory pool that returns blocks of contiguous memory of the
        // size of the parameterized &#39;VALUE&#39; using the specified &#39;allocator&#39; to
        // supply memory.  The chunk size grows starting with at least
        // &#39;sizeof(VALUE)&#39;, doubling in size up to an implementation defined
        // maximum number of blocks per chunk.

    ~SimplePool();
        // Destroy this pool, releasing all associated memory back to the
        // underlying allocator.

    // MANIPULATORS
    AllocatorType&amp; allocator();
        // Return a reference providing modifiable access to the rebound
        // allocator traits for the node-type.  Note that this operation
        // returns a base-class (&#39;AllocatorType&#39;) reference to this object.

    VALUE *allocate();
        // Return the address of a block of memory of at least the size of
        // &#39;VALUE&#39;.  Note that the memory is *not* initialized.

    void deallocate(void *address);
        // Relinquish the memory block at the specified &#39;address&#39; back to this
        // pool object for reuse.  The behavior is undefined unless &#39;address&#39;
        // is non-zero, was allocated by this pool, and has not already been
        // deallocated.

    void reserve(std::size_t numBlocks);
        // Dynamically allocate a new chunk containing the specified
        // &#39;numBlocks&#39; number of blocks, and use the chunk to replenish the
        // free memory list of this pool.  The behavior is undefined unless
        // &#39;0 &lt; numBlocks&#39;.

    void release();
        // Relinquish all memory currently allocated via this pool object.

    void swap(SimplePool&lt;VALUE, ALLOCATOR&gt;&amp; other);
        // Efficiently exchange the memory chunks and blocks of this object and
        // the specified &#39;other&#39; object.  The behavior is undefined unless the
        // underlying mechanisms of &#39;allocator()&#39; refers to the same allocator.

    // ACCESSORS
    const AllocatorType&amp; allocator() const;
        // Return a reference providing non-modifiable access to the rebound
        // allocator traits for the node-type.  Note that this operation
        // returns a base-class (&#39;AllocatorType&#39;) reference to this object.


};

// ============================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ============================================================================

// PRIVATE MANIPULATORS
template &lt;class VALUE, class ALLOCATOR&gt;
typename SimplePool&lt;VALUE, ALLOCATOR&gt;::Block *
SimplePool&lt;VALUE, ALLOCATOR&gt;::allocateChunk(std::size_t size)
{
    // Determine the number of bytes we want to allocate and compute the number
    // of &#39;MaxAlignedType&#39; needed to contain those bytes.

    std::size_t numBytes = sizeof (Chunk) + size;
    std::size_t numMaxAlignedType =
                       (numBytes + bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT - 1)
                     / bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT;

    Chunk *chunkPtr = reinterpret_cast&lt;Chunk *&gt;(
                    AllocatorTraits::allocate(allocator(), numMaxAlignedType));

    BSLS_ASSERT_SAFE(0 ==
             reinterpret_cast&lt;bsls::Types::UintPtr&gt;(chunkPtr) % sizeof(Chunk));

    chunkPtr-&gt;d_next_p = d_chunkList_p;
    d_chunkList_p      = chunkPtr;

    return reinterpret_cast&lt;Block *&gt;(chunkPtr + 1);
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
void SimplePool&lt;VALUE, ALLOCATOR&gt;::replenish()
{
    reserve(d_blocksPerChunk);

    enum { MAX_BLOCKS_PER_CHUNK = 32 };

    if (d_blocksPerChunk &lt; MAX_BLOCKS_PER_CHUNK) {
        d_blocksPerChunk *= 2;
    }
}

// CREATORS
template &lt;class VALUE, class ALLOCATOR&gt;
inline
SimplePool&lt;VALUE, ALLOCATOR&gt;::SimplePool(const ALLOCATOR&amp; allocator)
: AllocatorType(allocator)
, d_chunkList_p(0)
, d_freeList_p(0)
, d_blocksPerChunk(1)
{
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
SimplePool&lt;VALUE, ALLOCATOR&gt;::~SimplePool()
{
    release();
}

// MANIPULATORS
template &lt;class VALUE, class ALLOCATOR&gt;
inline
typename SimplePool&lt;VALUE, ALLOCATOR&gt;::AllocatorType&amp;
SimplePool&lt;VALUE, ALLOCATOR&gt;::allocator()
{
    return *this;
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
VALUE *SimplePool&lt;VALUE, ALLOCATOR&gt;::allocate()
{
    if (!d_freeList_p) {
        replenish();
    }
    VALUE *block = reinterpret_cast&lt;VALUE *&gt;(d_freeList_p);
    d_freeList_p = d_freeList_p-&gt;d_next_p;
    return block;
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
void SimplePool&lt;VALUE, ALLOCATOR&gt;::deallocate(void *address)
{
    BSLS_ASSERT_SAFE(address);

    reinterpret_cast&lt;Block *&gt;(address)-&gt;d_next_p = d_freeList_p;
    d_freeList_p = reinterpret_cast&lt;Block *&gt;(address);
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
void SimplePool&lt;VALUE, ALLOCATOR&gt;::swap(SimplePool&lt;VALUE, ALLOCATOR&gt;&amp; other)
{
    BSLS_ASSERT_SAFE(allocator() == other.allocator());

    std::swap(d_blocksPerChunk, other.d_blocksPerChunk);
    std::swap(d_freeList_p, other.d_freeList_p);
    std::swap(d_chunkList_p, other.d_chunkList_p);
}

template &lt;class VALUE, class ALLOCATOR&gt;
void SimplePool&lt;VALUE, ALLOCATOR&gt;::reserve(std::size_t numBlocks)
{
    BSLS_ASSERT(0 &lt; numBlocks);

    Block *begin = allocateChunk(numBlocks * sizeof(Block));
    Block *end   = begin + numBlocks - 1;

    for (Block *p = begin; p &lt; end; ++p) {
        p-&gt;d_next_p = p + 1;
    }
    end-&gt;d_next_p = d_freeList_p;
    d_freeList_p  = begin;
}

// ACCESSORS
template &lt;class VALUE, class ALLOCATOR&gt;
inline
const typename SimplePool&lt;VALUE, ALLOCATOR&gt;::AllocatorType&amp;
SimplePool&lt;VALUE, ALLOCATOR&gt;::allocator() const
{
    return *this;
}

template &lt;class VALUE, class ALLOCATOR&gt;
void SimplePool&lt;VALUE, ALLOCATOR&gt;::release()
{
    while (d_chunkList_p) {
        typename AllocatorTraits::value_type *lastChunk =
                      reinterpret_cast&lt;typename AllocatorTraits::value_type *&gt;(
                                                                d_chunkList_p);
        d_chunkList_p   = d_chunkList_p-&gt;d_next_p;
        AllocatorTraits::deallocate(allocator(), lastChunk, 1);
    }
    d_freeList_p = 0;
}

}  // close namespace bslstl
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
