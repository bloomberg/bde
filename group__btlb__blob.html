<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlb_blob Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlb_blob<br/>
<small>
[<a class="el" href="group__btlb.html">Package btlb</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an indexed set of buffers from multiple sources.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlb.html">btlb</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslmf.html">bslmf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: A Simple Blob Buffer Factory</a> </li>
<li>
<a href="#3.2.2">Simple Blob Usage</a> </li>
<li>
<a href="#3.2.3">Example 2: Data-Oriented Manipulation of a Blob</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an indexed set of buffers from multiple sources. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlb_1_1BlobBuffer.html">btlb::BlobBuffer</a> </td><td>in-core representation of a shared buffer  </td></tr>
<tr>
<td><a class="el" href="classbtlb_1_1BlobBufferFactory.html">btlb::BlobBufferFactory</a> </td><td>factory of blob buffers  </td></tr>
<tr>
<td><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> </td><td>indexed sequence of buffers  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bcema_sharedptr, <a class="el" href="group__btlb__pooledblobbufferfactory.html" title="Provide a concrete implementation of btlb::BlobBufferFactory.">Component btlb_pooledblobbufferfactory</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides an indexed sequence (<code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code>) of <code><a class="el" href="classbtlb_1_1BlobBuffer.html">btlb::BlobBuffer</a></code> objects allocated from potentially multiple <code><a class="el" href="classbtlb_1_1BlobBufferFactory.html">btlb::BlobBufferFactory</a></code> objects. A <code><a class="el" href="classbtlb_1_1BlobBuffer.html">btlb::BlobBuffer</a></code> is a simple in-core value object owning a shared pointer to a memory buffer. Therefore, the lifetime of the underlying memory is determined by shared ownership between the blob buffer, the blob(s) that may contain it, and any other entities that may share ownership of the memory buffer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Logically, a <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code> can be thought of as a sequence of bytes (although not contiguous). Each buffer in a blob contributes its own size to the blob, with the total size of a blob being the sum of sizes over all its buffers. A prefix of these bytes, collectively referred to as the data of the blob, are defined by the data length, which can be set by the user using the <code>setLength</code> method. Note that the data length never exceeds the total size. When setting the length to a value greater than the total size, the latter is increased automatically by adding buffers created from a factory passed at construction; the behavior is undefined if no factory was supplied at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The blob also updates its data length during certain operations (e.g., insertion/removal of buffers containing some data bytes), as well as several attributes driven by the data length. The first bytes numbered by the data length belong to the data buffers. Note that all data buffers, except perhaps the last, contribute all their bytes to the <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code> data. The last data buffer contributes anywhere between one and all of its bytes to the <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code> data. The number of data buffers (returned by the <code>numDataBuffers</code> method), as well as the last data buffer length (returned by <code>lastDataBufferLength</code>), are maintained by <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code> automatically when setting the length to a new value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Buffers which do not contain data are referred to as capacity buffers. The total size of a blob does not decrease when setting the length to a value smaller than the current length. Instead, any data buffer that no longer contains data after the call to <code>setLength</code> becomes a capacity buffer, and may become a data buffer again later if setting length past its prefix size. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This design is intended to allow very efficient re-assignment of buffers (or part of buffers using shared pointer aliasing) between different blobs, without copying of the underlying data, while promoting efficient allocation of resources (via retaining capacity). Thus, <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code> is an advantageous replacement for <code>btlb::PooledBufferChain</code> when manipulation of the sequence, sharing of portions of the sequence, and lifetime management of individual portions of the sequence, are desired. Another added flexibility of <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code> is the possibility for buffers in the sequence to have different sizes (as opposed to a uniform fixed size for <code>btlb::PooledBufferChain</code>). When choosing whether to use a <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code> vs. a <code>btlb::PooledBufferChain</code>, one must consider the added flexibility versus the added cost of shared ownership for each individual buffer and random access to the buffer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Different instances of the classes defined in this component can be concurrently modified by different threads. Thread safety of a particular instance is not guaranteed, and therefore must be handled by the user. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_a_simple_blob_buffer_factory"></a> <a class="anchor" id="usage.example_1~3A_a_simple_blob_buffer_factory"></a> <a class="anchor" id="description.usage.example_1~3A_a_simple_blob_buffer_factory"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: A Simple Blob Buffer Factory: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Classes that implement the <code><a class="el" href="classbtlb_1_1BlobBufferFactory.html">btlb::BlobBufferFactory</a></code> protocol are used to allocate <code><a class="el" href="classbtlb_1_1BlobBuffer.html">btlb::BlobBuffer</a></code> objects. A simple implementation follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>SimpleBlobBufferFactory : <span class="keyword">public</span> btlb::BlobBufferFactory {
      <span class="comment">// This factory creates blob buffers of a fixed size specified at</span>
      <span class="comment">// construction.</span>

      <span class="comment">// DATA</span>
      bsl::size_t       d_bufferSize;
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      SimpleBlobBufferFactory(<span class="keyword">const</span> SimpleBlobBufferFactory&amp;);
      SimpleBlobBufferFactory&amp; operator=(<span class="keyword">const</span> SimpleBlobBufferFactory&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> SimpleBlobBufferFactory(<span class="keywordtype">int</span>               bufferSize = 1024,
                                       <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
      ~SimpleBlobBufferFactory();

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> allocate(<a class="code" href="classbtlb_1_1BlobBuffer.html">btlb::BlobBuffer</a> *buffer);
  };

  SimpleBlobBufferFactory::SimpleBlobBufferFactory(
                                            <span class="keywordtype">int</span>               bufferSize,
                                            <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_bufferSize(bufferSize)
  , d_allocator_p(bslma::Default::allocator(basicAllocator))
  {
  }

  SimpleBlobBufferFactory::~SimpleBlobBufferFactory()
  {
  }

  <span class="keywordtype">void</span> SimpleBlobBufferFactory::allocate(<a class="code" href="classbtlb_1_1BlobBuffer.html">btlb::BlobBuffer</a> *buffer)
  {
      <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;char&gt;</a> shptr(
                              (<span class="keywordtype">char</span> *) d_allocator_p-&gt;allocate(d_bufferSize),
                              d_allocator_p);

      buffer-&gt;<a class="code" href="classbtlb_1_1BlobBuffer.html#ad2a1d6cbcbdc4a16a901a94f19869b91">reset</a>(shptr, d_bufferSize);
  }
</pre></div><br/>
<br/>
 Note that should the user desire a blob buffer factory for his/her application, a better implementation that pools buffers is available in the <code>btlb_pooledblobbufferfactory</code> component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="simple_blob_usage"></a> <a class="anchor" id="usage.simple_blob_usage"></a> <a class="anchor" id="description.usage.simple_blob_usage"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Simple Blob Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Blobs can be created just by passing a factory that is responsible to allocate the <code><a class="el" href="classbtlb_1_1BlobBuffer.html">btlb::BlobBuffer</a></code>. The following simple program illustrates how. <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      SimpleBlobBufferFactory myFactory(1024);

      <a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a> blob(&amp;myFactory);
      assert(0    == blob.length());
      assert(0    == blob.totalSize());

      blob.setLength(512);
      assert( 512 == blob.length());
      assert(1024 == blob.totalSize());
</pre></div><br/>
<br/>
 Users need to access buffers directly in order to read/write data. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">char</span> data[] = <span class="stringliteral">&quot;12345678901234567890&quot;</span>; <span class="comment">// 20 bytes</span>
      assert(0 != blob.numBuffers());
      assert(static_cast&lt;int&gt;(<span class="keyword">sizeof</span>(data)) &lt;= blob.buffer(0).size());
      bsl::memcpy(blob.buffer(0).data(), data, <span class="keyword">sizeof</span>(data));

      blob.setLength(<span class="keyword">sizeof</span>(data));
      assert(<span class="keyword">sizeof</span> data == blob.length());
      assert(       1024 == blob.totalSize());
</pre></div><br/>
<br/>
 A <code><a class="el" href="classbtlb_1_1BlobBuffer.html">btlb::BlobBuffer</a></code> can easily be re-assigned from one blob to another with no copy. In that case, the memory held by the buffer will be returned to its factory when the last blob referencing the buffer is destroyed. For the following example, a blob will be created using the default constructor. In this case, the <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code> object will not able to grow on its own. Calling <code>setLength</code> for a number equal or greater than <code>totalSize()</code> will result in undefined behavior. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a> dest;
      assert(   0 == dest.<a class="code" href="classbtlb_1_1Blob.html#af1369c876ea54a9996e2b4d557123a7d">length</a>());
      assert(   0 == dest.<a class="code" href="classbtlb_1_1Blob.html#a898bfd49811d8e436fddfe6c16096cad">totalSize</a>());

      assert(0 != blob.numBuffers());
      dest.<a class="code" href="classbtlb_1_1Blob.html#a0d504bf7aa649f0ca01ee9933ab89afc">appendBuffer</a>(blob.buffer(0));
      assert(   0 == dest.<a class="code" href="classbtlb_1_1Blob.html#af1369c876ea54a9996e2b4d557123a7d">length</a>());
      assert(1024 == dest.<a class="code" href="classbtlb_1_1Blob.html#a898bfd49811d8e436fddfe6c16096cad">totalSize</a>());
</pre></div><br/>
<br/>
 Note that at this point, the logical length (returned by <code>length</code>) of this object has not changed. <code>setLength</code> must be called explicitly by the user if the logical length of the <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code> must be changed: <br/>
<br/>
<div class="fragment"><pre class="fragment">      dest.<a class="code" href="classbtlb_1_1Blob.html#a08104301f34c449ee11eb1ccbc98946e">setLength</a>(dest.<a class="code" href="classbtlb_1_1Blob.html#a000ceb458dd2ffcbcec7f8add024dc90">buffer</a>(0).size());
      assert(1024 == dest.<a class="code" href="classbtlb_1_1Blob.html#af1369c876ea54a9996e2b4d557123a7d">length</a>());
      assert(1024 == dest.<a class="code" href="classbtlb_1_1Blob.html#a898bfd49811d8e436fddfe6c16096cad">totalSize</a>());
</pre></div><br/>
<br/>
 Sharing only a part of a buffer is also possible through shared pointer aliasing. In the following example, a buffer that contains only bytes 11-16 from the first buffer of <code>blob</code> will be appended to <code>blob</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      assert(0 != blob.numBuffers());
      assert(16 &lt;= blob.buffer(0).size());

      <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;char&gt;</a> shptr(blob.buffer(0).buffer(),
                                  blob.buffer(0).data() + 10);
          <span class="comment">// &#39;shptr&#39; is now an alias of &#39;blob.buffer(0).buffer()&#39;.</span>

      <a class="code" href="classbtlb_1_1BlobBuffer.html">btlb::BlobBuffer</a> partialBuffer(shptr, 6);
      dest.<a class="code" href="classbtlb_1_1Blob.html#a0d504bf7aa649f0ca01ee9933ab89afc">appendBuffer</a>(partialBuffer);
          <span class="comment">// The last buffer of &#39;dest&#39; contains only bytes 11-16 from</span>
          <span class="comment">// &#39;blob.buffer(0)&#39;.</span>
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_data-oriented_manipulation_of_a_blob"></a> <a class="anchor" id="usage.example_2~3A_data-oriented_manipulation_of_a_blob"></a> <a class="anchor" id="description.usage.example_2~3A_data-oriented_manipulation_of_a_blob"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Data-Oriented Manipulation of a Blob: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are several typical ways of manipulating a blob: the simplest lets the blob automatically manage the length, by using only <code>prependBuffer</code>, <code>appendBuffer</code>, and <code>insertBuffer</code>. Consider the following typical utilities (these utilities are to illustrate usage, they are not meant to be copy-pasted into application programs although they can provide a foundation for application utilities): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> prependProlog(<a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a>         *blob,
                     <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;  prolog,
                     <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *allocator = 0);
      <span class="comment">// Prepend the specified &#39;prolog&#39; to the specified &#39;blob&#39;, using the</span>
      <span class="comment">// optionally specified &#39;allocator&#39; to supply any memory (or the</span>
      <span class="comment">// currently installed default allocator if &#39;allocator&#39; is 0).  The</span>
      <span class="comment">// behavior is undefined unless &#39;blob&#39; points to an initialized</span>
      <span class="comment">// &#39;btlb::Blob&#39; instance.</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> DELETER&gt;
  <span class="keywordtype">void</span> composeMessage(<a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a>         *blob,
                      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;  prolog,
                      <span class="keywordtype">char</span> * <span class="keyword">const</span>       *vectors,
                      <span class="keyword">const</span> <span class="keywordtype">int</span>          *vectorSizes,
                      <span class="keywordtype">int</span>                 numVectors,
                      <span class="keyword">const</span> DELETER&amp;      deleter,
                      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *allocator = 0);
      <span class="comment">// Load into the specified &#39;blob&#39; the data composed of the specified</span>
      <span class="comment">// &#39;prolog&#39; and of the payload in the &#39;numVectors&#39; buffers pointed to</span>
      <span class="comment">// by the specified &#39;vectors&#39; of the respective &#39;vectorSizes&#39;.</span>
      <span class="comment">// Ownership of the vectors is transferred to the &#39;blob&#39; which will use</span>
      <span class="comment">// the specified &#39;deleter&#39; to destroy them.  Use the optionally</span>
      <span class="comment">// specified &#39;allocator&#39; to supply memory, or the currently installed</span>
      <span class="comment">// default allocator if &#39;allocator&#39; is 0.  Note that any buffer</span>
      <span class="comment">// belonging to &#39;blob&#39; prior to composing the message is not longer in</span>
      <span class="comment">// &#39;blob&#39; after composing the message.  Note also that &#39;blob&#39; need not</span>
      <span class="comment">// have been created with a blob buffer factory.  The behavior is</span>
      <span class="comment">// undefined unless &#39;blob&#39; points to an initialized &#39;btlb::Blob&#39;</span>
      <span class="comment">// instance.</span>

  <span class="keywordtype">int</span> timestampMessage(<a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a> *blob, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0);
      <span class="comment">// Insert a timestamp data buffer immediately after the prolog buffer</span>
      <span class="comment">// and prior to any payload buffer.  Return the number of bytes</span>
      <span class="comment">// inserted.  Use the optionally specified &#39;allocator&#39; to supply</span>
      <span class="comment">// memory, or the currently installed default allocator if &#39;allocator&#39;</span>
      <span class="comment">// is 0.  The behavior is undefined unless the specified &#39;blob&#39; points</span>
      <span class="comment">// to an initialized &#39;btlb::Blob&#39; instance with at least one data</span>
      <span class="comment">// buffer.</span>
</pre></div><br/>
<br/>
 A possible implementation using only <code>prependBuffer</code>, <code>appendBuffer</code>, and <code>insertBuffer</code> could be as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> prependProlog(<a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a>         *blob,
                     <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;  prolog,
                     <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *allocator)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(blob);

      (void)allocator;

      <span class="keywordtype">int</span> prologLength = prolog.<a class="code" href="group__bslstl__string.html#ga3c33f63f9d195be7499bd2f7cdb085ff">length</a>();
      SimpleBlobBufferFactory fa(prologLength + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
      <a class="code" href="classbtlb_1_1BlobBuffer.html">btlb::BlobBuffer</a> prologBuffer;
      fa.allocate(&amp;prologBuffer);

      <a class="code" href="structbslx_1_1MarshallingUtil.html#a2679531dc11461725b20ebdee1772dac">bslx::MarshallingUtil::putInt32</a>(prologBuffer.<a class="code" href="classbtlb_1_1BlobBuffer.html#a681b9309cca692ba13f57dd68cf7521e">data</a>(), prologLength);
      bsl::memcpy(prologBuffer.<a class="code" href="classbtlb_1_1BlobBuffer.html#a681b9309cca692ba13f57dd68cf7521e">data</a>() + <span class="keyword">sizeof</span>(int),
                  prolog.<a class="code" href="group__bslstl__string.html#gacef38ff51dcfc556fa13dda42a2665df">c_str</a>(),
                  prologLength);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(prologBuffer.<a class="code" href="classbtlb_1_1BlobBuffer.html#a21755d29896a95e156208d82c5312324">size</a>() == prologLength + <span class="keyword">sizeof</span>(int));

      blob-&gt;<a class="code" href="classbtlb_1_1Blob.html#a730f4e4ac8050876ec99da82daf74f43">prependDataBuffer</a>(prologBuffer);
  }
</pre></div><br/>
<br/>
 Note that the length of <code>blob</code> in the above implementation is automatically incremented by <code>prologBuffer.size()</code>. Consider instead: <br/>
<br/>
<div class="fragment"><pre class="fragment">      blob-&gt;<a class="code" href="classbtlb_1_1Blob.html#a006fd5988fe641ae2bc2f94017c20da4">insertBuffer</a>(0, prologBuffer);
</pre></div><br/>
<br/>
 which inserts the prologBuffer before the first buffer of <code>blob</code>. This call will almost always adjust the length properly <em>except</em> if the length of <code>blob</code> is 0 before the insertion (i.e., the message has an empty payload). In that case, the resulting <code>blob</code> will still be empty after <code>prependProlog</code>, which, depending on the intention of the programmer, could be intended (avoid sending empty messages) or could be (most likely) a mistake. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>composeMessage</code> implementation is simplified by using <code>prependProlog</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> DELETER&gt;
  <span class="keywordtype">void</span> composeMessage(<a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a>         *blob,
                      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;  prolog,
                      <span class="keywordtype">char</span> * <span class="keyword">const</span>       *vectors,
                      <span class="keyword">const</span> <span class="keywordtype">int</span>          *vectorSizes,
                      <span class="keywordtype">int</span>                 numVectors,
                      <span class="keyword">const</span> DELETER&amp;      deleter,
                      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *allocator)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(blob);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(vectors);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt;= numVectors);

      blob-&gt;<a class="code" href="classbtlb_1_1Blob.html#a0850ccbd58c2f19e5eb5bb91ece9033a">removeAll</a>();
      prependProlog(blob, prolog, allocator);

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numVectors; ++i) {
          <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;char&gt;</a> shptr(vectors[i], deleter, allocator);
          <a class="code" href="classbtlb_1_1BlobBuffer.html">btlb::BlobBuffer</a> partialBuffer(shptr, vectorSizes[i]);
          blob-&gt;<a class="code" href="classbtlb_1_1Blob.html#a99f05cefe5b8dcaa53cd66929e1199df">appendDataBuffer</a>(partialBuffer);
              <span class="comment">// The last buffer of &#39;dest&#39; contains only bytes 11-16 from</span>
              <span class="comment">// &#39;blob.buffer(0)&#39;.</span>
      }
  }
</pre></div><br/>
<br/>
 Note that the <code>deleter</code> is used to destroy the buffers transferred by <code>vectors</code>, but not the prolog buffer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Timestamping a message is done by creating a buffer holding a timestamp, and inserting it after the prolog and before the payload of the message. Note that in typical messages, timestamps would be part of the prolog itself, so this is a somewhat contrived example for exposition only. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> timestampMessage(<a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a> *blob, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(blob);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt; blob-&gt;<a class="code" href="classbtlb_1_1Blob.html#a7dcdb6c3d0c9847d0c1954d6fba65fec">numDataBuffers</a>());

      <a class="code" href="classbtlb_1_1BlobBuffer.html">btlb::BlobBuffer</a> buffer;
      <a class="code" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a> now = <a class="code" href="structbdlt_1_1CurrentTime.html#a42d082242c48b7445d21cabbaec1b50b">bdlt::CurrentTime::utc</a>();

      SimpleBlobBufferFactory fa(128, allocator);
      <a class="code" href="classbtlb_1_1BlobBuffer.html">btlb::BlobBuffer</a> timestampBuffer;
      fa.allocate(&amp;timestampBuffer);

      <a class="code" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a> bdexStream(20150826);
      now.<a class="code" href="classbdlt_1_1Datetime.html#a3c6322acedf61c15490c346c4c32a78b">bdexStreamOut</a>(bdexStream, 1);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(bdexStream);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(bdexStream.length() &lt; 128);
      bsl::memcpy(timestampBuffer.<a class="code" href="classbtlb_1_1BlobBuffer.html#a681b9309cca692ba13f57dd68cf7521e">data</a>(),
                  bdexStream.data(),
                  bdexStream.length());
      timestampBuffer.<a class="code" href="classbtlb_1_1BlobBuffer.html#a55763d56bb62aacfed79521174b43182">setSize</a>(bdexStream.length());
</pre></div><br/>
<br/>
 Now that we have fabricated the buffer holding the current data and time, we must insert it into the blob after the first buffer (i.e., before the buffer at index 1). Note however that the payload could be empty, a condition tested by the fact that there is only one data buffer in <code>blob</code>. In that case, it would be a mistake to use <code>insertBuffer</code> since it would not modify the length of the blob. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (1 &lt; blob-&gt;<a class="code" href="classbtlb_1_1Blob.html#a7dcdb6c3d0c9847d0c1954d6fba65fec">numDataBuffers</a>()) {
          blob-&gt;<a class="code" href="classbtlb_1_1Blob.html#a006fd5988fe641ae2bc2f94017c20da4">insertBuffer</a>(1, timestampBuffer);
      } <span class="keywordflow">else</span> {
          blob-&gt;<a class="code" href="classbtlb_1_1Blob.html#a99f05cefe5b8dcaa53cd66929e1199df">appendDataBuffer</a>(timestampBuffer);
      }

      <span class="keywordflow">return</span> bdexStream.length();
  }
</pre></div><br/>
<br/>
 Note that the call to <code>appendDataBuffer</code> also takes care of the possibility that the first buffer of <code>blob</code> may not be full to capacity (if the length of the blob was smaller than the buffer size, only the first <code>blob-&gt;length()</code> bytes would contain prolog data). In that case, that buffer is trimmed before appending the <code>timestampBuffer</code> so that the first byte of the <code>timestampBuffer</code> appears immediately next to the last prolog byte, and the blob length is automatically incremented by the size of the <code>timestampBuffer</code>. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:12 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
