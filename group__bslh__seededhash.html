<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslh_seededhash Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslh_seededhash<br/>
<small>
[<a class="el" href="group__bslh.html">Package bslh</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a struct to run seeded <code>bslh</code> hash algorithms on types.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslh.html">bslh</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Relationship to <code>bslh::Hash</code></a> </li>
<li>
<a href="#3.2">Requirements for Seeded <code>bslh</code> Hashing Algorithms</a> </li>
<li>
<a href="#3.3">Requirements on (template parameter) Type <code>SEED_GENERATOR</code></a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example: Storing User Defined Input in a Hash Table</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a struct to run seeded <code>bslh</code> hash algorithms on types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a> </td><td>functor that runs seeded <code>bslh</code> hash algorithms on types  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslh__hash.html" title="Provide a struct to run bslh hash algorithms on supported types.">Component bslh_hash</a>, <a class="el" href="group__bslh__seedgenerator.html" title="Provide a class to generate arbitrary length seeds for algorithms.">Component bslh_seedgenerator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a templated <code>struct</code>, <code><a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a></code>, that defines a hash-functor that can be used with standard containers (a drop in replacement for <code><a class="el" href="structbsl_1_1hash.html">bsl::hash</a></code>), and which applies the supplied (template parameter) <code>HASH_ALGORITHM</code> to the attributes of the (template parameter) <code>TYPE</code> which have been identified as salient to hashing. The <code><a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a></code> template parameter <code>HASH_ALGORITHM</code> must be a hashing algorithm that conforms the the requirements outlined below (see <a href="group__bslh__seededhash.html#requirements_for_seeded_bslh_hashing_algorithms" class="el">Requirements for Seeded <code>bslh</code> Hashing Algorithms</a>). Note that there are several hashing algorithms defined in <code>bslh</code>, some of which do not accept seeds, meaning they cannot be used with <code><a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a></code> will use the (template parameter) <code>SEED_GENERATOR</code> to generate the seed used to instantiate the <code>HASH_ALGORITHM</code>. The <code><a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a></code> template parameter <code>SEED_GENERATOR</code> must be a seed generator that conforms the the requirements outlined below (see <a href="group__bslh__seededhash.html#requirements_on_(template_parameter)_type_seed_generator" class="el">Requirements on (template parameter) Type <code>SEED_GENERATOR</code></a>). The seed will be generated once upon construction of <code><a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a></code> and then held until destruction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A call to <code>bslh::Hash::operator()</code> for a (template parameter) <code>TYPE</code> will call the <code>hashAppend</code> free function for <code>TYPE</code> and provide <code>hashAppend</code> an instance of the <code>HASH_ALGORITHM</code> which has been constructed using the stored seed. Clients are expected to define a free-function <code>hashAppend</code> for each of the types they wish to be hashable (see <code><a class="el" href="bslh__hash_8h.html" title="Provide a struct to run bslh hash algorithms on supported types.">bslh_hash.h</a></code> for details on <code>hashAppend</code>). More information can be found in the package level documentation for <code>bslh</code> (internal users can also find information here {TEAM BDE:USING MODULAR HASHING&lt;GO&gt;}) </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="relationship_to_bslh~3A~3Ahash"></a> <a class="anchor" id="description.relationship_to_bslh~3A~3Ahash"></a> <a class="anchor" id="relationship_to_bslh"></a> <a class="anchor" id="description.relationship_to_bslh"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Relationship to bslh::Hash: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a></code> is substantially similar to <code><a class="el" href="structbslh_1_1Hash.html">bslh::Hash</a></code>. <code><a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a></code> presents a similar interface to that of <code><a class="el" href="structbslh_1_1Hash.html">bslh::Hash</a></code>, however, it adds a constructor that accepts a seed generator. Because of the use of seeds, <code><a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a></code> stores data and therefor does not allow the empty base optimization like <code><a class="el" href="structbslh_1_1Hash.html">bslh::Hash</a></code> does. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_for_seeded_bslh_hashing_algorithms"></a> <a class="anchor" id="description.requirements_for_seeded_bslh_hashing_algorithms"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Requirements for Seeded bslh Hashing Algorithms: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Users of this modular hashing system are free write their own hashing algorithms. In order to plug into <code><a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a></code>, the user-implemented algorithms must meet the requirements for regular <code>bslh</code> hashing algorithms defined in <code><a class="el" href="bslh__hash_8h.html" title="Provide a struct to run bslh hash algorithms on supported types.">bslh_hash.h</a></code>, with the exception that a default constructor is not required. The user-implemented algorithm must also implement the interface shown here: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>SomeHashAlgorithm
 {
   <span class="keyword">public</span>:
     <span class="comment">// CONSTANTS</span>
     <span class="keyword">enum</span> { k_SEED_LENGTH = XXX };

     <span class="comment">// CREATORS</span>
     <span class="keyword">explicit</span> SomeHashAlgorithm(<span class="keyword">const</span> <span class="keywordtype">char</span> *seed);
 };
</pre></div><br/>
<br/>
 The <code>k_SEED_LENGTH</code> enum must be in the public interface, and <code>XXX</code> must be replaced with an integer literal indicating the number of bytes of seed the algorithm requires. The parameterized constructor must accept a <code>const char *</code>. This pointer will point to a seed of <code>XXX</code> bytes in size. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_on_(template_parameter)_type_seed_generator"></a> <a class="anchor" id="description.requirements_on_(template_parameter)_type_seed_generator"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Requirements on (template parameter) Type SEED_GENERATOR: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Users are free to write their own seed generator, which can be supplied to <a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a>. The seed generator must conform to the interface shown here: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>SomeSeedGenerator
 {
     <span class="comment">// ACCESSORS</span>
     <span class="keywordtype">void</span> generateSeed(<span class="keywordtype">char</span> *seedLocation, <span class="keywordtype">size_t</span> seedLength);
 };
</pre></div><br/>
<br/>
 The only mandatory piece of the seed generator interface is the generateSeed method, which accepts a char pointer to memory to be written and a size_t length in bytes. The generateSeed method must fill the size_t bytes of the memory pointed to by the char pointer with a seed. The seed generator must be meet one of the two requirements: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> A The seed generator is default constructible.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> B The seed generator is copy constructible.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Option A is preferred because it allows <code><a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a></code> to be default constructible. Option B is allowed, but means that <code><a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a></code> must be passed an already-instantiated <code>SEED_GENERATOR</code> at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example~3A_storing_user_defined_input_in_a_hash_table"></a> <a class="anchor" id="usage.example~3A_storing_user_defined_input_in_a_hash_table"></a> <a class="anchor" id="description.usage.example~3A_storing_user_defined_input_in_a_hash_table"></a> <a class="anchor" id="example"></a> <a class="anchor" id="usage.example"></a> <a class="anchor" id="description.usage.example"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example: Storing User Defined Input in a Hash Table: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we have any array of user-specified nicknames, and we want a really fast way to find out if values are contained in the array. We can create a <code>HashTable</code> data structure that is capable of looking up values in O(1) time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Because we will be storing arbitrary user input in our table, it is possible that an attacker with knowledge of the hashing algorithm we are using could specially craft input that will cause collisions in our hash table, degrading performance to O(n). To avoid this we will need to use a secure hash algorithm with a random seed. This algorithm will need to be in the form of a hash functor -- an object that will take objects stored in our array as input, and yield a 64-bit int value which is hard enough for an outside observer to predict that it appear random. <code><a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a></code> provides a convenient functor that can wrap any seeded hashing algorithm and use it to produce a hash for any type them implements <code>hashAppend</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We can use the result of the hash function to index into our array of <code>buckets</code>. Each <code>bucket</code> is simply a pointer to a value in our original array of <code>TYPE</code> objects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define our <code>HashTable</code> template class, with the two type parameters: <code>TYPE</code> (the type being referenced) and <code>HASHER</code> (a functor that produces the hash). <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE, <span class="keyword">class</span> HASHER&gt;
  <span class="keyword">class </span>HashTable {
      <span class="comment">// This class template implements a hash table providing fast lookup of</span>
      <span class="comment">// an external, non-owned, array of values of (template parameter)</span>
      <span class="comment">// &#39;TYPE&#39;.</span>
      <span class="comment">//</span>
      <span class="comment">// The (template parameter) &#39;TYPE&#39; shall have a transitive, symmetric</span>
      <span class="comment">// &#39;operator==&#39; function and it will be hashable using &#39;bslh::Hash&#39;.</span>
      <span class="comment">// Note that there is no requirement that it have any kind of creator</span>
      <span class="comment">// defined.</span>
      <span class="comment">//</span>
      <span class="comment">// The &#39;HASHER&#39; template parameter type must be a functor with a method</span>
      <span class="comment">// having the following signature:</span>
      <span class="comment">//..</span>
      <span class="comment">//  size_t operator()(TYPE)  const;</span>
      <span class="comment">//                   -OR-</span>
      <span class="comment">//  size_t operator()(const TYPE&amp;) const;</span>
      <span class="comment">//..</span>
      <span class="comment">// and &#39;HASHER&#39; shall have a publicly accessible default constructor</span>
      <span class="comment">// and destructor.  Here we use &#39;bslh::Hash&#39; as our default template</span>
      <span class="comment">// argument.  This allows us to hash any type for which &#39;hashAppend&#39;</span>
      <span class="comment">// has been implemented.</span>
      <span class="comment">//</span>
      <span class="comment">// Note that this hash table has numerous simplifications because we</span>
      <span class="comment">// know the size of the array and never have to resize the table.</span>

      <span class="comment">// DATA</span>
      <span class="keyword">const</span> TYPE       *d_values;          <span class="comment">// Array of values table is to</span>
                                           <span class="comment">// hold</span>
      <span class="keywordtype">size_t</span>            d_numValues;       <span class="comment">// Length of &#39;d_values&#39;.</span>
      <span class="keyword">const</span> TYPE      **d_bucketArray;     <span class="comment">// Contains ptrs into &#39;d_values&#39;</span>
      <span class="keywordtype">unsigned</span>          d_bucketArrayMask; <span class="comment">// Will always be &#39;2^N - 1&#39;.</span>
      HASHER            d_hasher;          <span class="comment">// User supplied hashing algorithm</span>

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE ACCESSORS</span>
      <span class="keywordtype">bool</span> lookup(<span class="keywordtype">size_t</span>      *idx,
                  <span class="keyword">const</span> TYPE&amp;  value,
                  <span class="keywordtype">size_t</span>       hashValue) <span class="keyword">const</span>;
          <span class="comment">// Look up the specified &#39;value&#39;, having the specified &#39;hashValue&#39;,</span>
          <span class="comment">// and load its index in &#39;d_bucketArray&#39; into the specified &#39;idx&#39;.</span>
          <span class="comment">// If not found, return the vacant entry in &#39;d_bucketArray&#39; where</span>
          <span class="comment">// it should be inserted.  Return &#39;true&#39; if &#39;value&#39; is found and</span>
          <span class="comment">// &#39;false&#39; otherwise.</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      HashTable(<span class="keyword">const</span> TYPE *valuesArray,
                <span class="keywordtype">size_t</span>      numValues,
                HASHER      hasher);
          <span class="comment">// Create a hash table referring to the specified &#39;valuesArray&#39;</span>
          <span class="comment">// having length of the specified &#39;numValues&#39; and using the</span>
          <span class="comment">// specified &#39;hasher&#39; to generate hash values.  No value in</span>
          <span class="comment">// &#39;valuesArray&#39; shall have the same value as any of the other</span>
          <span class="comment">// values in &#39;valuesArray&#39;</span>

      ~HashTable();
          <span class="comment">// Free up memory used by this cross-reference.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">bool</span> contains(<span class="keyword">const</span> TYPE&amp; value) <span class="keyword">const</span>;
          <span class="comment">// Return true if the specified &#39;value&#39; is found in the table and</span>
          <span class="comment">// false otherwise.</span>
  };
</pre></div><br/>
<br/>
 Then, we will create an array of user supplied nicknames that would create collisions in some other hashing algorithm. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">const</span> <span class="keywordtype">char</span> names[6][11] = { <span class="stringliteral">&quot;COLLISION!&quot;</span>,
                                  <span class="stringliteral">&quot;COLLISION@&quot;</span>,
                                  <span class="stringliteral">&quot;COLLISION#&quot;</span>,
                                  <span class="stringliteral">&quot;COLLISION$&quot;</span>,
                                  <span class="stringliteral">&quot;COLLISION%&quot;</span>,
                                  <span class="stringliteral">&quot;COLLISION^&quot;</span>};

      <span class="keyword">enum</span> { NUM_NAMES = <span class="keyword">sizeof</span> names / <span class="keyword">sizeof</span> *names };
</pre></div><br/>
<br/>
 Next, we create a seed generator, with a cryptographically secure random number generator, that can be used to generate seeds for our secure hashing algorithm. We then pass that seed generator into <code><a class="el" href="structbslh_1_1SeededHash.html">bslh::SeededHash</a></code>. We use the <code><a class="el" href="classbslh_1_1SipHashAlgorithm.html">bslh::SipHashAlgorithm</a></code> as our secure hashing algorithm. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">typedef</span> SeedGenerator&lt;CryptographicallySecureRNG&gt; SecureSeedGenerator;
      <span class="keyword">typedef</span> SeededHash&lt;SecureSeedGenerator, SipHashAlgorithm&gt; SecureHash;

      SecureSeedGenerator secureSeedGenerator;
      SecureHash          secureHash(secureSeedGenerator);
</pre></div><br/>
<br/>
 Then, we create our hash table <code>hashTable</code>. We pass it the <code>secureHash</code> hashing functor we created. Passing it in through the functor, rather than just having it default constructed from the template parameter, allows us to pass in an algorithm with a pre-configured state if we so desire. <br/>
<br/>
<div class="fragment"><pre class="fragment">      HashTable&lt;const char [11], SecureHash&gt; hashTable(names,
                                                       NUM_NAMES,
                                                       secureHash);

 Now, we verify that each element in our array registers with count:
      <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; NUM_NAMES; ++i) {
          ASSERT(hashTable.contains(names[i]));
      }

 Finally, we verify that futures not in our original array are correctly
 identified as not being in the <span class="keyword">set</span>:

      ASSERT(!hashTable.contains(<span class="stringliteral">&quot;asdfasdfas&quot;</span>));
      ASSERT(!hashTable.contains(<span class="stringliteral">&quot;asdfqwerqw&quot;</span>));
      ASSERT(!hashTable.contains(<span class="stringliteral">&quot;asdfqwerzx&quot;</span>));
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:20 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
