<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslalg_hashtablebucket.h                                           -*-C++-*-
#ifndef INCLUDED_BSLALG_HASHTABLEBUCKET
#define INCLUDED_BSLALG_HASHTABLEBUCKET

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a bucket representation for hash table data structures.
//
//@CLASSES:
//   bslalg::HashTableBucket : hash-table, manages externally allocated nodes
//
//@SEE_ALSO: bslalg_hashtableimputil, bslalg_bidirectionallink,
//           bslalg_bidirectionalnode
//
//@DESCRIPTION: This component provides an ability to keep track of a segment
// of a linked list of &#39;bslalg::BidirectionalLink&#39; objects.  It contains
// pointers to the first and last elements of the list segment in question, or
// two null pointers for an empty list.
//
///Usage
///-----
// This section illustrates intended usage of this component.
//
///Example 1: Creating and Using a List Template Class
///- - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we want to create a linked list template class, it will be called
// &#39;MyList&#39;.
//
// First, we create the iterator helper class, which will eventually be
// defined as a nested type within the &#39;MyList&#39; class.
//..
//                              // ===============
//                              // MyList_Iterator
//                              // ===============
//
//  template &lt;class PAYLOAD&gt;
//  class MyList_Iterator {
//      // &#39;Iterator&#39; type for class &#39;MyList&#39;.  This class will be typedef&#39;ed
//      // to be a nested class within &#39;MyList&#39;.
//
//      // PRIVATE TYPES
//      typedef bslalg::BidirectionalNode&lt;PAYLOAD&gt; Node;
//
//      // DATA
//      Node *d_node;
//
//      // FRIENDS
//      template &lt;class PL&gt;
//      friend bool operator==(MyList_Iterator&lt;PL&gt;,
//                             MyList_Iterator&lt;PL&gt;);
//
//    public:
//      // CREATORS
//      MyList_Iterator() : d_node(0) {}
//      explicit
//      MyList_Iterator(Node *node) : d_node(node) {}
//      //! MyList_Iterator(const MyList_Iterator&amp; original) = default;
//      //! ~MyList_Iterator() = default;
//
//      // MANIPULATORS
//      //! MyList_Iterator&amp; operator=(const MyList_Iterator&amp; other) = default;
//
//      MyList_Iterator operator++();
//
//      // ACCESSORS
//      PAYLOAD&amp; operator*() const { return d_node-&gt;value(); }
//  };
//..
// Then, we define our &#39;MyList&#39; class, which will inherit from
// &#39;bslalg::HashTableBucket&#39;.  &#39;MyList::Iterator&#39; will be a public typedef of
// &#39;MyList_Iterator&#39;.  For brevity, we will omit a lot of functionality that a
// full, general-purpose list class would have, implementing only what we will
// need for this example.
//..
//                                  // ======
//                                  // MyList
//                                  // ======
//
//  template &lt;class PAYLOAD&gt;
//  class MyList : public bslalg::HashTableBucket {
//      // This class stores a doubly-linked list containing objects of type
//      // &#39;PAYLOAD&#39;.
//
//      // PRIVATE TYPES
//      typedef bslalg::BidirectionalNode&lt;PAYLOAD&gt; Node;
//
//    public:
//      // PUBLIC TYPES
//      typedef PAYLOAD                            ValueType;
//      typedef MyList_Iterator&lt;ValueType&gt;         Iterator;
//
//      // DATA
//      bslma::Allocator *d_allocator_p;
//
//    public:
//      // CREATORS
//      explicit
//      MyList(bslma::Allocator *basicAllocator = 0)
//      : d_allocator_p(bslma::Default::allocator(basicAllocator))
//      {
//          reset();
//      }
//      ~MyList();
//
//      // MANIPULATORS
//      Iterator begin() { return Iterator((Node *) first()); }
//      Iterator end()   { return Iterator(0); }
//      void pushBack(const ValueType&amp; value);
//      void popBack();
//  };
//..
// Next, we implement the functions for the iterator type.
//..
//                              // ---------------
//                              // MyList_Iterator
//                              // ---------------
//
//  // MANIPULATORS
//  template &lt;class PAYLOAD&gt;
//  MyList_Iterator&lt;PAYLOAD&gt; MyList_Iterator&lt;PAYLOAD&gt;::operator++()
//  {
//      d_node = (Node *) d_node-&gt;nextLink();
//      return *this;
//  }
//
//  template &lt;class PAYLOAD&gt;
//  inline
//  bool operator==(MyList_Iterator&lt;PAYLOAD&gt; lhs,
//                  MyList_Iterator&lt;PAYLOAD&gt; rhs)
//  {
//      return lhs.d_node == rhs.d_node;
//  }
//
//  template &lt;class PAYLOAD&gt;
//  inline
//  bool operator!=(MyList_Iterator&lt;PAYLOAD&gt; lhs,
//                  MyList_Iterator&lt;PAYLOAD&gt; rhs)
//  {
//      return !(lhs == rhs);
//  }
//..
// Then, we implement the functions for the &#39;MyList&#39; class:
//..
//                                  // ------
//                                  // MyList
//                                  // ------
//
//  // CREATORS
//  template &lt;class PAYLOAD&gt;
//  MyList&lt;PAYLOAD&gt;::~MyList()
//  {
//      typedef bslalg::BidirectionalLink BDL;
//
//      for (Node *p = (Node *) first(); p; ) {
//          Node *toDelete = p;
//          p = (Node *) p-&gt;nextLink();
//
//          toDelete-&gt;value().~ValueType();
//          d_allocator_p-&gt;deleteObjectRaw(static_cast&lt;BDL *&gt;(toDelete));
//      }
//
//      reset();
//  }
//
//  // MANIPULATORS
//  template &lt;class PAYLOAD&gt;
//  void MyList&lt;PAYLOAD&gt;::pushBack(const PAYLOAD&amp; value)
//  {
//      Node *node = (Node *) d_allocator_p-&gt;allocate(sizeof(Node));
//      node-&gt;setNextLink(0);
//      node-&gt;setPreviousLink(last());
//      bslalg::ScalarPrimitives::copyConstruct(&amp;node-&gt;value(),
//                                              value,
//                                              d_allocator_p);
//
//      if (0 == last()) {
//          BSLS_ASSERT_SAFE(0 == first());
//
//          setFirstAndLast(node, node);
//      }
//      else {
//          last()-&gt;setNextLink(node);
//          setLast(node);
//      }
//  }
//
//  template &lt;class PAYLOAD&gt;
//  void MyList&lt;PAYLOAD&gt;::popBack()
//  {
//      BSLS_ASSERT_SAFE(first() &amp;&amp; last());
//
//      Node *toDelete = (Node *) last();
//
//      if (first() != toDelete) {
//          BSLS_ASSERT_SAFE(0 != last());
//          setLast(last()-&gt;previousLink());
//          last()-&gt;setNextLink(0);
//      }
//      else {
//          reset();
//      }
//
//      d_allocator_p-&gt;deleteObject(toDelete);
//  }
//..
// Next, in &#39;main&#39;, we use our &#39;MyList&#39; class to store a list of ints:
//..
//  MyList&lt;int&gt; intList;
//..
// Then, we declare an array of ints to populate it with:
//..
//  int intArray[] = { 8, 2, 3, 5, 7, 2 };
//  enum { NUM_INTS = sizeof intArray / sizeof *intArray };
//..
// Now, we iterate, pushing ints to the list:
//..
//  for (const int *pInt = intArray; pInt &lt; intArray + NUM_INTS; ++pInt) {
//      intList.pushBack(*pInt);
//  }
//..
// Finally, we use our &#39;Iterator&#39; type to traverse the list and observe its
// values:
//..
//  MyList&lt;int&gt;::Iterator it = intList.begin();
//  assert(8 == *it);
//  assert(2 == *++it);
//  assert(3 == *++it);
//  assert(5 == *++it);
//  assert(7 == *++it);
//  assert(2 == *++it);
//  assert(intList.end() == ++it);
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLALG_BIDIRECTIONALLINK
#include &lt;bslalg_bidirectionallink.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYCOPYABLE
#include &lt;bslmf_istriviallycopyable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLS_NATIVESTD
#include &lt;bsls_nativestd.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;
#define INCLUDED_CSTDDEF
#endif

namespace BloombergLP {
namespace bslalg {

                          // =====================
                          // class HashTableBucket
                          // =====================

struct HashTableBucket {
  public:
    // DATA
    BidirectionalLink *d_first_p;
    BidirectionalLink *d_last_p;

    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(HashTableBucket,
                                   bsl::is_trivially_copyable);

  public:
    // No creators -- must be a POD so that aggregate initialization can be
    // done.

    // MANIPULATORS
    void setFirst(BidirectionalLink *node);
        // Set the &#39;first&#39; element of this bucket to the specified &#39;node&#39;.  The
        // behavior is undefined unless &#39;node&#39; is an element from the same
        // bidirectional list as the &#39;last&#39; element in this bucket, and &#39;node&#39;
        // either precedes &#39;last&#39; in that list, or is the same node, or this
        // bucket is empty and &#39;node&#39; has a null pointer value.

    void setLast(BidirectionalLink *node);
        // Set the &#39;last&#39; element of this bucket to the specified &#39;node&#39;.  The
        // behavior is undefined unless &#39;node&#39; is an element from the same
        // bidirectional list as the &#39;first&#39; element in this bucket, and &#39;node&#39;
        // either follows &#39;first&#39; in that list, or is the same node, or this
        // bucket is empty and &#39;node&#39; has a null pointer value.

    void setFirstAndLast(BidirectionalLink *first, BidirectionalLink *last);
        // Set &#39;first&#39; and &#39;last&#39; to the specified values.  Behavior is
        // undefined unless unless &#39;first == last&#39;, or unless &#39;first&#39; and
        // &#39;last&#39; are links from the same list, where &#39;first&#39; precedes &#39;last&#39;
        // in the list.  Note that &#39;first&#39; and &#39;last&#39; may both have a null
        // pointer value, indicating an empty bucket.

    void reset();
        // Set &#39;first&#39; and &#39;last&#39; to a null pointer value.

    // ACCESSORS
    BidirectionalLink *end() const;
        // Return the next node after the end of this bucket, or 0 if
        // &#39;0 == last()&#39;, so the range to traverse to traverse all nodes in the
        // bucket is always &#39;[ first(), end() )&#39; regardless of whether the
        // bucket is empty.

    BidirectionalLink *first() const;
        // Return the address of the first element in this hash bucket, or a
        // null pointer value if the bucket is empty.

    BidirectionalLink *last() const;
        // Return the address of the last element in this hash bucket, or a
        // null pointer value if the bucket is empty.

    native_std::size_t countElements() const;
        // Return the number of nodes in this hash bucket.
};

// ============================================================================
//                               FREE OPERATORS
// ============================================================================

bool operator==(const HashTableBucket&amp; lhs, const HashTableBucket&amp; rhs);
    // Return &#39;true&#39; if the specified hash table buckets &#39;lhs&#39; and &#39;rhs&#39; are
    // equivalent and &#39;false&#39; otherwise.

bool operator!=(const HashTableBucket&amp; lhs, const HashTableBucket&amp; rhs);
    // Return &#39;true&#39; if the specified hash table buckets &#39;lhs&#39; and &#39;rhs&#39; are
    // not equivalent and &#39;false&#39; otherwise.

// ============================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ============================================================================

                        //----------------------
                        // class HashTableBucket
                        //----------------------

// MANIPULATORS
inline
void HashTableBucket::setFirst(BidirectionalLink *node)
{
    BSLS_ASSERT_SAFE(!d_first_p == !node);

    d_first_p = node;
}

inline
void HashTableBucket::setLast(BidirectionalLink *node)
{
    BSLS_ASSERT_SAFE(!d_last_p == !node);

    d_last_p = node;
}

inline
void HashTableBucket::setFirstAndLast(BidirectionalLink *first,
                                      BidirectionalLink *last)
{
    BSLS_ASSERT_SAFE(!first == !last);

    d_first_p = first;
    d_last_p  = last;
}

inline
void HashTableBucket::reset()
{
    d_first_p = d_last_p = 0;
}

// ACCESSORS
inline
BidirectionalLink *HashTableBucket::end() const
{
    return d_last_p ? d_last_p-&gt;nextLink() : 0;
}

inline
BidirectionalLink *HashTableBucket::first() const
{
    return d_first_p;
}

inline
BidirectionalLink *HashTableBucket::last() const
{
    return d_last_p;
}

}  // close package namespace

// FREE OPERATORS
inline
bool bslalg::operator==(const bslalg::HashTableBucket&amp; lhs,
                        const bslalg::HashTableBucket&amp; rhs)
{
    return lhs.first() == rhs.first() &amp;&amp; lhs.last() == rhs.last();
}

inline
bool bslalg::operator!=(const bslalg::HashTableBucket&amp; lhs,
                        const bslalg::HashTableBucket&amp; rhs)
{
    return lhs.first() != rhs.first() || lhs.last() != rhs.last();
}


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
