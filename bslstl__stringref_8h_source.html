<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslstl_stringref.h                                                 -*-C++-*-
#ifndef INCLUDED_BSLSTL_STRINGREF
#define INCLUDED_BSLSTL_STRINGREF

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a reference to a &#39;const&#39; string.
//
//@CLASSES:
//   bslstl::StringRefImp: reference wrapper for a generic string
//      bslstl::StringRef: reference wrapper for a &#39;char&#39; string
//  bslstl::StringRefWide: reference wrapper for a &#39;wchar_t&#39; string
//
//@DESCRIPTION: This component defines two classes, &#39;bsls::StringRef&#39; and
// &#39;bsls::StringRefWide&#39;, each providing a reference to a non-modifiable string
// value having an external representation.  The type of characters in the
// string value can be either &#39;char&#39; (for &#39;bslstl::StringRef&#39;) or &#39;wchar_t&#39;
// (for &#39;bslstl::StringRefWide&#39;).
//
// The invariant of &#39;bslstl::StringRef&#39; is that it always has a valid
// non-modifiable &#39;std::string&#39; value, where non-empty string values have an
// external representation.  Empty string values do not need to have an
// external representation.  Most operations on &#39;bslstl::StringRef&#39; objects
// have reference semantics and apply to the string value: e.g., &#39;operator==&#39;
// compares string values, not whether &#39;bslstl::StringRef&#39; objects reference
// the same string object.
//
// The only operations that do not apply to the string value (i.e., that have
// pointer semantics) are copy construction and assignment.  These operations
// produce a &#39;bslstl::StringRef&#39; object with the same external representation
// as the original &#39;bslstl::StringRef&#39; object, which is a stronger
// post-condition than having &#39;operator==&#39; return &#39;true&#39; for two
// &#39;bslstl::StringRef&#39; objects that have the same value.
//
// The standard notion of substitutability defined by the &#39;operator==&#39; does not
// necessarily apply to &#39;bslstl::StringRef&#39; since &#39;bslstl::StringRef&#39; is not a
// value-semantic type (because of the external representation).  Therefore
// there can be a plausible sequence of operations applied to two &quot;equal&quot;
// &#39;bslstl::StringRef&#39; objects that result in objects that don&#39;t compare equal.
//
// The string value that is represented by a &#39;bslstl::StringRef&#39; object need
// not be null-terminated.  Moreover, the string may contain embedded null
// characters.  As such, the string referenced by &#39;bslstl::StringRef&#39;, in
// general, is not a C-style string.  Moreover, the notion of a null-string
// value is not supported.
//
// The address and extent of the string referenced by &#39;bslstl::StringRef&#39; are
// indicated by the &#39;data&#39; and &#39;length&#39; accessors, respectively.  The
// referenced string is also indicated by the &#39;begin&#39; and &#39;end&#39; accessors that
// return STL-compatible iterators to the beginning of the string and one
// character past the end of the string, respectively.  An overloaded
// &#39;operator[]&#39; is also provided for direct by-index access to individual
// characters in the string.
//
// Several overloaded free operators are provided for &#39;bslstl::StringRef&#39;
// objects (as well as variants for all combinations involving
// &#39;bslstl::StringRef&#39; and &#39;std::string&#39;, and &#39;bslstl::StringRef&#39; and &#39;char *&#39;)
// for (1) lexicographic comparison of values, and (2) concatenation of values
// (producing an &#39;std::string&#39;); also provided is an overloaded free
// &#39;operator&lt;&lt;&#39; for writing the value of a &#39;bslstl::StringRef&#39; object to a
// specified output stream.
//
// The &#39;bsl::hash&#39; template class is specialized for &#39;bslstl::StringRef&#39; to
// enable the use of &#39;bslstl::StringRef&#39; with STL hash containers (e.g.,
// &#39;bsl::hash_set&#39; and &#39;bsl::hash_map&#39;).
//
///Efficiency and Usage Considerations
///-----------------------------------
// Using &#39;bslstl::StringRef&#39; to pass strings as function arguments can be
// considerably more efficient than passing &#39;bsl::string&#39; objects by &#39;const&#39;
// reference.  First, consider a hypothetical class method in which the
// parameter is a reference to a non-modifiable &#39;bsl::string&#39;:
//..
//  void MyClass::setLabel(const bsl::string&amp; label)
//  {
//      d_label = label;  // &#39;MyClass::d_label&#39; is of type &#39;bsl::string&#39;
//  }
//..
// Then, consider a typical call to this method:
//..
//  MyClass myClassObj;
//  myClassObj.setLabel(&quot;hello&quot;);
//..
// As a side-effect of this call, a temporary &#39;bsl::string&#39; containing a *copy*
// of &quot;hello&quot; is created (using the default allocator), that value is copied to
// &#39;d_label&#39;, and the temporary is eventually destroyed.  The call thus
// requires the string data to be copied twice (as well as a possible
// allocation and deallocation).
//
// Next, consider the same method taking a reference to a non-modifiable
// &#39;bslstl::StringRef&#39;:
//..
//  void MyClass::setLabel(const bslstl::StringRef&amp; label)
//  {
//      d_label.assign(label.begin(), label.end());
//  }
//..
// Now:
//..
//  myClassObj.setLabel(&quot;hello&quot;);
//..
// This call has the side-effect of creating a temporary &#39;bslstl::StringRef&#39;
// object, which is likely to be more efficient than creating a temporary
// &#39;bsl::string&#39; (even which is implemented using the short-string
// optimization).  In this case, instead of copying the *contents* of &quot;hello&quot;,
// the *address* of the literal string is copied.  In addition, &#39;bsl::strlen&#39;
// is applied to the string in order to locate its end.  There are *no*
// allocations done on behalf of the temporary object.
//
///Caveats
///-------
// 1) The string referenced by &#39;bslstl::StringRef&#39; need not be null-terminated,
// and, in fact, may *contain* embedded null characters.  Thus, it is generally
// not valid to pass the address returned by the &#39;data&#39; accessor to Standard C
// functions that expect a null-terminated string (e.g., &#39;std::strlen&#39;,
// &#39;std::strcmp&#39;, etc.).
//
// 2) The string referenced by &#39;bslstl::StringRef&#39; must remain valid as long as
// the &#39;bslstl::StringRef&#39; references that string.  Lifetime issues should be
// carefully considered when, for example, returning a &#39;bslstl::StringRef&#39;
// object from a function or storing a &#39;bslstl::StringRef&#39; object in a
// container.
//
// 3) Passing a null string to any function (e.g., &#39;operator==&#39;) without also
// passing a 0 length results in undefined behavior.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Basic Operations
///- - - - - - - - - - - - - -
// The following snippets of code illustrate basic and varied use of the
// &#39;bslstl::StringRef&#39; class.
//
// First, we define a function, &#39;getNumBlanks&#39;, that returns the number of
// blank (&#39; &#39;) characters contained in the string referenced by a specified
// &#39;bslstl::StringRef&#39;:
//..
//  #include &lt;algorithm&gt;
//
//  int getNumBlanks(const bslstl::StringRef&amp; stringRef)
//      // Return the number of blank (&#39; &#39;) characters in the string referenced
//      // by the specified &#39;stringRef&#39;.
//  {
//      return std::count(stringRef.begin(), stringRef.end(), &#39; &#39;);
//  }
//..
// Notice that the function delegates the work to the &#39;std::count&#39; STL
// algorithm.  This delegation is made possible by the STL-compatible iterators
// provided by the &#39;begin&#39; and &#39;end&#39; accessors.
//
// Then, call &#39;getNumBlanks&#39; on a default constructed &#39;bslstl::StringRef&#39;:
//..
//  bslstl::StringRef emptyRef;
//  int numBlanks = getNumBlanks(emptyRef);
//  assert(0 == numBlanks);
//
//  assert(&quot;&quot;         == emptyRef);
//  assert(&quot;anything&quot; &gt;= emptyRef);
//..
// Notice that the behavior a default constructed &#39;bslstl::StringRef&#39; object
// behaves the same as if it referenced an empty string.
//
// Next, we (implicitly) construct a &#39;bsl::string&#39; object from
// &#39;bslstl::StringRef&#39;:
//..
//  bsl::string empty(emptyRef);
//  assert(0 == empty.size());
//..
// Then, we call &#39;getNumBlanks&#39; on a string literal and assert that the number
// of blanks returned is as expected:
//..
//  numBlanks = getNumBlanks(&quot;Good things come to those who wait.&quot;);
//  assert(6 == numBlanks);
//..
// Next, we define a longer string literal, &#39;poem&#39;, that we will use in the
// rest of this usage example:
//..
//  const char poem[] =                  // by William Butler Yeats (1865-1939)
//      |....5....|....5....|....5....|....5....|   //  length  blanks
//                                                  //
//      &quot;O love is the crooked thing,\n&quot;            //    29      5
//      &quot;There is nobody wise enough\n&quot;             //    28      4
//      &quot;To find out all that is in it,\n&quot;          //    31      7
//      &quot;For he would be thinking of love\n&quot;        //    33      6
//      &quot;Till the stars had run away\n&quot;             //    28      5
//      &quot;And the shadows eaten the moon.\n&quot;         //    32      5
//      &quot;Ah, penny, brown penny, brown penny,\n&quot;    //    37      5
//      &quot;One cannot begin it too soon.&quot;;            //    29      5
//                                                  //          ----
//                                                  //    total: 42
//
//  numBlanks = getNumBlanks(poem);
//  assert(42 == numBlanks);
//..
// Then, we construct a &#39;bslstl::StringRef&#39; object, &#39;line&#39;, that refers to only
// the first line of the &#39;poem&#39;:
//..
//  bslstl::StringRef line(poem, 29);
//  numBlanks = getNumBlanks(line);
//
//  assert( 5 == numBlanks);
//  assert(29 == line.length());
//  assert( 0 == std::strncmp(poem, line.data(), line.length()));
//..
// Next, we use the &#39;assign&#39; method to make &#39;line&#39; refer to the second line of
// the &#39;poem&#39;:
//..
//  line.assign(poem + 29, poem + 57);
//  numBlanks = getNumBlanks(line);
//  assert(4 == numBlanks);
//  assert((57 - 29) == line.length());
//  assert(&quot;There is nobody wise enough\n&quot; == line);
//..
// Then, we call &#39;getNumBlanks&#39; with a &#39;bsl::string&#39; initialized to the
// contents of the &#39;poem&#39;:
//..
//  const bsl::string poemString(poem);
//  numBlanks = getNumBlanks(poemString);
//  assert(42 == numBlanks);
//  assert(bslstl::StringRef(poemString) == poemString);
//  assert(bslstl::StringRef(poemString) == poemString.c_str());
//..
// Next, we make a &#39;bslstl::StringRef&#39; object that refers to a string that will
// be able to hold embedded null characters:
//..
//  char poemWithNulls[512];
//  const int poemLength = std::strlen(poem);
//  assert(poemLength &lt; 512);
//
//  std::memcpy(poemWithNulls, poem, poemLength + 1);
//  assert(0 == std::strcmp(poem, poemWithNulls));
//..
// Now, we replace each occurrence of a &#39;\n&#39; in &#39;poemWithNulls&#39; with a yielding
// &#39;\0&#39;:
//..
//  std::replace(poemWithNulls, poemWithNulls + poemLength, &#39;\n&#39;, &#39;\0&#39;);
//  assert(0 != std::strcmp(poem, poemWithNulls));
//..
// Finally, we observe that &#39;poemWithNulls&#39; has the same number of blank
// characters as the original &#39;poem&#39;:
//..
//  numBlanks = getNumBlanks(bslstl::StringRef(poemWithNulls, poemLength));
//  assert(42 == numBlanks);
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_STRING
#include &lt;bslstl_string.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_STRINGREFDATA
#include &lt;bslstl_stringrefdata.h&gt;
#endif

#ifndef INCLUDED_IOSFWD
#include &lt;iosfwd&gt;
#define INCLUDED_IOSFWD
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;              // for &#39;std::size_t&#39;
#define INCLUDED_CSTDDEF
#endif

#ifndef INCLUDED_CSTRING
#include &lt;cstring&gt;              // for &#39;std::strlen&#39;, &#39;std::memcmp&#39;
#define INCLUDED_CSTRING
#endif

namespace BloombergLP {

namespace bslstl {

                    // =============================
                    // class StringRefImp&lt;CHAR_TYPE&gt;
                    // =============================

template &lt;typename CHAR_TYPE&gt;
class StringRefImp : public StringRefData&lt;CHAR_TYPE&gt; {
    // This class provides a reference-semantic-like (see below) mechanism that
    // allows &#39;const&#39; &#39;std::string&#39; values, which are represented externally as
    // either an &#39;std::string&#39; or null-terminated c-style string (or parts
    // thereof), to be treated both uniformly and efficiently when passed as an
    // argument to a function in which the string&#39;s length will be needed.  The
    // interface of this class provides a subset of accessor methods found on
    // &#39;std::string&#39; (but none of the manipulators) -- all of which apply to
    // the referenced string.  But, because only non-modifiable access is
    // afforded to the referenced string value, each of the manipulators on
    // this type -- assignment in particular -- apply to this string-reference
    // object itself (as if it had pointer semantics).  Hence, this class has a
    // hybrid of reference- and pointer-semantics.
    //
    // This class:
    //: o supports a complete set of *value-semantic* operations
    //:   o except for &#39;bdex&#39; serialization
    //: o is *exception-neutral* (agnostic)
    //: o is *alias-safe*
    //: o is &#39;const&#39; *thread-safe*
    // For terminology see &#39;bsldoc_glossary&#39;.

  private:
    typedef StringRefData&lt;CHAR_TYPE&gt; Base;

    // PRIVATE ACCESSORS
    void write(std::basic_ostream&lt;CHAR_TYPE&gt;&amp; stream) const;
        // Write the value of this string reference to the specified output
        // &#39;stream&#39; in the unformatted way.

    template &lt;typename OTHER_CHAR_TYPE&gt;
    friend
    std::basic_ostream&lt;OTHER_CHAR_TYPE&gt;&amp; operator&lt;&lt;(
                       std::basic_ostream&lt;OTHER_CHAR_TYPE&gt;&amp;         stream,
                       const bslstl::StringRefImp&lt;OTHER_CHAR_TYPE&gt;&amp; stringRef);

  public:
    // PUBLIC TYPES
    typedef const CHAR_TYPE     value_type;
    typedef const CHAR_TYPE&amp;    reference;
    typedef const CHAR_TYPE&amp;    const_reference;
    typedef const CHAR_TYPE    *iterator;
    typedef const CHAR_TYPE    *const_iterator;
    typedef std::ptrdiff_t      difference_type;
    typedef std::size_t         size_type;
        // Standard Library general container requirements.

  public:
    // CREATORS
    StringRefImp();
        // Create an object representing an empty &#39;std::string&#39; value that is
        // independent of any external representation and with the following
        // attribute values:
        //..
        //  begin() == end()
        //  isEmpty() == true
        //..

    StringRefImp(const CHAR_TYPE *data, int length);
        // Create a string-reference object having a valid &#39;std::string&#39; value,
        // whose external representation begins at the specified &#39;data&#39; address
        // and extends for the specified &#39;numCharacters.  The external
        // representation must remain valid as long as it is bound to this
        // string reference.  Passing 0 has the same effect as default
        // construction.  The behavior is undefined unless &#39;0 &lt;= length&#39; and,
        // if &#39;0 == data&#39;, then &#39;0 == length&#39;.  Note that, like an
        // &#39;std::string&#39;, the &#39;data&#39; need not be null-terminated and may
        // contain embedded null characters.

    StringRefImp(const_iterator begin, const_iterator end);
        // Create a string-reference object having a valid &#39;std::string&#39; value,
        // whose external representation begins at the specified &#39;begin&#39;
        // iterator and extends up to, but not including, the specified &#39;end&#39;
        // iterator.  The external representation must remain valid as long as
        // it is bound to this string reference.  The behavior is undefined
        // unless &#39;begin &lt;= end&#39;.  Note that, like an &#39;std::string&#39;, the string
        // need not be null-terminated and may contain embedded null
        // characters.

    StringRefImp(const CHAR_TYPE *data);
        // Create a string-reference object having a valid &#39;std::string&#39; value,
        // whose external representation begins at the specified &#39;data&#39; address
        // and extends for &#39;std::strlen(data)&#39; characters.  The external
        // representation must remain valid as long as it is bound to this
        // string reference.  The behavior is undefined unless &#39;data&#39; is
        // null-terminated.

    StringRefImp(const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; str);
    StringRefImp(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; str);
        // Create a string-reference object having a valid &#39;std::string&#39; value,
        // whose external representation is defined by the specified &#39;str&#39;
        // object.  The external representation must remain valid as long as it
        // is bound to this string reference.

    StringRefImp(const StringRefImp&amp; original);
        // Create a string-reference object having a valid &#39;std::string&#39; value,
        // whose external representation is defined by the specified &#39;original&#39;
        // object.  The external representation must remain valid as long as it
        // is bound to this string reference.

    // ~StringRefImp() = default;
        // Destroy this object.

    // MANIPULATORS
    StringRefImp&amp; operator=(const StringRefImp&amp; rhs);
        // Modify this string reference to refer to the same string as the
        // specified &#39;rhs&#39; string reference and return a reference providing
        // modifiable access to this object.  The assigned object is guaranteed
        // to have values of attributes &#39;begin&#39; and &#39;end&#39; equal to the &#39;rhs&#39;
        // object&#39;s attributes.

    void assign(const CHAR_TYPE *data, int length);
        // Bind this string reference to the string at the specified &#39;data&#39;
        // address and extending for the specified &#39;length&#39; characters.  The
        // string indicated by &#39;data&#39; and &#39;length&#39; must remain valid as long as
        // it is bound to this object.  The behavior is undefined unless
        // &#39;0 &lt;= length&#39; or &#39;0 == data &amp;&amp; 0 == length&#39;.  Note that the string
        // need not be null-terminated and may contain embedded null
        // characters.

    void assign(const_iterator begin, const_iterator end);
        // Bind this string reference to the string at the specified &#39;begin&#39;
        // iterator, extending up to, but not including, the character at the
        // specified &#39;end&#39; iterator.  The string indicated by &#39;begin&#39; and &#39;end&#39;
        // must remain valid as long as it is bound to this object.  The
        // behavior is undefined unless &#39;begin &lt;= end&#39;.  Note that the string
        // need not be null-terminated and may contain embedded null
        // characters.

    void assign(const CHAR_TYPE *data);
        // Bind this string reference to the string at the specified &#39;data&#39;
        // address and extending for &#39;std::strlen(data)&#39; characters.  The
        // string at the &#39;data&#39; address must remain valid as long as it is
        // bound to this string reference.  The behavior is undefined unless
        // &#39;data&#39; is null-terminated.

    void assign(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; str);
        // Bind this string reference to the specified &#39;str&#39; string.  The
        // string indicated by &#39;str&#39; must remain valid as long as it is bound
        // to this object.

    void assign(const StringRefImp&lt;CHAR_TYPE&gt;&amp; stringRef);
        // Modify this string reference to refer to the same string as the
        // specified &#39;stringRef&#39;.  Note, that the string bound to &#39;stringRef&#39;
        // must remain valid as long as it is bound to this object.

    void reset();
        // Reset this string reference to the default-constructed state having
        // an empty &#39;std::string&#39; value and the following attribute values:
        //..
        //  begin() == end()
        //  isEmpty() == true
        //..

    // ACCESSORS
    const_reference operator[](int index) const;
        // Return a reference providing a non-modifiable access to the
        // character at the specified &#39;index&#39; in the string bound to this
        // reference.  This reference remains valid as long as the string
        // currently bound to this object remains valid.  The behavior is
        // undefined unless &#39;0 &lt;= index &lt; length()&#39;.

    operator native_std::basic_string&lt;CHAR_TYPE&gt;() const;
        // Return an &#39;std::basic_string&#39; (synonymous with
        // &#39;native_std::basic_string&#39;) having the value of the string bound to
        // this string reference.

    const_iterator begin() const;
        // Return an STL-compatible iterator to the first character of the
        // string bound to this string reference or &#39;end()&#39; if the string
        // reference is empty.  The iterator remains valid as long as this
        // object is valid and is bound to the same string.

    const_iterator end() const;
        // Return an STL-compatible iterator one past the last character of the
        // string bound to this string reference or &#39;begin()&#39; if the string
        // reference is empty.  The iterator remains valid as long as this
        // object is valid and is bound to the same string.

    const CHAR_TYPE *data() const;
        // Return the address of the first character of the string bound to
        // this string reference such that &#39;[data(), data()+length())&#39; is a
        // valid half-open range of characters.  Return 0 for an empty string
        // reference object.  Note that the range of characters may not be
        // null-terminated and may contain embedded null characters.

    bool isEmpty() const;
        // Return &#39;true&#39; if this object represents an empty string value, and
        // &#39;false&#39; otherwise.  This object represents an empty string value if
        // &#39;begin() == end()&#39;.

    size_type length() const;
        // Return the length of the string referred to by this object.  Note
        // that this call is equivalent to &#39;end() - begin()&#39;.
};

// FREE OPERATORS
template &lt;typename CHAR_TYPE&gt;
bool operator==(const StringRefImp&lt;CHAR_TYPE&gt;&amp; lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator==(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp;      rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator==(const StringRefImp&lt;CHAR_TYPE&gt;&amp;             lhs,
                const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator==(const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp;             rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator==(const StringRefImp&lt;CHAR_TYPE&gt;&amp;      lhs,
                const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator==(const CHAR_TYPE                *lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp;  rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator==(const StringRefImp&lt;CHAR_TYPE&gt;&amp;  lhs,
                const CHAR_TYPE                *rhs);
    // Return &#39;true&#39; if the strings referred to by the specified &#39;lhs&#39; and
    // &#39;rhs&#39; have the same lexicographic value, and &#39;false&#39; otherwise.  Two
    // strings have the same lexicographic value if they have the same length,
    // and the respective values at each character position are the same.

template &lt;typename CHAR_TYPE&gt;
bool operator!=(const StringRefImp&lt;CHAR_TYPE&gt;&amp; lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator!=(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp;      rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator!=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;      lhs,
                const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator!=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;             lhs,
                const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator!=(const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp;             rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator!=(const CHAR_TYPE                *lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp;  rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator!=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;  lhs,
                const CHAR_TYPE                *rhs);
    // Return &#39;true&#39; if the strings referred to by the specified &#39;lhs&#39; and
    // &#39;rhs&#39; do not have the same lexicographic value, and &#39;false&#39; otherwise.
    // Two strings do not have the same lexicographic value if they do not have
    // the same length, or respective values at any character position are not
    // the same.

template &lt;typename CHAR_TYPE&gt;
bool operator&lt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp; lhs,
               const StringRefImp&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&lt;(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
               const StringRefImp&lt;CHAR_TYPE&gt;&amp;      rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&lt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp;      lhs,
               const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&lt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp;             lhs,
               const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&lt;(const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
               const StringRefImp&lt;CHAR_TYPE&gt;&amp;             rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&lt;(const CHAR_TYPE                *lhs,
               const StringRefImp&lt;CHAR_TYPE&gt;&amp;  rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&lt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp;  lhs,
               const CHAR_TYPE                *rhs);
    // Return &#39;true&#39; if the string referred to by the specified &#39;lhs&#39; is
    // lexicographically less than the string referred to by the specified
    // &#39;rhs&#39;, and &#39;false&#39; otherwise.

template &lt;typename CHAR_TYPE&gt;
bool operator&gt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp; lhs,
               const StringRefImp&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&gt;(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
               const StringRefImp&lt;CHAR_TYPE&gt;&amp;      rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&gt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp;      lhs,
               const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&gt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp;             lhs,
               const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&gt;(const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
               const StringRefImp&lt;CHAR_TYPE&gt;&amp;             rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&gt;(const CHAR_TYPE                *lhs,
               const StringRefImp&lt;CHAR_TYPE&gt;&amp;  rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&gt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp;  lhs,
               const CHAR_TYPE                *rhs);
    // Return &#39;true&#39; if the string referred to by the specified &#39;lhs&#39; is
    // lexicographically greater than the string referred to by the specified
    // &#39;rhs&#39;, and &#39;false&#39; otherwise.

template &lt;typename CHAR_TYPE&gt;
bool operator&lt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp; lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&lt;=(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp;      rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&lt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;      lhs,
                const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&lt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;             lhs,
                const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&lt;=(const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp;             rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&lt;=(const CHAR_TYPE                *lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp;  rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&lt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;  lhs,
                const CHAR_TYPE                *rhs);
    // Return &#39;true&#39; if the string referred to by the specified &#39;lhs&#39; is
    // lexicographically less than or equal to the string referred to by the
    // specified &#39;rhs&#39;, and &#39;false&#39; otherwise.

template &lt;typename CHAR_TYPE&gt;
bool operator&gt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp; lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&gt;=(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp;      rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&gt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;      lhs,
                const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&gt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;             lhs,
                const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&gt;=(const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp;             rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&gt;=(const CHAR_TYPE                *lhs,
                const StringRefImp&lt;CHAR_TYPE&gt;&amp;  rhs);
template &lt;typename CHAR_TYPE&gt;
bool operator&gt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;  lhs,
                const CHAR_TYPE                *rhs);
    // Return &#39;true&#39; if the string referred to by the specified &#39;lhs&#39; is
    // lexicographically greater than or equal to the string referred to by the
    // specified &#39;rhs&#39;, and &#39;false&#39; otherwise.

template &lt;typename CHAR_TYPE&gt;
bsl::basic_string&lt;CHAR_TYPE&gt;
    operator+(const StringRefImp&lt;CHAR_TYPE&gt;&amp; lhs,
              const StringRefImp&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bsl::basic_string&lt;CHAR_TYPE&gt;
    operator+(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
              const StringRefImp&lt;CHAR_TYPE&gt;&amp;      rhs);
template &lt;typename CHAR_TYPE&gt;
bsl::basic_string&lt;CHAR_TYPE&gt;
    operator+(const StringRefImp&lt;CHAR_TYPE&gt;&amp;      lhs,
              const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bsl::basic_string&lt;CHAR_TYPE&gt;
    operator+(const StringRefImp&lt;CHAR_TYPE&gt;&amp;             lhs,
              const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; rhs);
template &lt;typename CHAR_TYPE&gt;
bsl::basic_string&lt;CHAR_TYPE&gt;
    operator+(const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
              const StringRefImp&lt;CHAR_TYPE&gt;&amp;             rhs);
template &lt;typename CHAR_TYPE&gt;
bsl::basic_string&lt;CHAR_TYPE&gt;
    operator+(const CHAR_TYPE                *lhs,
              const StringRefImp&lt;CHAR_TYPE&gt;&amp;  rhs);
template &lt;typename CHAR_TYPE&gt;
bsl::basic_string&lt;CHAR_TYPE&gt;
    operator+(const StringRefImp&lt;CHAR_TYPE&gt;&amp;  lhs,
              const CHAR_TYPE                *rhs);
    // Return a &#39;bsl::string&#39; having the value of the concatenation of the
    // strings referred to by the specified &#39;lhs&#39; and rhs&#39; values.

template &lt;typename CHAR_TYPE&gt;
std::basic_ostream&lt;CHAR_TYPE&gt;&amp;
    operator&lt;&lt;(std::basic_ostream&lt;CHAR_TYPE&gt;&amp; stream,
               const StringRefImp&lt;CHAR_TYPE&gt;&amp; stringRef);
    // Write the value of the string bound to the specified &#39;stringRef&#39; to the
    // specified output &#39;stream&#39; and return a reference to the modifiable
    // &#39;stream&#39;.

// ===========================================================================
//                                  TYPEDEFS
// ===========================================================================

typedef StringRefImp&lt;char&gt;       StringRef;
typedef StringRefImp&lt;wchar_t&gt;    StringRefWide;

// ===========================================================================
//                        INLINE FUNCTION DEFINITIONS
// ===========================================================================

                          // ------------------
                          // class StringRefImp
                          // ------------------

// PRIVATE ACCESSORS
template &lt;typename CHAR_TYPE&gt;
inline
void StringRefImp&lt;CHAR_TYPE&gt;::write(
                                   std::basic_ostream&lt;CHAR_TYPE&gt;&amp; stream) const
{
    if (data()) {
        stream.write(data(), length());
    }
    else {
        BSLS_ASSERT_SAFE(length() == 0);
    }
}

// CREATORS
template &lt;typename CHAR_TYPE&gt;
inline
StringRefImp&lt;CHAR_TYPE&gt;::StringRefImp()
: Base(0, 0)
{
}

template &lt;typename CHAR_TYPE&gt;
inline
StringRefImp&lt;CHAR_TYPE&gt;::StringRefImp(const CHAR_TYPE *data,
                                      int              length)
: Base(data, data + length)
{
    BSLS_ASSERT_SAFE(0 &lt;= length);
    BSLS_ASSERT_SAFE(data || 0 == length);
}

template &lt;typename CHAR_TYPE&gt;
inline
StringRefImp&lt;CHAR_TYPE&gt;::StringRefImp(const_iterator begin,
                                      const_iterator end)
: Base(begin, end)
{
}

template &lt;typename CHAR_TYPE&gt;
inline
StringRefImp&lt;CHAR_TYPE&gt;::StringRefImp(const CHAR_TYPE *data)
: Base(data, data + std::strlen(data))
{
}

template &lt;typename CHAR_TYPE&gt;
inline
StringRefImp&lt;CHAR_TYPE&gt;::StringRefImp(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; str)
: Base(str.data(), str.data() + str.length())
{
}

template &lt;typename CHAR_TYPE&gt;
inline
StringRefImp&lt;CHAR_TYPE&gt;::StringRefImp(
                                const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; str)
: Base(str.data(), str.data() + str.length())
{
}

template &lt;typename CHAR_TYPE&gt;
inline
StringRefImp&lt;CHAR_TYPE&gt;::StringRefImp(const StringRefImp&lt;CHAR_TYPE&gt;&amp; original)
: Base(original.begin(), original.end())
{
}

// MANIPULATORS
template &lt;typename CHAR_TYPE&gt;
inline
StringRefImp&lt;CHAR_TYPE&gt;&amp;
    StringRefImp&lt;CHAR_TYPE&gt;::operator=(const StringRefImp&amp; rhs)
{
    Base::operator=(rhs);
    return *this;
}

template &lt;typename CHAR_TYPE&gt;
inline
void StringRefImp&lt;CHAR_TYPE&gt;::assign(const CHAR_TYPE *data,
                                     int              length)
{
    BSLS_ASSERT_SAFE(0 &lt;= length);
    BSLS_ASSERT_SAFE(data || 0 == length);

    *this = StringRef(data, data + length);
}

template &lt;typename CHAR_TYPE&gt;
inline
void StringRefImp&lt;CHAR_TYPE&gt;::assign(const_iterator begin,
                                     const_iterator end)
{
    *this = StringRef(begin, end);
}

template &lt;typename CHAR_TYPE&gt;
inline
void StringRefImp&lt;CHAR_TYPE&gt;::assign(const CHAR_TYPE *data)
{
    BSLS_ASSERT_SAFE(data);

    *this = StringRef(data, data + std::strlen(data));
}

template &lt;typename CHAR_TYPE&gt;
inline
void StringRefImp&lt;CHAR_TYPE&gt;::assign(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; str)
{
    *this = StringRef(str.data(), str.data() + str.length());
}

template &lt;typename CHAR_TYPE&gt;
inline
void StringRefImp&lt;CHAR_TYPE&gt;::assign(const StringRefImp&lt;CHAR_TYPE&gt;&amp; stringRef)
{
    *this = stringRef;
}

template &lt;typename CHAR_TYPE&gt;
inline
void StringRefImp&lt;CHAR_TYPE&gt;::reset()
{
    *this = StringRef(0, 0);
}

// ACCESSORS
template &lt;typename CHAR_TYPE&gt;
inline
typename StringRefImp&lt;CHAR_TYPE&gt;::const_reference
    StringRefImp&lt;CHAR_TYPE&gt;::operator[](int index) const
{
    BSLS_ASSERT_SAFE(0 &lt;= index);
    BSLS_ASSERT_SAFE(index &lt; static_cast&lt;int&gt;(end() - begin()));

    return begin()[index];
}

}  // close package namespace

template &lt;typename CHAR_TYPE&gt;
inline
bslstl::StringRefImp&lt;CHAR_TYPE&gt;::
                           operator native_std::basic_string&lt;CHAR_TYPE&gt;() const
{
    return native_std::basic_string&lt;CHAR_TYPE&gt;(begin(), end());
}

namespace bslstl {

template &lt;typename CHAR_TYPE&gt;
inline
typename StringRefImp&lt;CHAR_TYPE&gt;::const_iterator
    StringRefImp&lt;CHAR_TYPE&gt;::begin() const
{
    return Base::begin();
}

template &lt;typename CHAR_TYPE&gt;
inline
typename StringRefImp&lt;CHAR_TYPE&gt;::const_iterator
    StringRefImp&lt;CHAR_TYPE&gt;::end() const
{
    return Base::end();
}

template &lt;typename CHAR_TYPE&gt;
inline
const CHAR_TYPE *StringRefImp&lt;CHAR_TYPE&gt;::data() const
{
    return begin();
}

template &lt;typename CHAR_TYPE&gt;
inline
bool StringRefImp&lt;CHAR_TYPE&gt;::isEmpty() const
{
    return begin() == end();
}

template &lt;typename CHAR_TYPE&gt;
inline
typename StringRefImp&lt;CHAR_TYPE&gt;::size_type
    StringRefImp&lt;CHAR_TYPE&gt;::length() const
{
    return static_cast&lt;size_type&gt;(end() - begin());
}

}  // close package namespace

// FREE OPERATORS
template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator==(const StringRefImp&lt;CHAR_TYPE&gt;&amp; lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp; rhs)
{
    std::size_t len = lhs.length();

    if (len != rhs.length()) {
        return false;                                                 // RETURN
    }

    return 0 == len || 0 == std::memcmp(lhs.data(), rhs.data(), len);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator==(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp;      rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) == rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator==(const StringRefImp&lt;CHAR_TYPE&gt;&amp;      lhs,
                        const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return lhs == StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator==(const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp;             rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) == rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator==(const StringRefImp&lt;CHAR_TYPE&gt;&amp;             lhs,
                        const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return lhs == StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator==(const CHAR_TYPE                *lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp;  rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) == rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator==(const StringRefImp&lt;CHAR_TYPE&gt;&amp;  lhs,
                        const CHAR_TYPE                *rhs)
{
    return lhs == StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator!=(const StringRefImp&lt;CHAR_TYPE&gt;&amp; lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return !(lhs == rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator!=(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp;      rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) != rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator!=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;      lhs,
                        const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return lhs != StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator!=(const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp;             rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) != rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator!=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;             lhs,
                        const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return lhs != StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator!=(const CHAR_TYPE                *lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp;  rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) != rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator!=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;  lhs,
                        const CHAR_TYPE                *rhs)
{
    return lhs != StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&lt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp; lhs,
                       const StringRefImp&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return std::lexicographical_compare(lhs.begin(), lhs.end(),
                                        rhs.begin(), rhs.end());
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&lt;(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                       const StringRefImp&lt;CHAR_TYPE&gt;&amp;      rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) &lt; rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&lt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp;      lhs,
                       const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return lhs &lt; StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&lt;(const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                       const StringRefImp&lt;CHAR_TYPE&gt;&amp;             rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) &lt; rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&lt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp;             lhs,
                       const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return lhs &lt; StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&lt;(const CHAR_TYPE                *lhs,
                       const StringRefImp&lt;CHAR_TYPE&gt;&amp;  rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) &lt; rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&lt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp;  lhs,
                       const CHAR_TYPE                *rhs)
{
    return lhs &lt; StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&gt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp; lhs,
                       const StringRefImp&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return std::lexicographical_compare(rhs.begin(), rhs.end(),
                                        lhs.begin(), lhs.end());
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&gt;(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                       const StringRefImp&lt;CHAR_TYPE&gt;&amp;      rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) &gt; rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&gt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp;      lhs,
                       const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return lhs &gt; StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&gt;(const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                       const StringRefImp&lt;CHAR_TYPE&gt;&amp;             rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) &gt; rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&gt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp;             lhs,
                       const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return lhs &gt; StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&gt;(const CHAR_TYPE                *lhs,
                       const StringRefImp&lt;CHAR_TYPE&gt;&amp;  rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) &gt; rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&gt;(const StringRefImp&lt;CHAR_TYPE&gt;&amp;  lhs,
                       const CHAR_TYPE                *rhs)
{
    return lhs &gt; StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&lt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp; lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return !(lhs &gt; rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&lt;=(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp;      rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) &lt;= rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&lt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;      lhs,
                        const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return lhs &lt;= StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&lt;=(const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp;             rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) &lt;= rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&lt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;             lhs,
                        const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return lhs &lt;= StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&lt;=(const CHAR_TYPE                *lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp;  rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) &lt;= rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&lt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;  lhs,
                        const CHAR_TYPE                *rhs)
{
    return lhs &lt;= StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&gt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp; lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return !(lhs &lt; rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&gt;=(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp;      rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) &gt;= rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&gt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;      lhs,
                        const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return lhs &gt;= StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&gt;=(const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp;             rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) &gt;= rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&gt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;             lhs,
                        const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return lhs &gt;= StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&gt;=(const CHAR_TYPE                *lhs,
                        const StringRefImp&lt;CHAR_TYPE&gt;&amp;  rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) &gt;= rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bool bslstl::operator&gt;=(const StringRefImp&lt;CHAR_TYPE&gt;&amp;  lhs,
                        const CHAR_TYPE                *rhs)
{
    return lhs &gt;= StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
bsl::basic_string&lt;CHAR_TYPE&gt;
    bslstl::operator+(const StringRefImp&lt;CHAR_TYPE&gt;&amp; lhs,
                      const StringRefImp&lt;CHAR_TYPE&gt;&amp; rhs)
{
    bsl::basic_string&lt;CHAR_TYPE&gt; result;

    result.reserve(lhs.length() + rhs.length());
    result.assign(lhs.begin(), lhs.end());
    result.append(rhs.begin(), rhs.end());

    return result;
}

template &lt;typename CHAR_TYPE&gt;
inline
bsl::basic_string&lt;CHAR_TYPE&gt;
    bslstl::operator+(const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                      const StringRefImp&lt;CHAR_TYPE&gt;&amp;      rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) + rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bsl::basic_string&lt;CHAR_TYPE&gt;
    bslstl::operator+(const StringRefImp&lt;CHAR_TYPE&gt;&amp;      lhs,
                      const bsl::basic_string&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return lhs + StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bsl::basic_string&lt;CHAR_TYPE&gt;
    bslstl::operator+(const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; lhs,
                      const StringRefImp&lt;CHAR_TYPE&gt;&amp;             rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) + rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bsl::basic_string&lt;CHAR_TYPE&gt;
    bslstl::operator+(const StringRefImp&lt;CHAR_TYPE&gt;&amp;             lhs,
                      const native_std::basic_string&lt;CHAR_TYPE&gt;&amp; rhs)
{
    return lhs + StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
inline
bsl::basic_string&lt;CHAR_TYPE&gt;
    bslstl::operator+(const CHAR_TYPE                *lhs,
                      const StringRefImp&lt;CHAR_TYPE&gt;&amp;  rhs)
{
    return StringRefImp&lt;CHAR_TYPE&gt;(lhs) + rhs;
}

template &lt;typename CHAR_TYPE&gt;
inline
bsl::basic_string&lt;CHAR_TYPE&gt;
    bslstl::operator+(const StringRefImp&lt;CHAR_TYPE&gt;&amp;  lhs,
                      const CHAR_TYPE                *rhs)
{
    return lhs + StringRefImp&lt;CHAR_TYPE&gt;(rhs);
}

template &lt;typename CHAR_TYPE&gt;
std::basic_ostream&lt;CHAR_TYPE&gt;&amp;
bslstl::operator&lt;&lt;(std::basic_ostream&lt;CHAR_TYPE&gt;&amp; stream,
                   const StringRefImp&lt;CHAR_TYPE&gt;&amp; stringRef)
{
    typedef CHAR_TYPE                                           char_type;
    typedef typename std::basic_ostream&lt;char_type&gt;::ios_base    ios_base;
    typedef typename bslstl::StringRefImp&lt;char_type&gt;::size_type size_type;

    size_type width = stream.width();
    size_type len = stringRef.length();

    if (len &lt; width) {
        bool leftAdjusted
            = (stream.flags() &amp; ios_base::adjustfield) == ios_base::left;
        char_type fillChar = stream.fill();

        if (leftAdjusted) {
            stringRef.write(stream);
        }

        for (size_type n = 0; n != width - len; ++n) {
            stream.put(fillChar);
        }

        if (!leftAdjusted) {
            stringRef.write(stream);
        }
    }
    else {
        stringRef.write(stream);
        stream.width(0);
    }

    return stream;
}


}  // close enterprise namespace

                      // =================================
                      // struct hash&lt;bslstl::StringRefImp&gt;
                      // =================================

namespace bsl {

template &lt;typename CHAR_TYPE&gt;
struct hash&lt;BloombergLP::bslstl::StringRefImp&lt;CHAR_TYPE&gt; &gt; {
    // This template specialization enables use of &#39;bslstl::StringRefImp&#39;
    // within STL hash containers, for example,
    // &#39;bsl::hash_set&lt;bslstl::StringRefImp&gt;&#39; and
    // &#39;bsl::hash_map&lt;bslstl::StringRefImp, Type&gt;&#39; for some type &#39;Type&#39;.

    // ACCESSORS
    std::size_t
    operator()(const BloombergLP::bslstl::StringRefImp&lt;CHAR_TYPE&gt;&amp;
                                                              stringRef) const;
        // Return a hash corresponding to the string bound to the specified
        // &#39;stringRef&#39;.
};

// ACCESSORS
template &lt;typename CHAR_TYPE&gt;
std::size_t hash&lt;BloombergLP::bslstl::StringRefImp&lt;CHAR_TYPE&gt; &gt;::
operator()(const BloombergLP::bslstl::StringRefImp&lt;CHAR_TYPE&gt;&amp; stringRef) const
{
    const CHAR_TYPE *string = stringRef.begin();
    const CHAR_TYPE *end    = stringRef.end();

    const unsigned int ADDEND       = 1013904223U;
    const unsigned int MULTIPLICAND =    1664525U;
    const unsigned int MASK         = 4294967295U;

    std::size_t r = 0;

    if (4 == sizeof(int)) {
        while (string != end) {
            r ^= *string++;
            r = r * MULTIPLICAND + ADDEND;
        }
    }
    else {
        while (string != end) {
            r ^= *string++;
            r = (r * MULTIPLICAND + ADDEND) &amp; MASK;
        }
    }

    return r;
}

}  // close namespace bsl

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
