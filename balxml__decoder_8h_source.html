<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// balxml_decoder.h                                                   -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALXML_DECODER
#define INCLUDED_BALXML_DECODER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a generic translation from XML into C++ objects.
//
//@CLASSES:
//   balxml::Decoder: an XML decoder
//
//@SEE_ALSO: balxml_decoderoptions, balxml_encoder, balber_berdecoder
//
//@DESCRIPTION: This component provides a class &#39;balxml::Decoder&#39; for decoding
// value-semantic objects in XML format.  The &#39;decode&#39; methods are function
// templates that will decode any object that meets the requirements of a
// sequence or choice object as defined in the &#39;bdlat_sequencefunctions&#39; and
// &#39;bdlat_choicefunctions&#39; components.  These generic frameworks provide a
// common compile-time interface for manipulating struct-like and union-like
// objects.
//
// There are two usage models for using &#39;balxml::Decoder&#39;.  The common case,
// when the type of object being decoded is known in advance, involves calling
// one of a set of &#39;decode&#39; method templates that decode a specified
// value-semantic object from a specified stream or other input source.  The
// caller may specify the input for &#39;decode&#39; as a file, an &#39;bsl::istream&#39;, an
// &#39;bsl::streambuf&#39;, or a memory buffer.
//
// A less common but more flexible usage model involves calling the &#39;open&#39; to
// open the XML document from the specified input, then calling &#39;decode&#39; to
// decode to an object without specifying the input source, and finally
// calling &#39;close&#39; to close the input source.  The &#39;open&#39; method positions the
// internal reader to the root element node, so the caller can examine the
// root element, decide what type of object is contained in the input
// stream/source, and construct an object of the needed type before calling
// &#39;decode&#39; to read from the already open input source.  Thus the input data
// is not constrained to a single root element type.
//
// Although the XML format is very useful for debugging and for conforming to
// external data-interchange specifications, it is relatively expensive to
// encode and decode and relatively bulky to transmit.  It is more efficient
// to use a binary encoding (such as BER) if the encoding format is under your
// control.  (See &#39;balber_berdecoder&#39;.)
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Generating Code from a Schema
/// - - - - - - - - - - - - - - - - - - - -
// Suppose we have the following XML schema inside a file called
// &#39;employee.xsd&#39;:
//..
//  &lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;
//  &lt;xs:schema xmlns:xs=&#39;http://www.w3.org/2001/XMLSchema&#39;
//             xmlns:test=&#39;http://bloomberg.com/schemas/test&#39;
//             targetNamespace=&#39;http://bloomberg.com/schemas/test&#39;
//             elementFormDefault=&#39;unqualified&#39;&gt;
//
//      &lt;xs:complexType name=&#39;Address&#39;&gt;
//          &lt;xs:sequence&gt;
//              &lt;xs:element name=&#39;street&#39; type=&#39;xs:string&#39;/&gt;
//              &lt;xs:element name=&#39;city&#39;   type=&#39;xs:string&#39;/&gt;
//              &lt;xs:element name=&#39;state&#39;  type=&#39;xs:string&#39;/&gt;
//          &lt;/xs:sequence&gt;
//      &lt;/xs:complexType&gt;
//
//      &lt;xs:complexType name=&#39;Employee&#39;&gt;
//          &lt;xs:sequence&gt;
//              &lt;xs:element name=&#39;name&#39;        type=&#39;xs:string&#39;/&gt;
//              &lt;xs:element name=&#39;homeAddress&#39; type=&#39;test:Address&#39;/&gt;
//              &lt;xs:element name=&#39;age&#39;         type=&#39;xs:int&#39;/&gt;
//          &lt;/xs:sequence&gt;
//      &lt;/xs:complexType&gt;
//
//      &lt;xs:element name=&#39;Address&#39; type=&#39;test:Address&#39;/&gt;
//      &lt;xs:element name=&#39;Employee&#39; type=&#39;test:Employee&#39;/&gt;
//
//  &lt;/xs:schema&gt;
//..
// Using the &#39;bas_codegen.pl&#39; tool, we can generate C++ classes for this
// schema:
//..
//  $ bas_codegen.pl -m msg -p test -E xsdfile.xsd
//..
// This tool will generate the header and implementation files for the
// &#39;test_address&#39; and &#39;test_employee&#39; components in the current directory.
//
// The following function decodes an XML string into a &#39;test::Employee&#39; object
// and verifies the results:
//..
//  #include &lt;test_employee.h&gt;
//  #include &lt;balxml_decoder.h&gt;
//  #include &lt;balxml_decoderoptions.h&gt;
//  #include &lt;balxml_errorinfo.h&gt;
//  #include &lt;balxml_minireader.h&gt;
//  #include &lt;bsl_sstream.h&gt;
//
//  using namespace BloombergLP;
//
//  int main()
//  {
//      const char INPUT[] = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot; ?&gt;\n&quot;
//                           &quot;&lt;Employee&gt;\n&quot;
//                           &quot;    &lt;name&gt;Bob&lt;/name&gt;\n&quot;
//                           &quot;    &lt;homeAddress&gt;\n&quot;
//                           &quot;        &lt;street&gt;Some Street&lt;/street&gt;\n&quot;
//                           &quot;        &lt;city&gt;Some City&lt;/city&gt;\n&quot;
//                           &quot;        &lt;state&gt;Some State&lt;/state&gt;\n&quot;
//                           &quot;    &lt;/homeAddress&gt;\n&quot;
//                           &quot;    &lt;age&gt;21&lt;/age&gt;\n&quot;
//                           &quot;&lt;/Employee&gt;\n&quot;;
//
//      bsl::stringstream ss(INPUT);
//
//      test::Employee bob;
//
//      balxml::DecoderOptions options;
//      balxml::MiniReader     reader;
//      balxml::ErrorInfo      errInfo;
//
//      balxml::Decoder decoder(&amp;options, &amp;reader, &amp;errInfo);
//
//      decoder.decode(ss, &amp;bob);
//
//      assert(ss);
//      assert(&quot;Bob&quot;         == bob.name());
//      assert(&quot;Some Street&quot; == bob.homeAddress().street());
//      assert(&quot;Some City&quot;   == bob.homeAddress().city());
//      assert(&quot;Some State&quot;  == bob.homeAddress().state());
//      assert(21            == bob.age());
//
//      return 0;
//  }
//..
//
///Example 2: Error and Warning Streams
/// - - - - - - - - - - - - - - - - - -
// The following snippets of code illustrate how to pass an error stream and
// warning stream to the &#39;decode&#39; function.  We will use the same
// &#39;test_employee&#39; component from the previous usage example.  Note that the
// input XML string contains an error.  (The &#39;homeAddress&#39; object has an
// element called &#39;country&#39;, which does not exist in the schema.):
//..
//  #include &lt;test_employee.h&gt;
//  #include &lt;balxml_decoder.h&gt;
//  #include &lt;balxml_decoderoptions.h&gt;
//  #include &lt;balxml_errorinfo.h&gt;
//  #include &lt;balxml_minireader.h&gt;
//  #include &lt;bsl_sstream.h&gt;
//
//  using namespace BloombergLP;
//
//  int main()
//  {
//      const char INPUT[] = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot; ?&gt;\n&quot;
//                           &quot;&lt;Employee&gt;\n&quot;
//                           &quot;    &lt;name&gt;Bob&lt;/name&gt;\n&quot;
//                           &quot;    &lt;homeAddress&gt;\n&quot;
//                           &quot;        &lt;street&gt;Some Street&lt;/street&gt;\n&quot;
//                           &quot;        &lt;city&gt;Some City&lt;/city&gt;\n&quot;
//                           &quot;        &lt;state&gt;Some State&lt;/state&gt;\n&quot;
//                           &quot;        &lt;country&gt;Some Country&lt;/country&gt;\n&quot;
//                           &quot;    &lt;/homeAddress&gt;\n&quot;
//                           &quot;    &lt;age&gt;21&lt;/age&gt;\n&quot;
//                           &quot;&lt;/Employee&gt;\n&quot;;
//
//      bsl::stringstream ss(INPUT);
//
//      test::Employee bob;
//
//      balxml::DecoderOptions options;
//      balxml::MiniReader     reader;
//      balxml::ErrorInfo      errInfo;
//
//      options.setSkipUnknownElements(false);
//      balxml::Decoder decoder(&amp;options, &amp;reader, &amp;errInfo,
//                              &amp;bsl::cerr, &amp;bsl::cerr);
//      decoder.decode(ss, &amp;bob);
//
//      assert(!ss);
//
//      return 0;
//  }
//..
// Note that the input stream is invalidated to indicate that an error
// occurred.  Also note that the following error message will be printed on
// &#39;bsl::cerr&#39;:
//..
//  employee.xml:8.18: Error: Unable to decode sub-element &#39;country&#39;.\n&quot;
//  employee.xml:8.18: Error: Unable to decode sub-element &#39;homeAddress&#39;.\n&quot;;
//..
// The following snippets of code illustrate how to open decoder and read the
// first node before calling &#39;decode&#39;:
//..
//  int main()
//  {
//      const char INPUT[] =
//          &quot;&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39; ?&gt;\n&quot;
//          &quot;&lt;Employee xmlns=&#39;http://www.bde.com/bdem_test&#39;&gt;\n&quot;
//          &quot;    &lt;name&gt;Bob&lt;/name&gt;\n&quot;
//          &quot;    &lt;homeAddress&gt;\n&quot;
//          &quot;        &lt;street&gt;Some Street&lt;/street&gt;\n&quot;
//          &quot;        &lt;state&gt;Some State&lt;/state&gt;\n&quot;
//          &quot;        &lt;city&gt;Some City&lt;/city&gt;\n&quot;
//          &quot;        &lt;country&gt;Some Country&lt;/country&gt;\n&quot;
//          &quot;    &lt;/homeAddress&gt;\n&quot;
//          &quot;    &lt;age&gt;21&lt;/age&gt;\n&quot;
//          &quot;&lt;/Employee&gt;\n&quot;;
//
//      balxml::MiniReader     reader;
//      balxml::ErrorInfo      errInfo;
//      balxml::DecoderOptions options;
//
//      balxml::Decoder decoder(&amp;options, &amp;reader, &amp;errInfo,
//                              &amp;bsl::cerr, &amp;bsl::cerr);
//
//..
// Now we open the document, but we don&#39;t begin decoding yet:
//..
//      int rc = decoder.open(INPUT, sizeof(INPUT) - 1);
//      assert(0 == rc);
//..
// Depending on the value of the first node, we can now determine whether the
// document is an &#39;Address&#39; object or an &#39;Employee&#39; object, and construct the
// target object accordingly:
//..
//      if (0 == bsl::strcmp(reader.nodeLocalName(), &quot;Address&quot;)) {
//          test::Address addr;
//          rc = decoder.decode(&amp;addr);
//          bsl::cout &lt;&lt; addr;
//      }
//      else {
//          test::Employee bob;
//          rc = decoder.decode(&amp;bob);
//          bsl::cout &lt;&lt; bob;
//      }
//
//      assert(0 == rc);
//..
// When decoding is complete, we must close the decoder object:
//..
//      decoder.close();
//      return 0;
//  }
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BALXML_BASE64PARSER
#include &lt;balxml_base64parser.h&gt;
#endif

#ifndef INCLUDED_BALXML_DECODEROPTIONS
#include &lt;balxml_decoderoptions.h&gt;
#endif

#ifndef INCLUDED_BALXML_HEXPARSER
#include &lt;balxml_hexparser.h&gt;
#endif

#ifndef INCLUDED_BALXML_LISTPARSER
#include &lt;balxml_listparser.h&gt;
#endif

#ifndef INCLUDED_BALXML_TYPESPARSERUTIL
#include &lt;balxml_typesparserutil.h&gt;
#endif

#ifndef INCLUDED_BALXML_ERRORINFO
#include &lt;balxml_errorinfo.h&gt;
#endif

#ifndef INCLUDED_BALXML_READER
#include &lt;balxml_reader.h&gt;
#endif

#ifndef INCLUDED_BDLAT_ARRAYFUNCTIONS
#include &lt;bdlat_arrayfunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_CHOICEFUNCTIONS
#include &lt;bdlat_choicefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_CUSTOMIZEDTYPEFUNCTIONS
#include &lt;bdlat_customizedtypefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_FORMATTINGMODE
#include &lt;bdlat_formattingmode.h&gt;
#endif

#ifndef INCLUDED_BDLAT_NULLABLEVALUEFUNCTIONS
#include &lt;bdlat_nullablevaluefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_SEQUENCEFUNCTIONS
#include &lt;bdlat_sequencefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_TYPECATEGORY
#include &lt;bdlat_typecategory.h&gt;
#endif

#ifndef INCLUDED_BDLAT_VALUETYPEFUNCTIONS
#include &lt;bdlat_valuetypefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLB_STRING
#include &lt;bdlb_string.h&gt;
#endif

#ifndef INCLUDED_BDLSB_MEMOUTSTREAMBUF
#include &lt;bdlsb_memoutstreambuf.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMF_IF
#include &lt;bslmf_if.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_OBJECTBUFFER
#include &lt;bsls_objectbuffer.h&gt;
#endif

#ifndef INCLUDED_BSL_ALGORITHM
#include &lt;bsl_algorithm.h&gt;            // bsl::min
#endif

#ifndef INCLUDED_BSL_ISTREAM
#include &lt;bsl_istream.h&gt;
#endif

#ifndef INCLUDED_BSL_MAP
#include &lt;bsl_map.h&gt;
#endif

#ifndef INCLUDED_BSL_OSTREAM
#include &lt;bsl_ostream.h&gt;
#endif

#ifndef INCLUDED_BSL_STREAMBUF
#include &lt;bsl_streambuf.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTRING
#include &lt;bsl_cstring.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDLIB
#include &lt;bsl_cstdlib.h&gt;
#endif

#ifndef INCLUDED_BSL_CERRNO
#include &lt;bsl_cerrno.h&gt;
#endif

namespace BloombergLP {


namespace balxml {class Reader;
class ErrorInfo;
class Decoder;

                        // ============================
                        // class Decoder_ElementContext
                        // ============================

class Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // This protocol class contain functions related to parsing XML elements.
    // When the Decoder reads the XML document, it forwards the information
    // about the current node as events to this protocol.  There are several
    // implementations of this protocol, depending on the type of element.  The
    // correct implementation for each type is selected by the
    // &#39;Decoder_SelectContext&#39; meta-function.  Each of the functions take a
    // &#39;context&#39; parameter, which contains members related to the context of
    // the decoder.

  public:
    virtual ~Decoder_ElementContext();
        // For syntactic purposes only.

    // CALLBACKS
    virtual int startElement(Decoder *decoder) = 0;

    virtual int endElement(Decoder *decoder) = 0;

    virtual int addCharacters(const char   *chars,
                              unsigned int  length,
                              Decoder      *decoder) = 0;

    virtual int parseAttribute(const char  *name,
                               const char  *value,
                               bsl::size_t  lenValue,
                               Decoder     *decoder) = 0;

    virtual int parseSubElement(const char *elementName, Decoder *decoder) = 0;

    int beginParse(Decoder *decoder);
};

                               // =============
                               // class Decoder
                               // =============

class Decoder {
    // Engine for decoding value-semantic objects in XML format.  The &#39;decode&#39;
    // methods are function templates that will decode any object that meets
    // the requirements of a sequence or choice object as defined in the
    // &#39;bdlat_sequencefunctions&#39; and &#39;bdlat_choicefunctions&#39; components.
    // These generic frameworks provide a common compile-time interface for
    // manipulating struct-like and union-like objects.

    friend class  Decoder_ElementContext;
    friend struct Decoder_decodeImpProxy;
    friend class  Decoder_ErrorLogger;

    // PRIVATE TYPES
    class MemOutStream : public bsl::ostream {
        // This class provides stream for logging using
        // &#39;bdlsb::MemOutStreamBuf&#39; as a streambuf.  The logging stream is
        // created on demand, i.e., during the first attempt to log message.
        bdlsb::MemOutStreamBuf d_sb;

        // NOT IMPLEMENTED
        MemOutStream(const MemOutStream&amp;);
        MemOutStream&amp; operator=(const MemOutStream&amp;);

      public:
        // CREATORS
        MemOutStream(bslma::Allocator *basicAllocator = 0);
            // Create a new stream using the optionally specified
            // &#39;basicAllocator&#39;.

        virtual ~MemOutStream();
            // Destroy this stream and release memory back to the allocator.

        // MANIPULATORS
        void reset();
            // Reset the internal streambuf to empty.

        // ACCESSORS
        const char *data() const;
            // Return a pointer to the memory containing the formatted values
            // formatted to this stream.  The data is not null-terminated
            // unless a null character was appended onto this stream.

        int length() const;
            // Return the length of of the formatted data, including null
            // characters appended to the stream, if any.
    };

    // DATA
    const DecoderOptions     *d_options;        // held, not owned
    Reader                   *d_reader;         // held, not owned
    ErrorInfo                *d_errorInfo;      // held, not owned

    bslma::Allocator                *d_allocator;      // held, not owned

    bsls::ObjectBuffer&lt;MemOutStream&gt; d_logArea;
        // placeholder for MemOutStream

    MemOutStream                    *d_logStream;
        // if not zero, log stream was created at the moment of first logging
        // and must be destroyed

    bsl::ostream                    *d_errorStream;    // held, not owned
    bsl::ostream                    *d_warningStream;  // held, not owned

    bsl::string                      d_sourceUri;      // URI of input document
    int                              d_errorCount;     // error count
    int                              d_warningCount;   // warning count

    int                              d_numUnknownElementsSkipped;
                                                       // number of unknown
                                                       // elements skipped

    bool                             d_fatalError;     // fatal error flag
    int                              d_remainingDepth;
        // remaining number of nesting levels allowed

    // NOT IMPLEMENTED
    Decoder(const Decoder&amp;);
    Decoder operator=(const Decoder&amp;);

  private:
    // PRIVATE MANIPULATORS
    bsl::ostream&amp; logStream();
        // Return the stream for logging.  Note the if stream has not been
        // created yet, it will be created during this call.

    void resetErrors();
    int  checkForReaderErrors();
    int  checkForErrors(const ErrorInfo&amp; errInfo);

    void setDecoderError(ErrorInfo::Severity severity, bslstl::StringRef msg);

    int  readTopElement();
    int  parse(Decoder_ElementContext *context);

    template &lt;class TYPE&gt;
    int decodeImp(TYPE *object, bdlat_TypeCategory::DynamicType);

    template &lt;class TYPE, class ANY_CATEGORY&gt;
    int decodeImp(TYPE *object, ANY_CATEGORY);

  public:
    // CREATORS
    Decoder(const DecoderOptions *options,
            Reader               *reader,
            ErrorInfo            *errInfo,
            bslma::Allocator     *basicAllocator);

    Decoder(const DecoderOptions *options,
            Reader               *reader,
            ErrorInfo            *errInfo = 0,
            bsl::ostream         *errorStream = 0,
            bsl::ostream         *warningStream = 0,
            bslma::Allocator     *basicAllocator = 0);
        // Construct a decoder object using the specified &#39;options&#39; and the
        // specified &#39;reader&#39; to perform the XML-level parsing.  If the
        // (optionally) specified &#39;errorInfo&#39; is non-null, it is used to store
        // information about most serious error encountered during parsing.
        // During parsing, error and warning messages will be written to the
        // (optionally) specified &#39;errorStream&#39; and &#39;warningStream&#39;
        // respectively.  The behavior is undefined unless &#39;options&#39; and
        // &#39;reader&#39; are both non-zero.  The behavior becomes undefined if the
        // objects pointed to by any of the arguments is destroyed before this
        // object has completed parsing.

    ~Decoder();
        // Call &#39;close&#39; and destroy this object.

    // MANIPULATORS
    void close();
        // Put the associated &#39;Reader&#39; object (i.e., the &#39;reader&#39; specified at
        // construction) into a closed state.

    int open(bsl::istream&amp; stream, const char *uri = 0);
        // Open the associated &#39;Reader&#39; object (see &#39;Reader::open&#39;) to read XML
        // data from the specified &#39;stream&#39;.  The (optionally) specified &#39;uri&#39;
        // is used for identifying the input document in error messages.
        // Return 0 on success and non-zero otherwise.

    int open(bsl::streambuf *buffer, const char *uri = 0);
        // Open the associated &#39;Reader&#39; object (see &#39;Reader::open&#39;) to read XML
        // data from the specified stream &#39;buffer&#39;.  The (optionally) specified
        // &#39;uri&#39; is used for identifying the input document in error messages.
        // Return 0 on success and non-zero otherwise.

    int open(const char *buffer, bsl::size_t length, const char *uri = 0);
        // Open the associated &#39;Reader&#39; object (see &#39;Reader::open&#39;) to read XML
        // data from memory at the specified &#39;buffer&#39;, with the specified
        // &#39;length&#39;.  The (optionally) specified &#39;uri&#39; is used for identifying
        // the input document in error messages.  Return 0 on success and
        // non-zero otherwise.

    int open(const char *filename);
        // Open the associated &#39;Reader&#39; object (see &#39;Reader::open&#39;) to read XML
        // data from the file with the specified &#39;filename&#39;.  Return 0 on
        // success and non-zero otherwise.

    template &lt;class TYPE&gt;
    bsl::istream&amp; decode(bsl::istream&amp;  stream,
                         TYPE          *object,
                         const char    *uri = 0);
        // Decode the specified &#39;object&#39; of parameterized &#39;TYPE&#39; from the
        // specified input &#39;stream&#39;.  Return a reference to the modifiable
        // &#39;stream&#39;.  If a decoding error is detected, &#39;stream.fail()&#39; will be
        // &#39;true&#39; after this method returns.  The (optionally) specified &#39;uri&#39;
        // is used for identifying the input document in error messages.  A
        // compilation error will result unless &#39;TYPE&#39; conforms to the
        // requirements of a &#39;bdlat&#39; sequence or choice, as described in
        // &#39;bdlat_sequencefunctions&#39; and &#39;bdlat_choicefunctions&#39;.

    template &lt;class TYPE&gt;
    int decode(bsl::streambuf *buffer, TYPE *object, const char *uri = 0);
        // Decode the specified &#39;object&#39; of parameterized &#39;TYPE&#39; from the
        // specified stream &#39;buffer&#39;.  The (optionally) specified &#39;uri&#39; is
        // used for identifying the input document in error messages.  Return
        // 0 on success, and a non-zero value otherwise.  A compilation error
        // will result unless &#39;TYPE&#39; conforms to the requirements of a bdlat
        // sequence or choice, as described in &#39;bdlat_sequencefunctions&#39; and
        // &#39;bdlat_choicefunctions&#39;.

    template &lt;class TYPE&gt;
    int decode(const char  *buffer,
               bsl::size_t  length,
               TYPE        *object,
               const char  *uri = 0);
        // Decode the specified &#39;object&#39; of parameterized &#39;TYPE&#39; from the
        // memory at the specified &#39;buffer&#39; address, having the specified
        // &#39;length&#39;.  The (optionally) specified &#39;uri&#39; is used for identifying
        // the input document in error messages.  Return 0 on success, and a
        // non-zero value otherwise.  A compilation error will result unless
        // &#39;TYPE&#39; conforms to the requirements of a bdlat sequence or choice,
        // as described in &#39;bdlat_sequencefunctions&#39; and
        // &#39;bdlat_choicefunctions&#39;.

    template &lt;class TYPE&gt;
    int decode(const char *filename, TYPE *object);
        // Decode the specified &#39;object&#39; of parameterized &#39;TYPE&#39; from the file
        // with the specified &#39;filename&#39;.  Return 0 on success, and a non-zero
        // value otherwise.  A compilation error will result unless &#39;TYPE&#39;
        // conforms to the requirements of a bdlat sequence or choice, as
        // described in &#39;bdlat_sequencefunctions&#39; and &#39;bdlat_choicefunctions&#39;.

    template &lt;class TYPE&gt;
    int decode(TYPE *object);
        // Decode the specified &#39;object&#39; of parameterized &#39;TYPE&#39; from the
        // input source specified by a previous call to &#39;open&#39; and leave the
        // reader in an open state.  Return 0 on success, and a non-zero value
        // otherwise.  A compilation error will result unless &#39;TYPE&#39; conforms
        // to the requirements of a bdlat sequence or choice, as described in
        // &#39;bdlat_sequencefunctions&#39; and &#39;bdlat_choicefunctions&#39;.  The
        // behavior is undefined unless this call was preceded by a prior
        // successful call to &#39;open&#39;

    void setNumUnknownElementsSkipped(int value);
        // Set the number of unknown elements skipped by the decoder during
        // the current decoding operation to the specified &#39;value&#39;.  The
        // behavior is undefined unless &#39;0 &lt;= value&#39;.

    //ACCESSORS
    const DecoderOptions *options() const;
        // Return a pointer to the non-modifiable decoder options provided at
        // construction.

    Reader *reader() const;
        // Return the a pointer to the modifiable reader associated with this
        // decoder (i.e., the &#39;reader&#39; pointer provided at construction).

    ErrorInfo *errorInfo() const;
        // Return a pointer to the modifiable error-reporting structure
        // associated with this decoder (i.e., the &#39;errInfo&#39; pointer provided
        // at construction).  The value stored in the error structure is reset
        // to indicate no error on a successful call to &#39;open&#39;.

    bsl::ostream *errorStream() const;
        // Return pointer to the error stream.

    bsl::ostream *warningStream() const;
        // Return pointer to the warning stream.

    int numUnknownElementsSkipped() const;
        // Return the number of unknown elements that were skipped during the
        // previous decoding operation.  Note that unknown elements are skipped
        // only if &#39;true == options()-&gt;skipUnknownElements()&#39;.

    ErrorInfo::Severity  errorSeverity() const;
        // Return the severity of the most severe warning or error encountered
        // during the last call to the &#39;encode&#39; method.  The severity is reset
        // each time &#39;decode&#39; is called.

    bslstl::StringRef loggedMessages() const;
        // Return a string containing any error, warning, or trace messages
        // that were logged during the last call to the &#39;decode&#39; method.  The
        // log is reset each time &#39;decode&#39; is called.

    int  errorCount() const;
        // Return the number of errors that occurred during decoding.  This
        // number is reset to zero on a call to &#39;open&#39;.

    int  warningCount() const;
        // Return the number of warnings that occurred during decoding.  This
        // number is reset to zero on a call to &#39;open&#39;.
};

                         // =========================
                         // class Decoder_ErrorLogger
                         // =========================

class Decoder_ErrorLogger {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // This class is used for logging errors and warnings.  The usage of this
    // class is simplified with macros, which are defined below.

    // DATA
    Decoder::MemOutStream   d_stream;
    ErrorInfo::Severity     d_severity;    // severity
    Decoder                *d_decoder;     // context

  private:
    // NOT IMPLEMENTED
    Decoder_ErrorLogger(const Decoder_ErrorLogger&amp;);
    Decoder_ErrorLogger&amp; operator=(const Decoder_ErrorLogger&amp;);

  public:
    // CREATORS
    Decoder_ErrorLogger(ErrorInfo::Severity severity, Decoder *decoder)
        // Construct a logger for the specified &#39;decoder&#39;.
    : d_stream(decoder-&gt;d_allocator)
    , d_severity(severity)
    , d_decoder(decoder)
    {
    }

    ~Decoder_ErrorLogger()
        // Set the decoder&#39;s error message to the contents of the message
        // stream.
    {
        d_decoder-&gt;setDecoderError(d_severity,
                                   bslstl::StringRef(d_stream.data(),
                                                     d_stream.length()));
    }

    bsl::ostream&amp; stream()
    {
        return d_stream;
    }
};
}  // close package namespace

// ---  Anything below this line is implementation specific.  Do not use.  ----

// LOGGING MACROS
#define BALXML_DECODER_LOG_ERROR(reporter)                     \
    do {                                                       \
        balxml::Decoder_ErrorLogger                             \
            logger(balxml::ErrorInfo::e_ERROR, reporter);  \
        logger.stream()
    // Usage: BAEXML_LOG_ERROR(myDecoder) &lt;&lt; &quot;Message&quot;
    //                                    &lt;&lt; value &lt;&lt; BALXML_DECODER_LOG_END;

#define BALXML_DECODER_LOG_WARNING(reporter)                   \
    do {                                                       \
        balxml::Decoder_ErrorLogger                             \
           logger(balxml::ErrorInfo::e_WARNING, reporter); \
        logger.stream()
    // Usage: BAEXML_LOG_WARNING(myDecoder) &lt;&lt; &quot;Message&quot;
    //                                      &lt;&lt; value &lt;&lt; BALXML_DECODER_LOG_END;

#define BALXML_DECODER_LOG_END     \
        bsl::flush;                \
    } while (false)
    // See usage of BALXML_DECODER_LOG_ERROR and BALXML_DECODER_LOG_WARNING,
    // above.

// FORWARD DECLARATIONS


namespace balxml {class Decoder_ElementContext;

template &lt;class TYPE&gt;
class Decoder_ChoiceContext;
template &lt;class TYPE&gt;
class Decoder_CustomizedContext;
template &lt;class TYPE, class PARSER&gt;
class Decoder_PushParserContext;
template &lt;class TYPE&gt;
class Decoder_SequenceContext;
template &lt;class TYPE&gt;
class Decoder_SimpleContext;
template &lt;class TYPE&gt;
class Decoder_UTF8Context;

class Decoder_UnknownElementContext;

class Decoder_StdStringContext;      // proxy context
class Decoder_StdVectorCharContext;  // proxy context

                       // ==============================
                       // class Decoder_ListParser&lt;TYPE&gt;
                       // ==============================

template &lt;class TYPE&gt;
class Decoder_ListParser {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // This is a wrapper around &#39;ListParser&lt;TYPE&gt;&#39;.  The
    // &#39;Decoder_PushParserContext&#39; class needs a default constructible push
    // parser.  However, &#39;ListParser&lt;TYPE&gt;&#39; is not default constructible - it
    // requires an &#39;parseElementCallback&#39;.  This wrapper provides a default
    // constructor that passes &#39;TypesParserUtil::parseDefault&#39; as the callback.

    // PRIVATE TYPES
    typedef typename
    ListParser&lt;TYPE&gt;::ParseElementFunction ParseElementFunction;
    typedef typename
    ListParser&lt;TYPE&gt;::ParseElementCallback ParseElementCallback;

    // DATA
    ListParser&lt;TYPE&gt; d_imp;  // implementation object

  private:
    // NOT IMPLEMENTED
    Decoder_ListParser(const Decoder_ListParser&amp;);
    Decoder_ListParser&amp; operator=(const Decoder_ListParser&amp;);

    // COMPILER BUG WORKAROUNDS
    static ParseElementCallback convert(ParseElementFunction func)
        // This function is provided to work around a bug in the AIX compiler.
        // It incorrectly complains that the following constructor initializer
        // list for &#39;d_imp&#39; is invalid:
        //..
        // : d_imp((ParseElementFunction)&amp;TypesParserUtil::parseDefault)
        //..
        // The error message generated by the AIX compiler is:
        //..
        // An object of type &quot;BloombergLP::balxml::ListParser&lt;TYPE&gt;&quot; cannot be
        // constructed from an rvalue of type &quot;ParseElementFunction&quot;.
        //..
        // To work around this, an explicit &#39;convert&#39; function is used to aid
        // the conversion.
    {
        ParseElementCallback temp(func);
        return temp;
    }

  public:
    // CREATORS
    Decoder_ListParser()
    : d_imp(convert(&amp;TypesParserUtil::parseDefault))
    {
    }

    // Using destructor generated by compiler:
    //  ~Decoder_ListParser();

    // MANIPULATORS
    int beginParse(TYPE *object)
    {
        return d_imp.beginParse(object);
    }

    int endParse()
    {
        return d_imp.endParse();
    }

    template &lt;class INPUT_ITERATOR&gt;
    int pushCharacters(INPUT_ITERATOR begin, INPUT_ITERATOR end)
    {
        return d_imp.pushCharacters(begin, end);
    }
};
}  // close package namespace

              // ===============================================
              // struct balxml::Decoder_InstantiateContext&lt;TYPE&gt;
              // ===============================================


namespace balxml {template &lt;class CATEGORY, class TYPE&gt;
struct Decoder_InstantiateContext;
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // This &#39;struct&#39; instantiates a context for the parameterized &#39;TYPE&#39; that
    // falls under the parameterized &#39;CATEGORY&#39;.

template &lt;class TYPE&gt;
struct Decoder_InstantiateContext&lt;bdlat_TypeCategory::Array, TYPE&gt;
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    typedef Decoder_PushParserContext&lt;TYPE, Decoder_ListParser&lt;TYPE&gt; &gt; Type;
};

template &lt;&gt;
struct Decoder_InstantiateContext&lt;bdlat_TypeCategory::Array,
                                      bsl::vector&lt;char&gt; &gt;
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    typedef Decoder_StdVectorCharContext Type;
};

template &lt;class TYPE&gt;
struct Decoder_InstantiateContext&lt;bdlat_TypeCategory::Choice, TYPE&gt;
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    typedef Decoder_ChoiceContext&lt;TYPE&gt; Type;
};

template &lt;class TYPE&gt;
struct Decoder_InstantiateContext&lt;bdlat_TypeCategory::Sequence, TYPE&gt;
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    typedef Decoder_SequenceContext&lt;TYPE&gt; Type;
};

template &lt;class TYPE&gt;
struct Decoder_InstantiateContext&lt;bdlat_TypeCategory::Simple, TYPE&gt;
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    typedef Decoder_SimpleContext&lt;TYPE&gt; Type;
};

template &lt;&gt;
struct
Decoder_InstantiateContext&lt;bdlat_TypeCategory::Simple, bsl::string&gt;
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    typedef Decoder_StdStringContext Type;
};

template &lt;class TYPE&gt;
struct
Decoder_InstantiateContext&lt;bdlat_TypeCategory::CustomizedType, TYPE&gt;
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // Note: Customized are treated as simple types (i.e., they are parsed by
    // &#39;TypesParserUtil&#39;).
    typedef Decoder_CustomizedContext&lt;TYPE&gt; Type;
};

template &lt;class TYPE&gt;
struct Decoder_InstantiateContext&lt;bdlat_TypeCategory::Enumeration, TYPE&gt;
{
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // Note: Enums are treated as simple types (i.e., they are parsed by
    // &#39;TypesParserUtil&#39;).

    typedef Decoder_SimpleContext&lt;TYPE&gt; Type;
};

                     // ==================================
                     // struct Decoder_SelectContext&lt;TYPE&gt;
                     // ==================================

template &lt;class TYPE&gt;
struct Decoder_SelectContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // This meta-function is used to select a context for the parameterized
    // &#39;TYPE&#39;.

  private:
    typedef typename
    bdlat_TypeCategory::Select&lt;TYPE&gt;::Type TypeCategory;

  public:
    typedef typename
    Decoder_InstantiateContext&lt;TypeCategory, TYPE&gt;::Type Type;
};

                     // =================================
                     // class Decoder_ChoiceContext&lt;TYPE&gt;
                     // =================================

template &lt;class TYPE&gt;
class Decoder_ChoiceContext :  public Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // This is the context for types that fall under
    // &#39;bdlat_TypeCategory::Choice&#39;.

    // DATA
    bool         d_isSelectionNameKnown;
    TYPE        *d_object_p;
    bool         d_selectionIsRepeatable;
    bsl::string  d_selectionName;

    // NOT IMPLEMENTED
    Decoder_ChoiceContext(const Decoder_ChoiceContext&amp;);
    Decoder_ChoiceContext &amp;operator=(const Decoder_ChoiceContext &amp;);

  public:
    // CREATORS
    Decoder_ChoiceContext(TYPE *object, int formattingMode);

    // Using compiler generated destructor:
    //  ~Decoder_ChoiceContext();

    // CALLBACKS
    virtual int startElement(Decoder *decoder);

    virtual int endElement(Decoder *decoder);

    virtual int addCharacters(const char   *chars,
                              unsigned int  length,
                              Decoder      *decoder);

    virtual int parseAttribute(const char  *name,
                               const char  *value,
                               bsl::size_t  lenValue,
                               Decoder     *decoder);

    virtual int parseSubElement(const char *elementName, Decoder *decoder);
};

                       // =============================
                       // class Decoder_NillableContext
                       // =============================

class Decoder_NillableContext : public Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // Context for elements that have &#39;bdlat_FormattingMode::e_NILLABLE&#39;.  It
    // acts as a proxy and forwards all callbacks to the held
    // &#39;d_elementContext_p&#39;.  If &#39;endElement&#39; is called directly after
    // &#39;startElement&#39;, then the &#39;isNil()&#39; accessor will return true.

    // DATA
    Decoder_ElementContext *d_elementContext_p;
    bool                    d_isNil;

    // NOT IMPLEMENTED
    Decoder_NillableContext(const Decoder_NillableContext&amp;);
    Decoder_NillableContext &amp;operator=(const Decoder_NillableContext &amp;);

  public:
    // CREATORS
    Decoder_NillableContext();

    ~Decoder_NillableContext();

    // CALLBACKS
    virtual int startElement(Decoder *decoder);

    virtual int endElement(Decoder *decoder);

    virtual int addCharacters(const char   *chars,
                              unsigned int  length,
                              Decoder      *decoder);

    virtual int parseAttribute(const char  *name,
                               const char  *value,
                               bsl::size_t  lenValue,
                               Decoder     *decoder);

    virtual int parseSubElement(const char *elementName, Decoder *decoder);

    // MANIPULATORS
    void setElementContext(Decoder_ElementContext *elementContext);
        // Set the element context to the specified &#39;elementContext&#39;.  The
        // behavior of all methods in this class are undefined if this method
        // has not been called.

    // ACCESSORS
    bool isNil() const;
        // Return &#39;true&#39; if the element is nil.
};

             // ====================================================
             // class Decoder_PushParserContext&lt;TYPE, PARSER&gt;
             // ====================================================

template &lt;class TYPE, class PARSER&gt;
class Decoder_PushParserContext : public Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // Context for types that use one of the following push parsers:
    //..
    //    o Base64Parser
    //    o HexParser
    //    o Decoder_ListParser
    //..

    // DATA
    int     d_formattingMode;
    TYPE   *d_object_p;
    PARSER  d_parser;

    // NOT IMPLEMENTED
    Decoder_PushParserContext(const Decoder_PushParserContext&amp;);
    Decoder_PushParserContext &amp;operator=(const Decoder_PushParserContext &amp;);

  public:
    // CREATORS
    Decoder_PushParserContext(TYPE *object, int formattingMode);

    // Using compiler generated destructor:
    //  ~Decoder_PushParserContext();

    // CALLBACKS
    virtual int startElement(Decoder *decoder);

    virtual int endElement(Decoder *decoder);

    virtual int addCharacters(const char   *chars,
                              unsigned int  length,
                              Decoder      *decoder);

    virtual int parseAttribute(const char  *name,
                               const char  *value,
                               bsl::size_t  lenValue,
                               Decoder     *decoder);

    virtual int parseSubElement(const char *elementName, Decoder *decoder);
};

                    // ===================================
                    // class Decoder_SequenceContext&lt;TYPE&gt;
                    // ===================================

template &lt;class TYPE&gt;
class Decoder_SequenceContext : public Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // Context for types that fall under &#39;bdlat_TypeCategory::Sequence&#39;.

    // DATA
    bdlb::NullableValue&lt;int&gt;  d_simpleContentId;
    TYPE                     *d_object_p;

    // NOT IMPLEMENTED
    Decoder_SequenceContext(const Decoder_SequenceContext&amp;);
    Decoder_SequenceContext &amp;operator=(const Decoder_SequenceContext &amp;);

  public:
    // CREATORS
    Decoder_SequenceContext(TYPE *object, int formattingMode);

    // Using compiler generated destructor:
    //  ~Decoder_SequenceContext();

    // CALLBACKS
    virtual int startElement(Decoder *decoder);

    virtual int endElement(Decoder *decoder);

    virtual int addCharacters(const char   *chars,
                              unsigned int  length,
                              Decoder      *decoder);

    virtual int parseAttribute(const char  *name,
                               const char  *value,
                               bsl::size_t  lenValue,
                               Decoder     *decoder);

    virtual int parseSubElement(const char *elementName, Decoder *decoder);
};

                     // =================================
                     // class Decoder_SimpleContext&lt;TYPE&gt;
                     // =================================

template &lt;class TYPE&gt;
class Decoder_SimpleContext : public Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // Context for simple types (uses TypesParserUtil).

    // DATA
    //bsl::string  d_chars;
    int            d_formattingMode;
    TYPE          *d_object_p;

    // NOT IMPLEMENTED
    Decoder_SimpleContext(const Decoder_SimpleContext&amp;);
    Decoder_SimpleContext &amp;operator=(const Decoder_SimpleContext &amp;);

  public:
    // CREATORS
    Decoder_SimpleContext(TYPE *object, int formattingMode);

    // Using compiler generated destructor:
    //  ~Decoder_SimpleContext();

    // CALLBACKS
    virtual int startElement(Decoder *decoder);

    virtual int endElement(Decoder *decoder);

    virtual int addCharacters(const char   *chars,
                              unsigned int  length,
                              Decoder      *decoder);

    virtual int parseAttribute(const char  *name,
                               const char  *value,
                               bsl::size_t  lenValue,
                               Decoder     *decoder);

    virtual int parseSubElement(const char *elementName, Decoder *decoder);
};

                   // =====================================
                   // class Decoder_CustomizedContext&lt;TYPE&gt;
                   // =====================================

template &lt;class TYPE&gt;
class Decoder_CustomizedContext : public Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // This is the context for types that fall under
    // &#39;bdlat_TypeCategory::Customized&#39;.

    typedef typename
    bdlat_CustomizedTypeFunctions::BaseType&lt;TYPE&gt;::Type         BaseType;

    typedef typename Decoder_InstantiateContext&lt;bdlat_TypeCategory::Simple,
                                                BaseType&gt;::Type BaseContext;
    // DATA
    TYPE       *d_object;
    BaseType    d_baseObj;
    BaseContext d_baseContext;

    // NOT IMPLEMENTED
    Decoder_CustomizedContext(const Decoder_CustomizedContext&amp;);
    Decoder_CustomizedContext &amp;operator=(const Decoder_CustomizedContext &amp;);

  public:
    // CREATORS
    Decoder_CustomizedContext(TYPE *object, int formattingMode);

    // Using compiler generated destructor:
    //  ~Decoder_CustomizedContext();

    // CALLBACKS
    virtual int startElement(Decoder *decoder);

    virtual int endElement(Decoder *decoder);

    virtual int addCharacters(const char   *chars,
                              unsigned int  length,
                              Decoder      *decoder);

    virtual int parseAttribute(const char  *name,
                               const char  *value,
                               bsl::size_t  lenValue,
                               Decoder     *decoder);

    virtual int parseSubElement(const char *elementName, Decoder *decoder);
};

                    // ===================================
                    // class Decoder_UnknownElementContext
                    // ===================================

class Decoder_UnknownElementContext : public Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // Context for unknown elements.  This context is used when an unknown
    // element is found, and the user selected.

  private:
    // NOT IMPLEMENTED
    Decoder_UnknownElementContext(const Decoder_UnknownElementContext &amp;);
    Decoder_UnknownElementContext&amp; operator=(
                                        const Decoder_UnknownElementContext &amp;);

  public:
    // CREATORS
    Decoder_UnknownElementContext();

    // Using compiler generated destructor:
    //  ~Decoder_UnknownElementContext();

    // CALLBACKS
    virtual int startElement(Decoder *decoder);

    virtual int endElement(Decoder *decoder);

    virtual int addCharacters(const char   *chars,
                              unsigned int  length,
                              Decoder      *decoder);

    virtual int parseAttribute(const char  *name,
                               const char  *value,
                               bsl::size_t  lenValue,
                               Decoder     *decoder);

    virtual int parseSubElement(const char *elementName, Decoder *decoder);
};

                         // =========================
                         // class Decoder_UTF8Context
                         // =========================

template &lt;class TYPE&gt;
class Decoder_UTF8Context : public Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // Context for UTF8 strings (i.e., &#39;bsl::string&#39; and &#39;bsl::vector&lt;char&gt;&#39;).

    // DATA
    TYPE *d_object_p;

    // NOT IMPLEMENTED
    Decoder_UTF8Context(const Decoder_UTF8Context&amp;);
    Decoder_UTF8Context&amp; operator=(const Decoder_UTF8Context&amp;);

  public:
    // CREATORS
    Decoder_UTF8Context(TYPE *object, int formattingMode);

    // Generated by compiler:
    //  ~Decoder_UTF8Context();

    // CALLBACKS
    virtual int startElement(Decoder *decoder);

    virtual int endElement(Decoder *decoder);

    virtual int addCharacters(const char   *chars,
                              unsigned int  length,
                              Decoder      *decoder);

    virtual int parseAttribute(const char  *name,
                               const char  *value,
                               bsl::size_t  lenValue,
                               Decoder     *decoder);

    virtual int parseSubElement(const char *elementName, Decoder *decoder);
};

                       // ==============================
                       // class Decoder_StdStringContext
                       // ==============================

class Decoder_StdStringContext : public Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // Proxy context for &#39;bsl::string&#39;.  This is just a proxy context.  It will
    // forward all callbacks to the appropriate context, based on the
    // formatting mode.

  public:
    // TYPES

    // Note that these typedefs need to be made public because Sun compiler
    // complains that they are inaccessible from the union (below).
    typedef Decoder_PushParserContext&lt;bsl::string, Base64Parser&lt;bsl::string&gt; &gt;
                                             Base64Context;
    typedef Decoder_PushParserContext&lt;bsl::string, HexParser&lt;bsl::string&gt; &gt;
                                             HexContext;
    typedef Decoder_UTF8Context&lt;bsl::string&gt; UTF8Context;

  private:
    // DATA
    union {
        bsls::ObjectBuffer&lt;Base64Context&gt; d_base64Context;
        bsls::ObjectBuffer&lt;HexContext&gt;    d_hexContext;
        bsls::ObjectBuffer&lt;UTF8Context&gt;   d_utf8Context;
    };

    Decoder_ElementContext *d_context_p;

    // NOT IMPLEMENTED
    Decoder_StdStringContext(const Decoder_StdStringContext&amp;);
    Decoder_StdStringContext &amp;operator=(const Decoder_StdStringContext &amp;);

  public:
    // CREATORS
    Decoder_StdStringContext(bsl::string *object, int formattingMode);

    virtual ~Decoder_StdStringContext();

    // CALLBACKS
    virtual int startElement(Decoder *decoder);

    virtual int endElement(Decoder *decoder);

    virtual int addCharacters(const char   *chars,
                              unsigned int  length,
                              Decoder      *decoder);

    virtual int parseAttribute(const char  *name,
                               const char  *value,
                               bsl::size_t  lenValue,
                               Decoder     *decoder);

    virtual int parseSubElement(const char *elementName, Decoder *decoder);
};

                     // ==================================
                     // class Decoder_StdVectorCharContext
                     // ==================================

class Decoder_StdVectorCharContext : public Decoder_ElementContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // Proxy context for &#39;bsl::string&#39;.  This is just a proxy context.  It will
    // forward all callbacks to the appropriate context, based on the
    // formatting mode.

  public:
    // TYPES

    // Note that these typedefs need to be made public because Sun compiler
    // complains that they are inaccessible from the union (below).
    typedef Decoder_PushParserContext&lt;bsl::vector&lt;char&gt;,
                                      Base64Parser&lt;bsl::vector&lt;char&gt; &gt; &gt;
                                                    Base64Context;
    typedef Decoder_PushParserContext&lt;bsl::vector&lt;char&gt;,
                                      HexParser&lt;bsl::vector&lt;char&gt; &gt; &gt;
                                                    HexContext;
    typedef Decoder_PushParserContext&lt;bsl::vector&lt;char&gt;,
                                      Decoder_ListParser&lt;bsl::vector&lt;char&gt; &gt; &gt;
                                                    ListContext;
    typedef Decoder_UTF8Context&lt;bsl::vector&lt;char&gt; &gt; UTF8Context;

  private:
    // DATA
    union {
        bsls::ObjectBuffer&lt;Base64Context&gt; d_base64Context;
        bsls::ObjectBuffer&lt;HexContext&gt;    d_hexContext;
        bsls::ObjectBuffer&lt;ListContext&gt;   d_listContext;
        bsls::ObjectBuffer&lt;UTF8Context&gt;   d_utf8Context;
    };

    Decoder_ElementContext *d_context_p;

    // NOT IMPLEMENTED
    Decoder_StdVectorCharContext(const Decoder_StdVectorCharContext &amp;);
    Decoder_StdVectorCharContext&amp; operator=(
                                          const Decoder_StdVectorCharContext&amp;);

  public:
    // CREATORS
    Decoder_StdVectorCharContext(bsl::vector&lt;char&gt; *object,
                                 int                formattingMode);

    virtual ~Decoder_StdVectorCharContext();

    // CALLBACKS
    virtual int startElement(Decoder *decoder);

    virtual int endElement(Decoder *decoder);

    virtual int addCharacters(const char   *chars,
                              unsigned int  length,
                              Decoder      *decoder);

    virtual int parseAttribute(const char  *name,
                               const char  *value,
                               bsl::size_t  lenValue,
                               Decoder     *decoder);

    virtual int parseSubElement(const char *elementName, Decoder *decoder);
};

                    // ====================================
                    // class Decoder_PrepareSequenceContext
                    // ====================================

class Decoder_PrepareSequenceContext {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // This class does one thing:
    //..
    //  o finds an element that has the &#39;IS_SIMPLE_CONTENT&#39; flag set
    //..

    // DATA
    bdlb::NullableValue&lt;int&gt; *d_simpleContentId_p; // held, not owned

    // NOT IMPLEMENTED
    Decoder_PrepareSequenceContext(const Decoder_PrepareSequenceContext &amp;);
    Decoder_PrepareSequenceContext&amp; operator=(
                                        const Decoder_PrepareSequenceContext&amp;);

  public:
    // CREATORS
    Decoder_PrepareSequenceContext(bdlb::NullableValue&lt;int&gt; *simpleContentId);

    // Using compiler generated destructor:
    //  ~Decoder_PrepareSequenceContext();

    // MANIPULATORS
    template &lt;class TYPE, class INFO_TYPE&gt;
    int operator()(const TYPE &amp;object, const INFO_TYPE &amp;info);
};

                  // ========================================
                  // class Decoder_ParseSequenceSimpleContent
                  // ========================================

class Decoder_ParseSequenceSimpleContent {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // Parse simple content.

    // DATA
    //const bsl::string *d_chars_p;  // content characters
    const char          *d_chars_p;  // content characters
    bsl::size_t          d_len;
    Decoder             *d_decoder;  // error logger (held)

    // NOT IMPLEMENTED
    Decoder_ParseSequenceSimpleContent(
                                    const Decoder_ParseSequenceSimpleContent&amp;);
    Decoder_ParseSequenceSimpleContent&amp; operator=(
                                    const Decoder_ParseSequenceSimpleContent&amp;);

  public:
    // CREATORS
    Decoder_ParseSequenceSimpleContent(Decoder     *decoder,
                                       const char  *chars,
                                       bsl::size_t  len);

    // Generated by compiler:
    //  ~Decoder_ParseSequenceSimpleContent();

    // MANIPULATORS
    template &lt;class TYPE, class INFO_TYPE&gt;
    int operator()(TYPE *object, const INFO_TYPE&amp; info);

    template &lt;class INFO_TYPE&gt;
    int operator()(bsl::string *object, const INFO_TYPE&amp; info);
};

                   // =====================================
                   // class Decoder_ParseSequenceSubElement
                   // =====================================

class Decoder_ParseSequenceSubElement {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // This is similar to &#39;Decoder_ParseObject&#39;.

    // DATA
    Decoder     *d_decoder;        // held, not owned
    const char  *d_elementName_p;  // held, not owned
    bsl::size_t  d_lenName;

    // NOT IMPLEMENTED
    Decoder_ParseSequenceSubElement(const Decoder_ParseSequenceSubElement &amp;);
    Decoder_ParseSequenceSubElement&amp; operator=(
                                       const Decoder_ParseSequenceSubElement&amp;);

  public:
    // CREATORS
    Decoder_ParseSequenceSubElement(Decoder     *decoder,
                                    const char  *elementName,
                                    bsl::size_t  lenName);

    // Using compiler-generated destructor:
    //  ~Decoder_ParseSequenceSubElement();

    // MANIPULATORS
    template &lt;class TYPE, class INFO_TYPE&gt;
    int operator()(TYPE *object, const INFO_TYPE &amp;info);

    template &lt;class TYPE&gt;
    int execute(TYPE *object, int id, int formattingMode);
};

                        // ============================
                        // class Decoder_ParseAttribute
                        // ============================

class Decoder_ParseAttribute {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // Parse an attribute.

    // DATA
    Decoder *d_decoder;     // error logger (held)
    bool            d_failed;      // set to true if parsing failed

    const char     *d_name_p;      // attribute name (held)
    const char     *d_value_p;     // attribute value (held)
    bsl::size_t     d_value_length;

  public:
    // IMPLEMENTATION MANIPULATORS
    template &lt;class TYPE&gt;
    int executeImp(TYPE                              *object,
                   int                                formattingMode,
                   bdlat_TypeCategory::NullableValue);
    template &lt;class TYPE&gt;
    int executeImp(TYPE                            *object,
                   int                              formattingMode,
                   bdlat_TypeCategory::DynamicType);
    template &lt;class TYPE, class ANY_CATEGORY&gt;
    int executeImp(TYPE *object, int formattingMode, ANY_CATEGORY);

  private:
    // NOT IMPLEMENTED
    Decoder_ParseAttribute(const Decoder_ParseAttribute&amp;);
    Decoder_ParseAttribute&amp;
    operator=(const Decoder_ParseAttribute&amp;);

  public:
    // CREATORS
    Decoder_ParseAttribute(Decoder     *decoder,
                           const char  *name,
                           const char  *value,
                           bsl::size_t  lengthValue);

    // Generated by compiler:
    //  ~Decoder_ParseAttribute();

    // MANIPULATORS
    template &lt;class TYPE, class INFO_TYPE&gt;
    int operator()(TYPE *object, const INFO_TYPE&amp; info);

    template &lt;class TYPE&gt;
    int execute(TYPE *object, int formattingMode);

    // ACCESSORS
    bool failed() const;
};

                         // =========================
                         // class Decoder_ParseObject
                         // =========================

class Decoder_ParseObject {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.
    //
    // Parse the visited object.

    // PRIVATE TYPES
    struct CanBeListOrRepetition { };
    struct CanBeRepetitionOnly   { };

    // DATA
    Decoder *d_decoder;        // held, not owned
    const char     *d_elementName_p;  // held, not owned
    bsl::size_t     d_lenName;

    // NOT IMPLEMENTED
    Decoder_ParseObject(const Decoder_ParseObject&amp;);
    Decoder_ParseObject&amp; operator=(const Decoder_ParseObject&amp;);

  public:
    // IMPLEMENTATION MANIPULATORS
    int executeImp(bsl::vector&lt;char&gt;         *object,
                   int                        formattingMode,
                   bdlat_TypeCategory::Array);

    template &lt;class TYPE&gt;
    int executeImp(bsl::vector&lt;TYPE&gt;         *object,
                   int                        formattingMode,
                   bdlat_TypeCategory::Array);

    template &lt;class TYPE&gt;
    int executeImp(TYPE                      *object,
                   int                        formattingMode,
                   bdlat_TypeCategory::Array);

    template &lt;class TYPE&gt;
    int executeImp(TYPE                         *object,
                   int                           formattingMode,
                   bdlat_TypeCategory::Sequence);

    template &lt;class TYPE&gt;
    int executeImp(TYPE                       *object,
                   int                         formattingMode,
                   bdlat_TypeCategory::Choice);

    template &lt;class TYPE&gt;
    int executeImp(TYPE                              *object,
                   int                                formattingMode,
                   bdlat_TypeCategory::NullableValue);

    template &lt;class TYPE&gt;
    int executeImp(TYPE                               *object,
                   int                                 formattingMode,
                   bdlat_TypeCategory::CustomizedType);

    template &lt;class TYPE&gt;
    int executeImp(TYPE                            *object,
                   int                              formattingMode,
                   bdlat_TypeCategory::DynamicType);

    template &lt;class TYPE, class ANY_CATEGORY&gt;
    int executeImp(TYPE *object, int formattingMode, ANY_CATEGORY);

    template &lt;class TYPE&gt;
    int executeArrayImp(TYPE                  *object,
                        int                    formattingMode,
                        CanBeListOrRepetition);

    template &lt;class TYPE&gt;
    int executeArrayImp(TYPE *object, int formattingMode, CanBeRepetitionOnly);

    template &lt;class TYPE&gt;
    int executeArrayRepetitionImp(TYPE *object, int formattingMode);

  public:
    // CREATORS
    Decoder_ParseObject(Decoder     *decoder,
                        const char  *elementName,
                        bsl::size_t  lenName);

    // Using compiler-generated destructor:
    //  ~Decoder_ParseObject();

    // MANIPULATORS
    template &lt;class TYPE, class INFO_TYPE&gt;
    int operator()(TYPE *object, const INFO_TYPE &amp;info);

    template &lt;class TYPE&gt;
    int execute(TYPE *object, int formattingMode);
};

                     // =================================
                     // class Decoder_ParseNillableObject
                     // =================================

class Decoder_ParseNillableObject {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.

    // DATA
    int                      d_formattingMode;
    Decoder_NillableContext  d_nillableContext;
    Decoder                 *d_decoder;

  public:
    // IMPLEMENTATION MANIPULATORS
    template &lt;class TYPE&gt;
    int executeImp(TYPE *object, bdlat_TypeCategory::DynamicType);

    template &lt;class TYPE, class ANY_CATEGORY&gt;
    int executeImp(TYPE *object, ANY_CATEGORY);

  private:
    // NOT IMPLEMENTED
    Decoder_ParseNillableObject(const Decoder_ParseNillableObject &amp;);
    Decoder_ParseNillableObject&amp; operator=(const Decoder_ParseNillableObject&amp;);

  public:
    Decoder_ParseNillableObject(Decoder *decoder, int formattingMode);
        // Construct a functor to parse nillable objects.

    // Using compiler-generated destructor:
    //  ~Decoder_ParseNillableObject();

    // MANIPULATORS
    template &lt;class TYPE&gt;
    int operator()(TYPE *object);
        // Visit the specified &#39;object&#39;.

    // ACCESSORS
    bool isNil() const;
        // Return &#39;true&#39; if the value was nil, and false otherwise.
};

// ============================================================================
//                               PROXY CLASSES
// ============================================================================

                       // =============================
                       // struct Decoder_decodeImpProxy
                       // =============================

struct Decoder_decodeImpProxy {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.

    // DATA
    Decoder *d_decoder;

    // CREATORS

    // Creators have been omitted to allow simple static initialization of this
    // struct.

    // FUNCTIONS
    template &lt;class TYPE&gt;
    inline
    int operator()(TYPE *, bslmf::Nil)
    {
        BSLS_ASSERT_SAFE(0);
        return -1;
    }

    template &lt;class TYPE, class ANY_CATEGORY&gt;
    inline
    int operator()(TYPE *object, ANY_CATEGORY category)
    {
        return d_decoder-&gt;decodeImp(object, category);
    }
};

                 // ==========================================
                 // struct Decoder_ParseAttribute_executeProxy
                 // ==========================================

struct Decoder_ParseAttribute_executeProxy {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.

    // DATA
    Decoder_ParseAttribute *d_instance_p;
    int                     d_formattingMode;

    // CREATORS

    // Creators have been omitted to allow simple static initialization of this
    // struct.

    // FUNCTIONS
    template &lt;class TYPE&gt;
    inline
    int operator()(TYPE *object)
    {
        return d_instance_p-&gt;execute(object, d_formattingMode);
    }
};

               // =============================================
               // struct Decoder_ParseAttribute_executeImpProxy
               // =============================================

struct Decoder_ParseAttribute_executeImpProxy {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.

    // DATA
    Decoder_ParseAttribute *d_instance_p;
    int                     d_formattingMode;

    // CREATORS

    // Creators have been omitted to allow simple static initialization of this
    // struct.

    // FUNCTIONS
    template &lt;class TYPE&gt;
    inline
    int operator()(TYPE *, bslmf::Nil)
    {
        BSLS_ASSERT_SAFE(0);
        return -1;
    }

    template &lt;class TYPE, class ANY_CATEGORY&gt;
    inline
    int operator()(TYPE *object, ANY_CATEGORY category)
    {
        return d_instance_p-&gt;executeImp(object, d_formattingMode, category);
    }
};

                  // =======================================
                  // struct Decoder_ParseObject_executeProxy
                  // =======================================

struct Decoder_ParseObject_executeProxy {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.

    // DATA
    Decoder_ParseObject *d_instance_p;
    int                  d_formattingMode;

    // CREATORS

    // Creators have been omitted to allow simple static initialization of this
    // struct.

    // FUNCTIONS
    template &lt;class TYPE&gt;
    inline
    int operator()(TYPE *object)
    {
        return d_instance_p-&gt;execute(object, d_formattingMode);
    }
};

                 // ==========================================
                 // struct Decoder_ParseObject_executeImpProxy
                 // ==========================================

struct Decoder_ParseObject_executeImpProxy {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.

    // DATA
    Decoder_ParseObject *d_instance_p;
    int                  d_formattingMode;

    // CREATORS

    // Creators have been omitted to allow simple static initialization of this
    // struct.

    // FUNCTIONS
    template &lt;class TYPE&gt;
    inline
    int operator()(TYPE *, bslmf::Nil)
    {
        BSLS_ASSERT_SAFE(0);
        return -1;
    }

    template &lt;class TYPE, class ANY_CATEGORY&gt;
    inline
    int operator()(TYPE *object, ANY_CATEGORY category)
    {
        return d_instance_p-&gt;executeImp(object, d_formattingMode, category);
    }
};

             // ==================================================
             // struct Decoder_ParseNillableObject_executeImpProxy
             // ==================================================

struct Decoder_ParseNillableObject_executeImpProxy {
    // COMPONENT-PRIVATE CLASS.  DO NOT USE OUTSIDE OF THIS COMPONENT.

    // DATA
    Decoder_ParseNillableObject *d_instance_p;

    // CREATORS

    // Creators have been omitted to allow simple static initialization of this
    // struct.

    // FUNCTIONS
    template &lt;class TYPE&gt;
    inline
    int operator()(TYPE *, bslmf::Nil)
    {
        BSLS_ASSERT_SAFE(0);
        return -1;
    }

    template &lt;class TYPE, class ANY_CATEGORY&gt;
    inline
    int operator()(TYPE *object, ANY_CATEGORY category)
    {
        return d_instance_p-&gt;executeImp(object, category);
    }
};
}  // close package namespace

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                    // -----------------------------------
                    // class balxml::Decoder::MemOutStream
                    // -----------------------------------

inline
balxml::Decoder::MemOutStream::MemOutStream(bslma::Allocator *basicAllocator)
: bsl::ostream(0)
, d_sb(bslma::Default::allocator(basicAllocator))
{
    rdbuf(&amp;d_sb);
}

// MANIPULATORS
inline
void balxml::Decoder::MemOutStream::reset()
{
    d_sb.reset();
}

// ACCESSORS
inline
const char *balxml::Decoder::MemOutStream::data() const
{
    return d_sb.data();
}

inline
int balxml::Decoder::MemOutStream::length() const
{
    return (int)d_sb.length();
}

namespace balxml {
inline
void Decoder::setNumUnknownElementsSkipped(int value)
{
    BSLS_ASSERT_SAFE(0 &lt;= value);

    d_numUnknownElementsSkipped = value;
}

                               // -------------
                               // class Decoder
                               // -------------

inline
const DecoderOptions *Decoder::options() const
{
    return d_options;
}

inline
Reader *Decoder::reader() const
{
    return d_reader;
}

inline
ErrorInfo *Decoder::errorInfo() const
{
    return d_errorInfo;
}

inline
bsl::ostream *Decoder::errorStream() const
{
    return d_errorStream;
}

inline
int Decoder::numUnknownElementsSkipped() const
{
    return d_numUnknownElementsSkipped;
}

inline
bsl::ostream *Decoder::warningStream() const
{
    return d_warningStream;
}

inline
int Decoder::errorCount() const
{
    return d_errorCount;
}

inline
int Decoder::warningCount() const
{
    return d_warningCount;
}

inline
int Decoder::open(bsl::istream&amp; stream, const char *uri)
{
    return open(stream.rdbuf(), uri);
}

template &lt;class TYPE&gt;
bsl::istream&amp; Decoder::decode(bsl::istream&amp;  stream,
                              TYPE          *object,
                              const char    *uri)
{
    if (!stream.good()) {

        BALXML_DECODER_LOG_ERROR(this)
                &lt;&lt; &quot;The input stream is invalid. &quot;
                &lt;&lt; &quot;Unable to decode XML object. &quot;
                &lt;&lt; BALXML_DECODER_LOG_END;

        return stream;                                                // RETURN
    }

    if (0 != this-&gt;decode(stream.rdbuf(), object, uri)) {
        stream.setstate(bsl::ios_base::failbit);
    }

    return stream;
}

template &lt;class TYPE&gt;
int
Decoder::decode(bsl::streambuf *buffer, TYPE *object, const char *uri)
{
    if (this-&gt;open(buffer, uri) != 0) {

        return this-&gt;errorCount();                                    // RETURN

    }

    int ret = this-&gt;decode(object);

    switch(errorSeverity()) {
      case ErrorInfo::e_NO_ERROR:
        break;
      case ErrorInfo::e_WARNING:
        if (d_warningStream) {
            *d_warningStream &lt;&lt; loggedMessages();
        }
        break;
      default:
        if (d_errorStream) {
            *d_errorStream &lt;&lt; loggedMessages();
        }
        break;
    }

    this-&gt;close();
    return ret;
}

template &lt;class TYPE&gt;
int Decoder::decode(const char  *buffer,
                    bsl::size_t  buflen,
                    TYPE        *object,
                    const char  *uri)
{
    if (this-&gt;open(buffer, buflen, uri) != 0) {

        return this-&gt;errorCount();                                    // RETURN
    }

    int ret = this-&gt;decode(object);
    this-&gt;close();
    return ret;
}

template &lt;class TYPE&gt;
int Decoder::decode(const char *filename, TYPE *object)
{
    if (this-&gt;open(filename) != 0) {

        return this-&gt;errorCount();                                    // RETURN
    }

    int ret = this-&gt;decode(object);
    this-&gt;close();
    return ret;
}

template &lt;class TYPE&gt;
inline
int Decoder::decode(TYPE *object)
{
    bdlat_ValueTypeFunctions::reset(object);

    typedef typename
    bdlat_TypeCategory::Select&lt;TYPE&gt;::Type TypeCategory;

    this-&gt;decodeImp(object, TypeCategory());

    return this-&gt;errorCount();
}

template &lt;class TYPE&gt;
inline
int Decoder::decodeImp(TYPE *object, bdlat_TypeCategory::DynamicType)
{
    Decoder_decodeImpProxy proxy = { this };
    return bdlat_TypeCategoryUtil::manipulateByCategory(object, proxy);
}

template &lt;class TYPE, class ANY_CATEGORY&gt;
inline
int Decoder::decodeImp(TYPE *object, ANY_CATEGORY)
{
    typedef typename
    Decoder_InstantiateContext&lt;ANY_CATEGORY, TYPE&gt;::Type ContextType;

    ContextType elementContext(object, d_options-&gt;formattingMode());

    return elementContext.beginParse(this);
}

                     // ---------------------------------
                     // class Decoder_ChoiceContext&lt;TYPE&gt;
                     // ---------------------------------

template &lt;class TYPE&gt;
inline
Decoder_ChoiceContext&lt;TYPE&gt;::Decoder_ChoiceContext(TYPE *object,
                                                   int   formattingMode)
: d_isSelectionNameKnown(false)
, d_object_p(object)
, d_selectionIsRepeatable(false)
, d_selectionName()
{
    (void) formattingMode;
    BSLS_ASSERT_SAFE(bdlat_FormattingMode::e_DEFAULT ==
                     (formattingMode &amp; bdlat_FormattingMode::e_TYPE_MASK));
}

// CALLBACKS

template &lt;class TYPE&gt;
int Decoder_ChoiceContext&lt;TYPE&gt;::startElement(Decoder *)
{
    enum { k_SUCCESS = 0 };

    d_isSelectionNameKnown = false;  // no selection seen yet

    return k_SUCCESS;
}

template &lt;class TYPE&gt;
int Decoder_ChoiceContext&lt;TYPE&gt;::endElement(Decoder *decoder)
{
    enum { k_SUCCESS = 0, k_FAILURE = -1 };

    if (!d_isSelectionNameKnown) {
        BALXML_DECODER_LOG_ERROR(decoder)
                 &lt;&lt; &quot;No elements selected in choice.&quot;
                 &lt;&lt; BALXML_DECODER_LOG_END;

        return k_FAILURE;  // will trigger failure in parser          // RETURN
    }

    return k_SUCCESS;
}

template &lt;class TYPE&gt;
int Decoder_ChoiceContext&lt;TYPE&gt;::addCharacters(const char   *chars,
                                               unsigned int  length,
                                               Decoder      *decoder)
{
    enum { k_SUCCESS = 0, k_FAILURE = -1 };

    BSLS_ASSERT_SAFE(0 != length);

    const char *begin = chars;
    const char *end   = begin + length;

    bdlb::String::skipLeadingTrailing(&amp;begin, &amp;end);

    if (begin != end) {
        BALXML_DECODER_LOG_ERROR(decoder)
                         &lt;&lt; &quot;Invalid characters \&quot;&quot;
                         &lt;&lt; bsl::string(begin, end - begin)
                         &lt;&lt; &quot;\&quot; when parsing choice.&quot;
                         &lt;&lt; BALXML_DECODER_LOG_END;

        return k_FAILURE;  // will trigger failure in parser          // RETURN
    }

    return k_SUCCESS;
}

template &lt;class TYPE&gt;
inline
int Decoder_ChoiceContext&lt;TYPE&gt;::parseAttribute(const char *,
                                                const char *,
                                                bsl::size_t,
                                                Decoder *)
{
    enum { k_ATTRIBUTE_IGNORED = 0 };

    return k_ATTRIBUTE_IGNORED;
}

template &lt;class TYPE&gt;
int Decoder_ChoiceContext&lt;TYPE&gt;::parseSubElement(const char *elementName,
                                                 Decoder    *decoder)
{
    enum { k_FAILURE = -1 };

    const int lenName = static_cast&lt;int&gt;(bsl::strlen(elementName));

    if (d_isSelectionNameKnown
     &amp;&amp; (!d_selectionIsRepeatable || d_selectionName != elementName))
    {
        BALXML_DECODER_LOG_ERROR(decoder)
                            &lt;&lt; &quot;Only one selection is permitted inside choice.&quot;
                            &lt;&lt; BALXML_DECODER_LOG_END;

        return k_FAILURE;                                             // RETURN
    }

    bool wasSelectionNameKnown = d_isSelectionNameKnown;
    d_isSelectionNameKnown = true;

    if (decoder-&gt;options()-&gt;skipUnknownElements() &amp;&amp;
        false == bdlat_ChoiceFunctions::hasSelection(*d_object_p,
                                                     elementName,
                                                     lenName)) {
        decoder-&gt;setNumUnknownElementsSkipped(
                                     decoder-&gt;numUnknownElementsSkipped() + 1);
        d_selectionIsRepeatable = true;  // assume repeatable
        d_selectionName.assign(elementName, lenName);

        Decoder_UnknownElementContext unknownElement;
        return unknownElement.beginParse(decoder);                    // RETURN
    }

    if (!wasSelectionNameKnown) {
        if (0 != bdlat_ChoiceFunctions::makeSelection(d_object_p,
                                                      elementName,
                                                      lenName)) {
            BALXML_DECODER_LOG_ERROR(decoder)
                                              &lt;&lt; &quot;Unable to make selection: \&quot;&quot;
                                              &lt;&lt; elementName
                                              &lt;&lt; &quot;\&quot;.&quot;
                                              &lt;&lt; BALXML_DECODER_LOG_END;

            return k_FAILURE;                                         // RETURN
        }

        d_selectionIsRepeatable = true;  // TBD: check if repeatable
        d_selectionName.assign(elementName, lenName);
    }

    Decoder_ParseObject parseObject(decoder, elementName, lenName);
    return bdlat_ChoiceFunctions::manipulateSelection(d_object_p, parseObject);
}

             // ----------------------------------------------------
             // class Decoder_PushParserContext&lt;TYPE, PARSER&gt;
             // ----------------------------------------------------

// CREATORS
template &lt;class TYPE, class PARSER&gt;
inline
Decoder_PushParserContext&lt;TYPE, PARSER&gt;::Decoder_PushParserContext(
                                                          TYPE *object,
                                                          int   formattingMode)
: d_formattingMode(formattingMode), d_object_p(object)
{
}

// CALLBACKS

template &lt;class TYPE, class PARSER&gt;
int Decoder_PushParserContext&lt;TYPE, PARSER&gt;::startElement(Decoder *decoder)
{
    int result = d_parser.beginParse(d_object_p);

    if (0 != result) {
        BALXML_DECODER_LOG_ERROR(decoder)
                    &lt;&lt; &quot;Unable to begin parsing list or binary type&quot;

                    &lt;&lt; &quot;\&quot;.&quot;
                    &lt;&lt; BALXML_DECODER_LOG_END;
    }

    return result;
}

template &lt;class TYPE, class PARSER&gt;
int Decoder_PushParserContext&lt;TYPE, PARSER&gt;::endElement(Decoder *decoder)
{
    int result = d_parser.endParse();

    if (0 != result) {
        BALXML_DECODER_LOG_ERROR(decoder)
                    &lt;&lt; &quot;Unable to end parsing list or binary type&quot;
                    &lt;&lt; &quot;\&quot;.&quot;
                    &lt;&lt; BALXML_DECODER_LOG_END;
    }

    return result;
}

template &lt;class TYPE, class PARSER&gt;
int Decoder_PushParserContext&lt;TYPE, PARSER&gt;::addCharacters(
                                                         const char   *chars,
                                                         unsigned int  length,
                                                         Decoder      *decoder)
{
    const char *begin = chars;
    const char *end   = begin + length;

    int result = d_parser.pushCharacters(begin, end);

    if (0 != result) {
        BALXML_DECODER_LOG_ERROR(decoder)
              &lt;&lt; &quot;Unable to push \&quot;&quot; &lt;&lt; chars
              &lt;&lt; &quot;\&quot; when parsing list or binary type&quot;

              &lt;&lt; &quot;\&quot;.&quot;
              &lt;&lt; BALXML_DECODER_LOG_END;
    }

    return result;
}

template &lt;class TYPE, class PARSER&gt;
inline
int Decoder_PushParserContext&lt;TYPE, PARSER&gt;::parseAttribute(const char *,
                                                            const char *,
                                                            bsl::size_t,
                                                            Decoder *)
{
    enum { k_ATTRIBUTE_IGNORED = 0 };

    return k_ATTRIBUTE_IGNORED;
}

template &lt;class TYPE, class PARSER&gt;
int Decoder_PushParserContext&lt;TYPE, PARSER&gt;::parseSubElement(
                                                       const char *elementName,
                                                       Decoder    *decoder)
{
    enum { k_FAILURE = -1 };

    BALXML_DECODER_LOG_ERROR(decoder)
                  &lt;&lt; &quot;Unexpected sub-element \&quot;&quot; &lt;&lt; elementName
                  &lt;&lt; &quot;\&quot; when parsing list or binary type&quot;
                  &lt;&lt; &quot;\&quot;.&quot;
                  &lt;&lt; BALXML_DECODER_LOG_END;

    return k_FAILURE;
}

                    // -----------------------------------
                    // class Decoder_SequenceContext&lt;TYPE&gt;
                    // -----------------------------------

// CREATORS
template &lt;class TYPE&gt;
inline
Decoder_SequenceContext&lt;TYPE&gt;::Decoder_SequenceContext(TYPE *object,
                                                       int   formattingMode)
: d_object_p(object)
{
    (void) formattingMode;
    BSLS_ASSERT_SAFE(bdlat_FormattingMode::e_DEFAULT ==
                     (formattingMode &amp; bdlat_FormattingMode::e_TYPE_MASK));
}

// CALLBACKS

template &lt;class TYPE&gt;
int Decoder_SequenceContext&lt;TYPE&gt;::startElement(Decoder *decoder)
{
    //d_chars.clear();

    Decoder_PrepareSequenceContext prepareSequenceContext(&amp;d_simpleContentId);

    int ret = bdlat_SequenceFunctions::manipulateAttributes(
                                                       d_object_p,
                                                       prepareSequenceContext);

    if (0 != ret) {
        BALXML_DECODER_LOG_ERROR(decoder)
                                       &lt;&lt; &quot;Unable to prepare sequence context!&quot;
                                       &lt;&lt; BALXML_DECODER_LOG_END;
    }

    return ret;
}

template &lt;class TYPE&gt;
int Decoder_SequenceContext&lt;TYPE&gt;::endElement(Decoder *)
{
    enum { k_SUCCESS = 0 };

    return k_SUCCESS;
}

template &lt;class TYPE&gt;
int Decoder_SequenceContext&lt;TYPE&gt;::addCharacters(const char   *chars,
                                                 unsigned int  length,
                                                 Decoder      *decoder)
{
    enum { k_SUCCESS = 0, k_FAILURE = -1 };

    BSLS_ASSERT_SAFE(0 != length);

    if (d_simpleContentId.isNull()) {

        const char *begin = chars;
        const char *end   = begin + length;

        bdlb::String::skipLeadingTrailing(&amp;begin, &amp;end);

        if (begin != end) {
            BALXML_DECODER_LOG_ERROR(decoder)
                                             &lt;&lt; &quot;Unexpected characters: \&quot;&quot;
                                             &lt;&lt; bsl::string(begin, end - begin)
                                             &lt;&lt; &quot;\&quot;.&quot;
                                             &lt;&lt; BALXML_DECODER_LOG_END;

            return k_FAILURE;                                         // RETURN
        }
        return k_SUCCESS;                                             // RETURN
    }

    Decoder_ParseSequenceSimpleContent parseSimpleContent(decoder,
                                                          chars,
                                                          length);

    return bdlat_SequenceFunctions::manipulateAttribute(
                                                    d_object_p,
                                                    parseSimpleContent,
                                                    d_simpleContentId.value());
}

template &lt;class TYPE&gt;
int Decoder_SequenceContext&lt;TYPE&gt;::parseAttribute(const char  *name,
                                                  const char  *value,
                                                  bsl::size_t  lenValue,
                                                  Decoder     *decoder)
{
    enum { k_SUCCESS = 0, k_ATTRIBUTE_IGNORED = 0, k_FAILURE = -1 };

    const int lenName = static_cast&lt;int&gt;(bsl::strlen(name));

    Decoder_ParseAttribute visitor(decoder, name, value, lenValue);

    if (0 != bdlat_SequenceFunctions::manipulateAttribute(d_object_p,
                                                          visitor,
                                                          name,
                                                          lenName)) {
        if (visitor.failed()) {
            return k_FAILURE;                                         // RETURN
        }
        return k_ATTRIBUTE_IGNORED;                                   // RETURN
    }

    return k_SUCCESS;
}

template &lt;class TYPE&gt;
int Decoder_SequenceContext&lt;TYPE&gt;::parseSubElement(const char *elementName,
                                                   Decoder    *decoder)
{
    enum { k_FAILURE = -1 };

    const int lenName = static_cast&lt;int&gt;(bsl::strlen(elementName));

    if (decoder-&gt;options()-&gt;skipUnknownElements()
     &amp;&amp; false == bdlat_SequenceFunctions::hasAttribute(*d_object_p,
                                                       elementName,
                                                       lenName)) {
        decoder-&gt;setNumUnknownElementsSkipped(
                                     decoder-&gt;numUnknownElementsSkipped() + 1);
        Decoder_UnknownElementContext unknownElement;
        return unknownElement.beginParse(decoder);                    // RETURN
    }

    Decoder_ParseSequenceSubElement visitor(decoder, elementName, lenName);

    return bdlat_SequenceFunctions::manipulateAttribute(d_object_p,
                                                        visitor,
                                                        elementName,
                                                        lenName);
}

                     // ---------------------------------
                     // class Decoder_SimpleContext&lt;TYPE&gt;
                     // ---------------------------------

// CREATORS
template &lt;class TYPE&gt;
inline
Decoder_SimpleContext&lt;TYPE&gt;::Decoder_SimpleContext(TYPE *object,
                                                   int   formattingMode)
: d_formattingMode(formattingMode)
, d_object_p(object)
{
}

// CALLBACKS

template &lt;class TYPE&gt;
int Decoder_SimpleContext&lt;TYPE&gt;::startElement(Decoder *)
{
    enum { k_SUCCESS = 0 };

    //d_chars.clear();

    return k_SUCCESS;
}

template &lt;class TYPE&gt;
int Decoder_SimpleContext&lt;TYPE&gt;::endElement(Decoder *)
{
    enum { k_SUCCESS = 0, k_FAILURE = -1 };

    return k_SUCCESS;
}

template &lt;class TYPE&gt;
int Decoder_SimpleContext&lt;TYPE&gt;::addCharacters(const char   *chars,
                                               unsigned int  length,
                                               Decoder      *decoder)
{
    enum { k_SUCCESS = 0, k_FAILURE = -1 };

    const char *begin = chars;
    const char *end   = begin + length;

    bdlb::String::skipLeadingTrailing(&amp;begin, &amp;end);

    if (0 != TypesParserUtil::parse(d_object_p,
                                    begin,
                                    static_cast&lt;int&gt;(end - begin),
                                    d_formattingMode)) {
        BALXML_DECODER_LOG_ERROR(decoder)
                    &lt;&lt; &quot;Unable to parse \&quot;&quot;
                    &lt;&lt; bsl::string(begin, end)
                    &lt;&lt; &quot;\&quot; when parsing list or binary type&quot;
                    &lt;&lt; &quot;\&quot;.\n&quot;
                    &lt;&lt; BALXML_DECODER_LOG_END;

        return k_FAILURE;                                             // RETURN
    }

    return k_SUCCESS;
}

template &lt;class TYPE&gt;
inline
int Decoder_SimpleContext&lt;TYPE&gt;::parseAttribute(const char *,
                                                const char *,
                                                bsl::size_t,
                                                Decoder *)
{
    enum { k_ATTRIBUTE_IGNORED = 0 };

    return k_ATTRIBUTE_IGNORED;
}

template &lt;class TYPE&gt;
int Decoder_SimpleContext&lt;TYPE&gt;::parseSubElement(const char *elementName,
                                                 Decoder    *decoder)
{
    enum { k_FAILURE = -1 };

    BALXML_DECODER_LOG_ERROR(decoder)
               &lt;&lt; &quot;Attempted to create sub context for \&quot;&quot;
               &lt;&lt; elementName &lt;&lt; &quot;\&quot; inside simple type&quot;

               &lt;&lt; &quot;\&quot;.&quot;
               &lt;&lt; BALXML_DECODER_LOG_END;

    return k_FAILURE;  // will trigger failure in parser
}

                   // -------------------------------------
                   // class Decoder_CustomizedContext&lt;TYPE&gt;
                   // -------------------------------------

// CREATORS
template &lt;class TYPE&gt;
inline
Decoder_CustomizedContext&lt;TYPE&gt;::Decoder_CustomizedContext(
                                                          TYPE *object,
                                                          int   formattingMode)
: d_object (object)
, d_baseObj()
, d_baseContext(&amp;d_baseObj, formattingMode)
{
}

// CALLBACKS

template &lt;class TYPE&gt;
int Decoder_CustomizedContext&lt;TYPE&gt;::startElement(Decoder *decoder)
{
    return d_baseContext.startElement (decoder);
}

template &lt;class TYPE&gt;
int Decoder_CustomizedContext&lt;TYPE&gt;::endElement(Decoder *decoder)
{
    enum { k_SUCCESS = 0, k_FAILURE = -1 };
    int rc = d_baseContext.endElement(decoder);
    if (rc == k_SUCCESS
     &amp;&amp;  0 == bdlat_CustomizedTypeFunctions::convertFromBaseType(d_object,
                                                                 d_baseObj)) {
        return k_SUCCESS;                                             // RETURN
    }

    return k_FAILURE;
}

template &lt;class TYPE&gt;
int Decoder_CustomizedContext&lt;TYPE&gt;::addCharacters(const char   *chars,
                                                   unsigned int  length,
                                                   Decoder      *decoder)
{
    return d_baseContext.addCharacters(chars, length, decoder);
}

template &lt;class TYPE&gt;
int Decoder_CustomizedContext&lt;TYPE&gt;::parseAttribute(const char  *name,
                                                    const char  *value,
                                                    bsl::size_t  lenValue,
                                                    Decoder     *decoder)
{
    return d_baseContext.parseAttribute(name, value, lenValue, decoder);
}

template &lt;class TYPE&gt;
int Decoder_CustomizedContext&lt;TYPE&gt;::parseSubElement(const char *elementName,
                                                     Decoder    *decoder)
{
    return d_baseContext.parseSubElement(elementName, decoder);
}

                         // -------------------------
                         // class Decoder_UTF8Context
                         // -------------------------

// CREATORS
template &lt;class TYPE&gt;
inline
Decoder_UTF8Context&lt;TYPE&gt;::Decoder_UTF8Context(TYPE *object, int)
: d_object_p(object)
{
}

// CALLBACKS

template &lt;class TYPE&gt;
inline
int Decoder_UTF8Context&lt;TYPE&gt;::startElement(Decoder *)
{
    enum { k_SUCCESS = 0 };

    d_object_p-&gt;clear();

    return k_SUCCESS;
}

template &lt;class TYPE&gt;
inline
int Decoder_UTF8Context&lt;TYPE&gt;::endElement(Decoder *)
{
    enum { k_SUCCESS = 0 };

    return k_SUCCESS;
}

template &lt;class TYPE&gt;
inline int
Decoder_UTF8Context&lt;TYPE&gt;::addCharacters(const char   *chars,
                                         unsigned int  length,
                                         Decoder      *)
{
    enum { k_SUCCESS = 0 };

    d_object_p-&gt;insert(d_object_p-&gt;end(), chars, chars + length);

    return k_SUCCESS;
}

template &lt;class TYPE&gt;
inline
int Decoder_UTF8Context&lt;TYPE&gt;::parseAttribute(const char *,
                                              const char *,
                                              bsl::size_t,
                                              Decoder *)
{
    enum { k_ATTRIBUTE_IGNORED = 0 };

    return k_ATTRIBUTE_IGNORED;
}

template &lt;class TYPE&gt;
int Decoder_UTF8Context&lt;TYPE&gt;::parseSubElement(const char *elementName,
                                               Decoder    *decoder)
{
    enum { k_FAILURE = -1 };

    BALXML_DECODER_LOG_ERROR(decoder)
                                    &lt;&lt; &quot;Attempted to create sub context for \&quot;&quot;
                                    &lt;&lt; elementName &lt;&lt; &quot;\&quot; inside UTF8 type.&quot;
                                    &lt;&lt; BALXML_DECODER_LOG_END;

    return k_FAILURE;  // will trigger failure in parser
}

                    // ------------------------------------
                    // class Decoder_PrepareSequenceContext
                    // ------------------------------------

// CREATORS
inline
Decoder_PrepareSequenceContext::Decoder_PrepareSequenceContext(
                                     bdlb::NullableValue&lt;int&gt; *simpleContentId)
: d_simpleContentId_p(simpleContentId)
{
    d_simpleContentId_p-&gt;reset();
}

// MANIPULATORS
template &lt;class TYPE, class INFO_TYPE&gt;
int Decoder_PrepareSequenceContext::operator()(const TYPE&amp;,
                                               const INFO_TYPE&amp; info)
{
    enum { k_SUCCESS = 0 };

    if (info.formattingMode() &amp; bdlat_FormattingMode::e_SIMPLE_CONTENT) {
        BSLS_ASSERT_SAFE(d_simpleContentId_p-&gt;isNull());
        d_simpleContentId_p-&gt;makeValue(info.id());
    }

    return k_SUCCESS;
}

                  // ----------------------------------------
                  // class Decoder_ParseSequenceSimpleContent
                  // ----------------------------------------

// CREATORS
inline
Decoder_ParseSequenceSimpleContent::Decoder_ParseSequenceSimpleContent(
                                                          Decoder     *decoder,
                                                          const char  *chars,
                                                          bsl::size_t  len)
: d_chars_p(chars), d_len(len), d_decoder(decoder)
{
    BSLS_ASSERT_SAFE(d_chars_p);
    BSLS_ASSERT_SAFE(d_decoder);
}

// MANIPULATORS
template &lt;class TYPE, class INFO_TYPE&gt;
int Decoder_ParseSequenceSimpleContent::operator()(TYPE             *object,
                                                   const INFO_TYPE&amp;  info)
{
    BSLS_ASSERT_SAFE(info.formattingMode()
                                 &amp; bdlat_FormattingMode::e_SIMPLE_CONTENT);

    enum { k_SUCCESS = 0, k_FAILURE = -1 };

    const char *begin = d_chars_p;
    const char *end   = begin + d_len;

    bdlb::String::skipLeadingTrailing(&amp;begin, &amp;end);

    if (0 != TypesParserUtil::parse(object,
                                    begin,
                                    static_cast&lt;int&gt;(end - begin),
                                    info.formattingMode())) {
        BALXML_DECODER_LOG_ERROR(d_decoder)
               &lt;&lt; &quot;Unable to parse \&quot;&quot;
               &lt;&lt; bsl::string(begin, end)
               &lt;&lt; &quot;\&quot; within simple content&quot;

               &lt;&lt; &quot;\&quot;.&quot;
               &lt;&lt; BALXML_DECODER_LOG_END;

        return k_FAILURE;                                             // RETURN
    }

    return k_SUCCESS;
}

template &lt;class INFO_TYPE&gt;
inline
int Decoder_ParseSequenceSimpleContent::operator()(bsl::string      *object,
                                                   const INFO_TYPE&amp;  info)
{
    enum { k_SUCCESS = 0 };

    BSLS_ASSERT_SAFE(info.formattingMode()
                   &amp; bdlat_FormattingMode::e_SIMPLE_CONTENT);

    (void) info;

    object-&gt;assign(d_chars_p, d_len);

    return k_SUCCESS;
}

                   // -------------------------------------
                   // class Decoder_ParseSequenceSubElement
                   // -------------------------------------

// CREATORS
inline
Decoder_ParseSequenceSubElement::Decoder_ParseSequenceSubElement(
                                                      Decoder     *decoder,
                                                      const char  *elementName,
                                                      bsl::size_t  lenName)
: d_decoder(decoder), d_elementName_p(elementName), d_lenName(lenName)
{
}

// MANIPULATORS
template &lt;class TYPE, class INFO_TYPE&gt;
inline
int Decoder_ParseSequenceSubElement::operator()(TYPE             *object,
                                                const INFO_TYPE&amp;  info)
{
    return execute(object, info.id(), info.formattingMode());
}

template &lt;class TYPE&gt;
int Decoder_ParseSequenceSubElement::execute(TYPE *object,
                                             int,
                                             int   formattingMode)
{
    enum { k_FAILURE = -1 };
    Decoder_ParseObject parseObject(d_decoder, d_elementName_p, d_lenName);

    return parseObject.execute(object, formattingMode);
}

                        // ----------------------------
                        // class Decoder_ParseAttribute
                        // ----------------------------

// PRIVATE MANIPULATORS
template &lt;class TYPE&gt;
int Decoder_ParseAttribute::executeImp(
                             TYPE                              *object,
                             int                                formattingMode,
                             bdlat_TypeCategory::NullableValue)
{
    if (bdlat_NullableValueFunctions::isNull(*object)) {
        bdlat_NullableValueFunctions::makeValue(object);
    }

    Decoder_ParseAttribute_executeProxy proxy = {
        this, formattingMode
    };

    return bdlat_NullableValueFunctions::manipulateValue(object, proxy);
}

template &lt;class TYPE&gt;
inline
int Decoder_ParseAttribute::executeImp(
                               TYPE                            *object,
                               int                              formattingMode,
                               bdlat_TypeCategory::DynamicType)
{
    Decoder_ParseAttribute_executeImpProxy proxy = { this,
                                                         formattingMode };
    return bdlat_TypeCategoryUtil::manipulateByCategory(object, proxy);
}

template &lt;class TYPE, class ANY_CATEGORY&gt;
int Decoder_ParseAttribute::executeImp(TYPE         *object,
                                       int           formattingMode,
                                       ANY_CATEGORY)
{
    enum { k_SUCCESS = 0, k_FAILURE = - 1 };

    bool isAttribute = formattingMode
                     &amp; bdlat_FormattingMode::e_ATTRIBUTE;

    if (!isAttribute) {
        BALXML_DECODER_LOG_WARNING(d_decoder)
                                          &lt;&lt; &quot;Object &#39;&quot; &lt;&lt; d_name_p &lt;&lt; &quot;&#39; is &quot;
                                          &lt;&lt; &quot;being parsed as an attribute, &quot;
                                          &lt;&lt; &quot;but it does not have the &quot;
                                          &lt;&lt; &quot;&#39;IS_ATTRIBUTE&#39; flag set.&quot;
                                          &lt;&lt; BALXML_DECODER_LOG_END;
    }

    if (0 != TypesParserUtil::parse(object,
                                    d_value_p,
                                    static_cast&lt;int&gt;(d_value_length),
                                    formattingMode)) {
        BALXML_DECODER_LOG_ERROR(d_decoder)
                   &lt;&lt; &quot;Unable to parse \&quot;&quot;
                   &lt;&lt; bsl::string(d_value_p, d_value_length)
                   &lt;&lt; &quot;\&quot; (for &#39;&quot; &lt;&lt; d_name_p &lt;&lt; &quot;&#39; attribute)&quot;

                   &lt;&lt; &quot;\&quot;.\n&quot;
                   &lt;&lt; BALXML_DECODER_LOG_END;

        d_failed = true;

        return k_FAILURE;                                             // RETURN
    }

    return k_SUCCESS;
}

// CREATORS
inline
Decoder_ParseAttribute::Decoder_ParseAttribute(Decoder     *decoder,
                                               const char  *name,
                                               const char  *value,
                                               bsl::size_t  lengthValue)
: d_decoder(decoder)
, d_failed(false)
, d_name_p(name)
, d_value_p(value)
, d_value_length(lengthValue)
{
    BSLS_ASSERT_SAFE(d_decoder);
    BSLS_ASSERT_SAFE(d_name_p);
    BSLS_ASSERT_SAFE(d_value_p);
}

// MANIPULATORS
template &lt;class TYPE, class INFO_TYPE&gt;
inline
int Decoder_ParseAttribute::operator()(TYPE *object, const INFO_TYPE&amp; info)
{
    return execute(object, info.formattingMode());
}

template &lt;class TYPE&gt;
inline
int Decoder_ParseAttribute::execute(TYPE *object, int formattingMode)
{
    typedef typename
    bdlat_TypeCategory::Select&lt;TYPE&gt;::Type TypeCategory;

    return executeImp(object, formattingMode, TypeCategory());
}

// ACCESSORS
inline
bool Decoder_ParseAttribute::failed() const
{
    return d_failed;
}

                         // -------------------------
                         // class Decoder_ParseObject
                         // -------------------------

// PRIVATE MANIPULATORS
template &lt;class TYPE&gt;
inline
int Decoder_ParseObject::executeImp(bsl::vector&lt;TYPE&gt;         *object,
                                    int                        formattingMode,
                                    bdlat_TypeCategory::Array)
{
    typedef bdlat_TypeCategory::Select&lt;TYPE&gt; Selector;

    enum {
        CAN_BE_REPETITION_ONLY
            = (  (int)Selector::e_SELECTION
                           == (int)bdlat_TypeCategory::e_SEQUENCE_CATEGORY
              || (int)Selector::e_SELECTION
                           == (int)bdlat_TypeCategory::e_CHOICE_CATEGORY)
    };

    typedef typename
    bslmf::If&lt;CAN_BE_REPETITION_ONLY, CanBeRepetitionOnly,
                                      CanBeListOrRepetition&gt;::Type Toggle;

    return executeArrayImp(object, formattingMode, Toggle());
}

template &lt;class TYPE&gt;
inline
int Decoder_ParseObject::executeImp(TYPE                      *object,
                                    int                        formattingMode,
                                    bdlat_TypeCategory::Array)
{
    return executeArrayImp(object, formattingMode, CanBeListOrRepetition());
}

template &lt;class TYPE&gt;
int Decoder_ParseObject::executeImp(
                                  TYPE                         *object,
                                  int                           formattingMode,
                                  bdlat_TypeCategory::Sequence)
{
    enum { k_FAILURE = -1 };

    if (formattingMode &amp; bdlat_FormattingMode::e_UNTAGGED) {
        if (d_decoder-&gt;options()-&gt;skipUnknownElements()
         &amp;&amp; false == bdlat_SequenceFunctions::hasAttribute(
                                                *object,
                                                d_elementName_p,
                                                static_cast&lt;int&gt;(d_lenName))) {
            d_decoder-&gt;setNumUnknownElementsSkipped(
                                   d_decoder-&gt;numUnknownElementsSkipped() + 1);
            Decoder_UnknownElementContext unknownElement;
            return unknownElement.beginParse(d_decoder);              // RETURN
        }

        return bdlat_SequenceFunctions::manipulateAttribute(
                                                  object,
                                                  *this,
                                                  d_elementName_p,
                                                  static_cast&lt;int&gt;(d_lenName));
                                                                      // RETURN
    }

    typedef typename
    Decoder_InstantiateContext&lt;
                             bdlat_TypeCategory::Sequence, TYPE&gt;::Type Context;

    Context context(object, formattingMode);

    return context.beginParse(d_decoder);
}

template &lt;class TYPE&gt;
int Decoder_ParseObject::executeImp(TYPE                       *object,
                                    int                         formattingMode,
                                    bdlat_TypeCategory::Choice)
{
    enum { k_FAILURE = -1 };

    bool isUntagged = formattingMode &amp; bdlat_FormattingMode::e_UNTAGGED;

    if (isUntagged) {
        if (d_decoder-&gt;options()-&gt;skipUnknownElements()
         &amp;&amp; false == bdlat_ChoiceFunctions::hasSelection(
                                                *object,
                                                d_elementName_p,
                                                static_cast&lt;int&gt;(d_lenName))) {
            d_decoder-&gt;setNumUnknownElementsSkipped(
                                   d_decoder-&gt;numUnknownElementsSkipped() + 1);
            Decoder_UnknownElementContext unknownElement;
            return unknownElement.beginParse(d_decoder);              // RETURN
        }

        if (0 != bdlat_ChoiceFunctions::makeSelection(
                                                object,
                                                d_elementName_p,
                                                static_cast&lt;int&gt;(d_lenName))) {
            BALXML_DECODER_LOG_ERROR(d_decoder)
                                              &lt;&lt; &quot;Unable to make selection: \&quot;&quot;
                                              &lt;&lt; d_elementName_p
                                              &lt;&lt; &quot;\&quot;.&quot;
                                              &lt;&lt; BALXML_DECODER_LOG_END;

            return k_FAILURE;                                         // RETURN
        }

        return bdlat_ChoiceFunctions::manipulateSelection(object, *this);
                                                                      // RETURN
    }

    typedef typename
    Decoder_InstantiateContext&lt;
                               bdlat_TypeCategory::Choice, TYPE&gt;::Type Context;

    Context context(object, formattingMode);

    return context.beginParse(d_decoder);
}

template &lt;class TYPE&gt;
int Decoder_ParseObject::executeImp(
                             TYPE                              *object,
                             int                                formattingMode,
                             bdlat_TypeCategory::NullableValue)
{
    enum { k_SUCCESS = 0, k_FAILURE = -1 };

    if (bdlat_NullableValueFunctions::isNull(*object)) {
        bdlat_NullableValueFunctions::makeValue(object);
    }

    bool isNillable = formattingMode &amp; bdlat_FormattingMode::e_NILLABLE;

    if (isNillable) {
        Decoder_ParseNillableObject parseAsNillable(d_decoder, formattingMode);

        if (0 != bdlat_NullableValueFunctions::manipulateValue(
                                                            object,
                                                            parseAsNillable)) {
            return k_FAILURE;                                         // RETURN
        }

        if (parseAsNillable.isNil()) {
            // reset the object to null
            bdlat_ValueTypeFunctions::reset(object);
        }

        return k_SUCCESS;                                             // RETURN
    }

    Decoder_ParseObject_executeProxy proxy = { this, formattingMode };

    return bdlat_NullableValueFunctions::manipulateValue(object, proxy);
}

template &lt;class TYPE&gt;
int Decoder_ParseObject::executeImp(
                            TYPE                               *object,
                            int                                 formattingMode,
                            bdlat_TypeCategory::CustomizedType)
{
    typedef typename
    Decoder_InstantiateContext&lt;
                     bdlat_TypeCategory::CustomizedType, TYPE&gt;::Type
                     Context;

    Context context(object, formattingMode);

    return context.beginParse(d_decoder);
}

template &lt;class TYPE&gt;
inline
int Decoder_ParseObject::executeImp(
                               TYPE                            *object,
                               int                              formattingMode,
                               bdlat_TypeCategory::DynamicType)
{
    Decoder_ParseObject_executeImpProxy proxy = {
        this, formattingMode
    };

    return bdlat_TypeCategoryUtil::manipulateByCategory(object, proxy);
}

template &lt;class TYPE, class ANY_CATEGORY&gt;
inline
int Decoder_ParseObject::executeImp(TYPE         *object,
                                    int           formattingMode,
                                    ANY_CATEGORY)
{
    typedef typename
    Decoder_InstantiateContext&lt;ANY_CATEGORY, TYPE&gt;::Type Context;

    Context context(object, formattingMode);

    return context.beginParse(d_decoder);
}

template &lt;class TYPE&gt;
int Decoder_ParseObject::executeArrayImp(TYPE                  *object,
                                         int                    formattingMode,
                                         CanBeListOrRepetition)
{
    if (formattingMode &amp; bdlat_FormattingMode::e_LIST) {
        typedef Decoder_PushParserContext&lt;TYPE, Decoder_ListParser&lt;TYPE&gt; &gt;
            ListContext;

        ListContext listContext(object, formattingMode);

        return listContext.beginParse(d_decoder);                     // RETURN
    } else {
        return executeArrayRepetitionImp(object, formattingMode);     // RETURN
    }
}

template &lt;class TYPE&gt;
inline
int Decoder_ParseObject::executeArrayImp(TYPE                *object,
                                         int                  formattingMode,
                                         CanBeRepetitionOnly)
{
    return executeArrayRepetitionImp(object, formattingMode);
}

template &lt;class TYPE&gt;
int Decoder_ParseObject::executeArrayRepetitionImp(TYPE *object,
                                                   int   formattingMode)
{
    BSLS_ASSERT_SAFE(! (formattingMode &amp; bdlat_FormattingMode::e_TYPE_MASK
                                   &amp; bdlat_FormattingMode::e_LIST));

    Decoder_ParseObject_executeProxy proxy = { this, formattingMode };

    const int i = static_cast&lt;int&gt;(bdlat_ArrayFunctions::size(*object));

    bdlat_ArrayFunctions::resize(object, i + 1);

    return bdlat_ArrayFunctions::manipulateElement(object, proxy, i);
}

// CREATORS
inline
Decoder_ParseObject::Decoder_ParseObject(Decoder     *decoder,
                                         const char  *elementName,
                                         bsl::size_t  lenName)
: d_decoder(decoder)
, d_elementName_p(elementName)
, d_lenName(lenName)
{
    BSLS_ASSERT_SAFE(d_elementName_p);
    BSLS_ASSERT_SAFE(d_decoder);
}

// MANIPULATORS
template &lt;class TYPE, class INFO_TYPE&gt;
inline
int Decoder_ParseObject::operator()(TYPE *object, const INFO_TYPE &amp;info)
{
    return execute(object, info.formattingMode());
}

template &lt;class TYPE&gt;
inline
int Decoder_ParseObject::execute(TYPE *object, int formattingMode)
{
    typedef typename
    bdlat_TypeCategory::Select&lt;TYPE&gt;::Type TypeCategory;

    return executeImp(object, formattingMode, TypeCategory());
}

                     // ---------------------------------
                     // class Decoder_ParseNillableObject
                     // ---------------------------------

// IMPLEMENTATION MANIPULATORS
template &lt;class TYPE&gt;
inline
int Decoder_ParseNillableObject::executeImp(
                                       TYPE                            *object,
                                       bdlat_TypeCategory::DynamicType)
{
    Decoder_ParseNillableObject_executeImpProxy proxy = { this };

    return bdlat_TypeCategoryUtil::manipulateByCategory(object, proxy);
}

template &lt;class TYPE, class ANY_CATEGORY&gt;
inline
int Decoder_ParseNillableObject::executeImp(TYPE *object, ANY_CATEGORY)
{
    typedef typename
    Decoder_InstantiateContext&lt;ANY_CATEGORY, TYPE&gt;::Type Context;

    Context elementContext(object, d_formattingMode);

    d_nillableContext.setElementContext(&amp;elementContext);

    return d_nillableContext.beginParse(d_decoder);
}

inline
Decoder_ParseNillableObject::Decoder_ParseNillableObject(
                                                       Decoder *decoder,
                                                       int      formattingMode)
: d_formattingMode(formattingMode)
, d_nillableContext()
, d_decoder(decoder)
{
}

// MANIPULATORS
template &lt;class TYPE&gt;
inline
int Decoder_ParseNillableObject::operator()(TYPE *object)
{
    typedef typename
    bdlat_TypeCategory::Select&lt;TYPE&gt;::Type TypeCategory;

    return executeImp(object, TypeCategory());
}

// ACCESSORS
inline
bool Decoder_ParseNillableObject::isNil() const
{
    return d_nillableContext.isNil();
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
