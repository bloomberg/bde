<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlmt::ChannelPoolChannel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlmt.html">btlmt</a>      </li>
      <li><a class="el" href="classbtlmt_1_1ChannelPoolChannel.html">btlmt::ChannelPoolChannel</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlmt::ChannelPoolChannel Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlmt::ChannelPoolChannel" --><!-- doxytag: inherits="btlmt::AsyncChannel" -->
<p><code>#include &lt;<a class="el" href="btlmt__channelpoolchannel_8h_source.html">btlmt_channelpoolchannel.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlmt::ChannelPoolChannel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlmt_1_1ChannelPoolChannel.png" usemap="#btlmt::ChannelPoolChannel_map" alt=""/>
  <map id="btlmt::ChannelPoolChannel_map" name="btlmt::ChannelPoolChannel_map">
<area href="classbtlmt_1_1AsyncChannel.html" alt="btlmt::AsyncChannel" shape="rect" coords="0,0,162,24"/>
</map>
</div>

<p><a href="classbtlmt_1_1ChannelPoolChannel-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>ReadQueueEntry</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551f">ReadResult</a> { <br/>
&nbsp;&nbsp;<a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551fa5cba2d111aa63093d4e64191f1707d03">e_SUCCESS</a> =  0, 
<a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551fa01f2e9ed90a39741ac081e5dce5a1759">e_TIMEOUT</a> =  1, 
<a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551fafa17e8cfc2c5c042da53507cfd1acb3e">e_CLOSED</a> =  2, 
<a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551fa6f2b061c0524b51ad80ae1cd44e0b505">e_FAILURE</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551fae89cb167dc0c7381d150577a6cfd96f4">e_CANCELED</a> =  4
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(int, <br class="typebreak"/>
int *, <a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> *, int)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1AsyncChannel.html#a6fd18c091cdc0fe58b37bd0c18e2d19c">BlobBasedReadCallback</a> )</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#ad54f311f604c58cb84a97103bb9bbd56">ChannelPoolChannel</a> (int channelId, <a class="el" href="classbtlmt_1_1ChannelPool.html">ChannelPool</a> *channelPool, <a class="el" href="classbtlb_1_1BlobBufferFactory.html">btlb::BlobBufferFactory</a> *blobBufferFactory, <a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a> *spAllocator, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a49e20e646da768961adb06af81d20009">~ChannelPoolChannel</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#af20c03421e1b18118c1fcacad40f14db">read</a> (int numBytes, const <a class="el" href="classbtlmt_1_1AsyncChannel.html#a6fd18c091cdc0fe58b37bd0c18e2d19c">BlobBasedReadCallback</a> &amp;readCallback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a2b6096061a2d3b6115ff463249c86417">timedRead</a> (int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeOut, const <a class="el" href="classbtlmt_1_1AsyncChannel.html#a6fd18c091cdc0fe58b37bd0c18e2d19c">BlobBasedReadCallback</a> &amp;readCallback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a5c23e590c1ed2f2cd812d30e2bb13bc3">write</a> (const <a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> &amp;blob, int highWaterMark=INT_MAX)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a534fad974a90d0dc84573dee069de8ae">setSocketOption</a> (int option, int level, int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a453b1614cdac188b848be3053ccdae0d">cancelRead</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#adece697dec8b2e46a201a631549dce7f">close</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a35c2c514483295c35be7a62042977e74">blobBasedDataCb</a> (int *numNeeded, <a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> *msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a0e7da2601843bc5df9b4c6814f61e8da">localAddress</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a1d068c796754864fd1e592ee55442812">peerAddress</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a9290d524f0e5c317709a504213240f3d">channelId</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtlmt_1_1ChannelPool.html">ChannelPool</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPoolChannel.html#a1466c11b856abdcfe74856716100dbef">channelPool</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides an implementation of the <code><a class="el" href="classbtlmt_1_1AsyncChannel.html">AsyncChannel</a></code> protocol for <code><a class="el" href="classbtlmt_1_1ChannelPool.html">ChannelPool</a></code>-based channels. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a6fd18c091cdc0fe58b37bd0c18e2d19c"></a><!-- doxytag: member="btlmt::ChannelPoolChannel::BlobBasedReadCallback" ref="a6fd18c091cdc0fe58b37bd0c18e2d19c" args=")" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(int, int *, <a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> *, int) <a class="el" href="classbtlmt_1_1AsyncChannel.html#a6fd18c091cdc0fe58b37bd0c18e2d19c">btlmt::AsyncChannel::BlobBasedReadCallback</a>)<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A callback of this type is invoked for <code>read</code> and <code>timeRead</code> when either the requested number of bytes are available, or an error occurs. The callback is invoked with four arguments: (1) an integer result code corresponding to <code>ReadResult</code> that indicates the result of the read operation, and if this code is equal to <code>e_SUCCESS</code>, (2) a pointer to an integer value where the callee can indicate how many more bytes are needed to complete the read operation, (3) a modifiable <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code> object containing the payload. The caller is responsible for taking ownership of a certain number of bytes in the <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code> and readjusting it appropriately. Note that the read operation is not considered completed until the callee indicates that zero more bytes are needed (argument 2), and (4) channel id. Also note that the last three arguments are ignored if the first argument is different from <code>e_SUCCESS</code>.</p>
<p>A typical function matching this interface might look as follows: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keywordtype">void</span> myReadCallback(<span class="keywordtype">int</span>         result,
                              <span class="keywordtype">int</span>        *numNeeded,
                              <a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a> *blob,
                              <span class="keywordtype">int</span>         channelId);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ad108cc12b44c814135812903da49551f"></a><!-- doxytag: member="btlmt::ChannelPoolChannel::ReadResult" ref="ad108cc12b44c814135812903da49551f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551f">btlmt::AsyncChannel::ReadResult</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad108cc12b44c814135812903da49551fa5cba2d111aa63093d4e64191f1707d03"></a><!-- doxytag: member="e_SUCCESS" ref="ad108cc12b44c814135812903da49551fa5cba2d111aa63093d4e64191f1707d03" args="" -->e_SUCCESS</em>&nbsp;</td><td>
<p>The operation was successful. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad108cc12b44c814135812903da49551fa01f2e9ed90a39741ac081e5dce5a1759"></a><!-- doxytag: member="e_TIMEOUT" ref="ad108cc12b44c814135812903da49551fa01f2e9ed90a39741ac081e5dce5a1759" args="" -->e_TIMEOUT</em>&nbsp;</td><td>
<p>The <code>timedRead</code> operation has timed out. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad108cc12b44c814135812903da49551fafa17e8cfc2c5c042da53507cfd1acb3e"></a><!-- doxytag: member="e_CLOSED" ref="ad108cc12b44c814135812903da49551fafa17e8cfc2c5c042da53507cfd1acb3e" args="" -->e_CLOSED</em>&nbsp;</td><td>
<p>The underlying stream used by this channel </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad108cc12b44c814135812903da49551fa6f2b061c0524b51ad80ae1cd44e0b505"></a><!-- doxytag: member="e_FAILURE" ref="ad108cc12b44c814135812903da49551fa6f2b061c0524b51ad80ae1cd44e0b505" args="" -->e_FAILURE</em>&nbsp;</td><td>
<p>An I/O error occurred during the read </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad108cc12b44c814135812903da49551fae89cb167dc0c7381d150577a6cfd96f4"></a><!-- doxytag: member="e_CANCELED" ref="ad108cc12b44c814135812903da49551fae89cb167dc0c7381d150577a6cfd96f4" args="" -->e_CANCELED</em>&nbsp;</td><td>
<p>The asynchronous read request was canceled. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad54f311f604c58cb84a97103bb9bbd56"></a><!-- doxytag: member="btlmt::ChannelPoolChannel::ChannelPoolChannel" ref="ad54f311f604c58cb84a97103bb9bbd56" args="(int channelId, ChannelPool *channelPool, btlb::BlobBufferFactory *blobBufferFactory, bdlma::ConcurrentPoolAllocator *spAllocator, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlmt::ChannelPoolChannel::ChannelPoolChannel </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html">ChannelPool</a> *&nbsp;</td>
          <td class="paramname"> <em>channelPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlb_1_1BlobBufferFactory.html">btlb::BlobBufferFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>blobBufferFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a> *&nbsp;</td>
          <td class="paramname"> <em>spAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbtlmt_1_1AsyncChannel.html">AsyncChannel</a></code> concrete implementation reading from and writing to the channel referenced by the specified <code>channelId</code> in the specified <code>channelPool</code>, using the specified <code>blobBufferFactory</code> and the specified <code>spAllocator</code> to supply memory to the data messages. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. If <code>blobBufferFactory</code> is 0, create a <code><a class="el" href="classbtlb_1_1PooledBlobBufferFactory.html">btlb::PooledBlobBufferFactory</a></code> object internally using <code>basicAllocator</code> or the currently installed default allocator if <code>basicAllocator</code> is 0. </p>

</div>
</div>
<a class="anchor" id="a49e20e646da768961adb06af81d20009"></a><!-- doxytag: member="btlmt::ChannelPoolChannel::~ChannelPoolChannel" ref="a49e20e646da768961adb06af81d20009" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual btlmt::ChannelPoolChannel::~ChannelPoolChannel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this channel. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af20c03421e1b18118c1fcacad40f14db"></a><!-- doxytag: member="btlmt::ChannelPoolChannel::read" ref="af20c03421e1b18118c1fcacad40f14db" args="(int numBytes, const BlobBasedReadCallback &amp;readCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlmt::ChannelPoolChannel::read </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1AsyncChannel.html#a6fd18c091cdc0fe58b37bd0c18e2d19c">BlobBasedReadCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>readCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate an asynchronous read operation on this channel, or append this request to the currently pending requests if an asynchronous read operation was already initiated. When at least the specified <code>numBytes</code> of data are available after all previous requests have been processed, if any, the specified <code>readCallback</code> will be invoked (with <code><a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551fa5cba2d111aa63093d4e64191f1707d03">btlmt::AsyncChannel::e_SUCCESS</a></code>). Return 0 on success, and a non-zero value otherwise. On error, the return value <em>may</em> equal to one of the enumerators in <code><a class="el" href="structbtlmt_1_1ChannelStatus.html#a4352e4c5f1558a16a42bff85712fe3dc">ChannelStatus::Enum</a></code>. </p>

<p>Implements <a class="el" href="classbtlmt_1_1AsyncChannel.html#a40529f78e22d0f2cf68ffd3d25071e00">btlmt::AsyncChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a2b6096061a2d3b6115ff463249c86417"></a><!-- doxytag: member="btlmt::ChannelPoolChannel::timedRead" ref="a2b6096061a2d3b6115ff463249c86417" args="(int numBytes, const bsls::TimeInterval &amp;timeOut, const BlobBasedReadCallback &amp;readCallback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlmt::ChannelPoolChannel::timedRead </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1AsyncChannel.html#a6fd18c091cdc0fe58b37bd0c18e2d19c">BlobBasedReadCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>readCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate an asynchronous timed read operation on this channel, or append this request to the currently pending requests if an asynchronous read operation was already initiated, with an associated specified absolute <code>timeOut</code>. When at least the specified <code>numBytes</code> of data are available after all previous requests have been processed, if any, or when the <code>timeOut</code> is reached, the specified <code>readCallback</code> will be invoked (with either <code><a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551fa5cba2d111aa63093d4e64191f1707d03">btlmt::AsyncChannel::e_SUCCESS</a></code> or <code><a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551fa01f2e9ed90a39741ac081e5dce5a1759">btlmt::AsyncChannel::e_TIMEOUT</a></code>, respectively). Return 0 on success, and a non-zero value otherwise. On error, the return value <em>may</em> equal to one of the enumerators in <code><a class="el" href="structbtlmt_1_1ChannelStatus.html#a4352e4c5f1558a16a42bff85712fe3dc">ChannelStatus::Enum</a></code>. </p>

<p>Implements <a class="el" href="classbtlmt_1_1AsyncChannel.html#abda8c1b331e8dbfaa4759373f74cd58d">btlmt::AsyncChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a5c23e590c1ed2f2cd812d30e2bb13bc3"></a><!-- doxytag: member="btlmt::ChannelPoolChannel::write" ref="a5c23e590c1ed2f2cd812d30e2bb13bc3" args="(const btlb::Blob &amp;blob, int highWaterMark=INT_MAX)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlmt::ChannelPoolChannel::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>highWaterMark</em> = <code>INT_MAX</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enqueue the specified <code>blob</code> message to be written to this channel. Optionally provide <code>highWaterMark</code> to specify the maximum data size that can be enqueued. If <code>highWaterMark</code> is not specified then <code>INT_MAX</code> is used. Return 0 on success, and a non-zero value otherwise. On error, the return value <em>may</em> equal to one of the enumerators in <code><a class="el" href="structbtlmt_1_1ChannelStatus.html#a4352e4c5f1558a16a42bff85712fe3dc">ChannelStatus::Enum</a></code>. Note that success does not imply that the data has been written or will be successfully written to the underlying stream used by this channel. Also note that in addition to <code>highWatermark</code> the enqueued portion must also be less than a high watermark value supplied at the construction of this channel for the write to succeed. </p>

<p>Implements <a class="el" href="classbtlmt_1_1AsyncChannel.html#a66bb58eb273e0b4325c57f743feea7d4">btlmt::AsyncChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a534fad974a90d0dc84573dee069de8ae"></a><!-- doxytag: member="btlmt::ChannelPoolChannel::setSocketOption" ref="a534fad974a90d0dc84573dee069de8ae" args="(int option, int level, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlmt::ChannelPoolChannel::setSocketOption </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified <code>option</code> (of the specified <code>level</code>) socket option on this channel to the specified <code>value</code>. Return 0 on success and a non-zero value otherwise. (See <code>btlso_socketoptutil</code> for the list of commonly supported options.) </p>

<p>Implements <a class="el" href="classbtlmt_1_1AsyncChannel.html#ab6fe7d9b78e55b1a894fbe91e472a08a">btlmt::AsyncChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a453b1614cdac188b848be3053ccdae0d"></a><!-- doxytag: member="btlmt::ChannelPoolChannel::cancelRead" ref="a453b1614cdac188b848be3053ccdae0d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlmt::ChannelPoolChannel::cancelRead </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel all pending <code>read</code> or <code>timedRead</code> requests, and invoke their read callbacks with a <code><a class="el" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551fae89cb167dc0c7381d150577a6cfd96f4">btlmt::AsyncChannel::e_CANCELED</a></code> status. Note that if the channel is active, the read callbacks are invoked in the thread in which the channel's data callbacks are invoked, else they are invoked in the thread calling <code>cancelRead</code>. </p>

<p>Implements <a class="el" href="classbtlmt_1_1AsyncChannel.html#a5675a6b49a9c262de4ea87914ae61437">btlmt::AsyncChannel</a>.</p>

</div>
</div>
<a class="anchor" id="adece697dec8b2e46a201a631549dce7f"></a><!-- doxytag: member="btlmt::ChannelPoolChannel::close" ref="adece697dec8b2e46a201a631549dce7f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlmt::ChannelPoolChannel::close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shutdown this channel, and cancel all pending requests. Note that this call will result in the shutdown of the channel pool channel associated with the channel, and will not invoke the pending read requests. </p>

<p>Implements <a class="el" href="classbtlmt_1_1AsyncChannel.html#af20340aa5d3fd2ed875533d12715acf5">btlmt::AsyncChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a35c2c514483295c35be7a62042977e74"></a><!-- doxytag: member="btlmt::ChannelPoolChannel::blobBasedDataCb" ref="a35c2c514483295c35be7a62042977e74" args="(int *numNeeded, btlb::Blob *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlmt::ChannelPoolChannel::blobBasedDataCb </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>numNeeded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is invoked in response to a blob based channel pool data callback on the channel id associated with this channel, and invokes the pending read requests until either more data is needed or this channel is closed. Note that the behavior is undefined if this method is invoked concurrently from multiple threads. </p>

</div>
</div>
<a class="anchor" id="a0e7da2601843bc5df9b4c6814f61e8da"></a><!-- doxytag: member="btlmt::ChannelPoolChannel::localAddress" ref="a0e7da2601843bc5df9b4c6814f61e8da" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> btlmt::ChannelPoolChannel::localAddress </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the "local" end of the channel. </p>

<p>Implements <a class="el" href="classbtlmt_1_1AsyncChannel.html#a837e8ce93384cf3a52679bf2751ab482">btlmt::AsyncChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a1d068c796754864fd1e592ee55442812"></a><!-- doxytag: member="btlmt::ChannelPoolChannel::peerAddress" ref="a1d068c796754864fd1e592ee55442812" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> btlmt::ChannelPoolChannel::peerAddress </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the "remote" end of the channel. </p>

<p>Implements <a class="el" href="classbtlmt_1_1AsyncChannel.html#a82e42998d5636d66143b518a70e72973">btlmt::AsyncChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a9290d524f0e5c317709a504213240f3d"></a><!-- doxytag: member="btlmt::ChannelPoolChannel::channelId" ref="a9290d524f0e5c317709a504213240f3d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPoolChannel::channelId </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the channelPool channel Id associated with this channel. </p>

</div>
</div>
<a class="anchor" id="a1466c11b856abdcfe74856716100dbef"></a><!-- doxytag: member="btlmt::ChannelPoolChannel::channelPool" ref="a1466c11b856abdcfe74856716100dbef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlmt_1_1ChannelPool.html">ChannelPool</a>* btlmt::ChannelPoolChannel::channelPool </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pointer to the channelPool object associated with the channel. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlmt__channelpoolchannel_8h_source.html">btlmt_channelpoolchannel.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:35:14 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
