<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btls_ratelimiter Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btls_ratelimiter<br/>
<small>
[<a class="el" href="group__btls.html">Package btls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a mechanism to limit peak and sustained consumption rates.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtls.html">btls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Internal Model</a> </li>
<li>
<a href="#3.2">Monitoring Resource Usage</a> </li>
<li>
<a href="#3.3">Time Synchronization</a> </li>
<li>
<a href="#3.4">Usage</a> </li>
<li>
<a href="#3.5">Example 1: Controlling Network Traffic Generation</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a mechanism to limit peak and sustained consumption rates. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtls_1_1RateLimiter.html">btls::RateLimiter</a> </td><td>mechanism to monitor resource consumption rates  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btls__leakybucket.html" title="Provide a mechanism to monitor the consumption rate of a resource.">Component btls_leakybucket</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a mechanism, <code><a class="el" href="classbtls_1_1RateLimiter.html">btls::RateLimiter</a></code>, that enables clients to monitor and control the use of a resource such that the peak consumption rate and the sustained consumption rate do not exceed their respective configured limits. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The limits on resource consumption rates of a <code><a class="el" href="classbtls_1_1RateLimiter.html">btls::RateLimiter</a></code> object are configured using a specified peak rate (measured in <code>units/s</code>) along with its time-window, and a specified sustained rate (measured in <code>units/s</code>) along with its time-window. The peak-rate time-window indicates a sliding time period over which the average consumption rate shall not exceed the peak-rate; similarly, the sustained-rate time-window indicates a sliding time period over which the average consumption rate shall not exceed the sustained rate. <code>unit</code> is a generic unit of measurement (e.g., bytes, megabytes, number of messages, packets, liters, clock cycles, etc.). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="internal_model"></a> <a class="anchor" id="description.internal_model"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Internal Model: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Internally, a rate limiter (currently) models resource usage using two corresponding <code><a class="el" href="classbtls_1_1LeakyBucket.html">btls::LeakyBucket</a></code> objects, one for limiting peak resource usage and one for limiting sustained resource usage. Each leaky bucket provides an approximation for a moving total, where the configured time window corresponds to the period of the moving total, and that time window multiplied by the corresponding rate indicates the sum that the moving total may not exceed (i.e., the capacity of the leaky bucket). As the units are submitted to a rate limiter, they are added to both the peak and sustained rate moving-totals, and then removed over time at the corresponding configured rate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Figure 1 illustrates the behavior of a rate limiter during a typical usage scenario using moving-totals: <br/>
<br/>
<div class="fragment"><pre class="fragment"> Fig. 1:

  Rp (peak rate)                  = 2 units/s
  Wp (peak-rate time-window)      = 2 s
  Rs (sustained rate)             = 1 units/s
  Ws (sustained-rate time-window) = 7 s

       Submit 5                                       Submit 7

      |   |     |   |        |   |      |   |       |   |     7|~~~|
    12|   |    6|   |      12|   |     6|   |     12|   |     6|~~~|
    11|   |    5|~~~|      11|   |     5|   |     11|   |     5|~~~|
    10|   | Lp-4|~~~|      10|   |  Lp-4|---|     10|   |  Lp-4|~~~|
     9|   |    3|~~~|       9|   |     3|   |      9|~~~|     3|~~~|
     8|   |    2|~~~|       8|   |     2|   |      8|~~~|     2|~~~|
  Ls-7|---|    1|~~~|    Ls-7|---|     1|~~~|   Ls-7|~~~|     1|~~~|
     6|   |     +- -+       6|   |      +- -+      6|~~~|      +- -+
     5|~~~|                 5|   |                 5|~~~|
     4|~~~|                 4|   |                 4|~~~|
     3|~~~|                 3|~~~|                 3|~~~|
     2|~~~|                 2|~~~|                 2|~~~|
     1|~~~|                 1|~~~|                 1|~~~|
      +- -+                  +- -+                  +- -+

 <a class="code" href="namespacebdet.html#aac65e816e68f5285b127a9071544c5c1">Time</a>:    t0                     t0 + 2s                  t0 + 2s

                                                      Submit 2

      |   |     7|   |       |   |     7|   |       |   |     7|   |
    12|   |     6|   |     12|   |     6|   |     12|   |     6|   |
    11|   |     5|   |     11|   |     5|   |     11|   |     5|   |
    10|   |  Lp-4|---|     10|   |  Lp-4|---|     10|   |  Lp-4|---|
     9|   |     3|~~~|      9|   |     3|   |      9|   |     3|~~~|
     8|   |     2|~~~|      8|   |     2|   |      8|   |     2|~~~|
  Ls-7|~~~|     1|~~~|   Ls-7|---|     1|~~~|   Ls-7|~~~|     1|~~~|
     6|~~~|      +- -+      6|---|      +- -+      6|~~~|      +- -+
     5|~~~|                 5|~~~|                 5|~~~|
     4|~~~|                 4|~~~|                 4|~~~|
     3|~~~|                 3|~~~|                 3|~~~|
     2|~~~|                 2|~~~|                 2|~~~|
     1|~~~|                 1|~~~|                 1|~~~|
      +- -+                  +- -+                  +- -+

 <a class="code" href="namespacebdet.html#aac65e816e68f5285b127a9071544c5c1">Time</a>:    t0 + 4s               t0 + 6s                t0 + 6s
</pre></div><br/>
<br/>
 Suppose we have a rate limiter with a peak rate of <code>Rp = 2 units/s</code>, a peak-rate time-window of <code>Wp = 2 s</code>, a sustained rate of <code>Rs = 1 units/s</code>, and a sustained-rate time-window of <code>Ws = 7 s</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This rate limiter maintains a moving-total having a capacity <code>Lp = Rp * Wp = 4 units</code> that controls the peak rate and another moving-total having a capacity <code>Ls = Rs * Ws = 7 units</code> that controls the sustained rate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Figure 1 shows the following sequence of events: <ul>
<li>
At time <code>t0s</code>, we submit 5 units. The submitted units are added to the both moving-totals, and as a result the <code>Lp</code> is exceeded, which means that the average consumption rate over the peak-rate time-window has exceeded the peak rate. Note that we can not submit any more units at this time even though <code>Ls</code> is not exceeded (the average consumption rate over the sustained-rate time-windows has not exceeded the sustained rate).  </li>
<li>
At time <code>t0 + 2s</code> the number of units contained moving-totals are recalculated. As a result, 4 units (<code>Rp * 2 s</code>) are subtracted from the peak rate moving-total, and 2 units (<code>Rs * 2 s</code>) are subtracted from the sustained rate moving-total. Now, capacities of both moving-totals are no longer exceeded, so we are free to submit more units. We submit 7 units, causing both <code>Lp</code> and <code>Ls</code> to be exceeded.  </li>
<li>
At time <code>t0 + 4s</code>, the moving-totals are again updated. The <code>Lp</code> limit is no longer exceeded. The number of units held by the moving-total tracking sustained rate matches the moving-total's capacity, and this boundary condition imply and no units can be submitted, because submitting any amount of units would cause <code>Ls</code> to be exceeded.  </li>
<li>
At time <code>t0 + 6s</code>, the moving-totals are again updated. Both <code>Lp</code> and <code>Ls</code> are no longer exceeded. We submit 2 units. The <code>Lp</code> limit is not exceeded, but <code>Ls</code> limit is exceeded.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="monitoring_resource_usage"></a> <a class="anchor" id="description.monitoring_resource_usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Monitoring Resource Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbtls_1_1LeakyBucket.html">btls::LeakyBucket</a></code> provides methods to both submit units and reserve units for future submission. Submitting a unit indicates that it has been consumed by the entity being modeled, and it is added to the moving-totals tracking both peak and sustained resource usage. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Reserving a unit guarantees that available capacity will be reserved so that unit can be submitted in the future without exceeding the configured limits. Reserved units may be later submitted using the <code>submitReserved</code> method or canceled using the <code>cancelReserved</code> method. Reserved units permanently reside in the two moving-totals of consumed units, resulting in the reduction in the effective capacities of the moving-totals, until the reserved units are canceled or submitted. Reserving units effectively shortens the time-window during which the average sustained and peak rate are enforced. Therefore, the time interval between reserving units and submitting or canceling them should be kept as short as possible. For a practical example of using reserved units, please see <code>btls_reservationguard</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The recommended usage of a rate limiter is to first check whether 1 unit can be added without exceeding the rate limiter's configured limits, and if so, consume the desired amount of the resource. Afterwards, submit the amount of consumed resource to the rate limiter. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Whether submitting more units would exceed the configured limits can be determined using the <code>wouldExceedBandwidth</code> method. The estimated amount of time to wait before 1 more unit will be allowed to be submitted can be determined using the <code>calculateTimeToSubmit</code> method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="time_synchronization"></a> <a class="anchor" id="description.time_synchronization"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Time Synchronization: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>rate limiter does not utilize an internal timer, so timing must be handled manually. Clients can specify an initial time interval for a rate limiter object at construction or using the <code>reset</code> method. Whenever the state of a rate limiter object needs to be updated, clients must invoke the <code>updateState</code> method specifying the current time interval. Since rate limiter cares only about the elapsed time (not absolute time), the specified time intervals may be relative to any arbitrary time origin, though all of them must refer to the same origin. For the sake of consistency, clients are encouraged to use the unix epoch time (such as the values returned by <code><a class="el" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a></code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates the intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_controlling_network_traffic_generation"></a> <a class="anchor" id="description.example_1~3A_controlling_network_traffic_generation"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="description.example_1"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Controlling Network Traffic Generation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose that we want to send data over a network interface with the load spike limitations explained below: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
The long term average rate of resource usage (i.e., the sustained rate) should not exceed 1024 bytes/s (<code>Rs</code>).  </li>
<li>
The period over which to monitor the long term average rate (i.e., the sustained-rate time-window) should be 0.5s (<code>Wp</code>).  </li>
<li>
The peak resource usage (i.e., the peak rate) should not exceed 2048 bytes/s (<code>Rp</code>).  </li>
<li>
The period over which to monitor the peak resource usage should be 0.0625s (Wp).  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>This is shown in Figure 2 below. <br/>
<br/>
<div class="fragment"><pre class="fragment"> Fig. 2:

     ^ Rate (Units per second)
     |                             _____         .
     |                            /  B  \        .
 2048|---------------------------/-------\--------Rp (Maximum peak rate)
     |           __             /         \      .
     |          /  \           /    A2     \     .
     |         / A1 \         /             \    .
 1024|--------/------\ ------/---------------\----Rs (Maximum sustained rate)
     |   __  /        \     /                 \__.
     |__/  \/          \___/                     .
     |                                           .
      ---------------------------------------------&gt;
                                         T (seconds)
</pre></div><br/>
<br/>
 Notice that we can understand the limitations imposed by the rate-limiter graphically as the maximum area above the respective lines, <code>Rp</code> and <code>Rs</code>, that the usage curve to allowed to achieve. In the example above: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>o The area above the sustained rate <code>Rs</code> (e.g., <code>A1</code> or <code>A2+B</code>) should contain no more than 512 bytes (Rs * Ws). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>o The area above the peak rate <code>Rp</code> should contain no more than 128 bytes (Rp * Wp). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Further suppose that we have a function, <code>sendData</code>, that transmits a specified amount of data over that network: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">bool</span> sendData(<span class="keywordtype">size_t</span> dataSize)
      <span class="comment">// Send a specified &#39;dataSize&#39; amount of data over the network.  Return</span>
      <span class="comment">// &#39;true&#39; if data was sent successfully and &#39;false&#39; otherwise.</span>
  {
      (void)(dataSize);
      <span class="comment">// For simplicity, &#39;sendData&#39; will not actually send any data and will</span>
      <span class="comment">// always return &#39;true&#39;.</span>
      <span class="keywordflow">return</span> <span class="keyword">true</span>;
  }
</pre></div><br/>
<br/>
 First, we create a <code><a class="el" href="classbtls_1_1RateLimiter.html">btls::RateLimiter</a></code> object having a sustained rate of 1024 bytes/s, a sustained-rate time-window of 0.5s (512 bytes / 1024 bytes/s), a peak-rate of 2048 bytes/s, and a peak-rate time-window of 0.0625s (128 bytes / 2048 bytes/s): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> sustainedRateLimit = 1024;
  <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>  sustainedRateWindow(0.5);
  <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> peakRateLimit = 2048;
  <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>  peakRateWindow(0.0625);
  <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>  now = <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>();

  <a class="code" href="classbtls_1_1RateLimiter.html">btls::RateLimiter</a>  rateLimiter(sustainedRateLimit,
                                 sustainedRateWindow,
                                 peakRateLimit,
                                 peakRateWindow,
                                 now);
</pre></div><br/>
<br/>
 Note that the rate limiter does not prevent the rate at any instant from exceeding either the peak-rate or the sustained rate; instead, it prevents the average rate over the peak-rate time-window from exceeding maximum peak-rate and the average rate over the sustained-rate time-window from exceeding the maximum sustained-rate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we define the size of data to be send, the size of each data chunk, and a counter of data actually sent: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> sizeOfData = 10 * 1024; <span class="comment">// in bytes</span>
  <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> chunkSize  = 64;        <span class="comment">// in bytes</span>
  <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> bytesSent  = 0;
</pre></div><br/>
<br/>
 Now, we send the chunks of data using a loop. For each iteration, we check whether submitting another byte would exceed the rate limiter's bandwidth limits. If not, we send an additional chunk of data and submit the number of bytes sent to the leaky bucket. Note that <code>submit</code> is invoked only after the data has been sent. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">while</span> (bytesSent &lt; sizeOfData) {
      now = <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>();
      <span class="keywordflow">if</span> (!rateLimiter.wouldExceedBandwidth(now)) {
          <span class="keywordflow">if</span> (<span class="keyword">true</span> == sendData(chunkSize)) {
              rateLimiter.submit(chunkSize);
              bytesSent += chunkSize;
          }
      }
</pre></div><br/>
<br/>
 Finally, if submitting another byte will cause the rate limiter to exceed its bandwidth limits, then we wait until the submission will be allowed by waiting for an amount time returned by the <code>calculateTimeToSubmit</code> method: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">else</span> {
          <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> timeToSubmit =
                                      rateLimiter.calculateTimeToSubmit(now);
          <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> uS = timeToSubmit.<a class="code" href="classbsls_1_1TimeInterval.html#ac444ef74eebd36b28c6eabd8ee1d75cb">totalMicroseconds</a>() +
                                 (timeToSubmit.<a class="code" href="classbsls_1_1TimeInterval.html#a6a37e5f3c58f4e02724d5fc6321d4d08">nanoseconds</a>() % 1000) ? 1 : 0;
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a4e6a840e495c3afa38474a2dcc073286">bslmt::ThreadUtil::microSleep</a>(static_cast&lt;int&gt;(uS));
      }
  }
</pre></div><br/>
<br/>
 Notice that we wait by putting the thread into a sleep state instead of using busy-waiting to better optimize for multi-threaded applications. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:13 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
