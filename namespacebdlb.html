<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Namespace bdlb</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>bdlb Namespace Reference<br/>
<small>
[<a class="el" href="group__bdlb__arrayutil.html">Component bdlb_arrayutil</a>,&nbsp;<a class="el" href="group__bdlb__bigendian.html">Component bdlb_bigendian</a>,&nbsp;<a class="el" href="group__bdlb__bitmaskutil.html">Component bdlb_bitmaskutil</a>,&nbsp;<a class="el" href="group__bdlb__bitstringimputil.html">Component bdlb_bitstringimputil</a>,&nbsp;<a class="el" href="group__bdlb__bitstringutil.html">Component bdlb_bitstringutil</a>,&nbsp;<a class="el" href="group__bdlb__bitutil.html">Component bdlb_bitutil</a>,&nbsp;<a class="el" href="group__bdlb__chartype.html">Component bdlb_chartype</a>,&nbsp;<a class="el" href="group__bdlb__cstringequalto.html">Component bdlb_cstringequalto</a>,&nbsp;<a class="el" href="group__bdlb__cstringhash.html">Component bdlb_cstringhash</a>,&nbsp;<a class="el" href="group__bdlb__cstringless.html">Component bdlb_cstringless</a>,&nbsp;<a class="el" href="group__bdlb__float.html">Component bdlb_float</a>,&nbsp;<a class="el" href="group__bdlb__functionoutputiterator.html">Component bdlb_functionoutputiterator</a>,&nbsp;<a class="el" href="group__bdlb__guid.html">Component bdlb_guid</a>,&nbsp;<a class="el" href="group__bdlb__guidutil.html">Component bdlb_guidutil</a>,&nbsp;<a class="el" href="group__bdlb__hashutil.html">Component bdlb_hashutil</a>,&nbsp;<a class="el" href="group__bdlb__nullableallocatedvalue.html">Component bdlb_nullableallocatedvalue</a>,&nbsp;<a class="el" href="group__bdlb__nullablevalue.html">Component bdlb_nullablevalue</a>,&nbsp;<a class="el" href="group__bdlb__nullinputiterator.html">Component bdlb_nullinputiterator</a>,&nbsp;<a class="el" href="group__bdlb__nulloutputiterator.html">Component bdlb_nulloutputiterator</a>,&nbsp;<a class="el" href="group__bdlb__print.html">Component bdlb_print</a>,&nbsp;<a class="el" href="group__bdlb__random.html">Component bdlb_random</a>,&nbsp;<a class="el" href="group__bdlb__randomdevice.html">Component bdlb_randomdevice</a>,&nbsp;<a class="el" href="group__bdlb__string.html">Component bdlb_string</a>,&nbsp;<a class="el" href="group__bdlb__tokenizer.html">Component bdlb_tokenizer</a>,&nbsp;<a class="el" href="group__bdlb__variant.html">Component bdlb_variant</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb_1_1PrintMethods.html">PrintMethods</a></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1ArrayUtil.html">ArrayUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1BigEndianInt16.html">BigEndianInt16</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1BigEndianUint16.html">BigEndianUint16</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1BigEndianInt32.html">BigEndianInt32</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1BigEndianUint32.html">BigEndianUint32</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1BigEndianInt64.html">BigEndianInt64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1BigEndianUint64.html">BigEndianUint64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitMaskUtil.html">BitMaskUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringImpUtil.html">BitStringImpUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html">BitStringUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitUtil.html">BitUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1CharType.html">CharType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1CStringEqualTo.html">CStringEqualTo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1CStringHash.html">CStringHash</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1CStringLess.html">CStringLess</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1Float.html">Float</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1FunctionOutputIterator.html">FunctionOutputIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Guid.html">Guid</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1GuidUtil.html">GuidUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1HashUtil.html">HashUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1NullableAllocatedValue.html">NullableAllocatedValue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1NullableValue.html">NullableValue</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1NullableValue__WithAllocator.html">NullableValue_WithAllocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1NullableValue__WithoutAllocator.html">NullableValue_WithoutAllocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1NullInputIterator.html">NullInputIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1NullOutputIteratorAssignmentProxy.html">NullOutputIteratorAssignmentProxy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1NullOutputIterator.html">NullOutputIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1Print.html">Print</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1PrintStringHexDumper.html">PrintStringHexDumper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1PrintStringSingleLineHexDumper.html">PrintStringSingleLineHexDumper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1HasPrintMethod.html">HasPrintMethod</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1TypeTraitHasPrintMethod.html">TypeTraitHasPrintMethod</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1PrintMethods__Imp_3_01TYPE_00_01bslmf_1_1SelectTraitCase_3_4_01_4.html">PrintMethods_Imp&lt; TYPE, bslmf::SelectTraitCase&lt;&gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1PrintMethods__Imp_3_01TYPE_00_01bslmf_1_1SelectTraitCase_3_01HasPrintMethod_01_4_01_4.html">PrintMethods_Imp&lt; TYPE, bslmf::SelectTraitCase&lt; HasPrintMethod &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1PrintMethods__Imp_3_01TYPE_00_01bslmf_1_1SelectTraitCase_3_01bslalg_1_1HasStlIterators_01_4_01_4.html">PrintMethods_Imp&lt; TYPE, bslmf::SelectTraitCase&lt; bslalg::HasStlIterators &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1PrintMethods__Imp_3_01TYPE_00_01bslmf_1_1SelectTraitCase_3_01bslmf_1_1IsPair_01_4_01_4.html">PrintMethods_Imp&lt; TYPE, bslmf::SelectTraitCase&lt; bslmf::IsPair &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1Random.html">Random</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1RandomDevice.html">RandomDevice</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1String.html">String</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer__Data.html">Tokenizer_Data</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1TokenizerIterator.html">TokenizerIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Tokenizer.html">Tokenizer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1Variant__ReturnValueHelper__NoType.html">Variant_ReturnValueHelper_NoType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp__AllocatorBase.html">VariantImp_AllocatorBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp__NonAllocatorBase.html">VariantImp_NonAllocatorBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1VariantImp__Traits.html">VariantImp_Traits</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1Variant__ReturnAnyTypeUtil.html">Variant_ReturnAnyTypeUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant__RawVisitorHelper.html">Variant_RawVisitorHelper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant.html">Variant</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant2.html">Variant2</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant3.html">Variant3</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant4.html">Variant4</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant5.html">Variant5</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant6.html">Variant6</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant7.html">Variant7</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant8.html">Variant8</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant9.html">Variant9</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant10.html">Variant10</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant11.html">Variant11</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant12.html">Variant12</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant13.html">Variant13</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant14.html">Variant14</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant15.html">Variant15</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant16.html">Variant16</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant17.html">Variant17</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant18.html">Variant18</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1Variant19.html">Variant19</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1Variant__TypeIndex.html">Variant_TypeIndex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1Variant__DefaultConstructVisitor.html">Variant_DefaultConstructVisitor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1Variant__CopyConstructVisitor.html">Variant_CopyConstructVisitor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1Variant__DestructorVisitor.html">Variant_DestructorVisitor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1Variant__AssignVisitor.html">Variant_AssignVisitor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1Variant__SwapVisitor.html">Variant_SwapVisitor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1Variant__PrintVisitor.html">Variant_PrintVisitor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1Variant__EqualityTestVisitor.html">Variant_EqualityTestVisitor</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a31b62ae351deb72fa0149686d8f2af5d">Variant_ReturnValueHelper_YesType</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#ad1f5c4082739436b242d4afd4e9016b2">operator==</a> (const <a class="el" href="classbdlb_1_1BigEndianInt16.html">BigEndianInt16</a> &amp;lhs, const <a class="el" href="classbdlb_1_1BigEndianInt16.html">BigEndianInt16</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a108cda3e7eb7bfd9da9eb13972e85fea">operator!=</a> (const <a class="el" href="classbdlb_1_1BigEndianInt16.html">BigEndianInt16</a> &amp;lhs, const <a class="el" href="classbdlb_1_1BigEndianInt16.html">BigEndianInt16</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a556d66ca87ee41fb0da626c00385272a">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlb_1_1BigEndianInt16.html">BigEndianInt16</a> &amp;integer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a261fb1c8cef7ec2808c80298e20c8c20">operator==</a> (const <a class="el" href="classbdlb_1_1BigEndianUint16.html">BigEndianUint16</a> &amp;lhs, const <a class="el" href="classbdlb_1_1BigEndianUint16.html">BigEndianUint16</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a1795fe50ff9e35a417b8f75d28f02ed3">operator!=</a> (const <a class="el" href="classbdlb_1_1BigEndianUint16.html">BigEndianUint16</a> &amp;lhs, const <a class="el" href="classbdlb_1_1BigEndianUint16.html">BigEndianUint16</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a75ca0a7f6f0c186830b2f61263b4d742">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlb_1_1BigEndianUint16.html">BigEndianUint16</a> &amp;integer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a52f2ca77b22347cfd1dabb9b825b44b4">operator==</a> (const <a class="el" href="classbdlb_1_1BigEndianInt32.html">BigEndianInt32</a> &amp;lhs, const <a class="el" href="classbdlb_1_1BigEndianInt32.html">BigEndianInt32</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#ab94d7c26401a86ad4ea3c99d1497fa1d">operator!=</a> (const <a class="el" href="classbdlb_1_1BigEndianInt32.html">BigEndianInt32</a> &amp;lhs, const <a class="el" href="classbdlb_1_1BigEndianInt32.html">BigEndianInt32</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#adef70b805f6c064c65c52de1b89300ec">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlb_1_1BigEndianInt32.html">BigEndianInt32</a> &amp;integer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a1b54037b4960b5a9a3f362488451d44b">operator==</a> (const <a class="el" href="classbdlb_1_1BigEndianUint32.html">BigEndianUint32</a> &amp;lhs, const <a class="el" href="classbdlb_1_1BigEndianUint32.html">BigEndianUint32</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#aea0e73d2cff37c28793e64fb4d6eceec">operator!=</a> (const <a class="el" href="classbdlb_1_1BigEndianUint32.html">BigEndianUint32</a> &amp;lhs, const <a class="el" href="classbdlb_1_1BigEndianUint32.html">BigEndianUint32</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#ab49adee417169658f5d646f4d73be452">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlb_1_1BigEndianUint32.html">BigEndianUint32</a> &amp;integer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#af6a8a5ecb7b645d051e0f61e86804fe4">operator==</a> (const <a class="el" href="classbdlb_1_1BigEndianInt64.html">BigEndianInt64</a> &amp;lhs, const <a class="el" href="classbdlb_1_1BigEndianInt64.html">BigEndianInt64</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#aab6325d6d3874c8bb23735286e4e9230">operator!=</a> (const <a class="el" href="classbdlb_1_1BigEndianInt64.html">BigEndianInt64</a> &amp;lhs, const <a class="el" href="classbdlb_1_1BigEndianInt64.html">BigEndianInt64</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#ab70f26a345c431198664a1cb386a02f6">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlb_1_1BigEndianInt64.html">BigEndianInt64</a> &amp;integer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#ac7f901381103c48937984a1bfbceecbf">operator==</a> (const <a class="el" href="classbdlb_1_1BigEndianUint64.html">BigEndianUint64</a> &amp;lhs, const <a class="el" href="classbdlb_1_1BigEndianUint64.html">BigEndianUint64</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#af5e7dfc49a669981177f9b2fafa5586a">operator!=</a> (const <a class="el" href="classbdlb_1_1BigEndianUint64.html">BigEndianUint64</a> &amp;lhs, const <a class="el" href="classbdlb_1_1BigEndianUint64.html">BigEndianUint64</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#af0032aa4eae8508bee2401a633b19f33">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlb_1_1BigEndianUint64.html">BigEndianUint64</a> &amp;integer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#ad460f8242041614d9db6ee48bc80ed53">operator&lt;&lt;</a> (bsl::ostream &amp;out, <a class="el" href="structbdlb_1_1CharType.html#a03eda5bfd3ac336da49d9e3b349d9f23">CharType::Category</a> category)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNCTION &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlb_1_1FunctionOutputIterator.html">FunctionOutputIterator</a><br class="typebreak"/>
&lt; FUNCTION &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a699612d059aa6db974f220f6823e4c0d">operator++</a> (<a class="el" href="classbdlb_1_1FunctionOutputIterator.html">FunctionOutputIterator</a>&lt; FUNCTION &gt; &amp;iterator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FUNCTION &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlb_1_1FunctionOutputIterator.html">FunctionOutputIterator</a>&lt; FUNCTION &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a3628a2f1344b4a2051b805978eb6f331">operator++</a> (<a class="el" href="classbdlb_1_1FunctionOutputIterator.html">FunctionOutputIterator</a>&lt; FUNCTION &gt; &amp;iterator, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#aa87851224efdfae6f5f519901c970262">operator==</a> (const <a class="el" href="classbdlb_1_1Guid.html">Guid</a> &amp;lhs, const <a class="el" href="classbdlb_1_1Guid.html">Guid</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#aceb1a703f6f64327cd3cdcd03a557f4a">operator!=</a> (const <a class="el" href="classbdlb_1_1Guid.html">Guid</a> &amp;lhs, const <a class="el" href="classbdlb_1_1Guid.html">Guid</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#ad07f3843b29d0d2bdc6cad3e1fa4a009">operator&lt;</a> (const <a class="el" href="classbdlb_1_1Guid.html">Guid</a> &amp;lhs, const <a class="el" href="classbdlb_1_1Guid.html">Guid</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a7a34722368eab1cbbc91d50056f136d6">operator&lt;=</a> (const <a class="el" href="classbdlb_1_1Guid.html">Guid</a> &amp;lhs, const <a class="el" href="classbdlb_1_1Guid.html">Guid</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#ac2101faf04b1514a514505b0b979d8e9">operator&gt;</a> (const <a class="el" href="classbdlb_1_1Guid.html">Guid</a> &amp;lhs, const <a class="el" href="classbdlb_1_1Guid.html">Guid</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a3d27cd726961d7f3e59d1f4fe0110156">operator&gt;=</a> (const <a class="el" href="classbdlb_1_1Guid.html">Guid</a> &amp;lhs, const <a class="el" href="classbdlb_1_1Guid.html">Guid</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a7192ca5a545d45c7990b607dfba2bb2f">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlb_1_1Guid.html">Guid</a> &amp;guid)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class HASH_ALGORITHM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a55903c875202f0400336538b847a6446">hashAppend</a> (HASH_ALGORITHM &amp;hashAlgorithm, const <a class="el" href="classbdlb_1_1Guid.html">Guid</a> &amp;guid)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a40578ac1b41c797faa2d717e782a7621">operator==</a> (const <a class="el" href="classbdlb_1_1NullableAllocatedValue.html">NullableAllocatedValue</a>&lt; LHS_TYPE &gt; &amp;lhs, const <a class="el" href="classbdlb_1_1NullableAllocatedValue.html">NullableAllocatedValue</a>&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a24a00e6b256ac4fab99bc2091a39edc1">operator!=</a> (const <a class="el" href="classbdlb_1_1NullableAllocatedValue.html">NullableAllocatedValue</a>&lt; LHS_TYPE &gt; &amp;lhs, const <a class="el" href="classbdlb_1_1NullableAllocatedValue.html">NullableAllocatedValue</a>&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#aea655d39e3d21543dfa1a7f6d7665341">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlb_1_1NullableAllocatedValue.html">NullableAllocatedValue</a>&lt; TYPE &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#ae0aca5201031bd8024f208a2af2d3df6">swap</a> (<a class="el" href="classbdlb_1_1NullableAllocatedValue.html">NullableAllocatedValue</a>&lt; TYPE &gt; &amp;a, <a class="el" href="classbdlb_1_1NullableAllocatedValue.html">NullableAllocatedValue</a>&lt; TYPE &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#aecd4c4e3c045415b9da8706a7f70a160">operator==</a> (const <a class="el" href="classbdlb_1_1NullableValue.html">NullableValue</a>&lt; LHS_TYPE &gt; &amp;lhs, const <a class="el" href="classbdlb_1_1NullableValue.html">NullableValue</a>&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a2ba82ca21801874141b8215923e214d9">operator!=</a> (const <a class="el" href="classbdlb_1_1NullableValue.html">NullableValue</a>&lt; LHS_TYPE &gt; &amp;lhs, const <a class="el" href="classbdlb_1_1NullableValue.html">NullableValue</a>&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a73973c3b291f09fd46aa3c48d20edbb4">operator==</a> (const <a class="el" href="classbdlb_1_1NullableValue.html">NullableValue</a>&lt; TYPE &gt; &amp;lhs, const TYPE &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a946a520ee7e4500461aa46e05a7cfd0e">operator==</a> (const TYPE &amp;lhs, const <a class="el" href="classbdlb_1_1NullableValue.html">NullableValue</a>&lt; TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#aabcd0fd9b9400520f32e54edb6f942df">operator!=</a> (const <a class="el" href="classbdlb_1_1NullableValue.html">NullableValue</a>&lt; TYPE &gt; &amp;lhs, const TYPE &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a635f6fd1cb4c20bada24d9e3ffb5d8b5">operator!=</a> (const TYPE &amp;lhs, const <a class="el" href="classbdlb_1_1NullableValue.html">NullableValue</a>&lt; TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a197c6b82922bffbb53f53ac6bc4b5f20">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlb_1_1NullableValue.html">NullableValue</a>&lt; TYPE &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a6cbb5e85de005508b8134ccc6340269f">swap</a> (<a class="el" href="classbdlb_1_1NullableValue.html">NullableValue</a>&lt; TYPE &gt; &amp;a, <a class="el" href="classbdlb_1_1NullableValue.html">NullableValue</a>&lt; TYPE &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#ab834af7f1661038ed2eef136a9642be7">operator==</a> (const <a class="el" href="classbdlb_1_1NullInputIterator.html">NullInputIterator</a>&lt; TYPE &gt; &amp;lhs, const <a class="el" href="classbdlb_1_1NullInputIterator.html">NullInputIterator</a>&lt; TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a042a42bf4f1a086785dec81dec72e56c">operator!=</a> (const <a class="el" href="classbdlb_1_1NullInputIterator.html">NullInputIterator</a>&lt; TYPE &gt; &amp;lhs, const <a class="el" href="classbdlb_1_1NullInputIterator.html">NullInputIterator</a>&lt; TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a05d9460124670378bb931277191ebdbb">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="structbdlb_1_1PrintStringHexDumper.html">PrintStringHexDumper</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a73457355e2a0db761d3b421c6d239fa2">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="structbdlb_1_1PrintStringSingleLineHexDumper.html">PrintStringSingleLineHexDumper</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#af215469782cf54b40b99022eb187c3db">operator==</a> (const <a class="el" href="classbdlb_1_1TokenizerIterator.html">TokenizerIterator</a> &amp;lhs, const <a class="el" href="classbdlb_1_1TokenizerIterator.html">TokenizerIterator</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#ae4edddca8cf67e0b0779ff6fd914b5dc">operator!=</a> (const <a class="el" href="classbdlb_1_1TokenizerIterator.html">TokenizerIterator</a> &amp;lhs, const <a class="el" href="classbdlb_1_1TokenizerIterator.html">TokenizerIterator</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbdlb_1_1TokenizerIterator.html">TokenizerIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a7f3abcf75ea24ab8769e15ee1a033c92">operator++</a> (<a class="el" href="classbdlb_1_1TokenizerIterator.html">TokenizerIterator</a> &amp;object, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbdlb_1_1Tokenizer.html">Tokenizer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a9f3beaa565d724cafac4648afab98e7e">operator++</a> (<a class="el" href="classbdlb_1_1Tokenizer.html">Tokenizer</a> &amp;object, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPES &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#ad5774a1111ee874612c763a4c40ffdac">operator==</a> (const <a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; TYPES &gt; &amp;lhs, const <a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; TYPES &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPES &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a2ac44cc0eb4d3a118fab3eea612a6939">operator!=</a> (const <a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; TYPES &gt; &amp;lhs, const <a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; TYPES &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPES &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a431d8849012c0e520e439c772ad57ded">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; TYPES &gt; &amp;object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPES &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlb.html#a182cede82b03848950e1ac2e8eb01604">swap</a> (<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; TYPES &gt; &amp;a, <a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; TYPES &gt; &amp;b)</td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a31b62ae351deb72fa0149686d8f2af5d"></a><!-- doxytag: member="bdlb::Variant_ReturnValueHelper_YesType" ref="a31b62ae351deb72fa0149686d8f2af5d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="namespacebdlb.html#a31b62ae351deb72fa0149686d8f2af5d">bdlb::Variant_ReturnValueHelper_YesType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad1f5c4082739436b242d4afd4e9016b2"></a><!-- doxytag: member="bdlb::operator==" ref="ad1f5c4082739436b242d4afd4e9016b2" args="(const BigEndianInt16 &amp;lhs, const BigEndianInt16 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator== </td>
          <td>(</td>
          <td class="paramtype">const BigEndianInt16 &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianInt16 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlb_1_1BigEndianInt16.html">BigEndianInt16</a></code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlb_1_1BigEndianInt16.html">BigEndianInt16</a></code> objects have the same value if and only if the respective integral network byte-order values that they represent have the same value. </p>

</div>
</div>
<a class="anchor" id="a108cda3e7eb7bfd9da9eb13972e85fea"></a><!-- doxytag: member="bdlb::operator!=" ref="a108cda3e7eb7bfd9da9eb13972e85fea" args="(const BigEndianInt16 &amp;lhs, const BigEndianInt16 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const BigEndianInt16 &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianInt16 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlb_1_1BigEndianInt16.html">BigEndianInt16</a></code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlb_1_1BigEndianInt16.html">BigEndianInt16</a></code> objects do not have the same value if and only if the respective integral network byte-order values that they represent do not have the same value. </p>

</div>
</div>
<a class="anchor" id="a556d66ca87ee41fb0da626c00385272a"></a><!-- doxytag: member="bdlb::operator&lt;&lt;" ref="a556d66ca87ee41fb0da626c00385272a" args="(bsl::ostream &amp;stream, const BigEndianInt16 &amp;integer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlb::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianInt16 &amp;&nbsp;</td>
          <td class="paramname"> <em>integer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>integer</code> to the specified output <code>stream</code> and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a261fb1c8cef7ec2808c80298e20c8c20"></a><!-- doxytag: member="bdlb::operator==" ref="a261fb1c8cef7ec2808c80298e20c8c20" args="(const BigEndianUint16 &amp;lhs, const BigEndianUint16 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator== </td>
          <td>(</td>
          <td class="paramtype">const BigEndianUint16 &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianUint16 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlb_1_1BigEndianUint16.html">BigEndianUint16</a></code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlb_1_1BigEndianUint16.html">BigEndianUint16</a></code> objects have the same value if and only if the respective integral network byte-order values that they represent have the same value. </p>

</div>
</div>
<a class="anchor" id="a1795fe50ff9e35a417b8f75d28f02ed3"></a><!-- doxytag: member="bdlb::operator!=" ref="a1795fe50ff9e35a417b8f75d28f02ed3" args="(const BigEndianUint16 &amp;lhs, const BigEndianUint16 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const BigEndianUint16 &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianUint16 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlb_1_1BigEndianUint16.html">BigEndianUint16</a></code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlb_1_1BigEndianUint16.html">BigEndianUint16</a></code> objects do not have the same value if and only if the respective integral network byte-order values that they represent do not have the same value. </p>

</div>
</div>
<a class="anchor" id="a75ca0a7f6f0c186830b2f61263b4d742"></a><!-- doxytag: member="bdlb::operator&lt;&lt;" ref="a75ca0a7f6f0c186830b2f61263b4d742" args="(bsl::ostream &amp;stream, const BigEndianUint16 &amp;integer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlb::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianUint16 &amp;&nbsp;</td>
          <td class="paramname"> <em>integer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>integer</code> to the specified output <code>stream</code>, and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a52f2ca77b22347cfd1dabb9b825b44b4"></a><!-- doxytag: member="bdlb::operator==" ref="a52f2ca77b22347cfd1dabb9b825b44b4" args="(const BigEndianInt32 &amp;lhs, const BigEndianInt32 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator== </td>
          <td>(</td>
          <td class="paramtype">const BigEndianInt32 &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianInt32 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlb_1_1BigEndianInt32.html">BigEndianInt32</a></code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlb_1_1BigEndianInt32.html">BigEndianInt32</a></code> objects have the same value if and only if the respective integral network byte-order values that they represent have the same value. </p>

</div>
</div>
<a class="anchor" id="ab94d7c26401a86ad4ea3c99d1497fa1d"></a><!-- doxytag: member="bdlb::operator!=" ref="ab94d7c26401a86ad4ea3c99d1497fa1d" args="(const BigEndianInt32 &amp;lhs, const BigEndianInt32 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const BigEndianInt32 &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianInt32 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlb_1_1BigEndianInt32.html">BigEndianInt32</a></code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlb_1_1BigEndianInt32.html">BigEndianInt32</a></code> objects do not have the same value if and only if the respective integral network byte-order values that they represent do not have the same value. </p>

</div>
</div>
<a class="anchor" id="adef70b805f6c064c65c52de1b89300ec"></a><!-- doxytag: member="bdlb::operator&lt;&lt;" ref="adef70b805f6c064c65c52de1b89300ec" args="(bsl::ostream &amp;stream, const BigEndianInt32 &amp;integer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlb::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianInt32 &amp;&nbsp;</td>
          <td class="paramname"> <em>integer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>integer</code> to the specified output <code>stream</code>, and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a1b54037b4960b5a9a3f362488451d44b"></a><!-- doxytag: member="bdlb::operator==" ref="a1b54037b4960b5a9a3f362488451d44b" args="(const BigEndianUint32 &amp;lhs, const BigEndianUint32 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator== </td>
          <td>(</td>
          <td class="paramtype">const BigEndianUint32 &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianUint32 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlb_1_1BigEndianUint32.html">BigEndianUint32</a></code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlb_1_1BigEndianUint32.html">BigEndianUint32</a></code> objects have the same value if and only if the respective integral network byte-order values that they represent have the same value. </p>

</div>
</div>
<a class="anchor" id="aea0e73d2cff37c28793e64fb4d6eceec"></a><!-- doxytag: member="bdlb::operator!=" ref="aea0e73d2cff37c28793e64fb4d6eceec" args="(const BigEndianUint32 &amp;lhs, const BigEndianUint32 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const BigEndianUint32 &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianUint32 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlb_1_1BigEndianUint32.html">BigEndianUint32</a></code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlb_1_1BigEndianUint32.html">BigEndianUint32</a></code> objects do not have the same value if and only if the respective integral network byte-order values that they represent do not have the same value. </p>

</div>
</div>
<a class="anchor" id="ab49adee417169658f5d646f4d73be452"></a><!-- doxytag: member="bdlb::operator&lt;&lt;" ref="ab49adee417169658f5d646f4d73be452" args="(bsl::ostream &amp;stream, const BigEndianUint32 &amp;integer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlb::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianUint32 &amp;&nbsp;</td>
          <td class="paramname"> <em>integer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>integer</code> to the specified output <code>stream</code>, and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="af6a8a5ecb7b645d051e0f61e86804fe4"></a><!-- doxytag: member="bdlb::operator==" ref="af6a8a5ecb7b645d051e0f61e86804fe4" args="(const BigEndianInt64 &amp;lhs, const BigEndianInt64 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator== </td>
          <td>(</td>
          <td class="paramtype">const BigEndianInt64 &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianInt64 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlb_1_1BigEndianInt64.html">BigEndianInt64</a></code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlb_1_1BigEndianInt64.html">BigEndianInt64</a></code> objects have the same value if and only if the respective integral network byte-order values that they represent have the same value. </p>

</div>
</div>
<a class="anchor" id="aab6325d6d3874c8bb23735286e4e9230"></a><!-- doxytag: member="bdlb::operator!=" ref="aab6325d6d3874c8bb23735286e4e9230" args="(const BigEndianInt64 &amp;lhs, const BigEndianInt64 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const BigEndianInt64 &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianInt64 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlb_1_1BigEndianInt64.html">BigEndianInt64</a></code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlb_1_1BigEndianInt64.html">BigEndianInt64</a></code> objects do not have the same value if and only if the respective integral network byte-order values that they represent do not have the same value. </p>

</div>
</div>
<a class="anchor" id="ab70f26a345c431198664a1cb386a02f6"></a><!-- doxytag: member="bdlb::operator&lt;&lt;" ref="ab70f26a345c431198664a1cb386a02f6" args="(bsl::ostream &amp;stream, const BigEndianInt64 &amp;integer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlb::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianInt64 &amp;&nbsp;</td>
          <td class="paramname"> <em>integer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>integer</code> to the specified output <code>stream</code>, and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="ac7f901381103c48937984a1bfbceecbf"></a><!-- doxytag: member="bdlb::operator==" ref="ac7f901381103c48937984a1bfbceecbf" args="(const BigEndianUint64 &amp;lhs, const BigEndianUint64 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator== </td>
          <td>(</td>
          <td class="paramtype">const BigEndianUint64 &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianUint64 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlb_1_1BigEndianUint64.html">BigEndianUint64</a></code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlb_1_1BigEndianUint64.html">BigEndianUint64</a></code> objects have the same value if and only if the respective integral network byte-order values that they represent have the same value. </p>

</div>
</div>
<a class="anchor" id="af5e7dfc49a669981177f9b2fafa5586a"></a><!-- doxytag: member="bdlb::operator!=" ref="af5e7dfc49a669981177f9b2fafa5586a" args="(const BigEndianUint64 &amp;lhs, const BigEndianUint64 &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const BigEndianUint64 &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianUint64 &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlb_1_1BigEndianUint64.html">BigEndianUint64</a></code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlb_1_1BigEndianUint64.html">BigEndianUint64</a></code> objects do not have the same value if and only if the respective integral network byte-order values that they represent do not have the same value. </p>

</div>
</div>
<a class="anchor" id="af0032aa4eae8508bee2401a633b19f33"></a><!-- doxytag: member="bdlb::operator&lt;&lt;" ref="af0032aa4eae8508bee2401a633b19f33" args="(bsl::ostream &amp;stream, const BigEndianUint64 &amp;integer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlb::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BigEndianUint64 &amp;&nbsp;</td>
          <td class="paramname"> <em>integer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>integer</code> to the specified output <code>stream</code>, and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="ad460f8242041614d9db6ee48bc80ed53"></a><!-- doxytag: member="bdlb::operator&lt;&lt;" ref="ad460f8242041614d9db6ee48bc80ed53" args="(bsl::ostream &amp;out, CharType::Category category)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlb::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharType::Category&nbsp;</td>
          <td class="paramname"> <em>category</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified character <code>category</code> enumerator to the specified output stream as a string that is identical to the enumerator name. </p>

</div>
</div>
<a class="anchor" id="a699612d059aa6db974f220f6823e4c0d"></a><!-- doxytag: member="bdlb::operator++" ref="a699612d059aa6db974f220f6823e4c0d" args="(FunctionOutputIterator&lt; FUNCTION &gt; &amp;iterator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNCTION &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1FunctionOutputIterator.html">FunctionOutputIterator</a>&lt;FUNCTION&gt;&amp; bdlb::operator++ </td>
          <td>(</td>
          <td class="paramtype">FunctionOutputIterator&lt; FUNCTION &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iterator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Do nothing and return specified <code>iterator</code>. </p>

</div>
</div>
<a class="anchor" id="a3628a2f1344b4a2051b805978eb6f331"></a><!-- doxytag: member="bdlb::operator++" ref="a3628a2f1344b4a2051b805978eb6f331" args="(FunctionOutputIterator&lt; FUNCTION &gt; &amp;iterator, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FUNCTION &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1FunctionOutputIterator.html">FunctionOutputIterator</a>&lt;FUNCTION&gt; bdlb::operator++ </td>
          <td>(</td>
          <td class="paramtype">FunctionOutputIterator&lt; FUNCTION &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Do nothing and return specified <code>iterator</code>. </p>

</div>
</div>
<a class="anchor" id="aa87851224efdfae6f5f519901c970262"></a><!-- doxytag: member="bdlb::operator==" ref="aa87851224efdfae6f5f519901c970262" args="(const Guid &amp;lhs, const Guid &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator== </td>
          <td>(</td>
          <td class="paramtype">const Guid &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Guid &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and specified <code>rhs</code> guid objects have the same value, and <code>false</code> otherwise. Two guid objects have the same value if each corresponding byte in their internal buffers are equal. </p>

</div>
</div>
<a class="anchor" id="aceb1a703f6f64327cd3cdcd03a557f4a"></a><!-- doxytag: member="bdlb::operator!=" ref="aceb1a703f6f64327cd3cdcd03a557f4a" args="(const Guid &amp;lhs, const Guid &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Guid &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Guid &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and specified <code>rhs</code> guid objects have different values, and <code>false</code> otherwise. Two guid objects have different value if any of corresponding byte in their internal buffers differ. </p>

</div>
</div>
<a class="anchor" id="ad07f3843b29d0d2bdc6cad3e1fa4a009"></a><!-- doxytag: member="bdlb::operator&lt;" ref="ad07f3843b29d0d2bdc6cad3e1fa4a009" args="(const Guid &amp;lhs, const Guid &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Guid &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Guid &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the value of the specified <code>lhs</code> guid object is less than the value of the specified <code>rhs</code> guid object, and <code>false</code> otherwise. Note that the comparison is accomplished using a lexicographic comparison of the internal representations. </p>

</div>
</div>
<a class="anchor" id="a7a34722368eab1cbbc91d50056f136d6"></a><!-- doxytag: member="bdlb::operator&lt;=" ref="a7a34722368eab1cbbc91d50056f136d6" args="(const Guid &amp;lhs, const Guid &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Guid &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Guid &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the value of the specified <code>lhs</code> guid object is less than or equal to the value of the specified <code>rhs</code> guid object, and <code>false</code> otherwise. Note that the comparison is accomplished using a lexicographic comparison of the internal representations. </p>

</div>
</div>
<a class="anchor" id="ac2101faf04b1514a514505b0b979d8e9"></a><!-- doxytag: member="bdlb::operator&gt;" ref="ac2101faf04b1514a514505b0b979d8e9" args="(const Guid &amp;lhs, const Guid &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Guid &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Guid &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the value of the specified <code>lhs</code> guid object is greater than the value of the specified <code>rhs</code> guid object, and <code>false</code> otherwise. Note that the comparison is accomplished using a lexicographic comparison of the internal representations. </p>

</div>
</div>
<a class="anchor" id="a3d27cd726961d7f3e59d1f4fe0110156"></a><!-- doxytag: member="bdlb::operator&gt;=" ref="a3d27cd726961d7f3e59d1f4fe0110156" args="(const Guid &amp;lhs, const Guid &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Guid &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Guid &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the value of the specified <code>lhs</code> guid object is greater than or equal to the value of the specified <code>rhs</code> guid object, and <code>false</code> otherwise. Note that the comparison is accomplished using a lexicographic comparison of the internal representations. </p>

</div>
</div>
<a class="anchor" id="a7192ca5a545d45c7990b607dfba2bb2f"></a><!-- doxytag: member="bdlb::operator&lt;&lt;" ref="a7192ca5a545d45c7990b607dfba2bb2f" args="(bsl::ostream &amp;stream, const Guid &amp;guid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlb::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Guid &amp;&nbsp;</td>
          <td class="paramname"> <em>guid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>guid</code> object to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified, can change without notice, and is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(stream, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a55903c875202f0400336538b847a6446"></a><!-- doxytag: member="bdlb::hashAppend" ref="a55903c875202f0400336538b847a6446" args="(HASH_ALGORITHM &amp;hashAlgorithm, const Guid &amp;guid)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HASH_ALGORITHM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlb::hashAppend </td>
          <td>(</td>
          <td class="paramtype">HASH_ALGORITHM &amp;&nbsp;</td>
          <td class="paramname"> <em>hashAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Guid &amp;&nbsp;</td>
          <td class="paramname"> <em>guid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke the specified <code>hashAlgorithm</code> on the underlying buffer held by the specified <code>guid</code> object. </p>

</div>
</div>
<a class="anchor" id="a40578ac1b41c797faa2d717e782a7621"></a><!-- doxytag: member="bdlb::operator==" ref="a40578ac1b41c797faa2d717e782a7621" args="(const NullableAllocatedValue&lt; LHS_TYPE &gt; &amp;lhs, const NullableAllocatedValue&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator== </td>
          <td>(</td>
          <td class="paramtype">const NullableAllocatedValue&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NullableAllocatedValue&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> nullable objects have the same value, and <code>false</code> otherwise. Two nullable objects have the same value if both are null, or if both are non-null and the values of their underlying objects compare equal. Note that this function will fail to compile if <code>LHS_TYPE</code> and <code>RHS_TYPE</code> are not compatible. </p>

</div>
</div>
<a class="anchor" id="a24a00e6b256ac4fab99bc2091a39edc1"></a><!-- doxytag: member="bdlb::operator!=" ref="a24a00e6b256ac4fab99bc2091a39edc1" args="(const NullableAllocatedValue&lt; LHS_TYPE &gt; &amp;lhs, const NullableAllocatedValue&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const NullableAllocatedValue&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NullableAllocatedValue&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> nullable objects do not have the same value, and <code>false</code> otherwise. Two nullable objects do not have the same value if one is null and the other is non-null, or if both are non-null and the values of their underlying objects do not compare equal. Note that this function will fail to compile if <code>LHS_TYPE</code> and <code>RHS_TYPE</code> are not compatible. </p>

</div>
</div>
<a class="anchor" id="aea655d39e3d21543dfa1a7f6d7665341"></a><!-- doxytag: member="bdlb::operator&lt;&lt;" ref="aea655d39e3d21543dfa1a7f6d7665341" args="(bsl::ostream &amp;stream, const NullableAllocatedValue&lt; TYPE &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlb::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NullableAllocatedValue&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>object</code> to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified, can change without notice, and is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(stream, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ae0aca5201031bd8024f208a2af2d3df6"></a><!-- doxytag: member="bdlb::swap" ref="ae0aca5201031bd8024f208a2af2d3df6" args="(NullableAllocatedValue&lt; TYPE &gt; &amp;a, NullableAllocatedValue&lt; TYPE &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlb::swap </td>
          <td>(</td>
          <td class="paramtype">NullableAllocatedValue&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullableAllocatedValue&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the values of the specified <code>a</code> and <code>b</code> objects. This method provides the no-throw exception-safety guarantee if the template parameter <code>TYPE</code> provides that guarantee and the result of the <code>isNull</code> method for <code>a</code> and <code>b</code> is the same. The behavior is undefined unless both objects were created with the same allocator. </p>

<p>Referenced by <a class="el" href="structbdlb_1_1Variant__SwapVisitor.html#abab5f56eed62ac55b87fb3f79e3ad59b">bdlb::Variant_SwapVisitor::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="aecd4c4e3c045415b9da8706a7f70a160"></a><!-- doxytag: member="bdlb::operator==" ref="aecd4c4e3c045415b9da8706a7f70a160" args="(const NullableValue&lt; LHS_TYPE &gt; &amp;lhs, const NullableValue&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator== </td>
          <td>(</td>
          <td class="paramtype">const NullableValue&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NullableValue&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> nullable objects have the same value, and <code>false</code> otherwise. Two nullable objects have the same value if both are null, or if both are non-null and the values of their underlying objects compare equal. Note that this function will fail to compile if <code>LHS_TYPE</code> and <code>RHS_TYPE</code> are not compatible. </p>

</div>
</div>
<a class="anchor" id="a2ba82ca21801874141b8215923e214d9"></a><!-- doxytag: member="bdlb::operator!=" ref="a2ba82ca21801874141b8215923e214d9" args="(const NullableValue&lt; LHS_TYPE &gt; &amp;lhs, const NullableValue&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const NullableValue&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NullableValue&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> nullable objects do not have the same value, and <code>false</code> otherwise. Two nullable objects do not have the same value if one is null and the other is non-null, or if both are non-null and the values of their underlying objects do not compare equal. Note that this function will fail to compile if <code>LHS_TYPE</code> and <code>RHS_TYPE</code> are not compatible. </p>

</div>
</div>
<a class="anchor" id="a73973c3b291f09fd46aa3c48d20edbb4"></a><!-- doxytag: member="bdlb::operator==" ref="a73973c3b291f09fd46aa3c48d20edbb4" args="(const NullableValue&lt; TYPE &gt; &amp;lhs, const TYPE &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator== </td>
          <td>(</td>
          <td class="paramtype">const NullableValue&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a946a520ee7e4500461aa46e05a7cfd0e"></a><!-- doxytag: member="bdlb::operator==" ref="a946a520ee7e4500461aa46e05a7cfd0e" args="(const TYPE &amp;lhs, const NullableValue&lt; TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator== </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NullableValue&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. A nullable object and a value of the underlying <code>TYPE</code> have the same value if the nullable object is non-null and its underlying value compares equal to the other value. </p>

</div>
</div>
<a class="anchor" id="aabcd0fd9b9400520f32e54edb6f942df"></a><!-- doxytag: member="bdlb::operator!=" ref="aabcd0fd9b9400520f32e54edb6f942df" args="(const NullableValue&lt; TYPE &gt; &amp;lhs, const TYPE &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const NullableValue&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a635f6fd1cb4c20bada24d9e3ffb5d8b5"></a><!-- doxytag: member="bdlb::operator!=" ref="a635f6fd1cb4c20bada24d9e3ffb5d8b5" args="(const TYPE &amp;lhs, const NullableValue&lt; TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NullableValue&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. A nullable object and a value of the underlying <code>TYPE</code> do not have the same value if either the nullable object is null, or its underlying value does not compare equal to the other value. </p>

</div>
</div>
<a class="anchor" id="a197c6b82922bffbb53f53ac6bc4b5f20"></a><!-- doxytag: member="bdlb::operator&lt;&lt;" ref="a197c6b82922bffbb53f53ac6bc4b5f20" args="(bsl::ostream &amp;stream, const NullableValue&lt; TYPE &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlb::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NullableValue&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>object</code> to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified, can change without notice, and is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(stream, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a6cbb5e85de005508b8134ccc6340269f"></a><!-- doxytag: member="bdlb::swap" ref="a6cbb5e85de005508b8134ccc6340269f" args="(NullableValue&lt; TYPE &gt; &amp;a, NullableValue&lt; TYPE &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlb::swap </td>
          <td>(</td>
          <td class="paramtype">NullableValue&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullableValue&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the values of the specified <code>a</code> and <code>b</code> objects. This method provides the no-throw exception-safety guarantee if the template parameter <code>TYPE</code> provides that guarantee and the result of the <code>isNull</code> method for <code>a</code> and <code>b</code> is the same. The behavior is undefined unless both objects were created with the same allocator, if any. </p>

</div>
</div>
<a class="anchor" id="ab834af7f1661038ed2eef136a9642be7"></a><!-- doxytag: member="bdlb::operator==" ref="ab834af7f1661038ed2eef136a9642be7" args="(const NullInputIterator&lt; TYPE &gt; &amp;lhs, const NullInputIterator&lt; TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator== </td>
          <td>(</td>
          <td class="paramtype">const NullInputIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NullInputIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> since the specified <code>lhs</code> iterator always has the same value as the specified <code>rhs</code> iterator. </p>

</div>
</div>
<a class="anchor" id="a042a42bf4f1a086785dec81dec72e56c"></a><!-- doxytag: member="bdlb::operator!=" ref="a042a42bf4f1a086785dec81dec72e56c" args="(const NullInputIterator&lt; TYPE &gt; &amp;lhs, const NullInputIterator&lt; TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const NullInputIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NullInputIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>false</code> since the specified <code>lhs</code> iterator always has the same value as the specified <code>rhs</code> iterator. </p>

</div>
</div>
<a class="anchor" id="a05d9460124670378bb931277191ebdbb"></a><!-- doxytag: member="bdlb::operator&lt;&lt;" ref="a05d9460124670378bb931277191ebdbb" args="(bsl::ostream &amp;stream, const PrintStringHexDumper &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlb::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PrintStringHexDumper &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Hex dump the data referenced by the specified <code>rhs</code> to the specified <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a73457355e2a0db761d3b421c6d239fa2"></a><!-- doxytag: member="bdlb::operator&lt;&lt;" ref="a73457355e2a0db761d3b421c6d239fa2" args="(bsl::ostream &amp;stream, const PrintStringSingleLineHexDumper &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlb::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PrintStringSingleLineHexDumper &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Hex dump the data referenced by the specified <code>rhs</code> to the specified <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="af215469782cf54b40b99022eb187c3db"></a><!-- doxytag: member="bdlb::operator==" ref="af215469782cf54b40b99022eb187c3db" args="(const TokenizerIterator &amp;lhs, const TokenizerIterator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator== </td>
          <td>(</td>
          <td class="paramtype">const TokenizerIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TokenizerIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlb_1_1TokenizerIterator.html">TokenizerIterator</a></code> objects have the same value if both of them are pointing to the same token within the same tokenized string or if they both point past the tokenized string. The behaviour is undefined unless the iterators returned by the same <code><a class="el" href="classbdlb_1_1Tokenizer.html">Tokenizer</a></code> object, or if the underlying input has been modified or destroyed since any of those objects were created. </p>

</div>
</div>
<a class="anchor" id="ae4edddca8cf67e0b0779ff6fd914b5dc"></a><!-- doxytag: member="bdlb::operator!=" ref="ae4edddca8cf67e0b0779ff6fd914b5dc" args="(const TokenizerIterator &amp;lhs, const TokenizerIterator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const TokenizerIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TokenizerIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. The behaviour is undefined unless the iterators returned by the same <code><a class="el" href="classbdlb_1_1Tokenizer.html">Tokenizer</a></code> object, or if the underlying input has been modified or destroyed since any of those objects were created. </p>

</div>
</div>
<a class="anchor" id="a7f3abcf75ea24ab8769e15ee1a033c92"></a><!-- doxytag: member="bdlb::operator++" ref="a7f3abcf75ea24ab8769e15ee1a033c92" args="(TokenizerIterator &amp;object, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbdlb_1_1TokenizerIterator.html">TokenizerIterator</a> bdlb::operator++ </td>
          <td>(</td>
          <td class="paramtype">TokenizerIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Advance the iteration state of the specified <code>object</code> to refer to the next token in the underlying input sequence, and return a copy of this object prior advancing the iteration state. The behavior is undefined unless the iteration state of this object is initially valid, or if the underlying input has been modified or destroyed since this object was created. </p>

</div>
</div>
<a class="anchor" id="a9f3beaa565d724cafac4648afab98e7e"></a><!-- doxytag: member="bdlb::operator++" ref="a9f3beaa565d724cafac4648afab98e7e" args="(Tokenizer &amp;object, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbdlb_1_1Tokenizer.html">Tokenizer</a> bdlb::operator++ </td>
          <td>(</td>
          <td class="paramtype">Tokenizer &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad5774a1111ee874612c763a4c40ffdac"></a><!-- doxytag: member="bdlb::operator==" ref="ad5774a1111ee874612c763a4c40ffdac" args="(const VariantImp&lt; TYPES &gt; &amp;lhs, const VariantImp&lt; TYPES &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator== </td>
          <td>(</td>
          <td class="paramtype">const VariantImp&lt; TYPES &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VariantImp&lt; TYPES &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> variant object has the same value as the specified <code>rhs</code> variant object, and <code>false</code> otherwise. Two variant objects have the same value if they are both set and hold objects of the same type and same value, or are both unset. </p>

</div>
</div>
<a class="anchor" id="a2ac44cc0eb4d3a118fab3eea612a6939"></a><!-- doxytag: member="bdlb::operator!=" ref="a2ac44cc0eb4d3a118fab3eea612a6939" args="(const VariantImp&lt; TYPES &gt; &amp;lhs, const VariantImp&lt; TYPES &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlb::operator!= </td>
          <td>(</td>
          <td class="paramtype">const VariantImp&lt; TYPES &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VariantImp&lt; TYPES &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> variant object does not have the same value as the specified <code>rhs</code> variant object, and <code>false</code> otherwise. Two variant objects do not have the same value if one is set and the other is unset, or if they are both set but hold objects that differ in type or value. </p>

</div>
</div>
<a class="anchor" id="a431d8849012c0e520e439c772ad57ded"></a><!-- doxytag: member="bdlb::operator&lt;&lt;" ref="a431d8849012c0e520e439c772ad57ded" args="(bsl::ostream &amp;stream, const VariantImp&lt; TYPES &gt; &amp;object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlb::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VariantImp&lt; TYPES &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified variant <code>object</code> to the specified output <code>stream</code> in a single-line (human-readable) format, and return a reference to <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a182cede82b03848950e1ac2e8eb01604"></a><!-- doxytag: member="bdlb::swap" ref="a182cede82b03848950e1ac2e8eb01604" args="(VariantImp&lt; TYPES &gt; &amp;a, VariantImp&lt; TYPES &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlb::swap </td>
          <td>(</td>
          <td class="paramtype">VariantImp&lt; TYPES &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VariantImp&lt; TYPES &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap the values of the specified <code>a</code> and <code>b</code> objects. This method provides the no-throw guarantee if the <code>TYPE</code> template parameter has a no-throw <code>swap</code> and the two variant objects being swapped has the same type; otherwise this method provides the basic guarantee. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:33 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
