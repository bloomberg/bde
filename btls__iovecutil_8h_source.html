<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// btls_iovecutil.h                                                   -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BTLS_IOVECUTIL
#define INCLUDED_BTLS_IOVECUTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide utilities to manipulate iovec structures.
//
//@CLASSES:
//  btls::IovecUtil: namespace for iovec manipulation utilities
//
//@SEE_ALSO: btls_iovec
//
//@DESCRIPTION: This component provides a namespace &#39;btls::IovecUtil&#39; for
// several utilities for accessing and manipulating sequences of &#39;btls::Iovec&#39;
// and &#39;btls::Ovec&#39; buffers, including &#39;scatter&#39;-ing (&#39;gather&#39;-ing) a single
// continuous buffer into (from) a sequence of buffers, computing the total
// length of a sequence of buffers, and rewriting the data from a sequence of
// buffers into a &#39;btlb::Blob&#39; object.
//
///Thread Safety
///-------------
// It is safe to invoke methods of this utility with distinct instances of
// their arguments in different threads.  It is safe to access a &#39;btlb::Blob&#39;
// object within different methods of this utility from different threads if no
// method modifies the contents of that object.  It is not safe to access or
// modify a &#39;btlb::Blob&#39; object from any method of this utility while a method
// modifies the content of this object.
//
///Performance
///-----------
// Computing &#39;length&#39; takes time proportional to the number of buffers in the
// sequence.  All other methods take time proportional to the total length of
// the buffers in the sequence.
//
///Usage
///-----
//..
//..

#ifndef INCLUDED_BTLSCM_VERSION
#include &lt;btlscm_version.h&gt;
#endif

#ifndef INCLUDED_BTLS_IOVEC
#include &lt;btls_iovec.h&gt;
#endif

                          // =====================
                          // class btls::IovecUtil
                          // =====================

namespace BloombergLP {
namespace bslma  { class Allocator; }
namespace btlb { class Blob; }
namespace btlb { class BlobBufferFactory; }
namespace btls {

struct IovecUtil {
    // This &#39;struct&#39; provides a namespace for several utilities for
    // manipulating &#39;Iovecs&#39;, including scatter/gather from a single continuous
    // buffer into an iovec structure, computing the length of an iovec
    // structure, and rewriting the data in an iovec structure into a
    // &#39;btlb::Blob&#39;.

    static void appendToBlob(btlb::Blob  *blob,
                             const Iovec *buffers,
                             int          numBuffers,
                             int          offset = 0);
    static void appendToBlob(btlb::Blob *blob,
                             const Ovec *buffers,
                             int         numBuffers,
                             int         offset = 0);
        // Append to the specified &#39;blob&#39; the data in the specified sequence of
        // &#39;buffers&#39; of the specified &#39;numBuffers&#39; length.  Optionally specify
        // an &#39;offset&#39; (in bytes) in the data contained in the &#39;buffers&#39; to
        // indicate the start of the appended data; if offset is not specified,
        // then start at offset 0 (i.e., use all the &#39;buffers&#39;).  Upon return,
        // the length of the &#39;blob&#39; will be increased by the number of
        // characters appended, and the data contained in the &#39;blob&#39; will be a
        // concatenation of the data contained in the buffers from &#39;offset&#39;
        // until the end.  The behavior is undefined unless
        // &#39;0 &lt;= offset &lt; totalDataSize&#39; and either
        // &#39;blob.length() + totalDataSize &lt;= blob.totalSize()&#39; or &#39;blob&#39; was
        // created with a blob buffer factory where &#39;totalDataSize&#39; represents
        // the total size of the data in &#39;buffers&#39;.

    static btlb::Blob *blob(const Iovec             *buffers,
                            int                      numBuffers,
                            btlb::BlobBufferFactory *factory,
                            bslma::Allocator        *basicAllocator = 0);
    static btlb::Blob *blob(const Iovec             *buffers,
                            int                      numBuffers,
                            int                      offset,
                            btlb::BlobBufferFactory *factory,
                            bslma::Allocator        *basicAllocator = 0);
        // Create a &#39;btlb::Blob&#39; object allocated using the specified &#39;factory&#39;
        // and containing data from the specified sequence of &#39;buffers&#39; of the
        // specified &#39;numBuffers&#39; length.  Optionally specify an &#39;offset&#39; (in
        // bytes) in the data contained in the &#39;buffers&#39; to indicate the start
        // of the copied data; if offset is not specified, then start at offset
        // 0 (i.e., use all the &#39;buffers&#39;).  Optionally specify
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.  Return a pointer
        // to the created blob.  The behavior is undefined unless
        // &#39;0 &lt;= offset &lt; totalDataSize&#39; where &#39;totalDataSize&#39; represents the
        // total size of the data in &#39;buffers&#39;.

    static int gather(char        *buffer,
                      int          length,
                      const Iovec *buffers,
                      int          numBuffers);
    static int gather(char        *buffer,
                      int          length,
                      const Ovec  *buffers,
                      int          numBuffers);
        // Copy into the specified &#39;buffer&#39; of the specified &#39;length&#39; data from
        // the specified sequence of &#39;buffers&#39; of the specified &#39;numBuffers&#39;
        // length.  Return the total number of bytes copied.  The behavior is
        // undefined unless &#39;0 &lt;= length&#39; and &#39;0 &lt;= numBuffers&#39;.

    static int length(const Iovec *buffers, int numBuffers);
    static int length(const Ovec  *buffers, int numBuffers);
        // Return the total length of data in bytes contained in the specified
        // sequence of &#39;buffers&#39; of the specified &#39;numBuffers&#39; length.  The
        // behavior is undefined unless &#39;0 &lt;= numBuffers&#39;.

    static void pivot(int         *bufferIndex,
                      int         *offset,
                      const Iovec *buffers,
                      int          numBuffers,
                      int          position);
    static void pivot(int         *bufferIndex,
                      int         *offset,
                      const Ovec  *buffers,
                      int          numBuffers,
                      int          position);
        // Load into the specified &#39;bufferIndex&#39; the index of the buffer and
        // into the specified &#39;offset&#39; the offset within that buffer of the
        // byte corresponding to the specified &#39;position&#39; in the specified
        // sequence of &#39;buffers&#39; of the specified &#39;numBuffers&#39; length.  The
        // behavior is undefined unless &#39;0 &lt;= numBuffers&#39; and &#39;0 &lt;= position&#39;.
        // Note that if &#39;position&#39; is greater than the total length of the
        // &#39;buffers&#39;, &#39;bufferIndex&#39; is set to &#39;numBuffers&#39;, and &#39;offset&#39; is not
        // changed.

    static int scatter(const Iovec *buffers,
                       int          numBuffers,
                       const char  *buffer,
                       int          length);
    static int scatter(const Ovec  *buffers,
                       int          numBuffers,
                       const char  *buffer,
                       int          length);
        // Copy into the specified sequence of &#39;buffers&#39; of the specified
        // &#39;numBuffers&#39; length the data from the specified &#39;buffer&#39; of the
        // specified &#39;length&#39;.  Return the total number of bytes copied.  The
        // behavior is undefined unless &#39;0 &lt;= numBuffers&#39; and &#39;0 &lt;= length&#39;.
};

// ----------------------------------------------------------------------------
//                             INLINE DEFINITIONS
// ----------------------------------------------------------------------------

                             // ---------------
                             // class IovecUtil
                             // ---------------

inline
btlb::Blob *IovecUtil::blob(const Iovec             *buffers,
                            int                      numBuffers,
                            btlb::BlobBufferFactory *factory,
                            bslma::Allocator        *basicAllocator)
{
    return blob(buffers, numBuffers, 0, factory, basicAllocator);
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
