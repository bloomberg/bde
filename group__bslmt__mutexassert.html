<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslmt_mutexassert Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslmt_mutexassert<br/>
<small>
[<a class="el" href="group__bslmt.html">Package bslmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an assert macro for verifying that a mutex is locked.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslmt.html">bslmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Macros</a> </li>
<li>
<a href="#4">Description</a> <ul>
<li>
<a href="#4.1">Usage</a> <ul>
<li>
<a href="#4.1.1">Example 1: Checking Consistency Within a Private Method</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an assert macro for verifying that a mutex is locked. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="macros"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>BSLMT_MUTEXASSERT_IS_LOCKED </td><td>verify a mutex is locked in non-opt modes  </td></tr>
<tr>
<td>BSLMT_MUTEXASSERT_IS_LOCKED_SAFE </td><td>verify a mutex is locked in safe mode  </td></tr>
<tr>
<td>BSLMT_MUTEXASSERT_IS_LOCKED_OPT </td><td>verify a mutex is locked in all modes  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslmt__mutex.html" title="Provide a platform-independent mutex.">Component bslmt_mutex</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="4"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides macros for asserting that a mutex is locked. It does not distinguish between locks held by the current thread or other threads. If the macro is active in the current build mode, when the macro is called, if the supplied mutex is unlocked, the assert handler installed for <code>BSLS_ASSERT</code> will be called. The assert handler installed by default will report an error and abort the task. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The three macros defined by the component are analogous to the macros defined by <code>BSLS_ASSERT</code>: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
<code>BSLMT_MUTEXASSERT_IS_LOCKED</code>: active when <code>BSLS_ASSERT</code> is active  </li>
<li>
<code>BSLMT_MUTEXASSERT_IS_LOCKED_SAFE</code>: active when <code>BSLS_ASSERT_SAFE</code> is active  </li>
<li>
<code>BSLMT_MUTEXASSERT_IS_LOCKED_OPT</code>: active when <code>BSLS_ASSERT_OPT</code> is active  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>In build modes where any one of these macros is not active, calling it will have no effect. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If any of these asserts are in effect and fail (because the mutex in question was unlocked), the behavior parallels the behavior of the assertion macros defined in <code><a class="el" href="bsls__assert_8h.html" title="Provide build-specific, runtime-configurable assertion macros.">bsls_assert.h</a></code> -- <code><a class="el" href="classbsls_1_1Assert.html#ac809c4c1ef9ec0e5616a2923f216957f">bsls::Assert::invokeHandler</a></code> is called, with a source code expression, the name of the source file, and the line number in the source file where the macro was called. If the default handler is installed, this will result in an error message and an abort. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="4.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_checking_consistency_within_a_private_method"></a> <a class="anchor" id="usage.example_1~3A_checking_consistency_within_a_private_method"></a> <a class="anchor" id="description.usage.example_1~3A_checking_consistency_within_a_private_method"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="4.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Checking Consistency Within a Private Method: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Sometimes multithreaded code is written such that the author of a function requires that a caller has already acquired a mutex. The <code>BSLMT_MUTEXASSERT_IS_LOCKED*</code> family of assertions allows the programmers to verify, using defensive programming techniques, that the mutex in question is indeed locked. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we have a fully thread-safe queue that contains <code>int</code> values, and is guarded by an internal mutex. We can use <code>BSLMT_MUTEXASSERT_IS_LOCKED_SAFE</code> to ensure (in appropriate build modes) that proper internal locking of the mutex is taking place. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define the container: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyThreadSafeQueue {
      <span class="comment">// This &#39;class&#39; provides a fully *thread-safe* unidirectional queue of</span>
      <span class="comment">// &#39;int&#39; values.  See {&#39;bsls_glossary&#39;|Fully Thread-Safe}.  All public</span>
      <span class="comment">// manipulators operate as single, atomic actions.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1deque.html">bsl::deque&lt;int&gt;</a>      d_deque;    <span class="comment">// underlying non-*thread-safe*</span>
                                       <span class="comment">// standard container</span>

      <span class="keyword">mutable</span> <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>  d_mutex;    <span class="comment">// mutex to provide thread safety</span>

      <span class="comment">// PRIVATE MANIPULATOR</span>
      <span class="keywordtype">int</span> popImp(<span class="keywordtype">int</span> *result);
          <span class="comment">// Assign the value at the front of the queue to the specified</span>
          <span class="comment">// &#39;*result&#39;, and remove the value at the front of the queue;</span>
          <span class="comment">// return 0 if the queue was not initially empty, and a non-zero</span>
          <span class="comment">// value (with no effect) otherwise.  The behavior is undefined</span>
          <span class="comment">// unless &#39;d_mutex&#39; is locked.</span>

    <span class="keyword">public</span>:
      <span class="comment">// ...</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">int</span> pop(<span class="keywordtype">int</span> *result);
          <span class="comment">// Assign the value at the front of the queue to the specified</span>
          <span class="comment">// &#39;*result&#39;, and remove the value at the front of the queue;</span>
          <span class="comment">// return 0 if the queue was not initially empty, and a non-zero</span>
          <span class="comment">// value (with no effect) otherwise.</span>

      <span class="keywordtype">void</span> popAll(<a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;int&gt;</a> *result);
          <span class="comment">// Assign the values of all the elements from this queue, in order,</span>
          <span class="comment">// to the specified &#39;*result&#39;, and remove them from this queue.</span>
          <span class="comment">// Any previous contents of &#39;*result&#39; are discarded.  Note that, as</span>
          <span class="comment">// with the other public manipulators, this entire operation occurs</span>
          <span class="comment">// as a single, atomic action.</span>

      <span class="keywordtype">void</span> push(<span class="keywordtype">int</span> value);
          <span class="comment">// ...</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> INPUT_ITER&gt;
      <span class="keywordtype">void</span> pushRange(<span class="keyword">const</span> INPUT_ITER&amp; first, <span class="keyword">const</span> INPUT_ITER&amp; last);
          <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Notice that our public manipulators have two forms: push/pop a single element, and push/pop a collection of elements. Popping even a single element is non-trivial, so we factor this operation into a non-*thread-safe* private manipulator that performs the pop, and is used in both public <code>pop</code> methods. This private manipulator requires that the mutex be locked, but cannot lock the mutex itself, since the correctness of <code>popAll</code> demands that all of the pops be collectively performed using a single mutex lock/unlock. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we define the private manipulator: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// PRIVATE MANIPULATOR</span>
  <span class="keywordtype">int</span> MyThreadSafeQueue::popImp(<span class="keywordtype">int</span> *result)
  {
      <a class="code" href="bslmt__mutexassert_8h.html#a563a4de68de83cead989f7f6ed2f340e">BSLMT_MUTEXASSERT_IS_LOCKED_SAFE</a>(&amp;d_mutex);

      <span class="keywordflow">if</span> (d_deque.empty()) {
          <span class="keywordflow">return</span> -1;                                                <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">else</span> {
          *result = d_deque.front();
          d_deque.pop_front();
          <span class="keywordflow">return</span> 0;                                                 <span class="comment">// RETURN</span>
      }
  }
</pre></div><br/>
<br/>
 Notice that, on the very first line, the private manipulator verifies, as a precondition check, that the mutex has been acquired, using one of the <code>BSLMT_MUTEXASSERT_IS_LOCKED*</code> macros. We use the <code>...IS_LOCKED_SAFE...</code> version of the macro so that the check, which on some platforms is as expensive as locking the mutex, is performed in only the safe build mode. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we define the public manipulators; each of which must acquire a lock on the mutex (note that there is a bug in <code>popAll</code>): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">int</span> MyThreadSafeQueue::pop(<span class="keywordtype">int</span> *result)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(result);

      d_mutex.lock();
      <span class="keywordtype">int</span> rc = popImp(result);
      d_mutex.unlock();
      <span class="keywordflow">return</span> rc;
  }

  <span class="keywordtype">void</span> MyThreadSafeQueue::popAll(<a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;int&gt;</a> *result)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(result);

      <span class="keyword">const</span> <span class="keywordtype">int</span> size = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(d_deque.size());
      result-&gt;<a class="code" href="group__bslstl__vector.html#gac5203d4410a4c7c3d1d2014d5542e0d9">resize</a>(size);
      <span class="keywordtype">int</span> *begin = result-&gt;<a class="code" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a>();
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> index = 0; index &lt; size; ++index) {
          <span class="keywordtype">int</span> rc = popImp(&amp;begin[index]);
          <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 == rc);
      }
  }

  <span class="keywordtype">void</span> MyThreadSafeQueue::push(<span class="keywordtype">int</span> value)
  {
      d_mutex.lock();
      d_deque.push_back(value);
      d_mutex.unlock();
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INPUT_ITER&gt;
  <span class="keywordtype">void</span> MyThreadSafeQueue::pushRange(<span class="keyword">const</span> INPUT_ITER&amp; first,
                                    <span class="keyword">const</span> INPUT_ITER&amp; last)
  {
      d_mutex.lock();
      d_deque.insert(d_deque.begin(), first, last);
      d_mutex.unlock();
  }
</pre></div><br/>
<br/>
 Notice that, in <code>popAll</code>, we forgot to lock/unlock the mutex! </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, in our function <code>example2Function</code>, we make use of our class to create and exercise a <code>MyThreadSafeQueue</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> testThreadSafeQueue(bsl::ostream&amp; stream)
  {
      MyThreadSafeQueue queue;
</pre></div><br/>
<br/>
 Next, we populate the queue using <code>pushRange</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">const</span> <span class="keywordtype">int</span> rawData[] = { 17, 3, 21, -19, 4, 87, 29, 3, 101, 31, 36 };
      <span class="keyword">enum</span> { k_RAW_DATA_LENGTH = <span class="keyword">sizeof</span> rawData / <span class="keyword">sizeof</span> *rawData };

      queue.pushRange(rawData + 0, rawData + k_RAW_DATA_LENGTH);
</pre></div><br/>
<br/>
 Then, we pop a few items off the front of the queue and verify their values: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">int</span> value = -1;

      assert(0 == queue.pop(&amp;value));    assert(17 == value);
      assert(0 == queue.pop(&amp;value));    assert( 3 == value);
      assert(0 == queue.pop(&amp;value));    assert(21 == value);
</pre></div><br/>
<br/>
 Next, we attempt to empty the queue with <code>popAll</code>, which, if built in safe mode, would fail because it neglects to lock the mutex: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;int&gt;</a> v;
      queue.popAll(&amp;v);

      stream &lt;&lt; <span class="stringliteral">&quot;Remaining raw numbers: &quot;</span>;
      <span class="keywordflow">for</span> (bsl::size_t ti = 0; ti &lt; v.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>(); ++ti) {
          stream &lt;&lt; (ti ? <span class="stringliteral">&quot;, &quot;</span> : <span class="stringliteral">&quot;&quot;</span>) &lt;&lt; v[ti];
      }
      stream &lt;&lt; bsl::endl;
  }
</pre></div><br/>
<br/>
 Then, we build in non-safe mode and run: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Remaining raw numbers: -19, 4, 87, 29, 3, 101, 31, 36
</pre></div><br/>
<br/>
 Notice that, since the test case is being run in a single thread and our check is disabled, the bug where the mutex was not acquired does not manifest itself in a visible error, and we observe the seemingly correct output. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Now, we build in safe mode (which enables our check), run the program (which calls <code>example2Function</code>), and observe that, when we call <code>popAll</code>, the <code>BSLMT_MUTEXASSERT_IS_LOCKED_SAFE(&amp;d_mutex)</code> macro issues an error message and aborts: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Assertion failed: <a class="code" href="bslmt__mutexassert_8h.html#a563a4de68de83cead989f7f6ed2f340e">BSLMT_MUTEXASSERT_IS_LOCKED_SAFE</a>(&amp;d_mutex), file /bb/big
  storn/dev_framework/bchapman/git/bde-core/groups/bce/bslmt/unix-Linux-x86_6
  4-2.6.18-gcc-4.6.1/bslmt_mutexassertislocked.t.cpp, line 137
  Aborted (core dumped)
</pre></div><br/>
<br/>
 Finally, note that the message printed above and the subsequent aborting of the program were the result of a call to <code><a class="el" href="classbsls_1_1Assert.html#ac809c4c1ef9ec0e5616a2923f216957f">bsls::Assert::invokeHandler</a></code>, which in this case was configured (by default) to call <code><a class="el" href="classbsls_1_1Assert.html#a330f1589f484ad67d234454c1bc53966">bsls::Assert::failAbort</a></code>. Other handlers may be installed that produce different results, but in all cases should prevent the program from proceeding normally. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:00 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
