<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlma::ConcurrentFixedPool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlma.html">bdlma</a>      </li>
      <li><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html">bdlma::ConcurrentFixedPool</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlma::ConcurrentFixedPool Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlma::ConcurrentFixedPool" -->
<p><code>#include &lt;<a class="el" href="bdlma__concurrentfixedpool_8h_source.html">bdlma_concurrentfixedpool.h</a>&gt;</code></p>

<p><a href="classbdlma_1_1ConcurrentFixedPool-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#af1cd8cab6de90a56f6ed4f2903e04fad">ConcurrentFixedPool</a> (int objectSize, int poolSize, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#ac1a1d06afe045b8ffbb575ea86056946">~ConcurrentFixedPool</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#a4ac43c1e317f6932ea2968f86b964144">allocate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#ac54bed660d00e4faa16aebf57e53e4bf">deallocate</a> (void *address)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#af3cecbb01562e608b438beafa4f22333">deleteObject</a> (const TYPE *object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#a08591a3485314426cadbfc9c9bbda17b">deleteObjectRaw</a> (const TYPE *object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#a74db38244c9d8a81df4c924568a27fb3">release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#a235343ff1cf8e3fbb38e35315dacdba0">reserveCapacity</a> (int numObjects)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#a7dc790e452d8f2e407605192c802bf6a">setBackoffLevel</a> (int backoffLevel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#af9e63af867caec295123e76a137a702e">backoffLevel</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#a1718e357b540f755d6993eae47906686">indexFromAddress</a> (void *address) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#a6725a82d5f535b6bca6f2b92ee7218c1">objectSize</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#a5bef511aaf2399ace0d690f459d86208">addressFromIndex</a> (int index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#a69b2a7669651969ae137ab0f5075da53">poolSize</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements a memory pool that allocates and manages up to a fixed number of memory blocks of some uniform size, with both the limit on the number of blocks and the block size specified at construction.</p>
<p>This class guarantees thread safety when allocating or releasing memory (but see the documentation for the <code>release</code> method). </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af1cd8cab6de90a56f6ed4f2903e04fad"></a><!-- doxytag: member="bdlma::ConcurrentFixedPool::ConcurrentFixedPool" ref="af1cd8cab6de90a56f6ed4f2903e04fad" args="(int objectSize, int poolSize, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentFixedPool::ConcurrentFixedPool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>objectSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>poolSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a memory pool that returns memory of the specified <code>objectSize</code> for each invocation of the <code>allocate</code> method. Configure this pool to support allocation of up to the specified <code>poolSize</code> number of memory blocks. The largest supported <code>poolSize</code> is 33554431. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 &lt; objectSize</code>, <code>0 &lt; poolSize</code>, and <code>0x1FFFFFF &gt;= poolSize</code>. </p>

</div>
</div>
<a class="anchor" id="ac1a1d06afe045b8ffbb575ea86056946"></a><!-- doxytag: member="bdlma::ConcurrentFixedPool::~ConcurrentFixedPool" ref="ac1a1d06afe045b8ffbb575ea86056946" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentFixedPool::~ConcurrentFixedPool </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object and release all associated memory. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4ac43c1e317f6932ea2968f86b964144"></a><!-- doxytag: member="bdlma::ConcurrentFixedPool::allocate" ref="a4ac43c1e317f6932ea2968f86b964144" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bdlma::ConcurrentFixedPool::allocate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a memory block of the <code>objectSize</code> specified at construction. Return the address of that block or 0 if the pool is exhausted (i.e., <code><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#a69b2a7669651969ae137ab0f5075da53">poolSize()</a></code> memory blocks have already been allocated from this pool). </p>

</div>
</div>
<a class="anchor" id="ac54bed660d00e4faa16aebf57e53e4bf"></a><!-- doxytag: member="bdlma::ConcurrentFixedPool::deallocate" ref="ac54bed660d00e4faa16aebf57e53e4bf" args="(void *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::ConcurrentFixedPool::deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocate the memory block at the specified <code>address</code> back to this pool for reuse. </p>

</div>
</div>
<a class="anchor" id="af3cecbb01562e608b438beafa4f22333"></a><!-- doxytag: member="bdlma::ConcurrentFixedPool::deleteObject" ref="af3cecbb01562e608b438beafa4f22333" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::ConcurrentFixedPool::deleteObject </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> based on its dynamic type and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is 0. The behavior is undefined unless <code>object</code>, when cast appropriately to <code>void *</code>, was allocated using this allocator and has not already been deallocated. Note that <code>dynamic_cast&lt;void *&gt;(object)</code> is applied if <code>TYPE</code> is polymorphic, and <code>static_cast&lt;void *&gt;(object)</code> is applied otherwise. </p>

</div>
</div>
<a class="anchor" id="a08591a3485314426cadbfc9c9bbda17b"></a><!-- doxytag: member="bdlma::ConcurrentFixedPool::deleteObjectRaw" ref="a08591a3485314426cadbfc9c9bbda17b" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::ConcurrentFixedPool::deleteObjectRaw </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> based on its static type and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is 0. The behavior is undefined if <code>object</code> is a base-class pointer to a derived type, was not allocated using this allocator, or has already been deallocated. </p>

</div>
</div>
<a class="anchor" id="a74db38244c9d8a81df4c924568a27fb3"></a><!-- doxytag: member="bdlma::ConcurrentFixedPool::release" ref="a74db38244c9d8a81df4c924568a27fb3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::ConcurrentFixedPool::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release all memory currently allocated through this object. Note that this method should only be invoked when it is known that no blocks currently allocated through this pool will be used; therefore, it is not safe to use this method if any other thread may be concurrently allocating memory from this pool. Also note that <code><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#a74db38244c9d8a81df4c924568a27fb3">release()</a></code> is intended to free all memory without regard to the contents of that memory. Specifically, <code><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#a74db38244c9d8a81df4c924568a27fb3">release()</a></code> can <em>not</em> call object destructors for any allocated objects, since it has no knowledge of their type. If object destruction is required, use <code><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#af3cecbb01562e608b438beafa4f22333">ConcurrentFixedPool::deleteObject()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a235343ff1cf8e3fbb38e35315dacdba0"></a><!-- doxytag: member="bdlma::ConcurrentFixedPool::reserveCapacity" ref="a235343ff1cf8e3fbb38e35315dacdba0" args="(int numObjects)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlma::ConcurrentFixedPool::reserveCapacity </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numObjects</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reserve memory from this pool to satisfy memory requests for at least the specified <code>numObjects</code> before the pool replenishes. The behavior is undefined unless <code>0 &lt;= numObjects</code>. Return 0 on success and the number of objects that could not be reserved otherwise. Note that this method fails if the number of memory blocks already allocated plus <code>numObjects</code> exceeds <code><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#a69b2a7669651969ae137ab0f5075da53">poolSize()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a7dc790e452d8f2e407605192c802bf6a"></a><!-- doxytag: member="bdlma::ConcurrentFixedPool::setBackoffLevel" ref="a7dc790e452d8f2e407605192c802bf6a" args="(int backoffLevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::ConcurrentFixedPool::setBackoffLevel </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>backoffLevel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configure this pool with the specified non-negative <code>backoffLevel</code> that controls the amount of spinning that occurs when calls to this pool encounter contention. Setting <code>backoffLevel</code> to 0 disables spinning. Greater values of <code>backoffLevel</code> correspond to greater amounts of spinning. The behavior is undefined unless <code>0 &lt;= backoffLevel</code>. Note that both contention detection and spinning strategy are implementation defined. </p>

</div>
</div>
<a class="anchor" id="af9e63af867caec295123e76a137a702e"></a><!-- doxytag: member="bdlma::ConcurrentFixedPool::backoffLevel" ref="af9e63af867caec295123e76a137a702e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlma::ConcurrentFixedPool::backoffLevel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the non-negative <code>backoffLevel</code> that controls the amount of spinning that occurs when calls to this pool encounter contention. </p>

</div>
</div>
<a class="anchor" id="a1718e357b540f755d6993eae47906686"></a><!-- doxytag: member="bdlma::ConcurrentFixedPool::indexFromAddress" ref="a1718e357b540f755d6993eae47906686" args="(void *address) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlma::ConcurrentFixedPool::indexFromAddress </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an index in the range from 0 to the maximum size of this pool that uniquely identifies the memory block at the specified <code>address</code>. The behavior is undefined unless <code>address</code> corresponds to a memory block allocated from this pool. </p>

</div>
</div>
<a class="anchor" id="a6725a82d5f535b6bca6f2b92ee7218c1"></a><!-- doxytag: member="bdlma::ConcurrentFixedPool::objectSize" ref="a6725a82d5f535b6bca6f2b92ee7218c1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlma::ConcurrentFixedPool::objectSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the size of the memory blocks allocated from this object. Note that all blocks have the same size. </p>

</div>
</div>
<a class="anchor" id="a5bef511aaf2399ace0d690f459d86208"></a><!-- doxytag: member="bdlma::ConcurrentFixedPool::addressFromIndex" ref="a5bef511aaf2399ace0d690f459d86208" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bdlma::ConcurrentFixedPool::addressFromIndex </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the memory block identified by the specified <code>index</code>. The behavior is undefined unless the index has been obtained through <code>indexFromAddress</code>. </p>

</div>
</div>
<a class="anchor" id="a69b2a7669651969ae137ab0f5075da53"></a><!-- doxytag: member="bdlma::ConcurrentFixedPool::poolSize" ref="a69b2a7669651969ae137ab0f5075da53" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlma::ConcurrentFixedPool::poolSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum size of this pool. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlma__concurrentfixedpool_8h_source.html">bdlma_concurrentfixedpool.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:31 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
