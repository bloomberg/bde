<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlcc_queue Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlcc_queue<br/>
<small>
[<a class="el" href="group__bdlcc.html">Package bdlcc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a thread-enabled queue of items of parameterized <code>TYPE</code>.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlcc.html">bdlcc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread-Enabled Idioms in the <code>bdlcc::Queue</code> Interface</a> </li>
<li>
<a href="#3.2">Use of the <code>bdlc::Queue</code> Interface</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Simple Thread Pool</a> </li>
<li>
<a href="#3.3.2">Example 2: Multi-Threaded Observer</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a thread-enabled queue of items of parameterized <code>TYPE</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a> </td><td>thread-enabled <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code> wrapper  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlc__queue.html" title="Provide an in-place double-ended queue of T values.">Component bdlc_queue</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a thread-enabled implementation of an efficient, in-place, indexable, double-ended queue of parameterized <code>TYPE</code> values, namely the <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt;TYPE&gt;</code> container. <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code> is effectively a thread-enabled handle for <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code>, whose interface is also made available through <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread-enabled_idioms_in_the_bdlcc~3A~3Aqueue_interface"></a> <a class="anchor" id="description.thread-enabled_idioms_in_the_bdlcc~3A~3Aqueue_interface"></a> <a class="anchor" id="thread-enabled_idioms_in_the_bdlcc"></a> <a class="anchor" id="description.thread-enabled_idioms_in_the_bdlcc"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread-Enabled Idioms in the bdlcc::Queue Interface: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The thread-enabled <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code> is similar to <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code> in many regards, but there are several differences in method behavior and signature that arise due to the thread-enabled nature of the queue and its anticipated usage pattern. Most notably, the <code>popFront</code> and <code>popBack</code> methods return a <code>TYPE</code> object <em>by</em> <em>value</em>, rather than returning <code>void</code>, as <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code> does. Moreover, if a queue object is empty, <code>popFront</code> and <code>popBack</code> will block indefinitely until an item is added to the queue. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As a corollary to this behavior choice, <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code> also provides <code>timedPopFront</code> and <code>timedPopBack</code> methods. These methods wait until a specified timeout expires if the queue is empty, returning an item if one becomes available before the specified timeout; otherwise, they return a non-zero value to indicate that the specified timeout expired before an item was available. Note that <em>all</em> timeouts are expressed as values of type <code><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a></code> that represent <b>ABSOLUTE</b> times from 00:00:00 UTC, January 1, 1970. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The behavior of the <code>push</code> methods differs in a similar manner. <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code> supports the notion of a suggested maximum queue size, called the "high-water mark", a value supplied at construction. The <code>pushFront</code> and <code>pushBack</code> methods will block indefinitely if the queue contains (at least) the high-water mark number of items, until the number of items falls below the high-water mark. The <code>timedPushFront</code> and <code>timedPushBack</code> are provided to limit the duration of blocking; note, however, that these methods can fail to add an item to the queue. For this reason, <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code> also provides a <code>forcePushFront</code> method that will override the high-water mark, if needed, in order to succeed without blocking. Note that this design decision makes the high-water mark concept a suggestion and not an invariant. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="use_of_the_bdlc~3A~3Aqueue_interface"></a> <a class="anchor" id="description.use_of_the_bdlc~3A~3Aqueue_interface"></a> <a class="anchor" id="use_of_the_bdlc"></a> <a class="anchor" id="description.use_of_the_bdlc"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Use of the bdlc::Queue Interface: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Class <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code> provides access to an underlying <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code>, so clients of <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code> have full access to the interface behavior of <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code> to inspect and modify the <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Member function <code><a class="el" href="classbdlcc_1_1Queue.html#a4e1d9f694b96bf24f76f5d2e56f3f894">bdlcc::Queue::queue()</a></code> provides <em>direct</em> modifiable access to the <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code> object used in the implementation. Member functions <code><a class="el" href="classbdlcc_1_1Queue.html#acee74ac49dd35272304f3b36d2dac369">bdlcc::Queue::mutex()</a></code>, <code><a class="el" href="classbdlcc_1_1Queue.html#ae15555f980577a528ec2e871b69086e5">bdlcc::Queue::notEmptyCondition()</a></code>, and <code><a class="el" href="classbdlcc_1_1Queue.html#a994e4e7a46b79e5a3935fd729008869e">bdlcc::Queue::notFullCondition()</a></code> correspondingly provide <em>direct</em> modifiable access to the underlying <code><a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a></code> and <code><a class="el" href="classbslmt_1_1Condition.html">bslmt::Condition</a></code> objects respectively. These underlying objects are used within <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code> to manage concurrent access to the queue. Clients may use these member variables together if needed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Whenever accessing the <code>bdec</code> queue directly, clients must be sure to lock and unlock the mutex or to signal or broadcast on the condition variable as appropriate. For example, a client might use the underlying queue and mutex as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">     <a class="code" href="classbdlcc_1_1Queue.html">bdlcc::Queue&lt;myData&gt;</a>  myWorkQueue;
     <a class="code" href="classbdlc_1_1Queue.html">bdlc::Queue&lt;myData&gt;</a>&amp; rawQueue = myWorkQueue.<a class="code" href="classbdlcc_1_1Queue.html#a4e1d9f694b96bf24f76f5d2e56f3f894">queue</a>();
     <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>&amp;        queueMutex = myWorkQueue.<a class="code" href="classbdlcc_1_1Queue.html#acee74ac49dd35272304f3b36d2dac369">mutex</a>();
         <span class="comment">// other code omitted...</span>

     myData  data1;
     myData  data2;
     <span class="keywordtype">bool</span> pairFoundFlag = 0;
     <span class="comment">// Take two items from the queue atomically, if available.</span>

     queueMutex.<a class="code" href="classbslmt_1_1Mutex.html#a3451960cdbb0ab49bd3c70e8702c2a4f">lock</a>();
     <span class="keywordflow">if</span> (rawQueue.<a class="code" href="classbdlc_1_1Queue.html#a33ccacc9417d42712b56ead0abf165a2">length</a>() &gt;= 2) {
         data1 = rawQueue.<a class="code" href="classbdlc_1_1Queue.html#aea0d9fe1ebd0a208ae2e159193bdba06">front</a>();
         rawQueue.<a class="code" href="classbdlc_1_1Queue.html#a69b2057cdc8eebc6a7b616ebfb8daadd">popFront</a>();
         data2 = rawQueue.<a class="code" href="classbdlc_1_1Queue.html#aea0d9fe1ebd0a208ae2e159193bdba06">front</a>();
         rawQueue.<a class="code" href="classbdlc_1_1Queue.html#a69b2057cdc8eebc6a7b616ebfb8daadd">popFront</a>();
         pairFound = 1;
     }
     queueMutex.<a class="code" href="classbslmt_1_1Mutex.html#ac02d8e714a5dc0330e56d4ef66638d76">unlock</a>();

     <span class="keywordflow">if</span> (pairFoundFlag) {
         <span class="comment">// Process the pair</span>
     }
</pre></div><br/>
<br/>
 Note that a future version of this component will provide access to a thread-safe "smart pointer" that will manage the <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code> with respect to locking and signaling. At that time, direct access to the <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code> will be deprecated. In the meanwhile, the user should be careful to use the <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code> and the synchronization objects properly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_simple_thread_pool"></a> <a class="anchor" id="usage.example_1~3A_simple_thread_pool"></a> <a class="anchor" id="description.usage.example_1~3A_simple_thread_pool"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Simple Thread Pool: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example demonstrates a typical usage of a <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code> is used to communicate between a single "producer" thread and multiple "consumer" threads. The "producer" will push work requests onto the queue, and each "consumer" will iteratively take a work request from the queue and service the request. This example shows a partial, simplified implementation of the <code><a class="el" href="classbdlmt_1_1ThreadPool.html">bdlmt::ThreadPool</a></code> class. See component <code>bdlmt_threadpool</code> for more information. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We begin our example with some utility classes that define a simple "work
 item": <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> {
      k_MAX_CONSUMER_THREADS = 10
  };

  <span class="keyword">struct </span>my_WorkData {
      <span class="comment">// Work data...</span>
  };

  <span class="keyword">struct </span>my_WorkRequest {
      <span class="keyword">enum</span> RequestType {
          e_WORK = 1,
          e_STOP = 2
      };

      RequestType d_type;
      my_WorkData d_data;
      <span class="comment">// Work data...</span>
  };
</pre></div><br/>
<br/>
 Next, we provide a simple function to service an individual work item. The details are unimportant for this example. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myDoWork(my_WorkData&amp; data)
  {
      <span class="comment">// do some stuff...</span>
      (void)data;
  }
</pre></div><br/>
<br/>
 The <code>myConsumer</code> function will pop items off the queue and process them. As discussed above, note that the call to <code>queue-&gt;popFront()</code> will block until there is an item available on the queue. This function will be executed in multiple threads, so that each thread waits in <code>queue-&gt;popFront()</code>, and <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code> guarantees that each thread gets a unique item from the queue. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myConsumer(<a class="code" href="classbdlcc_1_1Queue.html">bdlcc::Queue&lt;my_WorkRequest&gt;</a> *queue)
  {
      <span class="keywordflow">while</span> (1) {
          <span class="comment">// &#39;popFront()&#39; will wait for a &#39;my_WorkRequest&#39; until available.</span>

          my_WorkRequest item = queue-&gt;<a class="code" href="classbdlcc_1_1Queue.html#aba6523bb41b6af87258d7706259aceed">popFront</a>();
          <span class="keywordflow">if</span> (item.d_type == my_WorkRequest::e_STOP) <span class="keywordflow">break</span>;
          myDoWork(item.d_data);
      }
  }
</pre></div><br/>
<br/>
 The function below is a callback for <code><a class="el" href="structbslmt_1_1ThreadUtil.html">bslmt::ThreadUtil</a></code>, which requires a "C" signature. <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create()</a></code> expects a pointer to this function, and provides that function pointer to the newly created thread. The new thread then executes this function. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Since <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create()</a></code> uses the familiar "C" convention of passing a <code>void</code> pointer, our function simply casts that pointer to our required type (<code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt;my_WorkRequest*&gt; *</code>), and then delegates to the queue-specific function <code>myConsumer</code>, above. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *myConsumerThread(<span class="keywordtype">void</span> *queuePtr)
  {
      myConsumer ((<a class="code" href="classbdlcc_1_1Queue.html">bdlcc::Queue&lt;my_WorkRequest&gt;</a> *)queuePtr);
      <span class="keywordflow">return</span> queuePtr;
  }
</pre></div><br/>
<br/>
 In this simple example, the <code>myProducer</code> function serves multiple roles: it creates the <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code>, starts out the consumer threads, and then produces and queues work items. When work requests are exhausted, this function queues one <code>STOP</code> item for each consumer queue. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When each Consumer thread reads a <code>STOP</code>, it terminates its thread-handling function. Note that, although the producer cannot control which thread <code>pop</code>s a particular work item, it can rely on the knowledge that each Consumer thread will read a single <code>STOP</code> item and then terminate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, the <code>myProducer</code> function "joins" each Consumer thread, which ensures that the thread itself will terminate correctly; see the <code>bslmt_threadutil</code> component for details. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myProducer(<span class="keywordtype">int</span> numThreads)
  {
      my_WorkRequest item;
      my_WorkData    workData;

      <a class="code" href="classbdlcc_1_1Queue.html">bdlcc::Queue&lt;my_WorkRequest&gt;</a> queue;

      assert(0 &lt; numThreads &amp;&amp; numThreads &lt;= k_MAX_CONSUMER_THREADS);
      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> consumerHandles[k_MAX_CONSUMER_THREADS];

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numThreads; ++i) {
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;consumerHandles[i],
                                    myConsumerThread,
                                    &amp;queue);
      }

      <span class="keywordflow">while</span> (!getWorkData(&amp;workData)) {
          item.d_type = my_WorkRequest::e_WORK;
          item.d_data = workData;
          queue.<a class="code" href="classbdlcc_1_1Queue.html#a7835a8aad26ca5685dae884a0bc19d46">pushBack</a>(item);
      }

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numThreads; ++i) {
          item.d_type = my_WorkRequest::e_STOP;
          queue.<a class="code" href="classbdlcc_1_1Queue.html#a7835a8aad26ca5685dae884a0bc19d46">pushBack</a>(item);
      }

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numThreads; ++i) {
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(consumerHandles[i]);
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_multi-threaded_observer"></a> <a class="anchor" id="usage.example_2~3A_multi-threaded_observer"></a> <a class="anchor" id="description.usage.example_2~3A_multi-threaded_observer"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Multi-Threaded Observer: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The previous example shows a simple mechanism for distributing work requests over multiple threads. This approach works well for large tasks that can be decomposed into discrete, independent tasks that can benefit from parallel execution. Note also that the various threads are synchronized only at the end of execution, when the Producer "joins" the various consumer threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The simple strategy used in the first example works well for tasks that share no state, and are completely independent of one another. For instance, a web server might use a similar strategy to distribute http requests across multiple worker threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In more complicated examples, it is often necessary or desirable to synchronize the separate tasks during execution. The second example below shows a single "Observer" mechanism that receives event notification from the various worker threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We first create a simple <code>my_Event</code> data type. Worker threads will use this data type to report information about their work. In our example, we will report the "worker Id", the event number, and some arbitrary text. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As with the previous example, class <code>my_Event</code> also contains an <code>EventType</code>, which is an enumeration which that indicates whether the worker has completed all work. The "Observer" will use this enumerated value to note when a Worker thread has completed its work. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> {
      k_MAX_CONSUMER_THREADS = 10,
      k_MAX_EVENT_TEXT       = 80
  };

  <span class="keyword">struct </span>my_Event {
      <span class="keyword">enum</span> EventType {
          e_IN_PROGRESS   = 1,
          e_TASK_COMPLETE = 2
      };

      EventType d_type;
      <span class="keywordtype">int</span>       d_workerId;
      <span class="keywordtype">int</span>       d_eventNumber;
      <span class="keywordtype">char</span>      d_eventText[k_MAX_EVENT_TEXT];
  };
</pre></div><br/>
<br/>
 As noted in the previous example, <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create()</a></code> spawns a new thread, which invokes a simple "C" function taking a <code>void</code> pointer. In the previous example, we simply converted that <code>void</code> pointer into a pointer to the parameterized <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt;TYPE&gt;</code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we want to pass an additional data item. Each worker thread is initialized with a unique integer value ("worker Id") that identifies that thread. We create a simple data structure that contains both of these values: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>my_WorkerData {
      <span class="keywordtype">int</span>                     d_workerId;
      <a class="code" href="classbdlcc_1_1Queue.html">bdlcc::Queue&lt;my_Event&gt;</a> *d_queue_p;
  };
</pre></div><br/>
<br/>
 Function <code>myWorker</code> simulates a working thread by enqueuing multiple <code>my_Event</code> events during execution. In a normal application, each <code>my_Event</code> structure would likely contain different textual information; for the sake of simplicity, our loop uses a constant value for the text field. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myWorker(<span class="keywordtype">int</span> workerId, <a class="code" href="classbdlcc_1_1Queue.html">bdlcc::Queue&lt;my_Event&gt;</a> *queue)
  {
      <span class="keyword">const</span> <span class="keywordtype">int</span> NEVENTS = 5;
      <span class="keywordtype">int</span> evnum;

      <span class="keywordflow">for</span> (evnum = 0; evnum &lt; NEVENTS; ++evnum) {
          my_Event ev = {
              my_Event::e_IN_PROGRESS,
              workerId,
              evnum,
              <span class="stringliteral">&quot;In-Progress Event&quot;</span>
          };
          queue-&gt;<a class="code" href="classbdlcc_1_1Queue.html#a7835a8aad26ca5685dae884a0bc19d46">pushBack</a>(ev);
      }

      my_Event ev = {
          my_Event::e_TASK_COMPLETE,
          workerId,
          evnum,
          <span class="stringliteral">&quot;Task Complete&quot;</span>
      };
      queue-&gt;<a class="code" href="classbdlcc_1_1Queue.html#a7835a8aad26ca5685dae884a0bc19d46">pushBack</a>(ev);
  }
</pre></div><br/>
<br/>
 The callback function invoked by <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create()</a></code> takes the traditional <code>void</code> pointer. The expected data is the composite structure <code>my_WorkerData</code>. The callback function casts the <code>void</code> pointer to the application-specific data type and then uses the referenced object to construct a call to the <code>myWorker</code> function. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *myWorkerThread(<span class="keywordtype">void</span> *v_worker_p)
  {
      my_WorkerData *worker_p = (my_WorkerData *) v_worker_p;
      myWorker(worker_p-&gt;d_workerId, worker_p-&gt;d_queue_p);
      <span class="keywordflow">return</span> v_worker_p;
  }
</pre></div><br/>
<br/>
 For the sake of simplicity, we will implement the Observer behavior in the main thread. The <code>void</code> function <code>myObserver</code> starts out multiple threads running the <code>myWorker</code> function, reads <code>my_Event</code>s from the queue, and logs all messages in the order of arrival. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As each <code>myWorker</code> thread terminates, it sends a <code>e_TASK_COMPLETE</code> event. Upon receiving this event, the <code>myObserver</code> function uses the <code>d_workerId</code> to find the relevant thread, and then "joins" that thread. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>myObserver</code> function determines when all tasks have completed simply by counting the number of <code>e_TASK_COMPLETE</code> messages received. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myObserver()
  {
      <span class="keyword">const</span> <span class="keywordtype">int</span> NTHREADS = 10;
      <a class="code" href="classbdlcc_1_1Queue.html">bdlcc::Queue&lt;my_Event&gt;</a> queue;

      assert(NTHREADS &gt; 0 &amp;&amp; NTHREADS &lt;= k_MAX_CONSUMER_THREADS);
      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> workerHandles[k_MAX_CONSUMER_THREADS];

      my_WorkerData workerData;
      workerData.d_queue_p = &amp;queue;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NTHREADS; ++i) {
          workerData.d_workerId = i;
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;workerHandles[i],
                                    myWorkerThread,
                                    &amp;workerData);
      }
      <span class="keywordtype">int</span> nStop = 0;
      <span class="keywordflow">while</span> (nStop &lt; NTHREADS) {
          my_Event ev = queue.<a class="code" href="classbdlcc_1_1Queue.html#aba6523bb41b6af87258d7706259aceed">popFront</a>();
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; ev.d_workerId    &lt;&lt; <span class="stringliteral">&quot;] &quot;</span>
                           &lt;&lt; ev.d_eventNumber &lt;&lt; <span class="stringliteral">&quot;. &quot;</span>
                           &lt;&lt; ev.d_eventText   &lt;&lt; bsl::endl;
          <span class="keywordflow">if</span> (my_Event::e_TASK_COMPLETE == ev.d_type) {
              ++nStop;
              <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(workerHandles[ev.d_workerId]);
          }
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:41 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
