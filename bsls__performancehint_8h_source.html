<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bsls_performancehint.h                                             -*-C++-*-
#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#define INCLUDED_BSLS_PERFORMANCEHINT

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide performance hints for code optimization.
//
//@CLASSES:
//  bsls::PerformanceHint: namespace for performance optimization hints
//
//@MACROS:
//  BSLS_PERFORMANCEHINT_PREDICT_LIKELY(X): &#39;X&#39; probably evaluates to non-zero
//  BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(X): &#39;X&#39; probably evaluates to zero
//  BSLS_PERFORMANCEHINT_PREDICT_EXPECT(X, Y): &#39;X&#39; probably evaluates to &#39;Y&#39;
//  BSLS_PERFORMANCEHINT_UNLIKELY_HINT: annotate block unlikely to be taken
//
//@DESCRIPTION: This component provides performance hints for the compiler or
// hardware.  There are currently two types of hints that are supported:
//: o branch prediction
//: o data cache prefetching
//
///Branch Prediction
///-----------------
// The three macros provided, &#39;BSLS_PERFORMANCEHINT_PREDICT_LIKELY&#39;,
// &#39;BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY&#39;, and
// &#39;BSLS_PERFORMANCEHINT_PREDICT_EXPECT&#39;, can be used to optimize compiler
// generated code for branch prediction.  The compiler, when given the hint
// under *optimized* mode (i.e., with &#39;BDE_BUILD_TARGET_OPT&#39; defined) will
// rearrange the assembly instructions it generates to minimize the number of
// jumps needed.
//
// The following describes the macros provided by this component:
//..
///               Macro Name                          Description of Macro
///----------------------------------------       -----------------------------
// BSLS_PERFORMANCEHINT_PREDICT_LIKELY(expr)      Hint to the compiler that the
//                                                specified *integral* &#39;expr&#39;
//                                                expression is likely to
//                                                evaluate to non-zero.
//                                                Returns &#39;true&#39; or &#39;false&#39;
//                                                depending on the result of
//                                                the expression.
//
// BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(expr)    Hint to the compiler that the
//                                                specified *integral* &#39;expr&#39;
//                                                expression is likely to
//                                                evaluate to zero.  Returns
//                                                &#39;true&#39; or &#39;false&#39; depending
//                                                on the result of the
//                                                expression.
//
// BSLS_PERFORMANCEHINT_PREDICT_EXPECT(expr, value)
//                                                Hint to the compiler that the
//                                                specified *integral* &#39;expr&#39;
//                                                expression is likely to
//                                                evaluate to the specified
//                                                &#39;value&#39;.  Returns the result
//                                                of the expression.
//
// BSLS_PERFORMANCEHINT_UNLIKELY_HINT             Hint to the compiler that the
//                                                block which contains the hint
//                                                is unlikely chosen.  Use this
//                                                in conjunction with the
//                                                &#39;PREDICT_UNLIKELY&#39; clause for
//                                                maximum portability.
//..
///Warning
///- - - -
// Please use the macros provided in this component *with* *caution*.  Always
// profile your code to get an idea of actual usage before attempting to
// optimize with these macros.  Furthermore, these macros are merely *hints* to
// the compiler.  Whether or not they will have visible effect on performance
// is not guaranteed.  Note that one can perform similar optimization with a
// profile-based compilation.  When compiled with the proper options, the
// compiler can collect usage information of the code, and such information can
// then be passed back to recompile the code in a more optimized form.  Please
// refer to the compiler manual for more information.
//
///Limitations
///- - - - - -
// There is a bug in gcc 4.2, 4.3, and 4.4 such that when using the branch
// prediction macros with multiple conditions, the generated code might not be
// properly optimized.  For example:
//..
//  if (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(a &amp;&amp; b)) {
//      // ...
//  }
//..
// The work-around is simply to split the conditions:
//..
//  if (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(a)
//   &amp;&amp; BSLS_PERFORMANCEHINT_PREDICT_LIKELY(b)) {
//      // ...
//  }
//..
// This applies to all of the &quot;likely&quot;, &quot;unlikely&quot;, and &quot;expect&quot; macros defined
// in this component.  Note that a bug report has been filed:
//..
//  http://gcc.gnu.org/bugzilla/show_bug.cgi?id=42233
//..
//
///Data Cache Prefetching
///----------------------
// The two functions provided in the &#39;bsls::PerformanceHint&#39; &#39;struct&#39; are
// &#39;prefetchForReading&#39; and &#39;prefetchForWriting&#39;.  Use of these functions will
// cause the compiler to generate prefetch instructions to prefetch one cache
// line worth of data at the specified address into the cache line to minimize
// processor stalls.
//..
//       Function Name                       Description of Function
//  ------------------------         ------------------------------------------
//  prefetchForReading(address)      Prefetches one cache line worth of data at
//                                   the specified &#39;address&#39; for reading.
//
//  prefetchForWriting(address)      Prefetches one cache line worth of data at
//                                   the specified &#39;address&#39; for writing.
//..
///Warning
///- - - -
// These functions must be used *with* *caution*.  Inappropriate use of these
// functions degrades performance.  Note that there should be sufficient time
// for the prefetch instruction to finish before the specified address is
// accessed, otherwise prefetching will be pointless.  A profiler should be
// used to understand the program&#39;s behavior before attempting to optimize with
// these functions.
//
///Usage
///-----
// The following series of examples illustrates use of the macros and functions
// provided by this component.
//
///Example 1 -- USING BRANCH PREDICTION MACROS
///-- -- -- -- -- -- -- -- -- -- -- -- -- -- -
// The following demonstrates the use of &#39;BSLS_PERFORMANCEHINT_PREDICT_LIKELY&#39;
// and &#39;BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY&#39; to generate more efficient
// assembly instructions.  Note the use of &#39;BSLS_PERFORMANCEHINT_UNLIKELY_HINT&#39;
// inside the &#39;if&#39; branch for maximum portability.
//..
//  int global;
//
//  void foo()
//  {
//      global = 1;
//  }
//
//  void bar()
//  {
//      global = 2;
//  }
//
//  int main(int argc, char **argv)
//  {
//      argc = std::atoi(argv[1]);
//
//      for (int x = 0; x &lt; argc; ++x) {
//          int y = std::rand() % 10;
//
//          // Correct usage of &#39;BSLS_PERFORMANCEHINT_PREDICT_LIKELY&#39; since
//          // there are nine of ten chance that this branch is taken.
//
//          if (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(8 != y)) {
//              foo();
//          }
//          else {
//              BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
//              bar();
//          }
//      }
//      return 0;
//  }
//..
// An excerpt of the assembly code generated using &#39;xlC&#39; Version 10 on AIX from
// this small program is:
//..
//  b8:   2c 00 00 08     cmpwi   r0,8
//  bc:   41 82 00 38     beq-    f4 &lt;.main+0xb4&gt;
//                         ^
//                         Note that if register r0 (y) equals 8, branch to
//                         instruction f4 (a jump).  The &#39;-&#39; after &#39;beq&#39;
//                         indicates that the branch is unlikely to be taken.
//                         The predicted code path continues the &#39;if&#39;
//                         statement, which calls &#39;foo&#39; below.
//
//  c0:   4b ff ff 41     bl      0 &lt;.foo__Fv&gt;
//  ...
//  f4:   4b ff ff 2d     bl      20 &lt;.bar__Fv&gt;
//..
// Now, if &#39;BSLS_PERFORMANCEHINT_PREDICT_LIKELY&#39; is changed to
// &#39;BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY&#39;, and the
// &#39;BSLS_PERFORMANCEHINT_UNLIKELY_HINT&#39; is moved to the first branch, the
// following assembly code will be generated:
//..
//  b8:   2c 00 00 08     cmpwi   r0,8
//  bc:   40 c2 00 38     bne-    f4 &lt;.main+0xb4&gt;
//                         ^
//                         Note that the test became a &quot;branch not equal&quot;
//                         test.  The predicted code path now continues to the
//                         &#39;else&#39; statement, which calls &#39;bar&#39; below.
//
//  c0:   4b ff ff 61     bl      20 &lt;.bar__Fv&gt;
//  ...
//  f4:   4b ff ff 0d     bl      0 &lt;.foo__Fv&gt;
//..
// A timing analysis shows that effective use of branch prediction can have a
// material effect on code efficiency:
//..
//  $time ./unlikely.out 100000000
//
//  real    0m2.022s
//  user    0m2.010s
//  sys     0m0.013s
//
//  $time ./likely.out 100000000
//
//  real    0m2.159s
//  user    0m2.149s
//  sys     0m0.005s
//..
///Example 2 -- USING &#39;BSLS_PERFORMANCEHINT_PREDICT_EXPECT&#39;
///-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
// This macro is essentially the same as the &#39;__builtin_expect(expr, value)&#39;
// macro that is provided by some compilers.  This macro allows the user to
// define more complex hints to the compiler, such as the optimization of
// &#39;switch&#39; statements.  For example, given:
//..
//  int x = std::rand() % 4;
//..
// the following is incorrect usage of &#39;BSLS_PERFORMANCEHINT_PREDICT_EXPECT&#39;,
// since the probability of getting a 3 is equivalent to the other
// possibilities ( 0, 1, 2 ):
//..
//  switch (BSLS_PERFORMANCEHINT_PREDICT_EXPECT(x, 3)) {
//    case 1: //..
//            break;
//    case 2: //..
//            break;
//    case 3: //..
//            break;
//    default: break;
//  }
//..
// However, this is sufficient to illustrate the intent of this macro.
//
///Example 3 -- Cache Line Prefetching
///-- -- -- -- -- -- -- -- -- -- -- --
// The following demonstrates use of &#39;prefetchForReading&#39; and
// &#39;prefetchForWriting&#39; to prefetch data cache lines:
//..
//  const int SIZE = 10 * 1024 * 1024;
//
//  void add(int *arrayA, int *arrayB)
//  {
//      for (int i = 0; i &lt; SIZE / 8; ++i){
//          *(arrayA++) = *arrayA + *(arrayB++);
//          *(arrayA++) = *arrayA + *(arrayB++);
//          *(arrayA++) = *arrayA + *(arrayB++);
//          *(arrayA++) = *arrayA + *(arrayB++);
//
//          *(arrayA++) = *arrayA + *(arrayB++);
//          *(arrayA++) = *arrayA + *(arrayB++);
//          *(arrayA++) = *arrayA + *(arrayB++);
//          *(arrayA++) = *arrayA + *(arrayB++);
//      }
//  }
//
//  int array1[SIZE];
//  int array2[SIZE];
//
//  int main()
//  {
//      BloombergLP::bsls::Stopwatch timer;
//      timer.start();
//      for (int i = 0; i &lt; 10; ++i) {
//          add(array1, array2);
//      }
//      std::printf(&quot;time: %f\n&quot;, timer.elapsedTime());
//      return 0;
//  }
//..
// The above code simply adds two arrays together multiple times.  Using
// &#39;bsls::Stopwatch&#39;, we recorded the running time and printed it to &#39;stdout&#39;:
//..
//  $./prefetch.sundev1.tsk
//  time: 8.446806
//..
// Now, we can observe that in the &#39;add&#39; function, &#39;arrayA&#39; and &#39;arrayB&#39; are
// accessed sequentially for the majority of the program.  &#39;arrayA&#39; is used for
// writing and &#39;arrayB&#39; is used for reading.  Making use of prefetch, we add
// calls to &#39;prefetchForReading&#39; and &#39;prefetchForWriting&#39;:
//..
//  void add(int *arrayA, int *arrayB)
//  {
//      for (int i = 0; i &lt; SIZE / 8; ++i){
//          bsls::PerformanceHint::prefetchForWriting((int *) arrayA + 16);
//          bsls::PerformanceHint::prefetchForReading((int *) arrayB + 16);
//
//          *(arrayA++) = *arrayA + *(arrayB++);
//          *(arrayA++) = *arrayA + *(arrayB++);
//          *(arrayA++) = *arrayA + *(arrayB++);
//          *(arrayA++) = *arrayA + *(arrayB++);
//
//          *(arrayA++) = *arrayA + *(arrayB++);
//          *(arrayA++) = *arrayA + *(arrayB++);
//          *(arrayA++) = *arrayA + *(arrayB++);
//          *(arrayA++) = *arrayA + *(arrayB++);
//      }
//  }
//..
// Adding the prefetch improves the program&#39;s efficiency:
//..
//  $./prefetch.sundev1.tsk
//  time: 6.442100
//..
// Note that we prefetch the address &#39;16 * sizeof(int)&#39; bytes away from
// &#39;arrayA&#39;.  This is such that the prefetch instruction has sufficient time to
// finish before the data is actually accessed.  To see the difference, if we
// changed &#39;+ 16&#39; to &#39;+ 4&#39;:
//..
//  $./prefetch.sundev1.tsk
//  time: 6.835928
//..
// And we get less of an improvement in speed.  Similarly, if we prefetch too
// far away from the data use, the data might be removed from the cache before
// it is looked at and the prefetch is wasted.

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#if defined(BSLS_PLATFORM_CMP_IBM)

#ifndef INCLUDED_BUILTINS
#include &lt;builtins.h&gt;      // for &#39;dcbt&#39;, &#39;__builtin_expect&#39;
#define INCLUDED_BUILTINS
#endif

#endif

#if defined(BSLS_PLATFORM_CMP_HP)

#ifndef INCLUDED_MACHINE_SYS_BUILTINS
#include &lt;machine/sys/builtins.h&gt;
#define INCLUDED_MACHINE_SYS_BUILTINS
#endif

#endif

#if defined(BSLS_PLATFORM_CMP_SUN)

#ifndef INCLUDED_SUN_PREFETCH
#include &lt;sun_prefetch.h&gt;  // for &#39;sparc_prefetch_write_many&#39;,
                           // &#39;sparc_prefetch_read_many&#39;
#define INCLUDED_SUN_PREFETCH
#endif

#endif

#if defined(BSLS_PLATFORM_CMP_MSVC)

#ifndef INCLUDED_XMMINTRIN
#include &lt;xmmintrin.h&gt;     // for &#39;_mm_prefetch&#39;, &#39;_MM_HINT_T0&#39;
#define INCLUDED_XMMINTRIN
#endif

#endif

namespace BloombergLP {

                        // ============================
                        // BSLS_PERFORMANCEHINT_PREDICT
                        // ============================

// These macros are effective in *optimized* mode only, and *only* on platforms
// that support &#39;__builtin_expect&#39;.

#if defined(BDE_BUILD_TARGET_OPT) &amp;&amp;                                          \
   (defined(BSLS_PLATFORM_CMP_GNU) ||                                        \
   (defined(BSLS_PLATFORM_CMP_IBM) &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &gt;= 0x0900))

    #define BSLS_PERFORMANCEHINT_PREDICT_LIKELY(expr)                         \
                                              __builtin_expect(!!(expr), 1)
    #define BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(expr)                       \
                                              __builtin_expect((expr), 0)
    #define BSLS_PERFORMANCEHINT_PREDICT_EXPECT(expr, value)                  \
                                              __builtin_expect((expr), (value))
#else

    #define BSLS_PERFORMANCEHINT_PREDICT_LIKELY(expr)           (expr)
    #define BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(expr)         (expr)
    #define BSLS_PERFORMANCEHINT_PREDICT_EXPECT(expr, value)    (expr)

#endif

#if defined(BDE_BUILD_TARGET_OPT) &amp;&amp; defined(BSLS_PLATFORM_CMP_SUN)
    #define BSLS_PERFORMANCEHINT_UNLIKELY_HINT                                \
                             BloombergLP::bsls::PerformanceHint::rarelyCalled()
#elif defined(BDE_BUILD_TARGET_OPT) &amp;&amp; defined(BSLS_PLATFORM_CMP_IBM)
    #define BSLS_PERFORMANCEHINT_UNLIKELY_HINT                                \
                             BloombergLP::bsls::PerformanceHint::lowFrequency()
#else
    #define BSLS_PERFORMANCEHINT_UNLIKELY_HINT
#endif

namespace bsls {

                        // ======================
                        // struct PerformanceHint
                        // ======================

struct PerformanceHint {
    // This &#39;struct&#39; provides a namespace for a suite of primitive pure
    // procedures that give performance hints to the compiler or hardware.

    // CLASS METHODS
    static void prefetchForReading(const void *address);
        // Prefetch one cache line worth of data at the specified &#39;address&#39; for
        // reading if the compiler built-in is available (see to the component
        // level document for limitations).  Otherwise this method has no
        // effect.

    static void prefetchForWriting(void *address);
        // Prefetch one cache line worth of data at the specified &#39;address&#39; for
        // writing if the compiler built-in is available (see to the component
        // level document for limitations).  Otherwise this method has no
        // effect.

    static void rarelyCalled();
        // This is an empty function that is marked as rarely called using
        // pragmas.  If this function is placed in a block of code inside a
        // branch, the compiler will optimize the assembly code generated and
        // mark the block as unlikely.  Note that this function is
        // intentionally not inlined.

#if defined(BDE_BUILD_TARGET_OPT)
#if defined(BSLS_PLATFORM_CMP_SUN)

// Pragma to flag the function as rarely called.
#pragma rarely_called(rarelyCalled)

// Pragma to flag the function as no side effect.  This is necessary because a
// function that is marked as rarely called cannot be inlined without losing
// the &#39;rarely_called&#39; characteristics.  When marked as no side effect, even an
// out-of-line function will not trigger a function call.
#pragma no_side_effect(rarelyCalled)

#endif  // BSLS_PLATFORM_CMP_SUN
#endif  // BDE_BUILD_TARGET_OPT

    static void lowFrequency();
        // This is an empty function that is marked with low execution
        // frequency using pragmas.  If this function is placed in a block of
        // code inside a branch, the compiler will optimize the assembly code
        // generated and mark the block as unlikely.
};

// ===========================================================================
//                      INLINE FUNCTION DEFINITIONS
// ===========================================================================

                        // ----------------------
                        // struct PerformanceHint
                        // ----------------------

// CLASS METHODS
inline
void PerformanceHint::prefetchForReading(const void *address)
{
#if defined(BSLS_PLATFORM_CMP_GNU)

    __builtin_prefetch(address, 0);

#elif defined(BSLS_PLATFORM_CMP_IBM)

    __dcbt(const_cast&lt;void *&gt;(address));

#elif defined(BSLS_PLATFORM_CMP_SUN)

    sparc_prefetch_read_many(const_cast&lt;void *&gt;(address));

#elif defined(BSLS_PLATFORM_CMP_MSVC)

    _mm_prefetch(static_cast&lt;const char*&gt;(address), _MM_HINT_T0);
        // &#39;_MM_HINT_T0&#39; fetches data to all levels of cache.

#elif defined(BSLS_PLATFORM_CMP_HP)

    _Asm_lfetch(_LFTYPE_NONE, _LFHINT_NTA, address);

#else

    // no-op

#endif
}

inline
void PerformanceHint::prefetchForWriting(void *address)
{
#if defined(BSLS_PLATFORM_CMP_GNU)

    __builtin_prefetch(address, 1);

#elif (defined(BSLS_PLATFORM_CMP_IBM) &amp;&amp;                                     \
       BSLS_PLATFORM_CMP_VER_MAJOR &gt;= 0x0900)

    __dcbtst(address);

#elif defined(BSLS_PLATFORM_CMP_SUN)

    sparc_prefetch_write_many(address);

#elif defined(BSLS_PLATFORM_CMP_MSVC)

    _mm_prefetch(static_cast&lt;const char*&gt;(address), _MM_HINT_T0);
        // &#39;_MM_HINT_T0&#39; fetches data to all levels of cache.

#elif defined(BSLS_PLATFORM_CMP_HP)

    _Asm_lfetch_excl(_LFTYPE_NONE, _LFHINT_NTA, address);

#else

    // no-op

#endif
}

// This function must be inlined for the pragma to take effect on the branch
// prediction.
inline
void PerformanceHint::lowFrequency()
{
#if defined(BDE_BUILD_TARGET_OPT) &amp;&amp; defined(BSLS_PLATFORM_CMP_IBM)

#pragma execution_frequency(very_low)

#endif
}

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
