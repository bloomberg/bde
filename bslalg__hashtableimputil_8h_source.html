<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslalg_hashtableimputil.h                                          -*-C++-*-
#ifndef INCLUDED_BSLALG_HASHTABLEIMPUTIL
#define INCLUDED_BSLALG_HASHTABLEIMPUTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide algorithms for implementing a hash table.
//
//@CLASSES:
//  bslalg::HashTableImpUtil: functions used to implement a hash table
//
//@SEE_ALSO: bslalg_bidirectionallinklistutil, bslalg_hashtableanchor,
//           bslstl_hashtable
//
//@DESCRIPTION: This component provides a namespace for utility functions used
// to implement a hash table container.  Almost all the functions provided by
// this component operate on a &#39;HashTableAnchor&#39;, a type encapsulating the key
// data members of a hash table.
//
///Hash Table Structure
///--------------------
// The utilities provided by this component are used to create and manipulate
// a hash table that resolves collisions using a linked-list of elements
// (i.e., chaining).  Many of the operations provided by &#39;HashTableImpUtil&#39;
// operate on a &#39;HashTableAnchor&#39;, which encapsulates the key data members of a
// hash table.  A &#39;HashTableAnchor&#39; has the address of a single, doubly linked
// list holding all the elements in the hash table, as well as the address of
// an array of buckets.  Each bucket holds a reference to the first and last
// element in the linked-list whose *adjusted* *hash* *value* is equal to the
// index of the bucket.  Further, the functions in this component ensure (and
// require) that all elements that fall within a bucket form a contiguous
// sequence in the linked list, as can be seen in the
// diagram below:
//..
//  FIG 1: a hash table holding 5 elements
//
//  Hash Function:  h(n) -&gt; n  [identity function]
//  F: First Element
//  L: Last Element
//
//                     0       1       2       3       4
//                 +-------+-------+-------+-------+-------+--
//  bucket array   |  F L  |  F L  |  F L  |  F L  |  F L  |  ...
//                 +--+-+--+-------+-------+--+-+--+-------+--
//                    | \___         _________/ /
//                     \    \       /          |
//                     V     V     V           V
//                    ,-.   ,-.   ,-.   ,-.   ,-.
//  doubly        |---|0|---|0|---|3|---|3|---|3|--|
//  linked-list       `-&#39;   `-&#39;   `-&#39;   `-&#39;   `-&#39;
//..
//
///Hash Function and the Adjusted Hash Value
///-----------------------------------------
// The C++11 standard defines a hash function as a function &#39;h(k)&#39; returning
// (integral) values of type &#39;size_t&#39;, such that, for two different values of
// &#39;k1&#39; and &#39;k2&#39;, the probability that &#39;h(k1) == h(k2)&#39; is true should approach
// &#39;1.0 / numeric_limits&lt;size_t&gt;::max()&#39; (see 17.6.3.4 [hash.requirements]).
// Such a function &#39;h(k)&#39; may return values within the entire range of values
// that can be described using &#39;size_t&#39;, [0 ..  numeric_limits&lt;size_t&gt;::max()],
// however the array of buckets maintained by a hash table is typically
// significantly smaller than &#39;number_limits&lt;size_t&gt;::max()&#39;, therefore a
// hash-table implementation must adjust the returned hash function so that it
// falls in the valid range of bucket indices (typically either using an
// integer division or modulo operation) -- we refer to this as the *adjusted*
// *hash* *value*.  Note that currently &#39;HashTableImpUtil&#39; adjusts the value
// returned by a supplied hash function using &#39;operator%&#39; (modulo), which
// is more resilient to pathological behaviors when used in conjunction with a
// hash function that may produce contiguous hash values (with the &#39;div&#39; method
// lower order bits do not participate to the final adjusted value); however,
// the means of adjustment may change in the future.
//
///Well-Formed &#39;HashTableAnchor&#39; Objects
///-------------------------------------
// Many of the algorithms defined in this component operate on
// &#39;HashTableAnchor&#39; objects, which describe the attributes of a hash table.
// The &#39;HashTableAnchor&#39; objects supplied to &#39;HashTableImpUtil&#39; are required
// to meet a series of constraints that are not enforced by the
// &#39;HashTableAnchor&#39; type itself.  A &#39;HashTableAnchor&#39; object meeting these
// requirements is said to be &quot;well-formed&quot; and the method
// &#39;HashTableImpUtil::isWellFormed&#39; returns &#39;true&#39; for such an object.  A
// &#39;HastTableAnchor&#39; is considered well-formed for a particular key policy,
// &#39;KEY_CONFIG&#39;, and hash functor, &#39;HASHER&#39;, if all of the following are true:
//
//: 1 The list refers to a well-formed doubly linked list (see
//:   &#39;bslalg_bidirectionallinklistutil&#39;).
//:
//: 2 Each link in the list is an object of type
//:   &#39;BidirectionalNode&lt;KEY_CONFIG::ValueType&gt;&#39;
//:
//: 3 For each bucket, the range of nodes &#39;[ bucket.first(), bucket.last() ]&#39;
//:   contains all nodes in the hash table for which
//:   &#39;computeBucketIndex(HASHER(extractKey(link)&#39; is the index of the bucket,
//:   and no other nodes.
//
///&#39;KEY_CONFIG&#39; Template Parameter
///-------------------------------
// Several of the operations provided by &#39;HashTableImpUtil&#39; are template
// functions parameterized on the typename &#39;KEY_CONFIG&#39;.
//
///&#39;KEY_CONFIG&#39;
/// - - - - - -
// The &#39;KEY_CONFIG&#39; template parameter must provide the the following type
// aliases and functions:
//..
//  typedef &lt;VALUE_TYPE&gt; ValueType;
//     // Alias for the type of the values stored by the &#39;BidirectionalNode&#39;
//     // elements in the hash table.
//
//  typedef &lt;KEY_TYPE&gt; KeyType;
//     // Alias for the type of the key value extracted from the &#39;ValueType&#39;
//     // stored in the &#39;BidirectionalNode&#39; elements of a hash table.
//
//  static const KeyType&amp; extractKey(const ValueType&amp; obj);
//      // Return the &#39;KeyType&#39; information associated with the specified
//      // &#39;object&#39;.
//..
//
///Usage
///-----
// This section illustrates intended usage of this component.
//
///Example 1: Creating and Using a Hash Set
/// - - - - - - - - - - - - - - - - - - - -
// Suppose we want to build a hash set that will keep track of keys stored in
// set.
//
// First, we define an abstract template class &#39;HashSet&#39; that will provide a
// hash set for any type that has a copy constructor, a destructor, an equality
// comparator and a hash function.  We inherit from the &#39;HashTableAnchor&#39; class
// use the the &#39;BidirectionalLinkListUtil&#39; and &#39;HashTableImpUtil&#39; classes to
// facilitate building the table:
//..
//  template &lt;class KEY, class HASHER, class EQUAL&gt;
//  class HashSet : public bslalg::HashTableAnchor {
//      // PRIVATE TYPES
//      typedef bslalg::BidirectionalLink         Link;
//      typedef bslalg::BidirectionalNode&lt;KEY&gt;    Node;
//      typedef bslalg::HashTableBucket           Bucket;
//      typedef bslalg::BidirectionalLinkListUtil ListUtil;
//      typedef bslalg::HashTableImpUtil          ImpUtil;
//      typedef native_std::size_t                size_t;
//
//      struct Policy {
//          typedef KEY KeyType;
//          typedef KEY ValueType;
//
//          static const KeyType&amp; extractKey(const ValueType&amp; value)
//          {
//              return value;
//          }
//      };
//
//      // DATA
//      double            d_maxLoadFactor;
//      unsigned          d_numNodes;
//      HASHER            d_hasher;
//      EQUAL             d_equal;
//      bslma::Allocator *d_allocator_p;
//
//      // PRIVATE MANIPULATORS
//      void grow();
//          // Roughly double the number of buckets, such that the number of
//          // buckets shall always be &#39;2^N - 1&#39;.
//
//      // PRIVATE ACCESSORS
//      bool checkInvariants() const;
//          // Perform sanity checks on this table, returning &#39;true&#39; if all the
//          // tests pass and &#39;false&#39; otherwise.  Note that many of the checks
//          // are done with the &#39;ASSERTV&#39; macro and will cause messages to be
//          // written to the console.
//
//      Node* find(const KEY&amp; key,
//                 size_t     hashCode) const;
//          // Return a pointer to the node containing the specified &#39;key&#39;, and
//          // 0 if no such node is in the table.
//
//    private:
//      // NOT IMPLEMENTED
//      HashSet(const HashSet&amp;, bslma::Allocator *);
//      HashSet&amp; operator=(const HashSet&amp;);
//
//    public:
//      // CREATORS
//      explicit
//      HashSet(bslma::Allocator *allocator = 0);
//          // Create a &#39;HashSet&#39;, using the specified &#39;allocator&#39;.  If no
//          // allocator is specified, use the default allocator.
//
//      ~HashSet();
//          // Destroy this &#39;HashSet&#39;, freeing all its memory.
//
//      // MANIPULATORS
//      bool insert(const KEY&amp; key);
//          // If the specfied &#39;key&#39; is not in this hash table, add it,
//          // returning &#39;true&#39;.  If it is already in the table, return &#39;false&#39;
//          // with no action taken.
//
//      bool erase(const KEY&amp; key);
//          // If the specfied &#39;key&#39; is in this hash table, remove it,
//          // returning &#39;true&#39;.  If it is not found in the table, return
//          // &#39;false&#39; with no action taken.
//
//      // ACCESSORS
//      native_std::size_t count(const KEY&amp; key) const;
//          // Return 1 if the specified &#39;key&#39; is in this table and 0
//          // otherwise.
//
//      native_std::size_t size() const;
//          // Return the number of discrete keys that are stored in this
//          // table.
//  };
//
//  // PRIVATE MANIPULATORS
//  template &lt;class KEY, class HASHER, class EQUAL&gt;
//  void HashSet&lt;KEY, HASHER, EQUAL&gt;::grow()
//  {
//      // &#39;bucketArraySize&#39; will always be &#39;2^N - 1&#39;, so that if hashed values
//      // are aligned by some 2^N they&#39;re likely to be relatively prime to the
//      // length of the hash table.
//
//      d_allocator_p-&gt;deallocate(bucketArrayAddress());
//      size_t newBucketArraySize = bucketArraySize() * 2 + 1;
//      setBucketArrayAddressAndSize((Bucket *) d_allocator_p-&gt;allocate(
//                                        newBucketArraySize * sizeof(Bucket)),
//                                        newBucketArraySize);
//
//      ImpUtil::rehash&lt;Policy, HASHER&gt;(this,
//                                      listRootAddress(),
//                                      d_hasher);
//  }
//
//  // PRIVATE ACCESSORS
//  template &lt;class KEY, class HASHER, class EQUAL&gt;
//  bool HashSet&lt;KEY, HASHER, EQUAL&gt;::checkInvariants() const
//  {
//..
// &#39;HashTableImpUtil&#39;s &#39;isWellFormed&#39; will verify that all nodes are in their
// proper buckets, that there are no buckets containing nodes that are not in
// the main linked list, and no nodes in the main linked list that are not in
// buckets.  To verify that &#39;d_numNodes&#39; is correct we have to traverse the
// list and count the nodes ourselves.
//..
//      size_t numNodes = 0;
//      for (BidirectionalLink *cursor = listRootAddress;
//                                       cursor; cursor = cursor-&gt;nextLink()) {
//          ++numNodes;
//      }
//
//      return size() == numNodes &amp;&amp;
//                  ImpUtil::isWellFormed&lt;Policy, HASHER&gt;(this, d_allocator_p);
//  }
//
//  template &lt;class KEY, class HASHER, class EQUAL&gt;
//  bslalg::BidirectionalNode&lt;KEY&gt; *HashSet&lt;KEY, HASHER, EQUAL&gt;::find(
//                                           const KEY&amp;         key,
//                                           native_std::size_t hashCode) const
//  {
//      return (Node *) ImpUtil::find&lt;Policy, EQUAL&gt;(*this,
//                                                   key,
//                                                   d_equal,
//                                                   hashCode);
//  }
//
//  // CREATORS
//  template &lt;class KEY, class HASHER, class EQUAL&gt;
//  HashSet&lt;KEY, HASHER, EQUAL&gt;::HashSet(bslma::Allocator *allocator)
//  : HashTableAnchor(0, 0, 0)
//  , d_maxLoadFactor(0.4)
//  , d_numNodes(0)
//  {
//      enum { NUM_BUCKETS = 3 };    // &#39;NUM_BUCKETS&#39; must be &#39;2^N - 1&#39; for
//                                   // some &#39;N&#39;.
//
//      d_allocator_p = bslma::Default::allocator(allocator);
//      native_std::size_t bucketArraySizeInBytes =
//                                                NUM_BUCKETS * sizeof(Bucket);
//      setBucketArrayAddressAndSize(
//                  (Bucket *) d_allocator_p-&gt;allocate(bucketArraySizeInBytes),
//                  NUM_BUCKETS);
//      memset(bucketArrayAddress(), 0, bucketArraySizeInBytes);
//  }
//
//  template &lt;class KEY, class HASHER, class EQUAL&gt;
//  HashSet&lt;KEY, HASHER, EQUAL&gt;::~HashSet()
//  {
//      BSLS_ASSERT_SAFE(checkInvariants());
//
//      for (Link *link = listRootAddress(); link; ) {
//          Node *toDelete = (Node *) link;
//          link = link-&gt;nextLink();
//
//          toDelete-&gt;value().~KEY();
//          d_allocator_p-&gt;deallocate(toDelete);
//      }
//
//      d_allocator_p-&gt;deallocate(bucketArrayAddress());
//  }
//
//  // MANIPULATORS
//  template &lt;class KEY, class HASHER, class EQUAL&gt;
//  bool HashSet&lt;KEY, HASHER, EQUAL&gt;::erase(const KEY&amp; key)
//  {
//      size_t hashCode = d_hasher(key);
//      Node *node = find(key, hashCode);
//
//      if (!node) {
//          return false;                                             // RETURN
//      }
//
//      size_t bucketIdx = ImpUtil::computeBucketIndex(hashCode,
//                                                     bucketArraySize());
//      Bucket&amp; bucket = bucketArrayAddress()[bucketIdx];
//
//      BSLS_ASSERT_SAFE(bucket.first() &amp;&amp; bucket.last());
//
//      if (bucket.first() == node) {
//          if (bucket.last() == node) {
//              bucket.reset();
//          }
//          else {
//              bucket.setFirst(node-&gt;nextLink());
//          }
//      }
//      else if (bucket.last() == node) {
//          bucket.setLast(node-&gt;previousLink());
//      }
//
//      if (listRootAddress() == node) {
//          setListRootAddress(node-&gt;nextLink());
//      }
//
//      ListUtil::unlink(node);
//
//      node-&gt;value().~KEY();
//      d_allocator_p-&gt;deallocate(node);
//
//      --d_numNodes;
//      BSLS_ASSERT_SAFE(checkInvariants());
//
//      return true;
//  }
//
//  template &lt;class KEY, class HASHER, class EQUAL&gt;
//  bool HashSet&lt;KEY, HASHER, EQUAL&gt;::insert(const KEY&amp; key)
//  {
//      size_t hashCode = d_hasher(key);
//
//      if (find(key, hashCode)) {
//          // Already in set, do nothing.
//
//          return false;                                             // RETURN
//      }
//
//      if (bucketArraySize() * d_maxLoadFactor &lt; d_numNodes + 1) {
//          grow();
//      }
//
//      ++d_numNodes;
//      Node *node = (Node *) d_allocator_p-&gt;allocate(sizeof(Node));
//      bslalg::ScalarPrimitives::copyConstruct(&amp;node-&gt;value(),
//                                              key,
//                                              d_allocator_p);
//
//      ImpUtil::insertAtBackOfBucket(this, node, hashCode);
//
//      BSLS_ASSERT_SAFE(find(key, hashCode));
//      BSLS_ASSERT_SAFE(checkInvariants());
//
//      return true;
//  }
//
//  // ACCESSORS
//  template &lt;class KEY, class HASHER, class EQUAL&gt;
//  native_std::size_t HashSet&lt;KEY, HASHER, EQUAL&gt;::count(const KEY&amp; key) const
//  {
//      return 0 != find(key, d_hasher(key));
//  }
//
//  template &lt;class KEY, class HASHER, class EQUAL&gt;
//  native_std::size_t HashSet&lt;KEY, HASHER, EQUAL&gt;::size() const
//  {
//      return d_numNodes;
//  }
//..
// Then, we customize our table to manipulate zero-terminated &#39;const char *&#39;
// strings.  We make the simplifying assumption that the strings pointed at by
// the &#39;const char *&#39;s are longer-lived that the &#39;HashSet&#39; will be.  We must
// provide an equality comparator so that two copies, in different locations,
// of the same sequence of characters will evaluate equal:
//..
//  struct StringEqual {
//      bool operator()(const char *lhs, const char *rhs) const
//      {
//          return !strcmp(lhs, rhs);
//      }
//  };
//..
// Next, we must provide a string hash function to convert a &#39;const char *&#39; to
// a &#39;size_t&#39;:
//..
//  struct StringHash {
//      native_std::size_t operator()(const char *string) const;
//  };
//
//  native_std::size_t StringHash::operator()(const char *string) const
//  {
//      enum { BITS_IN_SIZE_T = sizeof(size_t) * 8 };
//
//      native_std::size_t result = 0;
//      for (int shift = 0; *string;
//                            ++string, shift = (shift + 7) % BITS_IN_SIZE_T) {
//          unsigned char c = *string;
//          if (shift &lt;= BITS_IN_SIZE_T - 8) {
//              result += c &lt;&lt; shift;
//          }
//          else {
//              result += c &lt;&lt; shift;
//              result += c &gt;&gt; (BITS_IN_SIZE_T - shift);
//          }
//      }
//
//      return result;
//  };
//..
// Then, we declare a couple of &#39;TestAllocator&#39;s to use during our example:
//..
//  bslma::TestAllocator da(&quot;defaultAllocator&quot;);
//  bslma::DefaultAllocatorGuard defaultGuard(&amp;da);
//
//  bslma::TestAllocator ta(&quot;testAllocator&quot;);
//..
// Next, in &#39;main&#39;, we create an instance of our &#39;HashSet&#39; type, configured to
// contain &#39;const char *&#39; strings:
//..
//  HashSet&lt;const char *, StringHash, StringEqual&gt; hs(&amp;ta);
//..
// Then, we insert a few values:
//..
//  assert(1 == hs.insert(&quot;woof&quot;));
//  assert(1 == hs.insert(&quot;arf&quot;));
//  assert(1 == hs.insert(&quot;meow&quot;));
//..
// Next, we attempt to insert a redundant value, and observe that the &#39;insert&#39;
// method returns &#39;false&#39; to indicate that the insert was refused:
//..
//  assert(0 == hs.insert(&quot;woof&quot;));
//..
// Then, we use to &#39;size&#39; method to observe that there are 3 strings stored in
// our &#39;HashSet&#39;:
//..
//  assert(3 == hs.size());
//..
// Next, we use the &#39;count&#39; method to observe, specifically, which strings are
// and are not in our &#39;HashSet&#39;:
//..
//  assert(1 == hs.count(&quot;woof&quot;));
//  assert(1 == hs.count(&quot;arf&quot;));
//  assert(1 == hs.count(&quot;meow&quot;));
//  assert(0 == hs.count(&quot;ruff&quot;));
//  assert(0 == hs.count(&quot;chomp&quot;));
//..
// Then, we attempt to erase a string which is not in our &#39;HashSet&#39; and observe
// that &#39;false&#39; is returned, which tells us the &#39;erase&#39; attempt was
// unsuccessful:
//..
//  assert(0 == hs.erase(&quot;ruff&quot;));
//..
// Next, we erase the string &quot;meow&quot;, which is stored in our &#39;HashSet&#39; and
// observe that &#39;true&#39; is returned, telling us the &#39;erase&#39; attempt succeeded:
//..
//  assert(1 == hs.erase(&quot;meow&quot;));
//..
// Now, we use the &#39;size&#39; method to verify there are 2 strings remaining in our
// &#39;HashSet&#39;:
//..
//  assert(2 == hs.size());
//..
// Finally, we use the &#39;count&#39; method to observe specifically which strings are
// still in our &#39;HashSet&#39;.  Note that &quot;meow&quot; is no longer there.  We observe
// that the default allocator was never used.  When we leave the block, our
// &#39;HashSet&#39; will be destroyed, freeing its memory, then our &#39;TestAllocator&#39;
// will be destroyed, verifying that our destructor worked correctly and that
// no memory was leaked:
//..
//  assert(1 == hs.count(&quot;woof&quot;));
//  assert(1 == hs.count(&quot;arf&quot;));
//  assert(0 == hs.count(&quot;meow&quot;));
//  assert(0 == hs.count(&quot;ruff&quot;));
//  assert(0 == hs.count(&quot;chomp&quot;));
//
//  assert(0 == da.numAllocations());
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLALG_BIDIRECTIONALLINK
#include &lt;bslalg_bidirectionallink.h&gt;
#endif

#ifndef INCLUDED_BSLALG_BIDIRECTIONALLINKLISTUTIL
#include &lt;bslalg_bidirectionallinklistutil.h&gt;
#endif

#ifndef INCLUDED_BSLALG_BIDIRECTIONALNODE
#include &lt;bslalg_bidirectionalnode.h&gt;
#endif

#ifndef INCLUDED_BSLALG_HASHTABLEANCHOR
#include &lt;bslalg_hashtableanchor.h&gt;
#endif

#ifndef INCLUDED_BSLALG_HASHTABLEBUCKET
#include &lt;bslalg_hashtablebucket.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEALLOCATORGUARD
#include &lt;bslma_deallocatorguard.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMF_CONDITIONAL
#include &lt;bslmf_conditional.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_NATIVESTD
#include &lt;bsls_nativestd.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;
#define INCLUDED_CSTDDEF
#endif

namespace BloombergLP {
namespace bslalg {

                    // =======================================
                    // class HashTableImpUtil_ExtractKeyResult
                    // =======================================

template &lt;class KEY_CONFIG&gt;
struct HashTableImpUtil_ExtractKeyResult {

    typedef typename KEY_CONFIG::KeyType   KeyType;
    typedef typename KEY_CONFIG::ValueType ValueType;

    struct ConstMatch      { char dummy[ 1]; };
    struct NonConstMatch   { char dummy[17]; };
    struct ConversionMatch { char dummy[65]; };

    struct Impl {
        template &lt;class ARG&gt;
        static ConstMatch test(const KeyType&amp; (*)(const ARG &amp;));

        template&lt;class ARG&gt;
        static NonConstMatch test(KeyType&amp; (*)(ARG &amp;));

        template&lt;class RESULT, class ARG&gt;
        static ConversionMatch test(RESULT (*)(ARG));
    };

    enum { RESULT_SELECTOR = sizeof(Impl::test(&amp;KEY_CONFIG::extractKey)) };

    typedef typename bsl::conditional&lt;RESULT_SELECTOR == sizeof(ConstMatch),
                                      const KeyType&amp;,
            typename bsl::conditional&lt;RESULT_SELECTOR == sizeof(NonConstMatch),
                                      KeyType&amp;,
                                      KeyType&gt;::type&gt;::type Type;
};

                          // ======================
                          // class HashTableImpUtil
                          // ======================

struct HashTableImpUtil {
    // This &#39;struct&#39; provides a namespace for a suite of utility functions
    // for creating and manipulating a hash table.

  private:
    // PRIVATE TYPES
    typedef native_std::size_t size_t;

    // PRIVATE CLASS METHODS
    static HashTableBucket *findBucketForHashCode(
                                              const HashTableAnchor&amp; anchor,
                                              native_std::size_t     hashCode);
        // Return the address of the &#39;HashTableBucket&#39; in the array of buckets
        // referred to by the specified hash-table &#39;anchor&#39; whose index is the
        // adjusted value of the specified &#39;hashCode&#39; (see
        // &#39;computeBucketIndex&#39;).  The behavior is undefined if &#39;anchor&#39;
        // has 0 buckets.

  public:
    // CLASS METHODS
    static bool bucketContainsLink(const HashTableBucket&amp;  bucket,
                                   BidirectionalLink      *linkAddress);
        // Return &#39;true&#39; if the specified &#39;linkAddress&#39; is the address of one
        // of the links in the list of elements in the closed range
        // &#39;[bucket.first(), bucket.last()]&#39;.

    template&lt;class KEY_CONFIG&gt;
    static typename HashTableImpUtil_ExtractKeyResult&lt;KEY_CONFIG&gt;::Type
                                           extractKey(BidirectionalLink *link);
        // Return a reference providing non-modifiable access to the
        // key (of type &#39;KEY_CONFIG::KeyType&#39;) held by the specified
        // &#39;link&#39;.  The behavior is undefined unless &#39;link&#39; refers to a node
        // of type &#39;BidirectionalNode&lt;KEY_CONFIG::ValueType&gt;&#39;.  &#39;KEY_CONFIG&#39;
        // shall be a namespace providing the type names &#39;KeyType&#39; and
        // &#39;ValueType&#39;, as well as a function that can be called as if it had
        // the following signature:
        //..
        //  const KeyType&amp; extractKey(const ValueType&amp; obj);
        //..

    template &lt;class KEY_CONFIG&gt;
    static typename KEY_CONFIG::ValueType&amp; extractValue(
                                                      BidirectionalLink *link);
        // Return a reference providing non-modifiable access to the
        // value (of type &#39;KEY_CONFIG::ValueType&#39;) held by the specified
        // &#39;link&#39;.  The behavior is undefined unless &#39;link&#39; refers to a node
        // of type &#39;BidirectionalNode&lt;KEY_CONFIG::ValueType&gt;&#39;.  &#39;KEY_CONFIG&#39;
        // shall be a namespace providing the type name &#39;ValueType&#39;.

    template &lt;class KEY_CONFIG, class HASHER&gt;
    static bool isWellFormed(const HashTableAnchor&amp;  anchor,
                             const HASHER&amp;           hasher,
                             bslma::Allocator       *allocator = 0);
        // Return &#39;true&#39; if the specified &#39;anchor&#39; is well-formed for the
        // specified &#39;hasher&#39;.  Use the specified &#39;allocator&#39; for temporary
        // memory, or the default allocator if none is specified.  For a
        // &#39;HashTableAnchor&#39; to be considered well-formed for a particular key
        // policy, &#39;KEY_CONFIG&#39;, and hash functor, &#39;hasher&#39;, all of the
        // following must be true:
        //
        //: 1 The &#39;anchor.listRootAddress()&#39; is the address of a
        //:   well-formed doubly linked list (see
        //:   &#39;bslalg_bidirectionallinklistutil&#39;).
        //:
        //: 2 Links in the doubly linked list having the same adjusted hash
        //:   value are contiguous, where the adjusted hash value is the value
        //:   returned by &#39;computeBucketIndex&#39;, for
        //:   &#39;extractKey&lt;KEY_CONFIG&gt;(link)&#39; and &#39;anchor.bucketArraySize()&#39;.
        //:
        //: 3 Links in the doubly linked list having the same hash value are
        //:   contiguous.
        //:
        //: 4 The first and last links in each bucket (in the bucket array,
        //:   anchor.bucketArrayAddress()&#39;) refer to a the first and last
        //:   element in the well-formed doubly linked list of all nodes in the
        //:   list having an adjusted hash value equal to that bucket&#39;s array
        //:   index.  If no values in the doubly linked list have an adjusted
        //:   hash value equal to a bucket&#39;s index, then the addresses of the
        //:   first and last links for that bucket are 0.

    static native_std::size_t computeBucketIndex(
                                                native_std::size_t hashCode,
                                                native_std::size_t numBuckets);
        // Return the index of the bucket referring to the elements whose
        // adjusted hash codes are the same as the adjusted value of the
        // specified &#39;hashCode&#39;, where &#39;hashCode&#39; (and the
        // hash-codes of the elements) are adjusted for the specified
        // &#39;numBuckets&#39;.  The behavior is undefined if &#39;numBuckets&#39; is 0.

    static void insertAtFrontOfBucket(HashTableAnchor    *anchor,
                                      BidirectionalLink  *link,
                                      native_std::size_t  hashCode);
        // Insert the specified &#39;link&#39;, having the specified (non-adjusted)
        // &#39;hashCode&#39;,  into the the specified &#39;anchor&#39;, at the front of the
        // bucket with index
        // &#39;computeBucketIndex(hashCode, anchor-&gt;bucketArraySize())&#39;.  The
        // behavior is undefined unless &#39;anchor&#39; is well-formed (see
        // &#39;isWellFormed&#39;) for some combination of &#39;KEY_CONFIG&#39; and
        // &#39;HASHER&#39; such that &#39;link&#39; refers to a node of type
        // &#39;BidirectionalNode&lt;KEY_CONFIG::ValueType&gt;&#39; and
        // &#39;HASHER(extractKey&lt;KEY_CONFIG&gt;(link))&#39; returns &#39;hashCode&#39;.

    static void insertAtBackOfBucket(HashTableAnchor    *anchor,
                                     BidirectionalLink  *link,
                                     native_std::size_t  hashCode);
        // Insert the specified &#39;link&#39;, having the specified (non-adjusted)
        // &#39;hashCode&#39;, into the the specified &#39;anchor&#39;, into the bucket with
        // index &#39;computeBucketIndex(hashCode, anchor-&gt;bucketArraySize())&#39;,
        // after the last node in the bucket.  The behavior is undefined unless
        // &#39;anchor&#39; is well-formed (see &#39;isWellFormed&#39;) for some combination of
        // &#39;KEY_CONFIG&#39; and &#39;HASHER&#39; such that &#39;link&#39; refers to a node of type
        // &#39;BidirectionalNode&lt;KEY_CONFIG::ValueType&gt;&#39; and
        // &#39;HASHER(extractKey&lt;KEY_CONFIG&gt;(link))&#39; returns &#39;hashCode&#39;.

    static void insertAtPosition(HashTableAnchor    *anchor,
                                 BidirectionalLink  *link,
                                 native_std::size_t  hashCode,
                                 BidirectionalLink  *position);
        // Insert the specified &#39;link&#39;, having the specified (non-adjusted)
        // &#39;hashCode&#39;, into the specified &#39;anchor&#39; immediately before the
        // specified &#39;position&#39; in the bi-directional linked list of &#39;anchor&#39;.
        // The behavior is undefined unless position is in the bucket having
        // index &#39;computeBucketIndex(hashCode, anchor-&gt;bucketArraySize())&#39; and
        // &#39;anchor&#39; is well-formed (see &#39;isWellFormed&#39;) for some combination of
        // &#39;KEY_CONFIG&#39; and &#39;HASHER&#39; such that &#39;link&#39; refers to a node of type
        // &#39;BidirectionalNode&lt;KEY_CONFIG::ValueType&gt;&#39; and
        // &#39;HASHER(extractKey&lt;KEY_CONFIG&gt;(link))&#39; returns &#39;hashCode&#39;.

    static void remove(HashTableAnchor    *anchor,
                       BidirectionalLink  *link,
                       native_std::size_t  hashCode);
        // Remove the specified &#39;link&#39;, having the specified (non-adjusted)
        // &#39;hashCode&#39;, from the specified &#39;anchor&#39;.  The behavior is undefined
        // unless &#39;anchor&#39; is well-formed (see &#39;isWellFormed&#39;) for some
        // combination of &#39;KEY_CONFIG&#39; and &#39;HASHER&#39; such that &#39;link&#39; refers to
        // a node of type &#39;BidirectionalNode&lt;KEY_CONFIG::ValueType&gt;&#39; and
        // &#39;HASHER(extractKey&lt;KEY_CONFIG&gt;(link))&#39; returns &#39;hashCode&#39;.

    template &lt;class KEY_CONFIG, class KEY_EQUAL&gt;
    static BidirectionalLink *find(
              const HashTableAnchor&amp;                                    anchor,
              typename HashTableImpUtil_ExtractKeyResult&lt;KEY_CONFIG&gt;::Type key,
              const KEY_EQUAL&amp;                                 equalityFunctor,
              native_std::size_t                                     hashCode);
        // Return the address of the first link in the list element of
        // the specified &#39;anchor&#39;, having a value matching (according to the
        // specified &#39;equalityFunctor&#39;) the specified &#39;key&#39; in the bucket that
        // holds elements with the specified &#39;hashCode&#39; if such a link exists,
        // and return 0 otherwise.  The behavior is undefined unless, for the
        // provided &#39;KEY_CONFIG&#39; and some hash function, &#39;HASHER&#39;, &#39;anchor&#39; is
        // well-formed (see &#39;isWellFormed&#39;) and &#39;HASHER(key)&#39; returns
        // &#39;hashCode&#39;.  &#39;KEY_CONFIG&#39; shall be a
        // namespace providing the type names &#39;KeyType&#39; and &#39;ValueType&#39;, as
        // well as a function that can be called as if it had the following
        // signature:
        //..
        //  const KeyType&amp; extractKey(const ValueType&amp; obj);
        //..
        // &#39;KEY_EQUAL&#39; shall be a functor that can be called as if it had the
        // following signature:
        //..
        //  bool operator()(const KEY_CONFIG::KeyType&amp; key1,
        //                  const KEY_CONFIG::KeyType&amp; key2)
        //..

    template &lt;class KEY_CONFIG, class HASHER&gt;
    static void rehash(HashTableAnchor   *newAnchor,
                       BidirectionalLink *elementList,
                       const HASHER&amp;      hasher);
        // Populate the specified &#39;newHashTable&#39; with all the elements in the
        // specified &#39;elementList&#39;, using the specified &#39;hasher&#39; to determine
        // the (non-adjusted) hash code for each element.  This operation
        // provides the strong exception guarantee unless the supplied &#39;hasher&#39;
        // throws, in which case it provides no exception safety guarantee.
        // The buckets in the array in &#39;newAnchor&#39; and the list root address in
        // &#39;newAnchor&#39; are assumed to be garbage and overwritten.  The behavior
        // is undefined unless, &#39;newHashTable&#39; holds no elements and has one or
        // more (empty) buckets, and &#39;elementList&#39; is a well-formed
        // bi-directional list (see &#39;BidirectionalLinkListUtil::isWellFormed&#39;)
        // whose nodes are each of type
        // &#39;BidirectionalNode&lt;KEY_CONFIG::ValueType&gt;&#39;, the previous address of
        // the first node and the next address of the last node are 0.
};

// ============================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ============================================================================

                        //-----------------------
                        // class HashTableImpUtil
                        //-----------------------

// PRIVATE CLASS METHODS
inline
HashTableBucket *HashTableImpUtil::findBucketForHashCode(
                                               const HashTableAnchor&amp; anchor,
                                               native_std::size_t     hashCode)
{
    BSLS_ASSERT_SAFE(anchor.bucketArrayAddress());
    BSLS_ASSERT_SAFE(anchor.bucketArraySize());

    native_std::size_t bucketId = HashTableImpUtil::computeBucketIndex(
                                                     hashCode,
                                                     anchor.bucketArraySize());
    return &amp;(anchor.bucketArrayAddress()[bucketId]);
}

inline
native_std::size_t HashTableImpUtil::computeBucketIndex(
                                                 native_std::size_t hashCode,
                                                 native_std::size_t numBuckets)
{
    BSLS_ASSERT_SAFE(0 != numBuckets);

    return hashCode % numBuckets;
}

inline
bool HashTableImpUtil::bucketContainsLink(const HashTableBucket&amp;   bucket,
                                          BidirectionalLink       *linkAddress)
    // Return true the specified &#39;link&#39; is contained in the specified &#39;bucket&#39;
    // and false otherwise.
{
    BSLS_ASSERT_SAFE(!bucket.first() == !bucket.last());

    for (BidirectionalLink *cursor     = bucket.first(),
                           * const end = bucket.end(); end != cursor;
                                                 cursor = cursor-&gt;nextLink()) {
        if (linkAddress == cursor) {
            return true;                                              // RETURN
        }

        BSLS_ASSERT_SAFE(cursor);
    }

    return false;
}

// CLASS METHODS
template&lt;class KEY_CONFIG&gt;
inline
typename KEY_CONFIG::ValueType&amp; HashTableImpUtil::extractValue(
                                                       BidirectionalLink *link)
{
    BSLS_ASSERT_SAFE(link);

    typedef BidirectionalNode&lt;typename KEY_CONFIG::ValueType&gt; BNode;
    return static_cast&lt;BNode *&gt;(link)-&gt;value();
}

template&lt;class KEY_CONFIG&gt;
inline
typename HashTableImpUtil_ExtractKeyResult&lt;KEY_CONFIG&gt;::Type
HashTableImpUtil::extractKey(BidirectionalLink *link)
{
    BSLS_ASSERT_SAFE(link);

    typedef BidirectionalNode&lt;typename KEY_CONFIG::ValueType&gt; BNode;

    BNode *node = static_cast&lt;BNode *&gt;(link);
    return KEY_CONFIG::extractKey(node-&gt;value());
}

template &lt;class KEY_CONFIG, class KEY_EQUAL&gt;
inline
BidirectionalLink *HashTableImpUtil::find(
  const HashTableAnchor&amp;                                       anchor,
  typename HashTableImpUtil_ExtractKeyResult&lt;KEY_CONFIG&gt;::Type key,
  const KEY_EQUAL&amp;                                             equalityFunctor,
  native_std::size_t                                           hashCode)
{
    BSLS_ASSERT_SAFE(anchor.bucketArrayAddress());
    BSLS_ASSERT_SAFE(anchor.bucketArraySize());

    const HashTableBucket *bucket = findBucketForHashCode(anchor, hashCode);
    BSLS_ASSERT_SAFE(bucket);

    for (BidirectionalLink *cursor     = bucket-&gt;first(),
                           * const end = bucket-&gt;end();
                                 end != cursor; cursor = cursor-&gt;nextLink() ) {
        if (equalityFunctor(key, extractKey&lt;KEY_CONFIG&gt;(cursor))) {
            return cursor;                                            // RETURN
        }
    }

    return 0;
}

template &lt;class KEY_CONFIG, class HASHER&gt;
void HashTableImpUtil::rehash(HashTableAnchor   *newAnchor,
                              BidirectionalLink *elementList,
                              const HASHER&amp;      hasher)
{
    BSLS_ASSERT_SAFE(newAnchor);
    BSLS_ASSERT_SAFE(newAnchor-&gt;bucketArrayAddress());
    BSLS_ASSERT_SAFE(0 != newAnchor-&gt;bucketArraySize());
    BSLS_ASSERT_SAFE(!elementList || !elementList-&gt;previousLink());

    class Proctor {
        // An object of this proctor class guarantees that, on leaving scope,
        // any remaining elements in the original specified &#39;elementList&#39; are
        // spliced to the front of the list rooted in the specified &#39;newAnchor&#39;
        // so that there is only one list for the client to clear if an
        // exception is thrown by a user supplied hash functor.  Note that it
        // might be possible to avoid creating such a proctor in C++11 if the
        // hash functor is determined to be &#39;noexcept&#39;.

      private:
        BidirectionalLink **d_sourceList;
        HashTableAnchor    *d_targetAnchor;

#if !defined(BSLS_PLATFORM_CMP_MSVC)           // Microsoft warns if these
        Proctor(const Proctor&amp;); // = delete;  // methods are declared private.
        Proctor&amp; operator=(const Proctor&amp;); // = delete;
#endif

      public:
        Proctor(BidirectionalLink **sourceList,
                HashTableAnchor    *targetAnchor)
        : d_sourceList(sourceList)
        , d_targetAnchor(targetAnchor)
        {
            BSLS_ASSERT(sourceList);
            BSLS_ASSERT(targetAnchor);
        }

        ~Proctor()
        {
            if (BidirectionalLink *lastLink = *d_sourceList) {
                for( ; lastLink-&gt;nextLink(); lastLink = lastLink-&gt;nextLink()) {
                    // This loop body is intentionally left blank.
                }
                BidirectionalLinkListUtil::spliceListBeforeTarget(
                                           *d_sourceList,
                                            lastLink,
                                            d_targetAnchor-&gt;listRootAddress());
            }
        }
    };

    // The callers of this function should be rewritten to take into account
    // that it is the responsibility of this function, not its callers, to zero
    // out the buckets.

    for (void **cursor     = (void **)  newAnchor-&gt;bucketArrayAddress(),
              ** const end = (void **) (newAnchor-&gt;bucketArrayAddress() +
                                        newAnchor-&gt;bucketArraySize());
                                                      cursor &lt; end; ++cursor) {
        *cursor = 0;
    }
    newAnchor-&gt;setListRootAddress(0);

    Proctor enforceSingleListOnExit(&amp;elementList, newAnchor);

    while (elementList) {
        BidirectionalLink *nextNode = elementList;
        elementList = elementList-&gt;nextLink();

        insertAtBackOfBucket(newAnchor,
                             nextNode,
                             hasher(extractKey&lt;KEY_CONFIG&gt;(nextNode)));
    }
}

template &lt;class KEY_CONFIG, class HASHER&gt;
bool HashTableImpUtil::isWellFormed(const HashTableAnchor&amp;  anchor,
                                    const HASHER&amp;           hasher,
                                    bslma::Allocator       *allocator)
{
    HashTableBucket    *array = anchor.bucketArrayAddress();
    size_t              size  = anchor.bucketArraySize();
    BidirectionalLink  *root  = anchor.listRootAddress();

    if (!array || !size) {
        return false;                                                 // RETURN
    }

    if (!root) {
        // An empty list, so there should be no pointers set in the bucket
        // array.
        for (size_t i = 0; i &lt; size; ++i) {
            const HashTableBucket&amp; b = array[i];
            if  (b.first() || b.last()) {
                return false;                                         // RETURN
            }
        }

        return true;                                                  // RETURN
    }

    if (!allocator) {
        allocator = bslma::Default::defaultAllocator();
    }

    bool *bucketsUsed = (bool *) allocator-&gt;allocate(size);
    bslma::DeallocatorGuard&lt;bslma::Allocator&gt; guard(bucketsUsed, allocator);
    for (size_t i = 0; i &lt; size; ++i) {
        bucketsUsed[i] = false;
    }

    size_t hash = hasher(extractKey&lt;KEY_CONFIG&gt;(root));
    size_t bucketIdx = computeBucketIndex(hash, size);
    if (array[bucketIdx].first() != root) {
        return false;                                                 // RETURN
    }

    bucketsUsed[bucketIdx] = true;

    BidirectionalLink *prev = root;
    size_t prevBucketIdx    = bucketIdx;
    while (BidirectionalLink *cursor = prev-&gt;nextLink()) {
        if (cursor-&gt;previousLink() != prev) {
            return false;                                             // RETURN
        }

        hash      = hasher(extractKey&lt;KEY_CONFIG&gt;(cursor));
        bucketIdx = computeBucketIndex(hash, size);

        if (bucketIdx != prevBucketIdx) {
            // New bucket

            // We should be the first node in the new bucket, so if this
            // bucket&#39;s been visited before, it&#39;s an error.

            if (bucketsUsed[bucketIdx]) {
                return false;                                         // RETURN
            }
            bucketsUsed[bucketIdx] = true;

            // Since we&#39;re the first node in the bucket, bucket.first()
            // should point at us.

            if (array[bucketIdx].first() != cursor) {
                return false;                                         // RETURN
            }

            // &#39;last()&#39; of the previous bucket should point at the
            // previous node.

            if (array[prevBucketIdx].last() != prev) {
                return false;                                         // RETURN
            }
        }

        // Set &#39;prev&#39; variables for next iteration
        prev          = cursor;
        prevBucketIdx = bucketIdx;
    }

    if (array[prevBucketIdx].last() != prev) {
        return false;                                                 // RETURN
    }

    // Check that traversing the root list traversed all non-empty buckets.

    for (size_t i = 0; i &lt; size; ++i) {
        const HashTableBucket&amp; b = array[i];
        if (bucketsUsed[i]) {
            if  (!b.first() || !b.last()) {
                return false;                                         // RETURN
            }
        }
        else if ( b.first() ||  b.last()) {
            return false;                                             // RETURN
        }
    }

    return true;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
