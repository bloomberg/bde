<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlb_guid.h                                                        -*-C++-*-
#ifndef INCLUDED_BDLB_GUID
#define INCLUDED_BDLB_GUID

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

//@PURPOSE: Provide a value-semantic type for Globally Unique Identifiers.
//
//@CLASSES:
//  bdlb::Guid: value-semantic type to represent Globally Unique Identifiers
//
//@SEE_ALSO: bdlb_guidutil
//
//@DESCRIPTION: This component provides a value-semantic type for Globally
// Unique Identifiers (GUIDs), &#39;bdlb::Guid&#39;, with format as described by RFC
// 4122 (&lt;http://http://www.ietf.org/rfc/rfc4122.txt&gt;).  All equality and
// comparison methods are defined for these GUIDs.  Note that this component
// does not provide the facilities to generate GUIDs, and thus makes no
// guarantees of uniqueness or randomness.
//
///Usage
///-----
// Suppose we are building a utility to create globally unique names which may
// be based on a common base name, such as a code-generator.
//
// First, let us define the core types needed, the first of which is a utility
// to allocate GUIDs.
//..
//  struct MyGuidGeneratorUtil {
//      // This struct provides a namespace for methods to generate GUIDs.
//
//      // CLASS METHODS
//      static int generate(bdlb::Guid *guid);
//          // Generate a version 1 GUID, placing the value into the
//          // specified &#39;guid&#39; pointer.  Return 0 on success, and non-zero
//          // otherwise.
//  };
//
//  // CLASS METHODS
//  inline
//  int my_GuidGeneratorUtil::generate(bdlb::Guid *guid)
//  {
//      // For brevity, we use a static sequence of pre-generated GUIDs.
//
//      static unsigned char GUIDS[][bdlb::Guid::k_GUID_NUM_BYTES] = {
//          { 0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe, 0xba, 0xbe,
//            0x91, 0x91, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66 },
//
//          { 0x5c, 0x9d, 0x4e, 0x51, 0x0d, 0xf1, 0x11, 0xe4,
//            0x91, 0x91, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66 },
//
//          { 0x5c, 0x9d, 0x4e, 0x52, 0x0d, 0xf1, 0x11, 0xe4,
//            0x91, 0x91, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66 },
//
//          { 0x5c, 0x9d, 0x4e, 0x53, 0x0d, 0xf1, 0x11, 0xe4,
//            0x91, 0x91, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66 },
//
//          { 0x5c, 0x9d, 0x4e, 0x54, 0x0d, 0xf1, 0x11, 0xe4,
//            0x91, 0x91, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66 },
//
//          { 0x5c, 0x9d, 0x4e, 0x55, 0x0d, 0xf1, 0x11, 0xe4,
//            0x91, 0x91, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66 },
//
//          { 0x5c, 0x9d, 0x4e, 0x56, 0x0d, 0xf1, 0x11, 0xe4,
//            0x91, 0x91, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66 },
//      };
//
//      const bsl::size_t NUM_GUIDS = sizeof GUIDS / sizeof *GUIDS;
//
//      static bsl::size_t nextGuidIdx = 0;
//
//      int rval = -1;
//      if (nextGuidIdx++ &lt; NUM_GUIDS) {
//          *guid = bdlb::Guid(GUIDS[nextGuidIdx]);
//          rval = 0;
//      }
//      return rval;
// }
//..
//  Next, we create a utility to create unique strings.
//..
//  struct UniqueStringGenerator {
//      // This struct provides methods to create globally unique strings.
//
//      static int uniqueStringFromBase(bsl::string        *unique,
//                                      const bsl::string&amp;  base);
//            // Create a globally unique string from the specified non-unique
//            // &#39;base&#39; string, placing the result into the specified &#39;unique&#39;
//            // string pointer.
//
//  };
//
//  int
//  UniqueStringGenerator::uniqueStringFromBase(bsl::string        *unique,
//                                              const bsl::string&amp;  base,)
//  {
//      bdlb::Guid guid;
//
//      int rval = my_GuidGeneratorUtil::generate(&amp;guid);
//      if (rval == 0) {
//      {
//          ostringstream convert;
//          convert &lt;&lt; base &lt;&lt; &quot;-&quot; &lt;&lt; guid;
//          *unique = convert.str();
//      }
//      return rval;
//  }
//..
//  Finally, we implement a program to generate unique names for a code
//  auto-generator.
//..
//  bsl::string baseFileName = &quot;foo.cpp&quot;;
//  bsl::string uniqueFileName;
//  bsl::string previousFileName;
//
//  const bsl::size_t NUM_FILES = 5;
//  for (bsl::size_t i = 0; i &lt; NUM_FILES; ++i) {
//      UniqueStringGenerator::uniqueStringFromBase(&amp;uniqueFileName,
//                                                  baseFileName);
//      assert(previousFileName != uniqueFileName);
//       previousFileName = uniqueFileName;
//  }
//..

#ifndef INCLUDED_BSL_ALGORITHM
#include &lt;bsl_algorithm.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDDEF
#include &lt;bsl_cstddef.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEEQUALITYCOMPARABLE
#include &lt;bslmf_isbitwiseequalitycomparable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYCOPYABLE
#include &lt;bslmf_istriviallycopyable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

namespace BloombergLP {
namespace bdlb {
                                // ==========
                                // bdlb::Guid
                                // ==========
class Guid {
    // This class implements a value-semantic &#39;Guid&#39; type.  Each object
    // represents an unconstrained &#39;Guid&#39; object, but its uniqueness is *not*
    // guaranteed, and this component provides no ability to generate a GUID.
    //
    // This class provides a constructor and several accessors with names and
    // parameters phrased using RFC 4122 field names.  These names are used (by
    // RFC 4122 and this component) as designators for parts of the GUID even
    // when those names do not accurately describe the parts (for example,
    // &#39;time low&#39; names bytes 0-3 of the GUID regardless of whether the values
    // of those bytes come from a clock or are generated randomly).

  public:
    // CLASS DATA
    enum { k_GUID_NUM_BYTES = 16 };            // number of bytes in a guid

    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(Guid, bslmf::IsBitwiseEqualityComparable)
    BSLMF_NESTED_TRAIT_DECLARATION(Guid, bsl::is_trivially_copyable)

  private:
    // DATA
    unsigned char d_buffer[k_GUID_NUM_BYTES];  // byte array to hold the guid

    // FRIENDS
    friend bool operator==(const Guid&amp; lhs, const Guid&amp; rhs);
    friend bool operator!=(const Guid&amp; lhs, const Guid&amp; rhs);

  public:
    // CREATORS
    Guid();
        // Construct a zero-initialized guid object.  Note that a zero-
        // initialized guid object is not a GUID according to RFC 4122.

    //! ~Guid() = default;
        // Destroy this object

    explicit Guid(const unsigned char (&amp;buffer)[k_GUID_NUM_BYTES]);
        // Construct a guid object with the internal buffer set equal to the
        // specified &#39;buffer&#39; with the first byte representing the most
        // significant byte.  Note that this method does guarantee that the
        // created guid object is a GUID.

    Guid(unsigned long       timeLow,
         unsigned short      timeMid,
         unsigned short      timeHiAndVersion,
         unsigned char       clockSeqHiRes,
         unsigned char       clockSeqLow,
         bsls::Types::Uint64 node);
        // Construct a guid object with an internal buffer composed from the
        // specified &#39;timeLow&#39;, &#39;timeMid&#39;, &#39;timeHiAndVersion&#39;, &#39;clockSeqHiRes&#39;,
        // &#39;clockSeqLow&#39;, and &#39;node&#39; as specified by RFC 4122.  Note that only
        // the least significant 48 bits of &#39;node&#39; are used in constructing
        // the guid.

    //! Guid(const Guid&amp; original) = default;
        // Construct a guid object having the same value as the specified
        // &#39;original&#39; object.

    // MANIPULATORS
    //! Guid&amp; operator=(const Guid&amp; rhs) = default;
        // Assign to this guid object the value of the specified &#39;rhs&#39; and
        // return a reference to this modifiable object.

    Guid&amp; operator=(const unsigned char (&amp;buffer)[k_GUID_NUM_BYTES]);
        // Assign to the buffer of this guid the byte sequence in the specified
        // &#39;buffer&#39;.

    // ACCESSORS
    const unsigned char&amp; operator[](bsl::size_t offset) const;
        // Return a reference offering unmodifiable access to the byte at the
        // specified &#39;offset&#39; from the most significant byte of this guid
        // object.  The behavior is undefined unless
        // &#39;0 &lt;= offset &lt; k_GUID_NUM_BYTES&#39;.

    const unsigned char *begin() const;
    const unsigned char *data() const;
        // Return a pointer offering unmodifiable access to the most
        // significant byte of this guid object.

    const unsigned char *end() const;
        // Return a pointer one past the end of the least significant byte of
        // this guid object.

                        // RFC 4122 FIELD ACCESSORS

    unsigned char clockSeqHi() const;
        // Return the 5-bit value of the &#39;clk_seq_hi_res&#39; field of this guid as
        // specified in RFC 4122, excluding the variant bits.

    unsigned char clockSeqHiRes() const;
        // Return the 8-bit &#39;clk_seq_hi_res&#39; field of this guid as specified in
        // RFC 4122.

    unsigned char clockSeqLow() const;
        // Return the 8-bit &#39;clk_seq_low&#39; field of this guid as specified in
        // RFC 4122.

    bsls::Types::Uint64 node() const;
        // Return the 48-bit &#39;node&#39; field of this guid as specified in RFC
        // 4122.

    unsigned short timeHi() const;
        // Return the 12-bit value of the &#39;time_hi_and_version&#39; field of this
        // guid as specified in RFC 4122, excluding the &#39;version&#39; bits.

    unsigned short timeHiAndVersion() const;
        // Return the 16-bit &#39;time_hi_and_version&#39; field of this guid as
        // specified in RFC 4122.

    unsigned long timeLow() const;
        // Return the 32-bit &#39;time_low&#39; field of this guid as specified in RFC
        // 4122.

    unsigned short timeMid() const;
        // Return the 16-bit &#39;time_mid&#39; field of this guid as specified in RFC
        // 4122.

    unsigned char variant() const;
        // Return the 3-bit &#39;variant&#39; portion of the &#39;clk_seq_hi_res&#39; field of
        // this guid as specified in RFC 4122.

    unsigned char version() const;
        // Return the four-bit &#39;version&#39; portion of the &#39;time_hi_and_version&#39;
        // field of this guid as specified in RFC 4122.

    // ASPECTS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Write the value of this object to the specified output &#39;stream&#39; in a
        // human-readable format, and return a reference to &#39;stream&#39;.
        // Optionally specify an initial indentation &#39;level&#39;, whose absolute
        // value is incremented recursively for nested objects.  If &#39;level&#39; is
        // specified, optionally specify &#39;spacesPerLevel&#39;, whose absolute value
        // indicates the number of spaces per indentation level for this and
        // all of its nested objects.  If &#39;level&#39; is negative, suppress
        // indentation of the first line.  If &#39;spacesPerLevel&#39; is negative,
        // format the entire output on one line, suppressing all but the
        // initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is not
        // valid on entry, this operation has no effect.  Note that this
        // human-readable format is not fully specified, and can change without
        // notice.
};

// FREE OPERATORS
bool operator==(const Guid&amp; lhs, const Guid&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and specified &#39;rhs&#39; guid objects
    // have the same value, and &#39;false&#39; otherwise.  Two guid objects have the
    // same value if each corresponding byte in their internal buffers are
    // equal.

bool operator!=(const Guid&amp; lhs, const Guid&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and specified &#39;rhs&#39; guid objects
    // have different values, and &#39;false&#39; otherwise.  Two guid objects have
    // different value if any of corresponding byte in their internal buffers
    // differ.

bool operator&lt; (const Guid&amp; lhs, const Guid&amp; rhs);
    // Return &#39;true&#39; if the value of the specified &#39;lhs&#39; guid object is less
    // than the value of the specified &#39;rhs&#39; guid object, and &#39;false&#39;
    // otherwise.  Note that the comparison is accomplished using a
    // lexicographic comparison of the internal representations.

bool operator&lt;=(const Guid&amp; lhs, const Guid&amp; rhs);
    // Return &#39;true&#39; if the value of the specified &#39;lhs&#39; guid object is less
    // than or equal to the value of the specified &#39;rhs&#39; guid object, and
    // &#39;false&#39; otherwise.  Note that the comparison is accomplished using  a
    // lexicographic comparison of the internal representations.

bool operator&gt; (const Guid&amp; lhs, const Guid&amp; rhs);
    // Return &#39;true&#39; if the value of the specified &#39;lhs&#39; guid object is greater
    // than the value of the specified &#39;rhs&#39; guid object, and &#39;false&#39;
    // otherwise.  Note that the comparison is accomplished using a
    // lexicographic comparison of the internal representations.

bool operator&gt;=(const Guid&amp; lhs, const Guid&amp; rhs);
    // Return &#39;true&#39; if the value of the specified &#39;lhs&#39; guid object is greater
    // than or equal to the value of the specified &#39;rhs&#39; guid object, and
    // &#39;false&#39; otherwise.  Note that the comparison is accomplished using a
    // lexicographic comparison of the internal representations.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Guid&amp; guid);
    // Write the value of the specified &#39;guid&#39; object to the specified output
    // &#39;stream&#39; in a single-line format, and return a reference to &#39;stream&#39;.
    // If &#39;stream&#39; is not valid on entry, this operation has no effect.  Note
    // that this human-readable format is not fully specified, can change
    // without notice, and is logically equivalent to:
    //..
    //  print(stream, 0, -1);
    //..

template &lt;class HASH_ALGORITHM&gt;
void hashAppend(HASH_ALGORITHM&amp; hashAlgorithm, const Guid&amp; guid);
    // Invoke the specified &#39;hashAlgorithm&#39; on the underlying buffer held by
    // the specified &#39;guid&#39; object.

// ============================================================================
//                      INLINE DEFINITIONS
// ============================================================================

                                // ----------
                                // bdlb::Guid
                                // ----------
// CREATORS
inline
Guid::Guid()
{
    bsl::fill(d_buffer, d_buffer + k_GUID_NUM_BYTES, 0);
}

inline
Guid::Guid(const unsigned char (&amp;buffer)[k_GUID_NUM_BYTES])
{
    bsl::copy(buffer, buffer + k_GUID_NUM_BYTES, d_buffer);
}

inline Guid::Guid(unsigned long       timeLow,
                  unsigned short      timeMid,
                  unsigned short      timeHiAndVersion,
                  unsigned char       clockSeqHiRes,
                  unsigned char       clockSeqLow,
                  bsls::Types::Uint64 node)
{
    typedef unsigned char uc;

    d_buffer[ 0] = uc(timeLow &gt;&gt; 24);
    d_buffer[ 1] = uc(timeLow &gt;&gt; 16);
    d_buffer[ 2] = uc(timeLow &gt;&gt;  8);
    d_buffer[ 3] = uc(timeLow);

    d_buffer[ 4] = uc(timeMid &gt;&gt; 8);
    d_buffer[ 5] = uc(timeMid);

    d_buffer[ 6] = uc(timeHiAndVersion &gt;&gt; 8);
    d_buffer[ 7] = uc(timeHiAndVersion);

    d_buffer[ 8] = uc(clockSeqHiRes);

    d_buffer[ 9] = uc(clockSeqLow);

    d_buffer[10] = uc(node &gt;&gt; 40);
    d_buffer[11] = uc(node &gt;&gt; 32);
    d_buffer[12] = uc(node &gt;&gt; 24);
    d_buffer[13] = uc(node &gt;&gt; 16);
    d_buffer[14] = uc(node &gt;&gt;  8);
    d_buffer[15] = uc(node);
}

// MANIPULATORS
inline
Guid&amp; Guid::operator=(const unsigned char (&amp;buffer)[k_GUID_NUM_BYTES])
{
    bsl::copy(buffer, buffer + k_GUID_NUM_BYTES, d_buffer);
    return *this;
}

// ACCESSORS
inline
const unsigned char&amp; Guid::operator[](bsl::size_t offset) const
{
    BSLS_ASSERT_SAFE(offset &lt; k_GUID_NUM_BYTES);
    return d_buffer[offset];
}

inline
const unsigned char *Guid::begin() const
{
    return d_buffer;
}

inline
const unsigned char *Guid::data() const
{
    return d_buffer;
}

inline
const unsigned char *Guid::end() const
{
    return d_buffer + k_GUID_NUM_BYTES;
}

                        // RFC 4122 FIELD ACCESSORS

inline
unsigned char Guid::clockSeqHi() const
{
    return clockSeqHiRes() &amp; 0x1F;
}

inline
unsigned char Guid::clockSeqHiRes() const
{
    return d_buffer[8];
}

inline
unsigned char Guid::clockSeqLow() const
{
    return d_buffer[9];
}

inline
bsls::Types::Uint64 Guid::node() const
{
    return bsls::Types::Uint64(d_buffer[10]) &lt;&lt; 40 |
           bsls::Types::Uint64(d_buffer[11]) &lt;&lt; 32 |
           bsls::Types::Uint64(d_buffer[12]) &lt;&lt; 24 |
           bsls::Types::Uint64(d_buffer[13]) &lt;&lt; 16 |
           bsls::Types::Uint64(d_buffer[14]) &lt;&lt;  8 |
                               d_buffer[15];
}

inline
unsigned short Guid::timeHi() const
{
    return timeHiAndVersion() &amp; 0x0FFF;
}

inline
unsigned short Guid::timeHiAndVersion() const
{
    typedef unsigned short us;
    return us(d_buffer[6] &lt;&lt; 8 |
              d_buffer[7]);
}

inline
unsigned long Guid::timeLow() const {
    typedef unsigned long ul;
    return ul(d_buffer[0]) &lt;&lt; 24 |
              d_buffer[1]  &lt;&lt; 16 |
              d_buffer[2]  &lt;&lt;  8 |
              d_buffer[3];
}

inline
unsigned short Guid::timeMid() const {
    typedef unsigned short us;
    return us(d_buffer[4] &lt;&lt; 8 |
              d_buffer[5]);
}

inline
unsigned char Guid::variant() const {
    typedef unsigned char uc;
    return uc(clockSeqHiRes() &gt;&gt; 5);
}

inline
unsigned char Guid::version() const {
    typedef unsigned char uc;
    return uc(timeHiAndVersion() &gt;&gt; 12);
}

}  // close package namespace

// FREE OPERATORS
inline
bsl::ostream&amp; bdlb::operator&lt;&lt;(bsl::ostream&amp; stream, const bdlb::Guid&amp; guid)
{
    return guid.print(stream, 0, -1);
}

inline
bool bdlb::operator==(const bdlb::Guid&amp; lhs, const bdlb::Guid&amp; rhs)
{
    return bsl::equal(
        lhs.d_buffer, lhs.d_buffer + lhs.k_GUID_NUM_BYTES, rhs.d_buffer);
}

inline
bool bdlb::operator!=(const bdlb::Guid&amp; lhs, const bdlb::Guid&amp; rhs)
{
    return !bsl::equal(
        lhs.d_buffer, lhs.d_buffer + lhs.k_GUID_NUM_BYTES, rhs.d_buffer);
}

template &lt;class HASH_ALGORITHM&gt;
void bdlb::hashAppend(HASH_ALGORITHM&amp; hashAlgorithm, const Guid&amp; guid)
{
    hashAlgorithm(guid.data(), Guid::k_GUID_NUM_BYTES);
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
