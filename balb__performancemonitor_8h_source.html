<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// balb_performancemonitor.h                                          -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALB_PERFORMANCEMONITOR
#define INCLUDED_BALB_PERFORMANCEMONITOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a mechanism to collect process performance measures.
//
//@CLASSES:
//   balb::PerformanceMonitor: monitor process performance
//   balb::PerformanceMonitor::Statistics: performance stats
//   balb::PerformanceMonitor::ConstIterator: stats iteration
//
//@DESCRIPTION: This component provides an application developer the means to
// collect and report performance statistics for an arbitrary number of
// processes running on the local machine.  The &#39;balb::PerformanceMonitor&#39;
// provides the mechanism for doing so, the
// &#39;balb::PerformanceMonitor::Statistics&#39; class holds the data and the
// &#39;balb::PerformanceMonitor::ConstIterator&#39; class is used to iterate over the
// data.  The following table describes the measures collecting by this
// component.  Note that all the collected measures are specific to the
// monitored process and do not refer to any system-wide measurement.
//..
// Measure           Identifier           Description
// -------           ----------           -----------
// User CPU Time     e_CPU_TIME_USER   Total amount of time spent executing
//                                        instructions in user mode.
//
// System CPU Time   e_CPU_TIME_SYSTEM Total amount of time spent executing
//                                        instructions in kernel mode.
//
// CPU Time          e_CPU_TIME        The sum of User and System CPU times.
//
// User CPU %        e_CPU_UTIL_USER   Percentage of elapsed CPU time this
//                                        process spent executing instructions
//                                        in user mode.
//
// System CPU %      e_CPU_UTIL_SYSTEM Percentage of elapsed CPU time this
//                                        process spent executing instructions
//                                        in kernel mode.
//
// CPU %             e_CPU_UTIL        Sum of User CPU % and System CPU %.
//
// Resident Size     e_RESIDENT_SIZE   Number of mega-bytes of physical
//                                        memory used by the process.
//
// Virtual Size      e_VIRTUAL_SIZE    The size of the heap, in
//                                        mega-bytes. This value does not
//                                        include the size of the address
//                                        space mapped to files (anonymous or
//                                        otherwise.)
//
// Thread Count      e_NUM_THREADS     Number of threads executing in the
//                                        process.
//
// Page Faults       e_NUM_PAGEFAULTS  Total number of page faults incurred
//                                        throughout the lifetime of the
//                                        process.
//..
//
///OS-Specific Permissions
///-----------------------
// Various OSs might require specific permissions in order to inspect processes
// other than the current process.  For example, on Darwin, users other than
// root can only inspect processes running under the user with which the
// current process is running.  This error condition will be indicated by a
// non-zero return value from &#39;registerPid&#39;.
//
///Iterator Invalidation
///---------------------
// Registration of new pids does not invalidate existing iterators.
// Unregistration of pid only invalidates iterators pointing to the statistics
// for the pid being unregistered, all other iterators remain valid.
//
///Thread Safety
///-------------
// This class is completely thread safe.
//
///Usage
///-----
// The following example shows how to monitor the currently executing process
// and produce a formatted report of the collected measures after a certain
// interval.
//..
//  // Instantiate a scheduler used by the performance monitor to schedule
//  // collection events.
//  bdlmt::TimerEventScheduler scheduler;
//  scheduler.start();
//
//  // Create the performance monitor, monitoring the current process and
//  // auto-collecting statistics every second.
//  balb::PerformanceMonitor perfmon(&amp;scheduler, 1.0);
//
//  // Assume the existence of three pids, 1000, 1001, and 1002, running on
//  // the local machine.
//  perfmon.registerPid(1000, &quot;task1&quot;);
//  perfmon.registerPid(1001, &quot;task2&quot;);
//  perfmon.registerPid(1003, &quot;task3&quot;);
//
//  // Print a formatted report of the performance statistics collected for
//  // each pid every 10 seconds for one minute.
//  for (int i = 0; i &lt; 6; ++i) {
//      bslmt::ThreadUtil::microSleep(0, 10);
//
//      for (balb::PerformanceMonitor::ConstIterator it  = perfmon.begin();
//                                                  it != perfmon.end();
//                                                ++it) {
//          const balb::PerformanceMonitor::Statistics&amp; stats = *it;
//          bsl::cout &lt;&lt; &quot;Pid = &quot; &lt;&lt; stats.pid() &lt;&lt; &quot;:\n&quot;;
//          stats.print(bsl::cout);
//      }
//  }
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMT_READLOCKGUARD
#include &lt;bslmt_readlockguard.h&gt;
#endif

#ifndef INCLUDED_BSLMT_RWMUTEX
#include &lt;bslmt_rwmutex.h&gt;
#endif

#ifndef INCLUDED_BDLMT_TIMEREVENTSCHEDULER
#include &lt;bdlmt_timereventscheduler.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMIC
#include &lt;bsls_atomic.h&gt;
#endif

#ifndef INCLUDED_BDLT_DATETIME
#include &lt;bdlt_datetime.h&gt;
#endif

#ifndef INCLUDED_BSLS_TIMEINTERVAL
#include &lt;bsls_timeinterval.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSL_ITERATOR
#include &lt;bsl_iterator.h&gt;
#endif

#ifndef INCLUDED_BSL_MAP
#include &lt;bsl_map.h&gt;
#endif

#ifndef INCLUDED_BSL_MEMORY
#include &lt;bsl_memory.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

namespace BloombergLP {

namespace balb {
                          // ========================
                          // class PerformanceMonitor
                          // ========================

class PerformanceMonitor {
    // Provides a mechanism to collect performance statistics for an arbitrary
    // number of processes running on the local machine.

  public:
    // FRIENDS
    class Statistics;
    friend class Statistics;
        // Grant visibility of private types to &#39;Statistics&#39;.

    class ConstIterator;
    friend class ConstIterator;
        // Grant visibility of private types to &#39;ConstIterator&#39;.

  private:
    // PRIVATE TYPES

    // Defines a type alias for the operating system type discovered by the
    // &#39;bsls::platform&#39; component.  This type alias is used to specifically
    // select a particular template specialization of the &#39;Collector&#39; template.

#if defined(BSLS_PLATFORM_OS_LINUX) || defined(BSLS_PLATFORM_OS_CYGWIN)
    typedef bsls::Platform::OsLinux   OsType;
#elif defined(BSLS_PLATFORM_OS_FREEBSD)
    typedef bsls::Platform::OsFreeBsd OsType;
#elif defined(BSLS_PLATFORM_OS_DARWIN)
    typedef bsls::Platform::OsDarwin  OsType;
/*
#elif defined(BSLS_PLATFORM_OS_HPUX)
typedef bsls::Platform::OsHpUx OsType;
*/
#elif defined(BSLS_PLATFORM_OS_UNIX)
    typedef bsls::Platform::OsUnix    OsType;
#elif defined(BSLS_PLATFORM_OS_WINDOWS)
    typedef bsls::Platform::OsWindows OsType;
#endif

    template &lt;class PLATFORM&gt;
    class Collector;
        // Forward declares a class template for a performance measure
        // collector for a parameterized &#39;PLATFORM&#39;.  This class template is
        // never defined.  Instead, we define explicit specializations for
        // supported platforms.  Any attempt to compile this component on
        // unsupported platforms will result in a compile-time error.

    typedef Collector&lt;OsType&gt; CollectorType;
        // Defines a type alias for the type that defines the private platform-
        // specific mechanism used to collect the performance measures for a
        // pid.

    typedef bsl::shared_ptr&lt;CollectorType&gt; CollectorPtr;
        // Defines a type alias for the shared pointer to the platform-specific
        // mechanism used to collect the performance measures for a pid.

    typedef bsl::shared_ptr&lt;Statistics&gt; StatisticsPtr;
        // Defines a type alias for the shared pointer to the platform-specific
        // mechanism used to collect the performance measures for a pid.

    typedef bsl::map&lt;int, bsl::pair&lt;StatisticsPtr, CollectorPtr&gt; &gt; PidMap;
        // Defines a type alias for the map of pids to their collected
        // statistics and associated platform-specific collector
        // implementation.

    // DATA
    PidMap                              d_pidMap;       // map of pid stats

    double                              d_interval;     // collection interval

    bdlmt::TimerEventScheduler         *d_scheduler_p;  // scheduler of
                                                        // collection events
                                                        // (held)

    bdlmt::TimerEventScheduler::Handle  d_clock;        // handle to collection
                                                        // timer

    mutable bslmt::RWMutex              d_mapGuard;     // serializes write
                                                        // access to &#39;d_pidMap&#39;

    bslma::Allocator                   *d_allocator_p;  // supplies memory
                                                        // (held)

  private:
    // NOT IMPLEMENTED
    PerformanceMonitor(const PerformanceMonitor&amp;);
    PerformanceMonitor&amp; operator=(const PerformanceMonitor&amp;);

  public:
    // TYPES
    enum Measure {
        // Enumerates the set of performance measures this class is capable of
        // monitoring.

        e_CPU_TIME,          // CPU time (seconds)
        e_CPU_TIME_USER,     // user CPU time (seconds)
        e_CPU_TIME_SYSTEM,   // system CPU time (seconds)
        e_CPU_UTIL,          // weighted CPU % (user + system)
        e_CPU_UTIL_USER,     // weighted user CPU %
        e_CPU_UTIL_SYSTEM,   // weighted system CPU %
        e_RESIDENT_SIZE,     // number of MBs of physical memory
        e_NUM_THREADS,       // number of threads
        e_NUM_PAGEFAULTS,    // number of pagefaults (major + minor)
        e_VIRTUAL_SIZE,      // number of MBs in the heap
        e_NUM_MEASURES
    };

    class Statistics {
        // Defines the performance statistics collected for a monitored
        // process.  Note that this class is not fully value-semantic.  It is
        // intended to provide a read-only view of a set of collected
        // performance statistics.

        // FRIENDS
        friend class Collector&lt;OsType&gt;;
            // Grants write-access to the specific &#39;Collector&#39; instantiation
            // for the current platform.

        // DATA
        int                d_pid;                      // process identifier
        bsl::string        d_description;              // process description

        bdlt::Datetime     d_startTimeUtc;             // process start time,
                                                       // in UTC time

        bsls::TimeInterval d_startTime;                // process start time,
                                                       // since the system
                                                       // epoch

        double             d_elapsedTime;              // time elapsed since
                                                       // process startup

        bsls::AtomicInt    d_numSamples;               // num samples taken

        double             d_lstData[e_NUM_MEASURES];  // latest collected data
        double             d_minData[e_NUM_MEASURES];  // min
        double             d_maxData[e_NUM_MEASURES];  // max
        double             d_totData[e_NUM_MEASURES];  // cumulative

        mutable bslmt::RWMutex d_guard;  // serialize write access

    private:
        // NOT IMPLEMENTED
        Statistics(const Statistics&amp;);
        Statistics&amp; operator=(const Statistics&amp;);

    public:
        // TRAITS
        BSLMF_NESTED_TRAIT_DECLARATION(Statistics,
                                       bslma::UsesBslmaAllocator);


        // CREATORS
        explicit Statistics(bslma::Allocator *basicAllocator = 0);
            // Create an instance of this class.  Optionally specify a
            // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
            // 0, the currently installed default allocator is used.

        // MANIPULATORS
        void reset();
            // Reset the min, max, and average values collected for each
            // measure.

        // ACCESSORS
        double latestValue(Measure measure) const;
            // Return the latest collected value for the specified &#39;measure&#39;.

        double minValue(Measure measure) const;
            // Return the minimum collected value for the specified &#39;measure&#39;.

        double maxValue(Measure measure) const;
            // Return the maximum collected value for the specified &#39;measure&#39;.

        double avgValue(Measure measure) const;
            // Return the average of the collected values for the specified
            // &#39;metric&#39;.

        int pid() const;
            // Return the pid for which these statistics were collected.

        const bsl::string&amp; description() const;
            // Return the user-supplied description of the process identified
            // by the result of the &#39;pid()&#39; function.

        double elapsedTime() const;
            // Return the number of seconds (in wall time) that have elapsed
            // since the startup the process identified by the result of the
            // &#39;pid()&#39; function.

        const bdlt::Datetime&amp; startupTime() const;
            // Return the startup time in Coordinated Universal Time.

        void print(bsl::ostream&amp; os) const;
            // Print all collected statistics to the specified &#39;os&#39; stream.

        void print(bsl::ostream&amp; os, Measure measure) const;
            // Print the specified &#39;measure&#39; to the specified &#39;os&#39; stream.

        void print(bsl::ostream&amp; os, const char *measureIdentifier) const;
            // Print the specified &#39;measureIdentifier&#39; to the specified &#39;os&#39;
            // stream.  The value of &#39;measureIdentifier&#39; should be a string
            // literal corresponding to the desired measure enumerator, e.g.,
            // &#39;e_CPU_TIME&#39;.
    };

    class ConstIterator {
        // Provide a mechanism that models the &quot;Forward Iterator&quot; concept over
        // a collection of non-modifiable performance statistics.

        // FRIENDS

        friend class PerformanceMonitor;  // grant access to the private
                                          // constructor

        // INSTANCE DATA

        PidMap::const_iterator  d_it;          // wrapped iterator
        bslmt::RWMutex         *d_mapGuard_p;  // serialize access to the map

        // PRIVATE CREATORS
        explicit ConstIterator(PidMap::const_iterator  it,
                               bslmt::RWMutex         *mapGuard);
            // Create an instance of this class that wraps the specified &#39;it&#39;
            // iterator protected by the specified &#39;mapGuard&#39;.

      public:
        // TYPES
        typedef bsl::forward_iterator_tag iterator_category;
            // Defines a type alias for the tag type that represents the
            // iterator concept this class models.

        typedef Statistics value_type;
            // Defines a type alias for the type of the result of dereferencing
            // this iterator.

        typedef bsl::ptrdiff_t difference_type;
            // Defines a type alias for the type of the result of the
            // difference between the addresses of two value types.

        typedef const Statistics* pointer;
            // Defines a type alias for a pointer to this iterator&#39;s value
            // type.

        typedef const Statistics&amp; reference;
            // Defines a type alias for a reference to this iterator&#39;s value
            // type.

        // CREATORS
        ConstIterator();
            // Create an instance of this class having an invalid value.

        // MANIPULATORS
        ConstIterator&amp; operator++();
            // Advance this iterator to refer to the next collection of
            // statistics for a monitored pid and return a reference to the
            // modifiable value type of this iterator.  The behavior of this
            // function is undefined unless this iterator is dereferenceable.

        ConstIterator operator++(int);
            // Advance this iterator to refer to the next collection of
            // statistics for a monitored pid and return the iterator pointing
            // to the previous modifiable value type.  The behavior of this
            // function is undefined unless this iterator is dereferenceable.

        // ACCESSORS
        reference operator*() const;
            // Return a reference to the non-modifiable value type of this
            // iterator.

        pointer operator-&gt;() const;
            // Return a reference to the non-modifiable value type of this
            // iterator.

        bool operator==(const ConstIterator&amp; rhs) const;
            // Return &#39;true&#39; if the specified &#39;rhs&#39; iterator points to the
            // same instance of the iterator&#39;s value type as &quot;this&quot; iterator,
            // and &#39;false&#39; otherwise.  The behavior of this function is
            // undefined unless the &#39;rhs&#39; iterator and &quot;this&quot; iterator both
            // iterate over the same collection of Statistics.

        bool operator!=(const ConstIterator&amp; rhs) const;
            // Return &#39;true&#39; if the specified &#39;rhs&#39; iterator does not point to
            // the same instance of the iterator&#39;s value type as &quot;this&quot;
            // iterator, and &#39;false&#39; otherwise.  The behavior of this function
            // is undefined unless the &#39;rhs&#39; iterator and &quot;this&quot; iterator both
            // iterate over the same collection of Statistics.
    };

    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(PerformanceMonitor,
                                   bslma::UsesBslmaAllocator);

    // CREATORS
    explicit
    PerformanceMonitor(bslma::Allocator *basicAllocator = 0);
        // Create an instance of this class to collect performance statistics
        // on demand (via the &#39;collect&#39; method).  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    PerformanceMonitor(bdlmt::TimerEventScheduler *scheduler,
                       double                      interval,
                       bslma::Allocator           *basicAllocator = 0);
        // Create an instance of this class that uses the specified &#39;scheduler&#39;
        // to automatically collect performance statistics every specified
        // &#39;interval&#39; (specified in seconds).  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.  Note that a
        // non-positive &#39;interval&#39; value indicates that performance statistics
        // should *not* be automatically collected--in this case the user is
        // responsible for manually calling the &#39;collect&#39; function.

    ~PerformanceMonitor();
        // Destroy this object.

    // MANIPULATORS
    int registerPid(int pid, const bsl::string&amp; description);
        // Register the specified process &#39;pid&#39; having the specified
        // user-defined &#39;description&#39; with this performance monitor.  After
        // registration, performance statistics will be collected for the
        // &#39;pid&#39; upon invocation of the &#39;collect&#39; function.  Note that a &#39;pid&#39;
        // value of zero is interpreted as the &#39;pid&#39; of the current process.
        // Return 0 on success or a non-zero value otherwise.

    int unregisterPid(int pid);
        // Unregister the specified process &#39;pid&#39; from the performance monitor.
        // After unregistration, to statistics for the &#39;pid&#39; will be no longer
        // be available unless the &#39;pid&#39; is re-registered with the performance
        // monitor through calling &#39;registerPid&#39;.  Note that a &#39;pid&#39; value of
        // zero is interpreted as the &#39;pid&#39; of the current process.  Return
        // 0 on success or a non-zero value otherwise.

    void setCollectionInterval(double interval);
        // Set the specified time &#39;interval&#39;, in seconds, after which
        // statistics for each registered pid are automatically collected.  The
        // behavior is undefined unless a scheduler was supplied at the
        // construction of this performance monitor.  Note that a non-positive
        // &#39;interval&#39; value indicates that performance statistics should not be
        // automatically collected--in this case the user is responsible for
        // manually calling the &#39;collect&#39; function.

    void collect();
        // Collect performance statistics for each registered pid.

    void resetStatistics();
        // Reset the collected min, max, and average values collected for each
        // measure for each monitored process.

    // ACCESSORS
    ConstIterator begin() const;
        // Return an iterator positioned at the first set of collected
        // performance statistics.

    ConstIterator end() const;
        // Return an iterator that represents the end of the sequence of sets
        // of collected performance statistics.

    ConstIterator find(int pid) const;
        // Return the iterator pointing to the set of collected performance
        // statistics for the specified &#39;pid&#39; if &#39;pid&#39; has been registered with
        // this performance monitor through the &#39;registerPid&#39; function,
        // otherwise return &#39;end()&#39;.

    int numRegisteredPids() const;
        // Return the number of processes registered for statistics collection.
};
}  // close package namespace

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

               // ---------------------------------------------
               // class balb::PerformanceMonitor::ConstIterator
               // ---------------------------------------------

// CREATORS
inline
balb::PerformanceMonitor::ConstIterator::ConstIterator()
: d_it()
{
}

inline
balb::PerformanceMonitor::ConstIterator::ConstIterator(
               balb::PerformanceMonitor::PidMap::const_iterator  it,
               bslmt::RWMutex                                   *mapGuard)
: d_it(it)
, d_mapGuard_p(mapGuard)
{
}

// ACCESSORS
inline
balb::PerformanceMonitor::ConstIterator::reference
balb::PerformanceMonitor::ConstIterator::operator*() const
{
    return *d_it-&gt;second.first;
}

inline
balb::PerformanceMonitor::ConstIterator::pointer
balb::PerformanceMonitor::ConstIterator::operator-&gt;() const
{
    return d_it-&gt;second.first.get();
}

// MANIPULATORS
inline
balb::PerformanceMonitor::ConstIterator&amp;
balb::PerformanceMonitor::ConstIterator::operator++()
{
    bslmt::ReadLockGuard&lt;bslmt::RWMutex&gt; guard(d_mapGuard_p);
    ++d_it;
    return *this;
}

inline
balb::PerformanceMonitor::ConstIterator
balb::PerformanceMonitor::ConstIterator::operator++(int)
{
    balb::PerformanceMonitor::ConstIterator temp = *this;
    ++*this;
    return temp;
}

// ACCESSORS
inline
bool balb::PerformanceMonitor::ConstIterator::operator==(
                                                const ConstIterator&amp; rhs) const
{
    return d_it == rhs.d_it;
}

inline
bool balb::PerformanceMonitor::ConstIterator::operator!=(
                                                const ConstIterator&amp; rhs) const
{
    return d_it != rhs.d_it;
}

                 // ------------------------------------------
                 // class balb::PerformanceMonitor::Statistics
                 // ------------------------------------------

// ACCESSORS
inline
double balb::PerformanceMonitor::Statistics::latestValue(Measure measure) const
{
    BSLS_ASSERT_SAFE(measure &gt;= 0 &amp;&amp; measure &lt; e_NUM_MEASURES);

    bslmt::ReadLockGuard&lt;bslmt::RWMutex&gt; guard(&amp;d_guard);
    return d_lstData[measure];
}

inline
double balb::PerformanceMonitor::Statistics::minValue(Measure measure) const
{
    BSLS_ASSERT_SAFE(measure &gt;= 0 &amp;&amp; measure &lt; e_NUM_MEASURES);

    bslmt::ReadLockGuard&lt;bslmt::RWMutex&gt; guard(&amp;d_guard);
    return d_minData[measure];
}

inline
double balb::PerformanceMonitor::Statistics::maxValue(Measure measure) const
{
    BSLS_ASSERT_SAFE(measure &gt;= 0 &amp;&amp; measure &lt; e_NUM_MEASURES);

    bslmt::ReadLockGuard&lt;bslmt::RWMutex&gt; guard(&amp;d_guard);
    return d_maxData[measure];
}

inline
double balb::PerformanceMonitor::Statistics::avgValue(Measure measure) const
{
    BSLS_ASSERT_SAFE(measure &gt;= 0 &amp;&amp; measure &lt; e_NUM_MEASURES);

    bslmt::ReadLockGuard&lt;bslmt::RWMutex&gt; guard(&amp;d_guard);
    return d_totData[measure] / d_numSamples;
}

inline
int balb::PerformanceMonitor::Statistics::pid() const
{
    return d_pid;
}

inline
const bsl::string&amp; balb::PerformanceMonitor::Statistics::description() const
{
    return d_description;
}

inline
double balb::PerformanceMonitor::Statistics::elapsedTime() const
{
    return d_elapsedTime;
}

inline
const bdlt::Datetime&amp; balb::PerformanceMonitor::Statistics::startupTime() const
{
    return d_startTimeUtc;
}

namespace balb {
                          // ------------------------
                          // class PerformanceMonitor
                          // ------------------------

// ACCESSORS
inline
PerformanceMonitor::ConstIterator
PerformanceMonitor::begin() const
{
    bslmt::ReadLockGuard&lt;bslmt::RWMutex&gt; guard(&amp;d_mapGuard);
    return ConstIterator(d_pidMap.begin(), &amp;d_mapGuard);
}

inline
PerformanceMonitor::ConstIterator
PerformanceMonitor::end() const
{
    bslmt::ReadLockGuard&lt;bslmt::RWMutex&gt; guard(&amp;d_mapGuard);
    return ConstIterator(d_pidMap.end(), &amp;d_mapGuard);
}

inline
PerformanceMonitor::ConstIterator
PerformanceMonitor::find(int pid) const
{
    bslmt::ReadLockGuard&lt;bslmt::RWMutex&gt; guard(&amp;d_mapGuard);
    return ConstIterator(d_pidMap.find(pid), &amp;d_mapGuard);
}

inline
int
PerformanceMonitor::numRegisteredPids() const
{
    bslmt::ReadLockGuard&lt;bslmt::RWMutex&gt; guard(&amp;d_mapGuard);
    return static_cast&lt;int&gt;(d_pidMap.size());
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
