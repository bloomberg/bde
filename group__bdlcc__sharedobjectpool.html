<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlcc_sharedobjectpool Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlcc_sharedobjectpool<br/>
<small>
[<a class="el" href="group__bdlcc.html">Package bdlcc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a thread-safe pool of shared objects.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlcc.html">bdlcc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Object Construction and Destruction</a> </li>
<li>
<a href="#3.2">Creator and Resetter Template Contract</a> </li>
<li>
<a href="#3.3">Exception Safety</a> </li>
<li>
<a href="#3.4">Pool Replenishment Policy</a> </li>
<li>
<a href="#3.5">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a thread-safe pool of shared objects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlcc_1_1SharedObjectPool.html">bdlcc::SharedObjectPool</a> </td><td>thread-enabled container of shared objects  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bcema_sharedptr </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a generic thread-safe pool of shared objects, <code><a class="el" href="classbdlcc_1_1SharedObjectPool.html">bdlcc::SharedObjectPool</a></code>, using the acquire-release idiom. The functionality provided is identical to <code><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a></code>, except that <code>getObject</code> returns efficiently-constructed <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> objects instead of raw pointers. For client code that needs to provide shared access to objects in the pool, this functionality saves an additional allocation for the shared pointer itself. Since the shared pointer and the object are contiguous in memory, this component also tends to improve performance by reducing "cache misses." </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="object_construction_and_destruction"></a> <a class="anchor" id="description.object_construction_and_destruction"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Object Construction and Destruction: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The object pool owns the memory required to store the pooled objects and the shared-pointer representations, and manages the construction, resetting, and destruction of objects. The user may supply functors to create objects and to reset them to a valid state for their return to the pool; alternatively, this component supplies reasonable defaults. Upon destruction the object pool deallocates all memory associated with the objects in the pool. The behavior is undefined if there are any outstanding shared pointer references to the objects in the pool when it is destroyed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="creator_and_resetter_template_contract"></a> <a class="anchor" id="description.creator_and_resetter_template_contract"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Creator and Resetter Template Contract: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlcc_1_1SharedObjectPool.html">bdlcc::SharedObjectPool</a></code> is templated on two types <code>CREATOR</code> and <code>RESETTER</code> in addition to the underlying object <code>TYPE</code>. Objects of these types may be provided at construction (or defaults may be used). The creator will be invoked as: <code>void(*)(void*, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a>*)</code>. The resetter will be invoked as: <code>void(*)(TYPE*)</code>. The creator functor will be called to construct a new object of the parameterized <code>TYPE</code> when the pool must be expanded (and thus it will typically invoke placement new and pass its allocator argument to the constructor of <code>TYPE</code>). The resetter functor will be called before each object is returned to the pool, and is required to put the object into a state such that it is ready to be reused. The defaults for these types are as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">    CREATOR = <a class="code" href="structbdlcc_1_1ObjectPoolFunctors.html#a1e1490eacdd2d04969b1365b9d508382">bdlcc::ObjectPoolFunctors::DefaultCreator</a>
    RESETTER = <a class="code" href="classbdlcc_1_1ObjectPoolFunctors_1_1Nil.html">bdlcc::ObjectPoolFunctors::Nil&lt;TYPE&gt;</a>
</pre></div><br/>
<br/>
 <code><a class="el" href="classbdlcc_1_1ObjectPoolFunctors_1_1Nil.html">bdlcc::ObjectPoolFunctors::Nil</a></code> is a no-op; it is only suitable if the objects stored in the pool are <em>always</em> in a valid state to be reused. Otherwise - that is, if anything must be done to render the objects ready for reuse - another kind of <code>RESETTER</code> should be provided (so long as that type supplies <code>void(*)(TYPE*)</code>). In <code><a class="el" href="structbdlcc_1_1ObjectPoolFunctors.html">bdlcc::ObjectPoolFunctors</a></code>, the classes <code>Clear</code>, <code>RemoveAll</code>, and <code>Reset</code> are all acceptable types for <code>RESETTER</code>. Since these "functor" types are fully inline, it is generally most efficient to define <code><a class="el" href="namespacebdlat__ValueTypeFunctions.html#a712743f16be0f4121bca7574c9face99">reset()</a></code> (or <code>clear()</code> or <code>removeAll()</code>) in the underlying <code>TYPE</code> and allow the functor to call that method. The <code>CREATOR</code> functor defaults to an object that invokes the default constructor with placement new, passing the allocator argument if the type traits of the object indicate it uses an allocator (see <code>bslma_usesbslmaallocator</code>). If a custom creator functor or a custom <code>CREATOR</code> type is specified, it is the user's responsibility to ensure that it correctly passes its allocator argument through to the constructor of <code>TYPE</code> if <code>TYPE</code> uses allocator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="exception_safety"></a> <a class="anchor" id="description.exception_safety"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Exception Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are two potential sources of exceptions in this component: memory allocation and object construction. The object pool is exception-neutral with full guarantee of rollback for the following methods: if an exception is thrown in <code>getObject</code>, <code>reserveCapacity</code>, or <code>increaseCapacity</code>, then the pool is in a valid unmodified state (i.e., identical to prior the call to <code>getObject</code>). No other method of <code><a class="el" href="classbdlcc_1_1SharedObjectPool.html">bdlcc::SharedObjectPool</a></code> can throw. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="pool_replenishment_policy"></a> <a class="anchor" id="description.pool_replenishment_policy"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Pool Replenishment Policy: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>growBy</code> parameter can be specified in the pool's constructor to instruct the pool how it is to increase its capacity each time the pool is depleted. If <code>growBy</code> is positive, the pool always replenishes itself with enough objects so that it can satisfy at least <code>growBy</code> object requests before the next replenishment. If <code>growBy</code> is negative, the pool will increase its capacity geometrically until it exceeds the internal maximum (which itself is implementation-defined), and after that it will be replenished with constant number of objects. If <code>growBy</code> is not specified, an implementation-defined default will be chosen. The behavior is undefined if growBy is 0. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component is intended to improve the efficiency of code which provides shared pointers to pooled objects. As an example, consider a class which maintains a pool of <code>vector&lt;char&gt;</code> objects and provides shared pointers to them. Using <code><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a></code>, the class might be implemented like this: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> vector&lt;char&gt; CharArray;

  <span class="keyword">class </span>SlowCharArrayPool {
      <a class="code" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a> d_spAllocator;  <span class="comment">// alloc. shared pointer</span>
      <a class="code" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool&lt;CharArray&gt;</a>   d_charArrayPool;  <span class="comment">// supply charArrays</span>

      <span class="keyword">static</span> <span class="keywordtype">void</span> createCharArray(<span class="keywordtype">void</span> *address, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)
      {
          <span class="keyword">new</span> (address) CharArray(allocator);
      }

      <span class="keyword">static</span> <span class="keywordtype">void</span> resetAndReturnCharArray(
                                     CharArray                    *charArray,
                                     <a class="code" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool&lt;CharArray&gt;</a> *pool)
      {
          charArray-&gt;clear();
          pool-&gt;<a class="code" href="classbdlcc_1_1ObjectPool.html#a762eb19f3ddc452f85bd5e4b5c24ecb5">releaseObject</a>(charArray);
      }

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      SlowCharArrayPool(<span class="keyword">const</span> SlowCharArrayPool&amp;);

    <span class="keyword">public</span>:
      SlowCharArrayPool(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0)
      : d_spAllocator(basicAllocator)
      , d_charArrayPool(bdlf::BindUtil::bind(
                                         &amp;SlowCharArrayPool::createCharArray,
                                         bdlf::PlaceHolders::<a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>,
                                         basicAllocator),
                        -1,
                        basicAllocator)
      {
      }

      <span class="keywordtype">void</span> getCharArray(<a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;CharArray&gt;</a> *charArray_sp)
      {
          charArray_sp-&gt;<a class="code" href="classbsl_1_1shared__ptr.html#aa0dde6ea9a060945e2920464a72e0703">reset</a>(d_charArrayPool.getObject(),
                              <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
                                 &amp;SlowCharArrayPool::resetAndReturnCharArray,
                                 <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">bdlf::PlaceHolders::_1</a>,
                                 &amp;d_charArrayPool),
                              &amp;d_spAllocator);
      }
  };
</pre></div><br/>
<br/>
 Note that <code>SlowCharArrayPool</code> must allocate the shared pointer itself from its <code>d_spAllocator</code> in addition to allocating the charArray from its pool. Moreover, note that since the same function will handle resetting the object and returning it to the pool, we must define a special function for that purpose and bind its arguments. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We can solve both of these issues by using <code><a class="el" href="classbdlcc_1_1SharedObjectPool.html">bdlcc::SharedObjectPool</a></code> instead: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>FastCharArrayPool {
      <span class="keyword">typedef</span> <a class="code" href="classbdlcc_1_1SharedObjectPool.html">bdlcc::SharedObjectPool</a>&lt;
              CharArray,
              bdlcc::ObjectPoolFunctors::DefaultCreator,
              <a class="code" href="classbdlcc_1_1ObjectPoolFunctors_1_1Clear.html">bdlcc::ObjectPoolFunctors::Clear&lt;CharArray&gt;</a> &gt; CharArrayPool;

      CharArrayPool d_charArrayPool;     <span class="comment">// supply charArrays</span>

      <span class="keyword">static</span> <span class="keywordtype">void</span> createCharArray(<span class="keywordtype">void</span> *address, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator)
      {
          <span class="keyword">new</span> (address) CharArray(allocator);
      }

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      FastCharArrayPool(<span class="keyword">const</span> FastCharArrayPool&amp;);

    <span class="keyword">public</span>:
      FastCharArrayPool(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0)
      : d_charArrayPool(bdlf::BindUtil::bind(
                                         &amp;FastCharArrayPool::createCharArray,
                                         bdlf::PlaceHolders::<a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>,
                                         bdlf::PlaceHolders::<a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>),
                        -1,
                        basicAllocator)
      {
      }

      <span class="keywordtype">void</span> getCharArray(<a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;CharArray&gt;</a> *charArray_sp)
      {
          *charArray_sp = d_charArrayPool.getObject();
      }
  };
</pre></div><br/>
<br/>
 Now the shared pointer and the object are allocated as one unit from the same allocator. In addition, the resetter method is a fully-inlined class that is only responsible for resetting the object, improving efficiency and simplifying the design. We can verify that use of <code><a class="el" href="classbdlcc_1_1SharedObjectPool.html">bdlcc::SharedObjectPool</a></code> reduces the number of allocation requests: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> slowAllocator, fastAllocator;
  {
      SlowCharArrayPool slowPool(&amp;slowAllocator);
      FastCharArrayPool fastPool(&amp;fastAllocator);

      <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;CharArray&gt;</a> charArray_sp;

      fastPool.getCharArray(&amp;charArray_sp);
      slowPool.getCharArray(&amp;charArray_sp);  <span class="comment">// throw away the first array</span>
  }

  assert(2 == slowAllocator.<a class="code" href="classbslma_1_1TestAllocator.html#a464a6bc3f5125e8b0d303efbd339afec">numAllocations</a>());
  assert(1 == fastAllocator.<a class="code" href="classbslma_1_1TestAllocator.html#a464a6bc3f5125e8b0d303efbd339afec">numAllocations</a>());
  assert(0 == slowAllocator.<a class="code" href="classbslma_1_1TestAllocator.html#a55ecf964b4e4c5d0795cd4aaf3029be3">numBytesInUse</a>());
  assert(0 == fastAllocator.<a class="code" href="classbslma_1_1TestAllocator.html#a55ecf964b4e4c5d0795cd4aaf3029be3">numBytesInUse</a>());
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:41 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
