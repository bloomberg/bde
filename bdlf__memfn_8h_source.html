<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlf_memfn.h                                                       -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLF_MEMFN
#define INCLUDED_BDLF_MEMFN

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide member function pointer wrapper classes and utility.
//
//@CLASSES:
//          bdlf::MemFn: member function wrapper
//  bdlf::MemFnInstance: member function wrapper with embedded instance pointer
//      bdlf::MemFnUtil: utility for constructing wrapper objects
//
//@SEE_ALSO: bdlf_bind
//
//@DESCRIPTION: This component provides a member function pointer wrapper
// that wraps a member function pointer such that it can be invoked in
// syntactically the same manner as a free function.  Two wrappers, each
// supporting member function pointers that accept from zero to fourteen
// arguments, are provided, as well as a utility to create such wrappers.
// Member function wrappers are commonly used as function objects for standard
// algorithms.
//
// The first wrapper, &#39;bdlf::MemFn&#39;, contains a member function pointer and
// must be invoked with the first argument being a pointer or reference to the
// instance on which the function should be invoked, with the remaining
// arguments passed as arguments to the member function; that is, a wrapper
// &#39;memFn&#39; containing a pointer to a given &#39;memberFunction&#39; can be invoked as
// &#39;memFn(&amp;object, args...)&#39; as opposed to &#39;object.memberFunction(args...)&#39;.
//
// The second wrapper, &#39;bdlf::MemFnInstance&#39;, contains both the member function
// pointer and a pointer to an instance of the type which contains the member,
// and is invoked with arguments which are passed as arguments to the member
// function; that is, a wrapper &#39;memFnInstance&#39; containing pointers to both a
// given &#39;memberFunction&#39; and to an &#39;object&#39; instance can be invoked as
// &#39;memFnInstance(args...)&#39; as opposed to &#39;object.memberFunction(args...)&#39;.
//
// Finally, the &#39;bdlf::MemFnUtil&#39; utility class provides utility functions for
// constructing &#39;bdlf::MemFn&#39; and &#39;bdlf::MemFnInstance&#39; objects.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Basic Usage
/// - - - - - - - - - - -
// To illustrate basic usage more concretely, let us introduce a generic type:
//..
//  class MyObject {
//    public:
//      void doSomething(int, const char *);
//  };
//..
// The following function invokes the member function &#39;doSomething&#39; on the
// specified &#39;objectPtr&#39;, with the two arguments 100 and &quot;Hello&quot;, in two
// different ways.  In both cases, &#39;object&#39; is passed as parameter to a
// function, and a wrapper is built containing a pointer to the &#39;doSomething&#39;
// member function.  In the &#39;bdlf::MemFn&#39; case, the wrapper can be built once,
// so we make it a &#39;static&#39; local variable:
//..
//  void doSomethingWithMemFn(MyObject *objectPtr)
//  {
//      typedef bdlf::MemFn&lt;void (MyObject::*)(int, const char *)&gt; MemFnType;
//      static MemFnType func(&amp;MyObject::doSomething);
//
//      func(objectPtr, 100, &quot;Hello&quot;);
//  }
//..
// In the &#39;bdlf::MemFnInstance&#39; case, the wrapper needs to contain the object
// as well, so it must be created at every function call:
//..
//  void doSomethingWithMemFnInstance(MyObject *objectPtr)
//  {
//      typedef bdlf::MemFnInstance&lt;void (MyObject::*)(int, const char*),
//                                 MyObject*&gt; MemFnInstanceType;
//      MemFnInstanceType func(&amp;MyObject::doSomething, objectPtr);
//      func(100, &quot;Hello&quot;);
//  }
//..
// This latter example is for exposition only.  It would be much easier to
// invoke the member function directly.  Note that both function calls
// ultimately result in the member function call:
//..
//  objectPtr-&gt;doSomething(100, &quot;Hello&quot;);
//..
//
///Example 2: Usage with Standard Algorithms
///- - - - - - - - - - - - - - - - - - - - -
// The following example demonstrates the use of &#39;bdlf::MemFn&#39; with the
// standard algorithms &#39;find_if&#39; and &#39;for_each&#39;.  First we declare the
// &#39;MyConnection&#39; and &#39;MyConnectionManager&#39; classes used in the example,
// keeping the class definitions short to highlight the member functions for
// which we will later build wrappers:
//..
//  class MyConnection {
//
//      // DATA (not shown)
//
//    public:
//      // CREATORS (not shown)
//
//      // MANIPULATORS
//      void disconnect();
//
//      // ACCESSORS
//      bool isAvailable() const;
//  };
//
//  class MyConnectionManager {
//
//      // PRIVATE TYPES
//      typedef bsl::list&lt;MyConnection *&gt; MyConnectionList;
//
//      // DATA
//      MyConnectionList d_list;
//
//    public:
//      // CREATORS (not shown)
//
//      // MANIPULATORS
//      void disconnectAll();
//
//      // ACCESSORS
//      MyConnection *nextAvailable() const;
//  };
//..
// The &#39;nextAvailable&#39; function returns the next &#39;MyConnection&#39; object that is
// available.  The &#39;find_if&#39; algorithm is used to search the list for the first
// &#39;MyConnection&#39; object that is available.  &#39;find_if&#39; invokes the provided
// function object for each item in the list until a &#39;true&#39; result is returned,
// or the end of the list is reached.  A &#39;bdlf::MemFn&#39; object bound to the
// &#39;MyConnection::isAvailable&#39; member function is used as the test functor.
// Note that the type of this object is never spelled out, it is built on the
// fly using the &#39;bdlf::MemFnUtil&#39; utility before being passed as a functor to
// the &#39;bsl::find_if&#39; algorithm:
//..
//  MyConnection *MyConnectionManager::nextAvailable() const
//  {
//      MyConnectionList::const_iterator it =
//          bsl::find_if(d_list.begin(),
//                       d_list.end(),
//                       bdlf::MemFnUtil::memFn(&amp;MyConnection::isAvailable));
//      return it == d_list.end() ? 0 : *it;
//  }
//..
// The &#39;disconnectAll&#39; function calls &#39;disconnect&#39; on each &#39;MyConnection&#39;
// object in the list.  The &#39;for_each&#39; algorithm is used to iterate through
// each &#39;MyConnection&#39; object in the list and invoke the &#39;disconnect&#39; method:
//..
//  void MyConnectionManager::disconnectAll()
//  {
//      bsl::for_each(d_list.begin(),
//                    d_list.end(),
//                    bdlf::MemFnUtil::memFn(&amp;MyConnection::disconnect));
//  }
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLALG_CONSTRUCTORPROXY
#include &lt;bslalg_constructorproxy.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLMF_FORWARDINGTYPE
#include &lt;bslmf_forwardingtype.h&gt;
#endif

#ifndef INCLUDED_BSLMF_HASPOINTERSEMANTICS
#include &lt;bslmf_haspointersemantics.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISPOINTER
#include &lt;bslmf_ispointer.h&gt;
#endif

#ifndef INCLUDED_BSLMF_MEMBERFUNCTIONPOINTERTRAITS
#include &lt;bslmf_memberfunctionpointertraits.h&gt;
#endif

#ifndef INCLUDED_BSLMF_METAINT
#include &lt;bslmf_metaint.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLMF_TYPELIST
#include &lt;bslmf_typelist.h&gt;
#endif


namespace BloombergLP {

namespace bslma { class Allocator; }

namespace bdlf {
                          // =======================
                          // class MemFn_Dereference
                          // =======================

template &lt;class OBJTYPE&gt;
struct MemFn_Dereference {
    // This utility is used to convert user supplied values to references to
    // &#39;OBJTYPE&#39; for object references that are directly convertible to
    // &#39;OBJTYPE&#39;, the reference is returned directly.  For pointers and objects
    // that are not directly convertible (e.g., &quot;smart pointers to &#39;OBJTYPE&#39;&quot;),
    // the result of &#39;*OBJECT&#39; is returned, where &#39;OBJECT&#39; is the pointer or
    // object reference.

    static inline OBJTYPE&amp; derefImp(OBJTYPE&amp; obj, bslmf::MetaInt&lt;0&gt; *)
    {
        return obj;
    }

    template &lt;class TYPE&gt;
    static inline OBJTYPE&amp; derefImp(TYPE&amp; obj, bslmf::MetaInt&lt;1&gt; *)
    {
        return *obj;
    }

    template &lt;class TYPE&gt;
    static inline OBJTYPE&amp; derefImp(const TYPE&amp; obj, bslmf::MetaInt&lt;1&gt; *)
    {
        return *obj;
    }

    template &lt;class TYPE&gt;
    static inline OBJTYPE&amp; deref(TYPE&amp; obj)
    {
        enum { k_POINTER_SEMANTICS = bslmf::IsPointer&lt;TYPE&gt;::VALUE
                                  || bslmf::HasPointerSemantics&lt;TYPE&gt;::value};

        return derefImp(obj, (bslmf::MetaInt&lt;k_POINTER_SEMANTICS&gt; *)0);
    }

    template &lt;class TYPE&gt;
    static inline OBJTYPE&amp; deref(const TYPE&amp; obj)
    {
        enum { k_POINTER_SEMANTICS = bslmf::IsPointer&lt;TYPE&gt;::VALUE
                                  || bslmf::HasPointerSemantics&lt;TYPE&gt;::value};

        return derefImp(obj, (bslmf::MetaInt&lt;k_POINTER_SEMANTICS&gt; *)0);
    }
};

                                // ===========
                                // class MemFn
                                // ===========

template &lt;class PROTOTYPE&gt;
class MemFn {
    // This class encapsulates a member function pointer having the
    // parameterized &#39;PROTOTYPE&#39;, such that the member function pointer can be
    // invoked in syntactically the same manner as a free function pointer.
    // When invoking a member function through this wrapper, the first argument
    // must be a pointer or reference to the instance on which to invoke the
    // member function pointer.  Zero to fourteen additional arguments may be
    // specified depending on &#39;PROTOTYPE&#39;.

    // PRIVATE TYPES
    typedef bslmf::MemberFunctionPointerTraits&lt;PROTOTYPE&gt; Traits;

    // ASSERTIONS
    BSLMF_ASSERT(Traits::IS_MEMBER_FUNCTION_PTR);  // otherwise none of the
                                                   // &#39;typedef&#39;s below make any
                                                   // sense

  public:
    // TYPES
    typedef typename Traits::ResultType   ResultType;
        // &#39;ResultType&#39; is an alias for the type of the object returned by an
        // invocation of this member function wrapper.

    typedef typename Traits::ArgumentList Args;
        // &#39;Args&#39; is an alias for the list of arguments passed to an invocation
        // of this member function wrapper, expressed as a &#39;bslmf_Typelist&#39;.

    typedef typename Traits::ClassType    ObjectType;
        // &#39;ObjectType&#39; is an alias for the class type to which the member
        // function that is wrapped belongs.

    typedef PROTOTYPE                     Prototype;
        // &#39;ProtoType&#39; is an alias for the parameterized &#39;PROTOTYPE&#39; passed as
        // a template argument to this wrapper.

    typedef PROTOTYPE                     ProtoType;
        // &#39;ProtoType&#39; is an alias for the parameterized &#39;PROTOTYPE&#39; passed as
        // a template argument to this wrapper.
        //
        // *DEPRECATED*: Use &#39;Prototype&#39; instead.

  private:
    // PRIVATE TYPES
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 1, Args&gt;::TypeOrDefault&gt;::Type A1;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 2, Args&gt;::TypeOrDefault&gt;::Type A2;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 3, Args&gt;::TypeOrDefault&gt;::Type A3;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 4, Args&gt;::TypeOrDefault&gt;::Type A4;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 5, Args&gt;::TypeOrDefault&gt;::Type A5;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 6, Args&gt;::TypeOrDefault&gt;::Type A6;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 7, Args&gt;::TypeOrDefault&gt;::Type A7;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 8, Args&gt;::TypeOrDefault&gt;::Type A8;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 9, Args&gt;::TypeOrDefault&gt;::Type A9;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt;10, Args&gt;::TypeOrDefault&gt;::Type A10;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt;11, Args&gt;::TypeOrDefault&gt;::Type A11;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt;12, Args&gt;::TypeOrDefault&gt;::Type A12;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt;13, Args&gt;::TypeOrDefault&gt;::Type A13;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt;14, Args&gt;::TypeOrDefault&gt;::Type A14;
        // &#39;AN&#39;, for &#39;N&#39; from 1 up to 14, is an alias for the type of the &#39;N&#39;th
        // argument in the &#39;Args&#39; list.

    typedef MemFn_Dereference&lt;ObjectType&gt;                        Deref;

    // DATA
    PROTOTYPE d_func_p;  // pointer to member function

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(MemFn, bsl::is_trivially_copyable);
    BSLMF_NESTED_TRAIT_DECLARATION(MemFn, bslmf::IsBitwiseMoveable);

    // CREATORS
    explicit
    MemFn(PROTOTYPE func);
        // Create a member function pointer wrapper holding the address of the
        // specified &#39;func&#39; member function having the parameterized
        // &#39;PROTOTYPE&#39;.

    MemFn(const MemFn&lt;PROTOTYPE&gt;&amp; original);
        // Create a member function pointer wrapper holding the address of the
        // same member function as the specified &#39;original&#39; object.

    // ~MemFn();
        // Destroy this object.  Note that this trivial destructor is generated
        // by the compiler.

    // ACCESSORS
    template &lt;class INSTANCE&gt;
    ResultType operator()(INSTANCE&amp; object) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with no specified arguments, and
        // return the result of this invocation, or &#39;void&#39; if this member
        // function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)();
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(INSTANCE&amp; object, A1 a1) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified argument &#39;a1&#39;, and
        // return the result of this invocation, or &#39;void&#39; if this member
        // function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1);  // see NOTES above
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(INSTANCE&amp; object, A1 a1, A2 a2) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified argument &#39;a1&#39; up
        // to &#39;a2&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2);  // etc.
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(INSTANCE&amp; object, A1 a1, A2 a2, A3 a3) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified argument &#39;a1&#39; up
        // to &#39;a3&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(INSTANCE&amp; object, A1 a1, A2 a2, A3 a3, A4 a4) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified argument &#39;a1&#39; up
        // to &#39;a4&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3, a4);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(INSTANCE&amp; object,
                                 A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified argument &#39;a1&#39; up
        // to &#39;a5&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3, a4, a5);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(INSTANCE&amp; object,
                                 A1 a1, A2 a2, A3 a3, A4 a4, A5 a5,
                                 A6 a6) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified argument &#39;a1&#39; up
        // to &#39;a6&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3, a4, a5, a6);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(INSTANCE&amp; object,
                                 A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,
                                 A7 a7) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified argument &#39;a1&#39; up
        // to &#39;a7&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3, a4, a5, a6, a7);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(INSTANCE&amp; object,
                                 A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,
                                 A7 a7, A8 a8) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified argument &#39;a1&#39; up
        // to &#39;a8&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3, a4, a5, a6, a7,
                                                a8);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(INSTANCE&amp; object,
                                 A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,
                                 A7 a7, A8 a8, A9 a9) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified argument &#39;a1&#39; up
        // to &#39;a9&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3, a4, a5, a6, a7, a8,
                                                a9);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(INSTANCE&amp; object,
                                 A1 a1, A2 a2, A3 a3, A4  a4, A5  a5, A6  a6,
                                 A7 a7, A8 a8, A9 a9, A10 a10) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified argument &#39;a1&#39; up
        // to &#39;a10&#39;, and return the result of this invocation, or &#39;void&#39; if
        // this member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3, a4, a5, a6, a7, a8,
                                                a9, a10);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(INSTANCE&amp; object,
                                 A1 a1, A2 a2, A3 a3, A4  a4,  A5  a5, A6  a6,
                                 A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified argument &#39;a1&#39; up
        // to &#39;a11&#39;, and return the result of this invocation, or &#39;void&#39; if
        // this member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1,  a2, a3, a4, a5, a6, a7,
                                                a8, a9, a10, a11);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(INSTANCE&amp; object,
                                A1  a1, A2 a2, A3 a3, A4  a4,  A5  a5, A6 a6,
                                A7  a7, A8 a8, A9 a9, A10 a10, A11 a11,
                                A12 a12) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified argument &#39;a1&#39; up
        // to &#39;a12&#39;, and return the result of this invocation, or &#39;void&#39; if
        // this member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3,  a4,  a5,  a6,  a7,
                                                a8, a9, a10, a11, a12);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(INSTANCE&amp; object,
                                A1  a1,  A2  a2,  A3  a3, A4 a4, A5  a5,
                                A6  a6,  A7  a7,  A8  a8, A9 a9, A10 a10,
                                A11 a11, A12 a12, A13 a13) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified argument &#39;a1&#39; up
        // to &#39;a13&#39;, and return the result of this invocation, or &#39;void&#39; if
        // this member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3,  a4,  a5,  a6,  a7,
                                                a8, a9, a10, a11, a12, a13);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(INSTANCE&amp; object,
                                A1  a1,  A2  a2,  A3  a3,  A4  a4, A5  a5,
                                A6  a6,  A7  a7,  A8  a8,  A9  a9, A10 a10,
                                A11 a11, A12 a12, A13 a13, A14 a14) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified argument &#39;a1&#39; up
        // to &#39;a14&#39;, and return the result of this invocation, or &#39;void&#39; if
        // this member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3,  a4,  a5,  a6,  a7,
                                                a8, a9, a10, a11, a12, a13,
                                                a14);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(const INSTANCE&amp; object) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a non-modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with no arguments, and return the
        // result of this invocation, or &#39;void&#39; if this member function pointer
        // does not return a result.
    {
        return (Deref::deref(object).*d_func_p)();
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(const INSTANCE&amp; object, A1 a1) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a non-modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified argument &#39;a1&#39;, and
        // return the result of this invocation, or &#39;void&#39; if this member
        // function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(const INSTANCE&amp; object, A1 a1, A2 a2) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a non-modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified arguments &#39;a1&#39; up
        // to &#39;a2&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(const INSTANCE&amp; object, A1 a1, A2 a2, A3 a3) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a non-modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified arguments &#39;a1&#39; up
        // to &#39;a3&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(const INSTANCE&amp; object,
                                       A1 a1, A2 a2, A3 a3, A4 a4) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a non-modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified arguments &#39;a1&#39; up
        // to &#39;a4&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3, a4);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(const INSTANCE&amp; object,
                                       A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a non-modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified arguments &#39;a1&#39; up
        // to &#39;a5&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3, a4, a5);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(const INSTANCE&amp; object,
                                       A1 a1, A2 a2, A3 a3, A4 a4, A5 a5,
                                       A6 a6) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a non-modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified arguments &#39;a1&#39; up
        // to &#39;a6&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3, a4, a5, a6);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(const INSTANCE&amp; object,
                                       A1 a1, A2 a2, A3 a3, A4 a4, A5 a5,
                                       A6 a6, A7 a7) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a non-modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified arguments &#39;a1&#39; up
        // to &#39;a7&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2,  a3,  a4,  a5, a6, a7);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(const INSTANCE&amp; object,
                                       A1 a1, A2 a2, A3 a3, A4 a4, A5 a5,
                                       A6 a6, A7 a7, A8 a8) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a non-modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified arguments &#39;a1&#39; up
        // to &#39;a8&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3, a4, a5, a6, a7,
                                                a8);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(const INSTANCE&amp; object,
                                       A1 a1, A2 a2, A3 a3, A4 a4, A5 a5,
                                       A6 a6, A7 a7, A8 a8, A9 a9) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a non-modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified arguments &#39;a1&#39; up
        // to &#39;a9&#39;, and return the result of this invocation, or &#39;void&#39; if this
        // member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3, a4, a5, a6, a7,
                                                a8, a9);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(const INSTANCE&amp; object,
                                      A1  a1, A2 a2, A3 a3, A4 a4, A5  a5,
                                      A6  a6, A7 a7, A8 a8, A9 a9,
                                      A10 a10) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a non-modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified arguments &#39;a1&#39; up
        // to &#39;a10&#39;, and return the result of this invocation, or &#39;void&#39; if
        // this member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3, a4, a5, a6, a7,
                                                a8, a9, a10);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(const INSTANCE&amp; object,
                                      A1  a1, A2 a2, A3 a3, A4 a4, A5  a5,
                                      A6  a6, A7 a7, A8 a8, A9 a9, A10 a10,
                                      A11 a11) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a non-modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified arguments &#39;a1&#39; up
        // to &#39;a11&#39;, and return the result of this invocation, or &#39;void&#39; if
        // this member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3,  a4, a5, a6, a7,
                                                a8, a9, a10, a11);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(const INSTANCE&amp; object,
                                      A1  a1,  A2  a2, A3 a3, A4 a4, A5  a5,
                                      A6  a6,  A7  a7, A8 a8, A9 a9, A10 a10,
                                      A11 a11, A12 a12) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a non-modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified arguments &#39;a1&#39; up
        // to &#39;a12&#39;, and return the result of this invocation, or &#39;void&#39; if
        // this member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3,  a4,  a5, a6, a7,
                                                a8, a9, a10, a11, a12);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(const INSTANCE&amp; object,
                                      A1  a1,  A2  a2,  A3  a3, A4 a4, A5  a5,
                                      A6  a6,  A7  a7,  A8  a8, A9 a9, A10 a10,
                                      A11 a11, A12 a12, A13 a13) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a non-modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified arguments &#39;a1&#39; up
        // to &#39;a13&#39;, and return the result of this invocation, or &#39;void&#39; if
        // this member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3,  a4,  a5,  a6,  a7,
                                                a8, a9, a10, a11, a12, a13);
    }

    template &lt;class INSTANCE&gt;
    ResultType operator()(const INSTANCE&amp; object,
                                      A1  a1,  A2  a2,  A3  a3,  A4  a4,
                                      A5  a5,  A6  a6,  A7  a7,  A8  a8,
                                      A9  a9,  A10 a10, A11 a11, A12 a12,
                                      A13 a13, A14 a14) const
        // Invoke the member function pointer held by this wrapper on the
        // specified &#39;object&#39; reference to a non-modifiable instance of the
        // parameterized &#39;INSTANCE&#39; type, with the specified arguments &#39;a1&#39; up
        // to &#39;a14&#39;, and return the result of this invocation, or &#39;void&#39; if
        // this member function pointer does not return a result.
    {
        return (Deref::deref(object).*d_func_p)(a1, a2, a3,  a4,  a5,  a6,  a7,
                                                a8, a9, a10, a11, a12, a13,
                                                a14);
    }
};

                            // ===================
                            // class MemFnInstance
                            // ===================

template &lt;class PROTOTYPE, class INSTANCE&gt;
class MemFnInstance {
    // This class encapsulates a member function pointer having the
    // parameterized &#39;PROTOTYPE&#39; and a value of the parameterized &#39;INSTANCE&#39;
    // type, which can be either a pointer or reference to an associated
    // instance of the object type referred to by the &#39;PROTOTYPE&#39;, such that
    // the member function pointer can be invoked on the wrapped instance in
    // syntactically the same manner as a free function pointer.  Zero to
    // fourteen additional arguments may be specified depending on the
    // &#39;PROTOTYPE&#39;.  Note that whether &#39;INSTANCE&#39; is a pointer or a reference
    // is determined by whether it has pointer semantics or not (as determined
    // by the &#39;bslmf::HasPointerSemantics&#39; type trait).

    // PRIVATE TYPES
    typedef bslmf::MemberFunctionPointerTraits&lt;PROTOTYPE&gt; Traits;

  public:
    // TYPES
    typedef typename Traits::ResultType   ResultType;
        // &#39;ResultType&#39; is an alias for the type of the object returned by an
        // invocation of this member function wrapper.

    typedef typename Traits::ArgumentList Args;
        // &#39;Args&#39; is an alias for the list of arguments passed to an invocation
        // of this member function wrapper, expressed as a &#39;bslmf_Typelist&#39;.

    typedef typename Traits::ClassType    ObjectType;
        // &#39;ObjectType&#39; is an alias for the class type to which the member
        // function that is wrapped belongs.

    typedef PROTOTYPE                     Prototype;
        // &#39;ProtoType&#39; is an alias for the parameterized &#39;PROTOTYPE&#39; passed as
        // a template argument to this wrapper.

    typedef PROTOTYPE                     ProtoType;
        // &#39;ProtoType&#39; is an alias for the parameterized &#39;PROTOTYPE&#39; passed as
        // a template argument to this wrapper.
        //
        // *DEPRECATED*: Use &#39;Prototype&#39; instead.

    typedef MemFn_Dereference&lt;ObjectType&gt; Deref;


  private:
    // PRIVATE TYPES
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 1, Args&gt;::TypeOrDefault&gt;::Type A1;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 2, Args&gt;::TypeOrDefault&gt;::Type A2;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 3, Args&gt;::TypeOrDefault&gt;::Type A3;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 4, Args&gt;::TypeOrDefault&gt;::Type A4;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 5, Args&gt;::TypeOrDefault&gt;::Type A5;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 6, Args&gt;::TypeOrDefault&gt;::Type A6;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 7, Args&gt;::TypeOrDefault&gt;::Type A7;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 8, Args&gt;::TypeOrDefault&gt;::Type A8;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt; 9, Args&gt;::TypeOrDefault&gt;::Type A9;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt;10, Args&gt;::TypeOrDefault&gt;::Type A10;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt;11, Args&gt;::TypeOrDefault&gt;::Type A11;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt;12, Args&gt;::TypeOrDefault&gt;::Type A12;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt;13, Args&gt;::TypeOrDefault&gt;::Type A13;
    typedef typename bslmf::ForwardingType&lt;
        typename bslmf::TypeListTypeOf&lt;14, Args&gt;::TypeOrDefault&gt;::Type A14;
        // &#39;AN&#39;, for &#39;N&#39; from 1 up to 14, is an alias for the type of the &#39;N&#39;th
        // argument in the &#39;Args&#39; list.

    // DATA
    PROTOTYPE                          d_func_p;  // pointer to member function

    bslalg::ConstructorProxy&lt;INSTANCE&gt; d_obj;     // object instance, or
                                                  // pointer to such

    // PRIVATE ACCESSORS
  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(MemFnInstance, bslma::UsesBslmaAllocator);
    BSLMF_NESTED_TRAIT_DECLARATION(MemFnInstance, bslmf::IsBitwiseMoveable);

    // CREATORS
    MemFnInstance(PROTOTYPE         func,
                  const INSTANCE&amp;   object,
                  bslma::Allocator *basicAllocator = 0);
        // Create a member function pointer wrapper around the specified &#39;func&#39;
        // member function pointer of the parameterized &#39;PROTOTYPE&#39;, that is
        // invocable on the specified &#39;object&#39; instance of the parameterized
        // &#39;INSTANCE&#39;.  Optionally specify a &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.

    MemFnInstance(const MemFnInstance&amp;  original,
                  bslma::Allocator     *basicAllocator = 0);
        // Create a member function pointer wrapper around the same member
        // function and instance pointed to by the specified &#39;original&#39; object.
        // Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    ~MemFnInstance();
        // Destroy this object.

    // MANIPULATORS
    MemFnInstance&amp; operator=(const MemFnInstance&amp; rhs);
        // Assign to this member function pointer wrapper the same member
        // function and instance pointed to by the specified &#39;rhs&#39; member
        // function pointer wrapper, and return a reference to this modifiable
        // member function pointer wrapper.

    // ACCESSORS
    ResultType operator()() const;
    ResultType operator()(A1 a1) const;
    ResultType operator()(A1 a1, A2 a2) const;
    ResultType operator()(A1 a1, A2 a2, A3 a3) const;
    ResultType operator()(A1 a1, A2 a2, A3 a3, A4 a4) const;
    ResultType operator()(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const;
    ResultType operator()(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const;
    ResultType operator()(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,
                          A7 a7) const;
    ResultType operator()(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,
                          A7 a7, A8 a8) const;
    ResultType operator()(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,
                          A7 a7, A8 a8, A9 a9) const;
    ResultType operator()(A1 a1, A2 a2, A3 a3, A4  a4, A5 a5, A6 a6,
                          A7 a7, A8 a8, A9 a9, A10 a10) const;
    ResultType operator()(A1 a1, A2 a2, A3 a3, A4  a4,  A5  a5, A6 a6,
                          A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const;
    ResultType operator()(A1  a1, A2 a2, A3 a3, A4  a4,  A5  a5, A6 a6,
                          A7  a7, A8 a8, A9 a9, A10 a10, A11 a11,
                          A12 a12) const;
    ResultType operator()(A1  a1,  A2  a2, A3 a3, A4  a4,  A5  a5, A6 a6,
                          A7  a7,  A8  a8, A9 a9, A10 a10, A11 a11,
                          A12 a12, A13 a13) const;
    ResultType operator()(A1  a1,  A2  a2,  A3  a3, A4  a4,  A5  a5, A6 a6,
                          A7  a7,  A8  a8,  A9  a9, A10 a10, A11 a11,
                          A12 a12, A13 a13, A14 a14) const;
        // Invoke the member function pointer held by this wrapper on the
        // provided object with the specified &#39;a1&#39; up to &#39;aN&#39; as arguments,
        // with &#39;N&#39; being the number of arguments of the member function, and
        // return the result of this invocation, or &#39;void&#39; if this member
        // function pointer does not return a result.
};

                              // ================
                              // struct MemFnUtil
                              // ================

struct MemFnUtil {
    // The methods provided in this utility are used for constructing &#39;MemFn&#39;
    // and &#39;MemFnInstance&#39; objects from function pointers.

    // CLASS METHODS
    template &lt;class PROTOTYPE&gt;
    static
    MemFn&lt;PROTOTYPE&gt; memFn(PROTOTYPE func);
        // Return a &#39;MemFn&#39; member function wrapper that encapsulates the
        // specified &#39;func&#39; member function pointer of the parameterized
        // &#39;PROTOTYPE&#39;.

    template &lt;class PROTOTYPE, class INSTANCE&gt;
    static
    MemFnInstance&lt;PROTOTYPE, INSTANCE&gt; memFn(PROTOTYPE       func,
                                             const INSTANCE&amp; object);
        // Return a &#39;MemFnInstance&#39; member function wrapper that encapsulates
        // the specified &#39;func&#39; member function pointer of the parameterized
        // &#39;PROTOTYPE&#39; and the specified &#39;object&#39; instance of the parameterized
        // &#39;INSTANCE&#39; type.
};

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

                                // -----------
                                // class MemFn
                                // -----------

// CREATORS
template &lt;class PROTOTYPE&gt;
inline
MemFn&lt;PROTOTYPE&gt;::MemFn(PROTOTYPE func)
: d_func_p(func)
{
}

template &lt;class PROTOTYPE&gt;
inline
MemFn&lt;PROTOTYPE&gt;::MemFn(const MemFn&lt;PROTOTYPE&gt;&amp; original)
: d_func_p(original.d_func_p)
{
}

                            // -------------------
                            // class MemFnInstance
                            // -------------------

// CREATORS
template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::MemFnInstance(
                     const MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;&amp;  original,
                     bslma::Allocator                          *basicAllocator)
: d_func_p(original.d_func_p)
, d_obj(original.d_obj, bslma::Default::allocator(basicAllocator))
{
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::MemFnInstance(
                                              PROTOTYPE         func,
                                              const INSTANCE&amp;   object,
                                              bslma::Allocator *basicAllocator)
: d_func_p(func)
, d_obj(object, bslma::Default::allocator(basicAllocator))
{
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::~MemFnInstance()
{
}

// MANIPULATORS
template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;&amp;
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator=(
                                                 const MemFnInstance&amp; rhs)
{
    d_func_p       = rhs.d_func_p;
    d_obj.object() = rhs.d_obj.object();
    return *this;
}

// ACCESSORS
template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
typename MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::ResultType
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator()() const
{
    return (Deref::deref(d_obj.object()).*d_func_p)();
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
typename MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::ResultType
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator()(A1 a1) const
{
    return (Deref::deref(d_obj.object()).*d_func_p)(a1);
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
typename MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::ResultType
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator()(A1 a1, A2 a2) const
{
    return (Deref::deref(d_obj.object()).*d_func_p)(a1, a2);
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
typename MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::ResultType
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator()(A1 a1, A2 a2, A3 a3) const
{
    return (Deref::deref(d_obj.object()).*d_func_p)(a1, a2, a3);
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
typename MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::ResultType
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator()(
                                              A1 a1, A2 a2, A3 a3, A4 a4) const
{
    return (Deref::deref(d_obj.object()).*d_func_p)(a1, a2, a3, a4);
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
typename MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::ResultType
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator()(
                                       A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
{
    return (Deref::deref(d_obj.object()).*d_func_p)(a1, a2, a3, a4, a5);
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
typename MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::ResultType
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator()(
                                A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
{
    return (Deref::deref(d_obj.object()).*d_func_p)(a1, a2, a3, a4, a5, a6);
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
typename MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::ResultType
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator()(
                         A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
{
    return (Deref::deref(d_obj.object()).*d_func_p)(a1, a2, a3, a4, a5, a6,
                                                    a7);
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
typename MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::ResultType
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator()(
                  A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
{
    return (Deref::deref(d_obj.object()).*d_func_p)(a1, a2, a3, a4, a5, a6, a7,
                                                    a8);
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
typename MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::ResultType
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator()(
           A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
{
    return (Deref::deref(d_obj.object()).*d_func_p)(a1, a2, a3, a4, a5, a6, a7,
                                                    a8, a9);
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
typename MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::ResultType
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator()(
                A1  a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9,
                A10 a10) const
{
    return (Deref::deref(d_obj.object()).*d_func_p)(a1, a2, a3, a4, a5, a6, a7,
                                                    a8, a9, a10);
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
typename MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::ResultType
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator()(
              A1  a1,  A2  a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9,
              A10 a10, A11 a11) const
{
    return (Deref::deref(d_obj.object()).*d_func_p)(a1, a2, a3, a4, a5, a6,
                                                    a7, a8, a9, a10, a11);
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
typename MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::ResultType
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator()(
           A1  a1,  A2  a2,  A3  a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9,
           A10 a10, A11 a11, A12 a12) const
{
    return (Deref::deref(d_obj.object()).*d_func_p)(a1, a2, a3, a4, a5, a6, a7,
                                                    a8, a9, a10, a11, a12);
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
typename MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::ResultType
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator()(
          A1  a1,  A2  a2,  A3  a3,  A4  a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9,
          A10 a10, A11 a11, A12 a12, A13 a13) const
{
    return (Deref::deref(d_obj.object()).*d_func_p)(a1, a2, a3, a4, a5, a6, a7,
                                                    a8, a9, a10, a11, a12,
                                                    a13);
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
typename MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::ResultType
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;::operator()(
        A1  a1,  A2  a2,  A3  a3,  A4  a4,  A5  a5, A6 a6, A7 a7, A8 a8, A9 a9,
        A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
{
    return (Deref::deref(d_obj.object()).*d_func_p)(a1, a2, a3, a4, a5, a6, a7,
                                                    a8, a9, a10, a11, a12, a13,
                                                    a14);
}

                              // ----------------
                              // struct MemFnUtil
                              // ----------------

// CLASS METHODS
template &lt;class PROTOTYPE&gt;
inline
MemFn&lt;PROTOTYPE&gt;
MemFnUtil::memFn(PROTOTYPE func)
{
    return MemFn&lt;PROTOTYPE&gt;(func);
}

template &lt;class PROTOTYPE, class INSTANCE&gt;
inline
MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;
MemFnUtil::memFn(PROTOTYPE func, const INSTANCE&amp; object)
{
    return MemFnInstance&lt;PROTOTYPE, INSTANCE&gt;(func, object);
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
