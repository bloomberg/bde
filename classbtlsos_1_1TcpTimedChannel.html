<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlsos::TcpTimedChannel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlsos.html">btlsos</a>      </li>
      <li><a class="el" href="classbtlsos_1_1TcpTimedChannel.html">btlsos::TcpTimedChannel</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlsos::TcpTimedChannel Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlsos::TcpTimedChannel" --><!-- doxytag: inherits="btlsc::TimedChannel" -->
<p><code>#include &lt;<a class="el" href="btlsos__tcptimedchannel_8h_source.html">btlsos_tcptimedchannel.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlsos::TcpTimedChannel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlsos_1_1TcpTimedChannel.png" usemap="#btlsos::TcpTimedChannel_map" alt=""/>
  <map id="btlsos::TcpTimedChannel_map" name="btlsos::TcpTimedChannel_map">
<area href="classbtlsc_1_1TimedChannel.html" alt="btlsc::TimedChannel" shape="rect" coords="0,56,151,80"/>
<area href="classbtlsc_1_1Channel.html" alt="btlsc::Channel" shape="rect" coords="0,0,151,24"/>
</map>
</div>

<p><a href="classbtlsos_1_1TcpTimedChannel-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a395568c0c1acf17190086ef51682ddd5">TcpTimedChannel</a> (<a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *socket, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ac281aa5e92cde16d4f09b7047ce88848">~TcpTimedChannel</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a735286c8d0703c95f0ce7b46d34fc2f6">read</a> (char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a59c8d4a5dde54f787d434b6454390b07">read</a> (int *augStatus, char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a51e3795892b3e8e4b07f4f0f00420d17">timedRead</a> (char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ada1d0d17d220080cd5a53d70ec465e96">timedRead</a> (int *augStatus, char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ad59b39102e0c16ba67133ed01c56fd16">readv</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#af7eb08a819a2467f2c35130558e65ec8">readv</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a1ede9bdb52cbd652d4594664ea7e3f0b">timedReadv</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a7d1ff207fd82a6c0a29a17c83e093aec">timedReadv</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#af3a53d360e6d321c27cdc779a718db64">readRaw</a> (char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a17a3b84250892eb51666082bc641ce73">readRaw</a> (int *augStatus, char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#addd4b5dd913a39bb285a75d875e1d736">timedReadRaw</a> (char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ac22f9965e7cdc3b546f9e0a21864a835">timedReadRaw</a> (int *augStatus, char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a759d571ee9286c1e0aa53e2ebdbe1488">readvRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a75795b4d4304bcf7330a14e704f9c39c">readvRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#af8d6e64ff4c1ef8b39d6b063df1fbb9a">timedReadvRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a90c0fdf35ff0164410d3c296db346d48">timedReadvRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a8eecaa9c994297962c059abf53d14385">bufferedRead</a> (const char **buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a72f72ac59fd245a2e7de7f7c50854a01">bufferedRead</a> (int *augStatus, const char **buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a6c8202802fd718a1b22ffc95af50360b">timedBufferedRead</a> (const char **buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a17873f7d1fd9131dfa4762ed77cde07e">timedBufferedRead</a> (int *augStatus, const char **buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#aae5cee6d0a2819d4588d19e7df896499">bufferedReadRaw</a> (const char **buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ad86fbea8e77192280b02c7e7380269ed">bufferedReadRaw</a> (int *augStatus, const char **buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a43ef9f68bdb69997d3dff6164836c176">timedBufferedReadRaw</a> (const char **buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#af47a7032068d8772e0f687792908488e">timedBufferedReadRaw</a> (int *augStatus, const char **buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ab4d083426f2b0fc2e3f24b56efb0c3ee">write</a> (const char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ae585e569a0d7fb45379e56e707892f2c">write</a> (int *augStatus, const char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a7e1b7060a538ad6cdb09c98260bf2fa5">timedWrite</a> (int *augStatus, const char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#acd76a187c20f2afb0a1ed48b603de380">timedWrite</a> (const char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a897717b587849e0bcd99402e8dac6ed5">writeRaw</a> (const char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a93998cf7d4b5ecc4e5a1e6ec35bf490b">writeRaw</a> (int *augStatus, const char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a60fa72c4531426429ce3b8ae3f0f0039">timedWriteRaw</a> (int *augStatus, const char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a99a6a1ad6462a051f33f913e1e9305c3">timedWriteRaw</a> (const char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ae77fa6e093fdcf83866266c8a700d020">writev</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a00d5d3982a1e42735189a2ab29ca4087">writev</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#aeb9ad24d386b174c7d75c5c0c5f5ab85">writev</a> (int *augStatus, const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#afc322f0914cb50d6abee9f5012c49c2d">writev</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a556463f0f9a7b54aacb7dd810db19a96">timedWritev</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a15cea7877da7be56bfca34aa9363601b">timedWritev</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a6003601afd4e4e81b205da7b1a80c566">timedWritev</a> (int *augStatus, const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a4959e33840bf63b606ec659bdba56efa">timedWritev</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a316d48748074ad888cdfdd138262ce50">writevRaw</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#af60db49d74a32c17089b3d57ac0050b9">writevRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ac40e73055d876fb403d1eb298886334b">writevRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a8f2ef327d11a9780586862a51b37a6f9">writevRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ae63fab2f6ea5ccb87a92101eea34a18b">timedWritevRaw</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ab84a3306c896bc6de4663ff30a44440b">timedWritevRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#af1f0d3ada152b5f40a6cac6a140b6554">timedWritevRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a8d4503ce190f299af061395b80373747">timedWritevRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ae3d77d146a11a8b472d2fe9e308fe1c8">invalidate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#acd6bb50e81d38036b1606a39e6322d2f">getLocalAddress</a> (<a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *result)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#afd1f7eb8049de5e05055e4a81a359003">getOption</a> (int *result, int level, int option)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a366a7864c74dd301d8c740cd11a67d6e">getPeerAddress</a> (<a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *result)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a99590f7dba51f5932963b45831cfb818">setOption</a> (int level, int option, int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a9173d6b4ac3106ad3f6b78641d858064">isInvalid</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a><br class="typebreak"/>
&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a2ab40e795db1ec4f12ec823818a2af52">socket</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements <code><a class="el" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a></code> protocol over TCP/IP sockets. It operates on top of the stream-socket interface, which is provided at construction. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a395568c0c1acf17190086ef51682ddd5"></a><!-- doxytag: member="btlsos::TcpTimedChannel::TcpTimedChannel" ref="a395568c0c1acf17190086ef51682ddd5" args="(btlso::StreamSocket&lt; btlso::IPv4Address &gt; *socket, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlsos::TcpTimedChannel::TcpTimedChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a timed channel attached to the specified stream-oriented <code>socket</code>. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>socket</code> is not 0. </p>

</div>
</div>
<a class="anchor" id="ac281aa5e92cde16d4f09b7047ce88848"></a><!-- doxytag: member="btlsos::TcpTimedChannel::~TcpTimedChannel" ref="ac281aa5e92cde16d4f09b7047ce88848" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlsos::TcpTimedChannel::~TcpTimedChannel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this channel and release the underlying socket. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a735286c8d0703c95f0ce7b46d34fc2f6"></a><!-- doxytag: member="btlsos::TcpTimedChannel::read" ref="a735286c8d0703c95f0ce7b46d34fc2f6" args="(char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::read </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#aa6e7d7a43e3c921e3b7994143838c8a5">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a59c8d4a5dde54f787d434b6454390b07"></a><!-- doxytag: member="btlsos::TcpTimedChannel::read" ref="a59c8d4a5dde54f787d434b6454390b07" args="(int *augStatus, char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::read </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into the specified <code>buffer</code> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#ab59fde4eed8bf2f5b75ed60b550b7b11">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a51e3795892b3e8e4b07f4f0f00420d17"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedRead" ref="a51e3795892b3e8e4b07f4f0f00420d17" args="(char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedRead </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#aae95f9e919d0b410e8b98631f408f15c">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ada1d0d17d220080cd5a53d70ec465e96"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedRead" ref="ada1d0d17d220080cd5a53d70ec465e96" args="(int *augStatus, char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedRead </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into the specified <code>buffer</code> the specified <code>numBytes</code> or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, or a positive value if the interruption was due to an asynchronous event; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a51c73163640fbb67dbb743d30b545461">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ad59b39102e0c16ba67133ed01c56fd16"></a><!-- doxytag: member="btlsos::TcpTimedChannel::readv" ref="ad59b39102e0c16ba67133ed01c56fd16" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::readv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#ae3295a2d86824880eeb24d1c099776f1">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="af7eb08a819a2467f2c35130558e65ec8"></a><!-- doxytag: member="btlsos::TcpTimedChannel::readv" ref="af7eb08a819a2467f2c35130558e65ec8" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::readv </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> the respective numbers of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> buffer. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a partial result. Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffers</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffers</code> have sufficient capacity to hold the requested data and 0 &lt; numBytes. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#ad432f1bf2480dfa35ce1bfe5af096971">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a1ede9bdb52cbd652d4594664ea7e3f0b"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedReadv" ref="a1ede9bdb52cbd652d4594664ea7e3f0b" args="(const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedReadv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a15d50d46dfc8df7c7a8c345e95107fcc">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a7d1ff207fd82a6c0a29a17c83e093aec"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedReadv" ref="a7d1ff207fd82a6c0a29a17c83e093aec" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedReadv </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> the respective numbers of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> buffer, or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation or a positive value if the interruption was due to an asynchronous event; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffers</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffers</code> have sufficient capacity to hold the requested data and 0 &lt; numBytes. Note that if the <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#aee2a9f0588b23e3c1ca7ba9443c39d19">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="af3a53d360e6d321c27cdc779a718db64"></a><!-- doxytag: member="btlsos::TcpTimedChannel::readRaw" ref="af3a53d360e6d321c27cdc779a718db64" args="(char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::readRaw </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a6504f4a2919416095a920659e93d83ed">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a17a3b84250892eb51666082bc641ce73"></a><!-- doxytag: member="btlsos::TcpTimedChannel::readRaw" ref="a17a3b84250892eb51666082bc641ce73" args="(int *augStatus, char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::readRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into the specified <code>buffer</code> <em>at</em> <em>most</em> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. Note that if the specified <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a77dd10d5c91167f74215b4a076da2447">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="addd4b5dd913a39bb285a75d875e1d736"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedReadRaw" ref="addd4b5dd913a39bb285a75d875e1d736" args="(char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedReadRaw </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a343fb4d94f2deef15bb483357e96428c">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ac22f9965e7cdc3b546f9e0a21864a835"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedReadRaw" ref="ac22f9965e7cdc3b546f9e0a21864a835" args="(int *augStatus, char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedReadRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into the specified <code>buffer</code> <em>at</em> <em>most</em> the specified <code>numBytes</code> or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, a positive value if an asynchronous event caused an interruption, or a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a5b35a20d07081e88428772bda4ee9ed6">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a759d571ee9286c1e0aa53e2ebdbe1488"></a><!-- doxytag: member="btlsos::TcpTimedChannel::readvRaw" ref="a759d571ee9286c1e0aa53e2ebdbe1488" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::readvRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a11afd2f67cc89ab2360489daaa997275">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a75795b4d4304bcf7330a14e704f9c39c"></a><!-- doxytag: member="btlsos::TcpTimedChannel::readvRaw" ref="a75795b4d4304bcf7330a14e704f9c39c" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::readvRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> <em>at</em> <em>most</em> the respective numbers of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> buffer. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous
         events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffers</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffers</code> have sufficient capacity to hold the requested data and 0 &lt; numBytes. Note that if the specified <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#afda9947efb6bbe61076ef27002033468">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="af8d6e64ff4c1ef8b39d6b063df1fbb9a"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedReadvRaw" ref="af8d6e64ff4c1ef8b39d6b063df1fbb9a" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedReadvRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#aa55160a8750b3903c3df1b880267b6a1">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a90c0fdf35ff0164410d3c296db346d48"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedReadvRaw" ref="a90c0fdf35ff0164410d3c296db346d48" args="(const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedReadvRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> <em>at</em> <em>most</em> the respective numbers of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> buffer, or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous
         events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, a positive value if an asynchronous event caused an interruption, or a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffers</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffers</code> have sufficient capacity to hold the requested data and 0 &lt; numBytes. Note that if the <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#aa5e63267c7c8c697c65eb08d78e82e58">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a8eecaa9c994297962c059abf53d14385"></a><!-- doxytag: member="btlsos::TcpTimedChannel::bufferedRead" ref="a8eecaa9c994297962c059abf53d14385" args="(const char **buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::bufferedRead </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a87d383bf17a44ac7792cd4a3cb49d5c2">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a72f72ac59fd245a2e7de7f7c50854a01"></a><!-- doxytag: member="btlsos::TcpTimedChannel::bufferedRead" ref="a72f72ac59fd245a2e7de7f7c50854a01" args="(int *augStatus, const char **buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::bufferedRead </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into a channel-supplied buffer, identified via the specified <code>buffer</code>, the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. Any positive return value guarantees that <code>buffer</code> will remain valid until this channel is modified. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried with some reasonable hope of success -- buffered data from a partial result remains available until consumed by subsequent read operations. A negative "status", however, indicates a permanent error (leaving <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a06af323598ea8128962ad58c3f395541">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a6c8202802fd718a1b22ffc95af50360b"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedBufferedRead" ref="a6c8202802fd718a1b22ffc95af50360b" args="(const char **buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedBufferedRead </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#aa773c86182fbf9db87038eded3c100c0">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a17873f7d1fd9131dfa4762ed77cde07e"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedBufferedRead" ref="a17873f7d1fd9131dfa4762ed77cde07e" args="(int *augStatus, const char **buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedBufferedRead </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into a channel-supplied buffer, identified via the specified <code>buffer</code>, the specified <code>numBytes</code>, or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. Any positive return value guarantees that <code>buffer</code> will remain valid until this channel is modified. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, or a positive value if the interruption was due to an asynchronous event; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried with some reasonable hope of success -- buffered data from a partial result remains available until consumed by subsequent read operations. A negative "status", however, indicates a permanent error (leaving <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a9f88bb459460da9f7340b415e164e456">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aae5cee6d0a2819d4588d19e7df896499"></a><!-- doxytag: member="btlsos::TcpTimedChannel::bufferedReadRaw" ref="aae5cee6d0a2819d4588d19e7df896499" args="(const char **buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::bufferedReadRaw </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a5dd4767cd340cb49fba9cd7eef322252">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ad86fbea8e77192280b02c7e7380269ed"></a><!-- doxytag: member="btlsos::TcpTimedChannel::bufferedReadRaw" ref="ad86fbea8e77192280b02c7e7380269ed" args="(int *augStatus, const char **buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::bufferedReadRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into a channel-supplied buffer, identified via the specified <code>buffer</code>, <em>at</em> <em>most</em> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. Any positive return value guarantees that <code>buffer</code> will remain valid until this channel is modified. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation, or a negative value if the atomic OS-level operation transmitted at least one but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried with some reasonable hope of success -- buffered data from a partial result remains available until consumed by subsequent read operations. A negative "status", however, indicates a permanent error (leaving <code>buffer</code> unset); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#af5232093e6c2db53f2df06b79e4adf49">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a43ef9f68bdb69997d3dff6164836c176"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedBufferedReadRaw" ref="a43ef9f68bdb69997d3dff6164836c176" args="(const char **buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedBufferedReadRaw </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#ab01361256bd112dfcb2226fd62b46baa">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="af47a7032068d8772e0f687792908488e"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedBufferedReadRaw" ref="af47a7032068d8772e0f687792908488e" args="(int *augStatus, const char **buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedBufferedReadRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into a channel-supplied buffer, identified via the specified <code>buffer</code>, <em>at</em> <em>most</em> the specified <code>numBytes</code> or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, a positive value if an asynchronous event caused an interruption, or a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried with some reasonable hope of success -- buffered data from a partial result remains available until consumed by subsequent read operations. A negative "status", however, indicates a permanent error (leaving <code>buffer</code> unset); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a17e77dfd82469eb8e876de69d6197cf0">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ab4d083426f2b0fc2e3f24b56efb0c3ee"></a><!-- doxytag: member="btlsos::TcpTimedChannel::write" ref="ab4d083426f2b0fc2e3f24b56efb0c3ee" args="(const char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::write </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#af4618ca1d8246c5b1b7cd80aa22c6f3e">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ae585e569a0d7fb45379e56e707892f2c"></a><!-- doxytag: member="btlsos::TcpTimedChannel::write" ref="ae585e569a0d7fb45379e56e707892f2c" args="(int *augStatus, const char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::write </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this channel from the specified <code>buffer</code> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a9676b599f143bb2e557f6d2f35d87e7e">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a7e1b7060a538ad6cdb09c98260bf2fa5"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedWrite" ref="a7e1b7060a538ad6cdb09c98260bf2fa5" args="(int *augStatus, const char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedWrite </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#adfb9b67e2675cf0bac48100380b7be46">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="acd76a187c20f2afb0a1ed48b603de380"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedWrite" ref="acd76a187c20f2afb0a1ed48b603de380" args="(const char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedWrite </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this channel from the specified <code>buffer</code> the specified <code>numBytes</code> or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, or a positive value if the interruption was due to an asynchronous event; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "write" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a992bd0b098330327b38b8ac8e81ca2b3">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a897717b587849e0bcd99402e8dac6ed5"></a><!-- doxytag: member="btlsos::TcpTimedChannel::writeRaw" ref="a897717b587849e0bcd99402e8dac6ed5" args="(const char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::writeRaw </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#ae2f0f4ee7ddc0fac11e4a4e14aed2fb1">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a93998cf7d4b5ecc4e5a1e6ec35bf490b"></a><!-- doxytag: member="btlsos::TcpTimedChannel::writeRaw" ref="a93998cf7d4b5ecc4e5a1e6ec35bf490b" args="(int *augStatus, const char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::writeRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> write to this channel from the specified <code>buffer</code> <em>at</em> <em>most</em> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. Note that if the specified <code>timeout</code> value has already passed, the "write" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a18a872e47d6bed16924712c3d208b3b4">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a60fa72c4531426429ce3b8ae3f0f0039"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedWriteRaw" ref="a60fa72c4531426429ce3b8ae3f0f0039" args="(int *augStatus, const char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedWriteRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a9b3c2e1b9c7f76da0ce6e57f500266be">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a99a6a1ad6462a051f33f913e1e9305c3"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedWriteRaw" ref="a99a6a1ad6462a051f33f913e1e9305c3" args="(const char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedWriteRaw </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> write to this channel from the specified <code>buffer</code> <em>at</em> <em>most</em> the specified <code>numBytes</code>, or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, a positive value if an asynchronous event caused an interruption, or a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "write" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a72fb98c0c244722b0bf50de03f7c14ef">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ae77fa6e093fdcf83866266c8a700d020"></a><!-- doxytag: member="btlsos::TcpTimedChannel::writev" ref="ae77fa6e093fdcf83866266c8a700d020" args="(const btls::Ovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::writev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#abe0bcbc0fdb4df6e8ab99bea0740923a">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a00d5d3982a1e42735189a2ab29ca4087"></a><!-- doxytag: member="btlsos::TcpTimedChannel::writev" ref="a00d5d3982a1e42735189a2ab29ca4087" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::writev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#af1e9c9795a24ffca18f6fc9d07c36760">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aeb9ad24d386b174c7d75c5c0c5f5ab85"></a><!-- doxytag: member="btlsos::TcpTimedChannel::writev" ref="aeb9ad24d386b174c7d75c5c0c5f5ab85" args="(int *augStatus, const btls::Ovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::writev </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#ac0274a4ba4cd0435ab4052d537c94256">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="afc322f0914cb50d6abee9f5012c49c2d"></a><!-- doxytag: member="btlsos::TcpTimedChannel::writev" ref="afc322f0914cb50d6abee9f5012c49c2d" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::writev </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this channel from the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> the respective numbers of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> (or <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code>) structure. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous
         events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a partial result. Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless 0 &lt; numBytes. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#ab91d5a34cf60e1d19d53ba916d3d4e3b">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a556463f0f9a7b54aacb7dd810db19a96"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedWritev" ref="a556463f0f9a7b54aacb7dd810db19a96" args="(const btls::Ovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedWritev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a65f5e31b5c231f4c50b7da0a9a94e456">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a15cea7877da7be56bfca34aa9363601b"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedWritev" ref="a15cea7877da7be56bfca34aa9363601b" args="(const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedWritev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#aa8929c2572dc426110c1c298e8de4b6d">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a6003601afd4e4e81b205da7b1a80c566"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedWritev" ref="a6003601afd4e4e81b205da7b1a80c566" args="(int *augStatus, const btls::Ovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedWritev </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#aa6dbd53812337f1be6a9a19865fbf1b2">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a4959e33840bf63b606ec659bdba56efa"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedWritev" ref="a4959e33840bf63b606ec659bdba56efa" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedWritev </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this channel from the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> the respective numbers of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> (or <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code>) structure, or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous
         events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation or a positive value if the interruption was due to an asynchronous event; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "write" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a4aa9dc8de63950de2ea490266c366d15">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a316d48748074ad888cdfdd138262ce50"></a><!-- doxytag: member="btlsos::TcpTimedChannel::writevRaw" ref="a316d48748074ad888cdfdd138262ce50" args="(const btls::Ovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a51902a4d7db84af44306d8500ac6c1e8">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="af60db49d74a32c17089b3d57ac0050b9"></a><!-- doxytag: member="btlsos::TcpTimedChannel::writevRaw" ref="af60db49d74a32c17089b3d57ac0050b9" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#ae6fbfcb75a6762ac2b15414293ce1f99">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ac40e73055d876fb403d1eb298886334b"></a><!-- doxytag: member="btlsos::TcpTimedChannel::writevRaw" ref="ac40e73055d876fb403d1eb298886334b" args="(int *augStatus, const btls::Ovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a218f3e7f5dcd27ed808fc5322a19446e">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a8f2ef327d11a9780586862a51b37a6f9"></a><!-- doxytag: member="btlsos::TcpTimedChannel::writevRaw" ref="a8f2ef327d11a9780586862a51b37a6f9" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> write to this channel, from the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code>, <em>at</em> <em>most</em> the respective numbers of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> (or <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code>) buffer. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from ' buffer' (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless 0 &lt; numBytes. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#aed4f2547ec415cc0247cbd7923a554c4">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ae63fab2f6ea5ccb87a92101eea34a18b"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedWritevRaw" ref="ae63fab2f6ea5ccb87a92101eea34a18b" args="(const btls::Ovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedWritevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a9bbb75ce852a389417aa6727337614f1">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ab84a3306c896bc6de4663ff30a44440b"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedWritevRaw" ref="ab84a3306c896bc6de4663ff30a44440b" args="(const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedWritevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a2624dba51bab2f3eeede19c8906f3e27">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="af1f0d3ada152b5f40a6cac6a140b6554"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedWritevRaw" ref="af1f0d3ada152b5f40a6cac6a140b6554" args="(int *augStatus, const btls::Ovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedWritevRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a2b749f47cb21b60a88cf2c95e08e48b1">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a8d4503ce190f299af061395b80373747"></a><!-- doxytag: member="btlsos::TcpTimedChannel::timedWritevRaw" ref="a8d4503ce190f299af061395b80373747" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::timedWritevRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> write to this channel, from the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code>, <em>at</em> <em>most</em> the respective numbers of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> buffer, or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code>btlsc::TimedChannel::ASYNC_INTERRUPT</code>, "asynchronous
         events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, a positive value if an asynchronous event caused an interruption, or a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless 0 &lt; numBytes. Note that if the <code>timeout</code> value has already passed, the "write" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a32b82d439cecc66991850c248eb6c01b">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ae3d77d146a11a8b472d2fe9e308fe1c8"></a><!-- doxytag: member="btlsos::TcpTimedChannel::invalidate" ref="ae3d77d146a11a8b472d2fe9e308fe1c8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlsos::TcpTimedChannel::invalidate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make this channel invalid; no subsequent operations can be completed successfully. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#a61020bb76979046ff1f4d1c1b20cc365">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="acd6bb50e81d38036b1606a39e6322d2f"></a><!-- doxytag: member="btlsos::TcpTimedChannel::getLocalAddress" ref="acd6bb50e81d38036b1606a39e6322d2f" args="(btlso::IPv4Address *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::getLocalAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the complete IP address associated with the local (i.e., this process) end-point of this channel. Return 0 on success and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="afd1f7eb8049de5e05055e4a81a359003"></a><!-- doxytag: member="btlsos::TcpTimedChannel::getOption" ref="afd1f7eb8049de5e05055e4a81a359003" args="(int *result, int level, int option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::getOption </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the current value of the specified <code>option</code> of the specified <code>level</code> set on the underlying socket. Return 0 on success and a non-zero value otherwise. The list of commonly-supported options (and levels) is enumerated in <code>btlso_socketoptutil</code>. </p>

</div>
</div>
<a class="anchor" id="a366a7864c74dd301d8c740cd11a67d6e"></a><!-- doxytag: member="btlsos::TcpTimedChannel::getPeerAddress" ref="a366a7864c74dd301d8c740cd11a67d6e" args="(btlso::IPv4Address *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::getPeerAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the complete IP address associated with the remote (i.e., peer process) end-point of this channel. Return 0 on success and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="a99590f7dba51f5932963b45831cfb818"></a><!-- doxytag: member="btlsos::TcpTimedChannel::setOption" ref="a99590f7dba51f5932963b45831cfb818" args="(int level, int option, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::setOption </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified socket <code>option</code> of the specified <code>level</code> on the underlying socket to the specified <code>value</code>. Return 0 on success and a non-zero value otherwise. (The list of commonly-supported options is available in <code>btlso_socketoptutil</code>.) </p>

</div>
</div>
<a class="anchor" id="a9173d6b4ac3106ad3f6b78641d858064"></a><!-- doxytag: member="btlsos::TcpTimedChannel::isInvalid" ref="a9173d6b4ac3106ad3f6b78641d858064" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedChannel::isInvalid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if <em>any</em> transmission error has occurred or if the channel has been explicitly invalidated (via <code>invalidate</code>) and 0 otherwise. Once a channel is invalid, no operations can be completed successfully. Note also that 0 return value does NOT guarantee that a subsequent I/O operation would not fail. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannel.html#abea62fb47ee9411dd1277106e0d57a15">btlsc::TimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a2ab40e795db1ec4f12ec823818a2af52"></a><!-- doxytag: member="btlsos::TcpTimedChannel::socket" ref="a2ab40e795db1ec4f12ec823818a2af52" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt;<a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a>&gt;* btlsos::TcpTimedChannel::socket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the stream-socket used by this channel. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlsos__tcptimedchannel_8h_source.html">btlsos_tcptimedchannel.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:17 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
