<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslstl_function.h                                                  -*-C++-*-
#ifndef INCLUDED_BSLSTL_FUNCTION
#define INCLUDED_BSLSTL_FUNCTION

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a polymorphic function object with a specific prototype.
//
//@CLASSES:
// bsl::function: polymorphic function object with a specific prototype.
// bsl::bad_function_call: exception object thrown when invoking null function
//
//@SEE_ALSO:
//
//@DESCRIPTION: This component provides a polymorphic function object
// (functor) that can be invoked like a function and that wraps a run-time
// invokable object such as a function pointer, member function pointer, or
// functor.  The return type and the number and type of arguments at
// invocation are specified by the template parameter, which is a function
// prototype.  A &quot;functor&quot; is similar to a C/C++ function pointer, but unlike
// function pointers, functors can be used to invoke any object that can be
// syntactically invoked as a function.  Objects of type &#39;bsl::function&#39; are
// generally used as callback functions to avoid templatizing a function or
// class.
//
///Usage
///-----

// Prevent this header from being included directly in &#39;BSL_OVERRIDES_STD&#39;
// mode.  Doing so is unsupported, and is likely to cause compilation errors.
#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
#error &quot;include &lt;bsl_functional.h&gt; instead of &lt;bslstl_function.h&gt; in \
BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ALLOCATOR
#include &lt;bslstl_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_PAIR
#include &lt;bslstl_pair.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SCALARPRIMITIVES
#include &lt;bslalg_scalarprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATORADAPTOR
#include &lt;bslma_allocatoradaptor.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ADDLVALUEREFERENCE
#include &lt;bslmf_addlvaluereference.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ADDRVALUEREFERENCE
#include &lt;bslmf_addrvaluereference.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ALLOCATORARGT
#include &lt;bslmf_allocatorargt.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLMF_CONDITIONAL
#include &lt;bslmf_conditional.h&gt;
#endif

#ifndef INCLUDED_BSLMF_FORWARDINGTYPE
#include &lt;bslmf_forwardingtype.h&gt;
#endif

#ifndef INCLUDED_BSLMF_FUNCTIONPOINTERTRAITS
#include &lt;bslmf_functionpointertraits.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISEMPTY
#include &lt;bslmf_isempty.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISPOINTER
#include &lt;bslmf_ispointer.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISRVALUEREFERENCE
#include &lt;bslmf_isrvaluereference.h&gt;
#endif

#ifndef INCLUDED_BSLMF_MEMBERFUNCTIONPOINTERTRAITS
#include &lt;bslmf_memberfunctionpointertraits.h&gt;
#endif

#ifndef INCLUDED_BSLMF_MOVABLEREF
#include &lt;bslmf_movableref.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NTHPARAMETER
#include &lt;bslmf_nthparameter.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVECONST
#include &lt;bslmf_removeconst.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVECV
#include &lt;bslmf_removecv.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVEREFERENCE
#include &lt;bslmf_removereference.h&gt;
#endif

#ifndef INCLUDED_BSLMF_SELECTTRAIT
#include &lt;bslmf_selecttrait.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENTUTIL
#include &lt;bsls_alignmentutil.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_COMPILERFEATURES
#include &lt;bsls_compilerfeatures.h&gt;
#endif

#ifndef INCLUDED_BSLS_EXCEPTIONUTIL
#include &lt;bsls_exceptionutil.h&gt;
#endif

#ifndef INCLUDED_BSLS_NULLPTR
#include &lt;bsls_nullptr.h&gt;
#endif

#ifndef INCLUDED_BSLS_OBJECTBUFFER
#include &lt;bsls_objectbuffer.h&gt;
#endif

#ifndef INCLUDED_BSLS_UNSPECIFIEDBOOL
#include &lt;bsls_unspecifiedbool.h&gt;
#endif

#ifndef INCLUDED_CSTDLIB
#include &lt;cstdlib&gt;
#define INCLUDED_CSTDLIB
#endif

#ifndef INCLUDED_TYPEINFO
#include &lt;typeinfo&gt;
#define INCLUDED_TYPEINFO
#endif

#ifndef INCLUDED_UTILITY
#include &lt;utility&gt;
#define INCLUDED_UTILITY
#endif

#ifndef INCLUDED_STDDEF_H
#include &lt;stddef.h&gt;
#define INCLUDED_STDDEF_H
#endif

#ifndef INCLUDED_STDLIB_H
#include &lt;stdlib.h&gt;
#define INCLUDED_STDLIB_H
#endif

namespace bsl {

// Forward declarations
template &lt;class FUNC&gt;
class function;  // Primary template declared but not defined.

template &lt;class MEM_FUNC_PTR, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke; // Primary template declared but not defined.

template &lt;class ALLOC&gt;
struct Function_AllocTraits;

template &lt;class FUNC&gt;
struct Function_ArgTypes;

template &lt;class FUNC&gt;
struct Function_NothrowWrapperUtil;

                        // =======================
                        // class bad_function_call
                        // =======================

#ifdef BDE_BUILD_TARGET_EXC

class bad_function_call : public native_std::exception {
    // Standard exception object thrown when attempting to invoke a null
    // function object.

  public:
    bad_function_call() BSLS_NOTHROW_SPEC;
        // Constructs this exception object.

    const char* what() const BSLS_NOTHROW_SPEC;
        // Returns &quot;bad_function_call&quot;.
};

#endif // BDE_BUILD_TARGET_EXC

                        // ======================================
                        // class template Function_NothrowWrapper
                        // ======================================

template &lt;class FUNC&gt;
class Function_NothrowWrapper
{
    // If a functor can throw on move, &#39;bsl::function&#39; will always allocate it
    // out-of-place so that move and swap will always be nothrow operations, as
    // is required by the standard.  Thus, many small functors will fail to
    // take advantage of the small-object optimization because they might throw
    // on move, no matter how unlikely that may be.  A function object wrapped
    // in &#39;Function_NothrowWrapper&#39;, however, will be treated by
    // &#39;bsl::function&#39; as though it were a function object with a &#39;noexcept&#39;
    // move constructor (even though it does not have the interface of a
    // function object).  This wrapper is especially useful in C++03 mode,
    // where &#39;noexcept&#39; does not exist, it that even non-throwing operations
    // are assumed to throw unless they delcare the bitwise movable trait.
    // Note that, in the unlikely event that moving the wrapped object *does*
    // throw at runtime, the result will likely be a call to &#39;terminate()&#39;.

    FUNC d_func;

  public:
    typedef FUNC UnwrappedType;

    Function_NothrowWrapper(const FUNC&amp; other) : d_func(other) { }

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    Function_NothrowWrapper(FUNC&amp;&amp; other)
      : d_func(BloombergLP::bslmf::MovableRefUtil::move(other))
    {
    }
#endif

    //! Function_NothrowWrapper(const Function_NothrowWrapper&amp;) = default;
    //! Function_NothrowWrapper&amp; operator=(const Function_NothrowWrapper&amp;)
    //!    = default;
    //! ~Function_NothrowWrapper() = default;

    FUNC&amp;       unwrap()       { return d_func; }
    FUNC const&amp; unwrap() const { return d_func; }
};

                        // ======================================
                        // class Function_SmallObjectOptimization
                        // ======================================

class Function_SmallObjectOptimization {
    // Namespace for several definitions related to use of the small object
    // optimization.

    class Dummy;  // Declared but not defined

    // Short aliases for type with maximum platform alignment
    typedef BloombergLP::bsls::AlignmentUtil::MaxAlignedType MaxAlignedType;

  public:
    union InplaceBuffer {
        // This &#39;union&#39; defines the storage area for a functor representation.
        // The design uses the &quot;small-object optimization&quot; in an attempt to
        // avoid allocations for objects that are no larger than
        // &#39;InplaceBuffer&#39;.  When using the in-place representation, the
        // invocable, whether a function pointer or function object (if it
        // should fit in the size of &#39;InplaceBuffer&#39;) is stored directly in the
        // &#39;InplaceBuffer&#39;.  Anything bigger than &#39;sizeof(InplaceBuffer)&#39; will
        // be stored out-of-place and its address will be stored in
        // &#39;d_object_p&#39;.  Discriminating between the two representations can be
        // done by the manager with the opcode &#39;e_GET_SIZE&#39;.
        //
        // Note that union members other than &#39;d_object_p&#39; are just fillers to
        // make sure that a function or member function pointer can fit without
        // allocation and that alignment is respected.  The &#39;d_minbuf&#39; member
        // ensures that &#39;InplaceBuffer&#39; is at least large enough so that
        // modestly-complex functors (e.g., functors that own embedded
        // arguments, such as &#39;bdef_Bind&#39; objects) to be constructed in-place
        // without triggering further allocation.  The benefit of avoiding
        // allocation for those function objects is balanced against the waste
        // of space when used with smaller function objects.
        //
        // The size of this &#39;union&#39; was chosen so that the inplace buffer will
        // be 6 pointers in size and the total footprint of a &#39;bsl::function&#39;
        // object on most platforms will be 10 pointers, which matches the
        // sizes of previous implementations of &#39;bdef_Function&#39;.

        void                *d_object_p;     // pointer to external rep
        void               (*d_func_p)();    // pointer to function
        void        (Dummy::*d_memFunc_p)(); // pointer to member function
        MaxAlignedType       d_align;        // force align
        void                *d_minbuf[6];    // force minimum size
    };

    static const size_t k_NON_SOO_SMALL_SIZE = ~sizeof(InplaceBuffer);
        // This value is added to the size of a small stateful functor to
        // indicate that, despite being small, it should not be allocated
        // inplace using the small object optimization (SOO), e.g., because it
        // does not have a nothrow move constructor and cannot, therefore, be
        // swapped safely.  When a size larger than this constant is seen, the
        // actual object size can be determined by subtracting this constant.
        // A useful quality of this encoding is that if &#39;SZ &lt;=
        // sizeof(InplaceBuffer)&#39; for some object size &#39;SZ&#39;, then &#39;SZ +
        // k_NON_SOO_SMALL_SIZE &gt; sizeof(InplaceBuffer)&#39;, so the &#39;SooFuncSize&#39;
        // (below) for any object that should not be allocated inplace is
        // larger than &#39;sizeof(InplaceBuffer)&#39;, and the &#39;SooFuncSize&#39; for any
        // object that *should* be allocated inplace is smaller than or equal
        // to &#39;sizeof(InplaceBuffer)&#39;, making the test for &quot;is inplace
        // function&quot; simple.

    BSLMF_ASSERT(k_NON_SOO_SMALL_SIZE &gt; 0);  // Assert unsigned size_t

    template &lt;class TP&gt;
    struct SooFuncSize
    {
        // Metafunction to determine the size of an object for the purposes of
        // the small object optimization (SOO).  The &#39;VALUE&#39; member is encoded
        // as follows:
        //
        //: o If &#39;TP&#39; is not larger than &#39;InplaceBuffer&#39; but has a throwing
        //:   destructive move operation (and therefore should not be allocated
        //:   inplace), then &#39;VALUE == sizeof(TP) + k_NON_SOO_SMALL_SIZE&#39;.
        //: o Otherwise, &#39;VALUE == sizeof(TP)&#39;.
        //
        // Note that the &#39;Soo&#39; prefix is used to indicate that an identifier
        // uses the above protocol.  Thus a variable called &#39;SooSize&#39; is
        // assumed to be encoded as above, whereas a variable called &#39;size&#39;
        // can generally be assumed not to be encoded that way.

#if    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)           \
    &amp;&amp; defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES)
        template &lt;class SOME_TYPE&gt;
            static typename bsl::add_rvalue_reference&lt;SOME_TYPE&gt;::type
                myDeclVal() noexcept;
            // The older versions of clang on OS/X do not provide declval even
            // in c++11 mode.
#endif

        static const std::size_t VALUE =
            sizeof(TP) &gt; sizeof(InplaceBuffer)                ? sizeof(TP) :
            BloombergLP::bslmf::IsBitwiseMoveable&lt;TP&gt;::value  ? sizeof(TP) :
            Function_NothrowWrapperUtil&lt;TP&gt;::IS_WRAPPED       ? sizeof(TP) :
#if    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)           \
    &amp;&amp; defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES)
            // Check if nothrow move constructible.  The use of &#39;::new&#39; lets
            // us check the constructor without also checking the destructor.
            // This is especially important in gcc 4.7 and before because
            // destructors are not implicitly &#39;noexcept&#39; in those compilers.
            noexcept(::new((void*) 0) TP(myDeclVal&lt;TP&gt;())) ? sizeof(TP) :
#endif
            // If not nonthrow or bitwise moveable, then add
            // &#39;k_NON_SOO_SMALL_SIZE&#39; to the size indicate that we should not
            // use the small object optimization for this type.
            sizeof(TP) + k_NON_SOO_SMALL_SIZE;
    };

    template &lt;class FN&gt;
    struct IsInplaceFunc :
        integral_constant&lt;bool,SooFuncSize&lt;FN&gt;::VALUE &lt;= sizeof(InplaceBuffer)&gt;
    {
        // Metafunction to determine whether the specified &#39;FN&#39; template
        // parameter should be allocated within the &#39;InplaceBuffer&#39;.

        // TBD: &#39;InplaceFunc&#39; should also take alignment into account, but
        // since we don&#39;t (yet) have the ability to specify alignment when
        // allocating memory, there&#39;s nothing we can do at this point.
    };
};

                        // ==================
                        // class Function_Rep
                        // ==================

class Function_Rep {
    // This is a component-private class.  Do not use.
    //
    // This class provides a non-template representation for a &#39;bsl::function&#39;
    // instance.  It handles all of the object-management parts of
    // &#39;bsl::function&#39; that are not specific to the argument list or return
    // type: storing, copying, and moving the function object and allocator,
    // but not invoking the function (which would require knowledge of the
    // function prototype).  These management functions are run-time
    // polymorphic, and therefore do not require that this class be templated
    // (although several of the member functions are templated).  For technical
    // reasons, this class must be defined before &#39;bsl::function&#39; (although a
    // mere forward declaration would be all right with most compilers, the Gnu
    // compiler emits an error when trying to do syntactic checking on template
    // code even though it does not instantiate template).

    // TYPES

    union PtrOrSize_t {
        // This union stores either a pointer to const void or a size_t.  It
        // is used as the input argument and return type for manager functions
        // (below).
      private:
        std::size_t  d_asSize_t;
        void        *d_asPtr;

      public:
        PtrOrSize_t(std::size_t s) : d_asSize_t(s) { }
        PtrOrSize_t(void *p) : d_asPtr(p) { }
        PtrOrSize_t() : d_asPtr(0) { }

        std::size_t asSize_t() const { return d_asSize_t; }
        void *asPtr() const { return d_asPtr; }
    };

    enum ManagerOpCode {
        // This enumeration provide values to identify operations to be
        // performed by an object manager function (below).  The object being
        // managed is either the function object in the case of the function
        // manager or the allocator object in the case of the allocator
        // manager.

        e_MOVE_CONSTRUCT
            // move-construct the object in &#39;rep&#39; from the object pointed to
            // by &#39;input&#39;.  Return the number of bytes needed to hold the
            // object.

      , e_COPY_CONSTRUCT
            // copy-construct the object in &#39;rep&#39; from the object pointed to
            // by &#39;input&#39;.  Return the number of bytes needed to hold the
            // object.

      , e_DESTROY
            // Call the destructor on the object in &#39;rep&#39;.  Return the number
            // of bytes needed to hold the destroyed object.  Some managers
            // also deallocate memory.

      , e_DESTRUCTIVE_MOVE
            // move-construct the object in &#39;rep&#39; from the object pointed to
            // by &#39;input&#39; and destroy the object at &#39;input&#39;.  Return nothing.
            // This operation is guaranteed not to throw.  Uses bitwise move
            // where possible.

      , e_GET_SIZE
            // Return the size of the object.  For function objects, the
            // computed size is modified by the SOO convention described in
            // the &#39;SooFuncSize&#39; metafunction.  (&#39;rep&#39; and &#39;input&#39; are
            // ignored.)

      , e_GET_TARGET
            // Return a pointer to the object in &#39;rep&#39;.

      , e_GET_TYPE_ID
            // Return a pointer to the &#39;type_info&#39; for the object in &#39;rep&#39;.

      , e_IS_EQUAL
            // (Allocator manager only) Return whether the allocator stored in
            // &#39;*rep&#39; is equal to the allocator stored in &#39;input&#39;, where
            // &#39;input&#39; is the &#39;d_allocator_p&#39; member of another &#39;Function_Rep&#39;
            // object.  For &#39;STL-style&#39; allocators, the allocators will be
            // considered equal only if &#39;rep-&gt;d_allocator_p&#39; and &#39;input&#39; both
            // point to &#39;bslma::AllocatorAdaptor&#39; objects of the same type
            // wrapping allocators that compare equal.  For all other
            // allocators types, the allocators are considered equal only if
            // &#39;rep-&gt;d_allocator_p&#39; is equal to the pointer stored in &#39;input&#39;.

      , e_INIT_REP
            // (Allocator manager only) Initialize &#39;rep&#39; using the &#39;input&#39;
            // allocator.  Requires that &#39;input&#39; point to an object of the
            // manager&#39;s &#39;ALLOC&#39; type and that &#39;rep-&gt;d_funcManager_p&#39; is
            // already set.
    };

  public:

    // Not really public: made public to work around a Sun compiler bug.
    enum AllocCategory {
        // Category of allocator supplied to a constructor.

        e_BSLMA_ALLOC_PTR        // Ptr to type derived from &#39;bslma::Allocator&#39;
      , e_BSL_ALLOCATOR          // Instantiation of &#39;bsl::allocator&#39;
      , e_ERASED_STATEFUL_ALLOC  // C++03 STL-style stateful allocator
      , e_ERASED_STATELESS_ALLOC // C++03 STL-style stateless allocator
    };

  private:

    typedef PtrOrSize_t (*Manager)(ManagerOpCode  opCode,
                                   Function_Rep  *rep,
                                   PtrOrSize_t    input);
        // &#39;Manager&#39; is an alias for a pointer to a function that manages a
        // specific object type (i.e., it copies, moves, or destroys it).  It
        // implements a kind of hand-coded virtual-function dispatch.  The
        // specified &#39;opCode&#39; is used to choose the &quot;virtual function&quot; to
        // invoke, where the specified &#39;rep&#39; and &#39;input&#39; are arguments to that
        // function.  Internally, a &#39;Manager&#39; function uses a &#39;switch&#39;
        // statement rather than performing a virtual-table lookup.  This
        // mechanism is chosen because it saves a significant amount of space
        // over the C++ virtual-function mechanism, especially when the number
        // of different instantiations of &#39;bsl::function&#39; is large.

    typedef Function_SmallObjectOptimization Soo;
        // Type alias for convenience.

    typedef Soo::InplaceBuffer InplaceBuffer;
        // Type alias for convenience.

    typedef BloombergLP::bslma::Allocator Allocator;
        // Type alias for convenience.

    static const size_t k_NON_SOO_SMALL_SIZE = Soo::k_NON_SOO_SMALL_SIZE;
        // Constant alias for convenience.

    template &lt;class FUNC&gt;
    friend class bsl::function;

    template &lt;class ALLOC&gt;
    friend struct Function_AllocTraits;

    template &lt;class ALLOC&gt;
    void copyInit(const ALLOC&amp; alloc, const Function_Rep&amp; other);
        // Using the specified &#39;alloc&#39;, copy-initialize this rep from the
        // specified &#39;other&#39; rep.

    void moveInit(Function_Rep&amp; other);
        // Move-initialize this rep from the specified &#39;other&#39; rep, leaving
        // the latter empty.

    void makeEmpty();
        // Change this object to be an empty object without changing its
        // allocator.  Note that value returned by &#39;allocator()&#39; might change,
        // but will point to an allocator with the same type managing the same
        // memory resource.

    void *initRep(std::size_t sooFuncSize, Allocator* alloc,
                  integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;);
    void *initRep(std::size_t sooFuncSize, const bsl::allocator&lt;char&gt;&amp; alloc,
                  integral_constant&lt;AllocCategory, e_BSL_ALLOCATOR&gt;);
    template &lt;class ALLOC&gt;
    void *initRep(std::size_t sooFuncSize, const ALLOC&amp; alloc,
                  integral_constant&lt;AllocCategory, e_ERASED_STATEFUL_ALLOC&gt;);
    template &lt;class ALLOC&gt;
    void *initRep(std::size_t sooFuncSize, const ALLOC&amp; alloc,
                  integral_constant&lt;AllocCategory, e_ERASED_STATELESS_ALLOC&gt;);
        // Initialize this object&#39;s &#39;d_objbuf&#39;, &#39;d_allocator_p&#39;, and
        // &#39;d_allocManager_p&#39; fields, allocating (if necessary) enough storage
        // to hold a function object of the specified &#39;sooFuncSize&#39; and
        // holding a copy of &#39;alloc&#39;.  If the function and allocator fit
        // within &#39;d_objbuf&#39;, then no memory is allocated.  The actual wrapped
        // function object is not initialized, nor is &#39;d_funcManager_p&#39; set.
        // Note that, for STL-style allocators, including &#39;bsl::allocator&#39;,
        // the element type should be rebound to &#39;char&#39; before calling
        // &#39;initRep&#39;.

    bool equalAlloc(Allocator* alloc,
                    integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;) const;
    template &lt;class T&gt;
    bool equalAlloc(const bsl::allocator&lt;T&gt;&amp; alloc,
                    integral_constant&lt;AllocCategory, e_BSL_ALLOCATOR&gt;) const;
    template &lt;class ALLOC&gt;
    bool equalAlloc(const ALLOC&amp; alloc,
              integral_constant&lt;AllocCategory, e_ERASED_STATEFUL_ALLOC&gt;) const;
    template &lt;class ALLOC&gt;
    bool equalAlloc(const ALLOC&amp; alloc,
              integral_constant&lt;AllocCategory,e_ERASED_STATELESS_ALLOC&gt;) const;
        // Return true if the specified &#39;alloc&#39; can be used to free memory
        // from the allocator stored in this object and vice versa, and false
        // otherwise.

    template &lt;class ALLOC, AllocCategory ATP&gt;
    void copyRep(const Function_Rep&amp;                   other,
                 const ALLOC&amp;                          alloc,
                 integral_constant&lt;AllocCategory, ATP&gt; atp);

    void assign(Function_Rep *from, ManagerOpCode moveOrCopy);
        // Move or copy the value of the specified &#39;*from&#39; object into
        // &#39;*this&#39;, depending on the the value of the specified &#39;moveOrCopy&#39;
        // argument.  The previous value of &#39;*this&#39; is discarded.  The
        // bahavior is undefined unless &#39;moveOrCopy&#39; is either
        // &#39;e_MOVE_CONSTRUCT&#39; or &#39;e_COPY_CONSTRUCT&#39;.

    static void destructiveMove(Function_Rep *to,
                                Function_Rep *from) BSLS_NOTHROW_SPEC;
        // Move the state from the specified &#39;from&#39; location to the specified
        // &#39;to&#39; location, where &#39;to&#39; points to uninitialized storage.  After
        // the move, &#39;from&#39; points to uninitialized storage.  The move is
        // performed using only non-throwing operations.

    template &lt;class FUNC, bool IS_INPLACE&gt;
    static PtrOrSize_t functionManager(ManagerOpCode  opCode,
                                       Function_Rep  *rep,
                                       PtrOrSize_t    input);

    static PtrOrSize_t unownedAllocManager(ManagerOpCode  opCode,
                                           Function_Rep  *rep,
                                           PtrOrSize_t    input);
        // Note that this function is not a template.  It is defined in the
        // component .cpp file.

    template &lt;class ALLOC&gt;
    static PtrOrSize_t ownedAllocManager(ManagerOpCode  opCode,
                                         Function_Rep  *rep,
                                         PtrOrSize_t    input);

    template &lt;class FUNC&gt;
    static Manager getFunctionManager();

    static void nothing(...);
        // A function that does nothing but can be called to avoid an inlining
        // error in gcc 4.3.5 64-bit mode.

  private:
    // DATA
    mutable InplaceBuffer d_objbuf;  // in-place representation (if fits, as
                                     // indicated by the manager), or pointer
                                     // to external representation

    Manager               d_funcManager_p;
                                     // pointer to manager function used to
                                     // operate on function object instance
                                     // (which knows about the erased type
                                     // &#39;FUNC&#39; of the function object), or null
                                     // for raw function pointers.

    Allocator            *d_allocator_p; // allocator (held, not owned)

    Manager               d_allocManager_p;
                                     // pointer to manager function used to
                                     // operate on allocator instance (which
                                     // knows about the erased type &#39;ALLOC&#39; of
                                     // the allocator object), or null if
                                     // &#39;ALLOC&#39; is &#39;bslma::Allocator*&#39;.
                                     // INVARIANT: Must be NULL unless
                                     // &#39;d_allocator_p&#39; has been set to a
                                     // fully-constructed allocator.

    void (*d_invoker_p)();           // Pointer to invoker function

    // The &#39;isInplace function is public in BDE legacy mode and private
    // otherwise.

    bool isInplace() const BSLS_NOTHROW_SPEC;
        // Return true if the wrapped functor is allocated in place within the
        // footprint of this &#39;function&#39; object; otherwise return false.

  public:
    // CREATORS
    Function_Rep();
    ~Function_Rep();

    // MANIPULATORS
    void swap(Function_Rep&amp; other) BSLS_NOTHROW_SPEC;

    // ACCESSORS
    const std::type_info&amp; target_type() const BSLS_NOTHROW_SPEC;
    template&lt;class TP&gt; TP*       target()       BSLS_NOTHROW_SPEC;
    template&lt;class TP&gt; const TP* target() const BSLS_NOTHROW_SPEC;
    Allocator *allocator() const;
};

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES // $var-args=14

                    // =======================
                    // class template function
                    // =======================

template &lt;class RET, class... ARGS&gt;
class function&lt;RET(ARGS...)&gt; :
        public Function_ArgTypes&lt;RET(ARGS...)&gt;,
        public Function_Rep
{
    // An instantiation of this class template generalizes the notion of a
    // pointer to a function taking the specified &#39;ARGS&#39; types and returning
    // the specified &#39;RET&#39; type, i.e., a function pointer of type
    // &#39;RET(*)(ARGS)&#39;.  An object of this class wraps a run-time invokable
    // object specified at construction, such as a function pointer, member
    // function pointer, or functor.  Note that &#39;function&#39; is defined only for
    // template parameters that specify a function prototype; the primary
    // template (taking an arbitrary template parameter) is not defined.

    // PRIVATE TYPES
    typedef RET Invoker(const Function_Rep* rep,
              typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args);
        // A function of this type is used to invoke the wrapped functor.

    // PRIVATE MEMBER FUNCTIONS
    void setInvoker(Invoker *p);
        // Set the invoker to the address in the specified &#39;p&#39; argument.

    Invoker *invoker() const;
        // Return the current invoker.

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
        // Return the invoker for an invocable of
        // pointer-to-(non-member)function.  Defined inline to work around Sun
        // CC bug.
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;                         // RETURN
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            // G++ 4.3.5 64-bit with optimization has an error which causes
            // this function to seemingly always return null unless this
            // useless use of &#39;f&#39; is present.
            Function_Rep::nothing(f);
#endif
            return NULL;                                              // RETURN
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
        // Return the invoker for an invocable of pointer-to-member-function
        // type.  Defined inline to work around Sun CC bug.
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;                          // RETURN
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            // G++ 4.3.5 64-bit with optimization has an error which causes
            // this function to seemingly always return null unless this
            // useless use of &#39;f&#39; is present.
            Function_Rep::nothing(f);
#endif
            return NULL;                                              // RETURN
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
        // Return the invoker for an invocable of in-place functor type.
        // Defined inline to work around Sun CC bug.
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
        // Return the invoker for an invocable of out-of-place functor type.
        // Defined inline to work around Sun CC bug.
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
        // Return the invoker for an invocable of the specified &#39;FUNC&#39; type.
        // Defined inline to work around Sun CC bug.
    {
        typedef Function_SmallObjectOptimization Soo;

        // Unwrap FUNC type if it is a specialization of
        // &#39;Function_NothrowWrapper&#39;.
        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        // Determine dispatch based on the traits of &#39;FuncType&#39;.
        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        // The only reason that the original and unwrapped &#39;FUNC&#39; would result
        // in different &#39;SooFuncSize&#39; is if &#39;FUNC&#39; is wrapping a small object
        // that would otherwise have a throwing move.  In that case, we force
        // the dispatch to choose &#39;Soo::IsInplaceFunc&#39;, otherwise we dispatch
        // on the selection traits of the original &#39;FUNC&#39; type.
        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        // Dispatch to the correct variant of &#39;invokerForFunc&#39;
        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type...);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type...);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type...);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type...);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    // UNSPECIFIED BOOL

    // This type is needed only in C++03 mode, where &#39;explicit&#39; conversion
    // operators are not supported.  A &#39;function&#39; is implicitly converted to
    // &#39;UnspecifiedBool&#39; when used in &#39;if&#39; statements, but is not implicitly
    // convertible to &#39;bool&#39;.
    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    // Since &#39;function&#39; does not support &#39;operator==&#39; and &#39;operator!=&#39;, they
    // must be deliberately supressed; otherwise &#39;function&#39; objects would be
    // implicitly comparable by implicit conversion to &#39;UnspecifiedBool&#39;.
    bool operator==(const function&amp;) const;  // Declared but not defined
    bool operator!=(const function&amp;) const;  // Declared but not defined
#endif

  public:
    // PUBLIC TYPES
    typedef RET result_type;

    // CREATORS
    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    // MANIPULATORS
    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
        // Copy constructor.  Needed to overload in preference to
        // &#39;operator=(FUNC&amp;&amp;)&#39;.
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(FUNC&amp;&amp;);
    function&amp; operator=(nullptr_t);

    // TBD: Need to implement reference_wrapper.
    // template&lt;class FUNC&gt;
    // function&amp; operator=(reference_wrapper&lt;FUNC&gt;) BSLS_NOTHROW_SPEC;

    // template&lt;class FUNC, class ALLOC&gt; void assign(FUNC&amp;&amp;, const ALLOC&amp;);
    //     // We have filed an issue report and have elected not to support
    //     // this function because the arguments and definition in the
    //     // standard make no sense.  Replacing the allocator of an existing
    //     // object is inconsistent with the rest of the standard.

    RET operator()(ARGS...) const;

    // ACCESSORS
#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit  // Explicit conversion available only with C++11
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    // Simulation of explicit conversion to bool.
    // Inlined to work around xlC bug when out-of-line.
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

// FREE FUNCTIONS
template &lt;class RET, class... ARGS&gt;
bool operator==(const function&lt;RET(ARGS...)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class... ARGS&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS...)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class... ARGS&gt;
bool operator!=(const function&lt;RET(ARGS...)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class... ARGS&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS...)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class... ARGS&gt;
void swap(function&lt;RET(ARGS...)&gt;&amp; a, function&lt;RET(ARGS...)&gt;&amp; b);

#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Generator command line: sim_cpp11_features.pl bslstl_function.h


template &lt;class RET&gt;
class function&lt;RET()&gt; :
        public Function_ArgTypes&lt;RET()&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(BSLS_COMPILERFEATURES_FORWARD_REF(FUNC));
    function&amp; operator=(nullptr_t);



    RET operator()() const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

template &lt;class RET, class ARGS_01&gt;
class function&lt;RET(ARGS_01)&gt; :
        public Function_ArgTypes&lt;RET(ARGS_01)&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(BSLS_COMPILERFEATURES_FORWARD_REF(FUNC));
    function&amp; operator=(nullptr_t);



    RET operator()(ARGS_01) const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
class function&lt;RET(ARGS_01,
                   ARGS_02)&gt; :
        public Function_ArgTypes&lt;RET(ARGS_01,
                                     ARGS_02)&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(BSLS_COMPILERFEATURES_FORWARD_REF(FUNC));
    function&amp; operator=(nullptr_t);



    RET operator()(ARGS_01,
                   ARGS_02) const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
class function&lt;RET(ARGS_01,
                   ARGS_02,
                   ARGS_03)&gt; :
        public Function_ArgTypes&lt;RET(ARGS_01,
                                     ARGS_02,
                                     ARGS_03)&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(BSLS_COMPILERFEATURES_FORWARD_REF(FUNC));
    function&amp; operator=(nullptr_t);



    RET operator()(ARGS_01,
                   ARGS_02,
                   ARGS_03) const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
class function&lt;RET(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04)&gt; :
        public Function_ArgTypes&lt;RET(ARGS_01,
                                     ARGS_02,
                                     ARGS_03,
                                     ARGS_04)&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(BSLS_COMPILERFEATURES_FORWARD_REF(FUNC));
    function&amp; operator=(nullptr_t);



    RET operator()(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04) const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
class function&lt;RET(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05)&gt; :
        public Function_ArgTypes&lt;RET(ARGS_01,
                                     ARGS_02,
                                     ARGS_03,
                                     ARGS_04,
                                     ARGS_05)&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(BSLS_COMPILERFEATURES_FORWARD_REF(FUNC));
    function&amp; operator=(nullptr_t);



    RET operator()(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05) const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
class function&lt;RET(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06)&gt; :
        public Function_ArgTypes&lt;RET(ARGS_01,
                                     ARGS_02,
                                     ARGS_03,
                                     ARGS_04,
                                     ARGS_05,
                                     ARGS_06)&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(BSLS_COMPILERFEATURES_FORWARD_REF(FUNC));
    function&amp; operator=(nullptr_t);



    RET operator()(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06) const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
class function&lt;RET(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07)&gt; :
        public Function_ArgTypes&lt;RET(ARGS_01,
                                     ARGS_02,
                                     ARGS_03,
                                     ARGS_04,
                                     ARGS_05,
                                     ARGS_06,
                                     ARGS_07)&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(BSLS_COMPILERFEATURES_FORWARD_REF(FUNC));
    function&amp; operator=(nullptr_t);



    RET operator()(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07) const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
class function&lt;RET(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07,
                   ARGS_08)&gt; :
        public Function_ArgTypes&lt;RET(ARGS_01,
                                     ARGS_02,
                                     ARGS_03,
                                     ARGS_04,
                                     ARGS_05,
                                     ARGS_06,
                                     ARGS_07,
                                     ARGS_08)&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(BSLS_COMPILERFEATURES_FORWARD_REF(FUNC));
    function&amp; operator=(nullptr_t);



    RET operator()(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07,
                   ARGS_08) const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
class function&lt;RET(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07,
                   ARGS_08,
                   ARGS_09)&gt; :
        public Function_ArgTypes&lt;RET(ARGS_01,
                                     ARGS_02,
                                     ARGS_03,
                                     ARGS_04,
                                     ARGS_05,
                                     ARGS_06,
                                     ARGS_07,
                                     ARGS_08,
                                     ARGS_09)&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(BSLS_COMPILERFEATURES_FORWARD_REF(FUNC));
    function&amp; operator=(nullptr_t);



    RET operator()(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07,
                   ARGS_08,
                   ARGS_09) const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
class function&lt;RET(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07,
                   ARGS_08,
                   ARGS_09,
                   ARGS_10)&gt; :
        public Function_ArgTypes&lt;RET(ARGS_01,
                                     ARGS_02,
                                     ARGS_03,
                                     ARGS_04,
                                     ARGS_05,
                                     ARGS_06,
                                     ARGS_07,
                                     ARGS_08,
                                     ARGS_09,
                                     ARGS_10)&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(BSLS_COMPILERFEATURES_FORWARD_REF(FUNC));
    function&amp; operator=(nullptr_t);



    RET operator()(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07,
                   ARGS_08,
                   ARGS_09,
                   ARGS_10) const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
class function&lt;RET(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07,
                   ARGS_08,
                   ARGS_09,
                   ARGS_10,
                   ARGS_11)&gt; :
        public Function_ArgTypes&lt;RET(ARGS_01,
                                     ARGS_02,
                                     ARGS_03,
                                     ARGS_04,
                                     ARGS_05,
                                     ARGS_06,
                                     ARGS_07,
                                     ARGS_08,
                                     ARGS_09,
                                     ARGS_10,
                                     ARGS_11)&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(BSLS_COMPILERFEATURES_FORWARD_REF(FUNC));
    function&amp; operator=(nullptr_t);



    RET operator()(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07,
                   ARGS_08,
                   ARGS_09,
                   ARGS_10,
                   ARGS_11) const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
class function&lt;RET(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07,
                   ARGS_08,
                   ARGS_09,
                   ARGS_10,
                   ARGS_11,
                   ARGS_12)&gt; :
        public Function_ArgTypes&lt;RET(ARGS_01,
                                     ARGS_02,
                                     ARGS_03,
                                     ARGS_04,
                                     ARGS_05,
                                     ARGS_06,
                                     ARGS_07,
                                     ARGS_08,
                                     ARGS_09,
                                     ARGS_10,
                                     ARGS_11,
                                     ARGS_12)&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(BSLS_COMPILERFEATURES_FORWARD_REF(FUNC));
    function&amp; operator=(nullptr_t);



    RET operator()(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07,
                   ARGS_08,
                   ARGS_09,
                   ARGS_10,
                   ARGS_11,
                   ARGS_12) const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
class function&lt;RET(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07,
                   ARGS_08,
                   ARGS_09,
                   ARGS_10,
                   ARGS_11,
                   ARGS_12,
                   ARGS_13)&gt; :
        public Function_ArgTypes&lt;RET(ARGS_01,
                                     ARGS_02,
                                     ARGS_03,
                                     ARGS_04,
                                     ARGS_05,
                                     ARGS_06,
                                     ARGS_07,
                                     ARGS_08,
                                     ARGS_09,
                                     ARGS_10,
                                     ARGS_11,
                                     ARGS_12,
                                     ARGS_13)&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(BSLS_COMPILERFEATURES_FORWARD_REF(FUNC));
    function&amp; operator=(nullptr_t);



    RET operator()(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07,
                   ARGS_08,
                   ARGS_09,
                   ARGS_10,
                   ARGS_11,
                   ARGS_12,
                   ARGS_13) const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
class function&lt;RET(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07,
                   ARGS_08,
                   ARGS_09,
                   ARGS_10,
                   ARGS_11,
                   ARGS_12,
                   ARGS_13,
                   ARGS_14)&gt; :
        public Function_ArgTypes&lt;RET(ARGS_01,
                                     ARGS_02,
                                     ARGS_03,
                                     ARGS_04,
                                     ARGS_05,
                                     ARGS_06,
                                     ARGS_07,
                                     ARGS_08,
                                     ARGS_09,
                                     ARGS_10,
                                     ARGS_11,
                                     ARGS_12,
                                     ARGS_13,
                                     ARGS_14)&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_14&gt;::Type args_14);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_14&gt;::Type);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_14&gt;::Type);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_14&gt;::Type);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS_14&gt;::Type);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(BSLS_COMPILERFEATURES_FORWARD_REF(FUNC));
    function&amp; operator=(nullptr_t);



    RET operator()(ARGS_01,
                   ARGS_02,
                   ARGS_03,
                   ARGS_04,
                   ARGS_05,
                   ARGS_06,
                   ARGS_07,
                   ARGS_08,
                   ARGS_09,
                   ARGS_10,
                   ARGS_11,
                   ARGS_12,
                   ARGS_13,
                   ARGS_14) const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};


template &lt;class RET&gt;
bool operator==(const function&lt;RET()&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01&gt;
bool operator==(const function&lt;RET(ARGS_01)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
bool operator==(const function&lt;RET(ARGS_01,
                                   ARGS_02)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
bool operator==(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
bool operator==(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
bool operator==(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
bool operator==(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
bool operator==(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
bool operator==(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07,
                                   ARGS_08)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
bool operator==(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07,
                                   ARGS_08,
                                   ARGS_09)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
bool operator==(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07,
                                   ARGS_08,
                                   ARGS_09,
                                   ARGS_10)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
bool operator==(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07,
                                   ARGS_08,
                                   ARGS_09,
                                   ARGS_10,
                                   ARGS_11)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
bool operator==(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07,
                                   ARGS_08,
                                   ARGS_09,
                                   ARGS_10,
                                   ARGS_11,
                                   ARGS_12)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
bool operator==(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07,
                                   ARGS_08,
                                   ARGS_09,
                                   ARGS_10,
                                   ARGS_11,
                                   ARGS_12,
                                   ARGS_13)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
bool operator==(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07,
                                   ARGS_08,
                                   ARGS_09,
                                   ARGS_10,
                                   ARGS_11,
                                   ARGS_12,
                                   ARGS_13,
                                   ARGS_14)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;


template &lt;class RET&gt;
bool operator==(nullptr_t, const function&lt;RET()&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS_01)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09,
                                              ARGS_10)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09,
                                              ARGS_10,
                                              ARGS_11)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09,
                                              ARGS_10,
                                              ARGS_11,
                                              ARGS_12)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09,
                                              ARGS_10,
                                              ARGS_11,
                                              ARGS_12,
                                              ARGS_13)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09,
                                              ARGS_10,
                                              ARGS_11,
                                              ARGS_12,
                                              ARGS_13,
                                              ARGS_14)&gt;&amp;) BSLS_NOTHROW_SPEC;


template &lt;class RET&gt;
bool operator!=(const function&lt;RET()&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01&gt;
bool operator!=(const function&lt;RET(ARGS_01)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
bool operator!=(const function&lt;RET(ARGS_01,
                                   ARGS_02)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
bool operator!=(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
bool operator!=(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
bool operator!=(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
bool operator!=(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
bool operator!=(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
bool operator!=(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07,
                                   ARGS_08)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
bool operator!=(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07,
                                   ARGS_08,
                                   ARGS_09)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
bool operator!=(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07,
                                   ARGS_08,
                                   ARGS_09,
                                   ARGS_10)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
bool operator!=(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07,
                                   ARGS_08,
                                   ARGS_09,
                                   ARGS_10,
                                   ARGS_11)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
bool operator!=(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07,
                                   ARGS_08,
                                   ARGS_09,
                                   ARGS_10,
                                   ARGS_11,
                                   ARGS_12)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
bool operator!=(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07,
                                   ARGS_08,
                                   ARGS_09,
                                   ARGS_10,
                                   ARGS_11,
                                   ARGS_12,
                                   ARGS_13)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
bool operator!=(const function&lt;RET(ARGS_01,
                                   ARGS_02,
                                   ARGS_03,
                                   ARGS_04,
                                   ARGS_05,
                                   ARGS_06,
                                   ARGS_07,
                                   ARGS_08,
                                   ARGS_09,
                                   ARGS_10,
                                   ARGS_11,
                                   ARGS_12,
                                   ARGS_13,
                                   ARGS_14)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;


template &lt;class RET&gt;
bool operator!=(nullptr_t, const function&lt;RET()&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS_01)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09,
                                              ARGS_10)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09,
                                              ARGS_10,
                                              ARGS_11)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09,
                                              ARGS_10,
                                              ARGS_11,
                                              ARGS_12)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09,
                                              ARGS_10,
                                              ARGS_11,
                                              ARGS_12,
                                              ARGS_13)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS_01,
                                              ARGS_02,
                                              ARGS_03,
                                              ARGS_04,
                                              ARGS_05,
                                              ARGS_06,
                                              ARGS_07,
                                              ARGS_08,
                                              ARGS_09,
                                              ARGS_10,
                                              ARGS_11,
                                              ARGS_12,
                                              ARGS_13,
                                              ARGS_14)&gt;&amp;) BSLS_NOTHROW_SPEC;


template &lt;class RET&gt;
void swap(function&lt;RET()&gt;&amp; a, function&lt;RET()&gt;&amp; b);

template &lt;class RET, class ARGS_01&gt;
void swap(function&lt;RET(ARGS_01)&gt;&amp; a, function&lt;RET(ARGS_01)&gt;&amp; b);

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
void swap(function&lt;RET(ARGS_01,
                       ARGS_02)&gt;&amp; a, function&lt;RET(ARGS_01,
                                                  ARGS_02)&gt;&amp; b);

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
void swap(function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03)&gt;&amp; a, function&lt;RET(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03)&gt;&amp; b);

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
void swap(function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04)&gt;&amp; a, function&lt;RET(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04)&gt;&amp; b);

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
void swap(function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05)&gt;&amp; a, function&lt;RET(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05)&gt;&amp; b);

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
void swap(function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06)&gt;&amp; a, function&lt;RET(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06)&gt;&amp; b);

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
void swap(function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07)&gt;&amp; a, function&lt;RET(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07)&gt;&amp; b);

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
void swap(function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07,
                       ARGS_08)&gt;&amp; a, function&lt;RET(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08)&gt;&amp; b);

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
void swap(function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07,
                       ARGS_08,
                       ARGS_09)&gt;&amp; a, function&lt;RET(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09)&gt;&amp; b);

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
void swap(function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07,
                       ARGS_08,
                       ARGS_09,
                       ARGS_10)&gt;&amp; a, function&lt;RET(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10)&gt;&amp; b);

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
void swap(function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07,
                       ARGS_08,
                       ARGS_09,
                       ARGS_10,
                       ARGS_11)&gt;&amp; a, function&lt;RET(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11)&gt;&amp; b);

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
void swap(function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07,
                       ARGS_08,
                       ARGS_09,
                       ARGS_10,
                       ARGS_11,
                       ARGS_12)&gt;&amp; a, function&lt;RET(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11,
                                                  ARGS_12)&gt;&amp; b);

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
void swap(function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07,
                       ARGS_08,
                       ARGS_09,
                       ARGS_10,
                       ARGS_11,
                       ARGS_12,
                       ARGS_13)&gt;&amp; a, function&lt;RET(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11,
                                                  ARGS_12,
                                                  ARGS_13)&gt;&amp; b);

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
void swap(function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07,
                       ARGS_08,
                       ARGS_09,
                       ARGS_10,
                       ARGS_11,
                       ARGS_12,
                       ARGS_13,
                       ARGS_14)&gt;&amp; a, function&lt;RET(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11,
                                                  ARGS_12,
                                                  ARGS_13,
                                                  ARGS_14)&gt;&amp; b);

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.


template &lt;class RET, class... ARGS&gt;
class function&lt;RET(ARGS...)&gt; :
        public Function_ArgTypes&lt;RET(ARGS...)&gt;,
        public Function_Rep
{

    typedef RET Invoker(const Function_Rep* rep,
              typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args);

    void setInvoker(Invoker *p);

    Invoker *invoker() const;

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                                   BloombergLP::bslmf::SelectTraitCase&lt;
                                       BloombergLP::bslmf::IsFunctionPointer&gt;)
    {
        if (f) {
            return &amp;functionPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f,
                              BloombergLP::bslmf::SelectTraitCase&lt;
                                  BloombergLP::bslmf::IsMemberFunctionPointer&gt;)
    {
        if (f) {
            return &amp;memFuncPtrInvoker&lt;FUNC&gt;;
        }
        else {
#if BSLS_PLATFORM_CMP_GNU              &amp;&amp;                                     \
    BSLS_PLATFORM_CMP_VERSION &lt;= 40305 &amp;&amp;                                     \
    BSLS_PLATFORM_CPU_64_BIT           &amp;&amp;                                     \
    __GNUC_GNU_INLINE__
            Function_Rep::nothing(f);
#endif
            return NULL;
        }
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                       BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;)
    {
        return &amp;inplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp;,
                                   BloombergLP::bslmf::SelectTraitCase&lt;&gt;)
    {
        return &amp;outofplaceFunctorInvoker&lt;FUNC&gt;;
    }

    template &lt;class FUNC&gt;
    static Invoker *invokerForFunc(const FUNC&amp; f)
    {
        typedef Function_SmallObjectOptimization Soo;

        typedef typename
            Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UwFuncType;

        typedef typename
            BloombergLP::bslmf::SelectTrait&lt;
                UwFuncType,
                BloombergLP::bslmf::IsFunctionPointer,
                BloombergLP::bslmf::IsMemberFunctionPointer,
                Soo::IsInplaceFunc
            &gt;::Type UwFuncSelection;

        const std::size_t kSOOSIZE       = Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
        const std::size_t kUNWRAPPED_SOOSIZE
                                         = Soo::SooFuncSize&lt;UwFuncType&gt;::VALUE;

        typedef typename
            bsl::conditional&lt;kSOOSIZE != kUNWRAPPED_SOOSIZE,
            BloombergLP::bslmf::SelectTraitCase&lt;Soo::IsInplaceFunc&gt;,
            UwFuncSelection&gt;::type FuncSelection;

        return invokerForFunc(Function_NothrowWrapperUtil&lt;FUNC&gt;::unwrap(f),
                FuncSelection());
    }

    template &lt;class FUNC&gt;
    static RET functionPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type...);

    template &lt;class FUNC&gt;
    static RET memFuncPtrInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type...);

    template &lt;class FUNC&gt;
    static RET inplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type...);

    template &lt;class FUNC&gt;
    static RET outofplaceFunctorInvoker(const Function_Rep *rep,
                   typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type...);

#ifndef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

    typedef BloombergLP::bsls::UnspecifiedBool&lt;function&gt;  UnspecifiedBoolUtil;
    typedef typename UnspecifiedBoolUtil::BoolType        UnspecifiedBool;

    bool operator==(const function&amp;) const;
    bool operator!=(const function&amp;) const;
#endif

  public:
    typedef RET result_type;

    function() BSLS_NOTHROW_SPEC;
    function(nullptr_t) BSLS_NOTHROW_SPEC;
    function(const function&amp; other);
    template&lt;class FUNC&gt; function(FUNC func);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc);
    template&lt;class ALLOC&gt; function(allocator_arg_t, const ALLOC&amp; alloc,
                                   nullptr_t);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp;    alloc,
                                   const function&amp; other);
    template&lt;class FUNC, class ALLOC&gt; function(allocator_arg_t,
                                               const ALLOC&amp; alloc,
                                               FUNC         func);

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function(function&amp;&amp; other);
    template&lt;class ALLOC&gt; function(allocator_arg_t,
                                   const ALLOC&amp; alloc,
                                   function&amp;&amp;   other);
#endif

    ~function();

    function&amp; operator=(const function&amp;);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
    function&amp; operator=(function&amp;);
    function&amp; operator=(function&amp;&amp;);
#endif
    template&lt;class FUNC&gt;
    function&amp; operator=(FUNC&amp;&amp;);
    function&amp; operator=(nullptr_t);



    RET operator()(ARGS...) const;

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
    explicit
    operator bool() const BSLS_NOTHROW_SPEC;
#else
    operator UnspecifiedBool() const BSLS_NOTHROW_SPEC
    {
        return UnspecifiedBoolUtil::makeValue(invoker());
    }
#endif

};

template &lt;class RET, class... ARGS&gt;
bool operator==(const function&lt;RET(ARGS...)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class... ARGS&gt;
bool operator==(nullptr_t, const function&lt;RET(ARGS...)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class... ARGS&gt;
bool operator!=(const function&lt;RET(ARGS...)&gt;&amp;, nullptr_t) BSLS_NOTHROW_SPEC;

template &lt;class RET, class... ARGS&gt;
bool operator!=(nullptr_t, const function&lt;RET(ARGS...)&gt;&amp;) BSLS_NOTHROW_SPEC;

template &lt;class RET, class... ARGS&gt;
void swap(function&lt;RET(ARGS...)&gt;&amp; a, function&lt;RET(ARGS...)&gt;&amp; b);

// }}} END GENERATED CODE
#endif

// ============================================================================
//                TEMPLATE AND INLINE FUNCTION IMPLEMENTATIONS
// ============================================================================

                        // ---------------------------------
                        // struct template Function_ArgTypes
                        // ---------------------------------

template &lt;class FUNC&gt;
struct Function_ArgTypes {
    // This is a component-private struct template.  Do not use.
    //
    // The standard requires that &#39;function&#39; define certain typedefs for
    // compatibility with one- and two-argument legacy functor adaptors.  This
    // template provides the following nested typedefs:
    //..
    //  argument_type        -- Only if FUNC takes exactly one argument
    //  first_argument_type  -- Only if FUNC takes exactly two arguments
    //  second_argument_type -- Only if FUNC takes exactly two arguments
    //..

    // No typedefs for the unspecialized case
};

template &lt;class R, class ARG&gt;
struct Function_ArgTypes&lt;R(ARG)&gt; {
    // Specialization for functions that take exactly one argument.

    typedef ARG argument_type;
};

template &lt;class R, class ARG1, class ARG2&gt;
struct Function_ArgTypes&lt;R(ARG1, ARG2)&gt; {
    // Specialization for functions that take exactly two arguments.

    typedef ARG1 first_argument_type;
    typedef ARG2 second_argument_type;
};

                        // -------------------------------------------
                        // struct template Function_NothrowWrapperUtil
                        // -------------------------------------------

template &lt;class FUNC&gt;
struct Function_NothrowWrapperUtil {
    // This is a component-private struct template.  Do not use.
    //
    // Namesapace for &#39;Function_NothrowWrapper&#39; traits and utilities.

    typedef FUNC UnwrappedType;

    enum { IS_WRAPPED = false };
         // True for specializations of &#39;Function_NothrowWrapper&#39;, else false.

    static FUNC&amp;       unwrap(typename bsl::remove_cv&lt;FUNC&gt;::type&amp;       f)
        { return f; }
    static FUNC const&amp; unwrap(typename bsl::remove_cv&lt;FUNC&gt;::type const&amp; f)
        { return f; }
};

template &lt;class FUNC&gt;
struct  Function_NothrowWrapperUtil&lt;Function_NothrowWrapper&lt;FUNC&gt; &gt; {
    // This is a component-private struct template.  Do not use.
    //
    // Namesapace for &#39;Function_NothrowWrapper&#39; traits and utilities,
    // specialized for instantiations of &#39;Function_NothrowWrapper&lt;FUNC&gt;&#39;.

    typedef Function_NothrowWrapper&lt;FUNC&gt; WrappedType;
    typedef FUNC                          UnwrappedType;

    enum { IS_WRAPPED = true };
         // True for specializations of &#39;Function_NothrowWrapper&#39;, else false.

    static FUNC&amp;       unwrap(WrappedType&amp;       f) { return f.unwrap(); }
    static FUNC const&amp; unwrap(WrappedType const&amp; f) { return f.unwrap(); }
};

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES

                    // -------------------------------------
                    // class template Function_MemFuncInvoke
                    // -------------------------------------

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE,
          class RET, class... ARGS&gt;
struct Function_MemFuncInvokeImp {
    // This is a component-private class template.  Do not use.
    //

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS = sizeof...(ARGS) };

    static
    RET invoke_imp(true_type /* DirectInvoke */, FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args) {
        // If &#39;OBJ_ARG_TYPE&#39; is a non-const rvalue, then it will have been
        // forwarded as a const reference, instead.  In order to call a
        // potentially non-const member function on it, we must cast the
        // reference back to the original type.  The &#39;const_cast&#39;, below, will
        // have no effect unless &#39;OBJ_ARG_TYPE&#39; is a non-const rvalue.
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args...);
    }

    static
    RET invoke_imp(false_type /* DirectInvoke */, FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args) {
        // If &#39;OBJ_ARG_TYPE&#39; is a non-const rvalue, then it will have been
        // forwarded as a const reference, instead.  In order to call a
        // potentially non-const member function on it, we must cast the
        // reference back to a the original type.  The &#39;const_cast&#39;, below,
        // will have no effect unless &#39;OBJ_ARG_TYPE&#39; is a non-const rvalue.
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args...);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args)
        { return invoke_imp(DirectInvoke(), f, obj, args...); }

};

template &lt;class RET, class OBJ_TYPE, class... ARGS, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS...), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS...), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS...&gt;
{
    // This is a component-private struct template.  Do not use.
    //
};

template &lt;class RET, class OBJ_TYPE, class... ARGS, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS...) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS...) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS...&gt;
{
    // This is a component-private struct template.  Do not use.
    //
};

template &lt;class RET, class OBJ_TYPE, class... ARGS, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS...) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS...) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS...&gt;
{
    // This is a component-private struct template.  Do not use.
    //
};

template &lt;class RET, class OBJ_TYPE, class... ARGS, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS...) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS...) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS...&gt;
{
    // This is a component-private struct template.  Do not use.
    //
};

#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Generator command line: sim_cpp11_features.pl bslstl_function.h


template &lt;class FUNC,
          class OBJ_TYPE,
          class OBJ_ARG_TYPE,
          class RET,
          class ARGS_0 = BSLS_COMPILERFEATURES_NILT,
          class ARGS_1 = BSLS_COMPILERFEATURES_NILT,
          class ARGS_2 = BSLS_COMPILERFEATURES_NILT,
          class ARGS_3 = BSLS_COMPILERFEATURES_NILT,
          class ARGS_4 = BSLS_COMPILERFEATURES_NILT,
          class ARGS_5 = BSLS_COMPILERFEATURES_NILT,
          class ARGS_6 = BSLS_COMPILERFEATURES_NILT,
          class ARGS_7 = BSLS_COMPILERFEATURES_NILT,
          class ARGS_8 = BSLS_COMPILERFEATURES_NILT,
          class ARGS_9 = BSLS_COMPILERFEATURES_NILT,
          class ARGS_10 = BSLS_COMPILERFEATURES_NILT,
          class ARGS_11 = BSLS_COMPILERFEATURES_NILT,
          class ARGS_12 = BSLS_COMPILERFEATURES_NILT,
          class ARGS_13 = BSLS_COMPILERFEATURES_NILT,
          class = BSLS_COMPILERFEATURES_NILT&gt;
struct Function_MemFuncInvokeImp;

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE, class RET&gt;
struct Function_MemFuncInvokeImp&lt;FUNC, OBJ_TYPE, OBJ_ARG_TYPE, RET&gt; {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS =  0u };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)();
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)();
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj)
        { return invoke_imp(DirectInvoke(), f, obj); }

};

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE, class RET,
          class ARGS_01&gt;
struct Function_MemFuncInvokeImp&lt;FUNC, OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01&gt; {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS =  1u };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args_01);
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args_01);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01)
        { return invoke_imp(DirectInvoke(), f, obj, args_01); }

};

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE, class RET,
          class ARGS_01,
          class ARGS_02&gt;
struct Function_MemFuncInvokeImp&lt;FUNC, OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                    ARGS_02&gt; {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS =  2u };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args_01,
                                           args_02);
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args_01,
                                              args_02);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02)
        { return invoke_imp(DirectInvoke(), f, obj, args_01,
                                                    args_02); }

};

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE, class RET,
          class ARGS_01,
          class ARGS_02,
          class ARGS_03&gt;
struct Function_MemFuncInvokeImp&lt;FUNC, OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                    ARGS_02,
                                                                    ARGS_03&gt; {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS =  3u };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args_01,
                                           args_02,
                                           args_03);
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args_01,
                                              args_02,
                                              args_03);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03)
        { return invoke_imp(DirectInvoke(), f, obj, args_01,
                                                    args_02,
                                                    args_03); }

};

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE, class RET,
          class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04&gt;
struct Function_MemFuncInvokeImp&lt;FUNC, OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                    ARGS_02,
                                                                    ARGS_03,
                                                                    ARGS_04&gt; {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS =  4u };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args_01,
                                           args_02,
                                           args_03,
                                           args_04);
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args_01,
                                              args_02,
                                              args_03,
                                              args_04);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04)
        { return invoke_imp(DirectInvoke(), f, obj, args_01,
                                                    args_02,
                                                    args_03,
                                                    args_04); }

};

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE, class RET,
          class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05&gt;
struct Function_MemFuncInvokeImp&lt;FUNC, OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                    ARGS_02,
                                                                    ARGS_03,
                                                                    ARGS_04,
                                                                    ARGS_05&gt; {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS =  5u };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args_01,
                                           args_02,
                                           args_03,
                                           args_04,
                                           args_05);
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args_01,
                                              args_02,
                                              args_03,
                                              args_04,
                                              args_05);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05)
        { return invoke_imp(DirectInvoke(), f, obj, args_01,
                                                    args_02,
                                                    args_03,
                                                    args_04,
                                                    args_05); }

};

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE, class RET,
          class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06&gt;
struct Function_MemFuncInvokeImp&lt;FUNC, OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                    ARGS_02,
                                                                    ARGS_03,
                                                                    ARGS_04,
                                                                    ARGS_05,
                                                                    ARGS_06&gt; {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS =  6u };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args_01,
                                           args_02,
                                           args_03,
                                           args_04,
                                           args_05,
                                           args_06);
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args_01,
                                              args_02,
                                              args_03,
                                              args_04,
                                              args_05,
                                              args_06);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06)
        { return invoke_imp(DirectInvoke(), f, obj, args_01,
                                                    args_02,
                                                    args_03,
                                                    args_04,
                                                    args_05,
                                                    args_06); }

};

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE, class RET,
          class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07&gt;
struct Function_MemFuncInvokeImp&lt;FUNC, OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                    ARGS_02,
                                                                    ARGS_03,
                                                                    ARGS_04,
                                                                    ARGS_05,
                                                                    ARGS_06,
                                                                    ARGS_07&gt; {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS =  7u };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args_01,
                                           args_02,
                                           args_03,
                                           args_04,
                                           args_05,
                                           args_06,
                                           args_07);
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args_01,
                                              args_02,
                                              args_03,
                                              args_04,
                                              args_05,
                                              args_06,
                                              args_07);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07)
        { return invoke_imp(DirectInvoke(), f, obj, args_01,
                                                    args_02,
                                                    args_03,
                                                    args_04,
                                                    args_05,
                                                    args_06,
                                                    args_07); }

};

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE, class RET,
          class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08&gt;
struct Function_MemFuncInvokeImp&lt;FUNC, OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                    ARGS_02,
                                                                    ARGS_03,
                                                                    ARGS_04,
                                                                    ARGS_05,
                                                                    ARGS_06,
                                                                    ARGS_07,
                                                                    ARGS_08&gt; {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS =  8u };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args_01,
                                           args_02,
                                           args_03,
                                           args_04,
                                           args_05,
                                           args_06,
                                           args_07,
                                           args_08);
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args_01,
                                              args_02,
                                              args_03,
                                              args_04,
                                              args_05,
                                              args_06,
                                              args_07,
                                              args_08);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08)
        { return invoke_imp(DirectInvoke(), f, obj, args_01,
                                                    args_02,
                                                    args_03,
                                                    args_04,
                                                    args_05,
                                                    args_06,
                                                    args_07,
                                                    args_08); }

};

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE, class RET,
          class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09&gt;
struct Function_MemFuncInvokeImp&lt;FUNC, OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                    ARGS_02,
                                                                    ARGS_03,
                                                                    ARGS_04,
                                                                    ARGS_05,
                                                                    ARGS_06,
                                                                    ARGS_07,
                                                                    ARGS_08,
                                                                    ARGS_09&gt; {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS =  9u };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args_01,
                                           args_02,
                                           args_03,
                                           args_04,
                                           args_05,
                                           args_06,
                                           args_07,
                                           args_08,
                                           args_09);
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args_01,
                                              args_02,
                                              args_03,
                                              args_04,
                                              args_05,
                                              args_06,
                                              args_07,
                                              args_08,
                                              args_09);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09)
        { return invoke_imp(DirectInvoke(), f, obj, args_01,
                                                    args_02,
                                                    args_03,
                                                    args_04,
                                                    args_05,
                                                    args_06,
                                                    args_07,
                                                    args_08,
                                                    args_09); }

};

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE, class RET,
          class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09,
          class ARGS_10&gt;
struct Function_MemFuncInvokeImp&lt;FUNC, OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                    ARGS_02,
                                                                    ARGS_03,
                                                                    ARGS_04,
                                                                    ARGS_05,
                                                                    ARGS_06,
                                                                    ARGS_07,
                                                                    ARGS_08,
                                                                    ARGS_09,
                                                                    ARGS_10&gt; {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS = 10u };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args_01,
                                           args_02,
                                           args_03,
                                           args_04,
                                           args_05,
                                           args_06,
                                           args_07,
                                           args_08,
                                           args_09,
                                           args_10);
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args_01,
                                              args_02,
                                              args_03,
                                              args_04,
                                              args_05,
                                              args_06,
                                              args_07,
                                              args_08,
                                              args_09,
                                              args_10);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10)
        { return invoke_imp(DirectInvoke(), f, obj, args_01,
                                                    args_02,
                                                    args_03,
                                                    args_04,
                                                    args_05,
                                                    args_06,
                                                    args_07,
                                                    args_08,
                                                    args_09,
                                                    args_10); }

};

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE, class RET,
          class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09,
          class ARGS_10,
          class ARGS_11&gt;
struct Function_MemFuncInvokeImp&lt;FUNC, OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                    ARGS_02,
                                                                    ARGS_03,
                                                                    ARGS_04,
                                                                    ARGS_05,
                                                                    ARGS_06,
                                                                    ARGS_07,
                                                                    ARGS_08,
                                                                    ARGS_09,
                                                                    ARGS_10,
                                                                    ARGS_11&gt; {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS = 11u };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args_01,
                                           args_02,
                                           args_03,
                                           args_04,
                                           args_05,
                                           args_06,
                                           args_07,
                                           args_08,
                                           args_09,
                                           args_10,
                                           args_11);
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args_01,
                                              args_02,
                                              args_03,
                                              args_04,
                                              args_05,
                                              args_06,
                                              args_07,
                                              args_08,
                                              args_09,
                                              args_10,
                                              args_11);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11)
        { return invoke_imp(DirectInvoke(), f, obj, args_01,
                                                    args_02,
                                                    args_03,
                                                    args_04,
                                                    args_05,
                                                    args_06,
                                                    args_07,
                                                    args_08,
                                                    args_09,
                                                    args_10,
                                                    args_11); }

};

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE, class RET,
          class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09,
          class ARGS_10,
          class ARGS_11,
          class ARGS_12&gt;
struct Function_MemFuncInvokeImp&lt;FUNC, OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                    ARGS_02,
                                                                    ARGS_03,
                                                                    ARGS_04,
                                                                    ARGS_05,
                                                                    ARGS_06,
                                                                    ARGS_07,
                                                                    ARGS_08,
                                                                    ARGS_09,
                                                                    ARGS_10,
                                                                    ARGS_11,
                                                                    ARGS_12&gt; {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS = 12u };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args_01,
                                           args_02,
                                           args_03,
                                           args_04,
                                           args_05,
                                           args_06,
                                           args_07,
                                           args_08,
                                           args_09,
                                           args_10,
                                           args_11,
                                           args_12);
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args_01,
                                              args_02,
                                              args_03,
                                              args_04,
                                              args_05,
                                              args_06,
                                              args_07,
                                              args_08,
                                              args_09,
                                              args_10,
                                              args_11,
                                              args_12);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12)
        { return invoke_imp(DirectInvoke(), f, obj, args_01,
                                                    args_02,
                                                    args_03,
                                                    args_04,
                                                    args_05,
                                                    args_06,
                                                    args_07,
                                                    args_08,
                                                    args_09,
                                                    args_10,
                                                    args_11,
                                                    args_12); }

};

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE, class RET,
          class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09,
          class ARGS_10,
          class ARGS_11,
          class ARGS_12,
          class ARGS_13&gt;
struct Function_MemFuncInvokeImp&lt;FUNC, OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                    ARGS_02,
                                                                    ARGS_03,
                                                                    ARGS_04,
                                                                    ARGS_05,
                                                                    ARGS_06,
                                                                    ARGS_07,
                                                                    ARGS_08,
                                                                    ARGS_09,
                                                                    ARGS_10,
                                                                    ARGS_11,
                                                                    ARGS_12,
                                                                    ARGS_13&gt; {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS = 13u };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args_01,
                                           args_02,
                                           args_03,
                                           args_04,
                                           args_05,
                                           args_06,
                                           args_07,
                                           args_08,
                                           args_09,
                                           args_10,
                                           args_11,
                                           args_12,
                                           args_13);
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args_01,
                                              args_02,
                                              args_03,
                                              args_04,
                                              args_05,
                                              args_06,
                                              args_07,
                                              args_08,
                                              args_09,
                                              args_10,
                                              args_11,
                                              args_12,
                                              args_13);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13)
        { return invoke_imp(DirectInvoke(), f, obj, args_01,
                                                    args_02,
                                                    args_03,
                                                    args_04,
                                                    args_05,
                                                    args_06,
                                                    args_07,
                                                    args_08,
                                                    args_09,
                                                    args_10,
                                                    args_11,
                                                    args_12,
                                                    args_13); }

};

template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE, class RET,
          class ARGS_01,
          class ARGS_02,
          class ARGS_03,
          class ARGS_04,
          class ARGS_05,
          class ARGS_06,
          class ARGS_07,
          class ARGS_08,
          class ARGS_09,
          class ARGS_10,
          class ARGS_11,
          class ARGS_12,
          class ARGS_13,
          class ARGS_14&gt;
struct Function_MemFuncInvokeImp&lt;FUNC, OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                    ARGS_02,
                                                                    ARGS_03,
                                                                    ARGS_04,
                                                                    ARGS_05,
                                                                    ARGS_06,
                                                                    ARGS_07,
                                                                    ARGS_08,
                                                                    ARGS_09,
                                                                    ARGS_10,
                                                                    ARGS_11,
                                                                    ARGS_12,
                                                                    ARGS_13,
                                                                    ARGS_14&gt; {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS = 14u };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_14&gt;::Type args_14) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args_01,
                                           args_02,
                                           args_03,
                                           args_04,
                                           args_05,
                                           args_06,
                                           args_07,
                                           args_08,
                                           args_09,
                                           args_10,
                                           args_11,
                                           args_12,
                                           args_13,
                                           args_14);
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13,
          typename BloombergLP::bslmf::ForwardingType&lt;ARGS_14&gt;::Type args_14) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args_01,
                                              args_02,
                                              args_03,
                                              args_04,
                                              args_05,
                                              args_06,
                                              args_07,
                                              args_08,
                                              args_09,
                                              args_10,
                                              args_11,
                                              args_12,
                                              args_13,
                                              args_14);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS_14&gt;::Type args_14)
        { return invoke_imp(DirectInvoke(), f, obj, args_01,
                                                    args_02,
                                                    args_03,
                                                    args_04,
                                                    args_05,
                                                    args_06,
                                                    args_07,
                                                    args_08,
                                                    args_09,
                                                    args_10,
                                                    args_11,
                                                    args_12,
                                                    args_13,
                                                    args_14); }

};


template &lt;class RET, class OBJ_TYPE, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07,
                                                   ARGS_08&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07,
                                                   ARGS_08,
                                                   ARGS_09&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07,
                                                   ARGS_08,
                                                   ARGS_09,
                                                   ARGS_10&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07,
                                                   ARGS_08,
                                                   ARGS_09,
                                                   ARGS_10,
                                                   ARGS_11&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11,
                                     class ARGS_12, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11,
                                                ARGS_12), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11,
                                                  ARGS_12), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07,
                                                   ARGS_08,
                                                   ARGS_09,
                                                   ARGS_10,
                                                   ARGS_11,
                                                   ARGS_12&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11,
                                     class ARGS_12,
                                     class ARGS_13, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11,
                                                ARGS_12,
                                                ARGS_13), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11,
                                                  ARGS_12,
                                                  ARGS_13), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07,
                                                   ARGS_08,
                                                   ARGS_09,
                                                   ARGS_10,
                                                   ARGS_11,
                                                   ARGS_12,
                                                   ARGS_13&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11,
                                     class ARGS_12,
                                     class ARGS_13,
                                     class ARGS_14, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11,
                                                ARGS_12,
                                                ARGS_13,
                                                ARGS_14), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11,
                                                  ARGS_12,
                                                  ARGS_13,
                                                  ARGS_14), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07,
                                                   ARGS_08,
                                                   ARGS_09,
                                                   ARGS_10,
                                                   ARGS_11,
                                                   ARGS_12,
                                                   ARGS_13,
                                                   ARGS_14&gt;
{
};


template &lt;class RET, class OBJ_TYPE, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)() const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)() const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                   ARGS_02&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                   ARGS_02,
                                                                   ARGS_03&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                   ARGS_02,
                                                                   ARGS_03,
                                                                   ARGS_04&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                   ARGS_02,
                                                                   ARGS_03,
                                                                   ARGS_04,
                                                                   ARGS_05&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                   ARGS_02,
                                                                   ARGS_03,
                                                                   ARGS_04,
                                                                   ARGS_05,
                                                                   ARGS_06&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                   ARGS_02,
                                                                   ARGS_03,
                                                                   ARGS_04,
                                                                   ARGS_05,
                                                                   ARGS_06,
                                                                   ARGS_07&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                   ARGS_02,
                                                                   ARGS_03,
                                                                   ARGS_04,
                                                                   ARGS_05,
                                                                   ARGS_06,
                                                                   ARGS_07,
                                                                   ARGS_08&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                   ARGS_02,
                                                                   ARGS_03,
                                                                   ARGS_04,
                                                                   ARGS_05,
                                                                   ARGS_06,
                                                                   ARGS_07,
                                                                   ARGS_08,
                                                                   ARGS_09&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                   ARGS_02,
                                                                   ARGS_03,
                                                                   ARGS_04,
                                                                   ARGS_05,
                                                                   ARGS_06,
                                                                   ARGS_07,
                                                                   ARGS_08,
                                                                   ARGS_09,
                                                                   ARGS_10&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                   ARGS_02,
                                                                   ARGS_03,
                                                                   ARGS_04,
                                                                   ARGS_05,
                                                                   ARGS_06,
                                                                   ARGS_07,
                                                                   ARGS_08,
                                                                   ARGS_09,
                                                                   ARGS_10,
                                                                   ARGS_11&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11,
                                     class ARGS_12, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11,
                                                ARGS_12) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11,
                                                  ARGS_12) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                   ARGS_02,
                                                                   ARGS_03,
                                                                   ARGS_04,
                                                                   ARGS_05,
                                                                   ARGS_06,
                                                                   ARGS_07,
                                                                   ARGS_08,
                                                                   ARGS_09,
                                                                   ARGS_10,
                                                                   ARGS_11,
                                                                   ARGS_12&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11,
                                     class ARGS_12,
                                     class ARGS_13, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11,
                                                ARGS_12,
                                                ARGS_13) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11,
                                                  ARGS_12,
                                                  ARGS_13) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                   ARGS_02,
                                                                   ARGS_03,
                                                                   ARGS_04,
                                                                   ARGS_05,
                                                                   ARGS_06,
                                                                   ARGS_07,
                                                                   ARGS_08,
                                                                   ARGS_09,
                                                                   ARGS_10,
                                                                   ARGS_11,
                                                                   ARGS_12,
                                                                   ARGS_13&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11,
                                     class ARGS_12,
                                     class ARGS_13,
                                     class ARGS_14, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11,
                                                ARGS_12,
                                                ARGS_13,
                                                ARGS_14) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11,
                                                  ARGS_12,
                                                  ARGS_13,
                                                  ARGS_14) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                   ARGS_02,
                                                                   ARGS_03,
                                                                   ARGS_04,
                                                                   ARGS_05,
                                                                   ARGS_06,
                                                                   ARGS_07,
                                                                   ARGS_08,
                                                                   ARGS_09,
                                                                   ARGS_10,
                                                                   ARGS_11,
                                                                   ARGS_12,
                                                                   ARGS_13,
                                                                   ARGS_14&gt;
{
};


template &lt;class RET, class OBJ_TYPE, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)() volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)() volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                      ARGS_02&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                      ARGS_02,
                                                                      ARGS_03&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                      ARGS_02,
                                                                      ARGS_03,
                                                                      ARGS_04&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                      ARGS_02,
                                                                      ARGS_03,
                                                                      ARGS_04,
                                                                      ARGS_05&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                      ARGS_02,
                                                                      ARGS_03,
                                                                      ARGS_04,
                                                                      ARGS_05,
                                                                      ARGS_06&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                      ARGS_02,
                                                                      ARGS_03,
                                                                      ARGS_04,
                                                                      ARGS_05,
                                                                      ARGS_06,
                                                                      ARGS_07&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                      ARGS_02,
                                                                      ARGS_03,
                                                                      ARGS_04,
                                                                      ARGS_05,
                                                                      ARGS_06,
                                                                      ARGS_07,
                                                                      ARGS_08&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                      ARGS_02,
                                                                      ARGS_03,
                                                                      ARGS_04,
                                                                      ARGS_05,
                                                                      ARGS_06,
                                                                      ARGS_07,
                                                                      ARGS_08,
                                                                      ARGS_09&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                      ARGS_02,
                                                                      ARGS_03,
                                                                      ARGS_04,
                                                                      ARGS_05,
                                                                      ARGS_06,
                                                                      ARGS_07,
                                                                      ARGS_08,
                                                                      ARGS_09,
                                                                      ARGS_10&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                      ARGS_02,
                                                                      ARGS_03,
                                                                      ARGS_04,
                                                                      ARGS_05,
                                                                      ARGS_06,
                                                                      ARGS_07,
                                                                      ARGS_08,
                                                                      ARGS_09,
                                                                      ARGS_10,
                                                                      ARGS_11&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11,
                                     class ARGS_12, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11,
                                                ARGS_12) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11,
                                                  ARGS_12) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                      ARGS_02,
                                                                      ARGS_03,
                                                                      ARGS_04,
                                                                      ARGS_05,
                                                                      ARGS_06,
                                                                      ARGS_07,
                                                                      ARGS_08,
                                                                      ARGS_09,
                                                                      ARGS_10,
                                                                      ARGS_11,
                                                                      ARGS_12&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11,
                                     class ARGS_12,
                                     class ARGS_13, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11,
                                                ARGS_12,
                                                ARGS_13) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11,
                                                  ARGS_12,
                                                  ARGS_13) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                      ARGS_02,
                                                                      ARGS_03,
                                                                      ARGS_04,
                                                                      ARGS_05,
                                                                      ARGS_06,
                                                                      ARGS_07,
                                                                      ARGS_08,
                                                                      ARGS_09,
                                                                      ARGS_10,
                                                                      ARGS_11,
                                                                      ARGS_12,
                                                                      ARGS_13&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11,
                                     class ARGS_12,
                                     class ARGS_13,
                                     class ARGS_14, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11,
                                                ARGS_12,
                                                ARGS_13,
                                                ARGS_14) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11,
                                                  ARGS_12,
                                                  ARGS_13,
                                                  ARGS_14) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS_01,
                                                                      ARGS_02,
                                                                      ARGS_03,
                                                                      ARGS_04,
                                                                      ARGS_05,
                                                                      ARGS_06,
                                                                      ARGS_07,
                                                                      ARGS_08,
                                                                      ARGS_09,
                                                                      ARGS_10,
                                                                      ARGS_11,
                                                                      ARGS_12,
                                                                      ARGS_13,
                                                                      ARGS_14&gt;
{
};


template &lt;class RET, class OBJ_TYPE, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)() const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)() const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07,
                                                   ARGS_08&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07,
                                                   ARGS_08,
                                                   ARGS_09&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07,
                                                   ARGS_08,
                                                   ARGS_09,
                                                   ARGS_10&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07,
                                                   ARGS_08,
                                                   ARGS_09,
                                                   ARGS_10,
                                                   ARGS_11&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11,
                                     class ARGS_12, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11,
                                                ARGS_12) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11,
                                                  ARGS_12) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07,
                                                   ARGS_08,
                                                   ARGS_09,
                                                   ARGS_10,
                                                   ARGS_11,
                                                   ARGS_12&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11,
                                     class ARGS_12,
                                     class ARGS_13, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11,
                                                ARGS_12,
                                                ARGS_13) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11,
                                                  ARGS_12,
                                                  ARGS_13) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07,
                                                   ARGS_08,
                                                   ARGS_09,
                                                   ARGS_10,
                                                   ARGS_11,
                                                   ARGS_12,
                                                   ARGS_13&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class ARGS_01,
                                     class ARGS_02,
                                     class ARGS_03,
                                     class ARGS_04,
                                     class ARGS_05,
                                     class ARGS_06,
                                     class ARGS_07,
                                     class ARGS_08,
                                     class ARGS_09,
                                     class ARGS_10,
                                     class ARGS_11,
                                     class ARGS_12,
                                     class ARGS_13,
                                     class ARGS_14, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                ARGS_02,
                                                ARGS_03,
                                                ARGS_04,
                                                ARGS_05,
                                                ARGS_06,
                                                ARGS_07,
                                                ARGS_08,
                                                ARGS_09,
                                                ARGS_10,
                                                ARGS_11,
                                                ARGS_12,
                                                ARGS_13,
                                                ARGS_14) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS_01,
                                                  ARGS_02,
                                                  ARGS_03,
                                                  ARGS_04,
                                                  ARGS_05,
                                                  ARGS_06,
                                                  ARGS_07,
                                                  ARGS_08,
                                                  ARGS_09,
                                                  ARGS_10,
                                                  ARGS_11,
                                                  ARGS_12,
                                                  ARGS_13,
                                                  ARGS_14) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS_01,
                                                   ARGS_02,
                                                   ARGS_03,
                                                   ARGS_04,
                                                   ARGS_05,
                                                   ARGS_06,
                                                   ARGS_07,
                                                   ARGS_08,
                                                   ARGS_09,
                                                   ARGS_10,
                                                   ARGS_11,
                                                   ARGS_12,
                                                   ARGS_13,
                                                   ARGS_14&gt;
{
};

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.


template &lt;class FUNC, class OBJ_TYPE, class OBJ_ARG_TYPE,
          class RET, class... ARGS&gt;
struct Function_MemFuncInvokeImp {

    typedef typename is_convertible&lt;
            typename remove_reference&lt;OBJ_ARG_TYPE&gt;::type*,
            OBJ_TYPE*
        &gt;::type DirectInvoke;

    enum { NUM_ARGS = sizeof...(ARGS) };

    static
    RET invoke_imp(true_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return (const_cast&lt;ObjTp&gt;(obj).*f)(args...);
    }

    static
    RET invoke_imp(false_type , FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args) {
        typedef typename bsl::add_lvalue_reference&lt;OBJ_ARG_TYPE&gt;::type ObjTp;
        return ((*const_cast&lt;ObjTp&gt;(obj)).*f)(args...);
    }

  public:
    static
    RET invoke(FUNC f,
           typename BloombergLP::bslmf::ForwardingType&lt;OBJ_ARG_TYPE&gt;::Type obj,
           typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args)
        { return invoke_imp(DirectInvoke(), f, obj, args...); }

};

template &lt;class RET, class OBJ_TYPE, class... ARGS, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS...), OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS...), OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS...&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class... ARGS, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS...) const, OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS...) const,
                                const OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS...&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class... ARGS, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS...) volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS...) volatile,
                                volatile OBJ_TYPE, OBJ_ARG_TYPE, RET, ARGS...&gt;
{
};

template &lt;class RET, class OBJ_TYPE, class... ARGS, class OBJ_ARG_TYPE&gt;
struct Function_MemFuncInvoke&lt;RET (OBJ_TYPE::*)(ARGS...) const volatile,
                              OBJ_ARG_TYPE&gt;
    : Function_MemFuncInvokeImp&lt;RET (OBJ_TYPE::*)(ARGS...) const volatile,
                                const volatile OBJ_TYPE,
                                OBJ_ARG_TYPE, RET, ARGS...&gt;
{
};

// }}} END GENERATED CODE
#endif

class Function_PairBufDesc {
    // This is a component-private struct template.  Do not use.
    //
    // Descriptor for a maximally-aligned memory buffer that can hold two
    // objects.  Given a pointer to a maximally-aligned memory buffer, it
    // provides sufficient information to access the first and second objects
    // stored within that memory buffer, as if the memory buffer were a pair
    // struct.  In order to generate a descriptor, we need only the size of
    // the two objects being stored, thus allowing a descriptor to be created
    // dynamically for objects whose types are not known until runtime.  Note
    // that no attempt is made to match the layout of a &#39;std::pair&#39; containing
    // the members of the same data types and, in practice, the layout will
    // often differ from &#39;std::pair&#39;.

    std::size_t d_totalSize;    // Total size of the buffer
    std::size_t d_secondOffset; // Offset within the buffer of the 2nd object

  public:
    // CREATORS
    Function_PairBufDesc(std::size_t t1Size, std::size_t t2Size);
        // Construct a descriptor for a maximally-aligned pair of objects with
        // the specified sizes &#39;t1Size&#39; and &#39;t2Size&#39;.

    //! Function_PairBufDesc(const Function_PairBufDesc&amp;);
    //! ~Function_PairBufDesc();
    //! Function_PairBufDesc&amp; operator=(const Function_PairBufDesc&amp;);

    // ACCESSORS
    std::size_t totalSize() const;
        // Return the total size of the maximally-aligned buffer needed to
        // hold two objects whose sizes were specified in the constructor.

    void       *first(void       *buffer) const;
    void const *first(void const *buffer) const;
        // Treat the specified &#39;buffer&#39; as a pointer to memory intended to
        // hold two objects whose sizes were specified in the constructor of
        // this &#39;Function_PairBufDesc&#39; and return the address of the first of
        // those two objects.  The behavior is undefined unless &#39;buffer&#39; is
        // the address of a maximally-aligned block of memory of at least
        // &#39;totalSize()&#39; bytes.

    void       *second(void       *buffer) const;
    void const *second(void const *buffer) const;
        // Treat the specified &#39;buffer&#39; as a pointer to memory intended to
        // hold two objects whose sizes were specified in the constructor of
        // this &#39;Function_PairBufDesc&#39; and return the address of the second of
        // those two objects.  The behavior is undefined unless &#39;buffer&#39; is
        // the address of a maximally-aligned block of memory of at least
        // &#39;totalSize()&#39; bytes.
};

template &lt;class ALLOC&gt;
struct Function_AllocTraits
{
    // This is a component-private struct template.  Do not use.
    //
    // Determine the category of an allocator and compute a normalized type
    // for allocators that belong to the same family.

  private:
    typedef Function_Rep::AllocCategory         AllocCategory;

  public:
    static const AllocCategory k_CATEGORY =
        (bsl::is_empty&lt;ALLOC&gt;::value ?
         Function_Rep::e_ERASED_STATELESS_ALLOC :
         Function_Rep::e_ERASED_STATEFUL_ALLOC);

    typedef bsl::integral_constant&lt;AllocCategory, k_CATEGORY&gt; Category;
    typedef typename ALLOC::template rebind&lt;char&gt;::other      Type;
};

template &lt;class ALLOC&gt;
struct Function_AllocTraits&lt;ALLOC *&gt;
{
    // Specialization for pointer to type derived from &#39;bslma::Allocator&#39;.

  private:
    typedef BloombergLP::bslma::Allocator Allocator;

    BSLMF_ASSERT((bsl::is_convertible&lt;ALLOC *, Allocator*&gt;::value));

    typedef Function_Rep::AllocCategory AllocCategory;

  public:
    static const AllocCategory k_CATEGORY = Function_Rep::e_BSLMA_ALLOC_PTR;

    typedef bsl::integral_constant&lt;AllocCategory, k_CATEGORY&gt;  Category;
    typedef Allocator                                         *Type;
};

template &lt;class TYPE&gt;
struct Function_AllocTraits&lt;bsl::allocator&lt;TYPE&gt; &gt;
{
    // Specialization for &#39;bsl::allocator&lt;TYPE&gt;&#39;

  private:
    typedef Function_Rep::AllocCategory AllocCategory;

  public:
    static const AllocCategory k_CATEGORY = Function_Rep::e_BSL_ALLOCATOR;

    typedef bsl::integral_constant&lt;AllocCategory, k_CATEGORY&gt; Category;
    typedef bsl::allocator&lt;char&gt;                              Type;
};

template &lt;class ALLOC&gt;
const Function_Rep::AllocCategory Function_AllocTraits&lt;ALLOC&gt;::k_CATEGORY;

template &lt;class ALLOC&gt;
const Function_Rep::AllocCategory Function_AllocTraits&lt;ALLOC *&gt;::k_CATEGORY;

template &lt;class TYPE&gt;
const Function_Rep::AllocCategory
    Function_AllocTraits&lt;bsl::allocator&lt;TYPE&gt; &gt;::k_CATEGORY;

}  // close namespace bsl

                        // --------------------------
                        // class Function_PairBufDesc
                        // --------------------------

// CREATORS
inline
bsl::Function_PairBufDesc::Function_PairBufDesc(std::size_t t1Size,
                                                std::size_t t2Size)
{
    static const std::size_t k_MAX_ALIGNMENT =
        BloombergLP::bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT;

    d_totalSize = ((t1Size + t2Size + k_MAX_ALIGNMENT - 1) &amp;
                   ~(k_MAX_ALIGNMENT - 1));

    d_secondOffset = d_totalSize - t2Size;
}

// ACCESSORS
inline std::size_t bsl::Function_PairBufDesc::totalSize() const
{
    return d_totalSize;
}

inline void       *bsl::Function_PairBufDesc::first(void       *buffer) const
{
    return buffer;
}

inline void const *bsl::Function_PairBufDesc::first(void const *buffer) const
{
    return buffer;
}

inline void       *bsl::Function_PairBufDesc::second(void       *buffer) const
{
    return d_secondOffset + static_cast&lt;char*&gt;(buffer);
}

inline void const *bsl::Function_PairBufDesc::second(void const *buffer) const
{
    return d_secondOffset + static_cast&lt;const char*&gt;(buffer);
}

                        // --------------------------------------
                        // class Function_SmallObjectOptimization
                        // --------------------------------------

template &lt;class TP&gt;
const std::size_t
bsl::Function_SmallObjectOptimization::SooFuncSize&lt;TP&gt;::VALUE;

                        // -----------------------
                        // class bad_function_call
                        // -----------------------

#ifdef BDE_BUILD_TARGET_EXC

inline
bsl::bad_function_call::bad_function_call() BSLS_NOTHROW_SPEC
    : std::exception()
{
}

#endif

                        // -----------------------
                        // class bsl::Function_Rep
                        // -----------------------

template &lt;class ALLOC&gt;
inline
void bsl::Function_Rep::copyInit(const ALLOC&amp; alloc, const Function_Rep&amp; other)
{
    d_funcManager_p = other.d_funcManager_p;
    d_invoker_p = other.d_invoker_p;

    std::size_t sooFuncSize = d_funcManager_p ?
        d_funcManager_p(e_GET_SIZE, this, PtrOrSize_t()).asSize_t() : 0;

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(sooFuncSize,
            typename Traits::Type(alloc), typename Traits::Category());

    if (d_funcManager_p) {
        PtrOrSize_t source = d_funcManager_p(e_GET_TARGET,
                                             const_cast&lt;Function_Rep*&gt;(&amp;other),
                                             PtrOrSize_t());
        d_funcManager_p(e_COPY_CONSTRUCT, this, source);
    }
}

template &lt;class FUNC, bool IS_INPLACE&gt;
inline
bsl::Function_Rep::PtrOrSize_t
bsl::Function_Rep::functionManager(ManagerOpCode  opCode,
                                   Function_Rep  *rep,
                                   PtrOrSize_t    input)
{
    using namespace BloombergLP;

    static const std::size_t k_SOO_FUNC_SIZE =
        IS_INPLACE ? sizeof(FUNC) : Soo::SooFuncSize&lt;FUNC&gt;::VALUE;
    static const bool k_IS_INPLACE = IS_INPLACE;

    // If a function manager exists, then functor must have non-zero size.
    BSLMF_ASSERT(0 != k_SOO_FUNC_SIZE);

    // If wrapped function fits in &#39;d_objbuf&#39;, then it is inplace; otherwise,
    // its heap-allocated address is found in &#39;d_objbuf.d_object_p&#39;.  There is
    // no need to computed this using metaprogramming; the compiler will
    // optimize away the conditional test.
    char *wrappedFuncBuf_p = static_cast&lt;char*&gt;(
        k_IS_INPLACE ? &amp;rep-&gt;d_objbuf : rep-&gt;d_objbuf.d_object_p);
    FUNC *wrappedFunc_p = reinterpret_cast&lt;FUNC*&gt;(wrappedFuncBuf_p);

    switch (opCode) {

      case e_MOVE_CONSTRUCT: {
        // Move-construct function object.  There is no point to optimizing
        // this operation for trivial types.  If the type is trivially
        // moveable or copyable, then the move or copy operation below will do
        // it trivially.

        FUNC &amp;srcFunc = *static_cast&lt;FUNC*&gt;(input.asPtr());

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        bslalg::ScalarPrimitives::moveConstruct(wrappedFunc_p,
                                                srcFunc,
                                                rep-&gt;d_allocator_p);
#else
        bslalg::ScalarPrimitives::copyConstruct(wrappedFunc_p,
                                                srcFunc,
                                                rep-&gt;d_allocator_p);
#endif
        return wrappedFunc_p;                                         // RETURN
      } break;

      case e_COPY_CONSTRUCT: {

        // Copy-construct function object.  There is no point to optimizing
        // this operation for bitwise copyable types.  If the type is trivially
        // copyable, then the copy operation below will do it trivially.
        const FUNC &amp;srcFunc = *static_cast&lt;const FUNC*&gt;(input.asPtr());
        bslalg::ScalarPrimitives::copyConstruct(wrappedFunc_p,
                                                srcFunc,
                                                rep-&gt;d_allocator_p);
        return wrappedFunc_p;                                         // RETURN
      } break;

      case e_DESTROY: {

        // Call destructor for functor.
        wrappedFunc_p-&gt;~FUNC();

        // Return size of destroyed function object
        return k_SOO_FUNC_SIZE;                                       // RETURN
      } break;

      case e_DESTRUCTIVE_MOVE: {
        void *input_p      = input.asPtr();
        FUNC *srcFunc_p    = static_cast&lt;FUNC*&gt;(input_p);

        bslalg::ScalarPrimitives::destructiveMove(wrappedFunc_p, srcFunc_p,
                                                  rep-&gt;d_allocator_p);
      } break;

      case e_GET_SIZE:     return k_SOO_FUNC_SIZE;                    // RETURN
      case e_GET_TARGET:   return wrappedFunc_p;                      // RETURN
      case e_GET_TYPE_ID:
        return const_cast&lt;std::type_info*&gt;(&amp;typeid(FUNC));            // RETURN

      case e_IS_EQUAL:
      case e_INIT_REP: {
        BSLS_ASSERT(0 &amp;&amp; &quot;Opcode not implemented for function manager&quot;);
      } break;

    } // end switch

    return PtrOrSize_t();
}

template &lt;class ALLOC&gt;
inline
bsl::Function_Rep::PtrOrSize_t
bsl::Function_Rep::ownedAllocManager(ManagerOpCode  opCode,
                                     Function_Rep  *rep,
                                     PtrOrSize_t    input)
{
    using namespace BloombergLP;
    typedef typename bslma::AllocatorAdaptor&lt;ALLOC&gt;::Type Adaptor;

    switch (opCode) {
      case e_MOVE_CONSTRUCT: // Fall through: allocators are always copied
      case e_COPY_CONSTRUCT: {
        const Adaptor&amp; other = *static_cast&lt;const Adaptor*&gt;(input.asPtr());
        return ::new ((void*) rep-&gt;d_allocator_p) Adaptor(other);     // RETURN
      } break;

      case e_DESTROY: {
        // Allocator cannot deallocate itself, so make a copy of the allocator
        // on the stack and use the copy for deallocation.
        Adaptor allocCopy(*static_cast&lt;Adaptor*&gt;(rep-&gt;d_allocator_p));
        std::size_t sooFuncSize = input.asSize_t();

        rep-&gt;d_allocator_p-&gt;~Allocator();  // destroy allocator

        if (sooFuncSize &gt; sizeof(InplaceBuffer)) {
            // Deallocate memory holding both functor and allocator
            allocCopy.deallocate(rep-&gt;d_objbuf.d_object_p);
        }
        else {
            // Functor is inplace but allocator is not.
            // Deallocate space used by allocator.
            allocCopy.deallocate(rep-&gt;d_allocator_p);
        }

        // Return size allocator adaptor.
        return sizeof(Adaptor);                                       // RETURN
      }

      case e_DESTRUCTIVE_MOVE: {
        const Adaptor&amp; other = *static_cast&lt;const Adaptor*&gt;(input.asPtr());

        // Compute the distance (in bytes) between the start of the source and
        // the start of the destination to see if they overlap.
        std::size_t dist = static_cast&lt;std::size_t&gt;(
            std::abs(reinterpret_cast&lt;const char*&gt;(rep-&gt;d_allocator_p) -
                     reinterpret_cast&lt;const char*&gt;(&amp;other)));

        if (dist &gt;= sizeof(Adaptor)) {
            // Input and output don&#39;t overlap.
            ::new ((void*) rep-&gt;d_allocator_p)
                                   Adaptor(bslmf::MovableRefUtil::move(other));
            other.~Adaptor();
        }
        else {
            // Input and output overlap so we need to move through a temporary
            // variable.
            Adaptor temp(bslmf::MovableRefUtil::move(other));
            other.~Adaptor();
            ::new ((void*) rep-&gt;d_allocator_p)
                                    Adaptor(bslmf::MovableRefUtil::move(temp));
        }
      } break;

      case e_GET_SIZE: {
        // The SOO size of the adaptor is always the same as the true size of
        // the adaptor because it is always nothrow moveable.
        return sizeof(Adaptor);                                       // RETURN
      }

      case e_GET_TARGET:  return rep-&gt;d_allocator_p;                  // RETURN
      case e_GET_TYPE_ID:
          return const_cast&lt;std::type_info*&gt;(&amp;typeid(Adaptor));       // RETURN

      case e_IS_EQUAL: {
        const Allocator *inputAlloc =
            static_cast&lt;const Allocator *&gt;(input.asPtr());
        const Adaptor *inputAdaptor = dynamic_cast&lt;const Adaptor*&gt;(inputAlloc);
        Adaptor *thisAdaptor = static_cast&lt;Adaptor*&gt;(rep-&gt;d_allocator_p);
        return inputAdaptor ?
            inputAdaptor-&gt;adaptedAllocator() == thisAdaptor-&gt;adaptedAllocator()
            : false;                                                  // RETURN
      } break;

      case e_INIT_REP: {
        const Allocator *inputAlloc =
            static_cast&lt;const Allocator *&gt;(input.asPtr());
        const Adaptor *inputAdaptor =
            dynamic_cast&lt;const Adaptor*&gt;(inputAlloc);
        BSLS_ASSERT(inputAdaptor);

        std::size_t sooFuncSize = rep-&gt;d_funcManager_p ?
            rep-&gt;d_funcManager_p(e_GET_SIZE, rep,
                                 PtrOrSize_t()).asSize_t() : 0;

        rep-&gt;initRep(sooFuncSize, inputAdaptor-&gt;adaptedAllocator(),
                  integral_constant&lt;AllocCategory, e_ERASED_STATEFUL_ALLOC&gt;());

      } break;
    } // end switch

    return PtrOrSize_t();
}

template &lt;class FUNC&gt;
inline
bsl::Function_Rep::Manager bsl::Function_Rep::getFunctionManager()
{
    static const bool k_IS_INPLACE = Soo::IsInplaceFunc&lt;FUNC&gt;::value;
    typedef typename
        Function_NothrowWrapperUtil&lt;FUNC&gt;::UnwrappedType UnwrappedFunc;
    return &amp;functionManager&lt;UnwrappedFunc, k_IS_INPLACE&gt;;
}

inline
void *bsl::Function_Rep::initRep(std::size_t                 sooFuncSize,
                                 const bsl::allocator&lt;char&gt;&amp; alloc,
                                 integral_constant&lt;AllocCategory,
                                                   e_BSL_ALLOCATOR&gt;)
{
    return initRep(sooFuncSize, alloc.mechanism(),
                   integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());
}

template &lt;class ALLOC&gt;
inline
void *bsl::Function_Rep::initRep(std::size_t  sooFuncSize,
                                 const ALLOC&amp; alloc,
                                 integral_constant&lt;AllocCategory,
                                                   e_ERASED_STATEFUL_ALLOC&gt;)
{
    using namespace BloombergLP;
    typedef typename bslma::AllocatorAdaptor&lt;ALLOC&gt;::Type Adaptor;

    static const std::size_t allocSize = sizeof(Adaptor);

    // Get real size of invocable from the soo-encoded size.
    const std::size_t funcSize = (sooFuncSize &gt;= k_NON_SOO_SMALL_SIZE ?
                                  sooFuncSize - k_NON_SOO_SMALL_SIZE :
                                  sooFuncSize);

    const bool isInplaceFunc = sooFuncSize &lt;= sizeof(InplaceBuffer);

    void *function_p;
    void *allocator_p;

    // A type-erased allocator is never allocated inplace.  Allocating the
    // allocator out of place allows the allocator to be moved from one
    // function object to another without changing its address.  This pointer
    // stability is critical to ensuring that move-constructing an inplace
    // functor does not result in a functor holding an pointer to a different
    // &#39;function&#39; object&#39;s allocator.  Not having the erased allocator inplace
    // also simplifies the logic in a number of places.
    //
    // If the functor is allocated out of place, then the functor and the
    // out-of-place allocator can be allocated in a single memory block, since
    // they will always move together as a unit and the allocator&#39;s address
    // will not change.
    //
    // At the end if this &#39;if-else&#39; statement, &#39;function_p&#39; and &#39;allocator_p&#39;
    // will point to storage allocated for the invocable and the allocator
    // adaptor, respectively.  Although this is a run-time &#39;if&#39; statement, the
    // compiler will usually optimize away the conditional when &#39;sooFuncSize&#39;
    // is known at compile time, if this function is inlined.  (Besides, it&#39;s
    // cheap even if not optimized away).
    if (isInplaceFunc) {
        // Function object fits in-place, but allocator is out-of-place
        function_p = &amp;d_objbuf;
        // Allocate allocator adaptor from allocator itself
        allocator_p = Adaptor(alloc).allocate(allocSize);
    }
    else {
        // Not in-place.  Allocate (from the allocator) a single block to hold
        // the function and allocator adaptor.
        Function_PairBufDesc pairDesc(funcSize, allocSize);
        void *pair_p = Adaptor(alloc).allocate(pairDesc.totalSize());
        d_objbuf.d_object_p = pair_p;
        function_p = pairDesc.first(pair_p);
        allocator_p = pairDesc.second(pair_p);
    }

    // Construct allocator adaptor in its correct location.
    // Note that allocator copy constructor is not allowed to throw.
    d_allocator_p = ::new((void*) allocator_p) Adaptor(alloc);
    d_allocManager_p = &amp;ownedAllocManager&lt;ALLOC&gt;;

    return function_p;
}

template &lt;class ALLOC&gt;
inline
void *bsl::Function_Rep::initRep(std::size_t sooFuncSize,
                                 const ALLOC&amp; alloc,
                                 integral_constant&lt;AllocCategory,
                                                   e_ERASED_STATELESS_ALLOC&gt;)
{
    using namespace BloombergLP;

    // Since all instances of &#39;ALLOC&#39; compare equal, we need only one instance
    // of it.  This single instance is wrapped in an adaptor.  Note that
    // &#39;ALLOC&#39; should have been rebound to a common element type, so only one
    // singleton will be created for &#39;Foo&lt;int(*)()&gt;&#39; and &#39;Foo&lt;Bar&gt;&#39;, where
    // &#39;Foo&#39; is an STL-style allocator template.
    static typename bslma::AllocatorAdaptor&lt;ALLOC&gt;::Type allocInstance(alloc);

    return initRep(sooFuncSize, &amp;allocInstance,
                   integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());
}

inline
bool bsl::Function_Rep::equalAlloc(Allocator* alloc,
                     integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;) const
{
    return alloc == d_allocator_p;
}

template &lt;class TP&gt;
inline
bool bsl::Function_Rep::equalAlloc(const bsl::allocator&lt;TP&gt;&amp; alloc,
                       integral_constant&lt;AllocCategory, e_BSL_ALLOCATOR&gt;) const
{
    return alloc.mechanism() == d_allocator_p;
}

template &lt;class ALLOC&gt;
inline
bool bsl::Function_Rep::equalAlloc(const ALLOC&amp;,
              integral_constant&lt;AllocCategory,e_ERASED_STATELESS_ALLOC&gt;)  const
{
    using namespace BloombergLP;

    BSLMF_ASSERT((is_same&lt;typename ALLOC::value_type, char&gt;::value));

    typedef typename bslma::AllocatorAdaptor&lt;ALLOC&gt;::Type Adaptor;

    // If the our allocator has the same type as the adapted stateless
    // allocator, then they are assumed equal.
    return NULL != dynamic_cast&lt;Adaptor*&gt;(d_allocator_p);
}

template &lt;class ALLOC&gt;
inline
bool bsl::Function_Rep::equalAlloc(const ALLOC&amp; alloc,
               integral_constant&lt;AllocCategory, e_ERASED_STATEFUL_ALLOC&gt;) const
{
    using namespace BloombergLP;

    BSLMF_ASSERT((is_same&lt;typename ALLOC::value_type, char&gt;::value));

    typedef typename bslma::AllocatorAdaptor&lt;ALLOC&gt;::Type Adaptor;

    // Try to cast our allocator into the same type as the adapted &#39;ALLOC&#39;.
    Adaptor *thisAdaptor = dynamic_cast&lt;Adaptor*&gt;(d_allocator_p);

    if (! thisAdaptor) {
        // Different type.  Cannot compare equal.
        return false;                                                 // RETURN
    }

    // Compare the wrapped STL allocator to &#39;alloc&#39;.
    return thisAdaptor-&gt;adaptedAllocator() == alloc;
}

template &lt;class ALLOC, bsl::Function_Rep::AllocCategory ATP&gt;
inline
void bsl::Function_Rep::copyRep(const Function_Rep&amp;                   other,
                                const ALLOC&amp;                          alloc,
                                integral_constant&lt;AllocCategory, ATP&gt; atp)
{
    // Compute function size.
    std::size_t sooFuncSize =
        other.d_funcManager_p(e_GET_SIZE, this, PtrOrSize_t()).asSize_t();

    initRep(sooFuncSize, alloc, atp);

    void *otherFunction_p = (sooFuncSize &lt;= sizeof(InplaceBuffer) ?
                             &amp;other.d_objbuf : other.d_objbuf.d_object_p);

    d_funcManager_p = other.d_funcManager_p;

    // Construct a copy of the function int its correct location
    d_funcManager_p(e_COPY_CONSTRUCT, this, otherFunction_p);
}

inline
bsl::Function_Rep::Function_Rep()
{
    d_objbuf.d_func_p = NULL;
    d_funcManager_p   = NULL;
    d_allocator_p     = NULL;
    d_allocManager_p  = NULL;
    d_invoker_p       = NULL;
}

template&lt;class TP&gt;
inline
TP* bsl::Function_Rep::target() BSLS_NOTHROW_SPEC
{
    if ((! d_funcManager_p) || target_type() != typeid(TP)) {
        return NULL;                                                  // RETURN
    }

    PtrOrSize_t target = d_funcManager_p(e_GET_TARGET, this, PtrOrSize_t());
    return static_cast&lt;TP*&gt;(target.asPtr());
}

template&lt;class TP&gt;
inline
const TP* bsl::Function_Rep::target() const BSLS_NOTHROW_SPEC
{
#if defined(BSLS_PLATFORM_CMP_MSVC) &amp;&amp; BSLS_PLATFORM_CMP_VERSION &lt; 1900
    return reinterpret_cast&lt;const TP *&gt;(
                                const_cast&lt;Function_Rep*&gt;(this)-&gt;target&lt;TP&gt;());
#else
    return const_cast&lt;Function_Rep*&gt;(this)-&gt;target&lt;TP&gt;();
#endif
}

inline
BloombergLP::bslma::Allocator *bsl::Function_Rep::allocator() const
{
    return d_allocator_p;
}

                        // ----------------------------
                        // class template bsl::function
                        // ----------------------------

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES

// PRIVATE STATIC MEMBER FUNCTIONS
template &lt;class RET, class... ARGS&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS...)&gt;::functionPtrInvoker(const Function_Rep *rep,
               typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args)
{
    // Note that &#39;FUNC&#39; might be different than &#39;RET(*)(ARGS...)&#39;. All that is
    // required is that it be Callable with &#39;ARGS...&#39; and return something
    // convertible to &#39;RET&#39;.
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    // Cast to &#39;RET&#39; is needed to avoid compilation error if &#39;RET&#39; is void and
    // &#39;f&#39; returns non-void.
    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS&gt;::
                              forwardToTarget(args)...));
}

template &lt;class RET, class... ARGS&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS...)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
               typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args)
{
    using namespace BloombergLP;

    // Workaround Sun compiler issue - it thinks we&#39;re trying to cast away
    // const or volatile if we use reinterpret_cast.
    // FUNC f = reinterpret_cast&lt;const FUNC&amp;&gt;(rep-&gt;d_objbuf.d_memFunc_p);
    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS...&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT(sizeof...(ARGS) == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args...);
}

template &lt;class RET, class... ARGS&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS...)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
               typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    // Cast to &#39;RET&#39; is needed to avoid compilation error if &#39;RET&#39; is void and
    // &#39;f&#39; returns non-void.
    return static_cast&lt;RET&gt;(f(args...));
}

template &lt;class RET, class... ARGS&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS...)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
               typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    // Cast to &#39;RET&#39; is needed to avoid compilation error if &#39;RET&#39; is void and
    // &#39;f&#39; returns non-void.
    return static_cast&lt;RET&gt;(f(args...));
}

template &lt;class RET, class... ARGS&gt;
inline
void bsl::function&lt;RET(ARGS...)&gt;::setInvoker(Invoker *p)
{
    // Verify the assumption that all function pointers are the same size.
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class... ARGS&gt;
inline
typename bsl::function&lt;RET(ARGS...)&gt;::Invoker *
bsl::function&lt;RET(ARGS...)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

// CREATORS
template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class... ARGS&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class... ARGS&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class... ARGS&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class... ARGS&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class... ARGS&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        // Empty &#39;function&#39; object
        d_funcManager_p = NULL;
    }
}

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class... ARGS&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

#endif //  BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::~function()
{
    // Assert class invariants
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    // Destroying the functor is not done in the base class destructor because
    // the invariant of the functor being fully constructed is not maintained
    // in the base class.  Moving this destruction to the base class would
    // cause exception handling to break if an exception were thrown when
    // constructing the wrapped functor.
    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

// MANIPULATORS
template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;&amp;
bsl::function&lt;RET(ARGS...)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;&amp;
bsl::function&lt;RET(ARGS...)&gt;::operator=(function&amp; rhs)
{
    // Delegate to the const version
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;&amp;
bsl::function&lt;RET(ARGS...)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        // Equal allocators.  Just swap.
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

#endif

template &lt;class RET, class... ARGS&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;&amp;
bsl::function&lt;RET(ARGS...)&gt;::operator=(FUNC&amp;&amp; func)
{
    Function_Rep tempRep;

    // Remove reference and const from &#39;FUNC&#39; to get underlying functor type.
    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    // Initialize tempRep using allocator from &#39;this&#39;
    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    // Move &#39;func&#39; into initialized &#39;tempRep&#39;
    if (tempRep.d_funcManager_p) {
        // Get non-const pointer to &#39;func&#39;
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;FUNC&amp;&amp;&gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    // If successful (no exceptions thrown) swap &#39;tempRep&#39; into &#39;*this&#39;.
    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        // Destroy the functor in &#39;tempRep&#39; before &#39;tempRep&#39; goes out of scope
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;&amp;
bsl::function&lt;RET(ARGS...)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}

// TBD: Need to implement reference_wrapper.
// template &lt;class RET, class... ARGS&gt;
// template&lt;class FUNC&gt;
// function&amp; bsl::function&lt;RET(ARGS...)&gt;::operator=(reference_wrapper&lt;FUNC&gt;)
//     BSLS_NOTHROW_SPEC

template &lt;class RET, class... ARGS&gt;
inline
RET bsl::function&lt;RET(ARGS...)&gt;::operator()(ARGS... args) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args...);                              // RETURN
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    // Non-exception build
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args...);
#endif
}

// ACCESSORS

#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    // If there is an invoker, then this function is non-empty (return true);
    // otherwise it is empty (return false).
    return invoker();
}
#endif // BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT

// FREE FUNCTIONS
template &lt;class RET, class... ARGS&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS...)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class... ARGS&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS...)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class... ARGS&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS...)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class... ARGS&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS...)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class... ARGS&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS...)&gt;&amp; a, bsl::function&lt;RET(ARGS...)&gt;&amp; b)
{
    a.swap(b);
}

#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Generator command line: sim_cpp11_features.pl bslstl_function.h

template &lt;class RET&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET()&gt;::functionPtrInvoker(const Function_Rep *rep)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f());
}

template &lt;class RET, class ARGS_01&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01)&gt;::functionPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_01&gt;::
                              forwardToTarget(args_01)));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02)&gt;::functionPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_01&gt;::
                              forwardToTarget(args_01),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_02&gt;::
                              forwardToTarget(args_02)));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03)&gt;::functionPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_01&gt;::
                              forwardToTarget(args_01),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_02&gt;::
                              forwardToTarget(args_02),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_03&gt;::
                              forwardToTarget(args_03)));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04)&gt;::functionPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_01&gt;::
                              forwardToTarget(args_01),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_02&gt;::
                              forwardToTarget(args_02),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_03&gt;::
                              forwardToTarget(args_03),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_04&gt;::
                              forwardToTarget(args_04)));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05)&gt;::functionPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_01&gt;::
                              forwardToTarget(args_01),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_02&gt;::
                              forwardToTarget(args_02),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_03&gt;::
                              forwardToTarget(args_03),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_04&gt;::
                              forwardToTarget(args_04),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_05&gt;::
                              forwardToTarget(args_05)));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06)&gt;::functionPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_01&gt;::
                              forwardToTarget(args_01),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_02&gt;::
                              forwardToTarget(args_02),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_03&gt;::
                              forwardToTarget(args_03),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_04&gt;::
                              forwardToTarget(args_04),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_05&gt;::
                              forwardToTarget(args_05),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_06&gt;::
                              forwardToTarget(args_06)));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07)&gt;::functionPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_01&gt;::
                              forwardToTarget(args_01),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_02&gt;::
                              forwardToTarget(args_02),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_03&gt;::
                              forwardToTarget(args_03),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_04&gt;::
                              forwardToTarget(args_04),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_05&gt;::
                              forwardToTarget(args_05),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_06&gt;::
                              forwardToTarget(args_06),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_07&gt;::
                              forwardToTarget(args_07)));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08)&gt;::functionPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_01&gt;::
                              forwardToTarget(args_01),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_02&gt;::
                              forwardToTarget(args_02),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_03&gt;::
                              forwardToTarget(args_03),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_04&gt;::
                              forwardToTarget(args_04),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_05&gt;::
                              forwardToTarget(args_05),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_06&gt;::
                              forwardToTarget(args_06),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_07&gt;::
                              forwardToTarget(args_07),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_08&gt;::
                              forwardToTarget(args_08)));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09)&gt;::functionPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_01&gt;::
                              forwardToTarget(args_01),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_02&gt;::
                              forwardToTarget(args_02),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_03&gt;::
                              forwardToTarget(args_03),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_04&gt;::
                              forwardToTarget(args_04),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_05&gt;::
                              forwardToTarget(args_05),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_06&gt;::
                              forwardToTarget(args_06),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_07&gt;::
                              forwardToTarget(args_07),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_08&gt;::
                              forwardToTarget(args_08),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_09&gt;::
                              forwardToTarget(args_09)));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10)&gt;::functionPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_01&gt;::
                              forwardToTarget(args_01),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_02&gt;::
                              forwardToTarget(args_02),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_03&gt;::
                              forwardToTarget(args_03),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_04&gt;::
                              forwardToTarget(args_04),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_05&gt;::
                              forwardToTarget(args_05),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_06&gt;::
                              forwardToTarget(args_06),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_07&gt;::
                              forwardToTarget(args_07),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_08&gt;::
                              forwardToTarget(args_08),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_09&gt;::
                              forwardToTarget(args_09),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_10&gt;::
                              forwardToTarget(args_10)));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11)&gt;::functionPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_01&gt;::
                              forwardToTarget(args_01),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_02&gt;::
                              forwardToTarget(args_02),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_03&gt;::
                              forwardToTarget(args_03),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_04&gt;::
                              forwardToTarget(args_04),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_05&gt;::
                              forwardToTarget(args_05),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_06&gt;::
                              forwardToTarget(args_06),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_07&gt;::
                              forwardToTarget(args_07),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_08&gt;::
                              forwardToTarget(args_08),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_09&gt;::
                              forwardToTarget(args_09),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_10&gt;::
                              forwardToTarget(args_10),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_11&gt;::
                              forwardToTarget(args_11)));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11,
                      ARGS_12)&gt;::functionPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_01&gt;::
                              forwardToTarget(args_01),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_02&gt;::
                              forwardToTarget(args_02),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_03&gt;::
                              forwardToTarget(args_03),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_04&gt;::
                              forwardToTarget(args_04),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_05&gt;::
                              forwardToTarget(args_05),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_06&gt;::
                              forwardToTarget(args_06),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_07&gt;::
                              forwardToTarget(args_07),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_08&gt;::
                              forwardToTarget(args_08),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_09&gt;::
                              forwardToTarget(args_09),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_10&gt;::
                              forwardToTarget(args_10),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_11&gt;::
                              forwardToTarget(args_11),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_12&gt;::
                              forwardToTarget(args_12)));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11,
                      ARGS_12,
                      ARGS_13)&gt;::functionPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_01&gt;::
                              forwardToTarget(args_01),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_02&gt;::
                              forwardToTarget(args_02),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_03&gt;::
                              forwardToTarget(args_03),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_04&gt;::
                              forwardToTarget(args_04),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_05&gt;::
                              forwardToTarget(args_05),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_06&gt;::
                              forwardToTarget(args_06),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_07&gt;::
                              forwardToTarget(args_07),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_08&gt;::
                              forwardToTarget(args_08),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_09&gt;::
                              forwardToTarget(args_09),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_10&gt;::
                              forwardToTarget(args_10),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_11&gt;::
                              forwardToTarget(args_11),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_12&gt;::
                              forwardToTarget(args_12),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_13&gt;::
                              forwardToTarget(args_13)));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11,
                      ARGS_12,
                      ARGS_13,
                      ARGS_14)&gt;::functionPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_14&gt;::Type args_14)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_01&gt;::
                              forwardToTarget(args_01),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_02&gt;::
                              forwardToTarget(args_02),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_03&gt;::
                              forwardToTarget(args_03),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_04&gt;::
                              forwardToTarget(args_04),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_05&gt;::
                              forwardToTarget(args_05),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_06&gt;::
                              forwardToTarget(args_06),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_07&gt;::
                              forwardToTarget(args_07),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_08&gt;::
                              forwardToTarget(args_08),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_09&gt;::
                              forwardToTarget(args_09),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_10&gt;::
                              forwardToTarget(args_10),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_11&gt;::
                              forwardToTarget(args_11),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_12&gt;::
                              forwardToTarget(args_12),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_13&gt;::
                              forwardToTarget(args_13),
                              BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS_14&gt;::
                              forwardToTarget(args_14)));
}


template &lt;class RET&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET()&gt;::memFuncPtrInvoker(const Function_Rep *rep)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT( 0u == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f);
}

template &lt;class RET, class ARGS_01&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS_01&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT( 1u == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args_01);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS_01,
                                            ARGS_02&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT( 2u == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args_01,
                                       args_02);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS_01,
                                            ARGS_02,
                                            ARGS_03&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT( 3u == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args_01,
                                       args_02,
                                       args_03);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS_01,
                                            ARGS_02,
                                            ARGS_03,
                                            ARGS_04&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT( 4u == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args_01,
                                       args_02,
                                       args_03,
                                       args_04);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS_01,
                                            ARGS_02,
                                            ARGS_03,
                                            ARGS_04,
                                            ARGS_05&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT( 5u == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args_01,
                                       args_02,
                                       args_03,
                                       args_04,
                                       args_05);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS_01,
                                            ARGS_02,
                                            ARGS_03,
                                            ARGS_04,
                                            ARGS_05,
                                            ARGS_06&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT( 6u == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args_01,
                                       args_02,
                                       args_03,
                                       args_04,
                                       args_05,
                                       args_06);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS_01,
                                            ARGS_02,
                                            ARGS_03,
                                            ARGS_04,
                                            ARGS_05,
                                            ARGS_06,
                                            ARGS_07&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT( 7u == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args_01,
                                       args_02,
                                       args_03,
                                       args_04,
                                       args_05,
                                       args_06,
                                       args_07);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS_01,
                                            ARGS_02,
                                            ARGS_03,
                                            ARGS_04,
                                            ARGS_05,
                                            ARGS_06,
                                            ARGS_07,
                                            ARGS_08&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT( 8u == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args_01,
                                       args_02,
                                       args_03,
                                       args_04,
                                       args_05,
                                       args_06,
                                       args_07,
                                       args_08);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS_01,
                                            ARGS_02,
                                            ARGS_03,
                                            ARGS_04,
                                            ARGS_05,
                                            ARGS_06,
                                            ARGS_07,
                                            ARGS_08,
                                            ARGS_09&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT( 9u == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args_01,
                                       args_02,
                                       args_03,
                                       args_04,
                                       args_05,
                                       args_06,
                                       args_07,
                                       args_08,
                                       args_09);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS_01,
                                            ARGS_02,
                                            ARGS_03,
                                            ARGS_04,
                                            ARGS_05,
                                            ARGS_06,
                                            ARGS_07,
                                            ARGS_08,
                                            ARGS_09,
                                            ARGS_10&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT(10u == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args_01,
                                       args_02,
                                       args_03,
                                       args_04,
                                       args_05,
                                       args_06,
                                       args_07,
                                       args_08,
                                       args_09,
                                       args_10);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS_01,
                                            ARGS_02,
                                            ARGS_03,
                                            ARGS_04,
                                            ARGS_05,
                                            ARGS_06,
                                            ARGS_07,
                                            ARGS_08,
                                            ARGS_09,
                                            ARGS_10,
                                            ARGS_11&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT(11u == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args_01,
                                       args_02,
                                       args_03,
                                       args_04,
                                       args_05,
                                       args_06,
                                       args_07,
                                       args_08,
                                       args_09,
                                       args_10,
                                       args_11);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11,
                      ARGS_12)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS_01,
                                            ARGS_02,
                                            ARGS_03,
                                            ARGS_04,
                                            ARGS_05,
                                            ARGS_06,
                                            ARGS_07,
                                            ARGS_08,
                                            ARGS_09,
                                            ARGS_10,
                                            ARGS_11,
                                            ARGS_12&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT(12u == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args_01,
                                       args_02,
                                       args_03,
                                       args_04,
                                       args_05,
                                       args_06,
                                       args_07,
                                       args_08,
                                       args_09,
                                       args_10,
                                       args_11,
                                       args_12);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11,
                      ARGS_12,
                      ARGS_13)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS_01,
                                            ARGS_02,
                                            ARGS_03,
                                            ARGS_04,
                                            ARGS_05,
                                            ARGS_06,
                                            ARGS_07,
                                            ARGS_08,
                                            ARGS_09,
                                            ARGS_10,
                                            ARGS_11,
                                            ARGS_12,
                                            ARGS_13&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT(13u == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args_01,
                                       args_02,
                                       args_03,
                                       args_04,
                                       args_05,
                                       args_06,
                                       args_07,
                                       args_08,
                                       args_09,
                                       args_10,
                                       args_11,
                                       args_12,
                                       args_13);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11,
                      ARGS_12,
                      ARGS_13,
                      ARGS_14)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_14&gt;::Type args_14)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS_01,
                                            ARGS_02,
                                            ARGS_03,
                                            ARGS_04,
                                            ARGS_05,
                                            ARGS_06,
                                            ARGS_07,
                                            ARGS_08,
                                            ARGS_09,
                                            ARGS_10,
                                            ARGS_11,
                                            ARGS_12,
                                            ARGS_13,
                                            ARGS_14&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT(14u == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args_01,
                                       args_02,
                                       args_03,
                                       args_04,
                                       args_05,
                                       args_06,
                                       args_07,
                                       args_08,
                                       args_09,
                                       args_10,
                                       args_11,
                                       args_12,
                                       args_13,
                                       args_14);
}


template &lt;class RET&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET()&gt;::inplaceFunctorInvoker(const Function_Rep *rep)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f());
}

template &lt;class RET, class ARGS_01&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f(args_01));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f(args_01,
                              args_02));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07,
                              args_08));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07,
                              args_08,
                              args_09));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07,
                              args_08,
                              args_09,
                              args_10));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07,
                              args_08,
                              args_09,
                              args_10,
                              args_11));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11,
                      ARGS_12)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07,
                              args_08,
                              args_09,
                              args_10,
                              args_11,
                              args_12));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11,
                      ARGS_12,
                      ARGS_13)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07,
                              args_08,
                              args_09,
                              args_10,
                              args_11,
                              args_12,
                              args_13));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11,
                      ARGS_12,
                      ARGS_13,
                      ARGS_14)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_14&gt;::Type args_14)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07,
                              args_08,
                              args_09,
                              args_10,
                              args_11,
                              args_12,
                              args_13,
                              args_14));
}


template &lt;class RET&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET()&gt;::outofplaceFunctorInvoker(const Function_Rep *rep)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f());
}

template &lt;class RET, class ARGS_01&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS_01)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f(args_01));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f(args_01,
                              args_02));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07,
                              args_08));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07,
                              args_08,
                              args_09));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07,
                              args_08,
                              args_09,
                              args_10));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07,
                              args_08,
                              args_09,
                              args_10,
                              args_11));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07,
                              args_08,
                              args_09,
                              args_10,
                              args_11,
                              args_12));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07,
                              args_08,
                              args_09,
                              args_10,
                              args_11,
                              args_12,
                              args_13));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_01&gt;::Type args_01,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_02&gt;::Type args_02,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_03&gt;::Type args_03,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_04&gt;::Type args_04,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_05&gt;::Type args_05,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_06&gt;::Type args_06,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_07&gt;::Type args_07,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_08&gt;::Type args_08,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_09&gt;::Type args_09,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_10&gt;::Type args_10,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_11&gt;::Type args_11,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_12&gt;::Type args_12,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_13&gt;::Type args_13,
            typename BloombergLP::bslmf::ForwardingType&lt;ARGS_14&gt;::Type args_14)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f(args_01,
                              args_02,
                              args_03,
                              args_04,
                              args_05,
                              args_06,
                              args_07,
                              args_08,
                              args_09,
                              args_10,
                              args_11,
                              args_12,
                              args_13,
                              args_14));
}


template &lt;class RET&gt;
inline
void bsl::function&lt;RET()&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class ARGS_01&gt;
inline
void bsl::function&lt;RET(ARGS_01)&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
void bsl::function&lt;RET(ARGS_01,
                       ARGS_02)&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
void bsl::function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03)&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
void bsl::function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04)&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
void bsl::function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05)&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
void bsl::function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06)&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
void bsl::function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07)&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
void bsl::function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07,
                       ARGS_08)&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
void bsl::function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07,
                       ARGS_08,
                       ARGS_09)&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
void bsl::function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07,
                       ARGS_08,
                       ARGS_09,
                       ARGS_10)&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
void bsl::function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07,
                       ARGS_08,
                       ARGS_09,
                       ARGS_10,
                       ARGS_11)&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
void bsl::function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07,
                       ARGS_08,
                       ARGS_09,
                       ARGS_10,
                       ARGS_11,
                       ARGS_12)&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
void bsl::function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07,
                       ARGS_08,
                       ARGS_09,
                       ARGS_10,
                       ARGS_11,
                       ARGS_12,
                       ARGS_13)&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
void bsl::function&lt;RET(ARGS_01,
                       ARGS_02,
                       ARGS_03,
                       ARGS_04,
                       ARGS_05,
                       ARGS_06,
                       ARGS_07,
                       ARGS_08,
                       ARGS_09,
                       ARGS_10,
                       ARGS_11,
                       ARGS_12,
                       ARGS_13,
                       ARGS_14)&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}


template &lt;class RET&gt;
inline
typename bsl::function&lt;RET()&gt;::Invoker *
bsl::function&lt;RET()&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

template &lt;class RET, class ARGS_01&gt;
inline
typename bsl::function&lt;RET(ARGS_01)&gt;::Invoker *
bsl::function&lt;RET(ARGS_01)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
typename bsl::function&lt;RET(ARGS_01,
                           ARGS_02)&gt;::Invoker *
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
typename bsl::function&lt;RET(ARGS_01,
                           ARGS_02,
                           ARGS_03)&gt;::Invoker *
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
typename bsl::function&lt;RET(ARGS_01,
                           ARGS_02,
                           ARGS_03,
                           ARGS_04)&gt;::Invoker *
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
typename bsl::function&lt;RET(ARGS_01,
                           ARGS_02,
                           ARGS_03,
                           ARGS_04,
                           ARGS_05)&gt;::Invoker *
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
typename bsl::function&lt;RET(ARGS_01,
                           ARGS_02,
                           ARGS_03,
                           ARGS_04,
                           ARGS_05,
                           ARGS_06)&gt;::Invoker *
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
typename bsl::function&lt;RET(ARGS_01,
                           ARGS_02,
                           ARGS_03,
                           ARGS_04,
                           ARGS_05,
                           ARGS_06,
                           ARGS_07)&gt;::Invoker *
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
typename bsl::function&lt;RET(ARGS_01,
                           ARGS_02,
                           ARGS_03,
                           ARGS_04,
                           ARGS_05,
                           ARGS_06,
                           ARGS_07,
                           ARGS_08)&gt;::Invoker *
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
typename bsl::function&lt;RET(ARGS_01,
                           ARGS_02,
                           ARGS_03,
                           ARGS_04,
                           ARGS_05,
                           ARGS_06,
                           ARGS_07,
                           ARGS_08,
                           ARGS_09)&gt;::Invoker *
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
typename bsl::function&lt;RET(ARGS_01,
                           ARGS_02,
                           ARGS_03,
                           ARGS_04,
                           ARGS_05,
                           ARGS_06,
                           ARGS_07,
                           ARGS_08,
                           ARGS_09,
                           ARGS_10)&gt;::Invoker *
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
typename bsl::function&lt;RET(ARGS_01,
                           ARGS_02,
                           ARGS_03,
                           ARGS_04,
                           ARGS_05,
                           ARGS_06,
                           ARGS_07,
                           ARGS_08,
                           ARGS_09,
                           ARGS_10,
                           ARGS_11)&gt;::Invoker *
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
typename bsl::function&lt;RET(ARGS_01,
                           ARGS_02,
                           ARGS_03,
                           ARGS_04,
                           ARGS_05,
                           ARGS_06,
                           ARGS_07,
                           ARGS_08,
                           ARGS_09,
                           ARGS_10,
                           ARGS_11,
                           ARGS_12)&gt;::Invoker *
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
typename bsl::function&lt;RET(ARGS_01,
                           ARGS_02,
                           ARGS_03,
                           ARGS_04,
                           ARGS_05,
                           ARGS_06,
                           ARGS_07,
                           ARGS_08,
                           ARGS_09,
                           ARGS_10,
                           ARGS_11,
                           ARGS_12,
                           ARGS_13)&gt;::Invoker *
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
typename bsl::function&lt;RET(ARGS_01,
                           ARGS_02,
                           ARGS_03,
                           ARGS_04,
                           ARGS_05,
                           ARGS_06,
                           ARGS_07,
                           ARGS_08,
                           ARGS_09,
                           ARGS_10,
                           ARGS_11,
                           ARGS_12,
                           ARGS_13,
                           ARGS_14)&gt;::Invoker *
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}


template &lt;class RET&gt;
inline
bsl::function&lt;RET()&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}


template &lt;class RET&gt;
inline
bsl::function&lt;RET()&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}


template &lt;class RET&gt;
inline
bsl::function&lt;RET()&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class ARGS_01&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}


template &lt;class RET&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET()&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class ARGS_01&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}


template &lt;class RET&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET()&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}


template &lt;class RET&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET()&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}


template &lt;class RET&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET()&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class ARGS_01&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}


template &lt;class RET&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET()&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}

template &lt;class RET, class ARGS_01&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}


#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES

template &lt;class RET&gt;
inline
bsl::function&lt;RET()&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class ARGS_01&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}


template &lt;class RET&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET()&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

template &lt;class RET, class ARGS_01&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}


#endif

template &lt;class RET&gt;
inline
bsl::function&lt;RET()&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

template &lt;class RET, class ARGS_01&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}


template &lt;class RET&gt;
inline
bsl::function&lt;RET()&gt;&amp;
bsl::function&lt;RET()&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

template &lt;class RET, class ARGS_01&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;&amp;
bsl::function&lt;RET(ARGS_01)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}


#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES

template &lt;class RET&gt;
inline
bsl::function&lt;RET()&gt;&amp;
bsl::function&lt;RET()&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class ARGS_01&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;&amp;
bsl::function&lt;RET(ARGS_01)&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}


template &lt;class RET&gt;
inline
bsl::function&lt;RET()&gt;&amp;
bsl::function&lt;RET()&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

template &lt;class RET, class ARGS_01&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;&amp;
bsl::function&lt;RET(ARGS_01)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}


#endif

template &lt;class RET&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET()&gt;&amp;
bsl::function&lt;RET()&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class ARGS_01&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;&amp;
bsl::function&lt;RET(ARGS_01)&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}


template &lt;class RET&gt;
inline
bsl::function&lt;RET()&gt;&amp;
bsl::function&lt;RET()&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}

template &lt;class RET, class ARGS_01&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;&amp;
bsl::function&lt;RET(ARGS_01)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;&amp;
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}



template &lt;class RET&gt;
inline
RET bsl::function&lt;RET()&gt;::operator()() const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this);
#endif
}

template &lt;class RET, class ARGS_01&gt;
inline
RET bsl::function&lt;RET(ARGS_01)&gt;::operator()(ARGS_01 args_01) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args_01);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args_01);
#endif
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02)&gt;::operator()(ARGS_01 args_01,
                                            ARGS_02 args_02) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args_01,
                               args_02);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args_01,
                           args_02);
#endif
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03)&gt;::operator()(ARGS_01 args_01,
                                            ARGS_02 args_02,
                                            ARGS_03 args_03) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args_01,
                               args_02,
                               args_03);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args_01,
                           args_02,
                           args_03);
#endif
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04)&gt;::operator()(ARGS_01 args_01,
                                            ARGS_02 args_02,
                                            ARGS_03 args_03,
                                            ARGS_04 args_04) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args_01,
                               args_02,
                               args_03,
                               args_04);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args_01,
                           args_02,
                           args_03,
                           args_04);
#endif
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05)&gt;::operator()(ARGS_01 args_01,
                                            ARGS_02 args_02,
                                            ARGS_03 args_03,
                                            ARGS_04 args_04,
                                            ARGS_05 args_05) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args_01,
                               args_02,
                               args_03,
                               args_04,
                               args_05);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args_01,
                           args_02,
                           args_03,
                           args_04,
                           args_05);
#endif
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06)&gt;::operator()(ARGS_01 args_01,
                                            ARGS_02 args_02,
                                            ARGS_03 args_03,
                                            ARGS_04 args_04,
                                            ARGS_05 args_05,
                                            ARGS_06 args_06) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args_01,
                               args_02,
                               args_03,
                               args_04,
                               args_05,
                               args_06);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args_01,
                           args_02,
                           args_03,
                           args_04,
                           args_05,
                           args_06);
#endif
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07)&gt;::operator()(ARGS_01 args_01,
                                            ARGS_02 args_02,
                                            ARGS_03 args_03,
                                            ARGS_04 args_04,
                                            ARGS_05 args_05,
                                            ARGS_06 args_06,
                                            ARGS_07 args_07) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args_01,
                               args_02,
                               args_03,
                               args_04,
                               args_05,
                               args_06,
                               args_07);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args_01,
                           args_02,
                           args_03,
                           args_04,
                           args_05,
                           args_06,
                           args_07);
#endif
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08)&gt;::operator()(ARGS_01 args_01,
                                            ARGS_02 args_02,
                                            ARGS_03 args_03,
                                            ARGS_04 args_04,
                                            ARGS_05 args_05,
                                            ARGS_06 args_06,
                                            ARGS_07 args_07,
                                            ARGS_08 args_08) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args_01,
                               args_02,
                               args_03,
                               args_04,
                               args_05,
                               args_06,
                               args_07,
                               args_08);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args_01,
                           args_02,
                           args_03,
                           args_04,
                           args_05,
                           args_06,
                           args_07,
                           args_08);
#endif
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09)&gt;::operator()(ARGS_01 args_01,
                                            ARGS_02 args_02,
                                            ARGS_03 args_03,
                                            ARGS_04 args_04,
                                            ARGS_05 args_05,
                                            ARGS_06 args_06,
                                            ARGS_07 args_07,
                                            ARGS_08 args_08,
                                            ARGS_09 args_09) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args_01,
                               args_02,
                               args_03,
                               args_04,
                               args_05,
                               args_06,
                               args_07,
                               args_08,
                               args_09);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args_01,
                           args_02,
                           args_03,
                           args_04,
                           args_05,
                           args_06,
                           args_07,
                           args_08,
                           args_09);
#endif
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10)&gt;::operator()(ARGS_01 args_01,
                                            ARGS_02 args_02,
                                            ARGS_03 args_03,
                                            ARGS_04 args_04,
                                            ARGS_05 args_05,
                                            ARGS_06 args_06,
                                            ARGS_07 args_07,
                                            ARGS_08 args_08,
                                            ARGS_09 args_09,
                                            ARGS_10 args_10) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args_01,
                               args_02,
                               args_03,
                               args_04,
                               args_05,
                               args_06,
                               args_07,
                               args_08,
                               args_09,
                               args_10);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args_01,
                           args_02,
                           args_03,
                           args_04,
                           args_05,
                           args_06,
                           args_07,
                           args_08,
                           args_09,
                           args_10);
#endif
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11)&gt;::operator()(ARGS_01 args_01,
                                            ARGS_02 args_02,
                                            ARGS_03 args_03,
                                            ARGS_04 args_04,
                                            ARGS_05 args_05,
                                            ARGS_06 args_06,
                                            ARGS_07 args_07,
                                            ARGS_08 args_08,
                                            ARGS_09 args_09,
                                            ARGS_10 args_10,
                                            ARGS_11 args_11) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args_01,
                               args_02,
                               args_03,
                               args_04,
                               args_05,
                               args_06,
                               args_07,
                               args_08,
                               args_09,
                               args_10,
                               args_11);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args_01,
                           args_02,
                           args_03,
                           args_04,
                           args_05,
                           args_06,
                           args_07,
                           args_08,
                           args_09,
                           args_10,
                           args_11);
#endif
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11,
                      ARGS_12)&gt;::operator()(ARGS_01 args_01,
                                            ARGS_02 args_02,
                                            ARGS_03 args_03,
                                            ARGS_04 args_04,
                                            ARGS_05 args_05,
                                            ARGS_06 args_06,
                                            ARGS_07 args_07,
                                            ARGS_08 args_08,
                                            ARGS_09 args_09,
                                            ARGS_10 args_10,
                                            ARGS_11 args_11,
                                            ARGS_12 args_12) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args_01,
                               args_02,
                               args_03,
                               args_04,
                               args_05,
                               args_06,
                               args_07,
                               args_08,
                               args_09,
                               args_10,
                               args_11,
                               args_12);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args_01,
                           args_02,
                           args_03,
                           args_04,
                           args_05,
                           args_06,
                           args_07,
                           args_08,
                           args_09,
                           args_10,
                           args_11,
                           args_12);
#endif
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11,
                      ARGS_12,
                      ARGS_13)&gt;::operator()(ARGS_01 args_01,
                                            ARGS_02 args_02,
                                            ARGS_03 args_03,
                                            ARGS_04 args_04,
                                            ARGS_05 args_05,
                                            ARGS_06 args_06,
                                            ARGS_07 args_07,
                                            ARGS_08 args_08,
                                            ARGS_09 args_09,
                                            ARGS_10 args_10,
                                            ARGS_11 args_11,
                                            ARGS_12 args_12,
                                            ARGS_13 args_13) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args_01,
                               args_02,
                               args_03,
                               args_04,
                               args_05,
                               args_06,
                               args_07,
                               args_08,
                               args_09,
                               args_10,
                               args_11,
                               args_12,
                               args_13);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args_01,
                           args_02,
                           args_03,
                           args_04,
                           args_05,
                           args_06,
                           args_07,
                           args_08,
                           args_09,
                           args_10,
                           args_11,
                           args_12,
                           args_13);
#endif
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
RET bsl::function&lt;RET(ARGS_01,
                      ARGS_02,
                      ARGS_03,
                      ARGS_04,
                      ARGS_05,
                      ARGS_06,
                      ARGS_07,
                      ARGS_08,
                      ARGS_09,
                      ARGS_10,
                      ARGS_11,
                      ARGS_12,
                      ARGS_13,
                      ARGS_14)&gt;::operator()(ARGS_01 args_01,
                                            ARGS_02 args_02,
                                            ARGS_03 args_03,
                                            ARGS_04 args_04,
                                            ARGS_05 args_05,
                                            ARGS_06 args_06,
                                            ARGS_07 args_07,
                                            ARGS_08 args_08,
                                            ARGS_09 args_09,
                                            ARGS_10 args_10,
                                            ARGS_11 args_11,
                                            ARGS_12 args_12,
                                            ARGS_13 args_13,
                                            ARGS_14 args_14) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args_01,
                               args_02,
                               args_03,
                               args_04,
                               args_05,
                               args_06,
                               args_07,
                               args_08,
                               args_09,
                               args_10,
                               args_11,
                               args_12,
                               args_13,
                               args_14);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args_01,
                           args_02,
                           args_03,
                           args_04,
                           args_05,
                           args_06,
                           args_07,
                           args_08,
                           args_09,
                           args_10,
                           args_11,
                           args_12,
                           args_13,
                           args_14);
#endif
}



#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
template &lt;class RET&gt;
inline
bsl::function&lt;RET()&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}

template &lt;class RET, class ARGS_01&gt;
inline
bsl::function&lt;RET(ARGS_01)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
bsl::function&lt;RET(ARGS_01,
                  ARGS_02,
                  ARGS_03,
                  ARGS_04,
                  ARGS_05,
                  ARGS_06,
                  ARGS_07,
                  ARGS_08,
                  ARGS_09,
                  ARGS_10,
                  ARGS_11,
                  ARGS_12,
                  ARGS_13,
                  ARGS_14)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}

#endif

template &lt;class RET&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET()&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS_01)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12,
                                             ARGS_13)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12,
                                             ARGS_13,
                                             ARGS_14)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}


template &lt;class RET&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET()&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12,
                                             ARGS_13)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12,
                                             ARGS_13,
                                             ARGS_14)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}


template &lt;class RET&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET()&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS_01)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12,
                                             ARGS_13)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12,
                                             ARGS_13,
                                             ARGS_14)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}


template &lt;class RET&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET()&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12,
                                             ARGS_13)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS_01,
                                             ARGS_02,
                                             ARGS_03,
                                             ARGS_04,
                                             ARGS_05,
                                             ARGS_06,
                                             ARGS_07,
                                             ARGS_08,
                                             ARGS_09,
                                             ARGS_10,
                                             ARGS_11,
                                             ARGS_12,
                                             ARGS_13,
                                             ARGS_14)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}


template &lt;class RET&gt;
inline
void bsl::swap(bsl::function&lt;RET()&gt;&amp; a, bsl::function&lt;RET()&gt;&amp; b)
{
    a.swap(b);
}

template &lt;class RET, class ARGS_01&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS_01)&gt;&amp; a, bsl::function&lt;RET(ARGS_01)&gt;&amp; b)
{
    a.swap(b);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS_01,
                                 ARGS_02)&gt;&amp; a, bsl::function&lt;RET(ARGS_01,
                                                                 ARGS_02)&gt;&amp; b)
{
    a.swap(b);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS_01,
                                 ARGS_02,
                                 ARGS_03)&gt;&amp; a, bsl::function&lt;RET(ARGS_01,
                                                                 ARGS_02,
                                                                 ARGS_03)&gt;&amp; b)
{
    a.swap(b);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS_01,
                                 ARGS_02,
                                 ARGS_03,
                                 ARGS_04)&gt;&amp; a, bsl::function&lt;RET(ARGS_01,
                                                                 ARGS_02,
                                                                 ARGS_03,
                                                                 ARGS_04)&gt;&amp; b)
{
    a.swap(b);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS_01,
                                 ARGS_02,
                                 ARGS_03,
                                 ARGS_04,
                                 ARGS_05)&gt;&amp; a, bsl::function&lt;RET(ARGS_01,
                                                                 ARGS_02,
                                                                 ARGS_03,
                                                                 ARGS_04,
                                                                 ARGS_05)&gt;&amp; b)
{
    a.swap(b);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS_01,
                                 ARGS_02,
                                 ARGS_03,
                                 ARGS_04,
                                 ARGS_05,
                                 ARGS_06)&gt;&amp; a, bsl::function&lt;RET(ARGS_01,
                                                                 ARGS_02,
                                                                 ARGS_03,
                                                                 ARGS_04,
                                                                 ARGS_05,
                                                                 ARGS_06)&gt;&amp; b)
{
    a.swap(b);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS_01,
                                 ARGS_02,
                                 ARGS_03,
                                 ARGS_04,
                                 ARGS_05,
                                 ARGS_06,
                                 ARGS_07)&gt;&amp; a, bsl::function&lt;RET(ARGS_01,
                                                                 ARGS_02,
                                                                 ARGS_03,
                                                                 ARGS_04,
                                                                 ARGS_05,
                                                                 ARGS_06,
                                                                 ARGS_07)&gt;&amp; b)
{
    a.swap(b);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS_01,
                                 ARGS_02,
                                 ARGS_03,
                                 ARGS_04,
                                 ARGS_05,
                                 ARGS_06,
                                 ARGS_07,
                                 ARGS_08)&gt;&amp; a, bsl::function&lt;RET(ARGS_01,
                                                                 ARGS_02,
                                                                 ARGS_03,
                                                                 ARGS_04,
                                                                 ARGS_05,
                                                                 ARGS_06,
                                                                 ARGS_07,
                                                                 ARGS_08)&gt;&amp; b)
{
    a.swap(b);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS_01,
                                 ARGS_02,
                                 ARGS_03,
                                 ARGS_04,
                                 ARGS_05,
                                 ARGS_06,
                                 ARGS_07,
                                 ARGS_08,
                                 ARGS_09)&gt;&amp; a, bsl::function&lt;RET(ARGS_01,
                                                                 ARGS_02,
                                                                 ARGS_03,
                                                                 ARGS_04,
                                                                 ARGS_05,
                                                                 ARGS_06,
                                                                 ARGS_07,
                                                                 ARGS_08,
                                                                 ARGS_09)&gt;&amp; b)
{
    a.swap(b);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS_01,
                                 ARGS_02,
                                 ARGS_03,
                                 ARGS_04,
                                 ARGS_05,
                                 ARGS_06,
                                 ARGS_07,
                                 ARGS_08,
                                 ARGS_09,
                                 ARGS_10)&gt;&amp; a, bsl::function&lt;RET(ARGS_01,
                                                                 ARGS_02,
                                                                 ARGS_03,
                                                                 ARGS_04,
                                                                 ARGS_05,
                                                                 ARGS_06,
                                                                 ARGS_07,
                                                                 ARGS_08,
                                                                 ARGS_09,
                                                                 ARGS_10)&gt;&amp; b)
{
    a.swap(b);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS_01,
                                 ARGS_02,
                                 ARGS_03,
                                 ARGS_04,
                                 ARGS_05,
                                 ARGS_06,
                                 ARGS_07,
                                 ARGS_08,
                                 ARGS_09,
                                 ARGS_10,
                                 ARGS_11)&gt;&amp; a, bsl::function&lt;RET(ARGS_01,
                                                                 ARGS_02,
                                                                 ARGS_03,
                                                                 ARGS_04,
                                                                 ARGS_05,
                                                                 ARGS_06,
                                                                 ARGS_07,
                                                                 ARGS_08,
                                                                 ARGS_09,
                                                                 ARGS_10,
                                                                 ARGS_11)&gt;&amp; b)
{
    a.swap(b);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS_01,
                                 ARGS_02,
                                 ARGS_03,
                                 ARGS_04,
                                 ARGS_05,
                                 ARGS_06,
                                 ARGS_07,
                                 ARGS_08,
                                 ARGS_09,
                                 ARGS_10,
                                 ARGS_11,
                                 ARGS_12)&gt;&amp; a, bsl::function&lt;RET(ARGS_01,
                                                                 ARGS_02,
                                                                 ARGS_03,
                                                                 ARGS_04,
                                                                 ARGS_05,
                                                                 ARGS_06,
                                                                 ARGS_07,
                                                                 ARGS_08,
                                                                 ARGS_09,
                                                                 ARGS_10,
                                                                 ARGS_11,
                                                                 ARGS_12)&gt;&amp; b)
{
    a.swap(b);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS_01,
                                 ARGS_02,
                                 ARGS_03,
                                 ARGS_04,
                                 ARGS_05,
                                 ARGS_06,
                                 ARGS_07,
                                 ARGS_08,
                                 ARGS_09,
                                 ARGS_10,
                                 ARGS_11,
                                 ARGS_12,
                                 ARGS_13)&gt;&amp; a, bsl::function&lt;RET(ARGS_01,
                                                                 ARGS_02,
                                                                 ARGS_03,
                                                                 ARGS_04,
                                                                 ARGS_05,
                                                                 ARGS_06,
                                                                 ARGS_07,
                                                                 ARGS_08,
                                                                 ARGS_09,
                                                                 ARGS_10,
                                                                 ARGS_11,
                                                                 ARGS_12,
                                                                 ARGS_13)&gt;&amp; b)
{
    a.swap(b);
}

template &lt;class RET, class ARGS_01,
                     class ARGS_02,
                     class ARGS_03,
                     class ARGS_04,
                     class ARGS_05,
                     class ARGS_06,
                     class ARGS_07,
                     class ARGS_08,
                     class ARGS_09,
                     class ARGS_10,
                     class ARGS_11,
                     class ARGS_12,
                     class ARGS_13,
                     class ARGS_14&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS_01,
                                 ARGS_02,
                                 ARGS_03,
                                 ARGS_04,
                                 ARGS_05,
                                 ARGS_06,
                                 ARGS_07,
                                 ARGS_08,
                                 ARGS_09,
                                 ARGS_10,
                                 ARGS_11,
                                 ARGS_12,
                                 ARGS_13,
                                 ARGS_14)&gt;&amp; a, bsl::function&lt;RET(ARGS_01,
                                                                 ARGS_02,
                                                                 ARGS_03,
                                                                 ARGS_04,
                                                                 ARGS_05,
                                                                 ARGS_06,
                                                                 ARGS_07,
                                                                 ARGS_08,
                                                                 ARGS_09,
                                                                 ARGS_10,
                                                                 ARGS_11,
                                                                 ARGS_12,
                                                                 ARGS_13,
                                                                 ARGS_14)&gt;&amp; b)
{
    a.swap(b);
}

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template &lt;class RET, class... ARGS&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS...)&gt;::functionPtrInvoker(const Function_Rep *rep,
               typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args)
{
    FUNC f = reinterpret_cast&lt;FUNC&gt;(rep-&gt;d_objbuf.d_func_p);

    return static_cast&lt;RET&gt;(f(BloombergLP::bslmf::ForwardingTypeUtil&lt;ARGS&gt;::
                              forwardToTarget(args)...));
}

template &lt;class RET, class... ARGS&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS...)&gt;::memFuncPtrInvoker(const Function_Rep *rep,
               typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args)
{
    using namespace BloombergLP;

    FUNC f = (const FUNC&amp;)(rep-&gt;d_objbuf.d_memFunc_p);
    typedef typename bslmf::NthParameter&lt;0, ARGS...&gt;::Type ObjType;
    typedef Function_MemFuncInvoke&lt;FUNC, ObjType&gt; InvokeType;
    BSLMF_ASSERT(sizeof...(ARGS) == InvokeType::NUM_ARGS + 1);
    return (RET) InvokeType::invoke(f, args...);
}

template &lt;class RET, class... ARGS&gt;
template &lt;class FUNC&gt;
inline
RET bsl::function&lt;RET(ARGS...)&gt;::inplaceFunctorInvoker(const Function_Rep *rep,
               typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args)
{
    FUNC&amp; f = reinterpret_cast&lt;FUNC&amp;&gt;(rep-&gt;d_objbuf);

    return static_cast&lt;RET&gt;(f(args...));
}

template &lt;class RET, class... ARGS&gt;
template &lt;class FUNC&gt;
inline
RET
bsl::function&lt;RET(ARGS...)&gt;::outofplaceFunctorInvoker(const Function_Rep *rep,
               typename BloombergLP::bslmf::ForwardingType&lt;ARGS&gt;::Type... args)
{
    FUNC&amp; f = *reinterpret_cast&lt;FUNC*&gt;(rep-&gt;d_objbuf.d_object_p);
    return static_cast&lt;RET&gt;(f(args...));
}

template &lt;class RET, class... ARGS&gt;
inline
void bsl::function&lt;RET(ARGS...)&gt;::setInvoker(Invoker *p)
{
    BSLMF_ASSERT(sizeof(Invoker*) == sizeof(d_invoker_p));

    typedef void (*VoidFn)();

    d_invoker_p = reinterpret_cast&lt;VoidFn&gt;(p);
}

template &lt;class RET, class... ARGS&gt;
inline
typename bsl::function&lt;RET(ARGS...)&gt;::Invoker *
bsl::function&lt;RET(ARGS...)&gt;::invoker() const
{
    return reinterpret_cast&lt;Invoker*&gt;(d_invoker_p);
}

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function() BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(nullptr_t) BSLS_NOTHROW_SPEC
{
    using namespace BloombergLP;

    d_allocator_p     = bslma::Default::defaultAllocator();
    d_allocManager_p  = &amp;unownedAllocManager;
    setInvoker(NULL);
}

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(const function&amp; other)
{
    using namespace BloombergLP;
    copyInit(bslma::Default::defaultAllocator(), other);
}

template &lt;class RET, class... ARGS&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(FUNC func)
{
    using namespace BloombergLP;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, bslma::Default::defaultAllocator(),
            integral_constant&lt;AllocCategory, e_BSLMA_ALLOC_PTR&gt;());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
}

template &lt;class RET, class... ARGS&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class... ARGS&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(allocator_arg_t, const ALLOC&amp; alloc,
                                      nullptr_t)
{
    setInvoker(NULL);

    typedef Function_AllocTraits&lt;ALLOC&gt; Traits;
    initRep(0, typename Traits::Type(alloc), typename Traits::Category());
}

template &lt;class RET, class... ARGS&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp;    alloc,
                                      const function&amp; other)
{
    copyInit(alloc, other);
}

template &lt;class RET, class... ARGS&gt;
template&lt;class FUNC, class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      FUNC         func)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    setInvoker(invokerForFunc(func));

    std::size_t sooFuncSize = invoker() ? Soo::SooFuncSize&lt;FUNC&gt;::VALUE : 0;

    initRep(sooFuncSize, typename AllocTraits::Type(alloc),
            typename AllocTraits::Category());

    if (invoker()) {
        d_funcManager_p = getFunctionManager&lt;FUNC&gt;();
        d_funcManager_p(e_MOVE_CONSTRUCT, this, &amp;func);
    }
    else {
        d_funcManager_p = NULL;
    }
}

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(function&amp;&amp; other)
{
    moveInit(other);
}

template &lt;class RET, class... ARGS&gt;
template&lt;class ALLOC&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::function(allocator_arg_t,
                                      const ALLOC&amp; alloc,
                                      function&amp;&amp;   other)
{
    typedef Function_AllocTraits&lt;ALLOC&gt; AllocTraits;

    if (other.equalAlloc(alloc, typename AllocTraits::Category())) {
        moveInit(other);
    }
    else {
        copyInit(typename AllocTraits::Type(alloc), other);
    }
}

#endif

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::~function()
{
    BSLS_ASSERT(invoker() || ! d_funcManager_p);
    BSLS_ASSERT(d_allocator_p);

    if (d_funcManager_p) {
        d_funcManager_p(e_DESTROY, this, PtrOrSize_t());
    }
}

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;&amp;
bsl::function&lt;RET(ARGS...)&gt;::operator=(const function&amp; rhs)
{
    Function_Rep::assign(const_cast&lt;function*&gt;(&amp;rhs), e_COPY_CONSTRUCT);

    return *this;
}

#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;&amp;
bsl::function&lt;RET(ARGS...)&gt;::operator=(function&amp; rhs)
{
    return operator=(const_cast&lt;const function&amp;&gt;(rhs));
}

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;&amp;
bsl::function&lt;RET(ARGS...)&gt;::operator=(function&amp;&amp; rhs)
{
    if (d_allocManager_p(e_IS_EQUAL, this, rhs.d_allocator_p).asSize_t()) {
        this-&gt;swap(rhs);
    }
    else {
        Function_Rep::assign(&amp;rhs, e_MOVE_CONSTRUCT);
    }

    return *this;
}

#endif

template &lt;class RET, class... ARGS&gt;
template&lt;class FUNC&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;&amp;
bsl::function&lt;RET(ARGS...)&gt;::operator=(
                                  BSLS_COMPILERFEATURES_FORWARD_REF(FUNC) func)
{
    Function_Rep tempRep;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_reference&lt;FUNC&gt;::type
        &gt;::type FuncType;

    Invoker *invoker_p = invokerForFunc(func);
    tempRep.d_funcManager_p = invoker_p ? getFunctionManager&lt;FuncType&gt;() :NULL;

    this-&gt;d_allocManager_p(e_INIT_REP, &amp;tempRep, this-&gt;d_allocator_p);

    if (tempRep.d_funcManager_p) {
        FuncType *funcAddr = const_cast&lt;FuncType*&gt;(&amp;func);
#ifdef BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
        if (bsl::is_rvalue_reference&lt;BSLS_COMPILERFEATURES_FORWARD_REF(FUNC)
                                     &gt;::value) {
            tempRep.d_funcManager_p(e_MOVE_CONSTRUCT, &amp;tempRep, funcAddr);
        }
        else
#endif
        {
            tempRep.d_funcManager_p(e_COPY_CONSTRUCT, &amp;tempRep, funcAddr);
        }
    }

    tempRep.swap(*this);
    if (tempRep.d_funcManager_p) {
        tempRep.d_funcManager_p(e_DESTROY, &amp;tempRep, PtrOrSize_t());
    }

    setInvoker(invoker_p);

    return *this;
}

template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;&amp;
bsl::function&lt;RET(ARGS...)&gt;::operator=(nullptr_t)
{
    setInvoker(NULL);
    makeEmpty();
    return *this;
}


template &lt;class RET, class... ARGS&gt;
inline
RET bsl::function&lt;RET(ARGS...)&gt;::operator()(ARGS... args) const
{
#ifdef BDE_BUILD_TARGET_EXC

    if (invoker()) {
        return invoker()(this, args...);
    }
    else {
        BSLS_THROW(bad_function_call());
    }

#else
    BSLS_ASSERT_OPT(invoker());
    return invoker()(this, args...);
#endif
}


#ifdef BSLS_COMPILERFEATURES_SUPPORT_OPERATOR_EXPLICIT
template &lt;class RET, class... ARGS&gt;
inline
bsl::function&lt;RET(ARGS...)&gt;::operator bool() const BSLS_NOTHROW_SPEC
{
    return invoker();
}
#endif

template &lt;class RET, class... ARGS&gt;
inline
bool bsl::operator==(const bsl::function&lt;RET(ARGS...)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class... ARGS&gt;
inline
bool bsl::operator==(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS...)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return !f;
}

template &lt;class RET, class... ARGS&gt;
inline
bool bsl::operator!=(const bsl::function&lt;RET(ARGS...)&gt;&amp; f,
                     bsl::nullptr_t) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class... ARGS&gt;
inline
bool bsl::operator!=(bsl::nullptr_t,
                     const bsl::function&lt;RET(ARGS...)&gt;&amp; f) BSLS_NOTHROW_SPEC
{
    return static_cast&lt;bool&gt;(f);
}

template &lt;class RET, class... ARGS&gt;
inline
void bsl::swap(bsl::function&lt;RET(ARGS...)&gt;&amp; a, bsl::function&lt;RET(ARGS...)&gt;&amp; b)
{
    a.swap(b);
}

// }}} END GENERATED CODE
#endif

// TRAITS

namespace BloombergLP {
namespace bslmf {

template &lt;class FUNC&gt;
struct IsBitwiseMoveable&lt;bsl::Function_NothrowWrapper&lt;FUNC&gt; &gt;
   : IsBitwiseMoveable&lt;FUNC&gt;::type
{
};

} // close namespace bslmf
} // close namespace BloombergLP

#endif // ! defined(INCLUDED_BSLSTL_FUNCTION)

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
