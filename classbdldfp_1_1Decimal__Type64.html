<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdldfp::Decimal_Type64</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdldfp.html">bdldfp</a>      </li>
      <li><a class="el" href="classbdldfp_1_1Decimal__Type64.html">bdldfp::Decimal_Type64</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdldfp::Decimal_Type64 Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdldfp::Decimal_Type64" -->
<p><code>#include &lt;<a class="el" href="bdldfp__decimal_8h_source.html">bdldfp_decimal.h</a>&gt;</code></p>

<p><a href="classbdldfp_1_1Decimal__Type64-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a889a6bf6c369f6fa3fc1c8f40f75762e">BSLALG_DECLARE_NESTED_TRAITS</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>, <a class="el" href="structbslalg_1_1TypeTraitBitwiseCopyable.html">bslalg::TypeTraitBitwiseCopyable</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#ad1e50638f1d5976a4f505a28f20394a4">Decimal_Type64</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a2620f806eb4c10367766aa409d743e97">Decimal_Type64</a> (<a class="el" href="classbdldfp_1_1DecimalImpUtil.html#a48f434ac05252ee1e162dfb251cd4074">DecimalImpUtil::ValueType64</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#aa1916394e5f679908edb45596c13d215">Decimal_Type64</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#acdbdcefbfc62af30242b57465cfe75b2">Decimal_Type64</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a862e90d7912d4cce88c4331d55d2d8ab">Decimal_Type64</a> (float other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#aef035ba1b52b1b1ef627ac99f2c9c64f">Decimal_Type64</a> (double other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a3169cc7ec725b1043c92558580a35b7d">Decimal_Type64</a> (int other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#ab181adeba197af34d96f5bbeb6597e10">Decimal_Type64</a> (unsigned int other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a27a1bd047451ff900f35778d7da1e726">Decimal_Type64</a> (long other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a885de22c4b96a5d83eb8088ec119a8a2">Decimal_Type64</a> (unsigned long other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a544df768a557375da47d1c9c7d03e380">Decimal_Type64</a> (long long other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a61ce9f2fbbe0e3c20bf5971cc5b135d0">Decimal_Type64</a> (unsigned long long other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a9ced4689689fbaa2df36208a182d8b60">Decimal64_Type</a> (const Decimal64_Type &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#ab8ec184abc8e90e7b56739c82faae473">~Decimal64_Type</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Decimal64_Type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#adc029ca0483a22faa4d7a328d8596e29">operator=</a> (const Decimal64_Type &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a1b1a25a5eb07695518559aada123233c">operator++</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a5a5ed8a2a8b0d6ef2c87abfe8989b1d1">operator--</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#ad02b86fa2ecc044752fd4691e0ca4646">operator+=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a770fc00079bdb131c65ff3e8be4e694d">operator+=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a612f7f11172eabaa412c7ebd9ef1c3c3">operator+=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a2b35af080e78af5b3677f10846b01eff">operator+=</a> (int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#af85cfb47b14b7b08654b2f404b115c6e">operator+=</a> (unsigned int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#acbe4ec1b88d98cd7308e4fefece398a1">operator+=</a> (long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a67e11cb0725e821ff93aa2406433d133">operator+=</a> (unsigned long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a12843a6dfb47f4aef3529569e7d4630e">operator+=</a> (long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a495f432f5479c5492de7bdc1a9a028aa">operator+=</a> (unsigned long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a9dddc0f1d360cae72894cd08708d4553">operator-=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a843a419dd12b2e5e50472255e90ec534">operator-=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a002af3368f47312ad8114cbce54c14b3">operator-=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a4284c221a0b0f732fa97456840f97a88">operator-=</a> (int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a7b9a5f5135b1fe1d588d896505087bfe">operator-=</a> (unsigned int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a2ac45ab4fc57cf3d5a2903ed2befcd21">operator-=</a> (long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#ad59d32662892c5f97b69b0593d9948ee">operator-=</a> (unsigned long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a30c593a3e72b0c91f83c7bbc285192be">operator-=</a> (long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a932a02cc2cacdb698c96d645f4907238">operator-=</a> (unsigned long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a1982627cea293ea55a17b1d0f424b55b">operator*=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a78bd60dcc0397562dce4f0440e6153ac">operator*=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a2656a9e8819c4dd3861f206654d23e1d">operator*=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a13599aba57ae78ea67167c76c220c283">operator*=</a> (int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a623e3f7ffce84e5ffe074f8f427627d6">operator*=</a> (unsigned int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a1d212bb5a825ac0430ee10c88b916ad3">operator*=</a> (long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a04c1b7c3fdee9145cdd2ed99180c7a67">operator*=</a> (unsigned long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a1a86d00b33bd066e71de48d982ab8be4">operator*=</a> (long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#ab8e933ffe66ae1bbe1b6b93e37665fb3">operator*=</a> (unsigned long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a75285185c0b601d6c76de7a44fcaad29">operator/=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a5641a65542bcc590dded9a71bfc4806c">operator/=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a083cd10fe320253cec12c42b10251193">operator/=</a> (<a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#ad0340e800b0ffa7c02cc1f299f298c1d">operator/=</a> (int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a7a5533b78cd069c829d4b57523b697e0">operator/=</a> (unsigned int rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a2799eab6c2327dbb7f3e5985b8ea2a27">operator/=</a> (long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#abf8f46ade949a8543b06d09d8395fc08">operator/=</a> (unsigned long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a33b490fe129a4f54c78f1447d58190ec">operator/=</a> (long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a682a560b69dbb7e4fc7037f1d08cfaf0">operator/=</a> (unsigned long long rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1DecimalImpUtil.html#a48f434ac05252ee1e162dfb251cd4074">DecimalImpUtil::ValueType64</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a0da76a87ac9c84f9463c8b63f5a3f3d7">data</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a65f87dc52e13b1d1b82fce3d37092755">bdexStreamIn</a> (STREAM &amp;stream, int version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbdldfp_1_1DecimalImpUtil.html#a48f434ac05252ee1e162dfb251cd4074">DecimalImpUtil::ValueType64</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a23b2f4d74ffba1c7161c1b6adad05f35">data</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdldfp_1_1DecimalImpUtil.html#a48f434ac05252ee1e162dfb251cd4074">DecimalImpUtil::ValueType64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#ae2b19f190606680ef9d692e873d787c4">value</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#aa3bec29c6e310c0ea8f461b671fd91a6">bdexStreamOut</a> (STREAM &amp;stream, int version) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a1999c71bbe70e467540cbdb01b57f0df">print</a> (bsl::ostream &amp;stream, int level=0, int spacesPerLevel=4) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a2cc07921dc3044183b184dc85ee88ad3">maxSupportedBdexVersion</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdldfp_1_1Decimal__Type64.html#a7e7076b006f5089688d0a2e017ac581a">maxSupportedBdexVersion</a> (int versionSelector)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This value-semantic class implements the IEEE-754 64 bit decimal floating-point format arithmetic type. This class is a standard layout type that is <code>const</code> thread-safe and exception-neutral. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad1e50638f1d5976a4f505a28f20394a4"></a><!-- doxytag: member="bdldfp::Decimal_Type64::Decimal_Type64" ref="ad1e50638f1d5976a4f505a28f20394a4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdldfp::Decimal_Type64::Decimal_Type64 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>Decimal64_Type</code> object having the value positive zero, and 0 exponent (quantum 1e-15). </p>

</div>
</div>
<a class="anchor" id="a2620f806eb4c10367766aa409d743e97"></a><!-- doxytag: member="bdldfp::Decimal_Type64::Decimal_Type64" ref="a2620f806eb4c10367766aa409d743e97" args="(DecimalImpUtil::ValueType64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdldfp::Decimal_Type64::Decimal_Type64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1DecimalImpUtil.html#a48f434ac05252ee1e162dfb251cd4074">DecimalImpUtil::ValueType64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IMPLICIT: Create a <code>Decimal64_Type</code> object having the specified <code>value</code>. </p>

</div>
</div>
<a class="anchor" id="aa1916394e5f679908edb45596c13d215"></a><!-- doxytag: member="bdldfp::Decimal_Type64::Decimal_Type64" ref="aa1916394e5f679908edb45596c13d215" args="(Decimal32 other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdldfp::Decimal_Type64::Decimal_Type64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a>&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IMPLICIT: Create a <code>Decimal64_Type</code> object having the value of the specified <code>other</code> following the conversion rules defined by IEEE-754:</p>
<ul>
<li>
If <code>other</code> is NaN, initialize this object to a NaN.  </li>
<li>
Otherwise if <code>other</code> is infinity (positive or negative), then initialize this object to infinity with the same sign.  </li>
<li>
Otherwise if <code>other</code> is zero, then initialize this object to zero with the same sign.  </li>
<li>
Otherwise initialize this object to the value of the <code>other</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="acdbdcefbfc62af30242b57465cfe75b2"></a><!-- doxytag: member="bdldfp::Decimal_Type64::Decimal_Type64" ref="acdbdcefbfc62af30242b57465cfe75b2" args="(Decimal128 other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdldfp::Decimal_Type64::Decimal_Type64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>Decimal64_Type</code> object having the value closest to the value of the specified <code>other</code> following the conversion rules defined by IEEE-754:</p>
<ul>
<li>
If <code>other</code> is NaN, initialize this object to a NaN.  </li>
<li>
Otherwise if <code>other</code> is infinity (positive or negative), then initialize this object to infinity with the same sign.  </li>
<li>
Otherwise if <code>other</code> is zero, then initialize this object to zero with the same sign.  </li>
<li>
Otherwise if <code>other</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and initialize this object to infinity with the same sign as <code>other</code>.  </li>
<li>
Otherwise if <code>other</code> has an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal64&gt;min()</code> then raise the "underflow" floating-point exception and initialize this object to zero with the same sign as <code>other</code>.  </li>
<li>
Otherwise if <code>other</code> has a value that has more significant digits than <code>std::numeric_limits&lt;Decimal64&gt;max_digit</code> then raise the "inexact" floating-point exception and initialize this object to the value of <code>other</code> rounded according to the rounding direction.  </li>
<li>
Otherwise initialize this object to the value as the <code>other</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a862e90d7912d4cce88c4331d55d2d8ab"></a><!-- doxytag: member="bdldfp::Decimal_Type64::Decimal_Type64" ref="a862e90d7912d4cce88c4331d55d2d8ab" args="(float other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdldfp::Decimal_Type64::Decimal_Type64 </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aef035ba1b52b1b1ef627ac99f2c9c64f"></a><!-- doxytag: member="bdldfp::Decimal_Type64::Decimal_Type64" ref="aef035ba1b52b1b1ef627ac99f2c9c64f" args="(double other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdldfp::Decimal_Type64::Decimal_Type64 </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>Decimal64_Type</code> object having the value closest to the value of the specified <code>other</code> value. <em>Warning:</em> clients requiring a conversion for an exact decimal value should use <code>bdldfp_decimalconverutil</code> (see <em>WARNING</em>: Conversions from <code>float</code> and <code>double</code>}. This conversion follows the conversion rules as defined by IEEE-754:</p>
<ul>
<li>
If <code>other</code> is NaN, initialize this object to a NaN.  </li>
<li>
Otherwise if <code>other</code> is infinity (positive or negative), then initialize this object to infinity value with the same sign.  </li>
<li>
Otherwise if <code>other</code> has a zero value, then initialize this object to zero with the same sign.  </li>
<li>
Otherwise if <code>other</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and initialize this object to infinity with the same sign as <code>other</code>.  </li>
<li>
Otherwise if <code>other</code> has an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal64&gt;min()</code> then raise the "underflow" floating-point exception and initialize this object to zero with the same sign as <code>other</code>.  </li>
<li>
Otherwise if <code>other</code> has a value that needs more than <code>std::numeric_limits&lt;Decimal64&gt;max_digit</code> significant decimal digits to represent then raise the "inexact" floating-point exception and initialize this object to the value of <code>other</code> rounded according to the rounding direction.  </li>
<li>
Otherwise initialize this object to the value of the <code>other</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a3169cc7ec725b1043c92558580a35b7d"></a><!-- doxytag: member="bdldfp::Decimal_Type64::Decimal_Type64" ref="a3169cc7ec725b1043c92558580a35b7d" args="(int other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdldfp::Decimal_Type64::Decimal_Type64 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab181adeba197af34d96f5bbeb6597e10"></a><!-- doxytag: member="bdldfp::Decimal_Type64::Decimal_Type64" ref="ab181adeba197af34d96f5bbeb6597e10" args="(unsigned int other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdldfp::Decimal_Type64::Decimal_Type64 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a27a1bd047451ff900f35778d7da1e726"></a><!-- doxytag: member="bdldfp::Decimal_Type64::Decimal_Type64" ref="a27a1bd047451ff900f35778d7da1e726" args="(long other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdldfp::Decimal_Type64::Decimal_Type64 </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a885de22c4b96a5d83eb8088ec119a8a2"></a><!-- doxytag: member="bdldfp::Decimal_Type64::Decimal_Type64" ref="a885de22c4b96a5d83eb8088ec119a8a2" args="(unsigned long other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdldfp::Decimal_Type64::Decimal_Type64 </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a544df768a557375da47d1c9c7d03e380"></a><!-- doxytag: member="bdldfp::Decimal_Type64::Decimal_Type64" ref="a544df768a557375da47d1c9c7d03e380" args="(long long other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdldfp::Decimal_Type64::Decimal_Type64 </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a61ce9f2fbbe0e3c20bf5971cc5b135d0"></a><!-- doxytag: member="bdldfp::Decimal_Type64::Decimal_Type64" ref="a61ce9f2fbbe0e3c20bf5971cc5b135d0" args="(unsigned long long other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdldfp::Decimal_Type64::Decimal_Type64 </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>Decimal64_Type</code> object having the value closest to the value of the specified <code>other</code> following the conversion rules as defined by IEEE-754:</p>
<ul>
<li>
If <code>other</code> is zero then initialize this object to positive zero with a 0 exponent (quantum 1e-15).  </li>
<li>
Otherwise if <code>other</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and initialize this object to infinity with the same sign as <code>other</code>.  </li>
<li>
Otherwise if <code>other</code> has a value that is not exactly representable using <code>std::numeric_limits&lt;Decimal64&gt;max_digit</code> decimal digits then raise the "inexact" floating-point exception and initialize this object to the value of <code>other</code> rounded according to the rounding direction.  </li>
<li>
Otherwise initialize this object to the value of the <code>other</code>.  </li>
</ul>
<p>The exponent 0 (quantum 1e-15) is preferred during conversion unless it would cause unnecessary loss of precision. </p>

</div>
</div>
<a class="anchor" id="ab8ec184abc8e90e7b56739c82faae473"></a><!-- doxytag: member="bdldfp::Decimal_Type64::~Decimal64_Type" ref="ab8ec184abc8e90e7b56739c82faae473" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdldfp::Decimal_Type64::~Decimal64_Type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2cc07921dc3044183b184dc85ee88ad3"></a><!-- doxytag: member="bdldfp::Decimal_Type64::maxSupportedBdexVersion" ref="a2cc07921dc3044183b184dc85ee88ad3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdldfp::Decimal_Type64::maxSupportedBdexVersion </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7e7076b006f5089688d0a2e017ac581a"></a><!-- doxytag: member="bdldfp::Decimal_Type64::maxSupportedBdexVersion" ref="a7e7076b006f5089688d0a2e017ac581a" args="(int versionSelector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdldfp::Decimal_Type64::maxSupportedBdexVersion </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>versionSelector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum valid BDEX format version, as indicated by the specified <code>versionSelector</code>, to be passed to the <code>bdexStreamOut</code> method. Note that it is highly recommended that <code>versionSelector</code> be formatted as "YYYYMMDD", a date representation. Also note that <code>versionSelector</code> should be a <em>compile</em>-time-chosen value that selects a format version supported by both externalizer and unexternalizer. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a889a6bf6c369f6fa3fc1c8f40f75762e"></a><!-- doxytag: member="bdldfp::Decimal_Type64::BSLALG_DECLARE_NESTED_TRAITS" ref="a889a6bf6c369f6fa3fc1c8f40f75762e" args="(Decimal_Type64, bslalg::TypeTraitBitwiseCopyable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdldfp::Decimal_Type64::BSLALG_DECLARE_NESTED_TRAITS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1TypeTraitBitwiseCopyable.html">bslalg::TypeTraitBitwiseCopyable</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9ced4689689fbaa2df36208a182d8b60"></a><!-- doxytag: member="bdldfp::Decimal_Type64::Decimal64_Type" ref="a9ced4689689fbaa2df36208a182d8b60" args="(const Decimal64_Type &amp;original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdldfp::Decimal_Type64::Decimal64_Type </td>
          <td>(</td>
          <td class="paramtype">const Decimal64_Type &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>Decimal64_Type</code> object that is a copy of the specified <code>original</code> as defined by the <code>copy</code> operation of IEEE-754 2008:</p>
<ul>
<li>
If <code>other</code> is NaN, initialize this object to a NaN.  </li>
<li>
Otherwise initialize this object to the value of the <code>other</code>.  </li>
</ul>
<p>Note that since floating-point types may be NaN, and NaNs are unordered (do not compare equal even to themselves) it is possible that a copy of a decimal will not compare equal to the original; however it will behave as the original. </p>

</div>
</div>
<a class="anchor" id="adc029ca0483a22faa4d7a328d8596e29"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator=" ref="adc029ca0483a22faa4d7a328d8596e29" args="(const Decimal64_Type &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Decimal64_Type&amp; bdldfp::Decimal_Type64::operator= </td>
          <td>(</td>
          <td class="paramtype">const Decimal64_Type &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make this object a copy of the specified <code>rhs</code> as defined by the <code>copy</code> operation of IEEE-754 2008 and return a reference providing modifiable access to this object.</p>
<ul>
<li>
If <code>other</code> is NaN, set this object to a NaN.  </li>
<li>
Otherwise set this object to the value of the <code>other</code>.  </li>
</ul>
<p>Note that since floating-point types may be NaN, and NaNs are unordered (do not compare equal even to themselves) it is possible that, after an assignment, a decimal will not compare equal to the original; however it will behave as the original. </p>

</div>
</div>
<a class="anchor" id="a1b1a25a5eb07695518559aada123233c"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator++" ref="a1b1a25a5eb07695518559aada123233c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator++ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add 1.0 to the value of this object and return a reference to it. Note that this is a floating-point value so this operations may not change the value of this object at all (if the value is large) or it may seem to just set it to 1.0 (if the original value is small). </p>

</div>
</div>
<a class="anchor" id="a5a5ed8a2a8b0d6ef2c87abfe8989b1d1"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator&#45;&#45;" ref="a5a5ed8a2a8b0d6ef2c87abfe8989b1d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator-- </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add -1.0 to the value of this object and return a reference to it. Note that this is a floating-point value so this operations may not change the value of this object at all (if the value is large) or it may seem to just set it to -1.0 (if the original value is small). </p>

</div>
</div>
<a class="anchor" id="ad02b86fa2ecc044752fd4691e0ca4646"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator+=" ref="ad02b86fa2ecc044752fd4691e0ca4646" args="(Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a770fc00079bdb131c65ff3e8be4e694d"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator+=" ref="a770fc00079bdb131c65ff3e8be4e694d" args="(Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a612f7f11172eabaa412c7ebd9ef1c3c3"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator+=" ref="a612f7f11172eabaa412c7ebd9ef1c3c3" args="(Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the value of the specified <code>rhs</code> object to the value of this as described by IEEE-754, store the result in this object, and return a reference to this object.</p>
<ul>
<li>
If either this object or <code>rhs</code> is NaN, then raise the "invalid" floating-point exception and set this object to a NaN.  </li>
<li>
Otherwise if this object and <code>rhs</code> have infinite values of differing signs, then raise the "invalid" floating-point exception and set this object to a NaN.  </li>
<li>
Otherwise if this object and <code>rhs</code> have infinite values of the same sign, then do not change this object.  </li>
<li>
Otherwise if <code>rhs</code> has a zero value (positive or negative), do not change this object.  </li>
<li>
Otherwise if the sum of this object and <code>rhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and set this object to infinity value with the same sign as that result.  </li>
<li>
Otherwise set this object to the sum of the number represented by <code>rhs</code> and the number represented by this object.  </li>
</ul>
<p>Note that this is a floating-point value so this operations may not change the value of this object at all (if the value is large) or it may seem to update it to the value of the <code>other</code> (if the original value is small).</p>
<p>Note that when <code>rhs</code> is a <code>Decimal128</code>, this operation is always performed with 128 bits precision to prevent loss of precision of the <code>rhs</code> operand (prior to the operation). The result is then rounded back to 64 bits and stored to this object. See IEEE-754 2008, 5.1, first paragraph, second sentence for specification. </p>

</div>
</div>
<a class="anchor" id="a2b35af080e78af5b3677f10846b01eff"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator+=" ref="a2b35af080e78af5b3677f10846b01eff" args="(int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator+= </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af85cfb47b14b7b08654b2f404b115c6e"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator+=" ref="af85cfb47b14b7b08654b2f404b115c6e" args="(unsigned int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator+= </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acbe4ec1b88d98cd7308e4fefece398a1"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator+=" ref="acbe4ec1b88d98cd7308e4fefece398a1" args="(long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator+= </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a67e11cb0725e821ff93aa2406433d133"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator+=" ref="a67e11cb0725e821ff93aa2406433d133" args="(unsigned long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator+= </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a12843a6dfb47f4aef3529569e7d4630e"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator+=" ref="a12843a6dfb47f4aef3529569e7d4630e" args="(long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator+= </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a495f432f5479c5492de7bdc1a9a028aa"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator+=" ref="a495f432f5479c5492de7bdc1a9a028aa" args="(unsigned long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator+= </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>rhs</code> to the value of this object as described by IEEE-754, store the result in this object, and return a reference to this object.</p>
<ul>
<li>
If this object is NaN, then raise the "invalid" floating-point exception and do not change this object.  </li>
<li>
Otherwise if this object is infinity, then do not change it.  </li>
<li>
Otherwise if the sum of this object and <code>rhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and set this object to infinity with the same sign as that result.  </li>
<li>
Otherwise set this object to sum of adding <code>rhs</code> and the number represented by this object.  </li>
</ul>
<p>Note that this is a floating-point value so this operations may not change the value of this object at all (if the value is large) or it may seem to update it to the value of the <code>other</code> (if the original value is small). </p>

</div>
</div>
<a class="anchor" id="a9dddc0f1d360cae72894cd08708d4553"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator&#45;=" ref="a9dddc0f1d360cae72894cd08708d4553" args="(Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a843a419dd12b2e5e50472255e90ec534"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator&#45;=" ref="a843a419dd12b2e5e50472255e90ec534" args="(Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a002af3368f47312ad8114cbce54c14b3"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator&#45;=" ref="a002af3368f47312ad8114cbce54c14b3" args="(Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subtract the value of the specified <code>rhs</code> from the value of this object as described by IEEE-754, store the result in this object, and return a reference to this object.</p>
<ul>
<li>
If either this object or <code>rhs</code> is NaN, then raise the "invalid" floating-point exception and set this object to a NaN.  </li>
<li>
Otherwise if this object and the <code>rhs</code> have infinite values of the same sign, raise the "invalid" floating-point exception and set this object to a NaN.  </li>
<li>
Otherwise if this object and the <code>rhs</code> have infinite values of differing signs, then do not change this object.  </li>
<li>
Otherwise if the <code>rhs</code> has a zero value (positive or negative), do not change this object.  </li>
<li>
Otherwise if subtracting the value of the <code>rhs</code> object from this results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and set this object to infinity with the same sign as that result.  </li>
<li>
Otherwise set this object to the result of subtracting the value of <code>rhs</code> from the value of this object.  </li>
</ul>
<p>Note that this is a floating-point value so this operations may not change the value of this object at all (if the value is large) or it may seem to update it to the value of the <code>other</code> (if the original value is small).</p>
<p>Note that when <code>rhs</code> is a <code>Decimal128</code>, this operation is always performed with 128 bits precision to prevent loss of precision of the <code>rhs</code> operand (prior to the operation). The result is then rounded back to 64 bits and stored to this object. See IEEE-754 2008, 5.1, first paragraph, second sentence for specification. </p>

</div>
</div>
<a class="anchor" id="a4284c221a0b0f732fa97456840f97a88"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator&#45;=" ref="a4284c221a0b0f732fa97456840f97a88" args="(int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator-= </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b9a5f5135b1fe1d588d896505087bfe"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator&#45;=" ref="a7b9a5f5135b1fe1d588d896505087bfe" args="(unsigned int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator-= </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2ac45ab4fc57cf3d5a2903ed2befcd21"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator&#45;=" ref="a2ac45ab4fc57cf3d5a2903ed2befcd21" args="(long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator-= </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad59d32662892c5f97b69b0593d9948ee"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator&#45;=" ref="ad59d32662892c5f97b69b0593d9948ee" args="(unsigned long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator-= </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a30c593a3e72b0c91f83c7bbc285192be"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator&#45;=" ref="a30c593a3e72b0c91f83c7bbc285192be" args="(long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator-= </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a932a02cc2cacdb698c96d645f4907238"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator&#45;=" ref="a932a02cc2cacdb698c96d645f4907238" args="(unsigned long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator-= </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subtract the specified <code>rhs</code> from the value of this object as described by IEEE-754, store the result in this object, and return a reference to this object.</p>
<ul>
<li>
If this object is NaN, raise the "invalid" floating-point exception and do not change this object.  </li>
<li>
Otherwise if this object is infinity, then do not change it.  </li>
<li>
Otherwise if subtracting <code>rhs</code> from this object's value results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and set this object to infinity with the same sign as that result.  </li>
<li>
Otherwise set this object to the result of subtracting <code>rhs</code> from the value of this object.  </li>
</ul>
<p>Note that this is a floating-point value so this operations may not change the value of this object at all (if the value is large) or it may seem to update it to the value of the <code>other</code> (if the original value is small). </p>

</div>
</div>
<a class="anchor" id="a1982627cea293ea55a17b1d0f424b55b"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator*=" ref="a1982627cea293ea55a17b1d0f424b55b" args="(Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a78bd60dcc0397562dce4f0440e6153ac"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator*=" ref="a78bd60dcc0397562dce4f0440e6153ac" args="(Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2656a9e8819c4dd3861f206654d23e1d"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator*=" ref="a2656a9e8819c4dd3861f206654d23e1d" args="(Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multiply the value of the specified <code>rhs</code> object by the value of this as described by IEEE-754, store the result in this object, and return a reference to this object.</p>
<ul>
<li>
If either this object or <code>rhs</code> is NaN, raise the "invalid" floating-point exception and set this object to NaN.  </li>
<li>
Otherwise, if one of this object and <code>rhs</code> is zero (positive or negative) and the other is infinity (positive or negative), raise the "invalid" floating-point exception and set this object to a NaN.  </li>
<li>
Otherwise, if either this object or <code>rhs</code> is positive or negative infinity, set this object to infinity. The sign of this object will be positive if this object and <code>rhs</code> had the same sign, and negative otherwise.  </li>
<li>
Otherwise, if either this object or <code>rhs</code> is zero, set this object to zero. The sign of this object will be positive if this object and <code>rhs</code> had the same sign, and negative otherwise.  </li>
<li>
Otherwise if the product of this object and <code>rhs</code> has an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and set this object to infinity with the same sign of that result.  </li>
<li>
Otherwise if the product of this object and <code>rhs</code> has an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal64&gt;min()</code> then raise the "underflow" floating-point exception and set this object to zero value with the same sign as that result.  </li>
<li>
Otherwise set this object to the product of the value of <code>rhs</code> and the value of this object.  </li>
</ul>
<p>Note that when <code>rhs</code> is a <code>Decimal128</code>, this operation is always performed with 128 bits precision to prevent loss of precision of the <code>rhs</code> operand (prior to the operation). The result is then rounded back to 64 bits and stored to this object. See IEEE-754 2008, 5.1, first paragraph, second sentence for specification. </p>

</div>
</div>
<a class="anchor" id="a13599aba57ae78ea67167c76c220c283"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator*=" ref="a13599aba57ae78ea67167c76c220c283" args="(int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator*= </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a623e3f7ffce84e5ffe074f8f427627d6"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator*=" ref="a623e3f7ffce84e5ffe074f8f427627d6" args="(unsigned int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator*= </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1d212bb5a825ac0430ee10c88b916ad3"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator*=" ref="a1d212bb5a825ac0430ee10c88b916ad3" args="(long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator*= </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a04c1b7c3fdee9145cdd2ed99180c7a67"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator*=" ref="a04c1b7c3fdee9145cdd2ed99180c7a67" args="(unsigned long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator*= </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1a86d00b33bd066e71de48d982ab8be4"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator*=" ref="a1a86d00b33bd066e71de48d982ab8be4" args="(long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator*= </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab8e933ffe66ae1bbe1b6b93e37665fb3"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator*=" ref="ab8e933ffe66ae1bbe1b6b93e37665fb3" args="(unsigned long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator*= </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multiply the specified <code>rhs</code> by the value of this object as described by IEEE-754, store the result in this object, and return a reference to this object.</p>
<ul>
<li>
If this object is NaN, raise the "invalid" floating-point exception and set this object to a NaN.  </li>
<li>
Otherwise if this object is infinity (positive or negative), and <code>rhs</code> is zero, then raise the "invalid" floating-point exception and set this object to a NaN.  </li>
<li>
Otherwise if this object is infinity (positive or negative), then do not change it.  </li>
<li>
Otherwise if <code>rhs</code> is zero, then set this object to zero with the same sign as its value had prior to this operation.  </li>
<li>
Otherwise if the product of <code>rhs</code> and the value of this object results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and set this object to infinity with the same sign as that result.  </li>
<li>
Otherwise if the product of <code>rhs</code> and the value of this object results in an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal64&gt;min()</code> then raise the "underflow" floating-point exception and set this object to zero with the same sign as that result.  </li>
<li>
Otherwise set this object to the product of the value of this object and the value <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a75285185c0b601d6c76de7a44fcaad29"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator/=" ref="a75285185c0b601d6c76de7a44fcaad29" args="(Decimal32 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Decimal__Type32.html">Decimal32</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5641a65542bcc590dded9a71bfc4806c"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator/=" ref="a5641a65542bcc590dded9a71bfc4806c" args="(Decimal64 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal64</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a083cd10fe320253cec12c42b10251193"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator/=" ref="a083cd10fe320253cec12c42b10251193" args="(Decimal128 rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdldfp_1_1Decimal__Type128.html">Decimal128</a>&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Divide the value of this object by the value of the specified <code>rhs</code> as described by IEEE-754, store the result in this object, and return a reference to this object.</p>
<ul>
<li>
If either this object or <code>rhs</code> is NaN, then raise the "invalid" floating-point exception and set this object to a NaN.  </li>
<li>
Otherwise if this object and <code>rhs</code> are infinity (positive or negative) or zero (positive or negative), then raise the "invalid" floating-point exception and set this object to a NaN.  </li>
<li>
Otherwise if <code>rhs</code> has a positive zero value, then raise the "overflow" floating-point exception and set this object to infinity with the same sign as its original value.  </li>
<li>
Otherwise if <code>rhs</code> has a negative zero value, then raise the "overflow" floating-point exception and set this object to infinity with the opposite sign as its original value.  </li>
<li>
Otherwise if dividing the value of this object with the value of <code>rhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and set this object to infinity value with the same sign as that result.  </li>
<li>
Otherwise if dividing the value of this object with the value of <code>rhs</code> results in an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal64&gt;min()</code> then raise the "underflow" floating-point exception and set this object to zero with the same sign as that result.  </li>
<li>
Otherwise set this object to the result of dividing the value of this object with the value of <code>rhs</code>.  </li>
</ul>
<p>Note that when <code>rhs</code> is a <code>Decimal128</code>, this operation is always performed with 128 bits precision to prevent loss of precision of the <code>rhs</code> operand (prior to the operation). The result is then rounded back to 64 bits and stored to this object. See IEEE-754 2008, 5.1, first paragraph, second sentence for specification. </p>

</div>
</div>
<a class="anchor" id="ad0340e800b0ffa7c02cc1f299f298c1d"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator/=" ref="ad0340e800b0ffa7c02cc1f299f298c1d" args="(int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator/= </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7a5533b78cd069c829d4b57523b697e0"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator/=" ref="a7a5533b78cd069c829d4b57523b697e0" args="(unsigned int rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator/= </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2799eab6c2327dbb7f3e5985b8ea2a27"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator/=" ref="a2799eab6c2327dbb7f3e5985b8ea2a27" args="(long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator/= </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abf8f46ade949a8543b06d09d8395fc08"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator/=" ref="abf8f46ade949a8543b06d09d8395fc08" args="(unsigned long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator/= </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a33b490fe129a4f54c78f1447d58190ec"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator/=" ref="a33b490fe129a4f54c78f1447d58190ec" args="(long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator/= </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a682a560b69dbb7e4fc7037f1d08cfaf0"></a><!-- doxytag: member="bdldfp::Decimal_Type64::operator/=" ref="a682a560b69dbb7e4fc7037f1d08cfaf0" args="(unsigned long long rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1Decimal__Type64.html">Decimal_Type64</a>&amp; bdldfp::Decimal_Type64::operator/= </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Divide the value of this object by the specified <code>rhs</code> as described by IEEE-754, store the result in this object, and return a reference to this object.</p>
<ul>
<li>
If this object is NaN, raise the "invalid" floating-point exception and set this object to a NaN.  </li>
<li>
Otherwise if this object is infinity (positive or negative), and <code>rhs</code> is zero, raise the "invalid" floating-point exception and set this object to a NaN.  </li>
<li>
Otherwise if this object is infinity, then do not change it.  </li>
<li>
Otherwise if <code>rhs</code> is zero, raise the "overflow" floating-point exception and then set this object to infinity with the same sign it had prior to this operation.  </li>
<li>
Otherwise if the quotient of the value of this object and <code>rhs</code> results in an absolute value that is larger than <code>std::numeric_limits&lt;Decimal64&gt;max()</code> then raise the "overflow" floating-point exception and set this object to infinity with the same sign as that result.  </li>
<li>
Otherwise if the quotient of the value of this object and <code>rhs</code> results in an absolute value that is smaller than <code>std::numeric_limits&lt;Decimal64&gt;min()</code> then raise the "underflow" floating-point exception and set this object to zero with the same sign as that result.  </li>
<li>
Otherwise set this object to the result of dividing the number represented by this object by <code>rhs</code>.  </li>
</ul>

</div>
</div>
<a class="anchor" id="a0da76a87ac9c84f9463c8b63f5a3f3d7"></a><!-- doxytag: member="bdldfp::Decimal_Type64::data" ref="a0da76a87ac9c84f9463c8b63f5a3f3d7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1DecimalImpUtil.html#a48f434ac05252ee1e162dfb251cd4074">DecimalImpUtil::ValueType64</a>* bdldfp::Decimal_Type64::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a modifiable pointer to the underlying implementation. </p>

</div>
</div>
<a class="anchor" id="a65f87dc52e13b1d1b82fce3d37092755"></a><!-- doxytag: member="bdldfp::Decimal_Type64::bdexStreamIn" ref="a65f87dc52e13b1d1b82fce3d37092755" args="(STREAM &amp;stream, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bdldfp::Decimal_Type64::bdexStreamIn </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value read from the specified input <code>stream</code> using the specified <code>version</code> format, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If <code>version</code> is not supported, this object is unaltered and <code>stream</code> is invalidated, but otherwise unmodified. If <code>version</code> is supported but <code>stream</code> becomes invalid during this operation, this object has an undefined, but valid, state. Note that no version is read from <code>stream</code>. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a23b2f4d74ffba1c7161c1b6adad05f35"></a><!-- doxytag: member="bdldfp::Decimal_Type64::data" ref="a23b2f4d74ffba1c7161c1b6adad05f35" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbdldfp_1_1DecimalImpUtil.html#a48f434ac05252ee1e162dfb251cd4074">DecimalImpUtil::ValueType64</a>* bdldfp::Decimal_Type64::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a non-modifiable pointer to the underlying implementation. </p>

</div>
</div>
<a class="anchor" id="ae2b19f190606680ef9d692e873d787c4"></a><!-- doxytag: member="bdldfp::Decimal_Type64::value" ref="ae2b19f190606680ef9d692e873d787c4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdldfp_1_1DecimalImpUtil.html#a48f434ac05252ee1e162dfb251cd4074">DecimalImpUtil::ValueType64</a> bdldfp::Decimal_Type64::value </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the value of the underlying implementation. </p>

</div>
</div>
<a class="anchor" id="aa3bec29c6e310c0ea8f461b671fd91a6"></a><!-- doxytag: member="bdldfp::Decimal_Type64::bdexStreamOut" ref="aa3bec29c6e310c0ea8f461b671fd91a6" args="(STREAM &amp;stream, int version) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bdldfp::Decimal_Type64::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of this object, using the specified <code>version</code> format, to the specified output <code>stream</code>, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If <code>version</code> is not supported, <code>stream</code> is invalidated, but otherwise unmodified. Note that <code>version</code> is not written to <code>stream</code>. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a1999c71bbe70e467540cbdb01b57f0df"></a><!-- doxytag: member="bdldfp::Decimal_Type64::print" ref="a1999c71bbe70e467540cbdb01b57f0df" args="(bsl::ostream &amp;stream, int level=0, int spacesPerLevel=4) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdldfp::Decimal_Type64::print </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>spacesPerLevel</em> = <code>4</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of this object to the specified output <code>stream</code> in a human-readable format, and return a reference to <code>stream</code>. Optionally specify an initial indentation <code>level</code>, whose absolute value is incremented recursively for nested objects. If <code>level</code> is specified, optionally specify <code>spacesPerLevel</code>, whose absolute value indicates the number of spaces per indentation level for this and all of its nested objects. If <code>level</code> is negative, suppress indentation of the first line. If <code>spacesPerLevel</code> is negative, format the entire output on one line, suppressing all but the initial indentation (as governed by <code>level</code>). If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified, and can change without notice. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdldfp__decimal_8h_source.html">bdldfp_decimal.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:23 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
