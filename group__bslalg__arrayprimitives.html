<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslalg_arrayprimitives Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslalg_arrayprimitives<br/>
<small>
[<a class="el" href="group__bslalg.html">Package bslalg</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide primitive algorithms that operate on arrays.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslalg.html">bslalg</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Aliasing</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Defining a Vector-Like Type</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide primitive algorithms that operate on arrays. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbslalg_1_1ArrayPrimitives.html">bslalg::ArrayPrimitives</a> </td><td>namespace for array algorithms  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslalg__scalarprimitives.html" title="Provide primitive algorithms that operate on single elements.">Component bslalg_scalarprimitives</a>, <a class="el" href="group__bslalg__typetraits.html" title="Provide compile-time traits that can be associated with types.">Component bslalg_typetraits</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides utilities to initialize, move, and otherwise perform various primitive manipulations on arrays with a uniform interface, but selecting a different implementation according to the various traits possessed by the underlying type. Such primitives are exceptionally useful for implementing generic components such as containers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Several algorithms are provided, with the following short synopsis describing the observable behavior and mentioning the relevant traits. See the full function-level contract for detailed description, including exception-safety guarantees. In the description below, <code>Sc</code> stands for <code><a class="el" href="structbslalg_1_1ScalarPrimitives.html">bslalg::ScalarPrimitives</a></code> and <code>ADP</code> stands for <code><a class="el" href="structbslalg_1_1ArrayDestructionPrimitives.html">bslalg::ArrayDestructionPrimitives</a></code> (for brevity). Note that some algorithms (e.g., <code>insert</code>) are explained in terms of previous algorithms (e.g., <code>destructiveMove</code>). <br/>
<br/>
<div class="fragment"><pre class="fragment">  Algorithm                     Short description of observable behavior
  ----------------------------  ---------------------------------------------
  defaultConstruct              <span class="stringliteral">&#39;Sc::defaultConstruct&#39;</span> from value <span class="keywordflow">for each</span>
                                element in the target range, or <span class="stringliteral">&#39;std::memset&#39;</span>
                                <span class="keywordflow">if</span> type has a trivial <span class="keywordflow">default</span> constructor

  uninitializedFillN            <span class="stringliteral">&#39;Sc::copyConstruct&#39;</span> from value <span class="keywordflow">for each</span>
                                element in the target range, or <span class="stringliteral">&#39;std::memset&#39;</span>
                                <span class="keywordflow">if</span> value is all 0s or 1s bits, and type is
                                bit-wise copyable

  copyConstruct                 <span class="stringliteral">&#39;Sc::copyConstruct&#39;</span> from each element in the
                                original range to the corresponding element
                                in the target range, or <span class="stringliteral">&#39;std::memcpy&#39;</span> <span class="keywordflow">if</span>
                                value is null and type is bit-wise copyable

  destructiveMove               <span class="stringliteral">&#39;Sc::destructiveMove&#39;</span> from each element in
                                the original range to the corresponding
                                element in the target range, or <span class="stringliteral">&#39;std::memcpy&#39;</span>
                                <span class="keywordflow">if</span> type is bit-wise moveable

  destructiveMoveAndInsert      <span class="stringliteral">&#39;Sc::destructiveMove&#39;</span> from each element in
                                the original range to the corresponding
                                element in the target range, leaving a hole
                                in the middle, followed by
                                <span class="stringliteral">&#39;uninitializedFillN&#39;</span> or <span class="stringliteral">&#39;copyConstruct&#39;</span> to
                                fill hole with the appropriate values

  destructiveMoveAndMoveInsert  <span class="stringliteral">&#39;destructiveMove&#39;</span> from the original range to
                                the target range, leaving a hole in the
                                middle, followed by <span class="stringliteral">&#39;destructiveMove&#39;</span>
                                from second range to fill hole

  insert                        <span class="stringliteral">&#39;std::memmove&#39;</span> or <span class="stringliteral">&#39;copyConstruct&#39;</span> by some
                                positive offset to create a hole, followed by
                                <span class="stringliteral">&#39;uninitializedFillN&#39;</span>, <span class="stringliteral">&#39;copyConstruct&#39;</span>, or
                                copy assignment to fill hole with the
                                appropriate values

  emplace                       <span class="stringliteral">&#39;std::memmove&#39;</span> or <span class="stringliteral">&#39;copyConstruct&#39;</span> by some
                                positive offset to create a hole, followed by
                                in-place construction, <span class="stringliteral">&#39;copyConstruct&#39;</span>, or
                                copy assignment to fill hole with the
                                appropriate values

  moveInsert                    <span class="stringliteral">&#39;destructiveMove&#39;</span> by some positive offset to
                                create a hole, followed by <span class="stringliteral">&#39;destructiveMove&#39;</span>
                                to fill hole with the appropriate values

  erase                         <span class="stringliteral">&#39;ADP::destroy&#39;</span> elements in target range until
                                specified position, followed by
                                <span class="stringliteral">&#39;destructiveMove&#39;</span> by some negative offset
                                from the end of the range to fill hole with
                                the remaining values

  rotate                        <span class="stringliteral">&#39;Sc::destructiveMove&#39;</span> to move elements into a
                                shifting hole along parallel cyclic
                                permutations, or <span class="stringliteral">&#39;std::memmove&#39;</span> <span class="keywordflow">for</span> small
                                rotations <span class="keywordflow">if</span> type is bit-wise moveable
</pre></div><br/>
<br/>
 The traits under consideration by this component are: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Trait                                         English description
  --------------------------------------------  -----------------------------
  <a class="code" href="structbsl_1_1is__trivially__default__constructible.html">bsl::is_trivially_default_constructible</a>       <span class="stringliteral">&quot;TYPE has the trivial default</span>
<span class="stringliteral">                                                constructor trait&quot;</span>, or
                                                <span class="stringliteral">&quot;TYPE has a trivial default</span>
<span class="stringliteral">                                                constructor&quot;</span>

  <a class="code" href="structbsl_1_1is__trivially__copyable.html">bsl::is_trivially_copyable</a>                    <span class="stringliteral">&quot;TYPE has the bit-wise</span>
<span class="stringliteral">                                                copyable trait&quot;</span>, or
                                                <span class="stringliteral">&quot;TYPE is bit-wise copyable&quot;</span>

  <a class="code" href="structbslmf_1_1IsBitwiseMoveable.html">bslmf::IsBitwiseMoveable</a>                      <span class="stringliteral">&quot;TYPE has the bit-wise</span>
<span class="stringliteral">                                                moveable trait&quot;</span>, or
                                                <span class="stringliteral">&quot;TYPE is bit-wise moveable&quot;</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="aliasing"></a> <a class="anchor" id="description.aliasing"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Aliasing: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are some aliasing concerns in this component, due to the presence of the reference <code>const TARGET_TYPE&amp; value</code> argument, which may belong to a range that will be modified during the course of the operation. All such aliasing concerns are taken care of properly. Other aliasing concerns due to the copying or a range <code>[first, last)</code> are <em>not</em> taken care of, since their intended use is for range assignments and insertions in standard containers, for which the standard explicitly says that <code>first</code> and <code>last</code> shall not be iterators into the container. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_defining_a_vector-like_type"></a> <a class="anchor" id="usage.example_1~3A_defining_a_vector-like_type"></a> <a class="anchor" id="description.usage.example_1~3A_defining_a_vector-like_type"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Defining a Vector-Like Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we want to define a STL-vector-like type. One requirement is that an object of this vector should forward its allocator to its contained elements when appropriate. Another requirement is that the vector should take advantage of the optimizations available for certain traits of the contained element type. For example, if the contained element type has the <code><a class="el" href="structbslalg_1_1TypeTraitBitwiseMoveable.html">bslalg::TypeTraitBitwiseMoveable</a></code> trait, moving an element in a vector can be done using <code>memcpy</code> instead of copy construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We can utilize the class methods provided by <code><a class="el" href="structbslalg_1_1ArrayPrimitives.html">bslalg::ArrayPrimitives</a></code> to satisfy the above requirements. Unlike <code><a class="el" href="structbslalg_1_1ScalarPrimitives.html">bslalg::ScalarPrimitives</a></code>, which operates on a single element, <code><a class="el" href="structbslalg_1_1ArrayPrimitives.html">bslalg::ArrayPrimitives</a></code> operates on arrays, which will further help simplify our implementation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create an elided definition of the class template <code>MyVector</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>MyVector {
      <span class="comment">// This class implements a vector of elements of the (template</span>
      <span class="comment">// parameter) &#39;TYPE&#39;, which must be copy constructable.  Note that for</span>
      <span class="comment">// the brevity of the usage example, this class does not provide any</span>
      <span class="comment">// Exception-Safety guarantee.</span>

      <span class="comment">// DATA</span>
      TYPE             *d_array_p;     <span class="comment">// pointer to the allocated array</span>
      <span class="keywordtype">int</span>               d_capacity;    <span class="comment">// capacity of the allocated array</span>
      <span class="keywordtype">int</span>               d_size;        <span class="comment">// number of objects</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p; <span class="comment">// allocator pointer (held, not owned)</span>

    <span class="keyword">public</span>:
      <span class="comment">// TYPE TRAITS</span>
      <a class="code" href="bslmf__nestedtraitdeclaration_8h.html#a6d33ff2982d65052e0c33136bf4d74e7">BSLMF_NESTED_TRAIT_DECLARATION</a>(
          MyVector,
          BloombergLP::bslmf::IsBitwiseMoveable);

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> MyVector(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0)
          <span class="comment">// Construct a &#39;MyVector&#39; object having a size of 0 and and a</span>
          <span class="comment">// capacity of 0.  Optionally specify a &#39;basicAllocator&#39; used to</span>
          <span class="comment">// supply memory.  If &#39;basicAllocator&#39; is 0, the currently</span>
          <span class="comment">// installed default allocator is used.</span>
      : d_array_p(0)
      , d_capacity(0)
      , d_size(0)
      , d_allocator_p(bslma::Default::allocator(basicAllocator))
      {
      }

      MyVector(<span class="keyword">const</span> MyVector&amp;   original,
               <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;MyVector&#39; object having the same value as the</span>
          <span class="comment">// specified &#39;original&#39; object.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      <span class="comment">// ...</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> reserve(<span class="keywordtype">int</span> minCapacity);
          <span class="comment">// Change the capacity of this vector to at least the specified</span>
          <span class="comment">// &#39;minCapacity&#39; if it is greater than the vector&#39;s current</span>
          <span class="comment">// capacity.</span>

      <span class="keywordtype">void</span> insert(<span class="keywordtype">int</span> dstIndex, <span class="keywordtype">int</span> numElements, <span class="keyword">const</span> TYPE&amp; value);
          <span class="comment">// Insert, into this vector, the specified &#39;numElements&#39; of the</span>
          <span class="comment">// specified &#39;value&#39; at the specified &#39;dstIndex&#39;.  The behavior is</span>
          <span class="comment">// undefined unless &#39;0 &lt;= dstIndex &lt;= size()&#39;.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> TYPE&amp; operator[](<span class="keywordtype">int</span> position) <span class="keyword">const</span>
          <span class="comment">// Return a reference providing non-modifiable access to the</span>
          <span class="comment">// element at the specified &#39;position&#39; in this vector.</span>
      {
          <span class="keywordflow">return</span> d_array_p[position];
      }

      <span class="keywordtype">int</span> <a class="code" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size</a>() const
          <span class="comment">// Return the size of this vector.</span>
      {
          <span class="keywordflow">return</span> d_size;
      }
  };
</pre></div><br/>
<br/>
 Then, we implement the copy constructor of <code>MyVector</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  MyVector&lt;TYPE&gt;::MyVector(<span class="keyword">const</span> MyVector&lt;TYPE&gt;&amp;  original,
                           <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>      *basicAllocator)
  : d_array_p(0)
  , d_capacity(0)
  , d_size(0)
  , d_allocator_p(bslma::Default::allocator(basicAllocator))
  {
      reserve(original.d_size);
</pre></div><br/>
<br/>
 Here, we call the <code><a class="el" href="structbslalg_1_1ArrayPrimitives.html#ab3b2faada6341d555ceb351bba426933">bslalg::ArrayPrimitives::copyConstruct</a></code> class method to copy each element from <code>original.d_array_p</code> to <code>d_array_p</code> (When appropriate, this class method passes this vector's allocator to the copy constructor of <code>TYPE</code> or uses bit-wise copy.): <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="structbslalg_1_1ArrayPrimitives.html#ab3b2faada6341d555ceb351bba426933">bslalg::ArrayPrimitives::copyConstruct</a>(
                                        d_array_p,
                                        original.d_array_p,
                                        original.d_array_p + original.d_size,
                                        d_allocator_p);

      d_size = original.d_size;
  }
</pre></div><br/>
<br/>
 Now, we implement the <code>reserve</code> method of <code>MyVector</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> MyVector&lt;TYPE&gt;::reserve(<span class="keywordtype">int</span> minCapacity)
  {
      <span class="keywordflow">if</span> (d_capacity &gt;= minCapacity) <span class="keywordflow">return</span>;                        <span class="comment">// RETURN</span>

      TYPE *newArrayPtr = <span class="keyword">static_cast&lt;</span>TYPE*<span class="keyword">&gt;</span>(d_allocator_p-&gt;allocate(
      BloombergLP::bslma::Allocator::size_type(minCapacity * <span class="keyword">sizeof</span>(TYPE))));

      <span class="keywordflow">if</span> (d_array_p) {
</pre></div><br/>
<br/>
 Here, we call the <code><a class="el" href="structbslalg_1_1ArrayPrimitives.html#a5c38c0261136270c2cad4021180e41b1">bslalg::ArrayPrimitives::destructiveMove</a></code> class method to copy each original element from <code>d_array_p</code> to <code>newArrayPtr</code> and then destroy all the original elements (When appropriate, this class method passes this vector's allocator to the copy constructor of <code>TYPE</code> or uses bit-wise copy.): <br/>
<br/>
<div class="fragment"><pre class="fragment">          <a class="code" href="structbslalg_1_1ArrayPrimitives.html#a5c38c0261136270c2cad4021180e41b1">bslalg::ArrayPrimitives::destructiveMove</a>(newArrayPtr,
                                                   d_array_p,
                                                   d_array_p + d_size,
                                                   d_allocator_p);
          d_allocator_p-&gt;deallocate(d_array_p);
      }

      d_array_p = newArrayPtr;
      d_capacity = minCapacity;
  }
</pre></div><br/>
<br/>
 Finally, we implement the <code>insert</code> method of <code>MyVector</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span>
  MyVector&lt;TYPE&gt;::insert(<span class="keywordtype">int</span> dstIndex, <span class="keywordtype">int</span> numElements, <span class="keyword">const</span> TYPE&amp; value)
  {
      <span class="keywordtype">int</span> newSize = d_size + numElements;

      <span class="keywordflow">if</span> (newSize &gt; d_capacity) {
          <span class="keywordtype">int</span> newCapacity = d_capacity == 0 ? 2 : d_capacity * 2;
          reserve(newCapacity);
      }
</pre></div><br/>
<br/>
 Here, we call the <code><a class="el" href="structbslalg_1_1ArrayPrimitives.html#a55381d543e412d18de7802b60ffe2b62">bslalg::ArrayPrimitives::insert</a></code> class method to first move each element after <code>dstIndex</code> by <code>numElements</code> and then copy construct <code>numElements</code> of <code>value</code> at <code>dstIndex</code>. (When appropriate, this class method passes this vector's allocator to the copy constructor of <code>TYPE</code> or uses bit-wise copy.): <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="structbslalg_1_1ArrayPrimitives.html#a55381d543e412d18de7802b60ffe2b62">bslalg::ArrayPrimitives::insert</a>(d_array_p + dstIndex,
                                      d_array_p + d_size,
                                      value,
                                      numElements,
                                      d_allocator_p);

      d_size = newSize;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:51 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
