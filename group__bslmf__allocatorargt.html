<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslmf_allocatorargt Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>Component bslmf_allocatorargt<br/>
<small>
[<a class="el" href="group__bslmf.html">Package bslmf</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a tag type to precede allocator arguments.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1allocator__arg__t.html">bsl::allocator_arg_t</a></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const allocator_arg_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslmf__allocatorargt.html#ga6cebd63bf4531f3f05c924cbdc04a12b">bsl::allocator_arg</a> = { }</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Disambiguate a constructor invocation</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a tag type to precede allocator arguments. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbsl_1_1allocator__arg__t.html">bsl::allocator_arg_t</a> </td><td>tag indicating the next parameter is an allocator  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslalg__scalarprimitives.html" title="Provide primitive algorithms that operate on single elements.">Component bslalg_scalarprimitives</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The C++11 standard defines the empty class <code><a class="el" href="structbsl_1_1allocator__arg__t.html">bsl::allocator_arg_t</a></code> as a tag that precedes an argument of allocator type in circumstances where context alone cannot be used to determine which argument is an allocator. Typically, this disambiguation is needed when a class has templated constructors taking variable numbers of arguments, each of which is of parameterized type. If that class also uses an allocator (of either STL style or <code>bslma</code>/<code>memory_resource</code> style), then the allocator argument must be flagged as special. An argument of type <code>std::allocator_arg_t</code> is used to distinguish constructors that take an allocator from constructors that don't. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition to the <code><a class="el" href="structbsl_1_1allocator__arg__t.html">allocator_arg_t</a></code> class type, this component (and the standard) define a constant, <code>allocator_arg</code>, of type <code><a class="el" href="structbsl_1_1allocator__arg__t.html">allocator_arg_t</a></code>. That constant is used for passing an <code><a class="el" href="structbsl_1_1allocator__arg__t.html">allocator_arg_t</a></code> argument to a function or constructor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_disambiguate_a_constructor_invocation"></a> <a class="anchor" id="usage.example_1~3A_disambiguate_a_constructor_invocation"></a> <a class="anchor" id="description.usage.example_1~3A_disambiguate_a_constructor_invocation"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Disambiguate a constructor invocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we want to define a nullable type that can be in the full state (holding an object) or the null state (not holding an object). When in the full state, memory is allocated for the held object using a memory allocator. For simplicity, this memory allocator is not automatically propagated to the held object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a simple allocator class hierarchy with an abstract <code>xyzma::Allocator</code> base class and two derived classes: <code>xyzma::NewDeleteAllocator</code> and <code>xyzma::TestAllocator</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;cstddef&gt;</span>

  <span class="keyword">namespace </span>xyzma {

  <span class="keyword">class </span>Allocator {
      <span class="comment">// Abstract allocator base class</span>
  <span class="keyword">public</span>:
      <span class="keyword">virtual</span> ~Allocator() { }

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> *allocate(std::size_t nbytes) = 0;
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *ptr) = 0;
  };

  <span class="keyword">class </span>NewDeleteAllocator : <span class="keyword">public</span> Allocator {
      <span class="comment">// Concrete allocator that uses operators &#39;new&#39; and &#39;delete&#39;</span>

  <span class="keyword">public</span>:
      <span class="keyword">static</span> NewDeleteAllocator* singleton();
          <span class="comment">// Returns a singleton instance of this class</span>

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> *allocate(std::size_t nbytes);
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *ptr);
  };

  NewDeleteAllocator *NewDeleteAllocator::singleton() {
      <span class="keyword">static</span> NewDeleteAllocator s;
      <span class="keywordflow">return</span> &amp;s;
  }

  <span class="keywordtype">void</span> *NewDeleteAllocator::allocate(std::size_t nbytes) {
      <a class="code" href="group__bdlma__bufferedsequentialpool.html#gae18335d3caf814f9f9cd5250ec6696ad">return ::operator new</a>(nbytes);
  }

  <span class="keywordtype">void</span> NewDeleteAllocator::deallocate(<span class="keywordtype">void</span> *ptr) {
      ::operator <span class="keyword">delete</span>(ptr);
  }

  <span class="keyword">class </span>TestAllocator : <span class="keyword">public</span> Allocator {
      <span class="comment">// Concrete allocator that keeps track of number of blocks allocated</span>
      <span class="comment">// and deallocated.</span>

      std::size_t d_allocatedBlocks;
      std::size_t d_deallocatedBlocks;

  <span class="keyword">public</span>:
      TestAllocator() : d_allocatedBlocks(0), d_deallocatedBlocks(0) { }

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> *allocate(std::size_t nbytes);
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *ptr);

      <span class="comment">// ACCESSORS</span>
      std::size_t allocatedBlocks()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_allocatedBlocks; }
      std::size_t deallocatedBlocks()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_deallocatedBlocks; }
      std::size_t outstandingBlocks()<span class="keyword"> const </span>{
          <span class="keywordflow">return</span> d_allocatedBlocks - d_deallocatedBlocks;
      }
  };

  <span class="keywordtype">void</span> *TestAllocator::allocate(std::size_t nbytes) {
      ++d_allocatedBlocks;
      <a class="code" href="group__bdlma__bufferedsequentialpool.html#gae18335d3caf814f9f9cd5250ec6696ad">return ::operator new</a>(nbytes);
  }

  <span class="keywordtype">void</span> TestAllocator::deallocate(<span class="keywordtype">void</span> *ptr) {
      ++d_deallocatedBlocks;
      ::operator <span class="keyword">delete</span>(ptr);
  }

  }  <span class="comment">// close namespace xyzma</span>
</pre></div><br/>
<br/>
 Next, we define our nullable class template, declaring two constructors: one that constructs the null object, and one that constructs a non-null object using the specified constructor argument. For flexibility, the second constructor is a template that takes any type and can therefore construct the object without necessarily invoking the copy constructor. (Ideally, this second constructor would be variadic, but that is not necessary for this example.): <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;new&gt;</span>

  <span class="keyword">namespace </span>xyzutl {

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>Nullable {
      xyzma::Allocator *d_alloc_p;
      TYPE             *d_object_p;

  <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      Nullable();
          <span class="comment">// Construct a null object.  Note: this is ctor A.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> ARG&gt;
      Nullable(<span class="keyword">const</span> ARG&amp; arg);
          <span class="comment">// Construct a non-null object using the specified &#39;arg&#39; as the</span>
          <span class="comment">// constructor argument for the &#39;TYPE&#39; object.  Note: this is ctor</span>
          <span class="comment">// B.</span>
</pre></div><br/>
<br/>
 Next, we want to add constructors that supply an allocator for use by the <code>Nullable</code> object. Our first thought is to add two more constructors like the two above, but with an additional allocator argument at the end: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// Nullable(xyzma::Allocator *alloc);</span>
          <span class="comment">// ctor C</span>

      <span class="comment">// template &lt;class ARG&gt;</span>
      <span class="comment">// Nullable(const ARG&amp; arg, xyzma::Allocator *alloc);</span>
          <span class="comment">// ctor D</span>
</pre></div><br/>
<br/>
 However, ctor C is difficult to invoke, because ctor B is almost always a better match. Nor can we use SFINAE to disqualify ctor B in cases where ARG is <code>xyzma::Allocator*</code> because <code>xyzma::Allocator*</code> is a perfectly valid constructor argument for many <code>TYPE</code>s. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We solve this problem by using <code><a class="el" href="structbsl_1_1allocator__arg__t.html">allocator_arg_t</a></code> to explicitly tag the constructor that takes an allocator argument: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Nullable(<a class="code" href="structbsl_1_1allocator__arg__t.html">bsl::allocator_arg_t</a>, xyzma::Allocator *alloc);
          <span class="comment">// Construct a null object with the specified &#39;alloc&#39; allocator.</span>
          <span class="comment">// Note: this is ctor E</span>
</pre></div><br/>
<br/>
 The <code><a class="el" href="structbsl_1_1allocator__arg__t.html">allocator_arg_t</a></code> argument disambiguates the constructor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, to make things consistent (which is important for generic programming), we use the <code><a class="el" href="structbsl_1_1allocator__arg__t.html">allocator_arg_t</a></code> tag in the other allocator-aware constructor, as well: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">template</span> &lt;<span class="keyword">class</span> ARG&gt;
      Nullable(<a class="code" href="structbsl_1_1allocator__arg__t.html">bsl::allocator_arg_t</a>,
               xyzma::Allocator *alloc,
               <span class="keyword">const</span> ARG&amp;        arg);
          <span class="comment">// Construct a non-null object using the specified &#39;arg&#39; as the</span>
          <span class="comment">// constructor argument for the &#39;TYPE&#39; object, and the specified</span>
          <span class="comment">// &#39;alloc&#39; allocator.  Note: this is ctor F.</span>
</pre></div><br/>
<br/>
 Next, we finish the class interface and implementation: <br/>
<br/>
<div class="fragment"><pre class="fragment">      ~Nullable();

      <span class="comment">// MANIPULATORS</span>
      Nullable&amp; operator=(<span class="keyword">const</span> Nullable&amp; rhs);
          <span class="comment">// Copy assign this object from the specified &#39;rhs&#39;.</span>

      Nullable&amp; operator=(<span class="keyword">const</span> TYPE&amp; rhs);
          <span class="comment">// Construct a non-null object holding a copy of the specified</span>
          <span class="comment">// &#39;rhs&#39; object.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> TYPE&amp; value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *d_object_p; }
          <span class="comment">// Return the object stored in this Nullable. The behavior is</span>
          <span class="comment">// undefined if this is null.</span>

      <span class="keywordtype">bool</span> <a class="code" href="namespacebdlat__NullableValueFunctions.html#aef3bd184c8665becb25bcfefe9c6d1cd">isNull</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ! d_object_p; }
          <span class="comment">// Returns true if this object is not null.</span>

      xyzma::Allocator *allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_alloc_p; }
  };

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  Nullable&lt;TYPE&gt;::Nullable()
      : d_alloc_p(xyzma::NewDeleteAllocator::singleton())
      , d_object_p(0)
  {
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> ARG&gt;
  Nullable&lt;TYPE&gt;::Nullable(<span class="keyword">const</span> ARG&amp; arg)
      : d_alloc_p(xyzma::NewDeleteAllocator::singleton())
      , d_object_p(static_cast&lt;TYPE*&gt;(d_alloc_p-&gt;allocate(sizeof(TYPE))))
  {
      ::new(d_object_p) TYPE(arg);
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  Nullable&lt;TYPE&gt;::Nullable(<a class="code" href="structbsl_1_1allocator__arg__t.html">bsl::allocator_arg_t</a>, xyzma::Allocator *alloc)
      : d_alloc_p(alloc)
      , d_object_p(0)
  {
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> ARG&gt;
  Nullable&lt;TYPE&gt;::Nullable(<a class="code" href="structbsl_1_1allocator__arg__t.html">bsl::allocator_arg_t</a>,
                           xyzma::Allocator *alloc,
                           <span class="keyword">const</span> ARG&amp;        arg)
      : d_alloc_p(alloc)
      , d_object_p(static_cast&lt;TYPE*&gt;(d_alloc_p-&gt;allocate(sizeof(TYPE))))
  {
      ::new(d_object_p) TYPE(arg);
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  Nullable&lt;TYPE&gt;::~Nullable() {
      <span class="keywordflow">if</span> (d_object_p) {
          d_object_p-&gt;~TYPE();
          d_alloc_p-&gt;deallocate(d_object_p);
      }
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  Nullable&lt;TYPE&gt;&amp; Nullable&lt;TYPE&gt;::operator=(<span class="keyword">const</span> Nullable&amp; rhs) {
      <span class="keywordflow">if</span> (&amp;rhs == <span class="keyword">this</span>) <span class="keywordflow">return</span> *<span class="keyword">this</span>;                               <span class="comment">// RETURN</span>
      <span class="keywordflow">if</span> (!<a class="code" href="namespacebdlat__NullableValueFunctions.html#aef3bd184c8665becb25bcfefe9c6d1cd">isNull</a>() &amp;&amp; !rhs.isNull()) {
          *d_object_p = *rhs.d_object_p;
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="namespacebdlat__NullableValueFunctions.html#aef3bd184c8665becb25bcfefe9c6d1cd">isNull</a>() <span class="comment">/* &amp;&amp; rhs.isNull() */</span>) {
          <span class="comment">// Make null</span>
          d_object_p-&gt;~TYPE();
          d_alloc_p-&gt;deallocate(d_object_p);
          d_object_p = 0;
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="comment">/* isNull() &amp;&amp; */</span> !rhs.isNull()) {
          <span class="comment">// Allocate and copy from &#39;rhs&#39;</span>
          d_object_p = <span class="keyword">static_cast&lt;</span>TYPE*<span class="keyword">&gt;</span>(d_alloc_p-&gt;allocate(<span class="keyword">sizeof</span>(TYPE)));
          ::new(d_object_p) TYPE(*rhs.d_object_p);
      }
      <span class="comment">// else both are null</span>

      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  Nullable&lt;TYPE&gt;&amp; Nullable&lt;TYPE&gt;::operator=(<span class="keyword">const</span> TYPE&amp; rhs) {
      <span class="keywordflow">if</span> (<a class="code" href="namespacebdlat__NullableValueFunctions.html#aef3bd184c8665becb25bcfefe9c6d1cd">isNull</a>()) {
          d_object_p = <span class="keyword">static_cast&lt;</span>TYPE*<span class="keyword">&gt;</span>(d_alloc_p-&gt;allocate(<span class="keyword">sizeof</span>(TYPE)));
          ::new(d_object_p) TYPE(*rhs.d_object_p);
      }
      <span class="keywordflow">else</span> {
          *d_object_p = rhs;
      }

      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  }  <span class="comment">// close namespace xyzutl</span>
</pre></div><br/>
<br/>
 Now, for testing purposes, we define a class that takes an allocator constructor argument: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Obj {
      xyzma::Allocator *d_alloc_p;
      <span class="keywordtype">int</span>               d_count;
  <span class="keyword">public</span>:
      <span class="keyword">explicit</span> Obj(xyzma::Allocator *alloc = 0)
          : d_alloc_p(alloc), d_count(0)
      {
      }

      Obj(<span class="keywordtype">int</span> count, xyzma::Allocator *alloc = 0)                 <span class="comment">// IMPLICIT</span>
          : d_alloc_p(alloc), d_count(count)
      {
      }

      <span class="keywordtype">int</span> count()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_count; }
      xyzma::Allocator *allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_alloc_p; }
  };

  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> Obj&amp; a, <span class="keyword">const</span> Obj&amp; b) {
      <span class="keywordflow">return</span> a.count() == b.count();
  }

  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> Obj&amp; a, <span class="keyword">const</span> Obj&amp; b) {
      <span class="keywordflow">return</span> a.count() != b.count();
  }
</pre></div><br/>
<br/>
 Finally, we test that our nullable type can be constructed with and without an allocator pointer and that the allocator pointer can unambiguously be used for the object's allocator. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main() {

      <span class="keyword">using</span> xyzutl::Nullable;

      xyzma::TestAllocator ta;

      Nullable&lt;Obj&gt; no1;
      assert(  no1.isNull());
      assert(xyzma::NewDeleteAllocator::singleton() == no1.allocator());

      Nullable&lt;Obj&gt; no2(2);
      assert(! no2.isNull());
      assert(xyzma::NewDeleteAllocator::singleton() == no2.allocator());
      assert(2 == no2.value());
      assert(0 == no2.value().allocator());

      Nullable&lt;Obj&gt; no3(<a class="code" href="group__bslmf__allocatorargt.html#ga6cebd63bf4531f3f05c924cbdc04a12b">bsl::allocator_arg</a>, &amp;ta);
      assert(  no3.isNull());
      assert(&amp;ta == no3.allocator());
      assert(0 == ta.outstandingBlocks());

      Nullable&lt;Obj&gt; no4(<a class="code" href="group__bslmf__allocatorargt.html#ga6cebd63bf4531f3f05c924cbdc04a12b">bsl::allocator_arg</a>, &amp;ta, 4);
      assert(! no4.isNull());
      assert(&amp;ta == no4.allocator());
      assert(1 == ta.outstandingBlocks());
      assert(4 == no4.value());
      assert(0 == no4.value().allocator());

      <span class="comment">// &#39;&amp;ta&#39; used by &#39;Obj&#39;, not by &#39;Nullable&#39;.</span>
      Nullable&lt;Obj&gt; no5(&amp;ta);
      assert(! no5.isNull());
      assert(xyzma::NewDeleteAllocator::singleton() == no5.allocator());
      assert(1 == ta.outstandingBlocks());  <span class="comment">// No change</span>
      assert(0 == no5.value());
      assert(&amp;ta == no5.value().allocator());

      <span class="comment">// &#39;&amp;ta&#39; used by both &#39;Nullable&#39; and by &#39;Obj&#39;</span>
      Nullable&lt;Obj&gt; no6(<a class="code" href="group__bslmf__allocatorargt.html#ga6cebd63bf4531f3f05c924cbdc04a12b">bsl::allocator_arg</a>, &amp;ta, &amp;ta);
      assert(! no6.isNull());
      assert(&amp;ta == no6.allocator());
      assert(2 == ta.outstandingBlocks());
      assert(0 == no6.value());
      assert(&amp;ta == no6.value().allocator());

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga6cebd63bf4531f3f05c924cbdc04a12b"></a><!-- doxytag: member="bsl::allocator_arg" ref="ga6cebd63bf4531f3f05c924cbdc04a12b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const allocator_arg_t <a class="el" href="group__bslmf__allocatorargt.html#ga6cebd63bf4531f3f05c924cbdc04a12b">bsl::allocator_arg</a> = { }<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:59 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
