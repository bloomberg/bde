<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslstl_sharedptr Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_sharedptr<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a generic reference-counted shared pointer wrapper.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslstl.html">bslstl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsl.html">bsl</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Shared and Weak References</a> </li>
<li>
<a href="#3.3">In-place/Out-of-place Representations</a> <ul>
<li>
<a href="#3.3.1">Weak Pointers using "in-place" or Pooled Shared Pointer Representations</a> </li>
</ul>
</li>
<li>
<a href="#3.4">Correct Usage of the Allocator Model</a> </li>
<li>
<a href="#3.5">Deleters</a> </li>
<li>
<a href="#3.6">Aliasing</a> </li>
<li>
<a href="#3.7">Type Casting</a> <ul>
<li>
<a href="#3.7.1">Implicit Casting</a> </li>
<li>
<a href="#3.7.2">Explicit Casting</a> </li>
</ul>
</li>
<li>
<a href="#3.8">Converting to and from <code>BloombergLP::bslma::ManagedPtr</code></a> </li>
<li>
<a href="#3.9">Weak Pointers using "in-place" or Pooled Shared Pointer Representations</a> </li>
<li>
<a href="#3.10">C++ Standard Compliance</a> </li>
<li>
<a href="#3.11">Usage</a> <ul>
<li>
<a href="#3.11.1">Example 1: Basic Usage</a> </li>
<li>
<a href="#3.11.2">Using Custom Deleters</a> <ul>
<li>
<a href="#3.11.2.1">Example 2: Nil Deleters</a> </li>
</ul>
</li>
<li>
<a href="#3.11.3">Example 3: Basic Weak Pointer Usage</a> </li>
<li>
<a href="#3.11.4">Example 4: Breaking Cyclical Dependencies</a> </li>
<li>
<a href="#3.11.5">Example 5: Caching</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a generic reference-counted shared pointer wrapper. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a> </td><td>shared pointer  </td></tr>
<tr>
<td><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a> </td><td>"weak" reference to reference-counted shared object  </td></tr>
<tr>
<td><a class="el" href="structbslstl_1_1SharedPtrUtil.html">bslstl::SharedPtrUtil</a> </td><td>shared pointer utility functions  </td></tr>
<tr>
<td><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a> </td><td>no-op deleter  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__managedptr.html" title="Provide a managed pointer class.">Component bslma_managedptr</a>, <a class="el" href="group__bslma__sharedptrrep.html" title="Provide an abstract class for a shared object manager.">Component bslma_sharedptrrep</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements a thread-safe, generic, reference-counted "smart pointer" to support "shared ownership" of objects of (template parameter) <code>ELEMENT_TYPE</code>. Shared pointers implement a form of the "envelope/letter" idiom. For each shared object, a representation that manages the number of references to it is created. Many shared pointers can simultaneously refer to the same shared object by storing a reference to the same representation. Shared pointers also implement the "construction is
 acquisition, destruction is release" idiom. When a shared pointer is created it increments the number of shared references to the shared object that was specified to its constructor (or was referred to by a shared pointer passed to the copy constructor). When a shared pointer is assigned to or destroyed, then the number of shared references to the shared object is decremented. When all references to the shared object are released, both the representation and the object are destroyed. <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> emulates the interface of a native pointer. The shared object may be accessed directly using the <code>-&gt;</code> operator, or the dereference operator (operator <code>*</code>) can be used to obtain a reference to the shared object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component also provides a mechanism, <code><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a></code>, used to create weak references to reference-counted shared (<code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code>) objects. A weak reference provides conditional access to a shared object managed by a <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code>, but, unlike a shared (or "strong") reference, does not affect the shared object's lifetime. An object having even one shared reference to it will not be destroyed, but an object having only weak references would have been destroyed when the last shared reference was released. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A weak pointer can be constructed from another weak pointer or a <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code>. To access the shared object referenced by a weak pointer clients must first obtain a shared pointer to that object using the <code>lock</code> method. If the shared object has been destroyed (as indicated by the <code>expired</code> method), then <code>lock</code> returns a shared pointer in the default constructed (empty) state. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component also provides a functor, <code><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a></code>, which may used to create a shared pointer that takes no action when the last shared reference is destroyed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component also provides a utility class, <code><a class="el" href="structbslstl_1_1SharedPtrUtil.html">bslstl::SharedPtrUtil</a></code>, which provides several functions that are frequently used with shared pointers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section qualifies the thread safety of <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> objects and <code><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a></code> objects themselves rather than the thread safety of the objects being referenced. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is safe to access or modify two distinct <code>shared_ptr</code> (or <code><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a></code>) objects simultaneously, each from a separate thread, even if they share ownership of a common object. It is safe to access a single <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> (or <code><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a></code>) object simultaneously from two or more separate threads, provided no other thread is simultaneously modifying the object. It is not safe to access or modify a <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> (or <code><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a></code>) object in one thread while another thread modifies the same object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is safe to access, modify, copy, or delete a shared pointer (or weak pointer) in one thread, while other threads access or modify other shared pointers and weak pointers pointing to or managing the same object (the reference count is managed using atomic operations). However, there is no guarantee regarding the safety of accessing or modifying the object <em>referred</em> <em>to</em> by the shared pointer simultaneously from multiple threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="shared_and_weak_references"></a> <a class="anchor" id="description.shared_and_weak_references"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Shared and Weak References: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are two types of references to shared objects: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>1) A shared reference allows users to share the ownership of an object and control its lifetime. A shared object is destroyed only when the last shared reference to it is released. A shared reference to an object can be obtained by creating a <code>shared_ptr</code> referring to it. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>2) A weak reference provides users conditional access to an object without sharing its ownership (or affecting its lifetime). A shared object can be destroyed even if there are weak references to it. A weak reference to an object can be obtained by creating a <code>weak_ptr</code> referring to the object from a <code>shared_ptr</code> referring to that object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="in-place~2Fout-of-place_representations"></a> <a class="anchor" id="description.in-place~2Fout-of-place_representations"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>In-place/Out-of-place Representations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>shared_ptr</code> provides two types of representations: an out-of-place representation, and an in-place representation. Out-of-place representations are used to refer to objects that are constructed externally to their associated representations. Out-of-place objects are provided to a shared pointer by passing their address along with the deleter that should be used to destroy the object when all references to it have been released. In-place objects can be constructed directly within a shared pointer representation (see <code>createInplace</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Below we provide a diagram illustrating the differences between the two representations for a shared pointer to an <code>int</code>. First we create an <code>int</code> object on the heap, initialized to 10, and pass its address to a shared pointer constructor, resulting in an out-of-place representation for the shared object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a> nda;
  <span class="keywordtype">int</span> *value = <span class="keyword">new</span> (nda) <span class="keywordtype">int</span>(10);
  shared_ptr&lt;int&gt; outOfPlaceSharedPtr(value, &amp;nda);
</pre></div><br/>
<br/>
 Next we create an in-place representation of a shared <code>int</code> object that is also initialized to 10: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;int&gt; inPlaceSharedPtr;
  inPlaceSharedPtr.createInplace(&amp;nda, 10);
</pre></div><br/>
<br/>
 The memory layouts of these two representations are shown below (where <code>d_ptr_p</code> refers to the shared object and <code>d_rep_p</code> refers to the representation): <br/>
<br/>
<div class="fragment"><pre class="fragment">  Out-of-Place Representation                 In-Place Representation
  ----------------------------              ----------------------------

  +------------+                            +------------+
  |            |                            |            |
  |  d_ptr_p ------&gt;+-----------+           |  d_ptr_p ---------+
  |            |    |     10    |           |            |      |
  |            |    +-----------+           |            |      |
  |            |                            |            |      |
  |  d_rep_p ------&gt;+-----------+           |  d_rep_p ------&gt;+-v---------+
  |            |    | reference |           |            |    |+---------+|
  |            |    |  counts   |           |            |    ||    10   ||
  +------------+    +-----------+           +------------+    |+---------+|
                                                              | reference |
                                                              |  counts   |
                                                              +-----------+
</pre></div><br/>
<br/>
 An out-of-place representation is generally less efficient than an in-place representation since it usually requires at least two allocations (one to construct the object and one to construct the shared pointer representation for the object). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Creating an in-place shared pointer does not require the template parameter type to inherit from a special class (such as <code><a class="el" href="classbsl_1_1enable__shared__from__this.html">bsl::enable_shared_from_this</a></code>); in that case, <code>shared_ptr</code> supports up to fourteen arguments that can be passed directly to the object's constructor. For in-place representations, both the object and the representation can be constructed in one allocation as opposed to two, effectively creating an "intrusive" reference counter. Note that the size of the allocation is determined at compile-time from the combined footprint of the object and of the reference counts. It is also possible to create shared pointers to buffers whose sizes are determined at runtime, although such buffers consist of raw (uninitialized) memory. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="weak_pointers_using_~22in-place~22_or_pooled_shared_pointer_representations"></a> <a class="anchor" id="in-place~2Fout-of-place_representations.weak_pointers_using_~22in-place~22_or_pooled_shared_pointer_representations"></a> <a class="anchor" id="description.in-place~2Fout-of-place_representations.weak_pointers_using_~22in-place~22_or_pooled_shared_pointer_representations"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Weak Pointers using "in-place" or Pooled Shared Pointer Representations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A weak pointer that is not in the empty state shares a common representation (used to refer to the shared object) with the shared (or other weak) pointer from which it was constructed, and holds this representation until it is either destroyed or reset. This common representation is not destroyed and deallocated (although the shared object itself may have been destroyed) until all weak references to that common representation have been released. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Due to this behavior the <em>memory</em> <em>footprint</em> of shared objects that are constructed "in-place" in the shared pointer representation (see above) is not deallocated until all weak references to that shared object are released. Note that a shared object is always destroyed when the last shared reference to it is released. Also note that the same behavior applies if the shared object were obtained from a class that pools shared pointer representations (for example, <code>bcec_SharedObjectPool</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example suppose we have a class with a large memory footprint: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>ClassWithLargeFootprint {
      <span class="comment">// This class has a large memory footprint.</span>

      <span class="comment">// TYPES</span>
      <span class="keyword">enum</span> { BUFFER_SIZE = 1024 };
          <span class="comment">// The size of the buffer owned by this &#39;class&#39;.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> d_buffer[BUFFER_SIZE];

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 We then create an "in-place" shared pointer to an object of <code>ClassWithLargeFootprint</code> using the <code>createInplace</code> method of <code>shared_ptr</code>. The <code>sp</code> shared pointer representation of <code>sp</code> will create a <code>ClassWithLargeFootprint</code> object "in-place": <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;ClassWithLargeFootprint&gt; sp;
  sp.createInplace();
</pre></div><br/>
<br/>
 Next we construct a weak pointer from this (in-place) shared pointer: <br/>
<br/>
<div class="fragment"><pre class="fragment">  weak_ptr&lt;ClassWithLargeFootprint&gt; wp(sp);
</pre></div><br/>
<br/>
 Now releasing all shared references to the shared object (using the <code>reset</code> function) causes the object's destructor to be called, but the representation is not destroyed (and the object's footprint is not deallocated) until <code>wp</code> releases its weak reference: <br/>
<br/>
<div class="fragment"><pre class="fragment">  sp.reset(); <span class="comment">// The object&#39;s footprint is not deallocated until all weak</span>
              <span class="comment">// references to it are released.</span>

  wp.reset(); <span class="comment">// The release of the *last* weak reference results in the</span>
              <span class="comment">// destruction and deallocation of the representation and the</span>
              <span class="comment">// object&#39;s footprint.</span>
</pre></div><br/>
<br/>
 If a shared object has a large footprint, and the client anticipates there will be weak references to it, then an out-of-place shared pointer representation may be preferred because it destroys the shared object and deallocates its footprint when the last <em>shared</em> reference is released, regardless of whether there are any outstanding weak references to the same representation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="correct_usage_of_the_allocator_model"></a> <a class="anchor" id="description.correct_usage_of_the_allocator_model"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Correct Usage of the Allocator Model: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that once constructed, there is no difference in type, usage, or efficiency between in-place and out-of-place shared pointers, except that an in-place shared pointer will exhibit greater locality of reference and faster destruction (because there is only one allocated block). Also note that an object created with an allocator needs to have this allocator specified as its last constructor argument, but this allocator may be different from the one passed as the first argument to <code>createInplace</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, consider the following snippet of code: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator1, *allocator2;
  <span class="comment">// ...</span>
  shared_ptr&lt;bsl::string&gt; ptr;
  ptr.createInplace(allocator1, <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>(<span class="stringliteral">&quot;my string&quot;</span>), allocator2);
</pre></div><br/>
<br/>
 Here <code>allocator1</code> is used to obtain the shared pointer representation and the in-place <code>bsl::string</code> object, and <code>allocator2</code> is used by the <code>bsl::string</code> object (having the value "my string") for its memory allocations. Typically, both allocators will be the same, and so the same allocator will need to be specified twice. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="deleters"></a> <a class="anchor" id="description.deleters"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Deleters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>When the last shared reference to a shared object is released, the object is destroyed using the "deleter" provided when the associated shared pointer representation was created. <code>shared_ptr</code> supports two kinds of "deleter" objects, which vary in how they are invoked. A "function-like" deleter is any language entity that can be invoked such that the expression <code>deleterInstance(objectPtr)</code> is a valid expression, and a "factory" deleter is any language entity that can be invoked such that the expression <code>deleterInstance.deleteObject(objectPtr)</code> is a valid expression, where <code>deleterInstance</code> is an instance of the "deleter" object, and <code>objectPtr</code> is a pointer to the shared object. In summary: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Deleter                     Expression used to destroy <span class="stringliteral">&#39;objectPtr&#39;</span>
  - - - - - - - - - - - -     - - - - - - - - - - - - - - - - - - -
  <span class="stringliteral">&quot;function-like&quot;</span>             deleterInstance(objectPtr);
  <span class="stringliteral">&quot;factory&quot;</span>                   deleterInstance.deleteObject(objectPtr);
</pre></div><br/>
<br/>
 The following are examples of function-like deleters that delete an object of <code>my_Type</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> deleteObject(my_Type *<span class="keywordtype">object</span>);
      <span class="comment">// Delete the specified &#39;object&#39;.</span>

  <span class="keywordtype">void</span> releaseObject(my_Type *<span class="keywordtype">object</span>);
      <span class="comment">// Release the specified &#39;object&#39;.</span>

  <span class="keyword">struct </span>FunctionLikeDeleterObject {
      <span class="comment">// This &#39;struct&#39; provides an &#39;operator()&#39; that can be used to delete a</span>
      <span class="comment">// &#39;my_Type&#39; object.</span>

      <span class="keywordtype">void</span> operator()(my_Type *<span class="keywordtype">object</span>);
          <span class="comment">// Destroy the specified &#39;object&#39;.</span>
  };
</pre></div><br/>
<br/>
 The following, on the other hand is an example of a factory deleter: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Factory {

     <span class="comment">// . . .</span>

     <span class="comment">// MANIPULATORS</span>
     my_Type *createObject(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
         <span class="comment">// Create a &#39;my_Type&#39; object.  Optionally specify a</span>
         <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
         <span class="comment">// 0, the currently installed default allocator is used.</span>

     <span class="keywordtype">void</span> deleteObject(my_Type *<span class="keywordtype">object</span>);
         <span class="comment">// Delete the specified &#39;object&#39;.</span>
  };

  <span class="keyword">class </span>my_Allocator : <span class="keyword">public</span> bslma::Allocator { <span class="comment">/* ... */</span> };
</pre></div><br/>
<br/>
 Note that <code>deleteObject</code> is provided by all <code>bslma</code> allocators and by any object that implements the <code>bcema_Deleter</code> protocol. Thus, any of these objects can be used as a factory deleter. The purpose of this design is to allow <code>bslma</code> allocators and factories to be used seamlessly as deleters. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The selection of which expression is used by <code>shared_ptr</code> to destroy a shared object is based on how the deleter is passed to the shared pointer object: Deleters that are passed by <em>address</em> are assumed to be factory deleters (unless they are function pointers), while those that are passed by <em>value</em> are assumed to be function-like. Note that if the wrong interface is used for a deleter, i.e., if a function-like deleter is passed by pointer, or a factory deleter is passed by value, and the expression used to delete the object is invalid, a compiler diagnostic will be emitted indicating the error. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In general, deleters should have defined behavior when called with a null pointer. In all cases, throwing an exception out of a copy constructor for a deleter will yield undefined behavior. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following are examples of constructing shared pointers with the addresses of factory deleters: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_Factory factory;
  my_Type *myPtr1 = factory.createObject();
  shared_ptr&lt;my_Type&gt; mySharedPtr1(myPtr1, &amp;factory, 0);

  bdema_SequentialAllocator sa;
  my_Type *myPtr2 = <span class="keyword">new</span> (sa) my_Type(&amp;sa);
  shared_ptr&lt;my_Type&gt; mySharedPtr2(myPtr2, &amp;sa);
</pre></div><br/>
<br/>
 Note that the deleters are passed <em>by address</em> in the above examples. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following are examples of constructing shared pointers with function-like deleters: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_Type *getObject(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);

  my_Type *myPtr3 = getObject();
  shared_ptr&lt;my_Type&gt; mySharedPtr3(myPtr3, &amp;deleteObject);

  my_Type *myPtr4 = getObject();
  FunctionLikeDeleterObject deleter;
  shared_ptr&lt;my_Type&gt; mySharedPtr4(myPtr4, deleter, &amp;sa);
</pre></div><br/>
<br/>
 Note that <code>deleteObject</code> is also passed by address, but <code>deleter</code> is passed by value in the above examples. Function-like deleter objects (passed by value) are stored by value in the representation and therefore <em>must</em> be copy-constructible. Note that even though the deleter may be passed by reference, it is a copy (owned by the shared pointer representation) that is invoked and thus the <code>deleterInstance</code> is not required, nor assumed, to be non-modifiable. (For the example above, note that <code>operator()</code> is intentionally <em>not</em> defined <code>const</code>.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="aliasing"></a> <a class="anchor" id="description.aliasing"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Aliasing: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>shared_ptr</code> supports a powerful "aliasing" feature. That is, a shared pointer can be constructed to refer to a shared object of a certain type while the shared pointer representation it holds refers to a shared object of any (possibly different) type. All references are applied to the "aliased" shared object referred to by the representation and is used for reference counting. This "aliased" shared object is passed to the deleter upon destruction of the last instance of that shared pointer. Consider the following snippet of code: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Event { <span class="comment">/* ... */</span> };
  <span class="keywordtype">void</span> getEvents(<a class="code" href="classbsl_1_1list.html">bsl::list&lt;Event&gt;</a> *list);

  <span class="keywordtype">void</span> enqueueEvents(bcec_Queue&lt;shared_ptr&lt;Event&gt; &gt; *queue)
  {
      <a class="code" href="classbsl_1_1list.html">bsl::list&lt;Event&gt;</a> eventList;
      getEvents(&amp;eventList);
      <span class="keywordflow">for</span> (<a class="code" href="classbsl_1_1List__Iterator.html">bsl::list&lt;Event&gt;::iterator</a> it = eventList.<a class="code" href="group__bslstl__list.html#ga5c31176fa2f214a7932d504200b37f9f">begin</a>();
           it != eventList.<a class="code" href="group__bslstl__list.html#gaaff91bdeee8bf00648c6f0ea63e89c5d">end</a>();
           ++it) {
          shared_ptr&lt;Event&gt; e;
          e.createInplace(0, *it);  <span class="comment">// Copy construct the event into a new</span>
                                    <span class="comment">// shared ptr.</span>
          queue-&gt;pushBack(e);
      }
  }
</pre></div><br/>
<br/>
 In the above example, <code>getEvents</code> loads into the provided <code><a class="el" href="classbsl_1_1list.html">bsl::list</a></code> a sequence of event objects. The <code>enqueueEvents</code> function constructs an empty list and calls <code>getEvents</code> to fill the list with <code>Event</code> objects. Once the event list is filled, each event item is pushed as a shared pointer (presumably because events are "expensive" to construct and may be referenced simultaneously from multiple threads) onto the provided queue. Since the individual event items are contained by value within the list, pointers to them cannot be passed if it cannot be guaranteed that they will not live beyond the lifetime of the list itself. Therefore, an expensive copy operation is required to create individually-managed instances of each of the list items. The <code>createInplace</code> operation is used to reduce the number of required allocations, but this might still be too expensive. Now consider the following alternate implementation of <code>enqueueEvents</code> using the <code>shared_ptr</code> aliasing feature: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> enqueueEvents(bcec_Queue&lt;shared_ptr&lt;Event&gt; &gt; *queue)
  {
      shared_ptr&lt;bsl::list&lt;Event&gt; &gt; eventList;
      eventList.createInplace(0);  <span class="comment">// Construct a shared pointer</span>
                                   <span class="comment">// to the event list containing</span>
                                   <span class="comment">// all of the events.</span>
      getEvents(eventList.get());

      <span class="keywordflow">for</span> (<a class="code" href="classbsl_1_1List__Iterator.html">bsl::list&lt;Event&gt;::iterator</a> it = eventList-&gt;begin();
           it != eventList-&gt;end();
           ++it) {
          <span class="comment">// Push each event onto the queue as an alias of the &#39;eventList&#39;</span>
          <span class="comment">// shared pointer.  When all the alias references have been</span>
          <span class="comment">// released, the event list will be destroyed deleting all the</span>
          <span class="comment">// events at once.</span>

          queue-&gt;pushBack(shared_ptr&lt;Event&gt;(eventList, &amp;*it));
      }
  }
</pre></div><br/>
<br/>
 In the implementation above, we create a single shared pointer to the <code>Event</code> list, <code>eventList</code>, and use that to create <code>Event</code> shared pointers that are aliased to <code>eventList</code>. The lifetime of each <code>Event</code> object is then tied to the <code>eventList</code> and it will not be destroyed until the <code>eventList</code> is destroyed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="type_casting"></a> <a class="anchor" id="description.type_casting"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Type Casting: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code>shared_ptr</code> object of a given type can be implicitly or explicitly cast to a <code>shared_ptr</code> of another type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="implicit_casting"></a> <a class="anchor" id="type_casting.implicit_casting"></a> <a class="anchor" id="description.type_casting.implicit_casting"></a> <a class="anchor" id="3.7.1"></a> </dd></dl>
<dl class="user"><dt><b>Implicit Casting: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>As with native pointers, a shared pointer to a derived type can be directly assigned to a shared pointer to a base type. In other words, if the following statements are valid: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span><a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> { <span class="keyword">virtual</span> <span class="keywordtype">void</span> foo(); };  <span class="comment">// polymorphic type</span>
  <span class="keyword">class </span>B : <span class="keyword">public</span> <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> {};
  B *bp = 0;
  <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> *ap = bp;
</pre></div><br/>
<br/>
 then the following statements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;B&gt; spb;
  shared_ptr&lt;A&gt; spa;
  spa = spb;
</pre></div><br/>
<br/>
 and: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;B&gt; spb;
  shared_ptr&lt;A&gt; spa(spb);
</pre></div><br/>
<br/>
 are also valid. Note that in all of the above cases, the destructor of <code>B</code> will be invoked when the object is destroyed even if <code>A</code> does not provide a virtual destructor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="explicit_casting"></a> <a class="anchor" id="type_casting.explicit_casting"></a> <a class="anchor" id="description.type_casting.explicit_casting"></a> <a class="anchor" id="3.7.2"></a> </dd></dl>
<dl class="user"><dt><b>Explicit Casting: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Through "aliasing", a shared pointer of any type can be explicitly cast to a shared pointer of any other type using any legal cast expression. For example, to statically cast a shared pointer to type <code>A</code> (<code>shared_ptr&lt;A&gt;</code>) to a shared pointer to type <code>B</code> (<code>shared_ptr&lt;B&gt;</code>), one can simply do the following: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;A&gt; spa;
  shared_ptr&lt;B&gt; spb(spa, static_cast&lt;B *&gt;(spa.get()));
</pre></div><br/>
<br/>
 or even the less safe C-style cast: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;A&gt; spa;
  shared_ptr&lt;B&gt; spb(spa, (B *)(spa.get()));
</pre></div><br/>
<br/>
 For convenience, several utility functions are provided to perform common C++ casts. Dynamic casts, static casts, and <code>const</code> casts are all provided. Explicit casting is supported through the <code><a class="el" href="structbslstl_1_1SharedPtrUtil.html">bslstl::SharedPtrUtil</a></code> utility. The following example demonstrates the dynamic casting of a shared pointer to type <code>A</code> (<code>shared_ptr&lt;A&gt;</code>) to a shared pointer to type <code>B</code> (<code>shared_ptr&lt;B&gt;</code>): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a> nda;
  shared_ptr&lt;A&gt; sp1(<span class="keyword">new</span> (nda) <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a>(), &amp;nda);
  shared_ptr&lt;B&gt; sp2 = bslstl::SharedPtrUtil::dynamicCast&lt;B&gt;(sp1);
  shared_ptr&lt;B&gt; sp3;
  <a class="code" href="structbslstl_1_1SharedPtrUtil.html#a69f6feecf72eebbdb5154d80b313cea6">bslstl::SharedPtrUtil::dynamicCast</a>(&amp;sp3, sp1);
  shared_ptr&lt;B&gt; sp4;
  sp4 = bslstl::SharedPtrUtil::dynamicCast&lt;B&gt;(sp1);
</pre></div><br/>
<br/>
 To test if the cast succeeded, simply test if the target shared pointer refers to a non-null value (assuming the source was not null, of course): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (sp2) {
      <span class="comment">// The cast succeeded.</span>
  } <span class="keywordflow">else</span> {
      <span class="comment">// The cast failed.</span>
  }
</pre></div><br/>
<br/>
 As previously stated, the shared object will be destroyed correctly regardless of how it is cast. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="converting_to_and_from_bloomberglp~3A~3Abslma~3A~3Amanagedptr"></a> <a class="anchor" id="description.converting_to_and_from_bloomberglp~3A~3Abslma~3A~3Amanagedptr"></a> <a class="anchor" id="converting_to_and_from_bloomberglp"></a> <a class="anchor" id="description.converting_to_and_from_bloomberglp"></a> <a class="anchor" id="3.8"></a> </dd></dl>
<dl class="user"><dt><b>Converting to and from BloombergLP::bslma::ManagedPtr: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code>shared_ptr</code> can be converted to a <code>BloombergLP::bslma::ManagedPtr</code> while still retaining proper reference counting. When a shared pointer is converted to a <code>BloombergLP::bslma::ManagedPtr</code>, the number of references to the shared object is incremented. When the managed pointer is destroyed (if not transferred to another managed pointer first), the number of references will be decremented. If the number of references reaches zero, then the shared object will be destroyed. The <code>managedPtr</code> function can be used to create a managed pointer from a shared pointer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code>shared_ptr</code> also can be constructed from a <code>BloombergLP::bslma::ManagedPtr</code>. The resulting shared pointer takes over the management of the object and will use the deleter from the original <code>BloombergLP::bslma::ManagedPtr</code> to destroy the managed object when all the references to that shared object are released. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description.weak_pointers_using_~22in-place~22_or_pooled_shared_pointer_representations"></a> <a class="anchor" id="3.9"></a> </dd></dl>
<dl class="user"><dt><b>Weak Pointers using "in-place" or Pooled Shared Pointer Representations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A weak pointer that is not in the empty state shares a common representation (used to refer to the shared object) with the shared (or other weak) pointer from which it was constructed, and holds this representation until it is either destroyed or reset. This common representation is not destroyed and deallocated (although the shared object itself may have been destroyed) until all weak references to that common representation have been released. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Due to this behavior the memory footprint of shared objects that are constructed "in-place" in the shared pointer representation (refer to the component-level documentation of <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> for more information on shared pointers with "in-place" representations) is not deallocated until all weak references to that shared object are released. Note that a shared object is always destroyed when the last shared reference to it is released. Also note that the same behavior is applicable if the shared objects were obtained from a class that pools shared pointer representations (for example, <code>bcec_SharedObjectPool</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example suppose we have a class with a large memory footprint: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>ClassWithLargeFootprint {
      <span class="comment">// This class has a large memory footprint.</span>

      <span class="comment">// TYPES</span>
      <span class="keyword">enum</span> { BUFFER_SIZE = 1024 };
          <span class="comment">// The size of the buffer owned by this &#39;class&#39;.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> d_buffer[BUFFER_SIZE];

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 We then create an "in-place" shared pointer to an object of <code>ClassWithLargeFootprint</code> using the <code>createInplace</code> method of <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code>. The <code>sp</code> shared pointer representation of <code>sp</code> will create a <code>ClassWithLargeFootprint</code> object "in-place": <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;ClassWithLargeFootprint&gt;</a> sp;
  sp.<a class="code" href="classbsl_1_1shared__ptr.html#aafc3dbf236739df5e017f082b64db6ea">createInplace</a>();
</pre></div><br/>
<br/>
 Next we construct a weak pointer from this (in-place) shared pointer: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;ClassWithLargeFootprint&gt;</a> wp(sp);
</pre></div><br/>
<br/>
 Now releasing all shared references to the shared object (using the <code>reset</code> function) causes the object's destructor to be called, but the representation is not destroyed (and the object's footprint is not deallocated) until <code>wp</code> releases its weak reference: <br/>
<br/>
<div class="fragment"><pre class="fragment">  sp.<a class="code" href="classbsl_1_1shared__ptr.html#aa0dde6ea9a060945e2920464a72e0703">reset</a>(); <span class="comment">// The object&#39;s footprint is not deallocated until all weak</span>
              <span class="comment">// references to it are released.</span>

  wp.reset(); <span class="comment">// The release of the *last* weak reference results in the</span>
              <span class="comment">// destruction and deallocation of the representation and the</span>
              <span class="comment">// object&#39;s footprint.</span>
</pre></div><br/>
<br/>
 If a shared object has a large footprint, and the client anticipates there will be weak references to it, then it may be advisable to create an out-of-place shared pointer representation, which destroys the shared object and deallocates its footprint when the last <em>shared</em> reference to it is released, regardless of whether there are any outstanding weak references to the same representation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="c++_standard_compliance"></a> <a class="anchor" id="description.c++_standard_compliance"></a> <a class="anchor" id="3.10"></a> </dd></dl>
<dl class="user"><dt><b>C++ Standard Compliance: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a (subset of a) standard-compliant implementation of <code>std::shared_ptr</code> and <code>std::weak_ptr</code> (section 20.7.2, [util.smartptr], of the ISO C++11 standard)). Its interface is limited to the set of operations that can be implemented by an implementation of the C++03 language, e,g., there is no specific support for rvalue references. It does not support the atomic shared pointer interface. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component supports allocators following the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol in addition to the C++ Standard Allocators (section 17.6.3.5, [allocator.requirements]) and interoperation with <code><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a></code> smart pointers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.11"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following examples demonstrate various features and uses of shared pointers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_basic_usage"></a> <a class="anchor" id="usage.example_1~3A_basic_usage"></a> <a class="anchor" id="description.usage.example_1~3A_basic_usage"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.11.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example demonstrates the creation of a shared pointer. First, we declare the type of object that we wish to manage: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyUser {
      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_name;
      <span class="keywordtype">int</span>         d_id;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      MyUser(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *alloc = 0) : d_name(alloc), d_id(0) {}
      MyUser(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name, <span class="keywordtype">int</span> <span class="keywordtype">id</span>, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *alloc = 0)
      : d_name(name, alloc)
      , d_id(id)
      {
      }
      MyUser(<span class="keyword">const</span> MyUser&amp; original, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *alloc = 0)
      : d_name(original.d_name, alloc)
      , d_id(original.d_id)
      {
      }

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> setName(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name) { d_name = name; }
      <span class="keywordtype">void</span> setId(<span class="keywordtype">int</span> <span class="keywordtype">id</span>) { d_id = id; }

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_name; }
      <span class="keywordtype">int</span> id()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_id; }
  };
</pre></div><br/>
<br/>
 The <code>createUser</code> utility function (below) creates a <code>MyUser</code> object using the provided allocator and returns a shared pointer to the newly-created object. Note that the shared pointer's internal representation will also be allocated using the same allocator. Also note that if <code>allocator</code> is 0, the currently-installed default allocator is used. <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;MyUser&gt; createUser(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>       name,
                                     <span class="keywordtype">int</span>               <span class="keywordtype">id</span>,
                                     <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      allocator = <a class="code" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a>(allocator);
      MyUser *user = <span class="keyword">new</span> (*allocator) MyUser(name, <span class="keywordtype">id</span>, allocator);
      <span class="keywordflow">return</span> shared_ptr&lt;MyUser&gt;(user, allocator);
  }
</pre></div><br/>
<br/>
 Since the <code>createUser</code> function both allocates the object and creates the shared pointer, it can benefit from the in-place facilities to avoid an extra allocation. Again, note that the representation will also be allocated using the same allocator (see the section "Correct Usage of the
 Allocator Model" above). Also note that if <code>allocator</code> is 0, the currently-installed default allocator is used. <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;MyUser&gt; createUser2(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>       name,
                                      <span class="keywordtype">int</span>               <span class="keywordtype">id</span>,
                                      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      shared_ptr&lt;MyUser&gt; user;
      user.createInplace(allocator, name, <span class="keywordtype">id</span>, allocator);
      <span class="keywordflow">return</span> user;
  }
</pre></div><br/>
<br/>
 Note that the shared pointer allocates both the reference count and the <code>MyUser</code> object in a single region of memory (which is the memory that will eventually be deallocated), but refers to the <code>MyUser</code> object only. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="using_custom_deleters"></a> <a class="anchor" id="usage.using_custom_deleters"></a> <a class="anchor" id="description.usage.using_custom_deleters"></a> <a class="anchor" id="3.11.2"></a> </dd></dl>
<dl class="user"><dt><b>Using Custom Deleters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following examples demonstrate the use of custom deleters with shared pointers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_nil_deleters"></a> <a class="anchor" id="using_custom_deleters.example_2~3A_nil_deleters"></a> <a class="anchor" id="usage.using_custom_deleters.example_2~3A_nil_deleters"></a> <a class="anchor" id="description.usage.using_custom_deleters.example_2~3A_nil_deleters"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="using_custom_deleters.example_2"></a> <a class="anchor" id="usage.using_custom_deleters.example_2"></a> <a class="anchor" id="description.usage.using_custom_deleters.example_2"></a> <a class="anchor" id="3.11.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Nil Deleters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are cases when an interface calls for an object to be passed as a shared pointer, but the object being passed is not owned by the caller (e.g., a pointer to a static variable). In these cases, it is possible to create a shared pointer specifying <code><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a></code> as the deleter. The deleter function provided by <code><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a></code> is a no-op and does not delete the object. The following example demonstrates the use of <code>shared_ptr</code> using a <code><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a></code>. The code uses the <code>MyUser</code> class defined in Example 1. In this example, an asynchronous transaction manager is implemented. Transactions are enqueued into the transaction manager to be processed at some later time. The user associated with the transaction is passed as a shared pointer. Transactions can originate from the "system" or from "users". </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We first declare the transaction manager and transaction info classes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyTransactionInfo {
      <span class="comment">// Transaction Info...</span>
  };

  <span class="keyword">class </span>MyTransactionManager {

      <span class="comment">// PRIVATE MANIPULATORS</span>
      <span class="keywordtype">int</span> enqueueTransaction(shared_ptr&lt;MyUser&gt;  user,
                             <span class="keyword">const</span> MyTransactionInfo&amp; transaction);
    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> MyUser *systemUser(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">int</span> enqueueSystemTransaction(<span class="keyword">const</span> MyTransactionInfo&amp; transaction);

      <span class="keywordtype">int</span> enqueueUserTransaction(<span class="keyword">const</span> MyTransactionInfo&amp; transaction,
                                 shared_ptr&lt;MyUser&gt;  user);

  };
</pre></div><br/>
<br/>
 The <code>systemUser</code> class method returns the same <code>MyUser</code> object and should not be destroyed by its users: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyUser *MyTransactionManager::systemUser(
                                      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *<span class="comment">/* basicAllocator */</span>)
  {
      <span class="keyword">static</span> MyUser *systemUserSingleton;
      <span class="keywordflow">if</span> (!systemUserSingleton) {
          <span class="comment">// instantiate singleton in a thread-safe manner passing</span>
          <span class="comment">// &#39;basicAllocator&#39;</span>

          <span class="comment">// . . .</span>
      }
      <span class="keywordflow">return</span> systemUserSingleton;
  }
</pre></div><br/>
<br/>
 For enqueuing user transactions, simply proxy the information to <code>enqueueTransaction</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyTransactionManager::enqueueUserTransaction(
                                  <span class="keyword">const</span> MyTransactionInfo&amp; transaction,
                                  shared_ptr&lt;MyUser&gt;  user)
  {
      <span class="keywordflow">return</span> enqueueTransaction(user, transaction);
  }
</pre></div><br/>
<br/>
 For system transactions, we must use the <code>MyUser</code> objected returned from the <code>systemUser</code> <code>static</code> method. Since we do not own the returned object, we cannot directly construct a <code>shared_ptr</code> object for it: doing so would result in the singleton being destroyed when the last reference to the shared pointer is released. To solve this problem, we construct a <code>shared_ptr</code> object for the system user using a nil deleter. When the last reference to the shared pointer is released, although the deleter will be invoked to destroy the object, it will do nothing. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> MyTransactionManager::enqueueSystemTransaction(
                                        <span class="keyword">const</span> MyTransactionInfo&amp; transaction)
  {
      shared_ptr&lt;MyUser&gt; user(systemUser(),
                                   <a class="code" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a>(),
                                   0);
      <span class="keywordflow">return</span> enqueueTransaction(user, transaction);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_basic_weak_pointer_usage"></a> <a class="anchor" id="usage.example_3~3A_basic_weak_pointer_usage"></a> <a class="anchor" id="description.usage.example_3~3A_basic_weak_pointer_usage"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.11.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Basic Weak Pointer Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example illustrates the basic syntax needed to create and use a <code><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a></code>. Suppose that we want to construct a weak pointer that refers to an <code>int</code> managed by a shared pointer. Next we define the shared pointer and assign a value to the shared <code>int</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;int&gt;</a> intPtr;
  intPtr.<a class="code" href="classbsl_1_1shared__ptr.html#aafc3dbf236739df5e017f082b64db6ea">createInplace</a>(<a class="code" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a>());
  *intPtr = 10;
  assert(10 == *intPtr);
</pre></div><br/>
<br/>
 Next we construct a weak pointer to the <code>int</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;int&gt;</a> intWeakPtr(intPtr);
  assert(!intWeakPtr.expired());
</pre></div><br/>
<br/>
 <code><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a></code> does not provide direct access to the shared object being referenced. To access and manipulate the <code>int</code> from the weak pointer, we have to obtain a shared pointer from it: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;int&gt;</a> intPtr2 = intWeakPtr.lock();
  assert(intPtr2);
  assert(10 == *intPtr2);

  *intPtr2 = 20;
  assert(20 == *intPtr);
  assert(20 == *intPtr2);
</pre></div><br/>
<br/>
 We remove the weak reference to the shared <code>int</code> by calling the <code>reset</code> method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  intWeakPtr.reset();
  assert(intWeakPtr.expired());
</pre></div><br/>
<br/>
 Note that resetting the weak pointer does not affect the shared pointers referencing the <code>int</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(20 == *intPtr);
  assert(20 == *intPtr2);
</pre></div><br/>
<br/>
 Now, we construct another weak pointer referencing the shared <code>int</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;int&gt;</a> intWeakPtr2(intPtr);
  assert(!intWeakPtr2.expired());
</pre></div><br/>
<br/>
 Finally <code>reset</code> all shared references to the <code>int</code>, which will cause the weak pointer to become "expired"; any subsequent attempt to obtain a shared pointer from the weak pointer will return a shared pointer in the default constructed (empty) state: <br/>
<br/>
<div class="fragment"><pre class="fragment">  intPtr.<a class="code" href="classbsl_1_1shared__ptr.html#aa0dde6ea9a060945e2920464a72e0703">reset</a>();
  intPtr2.<a class="code" href="classbsl_1_1shared__ptr.html#aa0dde6ea9a060945e2920464a72e0703">reset</a>();
  assert(intWeakPtr2.expired());
  assert(!intWeakPtr2.lock());
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_4~3A_breaking_cyclical_dependencies"></a> <a class="anchor" id="usage.example_4~3A_breaking_cyclical_dependencies"></a> <a class="anchor" id="description.usage.example_4~3A_breaking_cyclical_dependencies"></a> <a class="anchor" id="example_4"></a> <a class="anchor" id="usage.example_4"></a> <a class="anchor" id="description.usage.example_4"></a> <a class="anchor" id="3.11.4"></a> </dd></dl>
<dl class="user"><dt><b>Example 4: Breaking Cyclical Dependencies: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Weak pointers are frequently used to break cyclical dependencies between objects that store references to each other via a shared pointer. Consider for example a simplified news alert system that sends news alerts to users based on keywords that they register for. The user information is stored in the <code>User</code> class and the details of the news alert are stored in the <code>Alert</code> class. The class definitions for <code>User</code> and <code>Alert</code> are provided below (with any code not relevant to this example elided): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Alert;

  <span class="keyword">class </span>User {
      <span class="comment">// This class stores the user information required for listening to</span>
      <span class="comment">// alerts.</span>

      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::shared_ptr&lt;Alert&gt;</a> &gt; d_alerts;  <span class="comment">// alerts user is</span>
                                                      <span class="comment">// registered for</span>

      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> addAlert(<span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;Alert&gt;</a>&amp; alertPtr)
      {
          <span class="comment">// Add the specified &#39;alertPtr&#39; to the list of alerts being</span>
          <span class="comment">// monitored by this user.</span>

          d_alerts.push_back(alertPtr);
      }

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Now we define an alert class, <code>Alert</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Alert {
      <span class="comment">// This class stores the alert information required for sending</span>
      <span class="comment">// alerts.</span>

      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::shared_ptr&lt;User&gt;</a> &gt; d_users;  <span class="comment">// users registered</span>
                                                    <span class="comment">// for this alert</span>

    <span class="keyword">public</span>:
      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> addUser(<span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;User&gt;</a>&amp; userPtr)
      {
          <span class="comment">// Add the specified &#39;userPtr&#39; to the list of users monitoring this</span>
          <span class="comment">// alert.</span>

          d_users.push_back(userPtr);
      }

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Even though we have released <code>alertPtr</code> and <code>userPtr</code> there still exists a cyclic reference between the two objects, so none of the objects are destroyed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We can break this cyclical dependency we define a modified alert class <code>ModifiedAlert</code> that stores a weak pointer to a <code>ModifiedUser</code> object. Below is the definition for the <code>ModifiedUser</code> class that is identical to the <code>User</code> class, the only difference being that it stores shared pointer to <code>ModifiedAlert</code>s instead of <code>Alert</code>s: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>ModifiedAlert;

  <span class="keyword">class </span>ModifiedUser {
      <span class="comment">// This class stores the user information required for listening to</span>
      <span class="comment">// alerts.</span>

      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::shared_ptr&lt;ModifiedAlert&gt;</a> &gt; d_alerts;<span class="comment">// alerts user is</span>
                                                            <span class="comment">// registered for</span>

      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> addAlert(<span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;ModifiedAlert&gt;</a>&amp; alertPtr)
      {
          <span class="comment">// Add the specified &#39;alertPtr&#39; to the list of alerts being</span>
          <span class="comment">// monitored by this user.</span>

          d_alerts.push_back(alertPtr);
      }

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Now we define the <code>ModifiedAlert</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>ModifiedAlert {
      <span class="comment">// This class stores the alert information required for sending</span>
      <span class="comment">// alerts.</span>
</pre></div><br/>
<br/>
 Note that the user is stored by a weak pointer instead of by a shared pointer: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::weak_ptr&lt;ModifiedUser&gt;</a> &gt; d_users;  <span class="comment">// users registered</span>
                                                          <span class="comment">// for this alert</span>

    <span class="keyword">public</span>:
      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> addUser(<span class="keyword">const</span> <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;ModifiedUser&gt;</a>&amp; userPtr)
      {
          <span class="comment">// Add the specified &#39;userPtr&#39; to the list of users monitoring this</span>
          <span class="comment">// alert.</span>

          d_users.<a class="code" href="group__bslstl__vector.html#gaa1d6a35af66d87307ee9a48be96644a5">push_back</a>(userPtr);
      }

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_5~3A_caching"></a> <a class="anchor" id="usage.example_5~3A_caching"></a> <a class="anchor" id="description.usage.example_5~3A_caching"></a> <a class="anchor" id="example_5"></a> <a class="anchor" id="usage.example_5"></a> <a class="anchor" id="description.usage.example_5"></a> <a class="anchor" id="3.11.5"></a> </dd></dl>
<dl class="user"><dt><b>Example 5: Caching: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we want to implement a peer to peer file sharing system that allows users to search for files that match specific keywords. A simplistic version of such a system with code not relevant to the usage example elided would have the following parts: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>a) A peer manager class that maintains a list of all connected peers and updates the list based on incoming peer requests and disconnecting peers. The following would be a simple interface for the Peer and PeerManager classes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Peer {
      <span class="comment">// This class stores all the relevant information for a peer.</span>

      <span class="comment">// ...</span>
  };

  <span class="keyword">class </span>PeerManager {
      <span class="comment">// This class acts as a manager of peers and adds and removes peers</span>
      <span class="comment">// based on peer requests and disconnections.</span>

      <span class="comment">// DATA</span>
</pre></div><br/>
<br/>
 The peer objects are stored by shared pointer to allow peers to be passed to search results and still allow their asynchronous destruction when peers disconnect. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbsl_1_1map.html">bsl::map&lt;int, bsl::shared_ptr&lt;Peer&gt;</a> &gt; d_peers;

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 b) A peer cache class that stores a subset of the peers that are used for sending search requests. The cache may select peers based on their connection bandwidth, relevancy of previous search results, etc. For brevity the population and flushing of this cache is not shown: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>PeerCache {
      <span class="comment">// This class caches a subset of all peers that match certain criteria</span>
      <span class="comment">// including connection bandwidth, relevancy of previous search</span>
      <span class="comment">// results, etc.</span>
</pre></div><br/>
<br/>
 Note that the cached peers are stored as a weak pointer so as not to interfere with the cleanup of Peer objects by the PeerManager if a Peer goes down. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1list.html">bsl::list&lt;bsl::weak_ptr&lt;Peer&gt;</a> &gt; d_cachedPeers;

    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1list.html">bsl::list&lt;bsl::weak_ptr&lt;Peer&gt;</a> &gt;::const_iterator PeerConstIter;

      <span class="comment">// ...</span>

      <span class="comment">// ACCESSORS</span>
      PeerConstIter begin()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_cachedPeers.<a class="code" href="group__bslstl__list.html#ga5c31176fa2f214a7932d504200b37f9f">begin</a>(); }
      PeerConstIter end()<span class="keyword"> const   </span>{ <span class="keywordflow">return</span> d_cachedPeers.<a class="code" href="group__bslstl__list.html#gaaff91bdeee8bf00648c6f0ea63e89c5d">end</a>(); }
  };
</pre></div><br/>
<br/>
 c) A search result class that stores a search result and encapsulates a peer with the file name stored by the peer that best matches the specified keywords: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>SearchResult {
      <span class="comment">// This class provides a search result and encapsulates a particular</span>
      <span class="comment">// peer and filename combination that matches a specified set of</span>
      <span class="comment">// keywords.</span>
</pre></div><br/>
<br/>
 The peer is stored as a weak pointer because when the user decides to select a particular file to download from this peer, the peer might have disconnected. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;Peer&gt;</a> d_peer;
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>         d_filename;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      SearchResult(<span class="keyword">const</span> <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;Peer&gt;</a>&amp; peer,
                   <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;         filename)
      : d_peer(peer)
      , d_filename(filename)
      {
      }

      <span class="comment">// ...</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;Peer&gt;</a>&amp; peer()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_peer; }
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; filename()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_filename; }
  };
</pre></div><br/>
<br/>
 d) A search function that takes a list of keywords and returns available results by searching the cached peers: <br/>
<br/>
<div class="fragment"><pre class="fragment">  ;

  <span class="keywordtype">void</span> search(<a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;SearchResult&gt;</a>       *<span class="comment">/* results */</span>,
              <span class="keyword">const</span> PeerCache&amp;                 peerCache,
              <span class="keyword">const</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a>&amp;  <span class="comment">/* keywords */</span>)
  {
      <span class="keywordflow">for</span> (PeerCache::PeerConstIter iter = peerCache.begin();
           iter != peerCache.end();
           ++iter) {
</pre></div><br/>
<br/>
 First we check if the peer is still connected by acquiring a shared pointer to the peer. If the acquire operation succeeds, then we can send the peer a request to send back the file best matching the specified keywords: <br/>
<br/>
<div class="fragment"><pre class="fragment">          <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;Peer&gt;</a> peerSharedPtr = iter-&gt;lock();
          <span class="keywordflow">if</span> (peerSharedPtr) {

              <span class="comment">// Search the peer for file best matching the specified</span>
              <span class="comment">// keywords and if a file is found add the returned</span>
              <span class="comment">// SearchResult object to result.</span>

              <span class="comment">// ...</span>
          }
      }
  }
</pre></div><br/>
<br/>
 e) A download function that downloads a file selected by the user: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> download(<span class="keyword">const</span> SearchResult&amp; result)
  {
      <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;Peer&gt;</a> peerSharedPtr = result.peer().lock();
      <span class="keywordflow">if</span> (peerSharedPtr) {
          <span class="comment">// Download the result.filename() file from peer knowing that</span>
          <span class="comment">// the peer is still connected.</span>
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:08 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
