<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslstl_sharedptr Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_sharedptr<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a generic reference-counted shared pointer wrapper.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt; ELEMENT_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt; ELEMENT_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslstl_1_1SharedPtr__DefaultDeleter.html">bslstl::SharedPtr_DefaultDeleter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1SharedPtr__RepProctor.html">bslstl::SharedPtr_RepProctor</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ELEMENT_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga61ba33bd2aeb0d92257c509d5871e5e2">bsl::shared_ptr::element_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ELEMENT_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga499733138e91edd57c5e1094a3a3ab57">bsl::shared_ptr::ElementType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ELEMENT_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga419d042c15b44670e9e8009d669ff153">bsl::weak_ptr::element_type</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga25bfad5e168d83249437014e7b6b8892">bsl::shared_ptr::shared_ptr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga5d2c2bd0c5dedf8e1198be362c0e0a82">bsl::shared_ptr::shared_ptr</a> (<a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga841c0f3459e54c1bf2158eb56b285093">bsl::shared_ptr::shared_ptr</a> (COMPATIBLE_TYPE *ptr)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gab7e1c63bc0f6cdf8a18745b0c52139ea">bsl::shared_ptr::shared_ptr</a> (COMPATIBLE_TYPE *ptr, BloombergLP::bslma::Allocator *basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga2a2e4bbff3006535d3173733b9f8ae2e">bsl::shared_ptr::shared_ptr</a> (ELEMENT_TYPE *ptr, BloombergLP::bslma::SharedPtrRep *rep)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE , class DELETER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga63d96baa49ed23efc1ac35505e2470ec">bsl::shared_ptr::shared_ptr</a> (COMPATIBLE_TYPE *ptr, DELETER *deleter)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE , class DELETER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga4cf0fdbff78c2ec3563ce9b7e6035b5a">bsl::shared_ptr::shared_ptr</a> (COMPATIBLE_TYPE *ptr, DELETER deleter, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE , class DELETER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gab2364e0cb3da8a2dfb19a423e3ce7d78">bsl::shared_ptr::shared_ptr</a> (COMPATIBLE_TYPE *ptr, DELETER deleter, ALLOCATOR basicAllocator, typename ALLOCATOR::value_type *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaadfe208676a03d4f1a718ac73b9f02e5">bsl::shared_ptr::shared_ptr</a> (nullptr_t nullPointerLiteral, BloombergLP::bslma::Allocator *basicAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class DELETER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gab0aa4a12d2b2002b2a6b5ec8d45ee774">bsl::shared_ptr::shared_ptr</a> (nullptr_t nullPointerLiteral, DELETER deleter, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class DELETER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga171ec51dc51b118a2c6bcfeac955fef8">bsl::shared_ptr::shared_ptr</a> (nullptr_t nullPointerLiteral, DELETER deleter, ALLOCATOR basicAllocator, typename ALLOCATOR::value_type *=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gad32ea0635de6a74d765ff432e7b6567e">bsl::shared_ptr::shared_ptr</a> (BloombergLP::bslma::ManagedPtr&lt; COMPATIBLE_TYPE &gt; managedPtr, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga31b7a3668bfef03fb5f66571eee139ed">bsl::shared_ptr::shared_ptr</a> (native_std::auto_ptr&lt; COMPATIBLE_TYPE &gt; &amp;autoPtr, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gabc7e7eb011eeea91ca07faeba21d5637">bsl::shared_ptr::shared_ptr</a> (native_std::auto_ptr_ref&lt; ELEMENT_TYPE &gt; autoRef, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga12461f1c2a32564f2e6aed992f147811">bsl::shared_ptr::shared_ptr</a> (const shared_ptr&lt; ANY_TYPE &gt; &amp;source, ELEMENT_TYPE *object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga52fd5aa2c3c730f07461871d120d2030">bsl::shared_ptr::shared_ptr</a> (const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gae1ba18a40fd81b46b1a579a0500164f2">bsl::shared_ptr::shared_ptr</a> (const shared_ptr &amp;original)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga00a7faf4ca60527b1506d9f90696d904">bsl::shared_ptr::shared_ptr</a> (const weak_ptr&lt; COMPATIBLE_TYPE &gt; &amp;ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaec035331c8d985691fd7c5929173259a">bsl::shared_ptr::~shared_ptr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">shared_ptr &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga1888243089d89d2d68487862ebe43eb8">bsl::shared_ptr::operator=</a> (const shared_ptr &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga40dddf94f309f6c0cfbe24d83a175f4c">bsl::shared_ptr::operator=</a> (const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaca3f778cf04e601b8ecf06e73fd42b8c">bsl::shared_ptr::operator=</a> (native_std::auto_ptr&lt; COMPATIBLE_TYPE &gt; rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga37f640bcf2343ba65ee81e87a794e35f">bsl::shared_ptr::reset</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga1a88d1f07d3287acb0a33871f005c6be">bsl::shared_ptr::reset</a> (COMPATIBLE_TYPE *ptr)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE , class DELETER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa004e232be1e2d260520369cbc95490d">bsl::shared_ptr::reset</a> (COMPATIBLE_TYPE *ptr, DELETER deleter)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE , class DELETER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gad56d4c635e12daf994c79a264d45bd19">bsl::shared_ptr::reset</a> (COMPATIBLE_TYPE *ptr, DELETER deleter, ALLOCATOR basicAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga880253329316183fae55d7670bf02cd5">bsl::shared_ptr::reset</a> (const shared_ptr&lt; ANY_TYPE &gt; &amp;source, ELEMENT_TYPE *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga57d3480dc19ef08fb4704e768a7f69ff">bsl::shared_ptr::swap</a> (shared_ptr &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaafc3dbf236739df5e017f082b64db6ea">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga03b9c9c63a4f1edccfb12a1a1075f72e">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga39246fe1a4523a81686c59232495a3f5">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gab3fc58be99de52434c7974e3d6fa795e">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga652422a023fdaa27313f11d5d0ce384c">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga55af65860795eb30bad02fb83508d5e2">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga9260b9f283836bd34814564f475759e3">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga02d1f3eb9a6c35471edb1ac1979b2da0">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gae3066aae4de276e4327ba8d94a09f130">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga640c4b75bf8a9ac0fb2af1604605a833">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga6565009e5d3855e7dc86f62de741b928">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa80b3327e687a5abf2c479986507d1aa">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga64401cd05e867290147dabf55dfbf3b1">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga51e62667dc0fa364f94d7d70d34f424b">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaf998e53f52f90d11c49a564bdbf5ae61">bsl::shared_ptr::createInplace</a> (BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga710218b15aeac3ab96e1269038a5aa21">bsl::shared_ptr::loadAlias</a> (const shared_ptr&lt; ANY_TYPE &gt; &amp;source, ELEMENT_TYPE *object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pair&lt; ELEMENT_TYPE <br class="typebreak"/>
*, BloombergLP::bslma::SharedPtrRep * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga54f46f5bb220e063bd7c097b8302a838">bsl::shared_ptr::release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga31292c33e0410049a25c59c0c4b74049">bsl::shared_ptr::operator BoolType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">add_lvalue_reference<br class="typebreak"/>
&lt; ELEMENT_TYPE &gt;::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga7561cfb064b73fc506712a0bf4b4f6d1">bsl::shared_ptr::operator*</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ELEMENT_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaf0b9e0d68f8775c9f64c4df92d0f0d9b">bsl::shared_ptr::operator-&gt;</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ELEMENT_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga48f002a13755bd11276a297079d8254e">bsl::shared_ptr::get</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gac888622df34e855572e95f569686308c">bsl::shared_ptr::owner_before</a> (const shared_ptr&lt; ANY_TYPE &gt; &amp;other) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga02e27d5b5b2bd9654791f92988bad1ea">bsl::shared_ptr::owner_before</a> (const weak_ptr&lt; ANY_TYPE &gt; &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga71ce3c0494bfb53b944cfad471f458cc">bsl::shared_ptr::unique</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga577317da7b2aa99e58309cc7db1941de">bsl::shared_ptr::use_count</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">add_lvalue_reference<br class="typebreak"/>
&lt; ELEMENT_TYPE &gt;::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gac951c0325b8179829b715d8e9e48c595">bsl::shared_ptr::operator[]</a> (ptrdiff_t index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BloombergLP::bslma::ManagedPtr<br class="typebreak"/>
&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gacf1fa65139ac6e757e041353be18897e">bsl::shared_ptr::managedPtr</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BloombergLP::bslma::SharedPtrRep *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa2c9e02ec8be7cb54746f8a41b0b5c12">bsl::shared_ptr::rep</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga1c1c2704b92642dd439cdad97a848d57">bsl::operator==</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga3a77beaa9951f55de2c793f025d576c4">bsl::operator!=</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga66ad66d30f8224d17b9a095394af53a3">bsl::operator&lt;</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga18eb1b3e0476913d7ba6ba1af5f1bde0">bsl::operator&gt;</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaf7d2404f8ddbbf36bbf27fe3fb8685a7">bsl::operator&lt;=</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE , class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gae407f6ed76abc4c51b61472c966c28fc">bsl::operator&gt;=</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga02586f71629626fe00132cefebf9d0f6">bsl::operator==</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga6ebbfc95461e707c1219dcfd8d5eb65c">bsl::operator==</a> (nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaf6de5b2e8b27c39f51c873993d71f9ad">bsl::operator!=</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gae1eab178a468625aa5836216595b076c">bsl::operator!=</a> (nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaf4c4bb456f48f1842cb63357527e9644">bsl::operator&lt;</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga88c588f14653fec148e0f293794505a4">bsl::operator&lt;</a> (nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga2fcb633c59eda20af4715e688bf0dbee">bsl::operator&lt;=</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga013b0c9607f5b710d6e54a95137560ed">bsl::operator&lt;=</a> (nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga8b013ca7ef46710259e40234cfcc735a">bsl::operator&gt;</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaeb88e103f0bc7111f829207a03644bcb">bsl::operator&gt;</a> (nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class LHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gac55976d83a9c4bb361e6d9acdb221405">bsl::operator&gt;=</a> (const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RHS_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gad53c3f8eaccc4210b0d6aa129870e5f8">bsl::operator&gt;=</a> (nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ELEMENT_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">native_std::basic_ostream<br class="typebreak"/>
&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaef9191e2d4f9e99421de794cfa210c63">bsl::operator&lt;&lt;</a> (native_std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;stream, const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class HASHALG , class ELEMENT_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gafe12b0f6723f7f260ec2c37f78ecc034">bsl::hashAppend</a> (HASHALG &amp;hashAlg, const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;input)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga050d5c3fbf77c1ddc00d3e18c07cebc8">bsl::swap</a> (shared_ptr&lt; ELEMENT_TYPE &gt; &amp;a, shared_ptr&lt; ELEMENT_TYPE &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class DELETER , class ELEMENT_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">DELETER *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga52fdaf60492df2fe31fe398d13184f82">bsl::get_deleter</a> (const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;p)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TO_TYPE , class FROM_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; TO_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga903f6e4e7b2befd616936456786efa34">bsl::const_pointer_cast</a> (const shared_ptr&lt; FROM_TYPE &gt; &amp;source)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TO_TYPE , class FROM_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; TO_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa4dded295fd97099aa32efb1d6e2a054">bsl::dynamic_pointer_cast</a> (const shared_ptr&lt; FROM_TYPE &gt; &amp;source)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TO_TYPE , class FROM_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; TO_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga22893acbe6dca3b4184b1b5f92891c09">bsl::static_pointer_cast</a> (const shared_ptr&lt; FROM_TYPE &gt; &amp;source)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga842124bb63d969e2caf74d9acab97fc5">bsl::allocate_shared</a> (ALLOC basicAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaf2cdad3ee884ea8b77ab9c1426f56fbd">bsl::allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaafac01371f305d61c5c78789e1e7946d">bsl::allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaf290055ca0d2dd2a1cb63b87b45c1150">bsl::allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga01d65a5dc53c7e2eb8e3611e26eb97bc">bsl::allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga2bd5e0e636661483155a7c1c8b3e38ae">bsl::allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga53ddafd51e59bf1e423a926039c54b52">bsl::allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga5c2325b69b0e632dce693eef38ec06b8">bsl::allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga2a65a4a51652aba5a8bba984d8619ae9">bsl::allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gace3929d2362de8b5b52094a9f6d6eed2">bsl::allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaac721eeddc042f80302f2b9f4785b53a">bsl::allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga9606c6f277d02bbfcc74c06f7cba41d1">bsl::allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gab59fe722c57eec981284f58d5d20cd29">bsl::allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa1da907c0dbd8b80f8a3c768e85e7d5d">bsl::allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gab57cfb5ad98e1adf035316e35672077a">bsl::allocate_shared</a> (ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa5cf03e39a028e9896de9a8c08df1445">bsl::allocate_shared</a> (ALLOC *basicAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga7f487dab167660990e57e8f6dd4ce8e6">bsl::allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga952b9d0f95d7a0f91f485d1146beb191">bsl::allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga2168d1fe1563beb5029888bf7f64f2ec">bsl::allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga0e189e4547a008770d94657320a19757">bsl::allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaffcd074404490763a00537270d15a919">bsl::allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga4074c4cc4167a9ed7c6c2dc5f88e7d29">bsl::allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga5d1ed3d2127b1f90ee4f088e236b98aa">bsl::allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga777ca6cbbff46d15b499a10a901d7d11">bsl::allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga9075db3c0bc09d1fb7fbcca6f8109392">bsl::allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga43c7f93dad387f6c22e352c18e4ebf21">bsl::allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga6a16b6a4c819dfbd9fb72dd3e1e7580a">bsl::allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga4b455a513f5fa28d4199646af210ef14">bsl::allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga3cdaf66722173632cf99dcba808fe7a4">bsl::allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga852abbdd03b262816ec5f706e78daa66">bsl::allocate_shared</a> (ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga0afacd0aecba8ee3341580f6e696bee5">bsl::make_shared</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga948481509b5773206e5ea25c52b61283">bsl::make_shared</a> (const A1 &amp;a1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaed83c08eabc1f22ff41be3d7949b016a">bsl::make_shared</a> (const A1 &amp;a1, const A2 &amp;a2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga5b3b07f21e4b038a58efa13ea2583d18">bsl::make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga5ccdad6d77d6f91c4d26d36a2a1c9933">bsl::make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gad70fcbb076fc7c7c9e75f297f2149c58">bsl::make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga41fdc22eb8ffb9ac386b266e2b100f47">bsl::make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga0a18cef762683586ddcf554750974540">bsl::make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga5386aae75c602403e22c26f58d9aa3f2">bsl::make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga0c90eba2b70dc7509f69950d04bfee31">bsl::make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga98eed9180e3758990ff0bda0b0f41683">bsl::make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga47afd18d2ac49909d2f78359550bcd65">bsl::make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gae7f8b8e43681cb4423673c7dce5488b1">bsl::make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga72666c8cd2da3ed6ce6bd6c27f0cd189">bsl::make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga3876caafb24bb32d3300754b741cd7a6">bsl::make_shared</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gad857b724f69dc6b25d1797702102549f">bsl::weak_ptr::weak_ptr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gae2adefc8f8926f276c3ecf36daa874f0">bsl::weak_ptr::weak_ptr</a> (const weak_ptr &amp;original)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga35a234785bed69f0cb3b9c69b466e707">bsl::weak_ptr::weak_ptr</a> (const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gab7aa5423fab31f0cd5d86514d85b13c9">bsl::weak_ptr::weak_ptr</a> (const weak_ptr&lt; COMPATIBLE_TYPE &gt; &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga2aef66bfe030b2aaecc59dcf3717f762">bsl::weak_ptr::~weak_ptr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">weak_ptr &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga688404a7ec31a3c2da8a8ad097bcb3d4">bsl::weak_ptr::operator=</a> (const weak_ptr &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">weak_ptr &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaec46064b65bcee0e7dbc947c38ceb75f">bsl::weak_ptr::operator=</a> (const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class COMPATIBLE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">weak_ptr &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga1e3495245099b3146e82bd006e586c70">bsl::weak_ptr::operator=</a> (const weak_ptr&lt; COMPATIBLE_TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga9d4ffeef0e33e4bbb6664605f39467af">bsl::weak_ptr::reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga74555d04ec23d02199d7c79951a5fc65">bsl::weak_ptr::swap</a> (weak_ptr &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaee9df79d0a4d9bc4aa352692d98490e3">bsl::weak_ptr::expired</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; ELEMENT_TYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga839f5aa12ddb60bd5fcc260849b406ac">bsl::weak_ptr::lock</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga9ec9e1557a53ecc665ac8ff8d38a45b7">bsl::weak_ptr::owner_before</a> (const shared_ptr&lt; ANY_TYPE &gt; &amp;other) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ANY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga8b95837ff793e790ed40b52877ce67fc">bsl::weak_ptr::owner_before</a> (const weak_ptr&lt; ANY_TYPE &gt; &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BloombergLP::bslma::SharedPtrRep *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga363c49165444b7f320feab8c3e24c940">bsl::weak_ptr::rep</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gad550e30b99fea724afcc02ad3433e141">bsl::weak_ptr::use_count</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ELEMENT_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gad7f43c35a15e87ad6e3f859c47f135f4">bsl::swap</a> (weak_ptr&lt; ELEMENT_TYPE &gt; &amp;a, weak_ptr&lt; ELEMENT_TYPE &gt; &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga6c2a72c4594b6193d545ae660731e0d4">bslstl::SharedPtrUtil::throwBadWeakPtr</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET , class SOURCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa7c3c7f1ae148cf6352b0fa6708a4aff">bslstl::SharedPtrUtil::constCast</a> (<a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt; *target, const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;source)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET , class SOURCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gafcce9eb23f8b3a7c494351c7cf9246f7">bslstl::SharedPtrUtil::constCast</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;source)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET , class SOURCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga69f6feecf72eebbdb5154d80b313cea6">bslstl::SharedPtrUtil::dynamicCast</a> (<a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt; *target, const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;source)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET , class SOURCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga7a422696c4adaaaaf54b519943563277">bslstl::SharedPtrUtil::dynamicCast</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;source)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET , class SOURCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaf025d8bc5b749fb04ae5d983e9fb605f">bslstl::SharedPtrUtil::staticCast</a> (<a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt; *target, const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;source)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET , class SOURCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gaa1e0c5e3e5a6041d830b7909dfe00bbd">bslstl::SharedPtrUtil::staticCast</a> (const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;source)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga8e1b55cac7dd44a68a1c4994289e373d">bslstl::SharedPtr_RepProctor::SharedPtr_RepProctor</a> (<a class="el" href="classbslma_1_1SharedPtrRep.html">bslma::SharedPtrRep</a> *rep)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#gabd1cddccae2f2fb5da0afd605c732110">bslstl::SharedPtr_RepProctor::~SharedPtr_RepProctor</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga64a079eb850eb72d5468958edbe37388">bslstl::SharedPtr_RepProctor::release</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="friend-members"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga9a4da829475f0cf1809fc6ef555ffe06">bsl::shared_ptr::shared_ptr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__sharedptr.html#ga73fb185cab8b7bb5f231491bb497071c">bsl::weak_ptr::weak_ptr</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread-Safety</a> </li>
<li>
<a href="#3.2">Shared and Weak References</a> </li>
<li>
<a href="#3.3">In-place/Out-of-place Representations</a> <ul>
<li>
<a href="#3.3.1">Weak Pointers using "in-place" or Pooled Shared Pointer Representations</a> </li>
</ul>
</li>
<li>
<a href="#3.4">Correct Usage of the Allocator Model</a> </li>
<li>
<a href="#3.5">Deleters</a> </li>
<li>
<a href="#3.6">Aliasing</a> </li>
<li>
<a href="#3.7">Type Casting</a> <ul>
<li>
<a href="#3.7.1">Implicit Casting</a> </li>
<li>
<a href="#3.7.2">Explicit Casting</a> </li>
</ul>
</li>
<li>
<a href="#3.8">Converting to and from <code>BloombergLP::bslma::ManagedPtr</code></a> </li>
<li>
<a href="#3.9">Weak Pointers using "in-place" or Pooled Shared Pointer Representations</a> </li>
<li>
<a href="#3.10">C++ Standard Compliance</a> </li>
<li>
<a href="#3.11">Usage</a> <ul>
<li>
<a href="#3.11.1">Example 1 - Basic Usage</a> </li>
<li>
<a href="#3.11.2">Using Custom Deleters</a> <ul>
<li>
<a href="#3.11.2.1">Example 2 - Nil deleters</a> </li>
</ul>
</li>
<li>
<a href="#3.11.3">Example 3 - Basic Weak Pointer Usage</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a generic reference-counted shared pointer wrapper. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a> </td><td>shared pointer  </td></tr>
<tr>
<td><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a> </td><td>"weak" reference to reference-counted shared object  </td></tr>
<tr>
<td><a class="el" href="structbslstl_1_1SharedPtrUtil.html">bslstl::SharedPtrUtil</a> </td><td>shared pointer utility functions  </td></tr>
<tr>
<td><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a> </td><td>no-op deleter  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__managedptr.html" title="Provide a managed pointer class.">Component bslma_managedptr</a>, <a class="el" href="group__bslma__sharedptrrep.html" title="Provide an abstract class for a shared object manager.">Component bslma_sharedptrrep</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements a thread-safe, generic, reference-counted "smart pointer" to support "shared ownership" of objects of (template parameter) <code>ELEMENT_TYPE</code>. Shared pointers implement a form of the "envelope/letter" idiom. For each shared object, a representation that manages the number of references to it is created. Many shared pointers can simultaneously refer to the same shared object by storing a reference to the same representation. Shared pointers also implement the "construction is
 acquisition, destruction is release" idiom. When a shared pointer is created it increments the number of shared references to the shared object that was specified to its constructor (or was referred to by a shared pointer passed to the copy constructor). When a shared pointer is assigned to or destroyed, then the number of shared references to the shared object is decremented. When all references to the shared object are released, both the representation and the object are destroyed. <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> emulates the interface of a native pointer. The shared object may be accessed directly using the <code>-&gt;</code> operator, or the dereference operator (operator <code>*</code>) can be used to obtain a reference to the shared object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component also provides a mechanism, <code><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a></code>, used to create weak references to reference-counted shared (<code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code>) objects. A weak reference provides conditional access to a shared object managed by a <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code>, but, unlike a shared (or "strong") reference, does not affect the shared object's lifetime. An object having even one shared reference to it will not be destroyed, but an object having only weak references would have been destroyed when the last shared reference was released. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A weak pointer can be constructed from another weak pointer or a <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code>. To access the shared object referenced by a weak pointer clients must first obtain a shared pointer to that object using the <code>lock</code> method. If the shared object has been destroyed (as indicated by the <code>expired</code> method), then <code>lock</code> returns a shared pointer in the default constructed (empty) state. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component also provides a functor, <code><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a></code>, which may used to create a shared pointer that takes no action when the last shared reference is destroyed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component also provides a utility class, <code><a class="el" href="structbslstl_1_1SharedPtrUtil.html">bslstl::SharedPtrUtil</a></code>, which provides several functions that are frequently used with shared pointers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread-safety"></a> <a class="anchor" id="description.thread-safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread-Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section qualifies the thread-safety of <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> objects and <code><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a></code> objects themselves rather than the thread-safety of the objects being referenced. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is safe to access or modify two distinct <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> (or <code><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a></code>) objects simultaneously, each from a separate thread, even if they share ownership of a common object. It is safe to access a single <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> (or <code><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a></code>) object simultaneously from two or more separate threads, provided no other thread is simultaneously modifying the object. It is not safe to access or modify a <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> (or <code><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a></code>) object in one thread while another thread modifies the same object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is safe to access, modify, copy, or delete a shared pointer (or weak pointer) in one thread, while other threads access or modify other shared pointers and weak pointers pointing to or managing the same object (the reference count is managed using atomic operations). However, there is no guarantee regarding the safety of accessing or modifying the object <em>referred</em> <em>to</em> by the shared pointer simultaneously from multiple threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="shared_and_weak_references"></a> <a class="anchor" id="description.shared_and_weak_references"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Shared and Weak References: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are two types of references to shared objects: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>1) A shared reference allows users to share the ownership of an object and control its lifetime. A shared object is destroyed only when the last shared reference to it is released. A shared reference to an object can be obtained by creating a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> referring to it. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>2) A weak reference provides users conditional access to an object without sharing its ownership (or affecting its lifetime). A shared object can be destroyed even if there are weak references to it. A weak reference to an object can be obtained by creating a <code><a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a></code> referring to the object from a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> referring to that object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="in-place~2Fout-of-place_representations"></a> <a class="anchor" id="description.in-place~2Fout-of-place_representations"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>In-place/Out-of-place Representations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> provides two types of representations: an out-of-place representation, and an in-place representation. Out-of-place representations are used to refer to objects that are constructed externally to their associated representations. Out-of-place objects are provided to a shared pointer by passing their address along with the deleter that should be used to destroy the object when all references to it have been released. In-place objects can be constructed directly within a shared pointer representation (see <code>createInplace</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Below we provide a diagram illustrating the differences between the two representations for a shared pointer to an <code>int</code>. First we create an <code>int</code> object on the heap, initialized to 10, and pass its address to a shared pointer constructor, resulting in an out-of-place representation for the shared object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a> nda;
  <span class="keywordtype">int</span> *value = <span class="keyword">new</span> (nda) <span class="keywordtype">int</span>(10);
  shared_ptr&lt;int&gt; outOfPlaceSharedPtr(value, &amp;nda);
</pre></div><br/>
<br/>
 Next we create an in-place representation of a shared <code>int</code> object that is also initialized to 10: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;int&gt; inPlaceSharedPtr;
  inPlaceSharedPtr.createInplace(&amp;nda, 10);
</pre></div><br/>
<br/>
 The memory layouts of these two representations are shown below (where <code>d_ptr_p</code> refers to the shared object and <code>d_rep_p</code> refers to the representation): <br/>
<br/>
<div class="fragment"><pre class="fragment">  Out-of-Place Representation                 In-Place Representation
  ----------------------------              ----------------------------

  +------------+                            +------------+
  |            |                            |            |
  |  d_ptr_p ------&gt;+-----------+           |  d_ptr_p ---------+
  |            |    |     10    |           |            |      |
  |            |    +-----------+           |            |      |
  |            |                            |            |      |
  |  d_rep_p ------&gt;+-----------+           |  d_rep_p ------&gt;+-v---------+
  |            |    | reference |           |            |    |+---------+|
  |            |    |  counts   |           |            |    ||    10   ||
  +------------+    +-----------+           +------------+    |+---------+|
                                                              | reference |
                                                              |  counts   |
                                                              +-----------+
</pre></div><br/>
<br/>
 An out-of-place representation is generally less efficient than an in-place representation since it usually requires at least two allocations (one to construct the object and one to construct the shared pointer representation for the object). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Creating an in-place shared pointer does not require the template parameter type to inherit from a special class (such as <code>bsl::enable_shared_from_this</code>); in that case, <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> supports up to fourteen arguments that can be passed directly to the object's constructor. For in-place representations, both the object and the representation can be constructed in one allocation as opposed to two, effectively creating an "intrusive" reference counter. Note that the size of the allocation is determined at compile-time from the combined footprint of the object and of the reference counts. It is also possible to create shared pointers to buffers whose sizes are determined at runtime, although such buffers consist of raw (uninitialized) memory. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="weak_pointers_using_~22in-place~22_or_pooled_shared_pointer_representations"></a> <a class="anchor" id="in-place~2Fout-of-place_representations.weak_pointers_using_~22in-place~22_or_pooled_shared_pointer_representations"></a> <a class="anchor" id="description.in-place~2Fout-of-place_representations.weak_pointers_using_~22in-place~22_or_pooled_shared_pointer_representations"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Weak Pointers using "in-place" or Pooled Shared Pointer Representations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A weak pointer that is not in the empty state shares a common representation (used to refer to the shared object) with the shared (or other weak) pointer from which it was constructed, and holds this representation until it is either destroyed or reset. This common representation is not destroyed and deallocated (although the shared object itself may have been destroyed) until all weak references to that common representation have been released. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Due to this behavior the <em>memory</em> <em>footprint</em> of shared objects that are constructed "in-place" in the shared pointer representation (see above) is not deallocated until all weak references to that shared object are released. Note that a shared object is always destroyed when the last shared reference to it is released. Also note that the same behavior applies if the shared object were obtained from a class that pools shared pointer representations (for example, <code>bcec_SharedObjectPool</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example suppose we have a class with a large memory footprint: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>ClassWithLargeFootprint {
      <span class="comment">// This class has a large memory footprint.</span>

      <span class="comment">// TYPES</span>
      <span class="keyword">enum</span> { BUFFER_SIZE = 1024 };
          <span class="comment">// The size of the buffer owned by this &#39;class&#39;.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> d_buffer[BUFFER_SIZE];

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 We then create an "in-place" shared pointer to an object of <code>ClassWithLargeFootprint</code> using the <code>createInplace</code> method of <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code>. The <code>sp</code> shared pointer representation of <code>sp</code> will create a <code>ClassWithLargeFootprint</code> object "in-place": <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;ClassWithLargeFootprint&gt; sp;
  sp.createInplace();
</pre></div><br/>
<br/>
 Next we construct a weak pointer from this (in-place) shared pointer: <br/>
<br/>
<div class="fragment"><pre class="fragment">  weak_ptr&lt;ClassWithLargeFootprint&gt; wp(sp);
</pre></div><br/>
<br/>
 Now releasing all shared references to the shared object (using the <code>reset</code> function) causes the object's destructor to be called, but the representation is not destroyed (and the object's footprint is not deallocated) until <code>wp</code> releases its weak reference: <br/>
<br/>
<div class="fragment"><pre class="fragment">  sp.reset(); <span class="comment">// The object&#39;s footprint is not deallocated until all weak</span>
              <span class="comment">// references to it are released.</span>

  wp.reset(); <span class="comment">// The release of the *last* weak reference results in the</span>
              <span class="comment">// destruction and deallocation of the representation and the</span>
              <span class="comment">// object&#39;s footprint.</span>
</pre></div><br/>
<br/>
 If a shared object has a large footprint, and the client anticipates there will be weak references to it, then an out-of-place shared pointer representation may be preferred because it destroys the shared object and deallocates its footprint when the last <em>shared</em> reference is released, regardless of whether there are any outstanding weak references to the same representation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="correct_usage_of_the_allocator_model"></a> <a class="anchor" id="description.correct_usage_of_the_allocator_model"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Correct Usage of the Allocator Model: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that once constructed, there is no difference in type, usage, or efficiency between in-place and out-of-place shared pointers, except that an in-place shared pointer will exhibit greater locality of reference and faster destruction (because there is only one allocated block). Also note that an object created with an allocator needs to have this allocator specified as its last constructor argument, but this allocator may be different from the one passed as the first argument to <code>createInplace</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, consider the following snippet of code: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator1, *allocator2;
  <span class="comment">// ...</span>
  shared_ptr&lt;bsl::string&gt; ptr;
  ptr.createInplace(allocator1, <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>(<span class="stringliteral">&quot;my string&quot;</span>), allocator2);
</pre></div><br/>
<br/>
 Here <code>allocator1</code> is used to obtain the shared pointer representation and the in-place <code>bsl::string</code> object, and <code>allocator2</code> is used by the <code>bsl::string</code> object (having the value "my string") for its memory allocations. Typically, both allocators will be the same, and so the same allocator will need to be specified twice. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="deleters"></a> <a class="anchor" id="description.deleters"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Deleters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>When the last shared reference to a shared object is released, the object is destroyed using the "deleter" provided when the associated shared pointer representation was created. <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> supports two kinds of "deleter" objects, which vary in how they are invoked. A "function-like" deleter is any language entity that can be invoked such that the expression <code>deleterInstance(objectPtr)</code> is a valid expression, and a "factory" deleter is any language entity that can be invoked such that the expression <code>deleterInstance.deleteObject(objectPtr)</code> is a valid expression, where <code>deleterInstance</code> is an instance of the "deleter" object, and <code>objectPtr</code> is a pointer to the shared object. In summary: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Deleter                     Expression used to destroy <span class="stringliteral">&#39;objectPtr&#39;</span>
  - - - - - - - - - - - -     - - - - - - - - - - - - - - - - - - -
  <span class="stringliteral">&quot;function-like&quot;</span>             deleterInstance(objectPtr);
  <span class="stringliteral">&quot;factory&quot;</span>                   deleterInstance.deleteObject(objectPtr);
</pre></div><br/>
<br/>
 The following are examples of function-like deleters that delete an object of <code>my_Type</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> deleteObject(my_Type *<span class="keywordtype">object</span>);
      <span class="comment">// Delete the specified &#39;object&#39;.</span>

  <span class="keywordtype">void</span> releaseObject(my_Type *<span class="keywordtype">object</span>);
      <span class="comment">// Release the specified &#39;object&#39;.</span>

  <span class="keyword">struct </span>FunctionLikeDeleterObject {
      <span class="comment">// This &#39;struct&#39; provides an &#39;operator()&#39; that can be used to delete a</span>
      <span class="comment">// &#39;my_Type&#39; object.</span>

      <span class="keywordtype">void</span> operator()(my_Type *<span class="keywordtype">object</span>);
          <span class="comment">// Destroy the specified &#39;object&#39;.</span>
  };
</pre></div><br/>
<br/>
 The following, on the other hand is an example of a factory deleter: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Factory {

     <span class="comment">// . . .</span>

     <span class="comment">// MANIPULATORS</span>
     my_Type *createObject(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
         <span class="comment">// Create a &#39;my_Type&#39; object.  Optionally specify a</span>
         <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
         <span class="comment">// 0, the currently installed default allocator is used.</span>

     <span class="keywordtype">void</span> deleteObject(my_Type *<span class="keywordtype">object</span>);
         <span class="comment">// Delete the specified &#39;object&#39;.</span>
  };

  <span class="keyword">class </span>my_Allocator : <span class="keyword">public</span> bslma::Allocator { <span class="comment">/* ... */</span> };
</pre></div><br/>
<br/>
 Note that <code>deleteObject</code> is provided by all <code>bslma</code> allocators and by any object that implements the <code>bcema_Deleter</code> protocol. Thus, any of these objects can be used as a factory deleter. The purpose of this design is to allow <code>bslma</code> allocators and factories to be used seamlessly as deleters. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The selection of which expression is used by <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> to destroy a shared object is based on how the deleter is passed to the shared pointer object: Deleters that are passed by <em>address</em> are assumed to be factory deleters (unless they are function pointers), while those that are passed by <em>value</em> are assumed to be function-like. Note that if the wrong interface is used for a deleter, i.e., if a function-like deleter is passed by pointer, or a factory deleter is passed by value, and the expression used to delete the object is invalid, a compiler diagnostic will be emitted indicating the error. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In general, deleters should have defined behavior when called with a null pointer. In all cases, throwing an exception out of a copy constructor for a deleter will yield undefined behavior. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following are examples of constructing shared pointers with the addresses of factory deleters: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_Factory factory;
  my_Type *myPtr1 = factory.createObject();
  shared_ptr&lt;my_Type&gt; mySharedPtr1(myPtr1, &amp;factory, 0);

  bdema_SequentialAllocator sa;
  my_Type *myPtr2 = <span class="keyword">new</span> (sa) my_Type(&amp;sa);
  shared_ptr&lt;my_Type&gt; mySharedPtr2(myPtr2, &amp;sa);
</pre></div><br/>
<br/>
 Note that the deleters are passed <em>by address</em> in the above examples. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following are examples of constructing shared pointers with function-like deleters: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_Type *getObject(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);

  my_Type *myPtr3 = getObject();
  shared_ptr&lt;my_Type&gt; mySharedPtr3(myPtr3, &amp;deleteObject);

  my_Type *myPtr4 = getObject();
  FunctionLikeDeleterObject deleter;
  shared_ptr&lt;my_Type&gt; mySharedPtr4(myPtr4, deleter, &amp;sa);
</pre></div><br/>
<br/>
 Note that <code>deleteObject</code> is also passed by address, but <code>deleter</code> is passed by value in the above examples. Function-like deleter objects (passed by value) are stored by value in the representation and therefore <em>must</em> be copy-constructible. Note that even though the deleter may be passed by reference, it is a copy (owned by the shared pointer representation) that is invoked and thus the <code>deleterInstance</code> is not required, nor assumed, to be non-modifiable. (For the example above, note that <code>operator()</code> is intentionally <em>not</em> defined <code>const</code>.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="aliasing"></a> <a class="anchor" id="description.aliasing"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Aliasing: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> supports a powerful "aliasing" feature. That is, a shared pointer can be constructed to refer to a shared object of a certain type while the shared pointer representation it holds refers to a shared object of any (possibly different) type. All references are applied to the "aliased" shared object referred to by the representation and is used for reference counting. This "aliased" shared object is passed to the deleter upon destruction of the last instance of that shared pointer. Consider the following snippet of code: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Event { <span class="comment">/* ... */</span> };
  <span class="keywordtype">void</span> getEvents(<a class="code" href="classbsl_1_1list.html">bsl::list&lt;Event&gt;</a> *list);

  <span class="keywordtype">void</span> enqueueEvents(bcec_Queue&lt;shared_ptr&lt;Event&gt; &gt; *queue)
  {
      <a class="code" href="classbsl_1_1list.html">bsl::list&lt;Event&gt;</a> eventList;
      getEvents(&amp;eventList);
      <span class="keywordflow">for</span> (<a class="code" href="classbsl_1_1List__Iterator.html">bsl::list&lt;Event&gt;::iterator</a> it = eventList.<a class="code" href="group__bslstl__list.html#ga5c31176fa2f214a7932d504200b37f9f">begin</a>();
           it != eventList.<a class="code" href="group__bslstl__list.html#gaaff91bdeee8bf00648c6f0ea63e89c5d">end</a>();
           ++it) {
          shared_ptr&lt;Event&gt; e;
          e.createInplace(0, *it);  <span class="comment">// Copy construct the event into a new</span>
                                    <span class="comment">// shared ptr.</span>
          queue-&gt;pushBack(e);
      }
  }
</pre></div><br/>
<br/>
 In the above example, <code>getEvents</code> loads into the provided <code><a class="el" href="classbsl_1_1list.html">bsl::list</a></code> a sequence of event objects. The <code>enqueueEvents</code> function constructs an empty list and calls <code>getEvents</code> to fill the list with <code>Event</code> objects. Once the event list is filled, each event item is pushed as a shared pointer (presumably because events are "expensive" to construct and may be referenced simultaneously from multiple threads) onto the provided queue. Since the individual event items are contained by value within the list, pointers to them cannot be passed if it cannot be guaranteed that they will not live beyond the lifetime of the list itself. Therefore, an expensive copy operation is required to create individually-managed instances of each of the list items. The <code>createInplace</code> operation is used to reduce the number of required allocations, but this might still be too expensive. Now consider the following alternate implementation of <code>enqueueEvents</code> using the <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> aliasing feature: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> enqueueEvents(bcec_Queue&lt;shared_ptr&lt;Event&gt; &gt; *queue)
  {
      shared_ptr&lt;bsl::list&lt;Event&gt; &gt; eventList;
      eventList.createInplace(0);  <span class="comment">// Construct a shared pointer</span>
                                   <span class="comment">// to the event list containing</span>
                                   <span class="comment">// all of the events.</span>
      getEvents(eventList.get());

      <span class="keywordflow">for</span> (<a class="code" href="classbsl_1_1List__Iterator.html">bsl::list&lt;Event&gt;::iterator</a> it = eventList-&gt;begin();
           it != eventList-&gt;end();
           ++it) {
          <span class="comment">// Push each event onto the queue as an alias of the &#39;eventList&#39;</span>
          <span class="comment">// shared pointer.  When all the alias references have been</span>
          <span class="comment">// released, the event list will be destroyed deleting all the</span>
          <span class="comment">// events at once.</span>

          queue-&gt;pushBack(shared_ptr&lt;Event&gt;(eventList, &amp;*it));
      }
  }
</pre></div><br/>
<br/>
 In the implementation above, we create a single shared pointer to the <code>Event</code> list, <code>eventList</code>, and use that to create <code>Event</code> shared pointers that are aliased to <code>eventList</code>. The lifetime of each <code>Event</code> object is then tied to the <code>eventList</code> and it will not be destroyed until the <code>eventList</code> is destroyed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="type_casting"></a> <a class="anchor" id="description.type_casting"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Type Casting: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> object of a given type can be implicitly or explicitly cast to a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> of another type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="implicit_casting"></a> <a class="anchor" id="type_casting.implicit_casting"></a> <a class="anchor" id="description.type_casting.implicit_casting"></a> <a class="anchor" id="3.7.1"></a> </dd></dl>
<dl class="user"><dt><b>Implicit Casting: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>As with native pointers, a shared pointer to a derived type can be directly assigned to a shared pointer to a base type. In other words, if the following statements are valid: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>A { <span class="keyword">virtual</span> <span class="keywordtype">void</span> foo(); };  <span class="comment">// polymorphic type</span>
  <span class="keyword">class </span>B : <span class="keyword">public</span> A {};
  B *bp = 0;
  A *ap = bp;
</pre></div><br/>
<br/>
 then the following statements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;B&gt; spb;
  shared_ptr&lt;A&gt; spa;
  spa = spb;
</pre></div><br/>
<br/>
 and: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;B&gt; spb;
  shared_ptr&lt;A&gt; spa(spb);
</pre></div><br/>
<br/>
 are also valid. Note that in all of the above cases, the destructor of <code>B</code> will be invoked when the object is destroyed even if <code>A</code> does not provide a virtual destructor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="explicit_casting"></a> <a class="anchor" id="type_casting.explicit_casting"></a> <a class="anchor" id="description.type_casting.explicit_casting"></a> <a class="anchor" id="3.7.2"></a> </dd></dl>
<dl class="user"><dt><b>Explicit Casting: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Through "aliasing", a shared pointer of any type can be explicitly cast to a shared pointer of any other type using any legal cast expression. For example, to statically cast a shared pointer to type <code>A</code> (<code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;A&gt;</code>) to a shared pointer to type <code>B</code> (<code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;B&gt;</code>), one can simply do the following: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;A&gt; spa;
  shared_ptr&lt;B&gt; spb(spa, static_cast&lt;B *&gt;(spa.get()));
</pre></div><br/>
<br/>
 or even the less safe C-style cast: <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;A&gt; spa;
  shared_ptr&lt;B&gt; spb(spa, (B *)(spa.get()));
</pre></div><br/>
<br/>
 For convenience, several utility functions are provided to perform common C++ casts. Dynamic casts, static casts, and <code>const</code> casts are all provided. Explicit casting is supported through the <code><a class="el" href="structbslstl_1_1SharedPtrUtil.html">bslstl::SharedPtrUtil</a></code> utility. The following example demonstrates the dynamic casting of a shared pointer to type <code>A</code> (<code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;A&gt;</code>) to a shared pointer to type <code>B</code> (<code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;B&gt;</code>): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a> nda;
  shared_ptr&lt;A&gt; sp1(<span class="keyword">new</span> (nda) A(), &amp;nda);
  shared_ptr&lt;B&gt; sp2 = bslstl::SharedPtrUtil::dynamicCast&lt;B&gt;(sp1);
  shared_ptr&lt;B&gt; sp3;
  <a class="code" href="group__bslstl__sharedptr.html#ga69f6feecf72eebbdb5154d80b313cea6">bslstl::SharedPtrUtil::dynamicCast</a>(&amp;sp3, sp1);
  shared_ptr&lt;B&gt; sp4;
  sp4 = bslstl::SharedPtrUtil::dynamicCast&lt;B&gt;(sp1);
</pre></div><br/>
<br/>
 To test if the cast succeeded, simply test if the target shared pointer refers to a non-null value (assuming the source was not null, of course): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (sp2) {
      <span class="comment">// The cast succeeded.</span>
  } <span class="keywordflow">else</span> {
      <span class="comment">// The cast failed.</span>
  }
</pre></div><br/>
<br/>
 As previously stated, the shared object will be destroyed correctly regardless of how it is cast. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="converting_to_and_from_bloomberglp~3A~3Abslma~3A~3Amanagedptr"></a> <a class="anchor" id="description.converting_to_and_from_bloomberglp~3A~3Abslma~3A~3Amanagedptr"></a> <a class="anchor" id="converting_to_and_from_bloomberglp"></a> <a class="anchor" id="description.converting_to_and_from_bloomberglp"></a> <a class="anchor" id="3.8"></a> </dd></dl>
<dl class="user"><dt><b>Converting to and from BloombergLP::bslma::ManagedPtr: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> can be converted to a <code>BloombergLP::bslma::ManagedPtr</code> while still retaining proper reference counting. When a shared pointer is converted to a <code>BloombergLP::bslma::ManagedPtr</code>, the number of references to the shared object is incremented. When the managed pointer is destroyed (if not transferred to another managed pointer first), the number of references will be decremented. If the number of references reaches zero, then the shared object will be destroyed. The <code>managedPtr</code> function can be used to create a managed pointer from a shared pointer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> also can be constructed from a <code>BloombergLP::bslma::ManagedPtr</code>. The resulting shared pointer takes over the management of the object and will use the deleter from the original <code>BloombergLP::bslma::ManagedPtr</code> to destroy the managed object when all the references to that shared object are released. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description.weak_pointers_using_~22in-place~22_or_pooled_shared_pointer_representations"></a> <a class="anchor" id="3.9"></a> </dd></dl>
<dl class="user"><dt><b>Weak Pointers using "in-place" or Pooled Shared Pointer Representations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A weak pointer that is not in the empty state shares a common representation (used to refer to the shared object) with the shared (or other weak) pointer from which it was constructed, and holds this representation until it is either destroyed or reset. This common representation is not destroyed and deallocated (although the shared object itself may have been destroyed) until all weak references to that common representation have been released. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Due to this behavior the memory footprint of shared objects that are constructed "in-place" in the shared pointer representation (refer to the component-level documentation of <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> for more information on shared pointers with "in-place" representations) is not deallocated until all weak references to that shared object are released. Note that a shared object is always destroyed when the last shared reference to it is released. Also note that the same behavior is applicable if the shared objects were obtained from a class that pools shared pointer representations (for example, <code>bcec_SharedObjectPool</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example suppose we have a class with a large memory footprint: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>ClassWithLargeFootprint {
      <span class="comment">// This class has a large memory footprint.</span>

      <span class="comment">// TYPES</span>
      <span class="keyword">enum</span> { BUFFER_SIZE = 1024 };
          <span class="comment">// The size of the buffer owned by this &#39;class&#39;.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> d_buffer[BUFFER_SIZE];

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 We then create an "in-place" shared pointer to an object of <code>ClassWithLargeFootprint</code> using the <code>createInplace</code> method of <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code>. The <code>sp</code> shared pointer representation of <code>sp</code> will create a <code>ClassWithLargeFootprint</code> object "in-place": <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;ClassWithLargeFootprint&gt;</a> sp;
  sp.<a class="code" href="group__bslstl__sharedptr.html#gaafc3dbf236739df5e017f082b64db6ea">createInplace</a>();
</pre></div><br/>
<br/>
 Next we construct a weak pointer from this (in-place) shared pointer: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;ClassWithLargeFootprint&gt;</a> wp(sp);
</pre></div><br/>
<br/>
 Now releasing all shared references to the shared object (using the <code>reset</code> function) causes the object's destructor to be called, but the representation is not destroyed (and the object's footprint is not deallocated) until <code>wp</code> releases its weak reference: <br/>
<br/>
<div class="fragment"><pre class="fragment">  sp.<a class="code" href="group__bslstl__sharedptr.html#ga37f640bcf2343ba65ee81e87a794e35f">reset</a>(); <span class="comment">// The object&#39;s footprint is not deallocated until all weak</span>
              <span class="comment">// references to it are released.</span>

  wp.reset(); <span class="comment">// The release of the *last* weak reference results in the</span>
              <span class="comment">// destruction and deallocation of the representation and the</span>
              <span class="comment">// object&#39;s footprint.</span>
</pre></div><br/>
<br/>
 If a shared object has a large footprint, and the client anticipates there will be weak references to it, then it may be advisable to create an out-of-place shared pointer representation, which destroys the shared object and deallocates its footprint when the last <em>shared</em> reference to it is released, regardless of whether there are any outstanding weak references to the same representation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="c++_standard_compliance"></a> <a class="anchor" id="description.c++_standard_compliance"></a> <a class="anchor" id="3.10"></a> </dd></dl>
<dl class="user"><dt><b>C++ Standard Compliance: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a (subset of a) standard-compliant implementation of <code>std::shared_ptr</code> and <code>std::weak_ptr</code> (section 20.7.2, [util.smartptr], of the ISO C++11 standard)). Its interface is limited to the set of operations that can be implemented by an implementation of the C++03 language, e,g., there is no specific support for rvalue references. It does not support the atomic shared pointer interface, nor does it collaborate with types that derive from <code>std::enable_shared_this</code>: using <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> with such types will result in (very destructive) undefined behavior. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component supports allocators following the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol in addition to the C++ Standard Allocators (section 17.6.3.5, [allocator.requirements]) and interoperation with <code><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a></code> smart pointers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.11"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following examples demonstrate various features and uses of shared pointers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1_-_basic_usage"></a> <a class="anchor" id="usage.example_1_-_basic_usage"></a> <a class="anchor" id="description.usage.example_1_-_basic_usage"></a> <a class="anchor" id="3.11.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1 - Basic Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example demonstrates the creation of a shared pointer. First, we declare the type of object that we wish to manage: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyUser {
      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_name;
      <span class="keywordtype">int</span>         d_id;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      MyUser(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *alloc = 0) : d_name(alloc), d_id(0) {}
      MyUser(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name, <span class="keywordtype">int</span> <span class="keywordtype">id</span>, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *alloc = 0)
      : d_name(name, alloc)
      , d_id(id)
      {
      }
      MyUser(<span class="keyword">const</span> MyUser&amp; original, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *alloc = 0)
      : d_name(original.d_name, alloc)
      , d_id(original.d_id)
      {
      }

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> setName(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name) { d_name = name; }
      <span class="keywordtype">void</span> setId(<span class="keywordtype">int</span> <span class="keywordtype">id</span>) { d_id = id; }

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_name; }
      <span class="keywordtype">int</span> id()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_id; }
  };
</pre></div><br/>
<br/>
 The <code>createUser</code> utility function (below) creates a <code>MyUser</code> object using the provided allocator and returns a shared pointer to the newly-created object. Note that the shared pointer's internal representation will also be allocated using the same allocator. Also note that if <code>allocator</code> is 0, the currently-installed default allocator is used. <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;MyUser&gt; createUser(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>       name,
                                     <span class="keywordtype">int</span>               <span class="keywordtype">id</span>,
                                     <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      allocator = <a class="code" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a>(allocator);
      MyUser *user = <span class="keyword">new</span> (*allocator) MyUser(name, <span class="keywordtype">id</span>, allocator);
      <span class="keywordflow">return</span> shared_ptr&lt;MyUser&gt;(user, allocator);
  }
</pre></div><br/>
<br/>
 Since the <code>createUser</code> function both allocates the object and creates the shared pointer, it can benefit from the in-place facilities to avoid an extra allocation. Again, note that the representation will also be allocated using the same allocator (see the section "Correct Usage of the
 Allocator Model" above). Also note that if <code>allocator</code> is 0, the currently-installed default allocator is used. <br/>
<br/>
<div class="fragment"><pre class="fragment">  shared_ptr&lt;MyUser&gt; createUser2(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>       name,
                                      <span class="keywordtype">int</span>               <span class="keywordtype">id</span>,
                                      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      shared_ptr&lt;MyUser&gt; user;
      user.createInplace(allocator, name, <span class="keywordtype">id</span>, allocator);
      <span class="keywordflow">return</span> user;
  }
</pre></div><br/>
<br/>
 Note that the shared pointer allocates both the reference count and the <code>MyUser</code> object in a single region of memory (which is the memory that will eventually be deallocated), but refers to the <code>MyUser</code> object only. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="using_custom_deleters"></a> <a class="anchor" id="usage.using_custom_deleters"></a> <a class="anchor" id="description.usage.using_custom_deleters"></a> <a class="anchor" id="3.11.2"></a> </dd></dl>
<dl class="user"><dt><b>Using Custom Deleters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following examples demonstrate the use of custom deleters with shared pointers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2_-_nil_deleters"></a> <a class="anchor" id="using_custom_deleters.example_2_-_nil_deleters"></a> <a class="anchor" id="usage.using_custom_deleters.example_2_-_nil_deleters"></a> <a class="anchor" id="description.usage.using_custom_deleters.example_2_-_nil_deleters"></a> <a class="anchor" id="3.11.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 2 - Nil deleters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are cases when an interface calls for an object to be passed as a shared pointer, but the object being passed is not owned by the caller (e.g., a pointer to a static variable). In these cases, it is possible to create a shared pointer specifying <code><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a></code> as the deleter. The deleter function provided by <code><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a></code> is a no-op and does not delete the object. The following example demonstrates the use of <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> using a <code><a class="el" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a></code>. The code uses the <code>MyUser</code> class defined in Example 1. In this example, an asynchronous transaction manager is implemented. Transactions are enqueued into the transaction manager to be processed at some later time. The user associated with the transaction is passed as a shared pointer. Transactions can originate from the "system" or from "users". </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We first declare the transaction manager and transaction info classes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyTransactionInfo {
      <span class="comment">// Transaction Info...</span>
  };

  <span class="keyword">class </span>MyTransactionManager {

      <span class="comment">// PRIVATE MANIPULATORS</span>
      <span class="keywordtype">int</span> enqueueTransaction(shared_ptr&lt;MyUser&gt;  user,
                             <span class="keyword">const</span> MyTransactionInfo&amp; transaction);
    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> MyUser *systemUser(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">int</span> enqueueSystemTransaction(<span class="keyword">const</span> MyTransactionInfo&amp; transaction);

      <span class="keywordtype">int</span> enqueueUserTransaction(<span class="keyword">const</span> MyTransactionInfo&amp; transaction,
                                 shared_ptr&lt;MyUser&gt;  user);

  };
</pre></div><br/>
<br/>
 The <code>systemUser</code> class method returns the same <code>MyUser</code> object and should not be destroyed by its users: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyUser *MyTransactionManager::systemUser(
                                      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *<span class="comment">/* basicAllocator */</span>)
  {
      <span class="keyword">static</span> MyUser *systemUserSingleton;
      <span class="keywordflow">if</span> (!systemUserSingleton) {
          <span class="comment">// instantiate singleton in a thread-safe manner passing</span>
          <span class="comment">// &#39;basicAllocator&#39;</span>

          <span class="comment">// . . .</span>
      }
      <span class="keywordflow">return</span> systemUserSingleton;
  }
</pre></div><br/>
<br/>
 For enqueuing user transactions, simply proxy the information to <code>enqueueTransaction</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyTransactionManager::enqueueUserTransaction(
                                  <span class="keyword">const</span> MyTransactionInfo&amp; transaction,
                                  shared_ptr&lt;MyUser&gt;  user)
  {
      <span class="keywordflow">return</span> enqueueTransaction(user, transaction);
  }
</pre></div><br/>
<br/>
 For system transactions, we must use the <code>MyUser</code> objected returned from the <code>systemUser</code> <code>static</code> method. Since we do not own the returned object, we cannot directly construct a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> object for it: doing so would result in the singleton being destroyed when the last reference to the shared pointer is released. To solve this problem, we construct a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> object for the system user using a nil deleter. When the last reference to the shared pointer is released, although the deleter will be invoked to destroy the object, it will do nothing. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> MyTransactionManager::enqueueSystemTransaction(
                                        <span class="keyword">const</span> MyTransactionInfo&amp; transaction)
  {
      shared_ptr&lt;MyUser&gt; user(systemUser(),
                                   <a class="code" href="structbslstl_1_1SharedPtrNilDeleter.html">bslstl::SharedPtrNilDeleter</a>(),
                                   0);
      <span class="keywordflow">return</span> enqueueTransaction(user, transaction);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3_-_basic_weak_pointer_usage"></a> <a class="anchor" id="usage.example_3_-_basic_weak_pointer_usage"></a> <a class="anchor" id="description.usage.example_3_-_basic_weak_pointer_usage"></a> <a class="anchor" id="3.11.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3 - Basic Weak Pointer Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example illustrates the basic syntax needed to create and use a <code><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a></code>. Suppose that we want to construct a weak pointer that refers to an <code>int</code> managed by a shared pointer. Next we define the shared pointer and assign a value to the shared <code>int</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;int&gt;</a> intPtr;
  intPtr.<a class="code" href="group__bslstl__sharedptr.html#gaafc3dbf236739df5e017f082b64db6ea">createInplace</a>(<a class="code" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a>());
  *intPtr = 10;
  assert(10 == *intPtr);
</pre></div><br/>
<br/>
 Next we construct a weak pointer to the <code>int</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;int&gt;</a> intWeakPtr(intPtr);
  assert(!intWeakPtr.expired());
</pre></div><br/>
<br/>
 <code><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a></code> does not provide direct access to the shared object being referenced. To access and manipulate the <code>int</code> from the weak pointer, we have to obtain a shared pointer from it: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;int&gt;</a> intPtr2 = intWeakPtr.lock();
  assert(intPtr2);
  assert(10 == *intPtr2);

  *intPtr2 = 20;
  assert(20 == *intPtr);
  assert(20 == *intPtr2);
</pre></div><br/>
<br/>
 We remove the weak reference to the shared <code>int</code> by calling the <code>reset</code> method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  intWeakPtr.reset();
  assert(intWeakPtr.expired());
</pre></div><br/>
<br/>
 Note that resetting the weak pointer does not affect the shared pointers referencing the <code>int</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(20 == *intPtr);
  assert(20 == *intPtr2);
</pre></div><br/>
<br/>
 Now, we construct another weak pointer referencing the shared <code>int</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;int&gt;</a> intWeakPtr2(intPtr);
  assert(!intWeakPtr2.expired());
</pre></div><br/>
<br/>
 Finally <code>reset</code> all shared references to the <code>int</code>, which will cause the weak pointer to become "expired"; any subsequent attempt to obtain a shared pointer from the weak pointer will return a shared pointer in the default constructed (empty) state: <br/>
<br/>
<div class="fragment"><pre class="fragment">  intPtr.<a class="code" href="group__bslstl__sharedptr.html#ga37f640bcf2343ba65ee81e87a794e35f">reset</a>();
  intPtr2.<a class="code" href="group__bslstl__sharedptr.html#ga37f640bcf2343ba65ee81e87a794e35f">reset</a>();
  assert(intWeakPtr2.expired());
  assert(!intWeakPtr2.lock());
</pre></div><br/>
<br/>
 Example 4 - Breaking cyclical dependencies<ul>
<li>- - - - - - - - - - - - - - - - - - - - - Weak pointers are frequently used to break cyclical dependencies between objects that store references to each other via a shared pointer. Consider for example a simplified news alert system that sends news alerts to users based on keywords that they register for. The user information is stored in the <code>User</code> class and the details of the news alert are stored in the <code>Alert</code> class. The class definitions for <code>User</code> and <code>Alert</code> are provided below (with any code not relevant to this example elided): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Alert;

  <span class="keyword">class </span>User {
      <span class="comment">// This class stores the user information required for listening to</span>
      <span class="comment">// alerts.</span>

      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::shared_ptr&lt;Alert&gt;</a> &gt; d_alerts;  <span class="comment">// alerts user is</span>
                                                      <span class="comment">// registered for</span>

      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> addAlert(<span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;Alert&gt;</a>&amp; alertPtr)
      {
          <span class="comment">// Add the specified &#39;alertPtr&#39; to the list of alerts being</span>
          <span class="comment">// monitored by this user.</span>

          d_alerts.push_back(alertPtr);
      }

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Now we define an alert class, <code>Alert</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Alert {
      <span class="comment">// This class stores the alert information required for sending</span>
      <span class="comment">// alerts.</span>

      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::shared_ptr&lt;User&gt;</a> &gt; d_users;  <span class="comment">// users registered</span>
                                                    <span class="comment">// for this alert</span>

    <span class="keyword">public</span>:
      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> addUser(<span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;User&gt;</a>&amp; userPtr)
      {
          <span class="comment">// Add the specified &#39;userPtr&#39; to the list of users monitoring this</span>
          <span class="comment">// alert.</span>

          d_users.push_back(userPtr);
      }

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Even though we have released <code>alertPtr</code> and <code>userPtr</code> there still exists a cyclic reference between the two objects, so none of the objects are destroyed. </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>We can break this cyclical dependency we define a modified alert class <code>ModifiedAlert</code> that stores a weak pointer to a <code>ModifiedUser</code> object. Below is the definition for the <code>ModifiedUser</code> class that is identical to the <code>User</code> class, the only difference being that it stores shared pointer to <code>ModifiedAlert</code>s instead of <code>Alert</code>s: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>ModifiedAlert;

  <span class="keyword">class </span>ModifiedUser {
      <span class="comment">// This class stores the user information required for listening to</span>
      <span class="comment">// alerts.</span>

      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::shared_ptr&lt;ModifiedAlert&gt;</a> &gt; d_alerts;<span class="comment">// alerts user is</span>
                                                            <span class="comment">// registered for</span>

      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> addAlert(<span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;ModifiedAlert&gt;</a>&amp; alertPtr)
      {
          <span class="comment">// Add the specified &#39;alertPtr&#39; to the list of alerts being</span>
          <span class="comment">// monitored by this user.</span>

          d_alerts.push_back(alertPtr);
      }

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Now we define the <code>ModifiedAlert</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>ModifiedAlert {
      <span class="comment">// This class stores the alert information required for sending</span>
      <span class="comment">// alerts.</span>
</pre></div><br/>
<br/>
 Note that the user is stored by a weak pointer instead of by a shared pointer: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::weak_ptr&lt;ModifiedUser&gt;</a> &gt; d_users;  <span class="comment">// users registered</span>
                                                          <span class="comment">// for this alert</span>

    <span class="keyword">public</span>:
      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> addUser(<span class="keyword">const</span> <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;ModifiedUser&gt;</a>&amp; userPtr)
      {
          <span class="comment">// Add the specified &#39;userPtr&#39; to the list of users monitoring this</span>
          <span class="comment">// alert.</span>

          d_users.<a class="code" href="group__bslstl__vector.html#gaa1d6a35af66d87307ee9a48be96644a5">push_back</a>(userPtr);
      }

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Usage example 5 - Caching example<ul>
<li>- - - - - - - - - - - - - - - - Suppose we want to implement a peer to peer file sharing system that allows users to search for files that match specific keywords. A simplistic version of such a system with code not relevant to the usage example elided would have the following parts: </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>a) A peer manager class that maintains a list of all connected peers and updates the list based on incoming peer requests and disconnecting peers. The following would be a simple interface for the Peer and PeerManager classes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Peer {
      <span class="comment">// This class stores all the relevant information for a peer.</span>

      <span class="comment">// ...</span>
  };

  <span class="keyword">class </span>PeerManager {
      <span class="comment">// This class acts as a manager of peers and adds and removes peers</span>
      <span class="comment">// based on peer requests and disconnections.</span>

      <span class="comment">// DATA</span>
</pre></div><br/>
<br/>
 The peer objects are stored by shared pointer to allow peers to be passed to search results and still allow their asynchronous destruction when peers disconnect. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbsl_1_1map.html">bsl::map&lt;int, bsl::shared_ptr&lt;Peer&gt;</a> &gt; d_peers;

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 b) A peer cache class that stores a subset of the peers that are used for sending search requests. The cache may select peers based on their connection bandwidth, relevancy of previous search results, etc. For brevity the population and flushing of this cache is not shown: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>PeerCache {
      <span class="comment">// This class caches a subset of all peers that match certain criteria</span>
      <span class="comment">// including connection bandwidth, relevancy of previous search</span>
      <span class="comment">// results, etc.</span>
</pre></div><br/>
<br/>
 Note that the cached peers are stored as a weak pointer so as not to interfere with the cleanup of Peer objects by the PeerManager if a Peer goes down. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1list.html">bsl::list&lt;bsl::weak_ptr&lt;Peer&gt;</a> &gt; d_cachedPeers;

    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1list.html">bsl::list&lt;bsl::weak_ptr&lt;Peer&gt;</a> &gt;::const_iterator PeerConstIter;

      <span class="comment">// ...</span>

      <span class="comment">// ACCESSORS</span>
      PeerConstIter begin()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_cachedPeers.<a class="code" href="group__bslstl__list.html#ga5c31176fa2f214a7932d504200b37f9f">begin</a>(); }
      PeerConstIter end()<span class="keyword"> const   </span>{ <span class="keywordflow">return</span> d_cachedPeers.<a class="code" href="group__bslstl__list.html#gaaff91bdeee8bf00648c6f0ea63e89c5d">end</a>(); }
  };
</pre></div><br/>
<br/>
 c) A search result class that stores a search result and encapsulates a peer with the file name stored by the peer that best matches the specified keywords: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>SearchResult {
      <span class="comment">// This class provides a search result and encapsulates a particular</span>
      <span class="comment">// peer and filename combination that matches a specified set of</span>
      <span class="comment">// keywords.</span>
</pre></div><br/>
<br/>
 The peer is stored as a weak pointer because when the user decides to select a particular file to download from this peer, the peer might have disconnected. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;Peer&gt;</a> d_peer;
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>         d_filename;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      SearchResult(<span class="keyword">const</span> <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;Peer&gt;</a>&amp; peer,
                   <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;         filename)
      : d_peer(peer)
      , d_filename(filename)
      {
      }

      <span class="comment">// ...</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr&lt;Peer&gt;</a>&amp; peer()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_peer; }
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; filename()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_filename; }
  };
</pre></div><br/>
<br/>
 d) A search function that takes a list of keywords and returns available results by searching the cached peers: <br/>
<br/>
<div class="fragment"><pre class="fragment">  ;

  <span class="keywordtype">void</span> search(<a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;SearchResult&gt;</a>       *<span class="comment">/* results */</span>,
              <span class="keyword">const</span> PeerCache&amp;                 peerCache,
              <span class="keyword">const</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a>&amp;  <span class="comment">/* keywords */</span>)
  {
      <span class="keywordflow">for</span> (PeerCache::PeerConstIter iter = peerCache.begin();
           iter != peerCache.end();
           ++iter) {
</pre></div><br/>
<br/>
 First we check if the peer is still connected by acquiring a shared pointer to the peer. If the acquire operation succeeds then we can send the peer a request to send back the file best matching the specified keywords: <br/>
<br/>
<div class="fragment"><pre class="fragment">          <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;Peer&gt;</a> peerSharedPtr = iter-&gt;lock();
          <span class="keywordflow">if</span> (peerSharedPtr) {

              <span class="comment">// Search the peer for file best matching the specified</span>
              <span class="comment">// keywords and if a file is found add the returned</span>
              <span class="comment">// SearchResult object to result.</span>

              <span class="comment">// ...</span>
          }
      }
  }
</pre></div><br/>
<br/>
 e) A download function that downloads a file selected by the user: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> download(<span class="keyword">const</span> SearchResult&amp; result)
  {
      <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;Peer&gt;</a> peerSharedPtr = result.peer().lock();
      <span class="keywordflow">if</span> (peerSharedPtr) {
          <span class="comment">// Download the result.filename() file from peer knowing that</span>
          <span class="comment">// the peer is still connected.</span>
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga61ba33bd2aeb0d92257c509d5871e5e2"></a><!-- doxytag: member="bsl::shared_ptr::element_type" ref="ga61ba33bd2aeb0d92257c509d5871e5e2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ELEMENT_TYPE <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::element_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga499733138e91edd57c5e1094a3a3ab57"></a><!-- doxytag: member="bsl::shared_ptr::ElementType" ref="ga499733138e91edd57c5e1094a3a3ab57" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ELEMENT_TYPE <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::ElementType<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga419d042c15b44670e9e8009d669ff153"></a><!-- doxytag: member="bsl::weak_ptr::element_type" ref="ga419d042c15b44670e9e8009d669ff153" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ELEMENT_TYPE <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::element_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga25bfad5e168d83249437014e7b6b8892"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga25bfad5e168d83249437014e7b6b8892" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty shared pointer, i.e., a shared pointer with no representation that does not refer to any object and has no deleter. </p>

</div>
</div>
<a class="anchor" id="ga5d2c2bd0c5dedf8e1198be362c0e0a82"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga5d2c2bd0c5dedf8e1198be362c0e0a82" args="(bsl::nullptr_t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IMPLICIT: Create an empty shared pointer, i.e., a shared pointer with no representation that does not refer to any object and has no deleter. </p>

</div>
</div>
<a class="anchor" id="ga841c0f3459e54c1bf2158eb56b285093"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga841c0f3459e54c1bf2158eb56b285093" args="(COMPATIBLE_TYPE *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that manages a modifiable object of (template parameter) type <code>COMPATIBLE_TYPE</code> and refers to the specified <code>(ELEMENT_TYPE *)ptr</code>. The currently installed default allocator is used to allocate and deallocate the internal representation of the shared pointer. When all references have been released, the object pointed to by the managed pointer will be destroyed by a call to <code>delete ptr</code>. If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code>, then a compiler diagnostic will be emitted indicating the error. If <code>ptr</code> is 0, then this shared pointer will still allocate an internal representation to share ownership of that empty state, which will be reclaimed when the last reference is destroyed. If an exception is thrown allocating storage for the representation, then <code>delete ptr</code> will be called. Note that if <code>ptr</code> is a null-pointer constant, the compiler will actually select the <code>shared_ptr(bsl::nullptr_t)</code> constructor, resulting in an empty shared pointer. </p>

</div>
</div>
<a class="anchor" id="gab7e1c63bc0f6cdf8a18745b0c52139ea"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="gab7e1c63bc0f6cdf8a18745b0c52139ea" args="(COMPATIBLE_TYPE *ptr, BloombergLP::bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that manages a modifiable object of (template parameter) type <code>COMPATIBLE_TYPE</code> and refers to the specified <code>ptr</code> cast to a pointer to the (template parameter) type <code>ELEMENT_TYPE</code>. If the specified <code>basicAllocator</code> is not 0 then <code>basicAllocator</code> is used to allocate and deallocate the internal representation of the shared pointer and to destroy the shared object when all references have been released; otherwise, the currently installed default allocator is used. If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code>, then a compiler diagnostic will be emitted indicating the error. If <code>ptr</code> is 0, then this shared pointer will still allocate an internal representation to share ownership of that empty state, which will be reclaimed when the last reference is destroyed. Note that if <code>ptr</code> is a null-pointer constant, the compiler will actually select the <code>shared_ptr(bsl::nullptr_t, BloombergLP::bslma::Allocator *)</code> constructor, resulting in an empty shared pointer. Note that if <code>basicAllocator</code> is a pointer to a class derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, the compiler will actually select the following (more general) constructor that has the same behavior: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keyword">template</span> &lt;<span class="keyword">class</span> COMPATIBLE_TYPE, <span class="keyword">class</span> DELETER&gt;
          <a class="code" href="group__bslstl__sharedptr.html#ga25bfad5e168d83249437014e7b6b8892">shared_ptr</a>(COMPATIBLE_TYPE *ptr, DELETER * deleter);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ga2a2e4bbff3006535d3173733b9f8ae2e"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga2a2e4bbff3006535d3173733b9f8ae2e" args="(ELEMENT_TYPE *ptr, BloombergLP::bslma::SharedPtrRep *rep)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::SharedPtrRep *&nbsp;</td>
          <td class="paramname"> <em>rep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that takes ownership of the specified <code>rep</code> and refers to the modifiable object at the specified <code>ptr</code> address. The number of references to <code>rep</code> is <em>NOT</em> incremented. Note that if <code>rep</code> is a pointer to a class derived from <code>BloombergLP::bslma::SharedPtrRep</code>, the compiler will actually select the following (more general) constructor that has the same behavior: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keyword">template</span> &lt;<span class="keyword">class</span> COMPATIBLE_TYPE, <span class="keyword">class</span> DELETER&gt;
          <a class="code" href="group__bslstl__sharedptr.html#ga25bfad5e168d83249437014e7b6b8892">shared_ptr</a>(COMPATIBLE_TYPE *ptr, DELETER * deleter);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ga63d96baa49ed23efc1ac35505e2470ec"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga63d96baa49ed23efc1ac35505e2470ec" args="(COMPATIBLE_TYPE *ptr, DELETER *deleter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE , class DELETER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DELETER *&nbsp;</td>
          <td class="paramname"> <em>deleter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that manages a modifiable object of (template parameter) type <code>COMPATIBLE_TYPE</code>, refers to the specified <code>ptr</code> cast to a pointer to the (template parameter) type <code>ELEMENT_TYPE</code>, and uses the specified <code>deleter</code> to delete the shared object when all references have been released. Use the currently installed default allocator to allocate and deallocate the internal representation of the shared pointer, unless <code>DELETER</code> is a class derived from either <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> or <code><a class="el" href="classbslma_1_1SharedPtrRep.html">bslma::SharedPtrRep</a></code>; if <code>DELETER</code> is a class derived from <code>bslma::allocator</code>, create a shared pointer as if calling the constructor: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keyword">template</span> &lt;<span class="keyword">class</span> COMPATIBLE_TYPE&gt;
          <a class="code" href="group__bslstl__sharedptr.html#ga25bfad5e168d83249437014e7b6b8892">shared_ptr</a>(COMPATIBLE_TYPE               *ptr,
                     BloombergLP::bslma::Allocator *basicAllocator);
</pre></div><p><br/>
<br/>
 If <code>DELETER</code> is a class derived from <code><a class="el" href="classbslma_1_1SharedPtrRep.html">bslma::SharedPtrRep</a></code>, create a shared pointer as if calling the constructor: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <a class="code" href="group__bslstl__sharedptr.html#ga25bfad5e168d83249437014e7b6b8892">shared_ptr</a>(ELEMENT_TYPE                     *ptr,
                     BloombergLP::bslma::SharedPtrRep *<a class="code" href="group__bslstl__sharedptr.html#gaa2c9e02ec8be7cb54746f8a41b0b5c12">rep</a>);
</pre></div><p><br/>
<br/>
 If <code>DELETER</code> does not derive from either <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> or <code>BloombergLP::bslma::SharedPtrRep</code>, then <code>deleter</code> shall be a pointer to a factory object that exposes a member function that can be invoked as <code>deleteObject(ptr)</code> that will be called to destroy the object at the <code>ptr</code> address (i.e., <code>deleter-&gt;deleteObject(ptr)</code> will be called to delete the shared object). (See the "Deleters" section in the component-level documentation.) If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code>, then a compiler diagnostic will be emitted indicating the error. If <code>ptr</code> is 0, then the null pointer will be reference counted, and the deleter will be called when the last reference is destroyed. If an exception is thrown when allocating storage for the internal representation, then <code>deleter(ptr)</code> will be called. Note that this method is a BDE extension and not part of the C++ standard interface. </p>

</div>
</div>
<a class="anchor" id="ga4cf0fdbff78c2ec3563ce9b7e6035b5a"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga4cf0fdbff78c2ec3563ce9b7e6035b5a" args="(COMPATIBLE_TYPE *ptr, DELETER deleter, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE , class DELETER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DELETER&nbsp;</td>
          <td class="paramname"> <em>deleter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that manages a modifiable object of (template parameter) type <code>COMPATIBLE_TYPE</code>, refers to the specified <code>(ELEMENT_TYPE *)ptr</code>, and uses the specified <code>deleter</code> to delete the shared object when all references have been released. Optionally specify a <code>basicAllocator</code> to allocate and deallocate the internal representation of the shared pointer (including a copy of <code>deleter</code>). If <code>basicAllocator</code> is 0, the currently installed default allocator is used. <code>DELETER</code> shall be either a function pointer or a function-like deleter that may be invoked to destroy the object referred to by a single argument of type <code>COMPATIBLE_TYPE *</code> (i.e., <code>deleter(ptr)</code> will be called to destroy the shared object). (See the "Deleters" section in the component- level documentation.) If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code>, then a compiler diagnostic will be emitted indicating the error. If <code>ptr</code> is 0, then the null pointer will be reference counted, and <code>deleter(ptr)</code> will be called when the last reference is destroyed. If an exception is thrown when allocating storage for the internal representation then <code>deleter(ptr)</code> will be called. The behavior is undefined unless the constructor making a copy of <code>deleter</code> does not throw an exception. </p>

</div>
</div>
<a class="anchor" id="gab2364e0cb3da8a2dfb19a423e3ce7d78"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="gab2364e0cb3da8a2dfb19a423e3ce7d78" args="(COMPATIBLE_TYPE *ptr, DELETER deleter, ALLOCATOR basicAllocator, typename ALLOCATOR::value_type *=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE , class DELETER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DELETER&nbsp;</td>
          <td class="paramname"> <em>deleter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ALLOCATOR::value_type *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that manages a modifiable object of (template parameter) type <code>COMPATIBLE_TYPE</code>, refers to the specified <code>ptr</code> cast to a pointer to the (template parameter) type <code>ELEMENT_TYPE</code>, and uses the specified <code>deleter</code> to delete the shared object when all references have been released. Use the specified <code>basicAllocator</code> to allocate and deallocate the internal representation of the shared pointer (including a copy of the <code>deleter</code>). The (template parameter) type <code>DELETER</code> shall be either a function pointer or a function-like deleter that may be invoked to destroy the object referred to by a single argument of type <code>COMPATIBLE_TYPE *</code> (i.e., <code>deleter(ptr)</code> will be called to destroy the shared object). (See the "Deleters" section in the component- level documentation.) The (template parameter) type <code>ALLOCATOR</code> shall satisfy the Allocator requirements of the C++ standard (C++11 17.6.3.5, [allocator.requirements]). If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code>, then a compiler diagnostic will be emitted indicating the error. If <code>ptr</code> is 0, then the null pointer will be reference counted, and <code>deleter(ptr)</code> will be called when the last reference is destroyed. If an exception is thrown when allocating storage for the internal representation, then <code>deleter(ptr)</code> will be called. The behavior is undefined unless the constructor making a copy of <code>deleter</code> does not throw an exception. Note that the final dummy parameter is a simple SFINAE check that the (template parameter) <code>ALLOCATOR</code> type probably satisfies the standard allocator requirements; in particular, it will not match pointer types, so any pointers to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> derived classes will dispatch to the constructor above this, and not be greedily matched to a generic type parameter. </p>

</div>
</div>
<a class="anchor" id="gaadfe208676a03d4f1a718ac73b9f02e5"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="gaadfe208676a03d4f1a718ac73b9f02e5" args="(nullptr_t nullPointerLiteral, BloombergLP::bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>&nbsp;</td>
          <td class="paramname"> <em>nullPointerLiteral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty shared pointer. The specified <code>nullPointerLiteral</code> and <code>basicAllocator</code> are not used. Note that use of this constructor is equivalent to calling the default constructor. </p>

</div>
</div>
<a class="anchor" id="gab0aa4a12d2b2002b2a6b5ec8d45ee774"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="gab0aa4a12d2b2002b2a6b5ec8d45ee774" args="(nullptr_t nullPointerLiteral, DELETER deleter, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class DELETER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>&nbsp;</td>
          <td class="paramname"> <em>nullPointerLiteral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DELETER&nbsp;</td>
          <td class="paramname"> <em>deleter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that reference-counts the null pointer, and calls the specified <code>deleter</code> with a null pointer (i.e., invokes <code>deleter((ELEMENT_TYPE *)0)</code>) when the last shared reference is destroyed. The specified <code>nullPointerLiteral</code> is not used. Optionally specify a <code>basicAllocator</code> to allocate and deallocate the internal representation of the shared pointer (including a copy of <code>deleter</code>). If <code>basicAllocator</code> is 0, the currently installed default allocator is used. If an exception is thrown when allocating storage for the internal representation, then <code>deleter((ELEMENT_TYPE *)0)</code> will be called. The behavior is undefined unless <code>deleter</code> can be called with a null pointer, and unless the constructor making a copy of <code>deleter</code> does not throw an exception. </p>

</div>
</div>
<a class="anchor" id="ga171ec51dc51b118a2c6bcfeac955fef8"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga171ec51dc51b118a2c6bcfeac955fef8" args="(nullptr_t nullPointerLiteral, DELETER deleter, ALLOCATOR basicAllocator, typename ALLOCATOR::value_type *=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class DELETER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">nullptr_t</a>&nbsp;</td>
          <td class="paramname"> <em>nullPointerLiteral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DELETER&nbsp;</td>
          <td class="paramname"> <em>deleter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ALLOCATOR::value_type *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that reference-counts the null pointer, calls the specified <code>deleter</code> with a null pointer (i.e., invokes <code>deleter((ELEMENT_TYPE *)0)</code>) when the last shared reference is destroyed, and uses the specified <code>basicAllocator</code> to allocate and deallocate the internal representation of the shared pointer (including a copy of the <code>deleter</code>). The (template parameter) type <code>DELETER</code> shall be either a function pointer or a function-like deleter (See the "Deleters" section in the component- level documentation). The (template parameter) type <code>ALLOCATOR</code> shall satisfy the Allocator requirements of the C++ standard (C++11 17.6.3.5, [allocator.requirements]). The specified <code>nullPointerLiteral</code> is not used. If an exception is thrown when allocating storage for the internal representation then <code>deleter((ELEMENT_TYPE *)0)</code> will be called. The behavior is undefined unless <code>deleter</code> can be called with a null pointer, and unless the constructor making a copy of <code>deleter</code> does not throw an exception. Note that the final dummy parameter is a simple SFINAE check that the <code>ALLOCATOR</code> type probably satisfies the standard allocator requirements; in particular, it will not match pointer types, so any pointers to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> derived classes will dispatch to the constructor above this, and not be greedily matched to a generic type parameter. </p>

</div>
</div>
<a class="anchor" id="gad32ea0635de6a74d765ff432e7b6567e"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="gad32ea0635de6a74d765ff432e7b6567e" args="(BloombergLP::bslma::ManagedPtr&lt; COMPATIBLE_TYPE &gt; managedPtr, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::ManagedPtr&lt; COMPATIBLE_TYPE &gt;&nbsp;</td>
          <td class="paramname"> <em>managedPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga31b7a3668bfef03fb5f66571eee139ed"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga31b7a3668bfef03fb5f66571eee139ed" args="(native_std::auto_ptr&lt; COMPATIBLE_TYPE &gt; &amp;autoPtr, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">native_std::auto_ptr&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>autoPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that takes over the management of the modifiable object previously managed by the specified <code>autoPtr</code> to the (template parameter) type <code>COMPATIBLE_TYPE</code>, and that refers to <code>(ELEMENT_TYPE *)autoPtr.get()</code>. <code>delete(autoPtr.release())</code> will be called to destroy the shared object when all references have been released. Optionally specify a <code>basicAllocator</code> used to allocate and deallocate the internal representation of the shared pointer. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code>, then a compiler diagnostic will be emitted indicating the error. </p>

</div>
</div>
<a class="anchor" id="gabc7e7eb011eeea91ca07faeba21d5637"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="gabc7e7eb011eeea91ca07faeba21d5637" args="(native_std::auto_ptr_ref&lt; ELEMENT_TYPE &gt; autoRef, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">native_std::auto_ptr_ref&lt; ELEMENT_TYPE &gt;&nbsp;</td>
          <td class="paramname"> <em>autoRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that takes over the management of the modifiable object of (template parameter) type <code>COMPATIBLE_TYPE</code> previously managed by the auto pointer object that the specified <code>autoRef</code> refers to; this shared pointer refers to the same object that it manages, and <code>delete(get())</code> will be called to destroy the shared object when all references have been released. Optionally specify a <code>basicAllocator</code> used to allocate and deallocate the internal representation of the shared pointer. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code>, then a compiler diagnostic will be emitted indicating the error. </p>

</div>
</div>
<a class="anchor" id="ga12461f1c2a32564f2e6aed992f147811"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga12461f1c2a32564f2e6aed992f147811" args="(const shared_ptr&lt; ANY_TYPE &gt; &amp;source, ELEMENT_TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ANY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ANY_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that manages the same modifiable object (if any) as the specified <code>source</code> shared pointer to the (template parameter) type <code>ANY_TYPE</code>, and that refers to the modifiable object at the specified <code>object</code> address. The resulting shared pointer is known as an "alias" of <code>source</code>. Note that typically the objects referred to by <code>source</code> and <code>object</code> have identical lifetimes (e.g., one might be a part of the other), so that the deleter for <code>source</code> will destroy them both, but they do not necessarily have the same type. Also note that if <code>source</code> is empty, then an empty shared pointer is created, even if <code>object</code> is not null (in which case this empty shared pointer will refer to the same object as <code>object</code>). Likewise note that if <code>object</code> is null and <code>source</code> is not empty, then a reference-counted null pointer alias will be created. </p>

</div>
</div>
<a class="anchor" id="ga52fd5aa2c3c730f07461871d120d2030"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga52fd5aa2c3c730f07461871d120d2030" args="(const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that manages the same modifiable object (if any) as the specified <code>other</code> shared pointer to the (template parameter) type <code>COMPATIBLE_TYPE</code>, uses the same deleter as <code>other</code> to destroy the shared object, and refers to <code>(ELEMENT_TYPE*)other.get()</code>. If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code>, then a compiler diagnostic will be emitted indicating the error. Note that if <code>other</code> is empty, then an empty shared pointer is created. </p>

</div>
</div>
<a class="anchor" id="gae1ba18a40fd81b46b1a579a0500164f2"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="gae1ba18a40fd81b46b1a579a0500164f2" args="(const shared_ptr &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that refers to and manages the same object (if any) as the specified <code>original</code> shared pointer, and used the same deleter as <code>original</code> to destroy the shared object. Note that if <code>original</code> is empty, then an empty shared pointer is created. </p>

</div>
</div>
<a class="anchor" id="ga00a7faf4ca60527b1506d9f90696d904"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga00a7faf4ca60527b1506d9f90696d904" args="(const weak_ptr&lt; COMPATIBLE_TYPE &gt; &amp;ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::shared_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a shared pointer that refers to and manages the same object as the specified <code>ptr</code> if <code>false == ptr.expired()</code>; otherwise, create a shared pointer in the empty state. Note that the referenced and managed objects may be different if <code>ptr</code> was created from a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> in an aliasing state. </p>

</div>
</div>
<a class="anchor" id="gaec035331c8d985691fd7c5929173259a"></a><!-- doxytag: member="bsl::shared_ptr::~shared_ptr" ref="gaec035331c8d985691fd7c5929173259a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::~shared_ptr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this shared pointer. If this shared pointer refers to a (possibly shared) object, then release the reference to that object, and destroy the shared object using its associated deleter if this shared pointer is the last reference to that object. </p>

</div>
</div>
<a class="anchor" id="ga1888243089d89d2d68487862ebe43eb8"></a><!-- doxytag: member="bsl::shared_ptr::operator=" ref="ga1888243089d89d2d68487862ebe43eb8" args="(const shared_ptr &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&amp; <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make this shared pointer manage the same modifiable object as the specified <code>rhs</code> shared pointer to the (template parameter) type <code>COMPATIBLE_TYPE</code>, use the same deleter as <code>rhs</code>, and refer to <code>(ELEMENT_TYPE *)rhs.get()</code>; return a reference providing modifiable access to this shared pointer. Note that if <code>rhs</code> is empty, then this shared pointer will also be empty after the assignment. Also note that if <code>*this</code> is the same object as <code>rhs</code>, then this method has no effect. </p>

</div>
</div>
<a class="anchor" id="ga40dddf94f309f6c0cfbe24d83a175f4c"></a><!-- doxytag: member="bsl::shared_ptr::operator=" ref="ga40dddf94f309f6c0cfbe24d83a175f4c" args="(const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&amp; <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make this shared pointer refer to and manage the same modifiable object as the specified <code>rhs</code> shared pointer to the (template parameter) type <code>COMPATIBLE_TYPE</code>, using the same deleter as <code>rhs</code> and referring to <code>(ELEMENT_TYPE *)rhs.get()</code>, and return a reference to this modifiable shared pointer. If this shared pointer is already managing a (possibly shared) object, then release the shared reference to that object, and destroy it using its associated deleter if this shared pointer held the last shared reference to that object. Note that if <code>rhs</code> is empty, then this shared pointer will also be empty after the assignment. </p>

</div>
</div>
<a class="anchor" id="gaca3f778cf04e601b8ecf06e73fd42b8c"></a><!-- doxytag: member="bsl::shared_ptr::operator=" ref="gaca3f778cf04e601b8ecf06e73fd42b8c" args="(native_std::auto_ptr&lt; COMPATIBLE_TYPE &gt; rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&amp; <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">native_std::auto_ptr&lt; COMPATIBLE_TYPE &gt;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transfer, to this shared pointer, ownership of the modifiable object managed by the specified <code>rhs</code> auto pointer to the (template parameter) type <code>COMPATIBLE_TYPE</code>, and make this shared pointer refer to <code>(ELEMENT_TYPE *)rhs.get()</code>. <code>delete(autoPtr.release())</code> will be called to destroy the shared object when all references have been released. If this shared pointer is already managing a (possibly shared) object, then release the reference to that shared object, and destroy it using its associated deleter if this shared pointer held the last shared reference to that object. Note that if <code>rhs</code> is empty, then this shared pointer will be empty after the assignment. </p>

</div>
</div>
<a class="anchor" id="ga37f640bcf2343ba65ee81e87a794e35f"></a><!-- doxytag: member="bsl::shared_ptr::reset" ref="ga37f640bcf2343ba65ee81e87a794e35f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset this shared pointer to the empty state. If this shared pointer is managing a (possibly shared) object, then release the reference to the shared object, calling the associated deleter to destroy the shared object if this shared pointer is the last shared reference. </p>

</div>
</div>
<a class="anchor" id="ga1a88d1f07d3287acb0a33871f005c6be"></a><!-- doxytag: member="bsl::shared_ptr::reset" ref="ga1a88d1f07d3287acb0a33871f005c6be" args="(COMPATIBLE_TYPE *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify this shared pointer to manage the modifiable object of the (template parameter) type <code>COMPATIBLE_TYPE</code> at the specified <code>ptr</code> address and to refer to <code>(ELEMENT_TYPE *)ptr</code>. If this shared pointer is already managing a (possibly shared) object, then, unless an exception is thrown allocating memory to manage <code>ptr</code>, release the reference to the shared object, calling the associated deleter to destroy the shared object if this shared pointer is the last reference. The currently installed default allocator is used to allocate the internal representation of this shared pointer, and the shared object will be destroyed by a call to <code>delete ptr</code> when all references have been released. If an exception is thrown allocating the internal representation, then <code>delete ptr</code> is called and this shared pointer retains ownership of its original object. If <code>COMPATIBLE_TYPE*</code> is not implicitly convertible to <code>ELEMENT_TYPE*</code>, then a compiler diagnostic will be emitted indicating the error. Note that if <code>ptr</code> is 0, then this shared pointer will still allocate an internal representation to share ownership of that empty state, which will be reclaimed when the last reference is destroyed. </p>

</div>
</div>
<a class="anchor" id="gaa004e232be1e2d260520369cbc95490d"></a><!-- doxytag: member="bsl::shared_ptr::reset" ref="gaa004e232be1e2d260520369cbc95490d" args="(COMPATIBLE_TYPE *ptr, DELETER deleter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE , class DELETER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DELETER&nbsp;</td>
          <td class="paramname"> <em>deleter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify this shared pointer to manage the modifiable object of the (template parameter) type <code>COMPATIBLE_TYPE</code> at the specified <code>ptr</code> address, refer to <code>(ELEMENT_TYPE *)ptr</code>, and use the specified <code>deleter</code> to delete the shared object when all references have been released. If this shared pointer is already managing a (possibly shared) object, then unless an exception is thrown allocating memory to manage <code>ptr</code>, release the reference to the shared object, calling the associated deleter to destroy the shared object if this shared pointer is the last reference. If <code>DELETER</code> is an object type, then <code>deleter</code> is assumed to be a function-like deleter that may be invoked to destroy the object referred to by a single argument of type <code>COMPATIBLE_TYPE *</code> (i.e., <code>deleter(ptr)</code> will be called to destroy the shared object). If <code>DELETER</code> is a pointer type that is not a function pointer, then <code>deleter</code> shall be a pointer to a factory object that exposes a member function that can be invoked as <code>deleteObject(ptr)</code> that will be called to destroy the object at the <code>ptr</code> address (i.e., <code>deleter-&gt;deleteObject(ptr)</code> will be called to delete the shared object). (See the "Deleters" section in the component-level documentation.) If <code>DELETER</code> is also a pointer to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> or to a class derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, then that allocator will also be used to allocate and destroy the internal representation of this shared pointer when all references have been released; otherwise, the currently installed default allocator is used to allocate and destroy the internal representation of this shared pointer when all references have been released. If an exception is thrown allocating the internal representation, then <code>deleter(ptr)</code> is called (or <code>deleter-&gt;deleteObject(ptr)</code> for factory-type deleters) and this shared pointer retains ownership of its original object. If <code>COMPATIBLE_TYPE*</code> is not implicitly convertible to <code>ELEMENT_TYPE*</code>, then a compiler diagnostic will be emitted indicating the error. Note that, for factory deleters, <code>deleter</code> must remain valid until all references to <code>ptr</code> have been released. If <code>ptr</code> is 0, then an internal representation will still be allocated, and this shared pointer will share ownership of a copy of <code>deleter</code>. Further note that this function is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          *<span class="keyword">this</span> = shared_ptr&lt;ELEMENT_TYPE&gt;(ptr, deleter);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="gad56d4c635e12daf994c79a264d45bd19"></a><!-- doxytag: member="bsl::shared_ptr::reset" ref="gad56d4c635e12daf994c79a264d45bd19" args="(COMPATIBLE_TYPE *ptr, DELETER deleter, ALLOCATOR basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE , class DELETER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">COMPATIBLE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DELETER&nbsp;</td>
          <td class="paramname"> <em>deleter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify this shared pointer to manage the modifiable object of the (template parameter) type <code>COMPATIBLE_TYPE</code> at the specified <code>ptr</code> address, refer to <code>(ELEMENT_TYPE *)ptr</code> and use the specified <code>deleter</code> to delete the shared object when all references have been released. Use the specified <code>basicAllocator</code> to allocate and deallocate the internal representation of the shared pointer. If this shared pointer is already managing a (possibly shared) object, then, unless an exception is thrown allocating memory to manage <code>ptr</code>, release the shared reference to that shared object, and destroy it using its associated deleter if this shared pointer held the last shared reference to that object. If <code>DELETER</code> is a reference type, then <code>deleter</code> is assumed to be a function-like deleter that may be invoked to destroy the object referred to by a single argument of type <code>COMPATIBLE_TYPE *</code> (i.e., <code>deleter(ptr)</code> will be called to destroy the shared object). If <code>DELETER</code> is a pointer type, then <code>deleter</code> is assumed to be a pointer to a factory object that exposes a member function that can be invoked as <code>deleteObject(ptr)</code> that will be called to destroy the object at the <code>ptr</code> address (i.e., <code>deleter-&gt;deleteObject(ptr)</code> will be called to delete the shared object). (See the "Deleters" section in the component-level documentation.) If an exception is thrown allocating the internal representation, then <code>deleter(ptr)</code> is called (or <code>deleter-&gt;deleteObject(ptr)</code> for factory-type deleters) and this shared pointer retains ownership of its original object. The behavior is undefined unless <code>deleter(ptr)</code> is a well-defined expression (or <code>deleter-&gt;deleteObject(ptr)</code> for factory-type deleters), and unless the copy constructor for <code>deleter</code> does not throw an exception. If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code>, then a compiler diagnostic will be emitted indicating the error. Note that, for factory deleters, the <code>deleter</code> must remain valid until all references to <code>ptr</code> have been released. Also note that if <code>ptr</code> is 0, then an internal representation will still be allocated, and this shared pointer will share ownership of a copy of <code>deleter</code>. Further note that this function is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          *<span class="keyword">this</span> = shared_ptr&lt;ELEMENT_TYPE&gt;(ptr, deleter, basicAllocator);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ga880253329316183fae55d7670bf02cd5"></a><!-- doxytag: member="bsl::shared_ptr::reset" ref="ga880253329316183fae55d7670bf02cd5" args="(const shared_ptr&lt; ANY_TYPE &gt; &amp;source, ELEMENT_TYPE *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ANY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ANY_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify this shared pointer to manage the same modifiable object (if any) as the specified <code>source</code> shared pointer to the (template parameter) type <code>ANY_TYPE</code>, and refer to the modifiable object at the specified <code>ptr</code> address (i.e., make this shared pointer an "alias" of <code>source</code>). If this shared pointer is already managing a (possibly shared) object, then release the reference to the shared object, calling the associated deleter to destroy the shared object if this shared pointer is the last reference. Note that typically the objects referred to by <code>source</code> and <code>ptr</code> have identical lifetimes (e.g., one might be a part of the other), so that the deleter for <code>source</code> will destroy them both, but do not necessarily have the same type. Also note that if <code>source</code> is empty, then this shared pointer will be reset to an empty state, even if <code>ptr</code> is not null (in which case this empty shared pointer will refer to the same object as <code>ptr</code>). Likewise note that if <code>ptr</code> is null and <code>source</code> is not empty, then this shared pointer will be reset to a (reference-counted) null pointer alias. Further note that the behavior of this method is the same as <code>loadAlias(source, ptr)</code>. </p>

</div>
</div>
<a class="anchor" id="ga57d3480dc19ef08fb4704e768a7f69ff"></a><!-- doxytag: member="bsl::shared_ptr::swap" ref="ga57d3480dc19ef08fb4704e768a7f69ff" args="(shared_ptr &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the states of this shared pointer and the specified <code>other</code> shared pointer such that each will refer to the object formerly referred to by the other and each will manage the object formerly managed by the other. </p>

</div>
</div>
<a class="anchor" id="gaafc3dbf236739df5e017f082b64db6ea"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="gaafc3dbf236739df5e017f082b64db6ea" args="(BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create "in-place" in a large enough contiguous memory region both an internal representation for this shared pointer and a default-constructed object of <code>ELEMENT_TYPE</code>, and make this shared pointer refer to the newly-created <code>ELEMENT_TYPE</code> object. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. If an exception is thrown during allocation or construction of the <code>ELEMENT_TYPE</code> object, this shared pointer will be unchanged. Otherwise, if this shared pointer is already managing a (possibly shared) object, then release the shared reference to that shared object, and destroy it using its associated deleter if this shared pointer held the last shared reference to that object. Note that the allocator argument is <em>not</em> passed to the constructor for <code>ELEMENT_TYPE</code>; to construct an in-place <code>ELEMENT_TYPE</code> with an allocator, use one of the other variants of <code>createInplace</code> below. </p>

</div>
</div>
<a class="anchor" id="ga03b9c9c63a4f1edccfb12a1a1075f72e"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga03b9c9c63a4f1edccfb12a1a1075f72e" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga39246fe1a4523a81686c59232495a3f5"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga39246fe1a4523a81686c59232495a3f5" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab3fc58be99de52434c7974e3d6fa795e"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="gab3fc58be99de52434c7974e3d6fa795e" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga652422a023fdaa27313f11d5d0ce384c"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga652422a023fdaa27313f11d5d0ce384c" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga55af65860795eb30bad02fb83508d5e2"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga55af65860795eb30bad02fb83508d5e2" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9260b9f283836bd34814564f475759e3"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga9260b9f283836bd34814564f475759e3" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga02d1f3eb9a6c35471edb1ac1979b2da0"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga02d1f3eb9a6c35471edb1ac1979b2da0" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae3066aae4de276e4327ba8d94a09f130"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="gae3066aae4de276e4327ba8d94a09f130" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga640c4b75bf8a9ac0fb2af1604605a833"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga640c4b75bf8a9ac0fb2af1604605a833" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6565009e5d3855e7dc86f62de741b928"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga6565009e5d3855e7dc86f62de741b928" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa80b3327e687a5abf2c479986507d1aa"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="gaa80b3327e687a5abf2c479986507d1aa" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga64401cd05e867290147dabf55dfbf3b1"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga64401cd05e867290147dabf55dfbf3b1" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga51e62667dc0fa364f94d7d70d34f424b"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="ga51e62667dc0fa364f94d7d70d34f424b" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf998e53f52f90d11c49a564bdbf5ae61"></a><!-- doxytag: member="bsl::shared_ptr::createInplace" ref="gaf998e53f52f90d11c49a564bdbf5ae61" args="(BloombergLP::bslma::Allocator *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::createInplace </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A14 &amp;&nbsp;</td>
          <td class="paramname"> <em>a14</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create "in-place" in a large enough contiguous memory region, using the specified <code>basicAllocator</code> to supply memory, both an internal representation for this shared pointer and an object of <code>ELEMENT_TYPE</code> using the <code>ELEMENT_TYPE</code> constructor that takes the specified arguments <code>a1</code> up to <code>aN</code> where <code>N</code> (at most 14) is the number of arguments passed to this method, and make this shared pointer refer to the newly-created <code>ELEMENT_TYPE</code> object. If an exception is thrown during the construction of the <code>ELEMENT_TYPE</code> object, this shared pointer will be unchanged. Otherwise, if this shared pointer is already managing a (possibly shared) object, then release the shared reference to that shared object, and destroy it using its associated deleter if this shared pointer held the last shared reference to that object. Note that the allocator argument is <em>not</em> implicitly passed to the constructor for <code>ELEMENT_TYPE</code>; to construct an object of <code>ELEMENT_TYPE</code> with an allocator, pass the allocator as one of the arguments (typically the last argument). </p>

</div>
</div>
<a class="anchor" id="ga710218b15aeac3ab96e1269038a5aa21"></a><!-- doxytag: member="bsl::shared_ptr::loadAlias" ref="ga710218b15aeac3ab96e1269038a5aa21" args="(const shared_ptr&lt; ANY_TYPE &gt; &amp;source, ELEMENT_TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ANY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::loadAlias </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ANY_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>[!DEPRECATED!] Use <code>reset</code> instead.</p>
<p>Modify this shared pointer to manage the same modifiable object (if any) as the specified <code>source</code> shared pointer to the (template parameter) type <code>ANY_TYPE</code>, and refer to the modifiable object at the specified <code>object</code> address (i.e., make this shared pointer an "alias" of <code>source</code>). If this shared pointer is already managing a (possibly shared) object, then release the shared reference to that shared object, and destroy it using its associated deleter if this shared pointer held the last shared reference to that object. Note that typically the objects referred to by <code>source</code> and <code>object</code> have identical lifetimes (e.g., one might be a part of the other), so that the deleter for <code>source</code> will destroy them both, but they do not necessarily have the same type. Also note that if <code>source</code> is empty, then this shared pointer will be reset to an empty state, even if <code>object</code> is not null (in which case this empty shared pointer will refer to the same object as <code>object</code>). Likewise note that if <code>object</code> is null and <code>source</code> is not empty, then this shared pointer will be reset to a (reference-counted) null pointer alias. Also note that this function is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          *<span class="keyword">this</span> = shared_ptr&lt;ELEMENT_TYPE&gt;(source, object);
</pre></div><p><br/>
<br/>
 Further note that the behavior of this method is the same as <code>reset(source, object)</code>. </p>

</div>
</div>
<a class="anchor" id="ga54f46f5bb220e063bd7c097b8302a838"></a><!-- doxytag: member="bsl::shared_ptr::release" ref="ga54f46f5bb220e063bd7c097b8302a838" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;ELEMENT_TYPE *, BloombergLP::bslma::SharedPtrRep *&gt; <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the pair consisting of the addresses of the modifiable <code>ELEMENT_TYPE</code> object referred to, and the representation shared by, this shared pointer, and reset this shared pointer to the empty state, referring to no object, with no effect on the representation. The reference counter is not modified nor is the shared object deleted; if the reference count of the representation is greater than one, then it is not safe to release the representation (thereby destroying the shared object), but it is always safe to create another shared pointer with the representation using the constructor with the signature 'shared_ptr(ELEMENT_TYPE *ptr, BloombergLP::bslma::SharedPtrRep *rep)'. Note that this function returns a pair of null pointers if this shared pointer is empty. </p>

</div>
</div>
<a class="anchor" id="ga31292c33e0410049a25c59c0c4b74049"></a><!-- doxytag: member="bsl::shared_ptr::operator BoolType" ref="ga31292c33e0410049a25c59c0c4b74049" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::operator BoolType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a value of an "unspecified bool" type that evaluates to <code>false</code> if this shared pointer does not refer to an object, and <code>true</code> otherwise. Note that this conversion operator allows a shared pointer to be used within a conditional context (e.g., within an <code>if</code> or <code>while</code> statement), but does <em>not</em> allow shared pointers to unrelated types to be compared (e.g., via <code>&lt;</code> or <code>&gt;</code>). </p>

</div>
</div>
<a class="anchor" id="ga7561cfb064b73fc506712a0bf4b4f6d1"></a><!-- doxytag: member="bsl::shared_ptr::operator*" ref="ga7561cfb064b73fc506712a0bf4b4f6d1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">add_lvalue_reference&lt;ELEMENT_TYPE&gt;::type <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the object referred to by this shared pointer. The behavior is undefined unless this shared pointer refers to an object, and <code>ELEMENT_TYPE</code> is not (potentially <code>const</code> or <code>volatile</code> qualified) <code>void</code>. </p>

</div>
</div>
<a class="anchor" id="gaf0b9e0d68f8775c9f64c4df92d0f0d9b"></a><!-- doxytag: member="bsl::shared_ptr::operator&#45;&gt;" ref="gaf0b9e0d68f8775c9f64c4df92d0f0d9b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ELEMENT_TYPE* <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address providing modifiable access to the object referred to by this shared pointer, or 0 if this shared pointer does not refer to an object. Note that applying this operator conventionally (e.g., to invoke a method) to an shared pointer that does not refer to an object will result in undefined behavior. </p>

</div>
</div>
<a class="anchor" id="ga48f002a13755bd11276a297079d8254e"></a><!-- doxytag: member="bsl::shared_ptr::get" ref="ga48f002a13755bd11276a297079d8254e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ELEMENT_TYPE* <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address providing modifiable access to the object referred to by this shared pointer, or 0 if this shared pointer does not refer to an object. </p>

</div>
</div>
<a class="anchor" id="gac888622df34e855572e95f569686308c"></a><!-- doxytag: member="bsl::shared_ptr::owner_before" ref="gac888622df34e855572e95f569686308c" args="(const shared_ptr&lt; ANY_TYPE &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ANY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ANY_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga02e27d5b5b2bd9654791f92988bad1ea"></a><!-- doxytag: member="bsl::shared_ptr::owner_before" ref="ga02e27d5b5b2bd9654791f92988bad1ea" args="(const weak_ptr&lt; ANY_TYPE &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ANY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ANY_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the address of the <code>BloombergLP::bslma::SharedPtrRep</code> object used by this shared pointer is ordered before the address of the <code>BloombergLP::bslma::SharedPtrRep</code> object used by the specified <code>other</code> shared pointer under the total ordering defined by <code>std::less&lt;BloombergLP::bslma::SharedPtrRep *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga71ce3c0494bfb53b944cfad471f458cc"></a><!-- doxytag: member="bsl::shared_ptr::unique" ref="ga71ce3c0494bfb53b944cfad471f458cc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this shared pointer is not empty and does not share ownership of the object it managed with any other shared pointer, and <code>false</code> otherwise. Note that a shared pointer with a custom deleter can refer to a null pointer without being empty, and so may be <code>unique</code>. </p>

</div>
</div>
<a class="anchor" id="ga577317da7b2aa99e58309cc7db1941de"></a><!-- doxytag: member="bsl::shared_ptr::use_count" ref="ga577317da7b2aa99e58309cc7db1941de" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "snapshot" of the number of shared pointers (including this one) that share ownership of the object managed by this shared pointer. Note that 0 is returned if this shared pointer is empty. </p>

</div>
</div>
<a class="anchor" id="gac951c0325b8179829b715d8e9e48c595"></a><!-- doxytag: member="bsl::shared_ptr::operator[]" ref="gac951c0325b8179829b715d8e9e48c595" args="(ptrdiff_t index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">add_lvalue_reference&lt;ELEMENT_TYPE&gt;::type <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">ptrdiff_t&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the object at the specified <code>index</code> offset in the object referred to by this shared pointer. The behavior is undefined unless this shared pointer is not empty, <code>ELEMENT_TYPE</code> is not <code>void</code> (a compiler error will be generated if this operator is instantiated within the <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;void&gt;</code> class), and this shared pointer refers to an array of <code>ELEMENT_TYPE</code> objects. Note that this method is logically equivalent to <code>*(get() + index)</code>. </p>

</div>
</div>
<a class="anchor" id="gacf1fa65139ac6e757e041353be18897e"></a><!-- doxytag: member="bsl::shared_ptr::managedPtr" ref="gacf1fa65139ac6e757e041353be18897e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BloombergLP::bslma::ManagedPtr&lt;ELEMENT_TYPE&gt; <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::managedPtr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a managed pointer that refers to the same object as this shared pointer and that has a deleter that decrements the reference count for the shared object. </p>

</div>
</div>
<a class="anchor" id="gaa2c9e02ec8be7cb54746f8a41b0b5c12"></a><!-- doxytag: member="bsl::shared_ptr::rep" ref="gaa2c9e02ec8be7cb54746f8a41b0b5c12" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BloombergLP::bslma::SharedPtrRep* <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; ELEMENT_TYPE &gt;::rep </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address providing modifiable access to the <code>BloombergLP::bslma::SharedPtrRep</code> object used by this shared pointer, or 0 if this shared pointer is empty. </p>

</div>
</div>
<a class="anchor" id="ga1c1c2704b92642dd439cdad97a848d57"></a><!-- doxytag: member="bsl::operator==" ref="ga1c1c2704b92642dd439cdad97a848d57" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer refers to the same object (if any) as that referred to by the specified <code>rhs</code> shared pointer (if any), and <code>false</code> otherwise; a compiler diagnostic will be emitted indicating the error unless a (raw) pointer to <code>LHS_TYPE</code> can be compared to a (raw) pointer to <code>RHS_TYPE</code>. Note that two shared pointers that compare equal do not necessarily manage the same object due to aliasing. </p>

</div>
</div>
<a class="anchor" id="ga3a77beaa9951f55de2c793f025d576c4"></a><!-- doxytag: member="bsl::operator!=" ref="ga3a77beaa9951f55de2c793f025d576c4" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer does not refer to the same object (if any) as that referred to by the specified <code>rhs</code> shared pointer (if any), and <code>false</code> otherwise; a compiler diagnostic will be emitted indicating the error unless a (raw) pointer to <code>LHS_TYPE</code> can be compared to a (raw) pointer to <code>RHS_TYPE</code>. Note that two shared pointers that do not compare equal may manage the same object due to aliasing. </p>

</div>
</div>
<a class="anchor" id="ga66ad66d30f8224d17b9a095394af53a3"></a><!-- doxytag: member="bsl::operator&lt;" ref="ga66ad66d30f8224d17b9a095394af53a3" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the address of the object that the specified <code>lhs</code> shared pointer refers to is ordered before the address of the object that the specified <code>rhs</code> shared pointer refers to under the total ordering supplied by <code>std::less&lt;T *&gt;</code>, where <code>T *</code> is the composite pointer type of <code>LHS_TYPE *</code> and <code>RHS_TYPE *</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga18eb1b3e0476913d7ba6ba1af5f1bde0"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga18eb1b3e0476913d7ba6ba1af5f1bde0" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the address of the object that the specified <code>lhs</code> shared pointer refers to is ordered after the address of the object that the specified <code>rhs</code> shared pointer refers to under the total ordering supplied by <code>std::less&lt;T *&gt;</code>, where <code>T *</code> is the composite pointer type of <code>LHS_TYPE *</code> and <code>RHS_TYPE *</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gaf7d2404f8ddbbf36bbf27fe3fb8685a7"></a><!-- doxytag: member="bsl::operator&lt;=" ref="gaf7d2404f8ddbbf36bbf27fe3fb8685a7" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer refers to the same object as the specified <code>rhs</code> shared pointer, or if the address of the object referred to by <code>lhs</code> (if any) is ordered before the address of the object referred to by <code>rhs</code> (if any) under the total ordering supplied by <code>std::less&lt;T *&gt;</code>, where <code>T *</code> is the composite pointer type of <code>LHS_TYPE *</code> and <code>RHS_TYPE *</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gae407f6ed76abc4c51b61472c966c28fc"></a><!-- doxytag: member="bsl::operator&gt;=" ref="gae407f6ed76abc4c51b61472c966c28fc" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE , class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer refers to the same object as the specified <code>rhs</code> shared pointer, or if the address of the object referred to by <code>lhs</code> (if any) is ordered after the address of the object referred to by <code>rhs</code> (if any) under the total ordering supplied by <code>std::less&lt;T *&gt;</code>, where <code>T *</code> is the composite pointer type of <code>LHS_TYPE *</code> and <code>RHS_TYPE *</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga02586f71629626fe00132cefebf9d0f6"></a><!-- doxytag: member="bsl::operator==" ref="ga02586f71629626fe00132cefebf9d0f6" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer does not refer to an object, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga6ebbfc95461e707c1219dcfd8d5eb65c"></a><!-- doxytag: member="bsl::operator==" ref="ga6ebbfc95461e707c1219dcfd8d5eb65c" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>rhs</code> shared pointer does not refer to an object, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gaf6de5b2e8b27c39f51c873993d71f9ad"></a><!-- doxytag: member="bsl::operator!=" ref="gaf6de5b2e8b27c39f51c873993d71f9ad" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer refers to an object, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gae1eab178a468625aa5836216595b076c"></a><!-- doxytag: member="bsl::operator!=" ref="gae1eab178a468625aa5836216595b076c" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>rhs</code> shared pointer refers to an object, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gaf4c4bb456f48f1842cb63357527e9644"></a><!-- doxytag: member="bsl::operator&lt;" ref="gaf4c4bb456f48f1842cb63357527e9644" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the address of the object referred to by the specified <code>lhs</code> shared pointer is ordered before the null-pointer value under the total ordering supplied by <code>std::less&lt;LHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga88c588f14653fec148e0f293794505a4"></a><!-- doxytag: member="bsl::operator&lt;" ref="ga88c588f14653fec148e0f293794505a4" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the address of the object referred to by the specified <code>rhs</code> shared pointer is ordered after the null-pointer value under the total ordering supplied by <code>std::less&lt;RHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga2fcb633c59eda20af4715e688bf0dbee"></a><!-- doxytag: member="bsl::operator&lt;=" ref="ga2fcb633c59eda20af4715e688bf0dbee" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer does not refer to an object, or if the address of the object referred to by <code>lhs</code> is ordered before the null-pointer value under the total ordering supplied by <code>std::less&lt;LHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga013b0c9607f5b710d6e54a95137560ed"></a><!-- doxytag: member="bsl::operator&lt;=" ref="ga013b0c9607f5b710d6e54a95137560ed" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>rhs</code> shared pointer does not refer to an object, or if the address of the object referred to by <code>rhs</code> is ordered after the null-pointer value under the total ordering supplied by <code>std::less&lt;RHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga8b013ca7ef46710259e40234cfcc735a"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga8b013ca7ef46710259e40234cfcc735a" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the address of the object referred to by the specified <code>lhs</code> shared pointer is ordered after the null-pointer value under the total ordering supplied by <code>std::less&lt;LHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gaeb88e103f0bc7111f829207a03644bcb"></a><!-- doxytag: member="bsl::operator&gt;" ref="gaeb88e103f0bc7111f829207a03644bcb" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the address of the object referred to by the specified <code>rhs</code> shared pointer is ordered before the null-pointer value under the total ordering supplied by <code>std::less&lt;RHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gac55976d83a9c4bb361e6d9acdb221405"></a><!-- doxytag: member="bsl::operator&gt;=" ref="gac55976d83a9c4bb361e6d9acdb221405" args="(const shared_ptr&lt; LHS_TYPE &gt; &amp;lhs, nullptr_t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; LHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> shared pointer does not refer to an object, or if the address of the object referred to by <code>lhs</code> is ordered after the null-pointer value under the total ordering supplied by <code>std::less&lt;LHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gad53c3f8eaccc4210b0d6aa129870e5f8"></a><!-- doxytag: member="bsl::operator&gt;=" ref="gad53c3f8eaccc4210b0d6aa129870e5f8" args="(nullptr_t, const shared_ptr&lt; RHS_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RHS_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">nullptr_t&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; RHS_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>rhs</code> shared pointer does not refer to an object, or if the address of the object referred to by <code>rhs</code> is ordered before the null-pointer value under the total ordering supplied by <code>std::less&lt;RHS_TYPE *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gaef9191e2d4f9e99421de794cfa210c63"></a><!-- doxytag: member="bsl::operator&lt;&lt;" ref="gaef9191e2d4f9e99421de794cfa210c63" args="(native_std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;stream, const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">native_std::basic_ostream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp; bsl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">native_std::basic_ostream&lt; CHAR_TYPE, CHAR_TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print to the specified <code>stream</code> the address of the shared object referred to by the specified <code>rhs</code> shared pointer and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="gafe12b0f6723f7f260ec2c37f78ecc034"></a><!-- doxytag: member="bsl::hashAppend" ref="gafe12b0f6723f7f260ec2c37f78ecc034" args="(HASHALG &amp;hashAlg, const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;input)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HASHALG , class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::hashAppend </td>
          <td>(</td>
          <td class="paramtype">HASHALG &amp;&nbsp;</td>
          <td class="paramname"> <em>hashAlg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pass the address of the object referred to by the specified <code>input</code> shared pointer to the specified <code>hashAlg</code> hashing algorithm of (template parameter) type <code>HASHALG</code>. </p>

</div>
</div>
<a class="anchor" id="ga050d5c3fbf77c1ddc00d3e18c07cebc8"></a><!-- doxytag: member="bsl::swap" ref="ga050d5c3fbf77c1ddc00d3e18c07cebc8" args="(shared_ptr&lt; ELEMENT_TYPE &gt; &amp;a, shared_ptr&lt; ELEMENT_TYPE &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">shared_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the states of the specified <code>a</code> and <code>b</code> shared pointers such that each will refer to the object formerly referred to by the other, and each will manage the object formerly managed by the other. </p>

</div>
</div>
<a class="anchor" id="ga52fdaf60492df2fe31fe398d13184f82"></a><!-- doxytag: member="bsl::get_deleter" ref="ga52fdaf60492df2fe31fe398d13184f82" args="(const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DELETER , class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DELETER* bsl::get_deleter </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of deleter used by the specified <code>p</code> shared pointer if the (template parameter) type <code>DELETER</code> is the type of the deleter installed in <code>p</code>, and a null pointer value otherwise. </p>

</div>
</div>
<a class="anchor" id="ga903f6e4e7b2befd616936456786efa34"></a><!-- doxytag: member="bsl::const_pointer_cast" ref="ga903f6e4e7b2befd616936456786efa34" args="(const shared_ptr&lt; FROM_TYPE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TO_TYPE , class FROM_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;TO_TYPE&gt; bsl::const_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; FROM_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;TO_TYPE&gt;</code> object sharing ownership of the same object as the specified <code>source</code> shared pointer to the (template parameter) <code>FROM_TYPE</code>, and referring to <code>const_cast&lt;TO_TYPE *&gt;(source.get())</code>. Note that if <code>source</code> cannot be <code>const</code>-cast to <code>TO_TYPE *</code>, then a compiler diagnostic will be emitted indicating the error. </p>

</div>
</div>
<a class="anchor" id="gaa4dded295fd97099aa32efb1d6e2a054"></a><!-- doxytag: member="bsl::dynamic_pointer_cast" ref="gaa4dded295fd97099aa32efb1d6e2a054" args="(const shared_ptr&lt; FROM_TYPE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TO_TYPE , class FROM_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;TO_TYPE&gt; bsl::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; FROM_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;TO_TYPE&gt;</code> object sharing ownership of the same object as the specified <code>source</code> shared pointer to the (template parameter) <code>FROM_TYPE</code>, and referring to <code>dynamic_cast&lt;TO_TYPE*&gt;(source.get())</code>. If <code>source</code> cannot be dynamically cast to <code>TO_TYPE *</code>, then an empty <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;TO_TYPE&gt;</code> object is returned. </p>

</div>
</div>
<a class="anchor" id="ga22893acbe6dca3b4184b1b5f92891c09"></a><!-- doxytag: member="bsl::static_pointer_cast" ref="ga22893acbe6dca3b4184b1b5f92891c09" args="(const shared_ptr&lt; FROM_TYPE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TO_TYPE , class FROM_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;TO_TYPE&gt; bsl::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; FROM_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt;TO_TYPE&gt;</code> object sharing ownership of the same object as the specified <code>source</code> shared pointer to the (template parameter) <code>FROM_TYPE</code>, and referring to <code>static_cast&lt;TO_TYPE *&gt;(source.get())</code>. Note that if <code>source</code> cannot be statically cast to <code>TO_TYPE *</code>, then a compiler diagnostic will be emitted indicating the error. </p>

</div>
</div>
<a class="anchor" id="ga842124bb63d969e2caf74d9acab97fc5"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga842124bb63d969e2caf74d9acab97fc5" args="(ALLOC basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf2cdad3ee884ea8b77ab9c1426f56fbd"></a><!-- doxytag: member="bsl::allocate_shared" ref="gaf2cdad3ee884ea8b77ab9c1426f56fbd" args="(ALLOC basicAllocator, const A1 &amp;a1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaafac01371f305d61c5c78789e1e7946d"></a><!-- doxytag: member="bsl::allocate_shared" ref="gaafac01371f305d61c5c78789e1e7946d" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf290055ca0d2dd2a1cb63b87b45c1150"></a><!-- doxytag: member="bsl::allocate_shared" ref="gaf290055ca0d2dd2a1cb63b87b45c1150" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga01d65a5dc53c7e2eb8e3611e26eb97bc"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga01d65a5dc53c7e2eb8e3611e26eb97bc" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2bd5e0e636661483155a7c1c8b3e38ae"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga2bd5e0e636661483155a7c1c8b3e38ae" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga53ddafd51e59bf1e423a926039c54b52"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga53ddafd51e59bf1e423a926039c54b52" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5c2325b69b0e632dce693eef38ec06b8"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga5c2325b69b0e632dce693eef38ec06b8" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2a65a4a51652aba5a8bba984d8619ae9"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga2a65a4a51652aba5a8bba984d8619ae9" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gace3929d2362de8b5b52094a9f6d6eed2"></a><!-- doxytag: member="bsl::allocate_shared" ref="gace3929d2362de8b5b52094a9f6d6eed2" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaac721eeddc042f80302f2b9f4785b53a"></a><!-- doxytag: member="bsl::allocate_shared" ref="gaac721eeddc042f80302f2b9f4785b53a" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9606c6f277d02bbfcc74c06f7cba41d1"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga9606c6f277d02bbfcc74c06f7cba41d1" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab59fe722c57eec981284f58d5d20cd29"></a><!-- doxytag: member="bsl::allocate_shared" ref="gab59fe722c57eec981284f58d5d20cd29" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa1da907c0dbd8b80f8a3c768e85e7d5d"></a><!-- doxytag: member="bsl::allocate_shared" ref="gaa1da907c0dbd8b80f8a3c768e85e7d5d" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab57cfb5ad98e1adf035316e35672077a"></a><!-- doxytag: member="bsl::allocate_shared" ref="gab57cfb5ad98e1adf035316e35672077a" args="(ALLOC basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A14 &amp;&nbsp;</td>
          <td class="paramname"> <em>a14</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> object referring to and managing a new <code>ELEMENT_TYPE</code> object. The specified <code>basicAllocator</code> will be used to supply a single contiguous region of memory holding the returned shared pointer's internal representation and the new <code>ELEMENT_TYPE</code> object, which is initialized by calling <code><a class="el" href="structbsl_1_1allocator__traits.html">allocator_traits</a>&lt;ALLOC&gt;construct</code> passing <code>basicAllocator</code>, an <code>ELEMENT_TYPE *</code> pointer to space for the new shared object, and the specified arguments <code>a1</code> up to <code>aN</code> where <code>N</code> (at most 14) is the number of arguments passed to this method. Note that the allocator argument is <em>not</em> implicitly passed to the constructor for <code>ELEMENT_TYPE</code>; typically, to construct an object of <code>ELEMENT_TYPE</code> with an allocator, pass the allocator as one of the arguments (frequently the last argument), but note that some allocators will perform this customization in their <code>construct</code> implementation. </p>

</div>
</div>
<a class="anchor" id="gaa5cf03e39a028e9896de9a8c08df1445"></a><!-- doxytag: member="bsl::allocate_shared" ref="gaa5cf03e39a028e9896de9a8c08df1445" args="(ALLOC *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7f487dab167660990e57e8f6dd4ce8e6"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga7f487dab167660990e57e8f6dd4ce8e6" args="(ALLOC *basicAllocator, const A1 &amp;a1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga952b9d0f95d7a0f91f485d1146beb191"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga952b9d0f95d7a0f91f485d1146beb191" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2168d1fe1563beb5029888bf7f64f2ec"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga2168d1fe1563beb5029888bf7f64f2ec" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0e189e4547a008770d94657320a19757"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga0e189e4547a008770d94657320a19757" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaffcd074404490763a00537270d15a919"></a><!-- doxytag: member="bsl::allocate_shared" ref="gaffcd074404490763a00537270d15a919" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4074c4cc4167a9ed7c6c2dc5f88e7d29"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga4074c4cc4167a9ed7c6c2dc5f88e7d29" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5d1ed3d2127b1f90ee4f088e236b98aa"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga5d1ed3d2127b1f90ee4f088e236b98aa" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga777ca6cbbff46d15b499a10a901d7d11"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga777ca6cbbff46d15b499a10a901d7d11" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9075db3c0bc09d1fb7fbcca6f8109392"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga9075db3c0bc09d1fb7fbcca6f8109392" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga43c7f93dad387f6c22e352c18e4ebf21"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga43c7f93dad387f6c22e352c18e4ebf21" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6a16b6a4c819dfbd9fb72dd3e1e7580a"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga6a16b6a4c819dfbd9fb72dd3e1e7580a" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4b455a513f5fa28d4199646af210ef14"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga4b455a513f5fa28d4199646af210ef14" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3cdaf66722173632cf99dcba808fe7a4"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga3cdaf66722173632cf99dcba808fe7a4" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga852abbdd03b262816ec5f706e78daa66"></a><!-- doxytag: member="bsl::allocate_shared" ref="ga852abbdd03b262816ec5f706e78daa66" args="(ALLOC *basicAllocator, const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class ALLOC , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared </td>
          <td>(</td>
          <td class="paramtype">ALLOC *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A14 &amp;&nbsp;</td>
          <td class="paramname"> <em>a14</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> object referring to and managing a new <code>ELEMENT_TYPE</code> object. The specified <code>basicAllocator</code> will be used to supply a single contiguous region of memory holding the returned shared pointer's internal representation and the new <code>ELEMENT_TYPE</code> object, which is initialized using the <code>ELEMENT_TYPE</code> constructor that takes the specified arguments <code>a1</code> up to <code>aN</code> where <code>N</code> (at most 14) is the number of arguments passed to this method. If <code>ELEMENT_TYPE</code> uses <code>blsma</code> allocators, then the default allocator is passed as an extra argument in the final position. </p>

</div>
</div>
<a class="anchor" id="ga0afacd0aecba8ee3341580f6e696bee5"></a><!-- doxytag: member="bsl::make_shared" ref="ga0afacd0aecba8ee3341580f6e696bee5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga948481509b5773206e5ea25c52b61283"></a><!-- doxytag: member="bsl::make_shared" ref="ga948481509b5773206e5ea25c52b61283" args="(const A1 &amp;a1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaed83c08eabc1f22ff41be3d7949b016a"></a><!-- doxytag: member="bsl::make_shared" ref="gaed83c08eabc1f22ff41be3d7949b016a" args="(const A1 &amp;a1, const A2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5b3b07f21e4b038a58efa13ea2583d18"></a><!-- doxytag: member="bsl::make_shared" ref="ga5b3b07f21e4b038a58efa13ea2583d18" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5ccdad6d77d6f91c4d26d36a2a1c9933"></a><!-- doxytag: member="bsl::make_shared" ref="ga5ccdad6d77d6f91c4d26d36a2a1c9933" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad70fcbb076fc7c7c9e75f297f2149c58"></a><!-- doxytag: member="bsl::make_shared" ref="gad70fcbb076fc7c7c9e75f297f2149c58" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga41fdc22eb8ffb9ac386b266e2b100f47"></a><!-- doxytag: member="bsl::make_shared" ref="ga41fdc22eb8ffb9ac386b266e2b100f47" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0a18cef762683586ddcf554750974540"></a><!-- doxytag: member="bsl::make_shared" ref="ga0a18cef762683586ddcf554750974540" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5386aae75c602403e22c26f58d9aa3f2"></a><!-- doxytag: member="bsl::make_shared" ref="ga5386aae75c602403e22c26f58d9aa3f2" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0c90eba2b70dc7509f69950d04bfee31"></a><!-- doxytag: member="bsl::make_shared" ref="ga0c90eba2b70dc7509f69950d04bfee31" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga98eed9180e3758990ff0bda0b0f41683"></a><!-- doxytag: member="bsl::make_shared" ref="ga98eed9180e3758990ff0bda0b0f41683" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga47afd18d2ac49909d2f78359550bcd65"></a><!-- doxytag: member="bsl::make_shared" ref="ga47afd18d2ac49909d2f78359550bcd65" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae7f8b8e43681cb4423673c7dce5488b1"></a><!-- doxytag: member="bsl::make_shared" ref="gae7f8b8e43681cb4423673c7dce5488b1" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga72666c8cd2da3ed6ce6bd6c27f0cd189"></a><!-- doxytag: member="bsl::make_shared" ref="ga72666c8cd2da3ed6ce6bd6c27f0cd189" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3876caafb24bb32d3300754b741cd7a6"></a><!-- doxytag: member="bsl::make_shared" ref="ga3876caafb24bb32d3300754b741cd7a6" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A14 &amp;&nbsp;</td>
          <td class="paramname"> <em>a14</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a></code> object referring to and managing a new <code>ELEMENT_TYPE</code> object. The default allocator will be used to supply a single contiguous region of memory holding the returned shared pointer's internal representation and the new <code>ELEMENT_TYPE</code> object, which is initialized using the <code>ELEMENT_TYPE</code> constructor that takes the specified arguments <code>a1</code> up to <code>aN</code> where <code>N</code> (at most 14) is the number of arguments passed to this method. If <code>ELEMENT_TYPE</code> uses <code>blsma</code> allocators, then the default allocator is passed as an extra argument in the final position. </p>

</div>
</div>
<a class="anchor" id="gad857b724f69dc6b25d1797702102549f"></a><!-- doxytag: member="bsl::weak_ptr::weak_ptr" ref="gad857b724f69dc6b25d1797702102549f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::weak_ptr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a weak pointer in the empty state and referring to no object, i.e., a weak pointer having no representation. </p>

</div>
</div>
<a class="anchor" id="gae2adefc8f8926f276c3ecf36daa874f0"></a><!-- doxytag: member="bsl::weak_ptr::weak_ptr" ref="gae2adefc8f8926f276c3ecf36daa874f0" args="(const weak_ptr &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::weak_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a weak pointer that refers to the same object (if any) as the specified <code>original</code> weak pointer, and increment the number of weak references to the object managed by <code>original</code> (if any). Note that if <code>original</code> is in the empty state, this weak pointer will be initialized to the empty state. </p>

</div>
</div>
<a class="anchor" id="ga35a234785bed69f0cb3b9c69b466e707"></a><!-- doxytag: member="bsl::weak_ptr::weak_ptr" ref="ga35a234785bed69f0cb3b9c69b466e707" args="(const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::weak_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IMPLICIT: </p>

</div>
</div>
<a class="anchor" id="gab7aa5423fab31f0cd5d86514d85b13c9"></a><!-- doxytag: member="bsl::weak_ptr::weak_ptr" ref="gab7aa5423fab31f0cd5d86514d85b13c9" args="(const weak_ptr&lt; COMPATIBLE_TYPE &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::weak_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IMPLICIT: Create a weak pointer that refers to the same object (if any) as the specified <code>other</code> (shared or weak) pointer of the (template parameter) <code>COMPATIBLE_TYPE</code>, and increment the number of weak references to the object managed by <code>other</code> (if any). If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>ELEMENT_TYPE *</code>, then a compiler diagnostic will be emitted. Note that if <code>other</code> is in the empty state, this weak pointer will be initialized to the empty state. </p>

</div>
</div>
<a class="anchor" id="ga2aef66bfe030b2aaecc59dcf3717f762"></a><!-- doxytag: member="bsl::weak_ptr::~weak_ptr" ref="ga2aef66bfe030b2aaecc59dcf3717f762" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::~weak_ptr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this weak pointer object. If this weak pointer manages a (possibly shared) object, release the weak reference to that object. </p>

</div>
</div>
<a class="anchor" id="ga688404a7ec31a3c2da8a8ad097bcb3d4"></a><!-- doxytag: member="bsl::weak_ptr::operator=" ref="ga688404a7ec31a3c2da8a8ad097bcb3d4" args="(const weak_ptr &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">weak_ptr&amp; <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make this weak pointer refer to the same object (if any) as the specified <code>rhs</code> weak pointer. Decrement the number of weak references to the object this weak pointer manages (if any), and increment the number of weak references to the object managed by <code>rhs</code> (if any). Return a reference providing modifiable access to this weak pointer. Note that if <code>rhs</code> is in the empty state, this weak pointer will be set to the empty state. </p>

</div>
</div>
<a class="anchor" id="gaec46064b65bcee0e7dbc947c38ceb75f"></a><!-- doxytag: member="bsl::weak_ptr::operator=" ref="gaec46064b65bcee0e7dbc947c38ceb75f" args="(const shared_ptr&lt; COMPATIBLE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">weak_ptr&amp; <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1e3495245099b3146e82bd006e586c70"></a><!-- doxytag: member="bsl::weak_ptr::operator=" ref="ga1e3495245099b3146e82bd006e586c70" args="(const weak_ptr&lt; COMPATIBLE_TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class COMPATIBLE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">weak_ptr&amp; <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; COMPATIBLE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make this weak pointer refer to the same object (if any) as the specified <code>rhs</code> (shared or weak) pointer to the (template parameter) <code>COMPATIBLE_TYPE</code>. Decrement the number of weak references to the object to which this weak pointer currently manages (if any), and increment the number of weak references to the object managed by <code>rhs</code> (if any). Return a reference providing modifiable access to this weak pointer. If <code>COMPATIBLE_TYPE *</code> is not implicitly convertible to <code>TYPE *</code>, then a compiler diagnostic will be emitted. Note that if <code>rhs</code> is in the empty state, this weak pointer will be set to the empty state. </p>

</div>
</div>
<a class="anchor" id="ga9d4ffeef0e33e4bbb6664605f39467af"></a><!-- doxytag: member="bsl::weak_ptr::reset" ref="ga9d4ffeef0e33e4bbb6664605f39467af" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset this weak pointer to the empty state. If this weak pointer manages a (possibly shared) object, then decrement the number of weak references to that object. </p>

</div>
</div>
<a class="anchor" id="ga74555d04ec23d02199d7c79951a5fc65"></a><!-- doxytag: member="bsl::weak_ptr::swap" ref="ga74555d04ec23d02199d7c79951a5fc65" args="(weak_ptr &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the states of this weak pointer and the specified <code>other</code> weak pointer such that each will refer to the object (if any) and representation (if any) formerly referred to and managed by the other. </p>

</div>
</div>
<a class="anchor" id="gaee9df79d0a4d9bc4aa352692d98490e3"></a><!-- doxytag: member="bsl::weak_ptr::expired" ref="gaee9df79d0a4d9bc4aa352692d98490e3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::expired </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this weak pointer is in the empty state or the object that it originally referenced has been destroyed, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga839f5aa12ddb60bd5fcc260849b406ac"></a><!-- doxytag: member="bsl::weak_ptr::lock" ref="ga839f5aa12ddb60bd5fcc260849b406ac" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;ELEMENT_TYPE&gt; <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::lock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a shared pointer to the object referred to by this weak pointer if <code>false == expired()</code>, and a shared pointer in the empty state otherwise. </p>

</div>
</div>
<a class="anchor" id="ga9ec9e1557a53ecc665ac8ff8d38a45b7"></a><!-- doxytag: member="bsl::weak_ptr::owner_before" ref="ga9ec9e1557a53ecc665ac8ff8d38a45b7" args="(const shared_ptr&lt; ANY_TYPE &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ANY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">shared_ptr</a>&lt; ANY_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8b95837ff793e790ed40b52877ce67fc"></a><!-- doxytag: member="bsl::weak_ptr::owner_before" ref="ga8b95837ff793e790ed40b52877ce67fc" args="(const weak_ptr&lt; ANY_TYPE &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ANY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1weak__ptr.html">weak_ptr</a>&lt; ANY_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the address of the <code>BloombergLP::bslma::SharedPtrRep</code> object used by this weak pointer is ordered before the address of the <code>BloombergLP::bslma::SharedPtrRep</code> object used by the specified <code>other</code> shared pointer under the total ordering defined by <code>std::less&lt;BloombergLP::bslma::SharedPtrRep *&gt;</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga363c49165444b7f320feab8c3e24c940"></a><!-- doxytag: member="bsl::weak_ptr::rep" ref="ga363c49165444b7f320feab8c3e24c940" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BloombergLP::bslma::SharedPtrRep* <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::rep </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address providing modifiable access to the <code>BloombergLP::bslma::SharedPtrRep</code> object held by this weak pointer, or 0 if this weak pointer is in the empty state. </p>

</div>
</div>
<a class="anchor" id="gad550e30b99fea724afcc02ad3433e141"></a><!-- doxytag: member="bsl::weak_ptr::use_count" ref="gad550e30b99fea724afcc02ad3433e141" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classbsl_1_1weak__ptr.html">bsl::weak_ptr</a>&lt; ELEMENT_TYPE &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "snapshot" of the current number of shared pointers that share ownership of the object referred to by this weak pointer, or 0 if this weak pointer is in the empty state. </p>

</div>
</div>
<a class="anchor" id="gad7f43c35a15e87ad6e3f859c47f135f4"></a><!-- doxytag: member="bsl::swap" ref="gad7f43c35a15e87ad6e3f859c47f135f4" args="(weak_ptr&lt; ELEMENT_TYPE &gt; &amp;a, weak_ptr&lt; ELEMENT_TYPE &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">weak_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">weak_ptr&lt; ELEMENT_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the states of the specified <code>a</code> and <code>b</code> weak pointers such that each will refer to the object (if any) and representation formerly referred to by the other. </p>

</div>
</div>
<a class="anchor" id="ga6c2a72c4594b6193d545ae660731e0d4"></a><!-- doxytag: member="bslstl::SharedPtrUtil::throwBadWeakPtr" ref="ga6c2a72c4594b6193d545ae660731e0d4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslstl::SharedPtrUtil::throwBadWeakPtr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Throw a <code><a class="el" href="namespacebsl.html#a906ad194bab928ecbd8b3c6bbc08405c">bsl::bad_weak_ptr</a></code> exception. </p>

</div>
</div>
<a class="anchor" id="gaa7c3c7f1ae148cf6352b0fa6708a4aff"></a><!-- doxytag: member="bslstl::SharedPtrUtil::constCast" ref="gaa7c3c7f1ae148cf6352b0fa6708a4aff" args="(bsl::shared_ptr&lt; TARGET &gt; *target, const bsl::shared_ptr&lt; SOURCE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET , class SOURCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslstl::SharedPtrUtil::constCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt; *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>target</code> an aliased shared pointer sharing ownership of the object managed by the specified <code>source</code> shared pointer and referring to <code>const_cast&lt;TARGET *&gt;(source.get())</code>. If <code>*target</code> is already managing a (possibly shared) object, then release the shared reference to that object, and destroy it using its associated deleter if that shared pointer held the last shared reference to that object. Note that a compiler diagnostic will be emitted indicating an error unless <code>const_cast&lt;TARGET *&gt;(source.get())</code> is a valid expression. </p>

</div>
</div>
<a class="anchor" id="gafcce9eb23f8b3a7c494351c7cf9246f7"></a><!-- doxytag: member="bslstl::SharedPtrUtil::constCast" ref="gafcce9eb23f8b3a7c494351c7cf9246f7" args="(const bsl::shared_ptr&lt; SOURCE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET , class SOURCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;TARGET&gt; bslstl::SharedPtrUtil::constCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;TARGET&gt;</code> object sharing ownership of the same object as the specified <code>source</code> shared pointer to the (template parameter) <code>SOURCE</code> type, and referring to <code>const_cast&lt;TARGET *&gt;(source.get())</code>. Note that a compiler diagnostic will be emitted indicating an error unless <code>const_cast&lt;TARGET *&gt;(source.get())</code> is a valid expression. </p>

</div>
</div>
<a class="anchor" id="ga69f6feecf72eebbdb5154d80b313cea6"></a><!-- doxytag: member="bslstl::SharedPtrUtil::dynamicCast" ref="ga69f6feecf72eebbdb5154d80b313cea6" args="(bsl::shared_ptr&lt; TARGET &gt; *target, const bsl::shared_ptr&lt; SOURCE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET , class SOURCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslstl::SharedPtrUtil::dynamicCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt; *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>target</code> an aliased shared pointer sharing ownership of the object managed by the specified <code>source</code> shared pointer and referring to <code>dynamic_cast&lt;TARGET *&gt;(source.get())</code>. If <code>*target</code> is already managing a (possibly shared) object, then release the shared reference to that object, and destroy it using its associated deleter if that shared pointer held the last shared reference to that object. If <code>0 == dynamic_cast&lt;TARGET*&gt;(source.get())</code> then <code>*target</code> shall be reset to an empty state that does not refer to an object. Note that a compiler diagnostic will be emitted indicating an error unless <code>dynamic_cast&lt;TARGET *&gt;(source.get())</code> is a valid expression. </p>

</div>
</div>
<a class="anchor" id="ga7a422696c4adaaaaf54b519943563277"></a><!-- doxytag: member="bslstl::SharedPtrUtil::dynamicCast" ref="ga7a422696c4adaaaaf54b519943563277" args="(const bsl::shared_ptr&lt; SOURCE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET , class SOURCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;TARGET&gt; bslstl::SharedPtrUtil::dynamicCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;TARGET&gt;</code> object sharing ownership of the same object as the specified <code>source</code> shared pointer to the (template parameter) <code>SOURCE</code> type, and referring to <code>dynamic_cast&lt;TARGET *&gt;(source.get())</code>. If that would return a shared pointer referring to nothing (<code>0 == get()</code>) then instead return an (empty) default constructed shared pointer. Note that a compiler diagnostic will be emitted indicating an error unless <code>dynamic_cast&lt;TARGET *&gt;(source.get())</code> is a valid expression.. </p>

</div>
</div>
<a class="anchor" id="gaf025d8bc5b749fb04ae5d983e9fb605f"></a><!-- doxytag: member="bslstl::SharedPtrUtil::staticCast" ref="gaf025d8bc5b749fb04ae5d983e9fb605f" args="(bsl::shared_ptr&lt; TARGET &gt; *target, const bsl::shared_ptr&lt; SOURCE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET , class SOURCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslstl::SharedPtrUtil::staticCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; TARGET &gt; *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>target</code> an aliased shared pointer sharing ownership of the object managed by the specified <code>source</code> shared pointer and referring to <code>static_cast&lt;TARGET *&gt;(source.get())</code>. If <code>*target</code> is already managing a (possibly shared) object, then release the shared reference to that object, and destroy it using its associated deleter if that shared pointer held the last shared reference to that object. Note that a compiler diagnostic will be emitted indicating an error unless <code>static_cast&lt;TARGET *&gt;(source.get())</code> is a valid expression. </p>

</div>
</div>
<a class="anchor" id="gaa1e0c5e3e5a6041d830b7909dfe00bbd"></a><!-- doxytag: member="bslstl::SharedPtrUtil::staticCast" ref="gaa1e0c5e3e5a6041d830b7909dfe00bbd" args="(const bsl::shared_ptr&lt; SOURCE &gt; &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET , class SOURCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;TARGET&gt; bslstl::SharedPtrUtil::staticCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; SOURCE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;TARGET&gt;</code> object sharing ownership of the same object as the specified <code>source</code> shared pointer to the (template parameter) <code>SOURCE</code> type, and referring to <code>static_cast&lt;TARGET *&gt;(source.get())</code>. Note that a compiler diagnostic will be emitted indicating an error unless <code>static_cast&lt;TARGET *&gt;(source.get())</code> is a valid expression. </p>

</div>
</div>
<a class="anchor" id="ga8e1b55cac7dd44a68a1c4994289e373d"></a><!-- doxytag: member="bslstl::SharedPtr_RepProctor::SharedPtr_RepProctor" ref="ga8e1b55cac7dd44a68a1c4994289e373d" args="(bslma::SharedPtrRep *rep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslstl::SharedPtr_RepProctor::SharedPtr_RepProctor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1SharedPtrRep.html">bslma::SharedPtrRep</a> *&nbsp;</td>
          <td class="paramname"> <em>rep</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbslstl_1_1SharedPtr__RepProctor.html">SharedPtr_RepProctor</a></code> that conditionally manages the specified <code>rep</code> (if non-zero). </p>

</div>
</div>
<a class="anchor" id="gabd1cddccae2f2fb5da0afd605c732110"></a><!-- doxytag: member="bslstl::SharedPtr_RepProctor::~SharedPtr_RepProctor" ref="gabd1cddccae2f2fb5da0afd605c732110" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslstl::SharedPtr_RepProctor::~SharedPtr_RepProctor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this <code><a class="el" href="classbslstl_1_1SharedPtr__RepProctor.html">SharedPtr_RepProctor</a></code>, and dispose of (deallocate) the <code><a class="el" href="classbslma_1_1SharedPtrRep.html">bslma::SharedPtrRep</a></code> it manages (if any). If no such object is currently being managed, this method has no effect. Note that the destructor of the <code><a class="el" href="classbslma_1_1SharedPtrRep.html">bslma::SharedPtrRep</a></code> will not be called as the reference count will not be decremented. </p>

</div>
</div>
<a class="anchor" id="ga64a079eb850eb72d5468958edbe37388"></a><!-- doxytag: member="bslstl::SharedPtr_RepProctor::release" ref="ga64a079eb850eb72d5468958edbe37388" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslstl::SharedPtr_RepProctor::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release from management the object currently managed by this proctor. If no object is currently being managed, this method has no effect. </p>

</div>
</div>
<hr/><h2>Friends</h2>
<a class="anchor" id="ga9a4da829475f0cf1809fc6ef555ffe06"></a><!-- doxytag: member="bsl::shared_ptr::shared_ptr" ref="ga9a4da829475f0cf1809fc6ef555ffe06" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class shared_ptr<code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga73fb185cab8b7bb5f231491bb497071c"></a><!-- doxytag: member="bsl::weak_ptr::weak_ptr" ref="ga73fb185cab8b7bb5f231491bb497071c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ELEMENT_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class weak_ptr<code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:23 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
