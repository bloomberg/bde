<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bdlma_countingallocator.h                                          -*-C++-*-
#ifndef INCLUDED_BDLMA_COUNTINGALLOCATOR
#define INCLUDED_BDLMA_COUNTINGALLOCATOR

//@PURPOSE: Provide a memory allocator that counts allocated bytes.
//
//@CLASSES:
//  bdlma::CountingAllocator: concrete allocator that counts allocated bytes
//
//@SEE_ALSO: bslma_allocator, bslma_testallocator
//
//@DESCRIPTION: This component provides a special-purpose counting allocator,
// &#39;bdlma::CountingAllocator&#39;, that implements the &#39;bslma::Allocator&#39; protocol
// and provides instrumentation to track: (1) the number of bytes currently in
// use (&#39;numBytesInUse&#39;), and (2) the cumulative number of bytes that have ever
// been allocated (&#39;numBytesTotal&#39;).  The accumulated statistics are based
// solely on the number of bytes requested in calls to the &#39;allocate&#39; method.
// A &#39;print&#39; method is provided to output the current state of the allocator&#39;s
// byte counts to a specified &#39;bsl::ostream&#39;:
//..
//   ,------------------------.
//  ( bdlma::CountingAllocator )
//   `------------------------&#39;
//                |           ctor/dtor
//                |           numBytesInUse
//                |           numBytesTotal
//                |           name
//                |           print
//                V
//       ,----------------.
//      ( bslma::Allocator )
//       `----------------&#39;
//                            allocate
//                            deallocate
//..
// Like many other allocators, &#39;bdlma::CountingAllocator&#39; relies on the
// currently installed default allocator (see &#39;bslma_default&#39;) at construction.
// Clients may, however, override this allocator by supplying (at construction)
// any other allocator implementing the &#39;bslma::Allocator&#39; protocol provided
// that it is fully thread-safe.
//
// Note that a &#39;bdlma::CountingAllocator&#39; necessarily incurs some overhead in
// order to provide its byte-counting functionality.  However, this overhead is
// *substantially* less than that incurred by the &#39;bslma::TestAllocator&#39; (see
// &#39;bslma_testallocator&#39;), which keeps track of the same two statistics that
// are maintained by a &#39;bdlma::CountingAllocator&#39;.  Consequently, use of a
// &#39;bdlma::CountingAllocator&#39; may be appropriate in cases where the overhead of
// &#39;bslma::TestAllocator&#39; is too onerous.  In particular, a counting allocator
// may be suitable even for production use in certain situations, whereas the
// test allocator is not intended for production use under any circumstance.
//
///Byte Counts
///-----------
// The two byte counts maintained by &#39;bdlma::CountingAllocator&#39; are initialized
// to 0 at construction and increased with each call to &#39;allocate&#39; by &#39;size&#39;,
// i.e., by the actual number of bytes requested.  Each call to &#39;deallocate&#39;
// decreases the &#39;numBytesInUse&#39; count by the same amount by which the byte
// count was increased in the original &#39;allocate&#39; call.  The number of bytes
// currently in use is returned by &#39;numBytesInUse&#39; and the total number of
// bytes ever allocated is returned by &#39;numBytesTotal&#39;.
//
///Thread Safety
///-------------
// The &#39;bdlma::CountingAllocator&#39; class is fully thread-safe (see
// &#39;bsldoc_glossary&#39;) provided that the underlying allocator (established at
// construction) is fully thread-safe.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Tracking a Container&#39;s Dynamic Memory Use
///----------------------------------------------------
// In this example, we demonstrate how a counting allocator may be used to
// track the amount of dynamic memory used by a container.  The container used
// for illustration is &#39;DoubleStack&#39;, a stack of out-of-place &#39;double&#39; values.
//
// First, we show the (elided) interface of the &#39;DoubleStack&#39; class:
//..
//  // doublestack.h
//  // ...
//
//  class DoubleStack {
//      // This class implements a stack of out-of-place &#39;double&#39; values.
//
//      // DATA
//      double           **d_stack_p;      // dynamically allocated array of
//                                         // &#39;d_capacity&#39; elements
//
//      int                d_capacity;     // physical capacity of the stack
//                                         // (in elements)
//
//      int                d_length;       // logical index of next available
//                                         // stack element
//
//      bslma::Allocator  *d_allocator_p;  // memory allocator (held, not
//                                         // owned)
//
//    // ...
//
//    private:
//      // PRIVATE MANIPULATORS
//      void increaseCapacity();
//          // Increase the capacity of this stack by at least one element.
//
//    public:
//      // CREATORS
//      explicit
//      DoubleStack(bslma::Allocator *basicAllocator = 0);
//          // Create a stack for &#39;double&#39; values having an initial capacity to
//          // hold one element.  Optionally specify a &#39;basicAllocator&#39; used to
//          // supply memory.  If &#39;basicAllocator&#39; is 0, the currently
//          // installed default allocator is used.
//
//      ~DoubleStack();
//          // Delete this object.
//
//      // MANIPULATORS
//      void push(double value);
//          // Add the specified &#39;value&#39; to the top of this stack.
//
//      void pop();
//          // Remove the element at the top of this stack.  The behavior is
//          // undefined unless this stack is non-empty.
//
//      // ACCESSORS
//      // ...
//  };
//..
// Next, we show the (elided) implementation of &#39;DoubleStack&#39;.
//
// The default constructor creates a stack having the capacity for one element
// (the implementation of the destructor is not shown):
//..
//  // doublestack.cpp
//  // ...
//
//  // TYPES
//  enum { INITIAL_CAPACITY = 1, GROWTH_FACTOR = 2 };
//
//  // CREATORS
//  DoubleStack::DoubleStack(bslma::Allocator *basicAllocator)
//  : d_stack_p(0)
//  , d_capacity(INITIAL_CAPACITY)
//  , d_length(0)
//  , d_allocator_p(bslma::Default::allocator(basicAllocator))
//  {
//      d_stack_p = (double **)
//                     d_allocator_p-&gt;allocate(d_capacity * sizeof *d_stack_p);
//  }
//..
// The &#39;push&#39; method first ensures that the array has sufficient capacity to
// accommodate an additional value, then allocates a block in which to store
// that value:
//..
//  // MANIPULATORS
//  void DoubleStack::push(double value)
//  {
//      if (d_length &gt;= d_capacity) {
//          increaseCapacity();
//      }
//      double *stackValue = (double *)d_allocator_p-&gt;allocate(sizeof(double));
//      *stackValue = value;
//      d_stack_p[d_length] = stackValue;
//      ++d_length;
//  }
//..
// The &#39;pop&#39; method asserts that the stack is not empty before deallocating the
// block used to store the element at the top of the stack:
//..
//  void DoubleStack::pop()
//  {
//      BSLS_ASSERT(0 &lt; d_length);
//
//      d_allocator_p-&gt;deallocate(d_stack_p[d_length - 1]);
//      --d_length;
//  }
//..
// The &#39;push&#39; method (above) made use of the private &#39;increaseCapacity&#39; method,
// which, in turn, makes use of the &#39;reallocate&#39; helper function (&#39;static&#39; to
// the &#39;.cpp&#39; file).  Note that &#39;increaseCapacity&#39; (below) increases the
// capacity of the &#39;double *&#39; array by a factor of 2 each time that it is
// called:
//..
//  // HELPER FUNCTIONS
//  static
//  void reallocate(double           ***array,
//                  int                 newCapacity,
//                  int                 length,
//                  bslma::Allocator   *allocator)
//      // Reallocate memory in the specified &#39;array&#39; to accommodate the
//      // specified &#39;newCapacity&#39; elements using the specified &#39;allocator&#39;.
//      // The specified &#39;length&#39; number of leading elements are preserved.
//      // The behavior is undefined unless &#39;newCapacity &gt; length&#39;.
//  {
//      BSLS_ASSERT(newCapacity &gt; length);
//
//      double **tmp = *array;
//      *array = (double **)allocator-&gt;allocate(newCapacity * sizeof **array);
//      bsl::memcpy(*array, tmp, length * sizeof **array);  // commit
//      allocator-&gt;deallocate(tmp);
//  }
//
//  // PRIVATE MANIPULATORS
//  void DoubleStack::increaseCapacity()
//  {
//      const int newCapacity = d_capacity * GROWTH_FACTOR;
//                                                      // reallocate can throw
//      reallocate(&amp;d_stack_p, newCapacity, d_length, d_allocator_p);
//      d_capacity = newCapacity;                       // commit
//  }
//..
// Now, we are ready to employ a &#39;CountingAllocator&#39; to illustrate the dynamic
// memory use of &#39;DoubleStack&#39;.  We first define two constants that facilitate
// portability of this example across 32- and 64-bit platforms:
//..
//  const int DBLSZ = sizeof(double);
//  const int PTRSZ = sizeof(double *);
//..
// First, we define a &#39;CountingAllocator&#39;, &#39;ca&#39;.  At construction, a counting
// allocator can be configured with an optional name and an optional allocator.
// In this case, we give &#39;ca&#39; a name to distinguish it from other counting
// allocators, but settle for using the default allocator:
//..
//  bdlma::CountingAllocator ca(&quot;&#39;DoubleStack&#39; Allocator&quot;);
//..
// Next, we create a &#39;DoubleStack&#39;, supplying it with &#39;ca&#39;, and assert the
// expected memory use incurred by the default constructor:
//..
//  DoubleStack stack(&amp;ca);
//                         assert(1 * PTRSZ             == ca.numBytesInUse());
//                         assert(1 * PTRSZ             == ca.numBytesTotal());
//..
// Next, we push an element onto the stack.  The first push incurs an
// additional allocation to store (out-of-place) the value being inserted:
//..
//  stack.push(1.54);      assert(1 * PTRSZ + 1 * DBLSZ == ca.numBytesInUse());
//                         assert(1 * PTRSZ + 1 * DBLSZ == ca.numBytesTotal());
//..
// Next, we push a second element onto the stack.  In this case, two
// allocations result, one due to the resizing of the internal array and one
// required to store the new value out-of-place:
//..
//  stack.push(0.99);      assert(2 * PTRSZ + 2 * DBLSZ == ca.numBytesInUse());
//                         assert(3 * PTRSZ + 2 * DBLSZ == ca.numBytesTotal());
//..
// Next, we pop the top-most element from the stack.  The number of bytes in
// use decreases by the amount used to store the popped element out-of-place:
//..
//  stack.pop();           assert(2 * PTRSZ + 1 * DBLSZ == ca.numBytesInUse());
//                         assert(3 * PTRSZ + 2 * DBLSZ == ca.numBytesTotal());
//..
// Finally, we print the state of &#39;ca&#39; to standard output:
//..
//  ca.print(bsl::cout);
//..
// which displays the following on a 32-bit platform:
//..
//  ----------------------------------------
//          Counting Allocator State
//  ----------------------------------------
//  Allocator name: &#39;DoubleStack&#39; Allocator
//  Bytes in use:   16
//  Bytes in total: 28
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMIC
#include &lt;bsls_atomic.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

namespace BloombergLP {
namespace bdlma {

                           // =======================
                           // class CountingAllocator
                           // =======================

class CountingAllocator : public bslma::Allocator {
    // This class defines a concrete &quot;counting&quot; allocator mechanism that
    // implements the &#39;bslma::Allocator&#39; protocol, and provides instrumentation
    // to track: (1) the number of bytes currently in use, and (2) the
    // cumulative number of bytes that have ever been allocated.  The
    // accumulated statistics are based solely on the number of bytes requested
    // (see &#39;allocate&#39;).
    //
    // Note that, like many other allocators, this allocator relies on the
    // currently installed default allocator (see &#39;bslma_default&#39;).  Clients
    // may, however, override this allocator by supplying (at construction) any
    // other allocator implementing the &#39;bslma::Allocator&#39; protocol provided
    // that it is fully thread-safe.

    // DATA
    const char        *d_name_p;         // optionally specified name of this
                                         // allocator object (or 0)

    bsls::AtomicInt64  d_numBytesInUse;  // number of bytes currently allocated
                                         // from this object

    bsls::AtomicInt64  d_numBytesTotal;  // cumulative number of bytes ever
                                         // allocated from this object

    bslma::Allocator  *d_allocator_p;    // memory allocator (held, not owned)

  private:
    // NOT IMPLEMENTED
    CountingAllocator(const CountingAllocator&amp;);
    CountingAllocator&amp; operator=(const CountingAllocator&amp;);

  public:
    // CREATORS
    explicit
    CountingAllocator(bslma::Allocator *basicAllocator = 0);
    explicit
    CountingAllocator(const char       *name,
                      bslma::Allocator *basicAllocator = 0);
        // Create a counting allocator.  Optionally specify a &#39;name&#39;
        // (associated with this object) to be included in messages output by
        // the &#39;print&#39; method, thereby distinguishing this counting allocator
        // from others that might be used in the same program.  If &#39;name&#39; is 0
        // (or not specified), no distinguishing name is incorporated in
        // &#39;print&#39; output.  Optionally specify a &#39;basicAllocator&#39; used to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    virtual ~CountingAllocator();
        // Destroy this allocator object.  Note that destroying this allocator
        // has no effect on any outstanding allocated memory.

    // MANIPULATORS
    virtual void *allocate(size_type size);
        // Return a newly-allocated block of memory of the specified &#39;size&#39; (in
        // bytes).  If &#39;size&#39; is 0, a null pointer is returned with no other
        // effect (e.g., on allocation statistics).  Otherwise, invoke the
        // &#39;allocate&#39; method of the allocator supplied at construction, and
        // increment the number of currently (and cumulatively) allocated bytes
        // by &#39;size&#39;.

    virtual void deallocate(void *address);
        // Return the memory block at the specified &#39;address&#39; back to this
        // allocator.  If &#39;address&#39; is 0, this function has no effect (e.g., on
        // allocation statistics).  Otherwise, decrease the number of currently
        // allocated bytes by the size originally requested for the block.  The
        // behavior is undefined unless &#39;address&#39; was allocated using this
        // allocator object and has not already been deallocated.

    // ACCESSORS
    const char *name() const;
        // Return the name of this counting allocator, or 0 if no name was
        // specified at construction.

    bsls::Types::Int64 numBytesInUse() const;
        // Return the number of bytes currently allocated from this object.
        // Note that &#39;numBytesInUse() &lt;= numBytesTotal()&#39;.

    bsls::Types::Int64 numBytesTotal() const;
        // Return the cumulative number of bytes ever allocated from this
        // object.  Note that &#39;numBytesInUse() &lt;= numBytesTotal()&#39;.

    bsl::ostream&amp; print(bsl::ostream&amp; stream) const;
        // Write the accumulated state information held in this allocator to
        // the specified &#39;stream&#39; in some reasonable (multi-line) format, and
        // return a reference to &#39;stream&#39;.
};

// ============================================================================
//                         INLINE FUNCTION DEFINITIONS
// ============================================================================

                           // -----------------------
                           // class CountingAllocator
                           // -----------------------

// ACCESSORS
inline
const char *CountingAllocator::name() const
{
    return d_name_p;
}

inline
bsls::Types::Int64 CountingAllocator::numBytesInUse() const
{
    return d_numBytesInUse.loadRelaxed();
}

inline
bsls::Types::Int64 CountingAllocator::numBytesTotal() const
{
    return d_numBytesTotal.loadRelaxed();
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
