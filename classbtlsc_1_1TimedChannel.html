<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlsc::TimedChannel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlsc.html">btlsc</a>      </li>
      <li><a class="el" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlsc::TimedChannel Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlsc::TimedChannel" --><!-- doxytag: inherits="btlsc::Channel" -->
<p><code>#include &lt;<a class="el" href="btlsc__timedchannel_8h_source.html">btlsc_timedchannel.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlsc::TimedChannel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlsc_1_1TimedChannel.png" usemap="#btlsc::TimedChannel_map" alt=""/>
  <map id="btlsc::TimedChannel_map" name="btlsc::TimedChannel_map">
<area href="classbtlsc_1_1Channel.html" alt="btlsc::Channel" shape="rect" coords="0,0,151,24"/>
<area href="classbtlsos_1_1TcpTimedChannel.html" alt="btlsos::TcpTimedChannel" shape="rect" coords="0,112,151,136"/>
</map>
</div>

<p><a href="classbtlsc_1_1TimedChannel-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a113f28ef0829edb688f7cea0735ef141">~TimedChannel</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#aa6e7d7a43e3c921e3b7994143838c8a5">read</a> (char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#ab59fde4eed8bf2f5b75ed60b550b7b11">read</a> (int *augStatus, char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#aae95f9e919d0b410e8b98631f408f15c">timedRead</a> (char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a51c73163640fbb67dbb743d30b545461">timedRead</a> (int *augStatus, char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#ae3295a2d86824880eeb24d1c099776f1">readv</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#ad432f1bf2480dfa35ce1bfe5af096971">readv</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a15d50d46dfc8df7c7a8c345e95107fcc">timedReadv</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#aee2a9f0588b23e3c1ca7ba9443c39d19">timedReadv</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a6504f4a2919416095a920659e93d83ed">readRaw</a> (char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a77dd10d5c91167f74215b4a076da2447">readRaw</a> (int *augStatus, char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a343fb4d94f2deef15bb483357e96428c">timedReadRaw</a> (char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a5b35a20d07081e88428772bda4ee9ed6">timedReadRaw</a> (int *augStatus, char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a11afd2f67cc89ab2360489daaa997275">readvRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#afda9947efb6bbe61076ef27002033468">readvRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#aa55160a8750b3903c3df1b880267b6a1">timedReadvRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#aa5e63267c7c8c697c65eb08d78e82e58">timedReadvRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a87d383bf17a44ac7792cd4a3cb49d5c2">bufferedRead</a> (const char **buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a06af323598ea8128962ad58c3f395541">bufferedRead</a> (int *augStatus, const char **buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#aa773c86182fbf9db87038eded3c100c0">timedBufferedRead</a> (const char **buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a9f88bb459460da9f7340b415e164e456">timedBufferedRead</a> (int *augStatus, const char **buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a5dd4767cd340cb49fba9cd7eef322252">bufferedReadRaw</a> (const char **buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#af5232093e6c2db53f2df06b79e4adf49">bufferedReadRaw</a> (int *augStatus, const char **buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#ab01361256bd112dfcb2226fd62b46baa">timedBufferedReadRaw</a> (const char **buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a17e77dfd82469eb8e876de69d6197cf0">timedBufferedReadRaw</a> (int *augStatus, const char **buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#af4618ca1d8246c5b1b7cd80aa22c6f3e">write</a> (const char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a9676b599f143bb2e557f6d2f35d87e7e">write</a> (int *augStatus, const char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#adfb9b67e2675cf0bac48100380b7be46">timedWrite</a> (int *augStatus, const char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a992bd0b098330327b38b8ac8e81ca2b3">timedWrite</a> (const char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#ae2f0f4ee7ddc0fac11e4a4e14aed2fb1">writeRaw</a> (const char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a18a872e47d6bed16924712c3d208b3b4">writeRaw</a> (int *augStatus, const char *buffer, int numBytes, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a9b3c2e1b9c7f76da0ce6e57f500266be">timedWriteRaw</a> (int *augStatus, const char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a72fb98c0c244722b0bf50de03f7c14ef">timedWriteRaw</a> (const char *buffer, int numBytes, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#abe0bcbc0fdb4df6e8ab99bea0740923a">writev</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#af1e9c9795a24ffca18f6fc9d07c36760">writev</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#ac0274a4ba4cd0435ab4052d537c94256">writev</a> (int *augStatus, const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#ab91d5a34cf60e1d19d53ba916d3d4e3b">writev</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a65f5e31b5c231f4c50b7da0a9a94e456">timedWritev</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#aa8929c2572dc426110c1c298e8de4b6d">timedWritev</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#aa6dbd53812337f1be6a9a19865fbf1b2">timedWritev</a> (int *augStatus, const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a4aa9dc8de63950de2ea490266c366d15">timedWritev</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a51902a4d7db84af44306d8500ac6c1e8">writevRaw</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#ae6fbfcb75a6762ac2b15414293ce1f99">writevRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a218f3e7f5dcd27ed808fc5322a19446e">writevRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#aed4f2547ec415cc0247cbd7923a554c4">writevRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a9bbb75ce852a389417aa6727337614f1">timedWritevRaw</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a2624dba51bab2f3eeede19c8906f3e27">timedWritevRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a2b749f47cb21b60a88cf2c95e08e48b1">timedWritevRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a32b82d439cecc66991850c248eb6c01b">timedWritevRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#a61020bb76979046ff1f4d1c1b20cc365">invalidate</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1TimedChannel.html#abea62fb47ee9411dd1277106e0d57a15">isInvalid</a> () const =0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class defines a protocol (pure abstract interface) for a synchronous communication channel that supports timed (blocking) read, write, and buffered read operations on a byte stream. In general, a non-negative status indicates the number of bytes read or written, while a negative status implies an unspecified error. Note that an error status of -1 indicates that the connection is <em>known</em> to have been closed by the peer. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a113f28ef0829edb688f7cea0735ef141"></a><!-- doxytag: member="btlsc::TimedChannel::~TimedChannel" ref="a113f28ef0829edb688f7cea0735ef141" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual btlsc::TimedChannel::~TimedChannel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa6e7d7a43e3c921e3b7994143838c8a5"></a><!-- doxytag: member="btlsc::TimedChannel::read" ref="aa6e7d7a43e3c921e3b7994143838c8a5" args="(char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::read </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a7d1d3187198316fffcc8d08b7e8786a3">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a735286c8d0703c95f0ce7b46d34fc2f6">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ab59fde4eed8bf2f5b75ed60b550b7b11"></a><!-- doxytag: member="btlsc::TimedChannel::read" ref="ab59fde4eed8bf2f5b75ed60b550b7b11" args="(int *augStatus, char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::read </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into the specified <code>buffer</code> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a644cd29a99f7be2fd646d574a3a4e9d8">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a59c8d4a5dde54f787d434b6454390b07">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aae95f9e919d0b410e8b98631f408f15c"></a><!-- doxytag: member="btlsc::TimedChannel::timedRead" ref="aae95f9e919d0b410e8b98631f408f15c" args="(char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedRead </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a51e3795892b3e8e4b07f4f0f00420d17">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a51c73163640fbb67dbb743d30b545461"></a><!-- doxytag: member="btlsc::TimedChannel::timedRead" ref="a51c73163640fbb67dbb743d30b545461" args="(int *augStatus, char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedRead </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into the specified <code>buffer</code> the specified <code>numBytes</code> or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, or a positive value if the interruption was due to an asynchronous event; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ada1d0d17d220080cd5a53d70ec465e96">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ae3295a2d86824880eeb24d1c099776f1"></a><!-- doxytag: member="btlsc::TimedChannel::readv" ref="ae3295a2d86824880eeb24d1c099776f1" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::readv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a2b26b82cfc6a061e214731bb8c1485ff">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ad59b39102e0c16ba67133ed01c56fd16">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ad432f1bf2480dfa35ce1bfe5af096971"></a><!-- doxytag: member="btlsc::TimedChannel::readv" ref="ad432f1bf2480dfa35ce1bfe5af096971" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::readv </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into the specified sequence of <code>buffers</code> of the specified <code>numBuffers</code>, the respective number of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> buffer. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a partial result. Return <code>numBytes</code> (i.e., the sum of calls to <code>length</code> on the <code>numBuffers</code> <code>buffers</code>) on success, a negative value on error, and the number of bytes newly read into <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffers</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffers</code> have sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a2606f75082b4dc81a79e8ac6a9abdb7f">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#af7eb08a819a2467f2c35130558e65ec8">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a15d50d46dfc8df7c7a8c345e95107fcc"></a><!-- doxytag: member="btlsc::TimedChannel::timedReadv" ref="a15d50d46dfc8df7c7a8c345e95107fcc" args="(const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedReadv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a1ede9bdb52cbd652d4594664ea7e3f0b">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aee2a9f0588b23e3c1ca7ba9443c39d19"></a><!-- doxytag: member="btlsc::TimedChannel::timedReadv" ref="aee2a9f0588b23e3c1ca7ba9443c39d19" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedReadv </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into the specified sequence of <code>buffers</code> of the specified <code>numBuffers</code>, the respective number of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> buffer, or interrupted after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> (i.e., the sum of calls to <code>length</code> on the <code>numBuffers</code> <code>buffers</code>) on success, a negative value on error, and the number of bytes newly read into <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation or a positive value if the interruption was due to an asynchronous event; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffers</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffers</code> have sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a7d1ff207fd82a6c0a29a17c83e093aec">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a6504f4a2919416095a920659e93d83ed"></a><!-- doxytag: member="btlsc::TimedChannel::readRaw" ref="a6504f4a2919416095a920659e93d83ed" args="(char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::readRaw </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a0f1f507ecd97fcdf09cfea3e6db6f8a4">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#af3a53d360e6d321c27cdc779a718db64">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a77dd10d5c91167f74215b4a076da2447"></a><!-- doxytag: member="btlsc::TimedChannel::readRaw" ref="a77dd10d5c91167f74215b4a076da2447" args="(int *augStatus, char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::readRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into the specified <code>buffer</code> <em>at</em> <em>most</em> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a16812cf3507d1f1c02dfccc3e28890a0">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a17a3b84250892eb51666082bc641ce73">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a343fb4d94f2deef15bb483357e96428c"></a><!-- doxytag: member="btlsc::TimedChannel::timedReadRaw" ref="a343fb4d94f2deef15bb483357e96428c" args="(char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedReadRaw </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#addd4b5dd913a39bb285a75d875e1d736">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a5b35a20d07081e88428772bda4ee9ed6"></a><!-- doxytag: member="btlsc::TimedChannel::timedReadRaw" ref="a5b35a20d07081e88428772bda4ee9ed6" args="(int *augStatus, char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedReadRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into the specified <code>buffer</code> <em>at</em> <em>most</em> the specified <code>numBytes</code> or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, a positive value if an asynchronous event caused an interruption, or a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ac22f9965e7cdc3b546f9e0a21864a835">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a11afd2f67cc89ab2360489daaa997275"></a><!-- doxytag: member="btlsc::TimedChannel::readvRaw" ref="a11afd2f67cc89ab2360489daaa997275" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::readvRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#af67ae242a8d90cd3e1f7a646021b8b6a">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a759d571ee9286c1e0aa53e2ebdbe1488">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="afda9947efb6bbe61076ef27002033468"></a><!-- doxytag: member="btlsc::TimedChannel::readvRaw" ref="afda9947efb6bbe61076ef27002033468" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::readvRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into the specified sequence of <code>buffers</code> of the specified <code>numBuffers</code>, <em>at</em> <em>most</em> the respective number of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> buffer. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> (i.e., the sum of calls to <code>length</code> on the <code>numBuffers</code> <code>buffers</code>) on success, a negative value on error, and the number of bytes newly read into <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffers</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffers</code> have sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#af30686c7fad7e62c4367ba62646d5e05">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a75795b4d4304bcf7330a14e704f9c39c">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aa55160a8750b3903c3df1b880267b6a1"></a><!-- doxytag: member="btlsc::TimedChannel::timedReadvRaw" ref="aa55160a8750b3903c3df1b880267b6a1" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedReadvRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#af8d6e64ff4c1ef8b39d6b063df1fbb9a">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aa5e63267c7c8c697c65eb08d78e82e58"></a><!-- doxytag: member="btlsc::TimedChannel::timedReadvRaw" ref="aa5e63267c7c8c697c65eb08d78e82e58" args="(const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedReadvRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into the specified sequence of <code>buffers</code> of the specified <code>numBuffers</code> <em>at</em> <em>most</em> the respective number of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> buffer, or interrupted after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> (i.e., the sum of calls to <code>length</code> on the <code>numBuffers</code> <code>buffers</code>) on success, a negative value on error, and the number of bytes newly read into <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, a positive value if an asynchronous event caused an interruption, or a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffers</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffers</code> have sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a90c0fdf35ff0164410d3c296db346d48">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a87d383bf17a44ac7792cd4a3cb49d5c2"></a><!-- doxytag: member="btlsc::TimedChannel::bufferedRead" ref="a87d383bf17a44ac7792cd4a3cb49d5c2" args="(const char **buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::bufferedRead </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a25814ffdbbe699bf33af793c701f233f">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a8eecaa9c994297962c059abf53d14385">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a06af323598ea8128962ad58c3f395541"></a><!-- doxytag: member="btlsc::TimedChannel::bufferedRead" ref="a06af323598ea8128962ad58c3f395541" args="(int *augStatus, const char **buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::bufferedRead </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into a channel-supplied buffer, identified via the specified <code>buffer</code>, the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes (indicating a partial result) otherwise. Any positive return value guarantees that <code>*buffer</code> will remain valid until this channel is modified. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried with some reasonable hope of success -- buffered data from a partial result remains available until consumed by subsequent read operations. A negative "status", however, indicates a permanent error (leaving <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a8cd68049ca8edc3e80d5f36ade6aac2f">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a72f72ac59fd245a2e7de7f7c50854a01">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aa773c86182fbf9db87038eded3c100c0"></a><!-- doxytag: member="btlsc::TimedChannel::timedBufferedRead" ref="aa773c86182fbf9db87038eded3c100c0" args="(const char **buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedBufferedRead </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a6c8202802fd718a1b22ffc95af50360b">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a9f88bb459460da9f7340b415e164e456"></a><!-- doxytag: member="btlsc::TimedChannel::timedBufferedRead" ref="a9f88bb459460da9f7340b415e164e456" args="(int *augStatus, const char **buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedBufferedRead </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into a channel-supplied buffer, identified via the specified <code>buffer</code>, the specified <code>numBytes</code>, or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes (indicating a partial result) otherwise. Any positive return value guarantees that <code>*buffer</code> will remain valid until this channel is modified. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, or a positive value if the interruption was due to an asynchronous event; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried with some reasonable hope of success -- buffered data from a partial result remains available until consumed by subsequent read operations. A negative "status", however, indicates a permanent error (leaving <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a17873f7d1fd9131dfa4762ed77cde07e">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a5dd4767cd340cb49fba9cd7eef322252"></a><!-- doxytag: member="btlsc::TimedChannel::bufferedReadRaw" ref="a5dd4767cd340cb49fba9cd7eef322252" args="(const char **buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::bufferedReadRaw </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a3c565a7f18a2515c6d00459db5ce7374">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#aae5cee6d0a2819d4588d19e7df896499">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="af5232093e6c2db53f2df06b79e4adf49"></a><!-- doxytag: member="btlsc::TimedChannel::bufferedReadRaw" ref="af5232093e6c2db53f2df06b79e4adf49" args="(int *augStatus, const char **buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::bufferedReadRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into a channel-supplied buffer, identified via the specified <code>buffer</code>, <em>at</em> <em>most</em> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. Any positive return value guarantees that <code>*buffer</code> will remain valid until this channel is modified. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation, or a negative value if the atomic OS-level operation transmitted at least one but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried with some reasonable hope of success -- buffered data from a partial result remains available until consumed by subsequent read operations. A negative "status", however, indicates a permanent error (leaving <code>buffer</code> unset); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#addbe8479c8251f6eade148029fddd2de">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ad86fbea8e77192280b02c7e7380269ed">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ab01361256bd112dfcb2226fd62b46baa"></a><!-- doxytag: member="btlsc::TimedChannel::timedBufferedReadRaw" ref="ab01361256bd112dfcb2226fd62b46baa" args="(const char **buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedBufferedReadRaw </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a43ef9f68bdb69997d3dff6164836c176">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a17e77dfd82469eb8e876de69d6197cf0"></a><!-- doxytag: member="btlsc::TimedChannel::timedBufferedReadRaw" ref="a17e77dfd82469eb8e876de69d6197cf0" args="(int *augStatus, const char **buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedBufferedReadRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into a channel-supplied buffer, identified via the specified <code>buffer</code>, <em>at</em> <em>most</em> the specified <code>numBytes</code> or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, a positive value if an asynchronous event caused an interruption, or a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried with some reasonable hope of success -- buffered data from a partial result remains available until consumed by subsequent read operations. A negative "status", however, indicates a permanent error (leaving <code>*buffer</code> unset); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#af47a7032068d8772e0f687792908488e">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="af4618ca1d8246c5b1b7cd80aa22c6f3e"></a><!-- doxytag: member="btlsc::TimedChannel::write" ref="af4618ca1d8246c5b1b7cd80aa22c6f3e" args="(const char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::write </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a707d767695090653fcf137f77e934caa">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ab4d083426f2b0fc2e3f24b56efb0c3ee">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a9676b599f143bb2e557f6d2f35d87e7e"></a><!-- doxytag: member="btlsc::TimedChannel::write" ref="a9676b599f143bb2e557f6d2f35d87e7e" args="(int *augStatus, const char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::write </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this channel from the specified <code>buffer</code> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a3f49d7e1fdaba60d733ffe95649a7549">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ae585e569a0d7fb45379e56e707892f2c">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="adfb9b67e2675cf0bac48100380b7be46"></a><!-- doxytag: member="btlsc::TimedChannel::timedWrite" ref="adfb9b67e2675cf0bac48100380b7be46" args="(int *augStatus, const char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedWrite </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a7e1b7060a538ad6cdb09c98260bf2fa5">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a992bd0b098330327b38b8ac8e81ca2b3"></a><!-- doxytag: member="btlsc::TimedChannel::timedWrite" ref="a992bd0b098330327b38b8ac8e81ca2b3" args="(const char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedWrite </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this channel from the specified <code>buffer</code> the specified <code>numBytes</code> or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, or a positive value if the interruption was due to an asynchronous event; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "write" operation will still be attempted, but the attempt will not block. </p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#acd76a187c20f2afb0a1ed48b603de380">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ae2f0f4ee7ddc0fac11e4a4e14aed2fb1"></a><!-- doxytag: member="btlsc::TimedChannel::writeRaw" ref="ae2f0f4ee7ddc0fac11e4a4e14aed2fb1" args="(const char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::writeRaw </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a0642d2cf21c570446af7f63b748b382d">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a897717b587849e0bcd99402e8dac6ed5">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a18a872e47d6bed16924712c3d208b3b4"></a><!-- doxytag: member="btlsc::TimedChannel::writeRaw" ref="a18a872e47d6bed16924712c3d208b3b4" args="(int *augStatus, const char *buffer, int numBytes, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::writeRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> write to this channel from the specified <code>buffer</code> <em>at</em> <em>most</em> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#afce89ca4cbe8df392ea0fc2b7cb18134">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a93998cf7d4b5ecc4e5a1e6ec35bf490b">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a9b3c2e1b9c7f76da0ce6e57f500266be"></a><!-- doxytag: member="btlsc::TimedChannel::timedWriteRaw" ref="a9b3c2e1b9c7f76da0ce6e57f500266be" args="(int *augStatus, const char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedWriteRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a60fa72c4531426429ce3b8ae3f0f0039">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a72fb98c0c244722b0bf50de03f7c14ef"></a><!-- doxytag: member="btlsc::TimedChannel::timedWriteRaw" ref="a72fb98c0c244722b0bf50de03f7c14ef" args="(const char *buffer, int numBytes, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedWriteRaw </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> write to this channel from the specified <code>buffer</code> <em>at</em> <em>most</em> the specified <code>numBytes</code>, or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, a positive value if an asynchronous event caused an interruption, or a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "write" operation will still be attempted, but the attempt will not block. </p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a99a6a1ad6462a051f33f913e1e9305c3">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="abe0bcbc0fdb4df6e8ab99bea0740923a"></a><!-- doxytag: member="btlsc::TimedChannel::writev" ref="abe0bcbc0fdb4df6e8ab99bea0740923a" args="(const btls::Ovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::writev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#af3be1ce9b3d03861d143b45b97132f5a">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ae77fa6e093fdcf83866266c8a700d020">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="af1e9c9795a24ffca18f6fc9d07c36760"></a><!-- doxytag: member="btlsc::TimedChannel::writev" ref="af1e9c9795a24ffca18f6fc9d07c36760" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::writev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a09eba049efd10344351ff5b4622f7e0e">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a00d5d3982a1e42735189a2ab29ca4087">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ac0274a4ba4cd0435ab4052d537c94256"></a><!-- doxytag: member="btlsc::TimedChannel::writev" ref="ac0274a4ba4cd0435ab4052d537c94256" args="(int *augStatus, const btls::Ovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::writev </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a3206ad8bcf977c74579538b493b25d1b">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#aeb9ad24d386b174c7d75c5c0c5f5ab85">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ab91d5a34cf60e1d19d53ba916d3d4e3b"></a><!-- doxytag: member="btlsc::TimedChannel::writev" ref="ab91d5a34cf60e1d19d53ba916d3d4e3b" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::writev </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this channel from the specified sequence of <code>buffers</code> of the specified sequence length <code>numBuffers</code>, the respective number of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> (or <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code>) buffer. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a partial result. Return <code>numBytes</code> (i.e., the sum of calls to <code>length</code> on the <code>numBuffers</code> <code>buffers</code>) on success, a negative value on error, and the number of bytes newly written from <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a0e798cdf27aa1971e22a15039c44db8d">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#afc322f0914cb50d6abee9f5012c49c2d">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a65f5e31b5c231f4c50b7da0a9a94e456"></a><!-- doxytag: member="btlsc::TimedChannel::timedWritev" ref="a65f5e31b5c231f4c50b7da0a9a94e456" args="(const btls::Ovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedWritev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a556463f0f9a7b54aacb7dd810db19a96">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aa8929c2572dc426110c1c298e8de4b6d"></a><!-- doxytag: member="btlsc::TimedChannel::timedWritev" ref="aa8929c2572dc426110c1c298e8de4b6d" args="(const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedWritev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a15cea7877da7be56bfca34aa9363601b">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aa6dbd53812337f1be6a9a19865fbf1b2"></a><!-- doxytag: member="btlsc::TimedChannel::timedWritev" ref="aa6dbd53812337f1be6a9a19865fbf1b2" args="(int *augStatus, const btls::Ovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedWritev </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a6003601afd4e4e81b205da7b1a80c566">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a4aa9dc8de63950de2ea490266c366d15"></a><!-- doxytag: member="btlsc::TimedChannel::timedWritev" ref="a4aa9dc8de63950de2ea490266c366d15" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedWritev </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this channel from the specified sequence of <code>buffers</code> of the specified sequence length <code>numBuffers</code> the respective number of bytes specified in each <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> (or <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code>) buffer, or interrupted after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> (i.e., the sum of calls to <code>length</code> on the <code>numBuffers</code> <code>buffers</code>) on success, a negative value on error, and the number of bytes newly written from <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation or a positive value if the interruption was due to an asynchronous event; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "write" operation will still be attempted, but the attempt will not block. </p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a4959e33840bf63b606ec659bdba56efa">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a51902a4d7db84af44306d8500ac6c1e8"></a><!-- doxytag: member="btlsc::TimedChannel::writevRaw" ref="a51902a4d7db84af44306d8500ac6c1e8" args="(const btls::Ovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#abf4d5f6379e59ce8b026a78a1567c95f">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a316d48748074ad888cdfdd138262ce50">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ae6fbfcb75a6762ac2b15414293ce1f99"></a><!-- doxytag: member="btlsc::TimedChannel::writevRaw" ref="ae6fbfcb75a6762ac2b15414293ce1f99" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a44ce53caa3bab5c448a35634e3918ffa">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#af60db49d74a32c17089b3d57ac0050b9">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a218f3e7f5dcd27ed808fc5322a19446e"></a><!-- doxytag: member="btlsc::TimedChannel::writevRaw" ref="a218f3e7f5dcd27ed808fc5322a19446e" args="(int *augStatus, const btls::Ovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a993810b91aa73a1ce659aa9a3cd59d93">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ac40e73055d876fb403d1eb298886334b">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aed4f2547ec415cc0247cbd7923a554c4"></a><!-- doxytag: member="btlsc::TimedChannel::writevRaw" ref="aed4f2547ec415cc0247cbd7923a554c4" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> write to this channel, from the specified sequence of <code>buffers</code> of the specified sequence length <code>numBuffers</code>, <em>at</em> <em>most</em> the respective number of bytes as specified in each <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> (or <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code>) buffer. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> (i.e., the sum of calls to <code>length</code> on the <code>numBuffers</code> <code>buffers</code>) on success, a negative value on error, and the number of bytes newly written from <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a0223adc9241f6d19264a7e38b2f61677">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a8f2ef327d11a9780586862a51b37a6f9">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a9bbb75ce852a389417aa6727337614f1"></a><!-- doxytag: member="btlsc::TimedChannel::timedWritevRaw" ref="a9bbb75ce852a389417aa6727337614f1" args="(const btls::Ovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedWritevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ae63fab2f6ea5ccb87a92101eea34a18b">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a2624dba51bab2f3eeede19c8906f3e27"></a><!-- doxytag: member="btlsc::TimedChannel::timedWritevRaw" ref="a2624dba51bab2f3eeede19c8906f3e27" args="(const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedWritevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ab84a3306c896bc6de4663ff30a44440b">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a2b749f47cb21b60a88cf2c95e08e48b1"></a><!-- doxytag: member="btlsc::TimedChannel::timedWritevRaw" ref="a2b749f47cb21b60a88cf2c95e08e48b1" args="(int *augStatus, const btls::Ovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedWritevRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#af1f0d3ada152b5f40a6cac6a140b6554">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a32b82d439cecc66991850c248eb6c01b"></a><!-- doxytag: member="btlsc::TimedChannel::timedWritevRaw" ref="a32b82d439cecc66991850c248eb6c01b" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::timedWritevRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> write to this channel, from the specified sequence of <code>buffers</code> of the specified sequence length <code>numBuffers</code>, <em>at</em> <em>most</em> the respective number of bytes specified in each <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> (or <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code>) buffer, or interrupted after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> (i.e., the sum of calls to <code>length</code> on the <code>numBuffers</code> <code>buffers</code>) on success, a negative value on error, and the number of bytes newly written from <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with 0 if <code>timeout</code> interrupted this operation, a positive value if an asynchronous event caused an interruption, or a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. Note that if the <code>timeout</code> value has already passed, the "write" operation will still be attempted, but the attempt will not block. </p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a8d4503ce190f299af061395b80373747">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a61020bb76979046ff1f4d1c1b20cc365"></a><!-- doxytag: member="btlsc::TimedChannel::invalidate" ref="a61020bb76979046ff1f4d1c1b20cc365" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlsc::TimedChannel::invalidate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make this channel invalid; no subsequent operations can be completed successfully. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#adc7cc9dfc2e802578f09dd2c0418523c">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#ae3d77d146a11a8b472d2fe9e308fe1c8">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<a class="anchor" id="abea62fb47ee9411dd1277106e0d57a15"></a><!-- doxytag: member="btlsc::TimedChannel::isInvalid" ref="abea62fb47ee9411dd1277106e0d57a15" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::TimedChannel::isInvalid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if this channel is invalid, and 0 otherwise. Note that once a channel is invalid, no operations can be completed successfully. Also note that a 0 return value does NOT guarantee that a subsequent I/O operation would not fail. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a115e9e4d1c7e221d8b8ed7f6fe0a63d9">btlsc::Channel</a>.</p>

<p>Implemented in <a class="el" href="classbtlsos_1_1TcpTimedChannel.html#a9173d6b4ac3106ad3f6b78641d858064">btlsos::TcpTimedChannel</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlsc__timedchannel_8h_source.html">btlsc_timedchannel.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:14 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
