<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// balm_stopwatchscopedguard.h                                        -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALM_STOPWATCHSCOPEDGUARD
#define INCLUDED_BALM_STOPWATCHSCOPEDGUARD

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a scoped guard for recording elapsed time.
//
//@CLASSES:
// balm::StopwatchScopedGuard: guard for recording a metric for elapsed time
//
//@SEE_ALSO: balm_metricsmanager, balm_defaultmetricsmanager, balm_metric
//
//@DESCRIPTION: This component provides a scoped guard class intended to
// simplify the task of recording (to a metric) the elapsed time of a block of
// code.  The &#39;balm::StopwatchScopedGuard&#39; is supplied the identity of a metric
// on construction, and an optional enumerated constant indicating the time
// units to report values in (by default, values are reported in seconds).  The
// guard measures the elapsed time between its construction and destruction,
// and on destruction records that elapsed time, in the indicated time units,
// to the supplied metric.
//
///Choosing Between &#39;balm::StopwatchScopedGuard&#39; and Macros
///--------------------------------------------------------
// The &#39;balm::StopwatchScopedGuard&#39; class and the macros defined in the
// &#39;balm_metrics&#39; component provide the same basic functionality.  Clients may
// find that using a &#39;balm::StopwatchScopedGuard&#39; object (in coordination with
// a &#39;balm::Metric&#39; object) is better suited to collecting metrics associated
// with a particular instance of a stateful object, while macros are better
// suited to collecting metrics associated with a particular code path (rather
// than an object instance).  In most instances, however, choosing between the
// two is a matter of taste.
//
///Thread Safety
///-------------
// &#39;balm::StopwatchScopedGuard&#39; is *const* *thread-safe*, meaning that
// accessors may be invoked concurrently from different threads, but it is not
// safe to access or modify a &#39;balm::StopwatchScopedGuard&#39; in one thread while
// thread modifies the same object.  Note however, that at this another time
// &#39;balm::StopwatchScopedGuard&#39; provides no manipulator methods.
//
///Usage
///-----
// The following examples demonstrate how to record the elapsed time of a block
// of code using a &#39;balm::StopwatchScopedGuard&#39;.
//
///Example 1: Create and Configure the Default &#39;balm::MetricsManager&#39; Instance
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// This example demonstrates how to create the default &#39;balm::MetricManager&#39;
// instance and perform a trivial configuration.
//
// First we create a &#39;balm::DefaultMetricsManagerScopedGuard&#39;, which manages
// the lifetime of the default metrics manager instance.  At construction, we
// provide the scoped guard an output stream (&#39;stdout&#39;) that it will publish
// metrics to.  Note that the default metrics manager is intended to be created
// and destroyed by the *owner* of &#39;main&#39;.  An instance of the manager should
// be created during the initialization of an application (while the task has a
// single thread) and destroyed just prior to termination (when there is
// similarly a single thread).
//..
//  int main(int argc, char *argv[])
//  {
//
//  // ...
//
//      balm::DefaultMetricsManagerScopedGuard managerGuard(bsl::cout);
//..
// Once the default instance has been created, it can be accessed using the
// &#39;instance&#39; operation:
//..
//     balm::MetricsManager *manager = balm::DefaultMetricsManager::instance();
//     assert(0 != manager);
//..
// Note that the default metrics manager will be released when &#39;managerGuard&#39;
// exits this scoped and is destroyed.  Clients that choose to explicitly call
// the &#39;balm::DefaultMetricsManager::create&#39; method must also explicitly call
// the &#39;balm::DefaultMetricsManager::release&#39; method.
//
///Example 2: Metric Collection with &#39;balm::StopwatchScopedGuard&#39;
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Alternatively, we can use the &#39;balm::StopwatchScopedGuard&#39; to record metric
// values.  In the following example we implement a hypothetical request
// processor similar to the one in example 3.  We use a &#39;balm::Metric&#39;
// (&#39;d_elapsedTime&#39;) and a &#39;balm::StopwatchScopedGuard&#39; (&#39;guard&#39;) to record the
// elapsed time of the request-processing function.
//..
//  class RequestProcessor {
//
//      // DATA
//      balm::Metric d_elapsedTime;
//
//    public:
//
//      // CREATORS
//      RequestProcessor()
//      : d_elapsedTime(&quot;MyCategory&quot;, &quot;RequestProcessor/elapsedTime&quot;)
//      {}
//
//      // MANIPULATORS
//      int processRequest(const bsl::string&amp; request)
//          // Process the specified &#39;request&#39;.  Return 0 on success, and a
//          // non-zero value otherwise.
//      {
//         int returnCode = 0;
//
//         balm::StopwatchScopedGuard guard(&amp;d_elapsedTime);
//
//  // ...
//
//         return returnCode;
//      }
//
//  // ...
//  };
//
//  // ...
//
//      RequestProcessor processor;
//
//      processor.processRequest(&quot;ab&quot;);
//      processor.processRequest(&quot;abc&quot;);
//      processor.processRequest(&quot;abc&quot;);
//      processor.processRequest(&quot;abdef&quot;);
//
//      manager-&gt;publishAll();
//
//      processor.processRequest(&quot;ab&quot;);
//      processor.processRequest(&quot;abc&quot;);
//      processor.processRequest(&quot;abc&quot;);
//      processor.processRequest(&quot;abdef&quot;);
//
//      processor.processRequest(&quot;a&quot;);
//      processor.processRequest(&quot;abc&quot;);
//      processor.processRequest(&quot;abc&quot;);
//      processor.processRequest(&quot;abdefg&quot;);
//
//      manager-&gt;publishAll();
//
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BALM_COLLECTOR
#include &lt;balm_collector.h&gt;
#endif

#ifndef INCLUDED_BALM_COLLECTORREPOSITORY
#include &lt;balm_collectorrepository.h&gt;
#endif

#ifndef INCLUDED_BALM_DEFAULTMETRICSMANAGER
#include &lt;balm_defaultmetricsmanager.h&gt;
#endif

#ifndef INCLUDED_BALM_METRIC
#include &lt;balm_metric.h&gt;
#endif

#ifndef INCLUDED_BALM_METRICSMANAGER
#include &lt;balm_metricsmanager.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSLS_STOPWATCH
#include &lt;bsls_stopwatch.h&gt;
#endif

namespace BloombergLP {

namespace balm {
                         // ==========================
                         // class StopwatchScopedGuard
                         // ==========================

class StopwatchScopedGuard {
    // This class provides a mechanism for recording, to a metric, the elapsed
    // time from the construction of an instance of the guard until that
    // instance goes out of scope (and is destroyed).  The constructor of this
    // class takes an optional argument indicating the time units in which to
    // report the elapsed time; by default a guard will report time in seconds.
    // The supplied time units determine the scale of the double value reported
    // by this guard, but does *not* affect the precision of the elapsed time
    // measurement.  Each instance of this class delegates to a &#39;Collector&#39; for
    // the metric.  This &#39;Collector&#39; is initialized on construction based on
    // the constructor arguments.  If this scoped guard is not initialized with
    // an active metric, or if the supplied metric becomes inactive before the
    // scoped guard is destroyed, then &#39;isActive()&#39; will return &#39;false&#39; and no
    // metric values will be recorded.  Note that if the metric supplied at
    // construction is not active when the scoped guard is constructed, the
    // scoped guard will not become active or record metric values regardless
    // of the future state of that supplied metric.

  public:
    // PUBLIC TYPES
    enum Units {
        // An enumeration of supported time units.

        k_NANOSECONDS   = 1000000000,
        k_MICROSECONDS  = 1000000,
        k_MILLISECONDS  = 1000,
        k_SECONDS       = 1
    };

  private:
    // DATA
    bsls::Stopwatch d_stopwatch;    // stopwatch

    Units           d_timeUnits;    // time units to record elapsed time in

    Collector *d_collector_p;  // metric collector (held, not owned); may
                                    // be 0, but cannot be invalid

    // NOT IMPLEMENTED
    StopwatchScopedGuard(const StopwatchScopedGuard&amp;);
    StopwatchScopedGuard&amp; operator=(const StopwatchScopedGuard&amp;);

  public:
    // CREATORS
    explicit StopwatchScopedGuard(Metric *metric,
                                  Units   timeUnits = k_SECONDS);
        // Initialize this scoped guard to record elapsed time using the
        // specified &#39;metric&#39;.  Optionally specify the &#39;timeUnits&#39; in which to
        // report elapsed time.  If &#39;metric-&gt;isActive()&#39; is &#39;false&#39;, this
        // object will also be inactive (i.e., will not record any values).
        // The behavior is undefined unless &#39;metric&#39; is a valid address of a
        // &#39;Metric&#39; object.  Note that &#39;timeUnits&#39; indicates the scale of the
        // double value reported by this guard, but does *not* affect the
        // precision of the elapsed time measurement.

    explicit StopwatchScopedGuard(Collector *collector,
                                  Units      timeUnits = k_SECONDS);
        // Initialize this scoped guard to record elapsed time using the
        // specified &#39;collector&#39;.  Optionally specify the &#39;timeUnits&#39; in which
        // to report elapsed time.  If &#39;collector&#39; is 0 or
        //&#39;collector-&gt;category().enabled() == false&#39;, this object will be
        // inactive (i.e., will not record any values).  The behavior is
        // undefined unless
        // &#39;collector == 0 || collector-&gt;metricId().isValid()&#39;.  Note that
        // &#39;timeUnits&#39; indicates the scale of the double value reported by
        // this guard, but does *not* affect the precision of the elapsed time
        // measurement.

    StopwatchScopedGuard(const MetricId&amp;  metricId,
                         MetricsManager  *manager = 0);
    StopwatchScopedGuard(const MetricId&amp;  metricId,
                         Units            timeUnits,
                         MetricsManager  *manager = 0);
        // Initialize this scoped guard to record an elapsed time to the
        // specified &#39;metricId&#39; from the optionally specified &#39;manager&#39;.
        // Optionally specify the &#39;timeUnits&#39; in which to report elapsed time.
        // If &#39;timeUnits&#39; is not provided, the elapsed time will be reported in
        // seconds.  If &#39;manager&#39; is 0, the &#39;DefaultMetricsManager&#39; singleton
        // instance is used.  If no &#39;manager&#39; is supplied and the default
        // instance has not been created, this object will be inactive (i.e.,
        // it will not record any values); similarly, if the metric&#39;s
        // associated category is disabled (i.e.,
        // &#39;metricId.category()-&gt;enabled()&#39; is &#39;false&#39;), then this object will
        // be inactive.  The behavior is undefined unless unless &#39;metricId&#39; is
        // a valid id returned by the &#39;MetricRepository&#39; object owned by the
        // indicated metrics manager.  Note that &#39;timeUnits&#39; indicates the
        // scale of the double value reported by this guard, but does *not*
        // affect the precision of the elapsed time measurement.

    StopwatchScopedGuard(const char     *category,
                         const char     *name,
                         MetricsManager *manager = 0);
    StopwatchScopedGuard(const char     *category,
                         const char     *name,
                         Units           timeUnits,
                         MetricsManager *manager = 0);
        // Initialize this scoped guard to record an elapsed time to the
        // metric, identified by the specified &#39;category&#39; and &#39;name&#39;, from the
        // optionally specified &#39;manager&#39;.  Optionally specify the &#39;timeUnits&#39;
        // in which to report elapsed time.  If &#39;timeUnits&#39; is not provided,
        // the elapsed time will be reported in seconds.  If &#39;manager&#39; is 0,
        // use the &#39;DefaultMetricsManager&#39; instance.  If no &#39;manager&#39; is
        // supplied, and the default instance has not been created, this
        // object will be inactive (i.e., it will not record any values);
        // similarly, if the identified &#39;category&#39; is disabled, then this
        // object will be inactive.  The behavior is undefined unless
        // &#39;category&#39; and &#39;name&#39; are null-terminated.  Note that &#39;timeUnits&#39;
        // indicates the scale of the double value reported by this guard, but
        // does *not* affect the precision of the elapsed time measurement.

    ~StopwatchScopedGuard();
        // Destroy this scoped guard and, if the scoped guard is active,
        // record the accumulated elapsed time from its creation..

    // ACCESSORS
    bool isActive() const;
        // Return &#39;true&#39; if this scoped guard will actively record metrics, and
        // &#39;false&#39; otherwise.  If the returned value is &#39;false&#39; the destructor
        // will not record a value to the metric.  A scoped guard will be
        // inactive if either (1) it was not initialized with a valid metric,
        // (2) the metric it was initialized with was not active at the time
        // of construction, or (3) the metric supplied at construction is
        // currently inactive, meaning the category of metrics this metric
        // belongs to has been disabled since this object&#39;s construction (see
        // the &#39;MetricsManager&#39; method &#39;setCategoryEnabled&#39;).
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                         // --------------------------
                         // class StopwatchScopedGuard
                         // --------------------------

// CREATORS
inline
StopwatchScopedGuard::StopwatchScopedGuard(Metric *metric,
                                           Units   timeUnits)
: d_stopwatch()
, d_timeUnits(timeUnits)
, d_collector_p(metric-&gt;isActive() ? metric-&gt;collector() : 0)
{
    if (d_collector_p) {
        d_stopwatch.start();
    }
}

inline
StopwatchScopedGuard::StopwatchScopedGuard(Collector *collector,
                                           Units      timeUnits)
: d_stopwatch()
, d_timeUnits(timeUnits)
, d_collector_p((collector &amp;&amp; collector-&gt;metricId().category()-&gt;enabled())
                ? collector
                : 0)
{
    if (d_collector_p) {
        d_stopwatch.start();
    }
}

inline
StopwatchScopedGuard::StopwatchScopedGuard(const MetricId&amp;  metricId,
                                           MetricsManager  *manager)
: d_stopwatch()
, d_timeUnits(k_SECONDS)
, d_collector_p(0)
{
    Collector *collector = Metric::lookupCollector(metricId, manager);
    d_collector_p = (collector &amp;&amp;
                     collector-&gt;metricId().category()-&gt;enabled())
                    ? collector : 0;
    if (d_collector_p) {
        d_stopwatch.start();
    }
}

inline
StopwatchScopedGuard::StopwatchScopedGuard(const MetricId&amp;  metricId,
                                           Units            timeUnits,
                                           MetricsManager  *manager)
: d_stopwatch()
, d_timeUnits(timeUnits)
, d_collector_p(0)
{
    Collector *collector = Metric::lookupCollector(metricId, manager);
    d_collector_p = (collector &amp;&amp;
                     collector-&gt;metricId().category()-&gt;enabled())
                    ? collector : 0;
    if (d_collector_p) {
        d_stopwatch.start();
    }
}

inline
StopwatchScopedGuard::StopwatchScopedGuard(const char     *category,
                                           const char     *name,
                                           MetricsManager *manager)
: d_stopwatch()
, d_timeUnits(k_SECONDS)
, d_collector_p(0)
{
    Collector *collector = Metric::lookupCollector(category, name, manager);

    d_collector_p = (collector &amp;&amp;
                     collector-&gt;metricId().category()-&gt;enabled())
                    ? collector : 0;

    if (d_collector_p) {
        d_stopwatch.start();
    }
}

inline
StopwatchScopedGuard::StopwatchScopedGuard(const char     *category,
                                           const char     *name,
                                           Units           timeUnits,
                                           MetricsManager *manager)
: d_stopwatch()
, d_timeUnits(timeUnits)
, d_collector_p(0)
{
    Collector *collector = Metric::lookupCollector(category, name, manager);
    d_collector_p = (collector &amp;&amp; collector-&gt;metricId().category()-&gt;enabled())
                    ? collector : 0;
    if (d_collector_p) {
        d_stopwatch.start();
    }
}

inline
StopwatchScopedGuard::~StopwatchScopedGuard()
{
    if (isActive()) {
        d_collector_p-&gt;update(d_stopwatch.elapsedTime() * d_timeUnits);
    }
}

// ACCESSORS
inline
bool StopwatchScopedGuard::isActive() const
{
    return 0 != d_collector_p
        &amp;&amp; d_collector_p-&gt;metricId().category()-&gt;enabled();
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
