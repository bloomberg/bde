<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlt_calendar.h                                                    -*-C++-*-
#ifndef INCLUDED_BDLT_CALENDAR
#define INCLUDED_BDLT_CALENDAR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide fast repository for accessing weekend/holiday information.
//
//@CLASSES:
//  bdlt::Calendar: fast repository for accessing weekend/holiday information
//
//@SEE_ALSO: bdlt_packedcalendar
//
//@DESCRIPTION: This component provides a value-semantic class,
// &#39;bdlt::Calendar&#39;, that represents weekend and holiday information over a
// *valid* *range* of dates.  A &#39;bdlt::Calendar&#39; is an approximation to the
// same *mathematical* type, and is capable of representing the same subset of
// *mathematical* values, as a &#39;bdlt::PackedCalendar&#39;.  A &#39;bdlt::Calendar&#39;
// object (representing the same *mathematical* value) can be constructed
// directly from a reference to a non-modifiable &#39;bdlt::PackedCalendar&#39; object,
// and a reference to a non-modifiable &#39;bdlt::PackedCalendar&#39; is readily
// accessible from any &#39;bdlt::Calendar&#39; object.
//
// But unlike &#39;bdlt::PackedCalendar&#39;, which is optimized for spatial
// efficiency, &#39;bdlt::Calendar&#39; is designed to be especially efficient at
// determining whether a given &#39;bdlt::Date&#39; value (within the valid range for a
// particular &#39;bdlt::Calendar&#39; object) is a business day -- i.e., not a weekend
// day or holiday (see &quot;Usage&quot; below).  For example, the cost of determining
// whether a given &#39;bdlt::Date&#39; is a business day, as opposed to a weekend or
// holiday, consists of only a few constant-time operations, compared to a
// binary search in a &#39;bdlt::PackedCalendar&#39; representing the same calendar
// value.
//
// Default-constructed calendars are empty, and have an empty valid range.
// Calendars can also be constructed with an initial (non-empty) valid range,
// implying that all dates within that range are business days.  The
// &#39;setValidRange&#39; and &#39;addDay&#39; methods modify the valid range of a calendar,
// and a suite of &quot;add&quot; methods can be used to populate a calendar with
// weekend days and holidays.
//
// The &#39;addHolidayCode&#39; method associates an integer &quot;holiday code&quot; with a
// specific date, and can be called repeatedly with different integers and the
// same date to build up a set of holiday codes for that date.  Note that
// holiday codes are unique integers that, from the perspective of the
// calendar, have no particular meaning.  Typically, the user will choose
// holiday code values that are indices into an auxiliary collection (such as a
// &#39;bsl::vector&lt;bsl::string&gt;&#39;) to identify holiday names for end-user display.
//
// Once a calendar is populated, a rich set of accessor methods can be used to
// determine, e.g., if a given date is a business day, or the number of
// non-business days within some subrange of the calendar.  The holidays
// within a calendar can be obtained in increasing (chronological) order using
// an iterator identified by the nested &#39;HolidayConstIterator&#39; &#39;typedef&#39;.  The
// set of holiday codes associated with an arbitrary date in a
// &#39;bdlt::Calendar&#39; (or the current holiday referred to by a
// &#39;HolidayConstIterator&#39;) can be obtained in increasing (numerical) order
// using an iterator identified by the nested &#39;HolidayCodeConstIterator&#39;
// &#39;typedef&#39; (see below).
//
// Calendars are value-semantic objects, and, as such, necessarily support all
// of the standard value-semantic operations, such as default construction,
// copy construction and copy assignment, equality comparison, and
// externalization (BDEX streaming, in particular).  Calendars also support
// the notions of both union and intersection merging operations, whereby a
// calendar can change its value to contain the union or intersection of its
// own contained weekend days, holidays, and holiday codes with those of
// another calendar object.  Such merging operations will, in general, also
// alter the valid range of the resulting calendar.  Note that merged
// calendars can be significantly more efficient for certain repeated
// &quot;is-common-business-day&quot; determinations among two or more calendars.
//
///Weekend Days and Weekend-Days Transitions
///-----------------------------------------
// A calendar maintains a set of dates considered to be weekend days.
// Typically, a calendar&#39;s weekend days fall on the same days of the week for
// the entire range of a calendar.  For example, the weekend for United States
// has consisted of Saturday and Sunday since the year 1940.  The
// &#39;addWeekendDay&#39; and &#39;addWeekendDays&#39; methods can be used to specify the
// weekend days for these calendars.
//
// However, sometimes a calendar&#39;s weekend days changes over time.  For
// example, Bangladesh&#39;s weekend consisted of Friday until June 1, 1997 when
// Bangladesh changed its weekends to contain both Friday and Saturday.  Later,
// on October 1, 2001, Bangladesh reverted to a weekend of only Friday, until
// on September 9, 2009, Bangladesh again changed its weekends to include both
// Friday and Saturday.
//
// To optimize for space allocation while supporting both consistent and
// changing weekend days, a calendar represents weekend information using a
// sequence of &quot;weekend-days transitions&quot;, each of which comprises a date and a
// set of days of the week considered to be the weekend on and after that
// date.  To represent the weekend days of Bangladesh, a calendar can use a
// sequence of four weekend-days transitions: (1) a transition on January 1,
// 0001 having a weekend day set containing only Friday, (2) a transition at
// June 1, 1997 having a weekend day set containing Friday and Saturday, (3) a
// transition at October 1, 2001 having a weekend day set containing only
// Friday, and (4) a transition at September 9, 2009 having a weekend day set
// containing Friday and Saturday.  To represent the weekend days of the United
// States, a calendar having a range after 1940 can use a single weekend-days
// transition on January 1, 0001 containing Saturday and Sunday.
//
// On construction, a calendar does not contain any weekend-days transitions.
// The &#39;addWeekendDaysTransition&#39; method adds a new weekend-days transition or
// replaces an existing weekend-days transition.  The &#39;addWeekendDay&#39; and
// &#39;addWeekendDays&#39; methods create a weekend-days transition at January 1,
// 0001, if one doesn&#39;t already exist, and update the set of weekend days for
// that transition.  &#39;addWeekendDay&#39; and &#39;addWeekendDays&#39; should only be used
// for calendars having a consistent set of weekend days throughout their
// entire range.  The use of &#39;addWeekendDay&#39; and &#39;addWeekendDays&#39; is intended
// to be *mutually* *exclusive* to the use of &#39;addWeekendDaysTransition&#39;.  As
// such, the behavior of using these two methods together with
// &#39;addWeekendDaysTransition&#39; is undefined.
//
///Nested Iterators
///----------------
// Also provided are several STL-style &#39;const&#39; bidirectional iterators
// accessible as nested &#39;typedef&#39;s.  &#39;HolidayConstIterator&#39;,
// &#39;HolidayCodeConstIterator&#39;, &#39;WeekendDaysTransitionConstIterator&#39;, and
// &#39;BusinessDayConstIterator&#39;, respectively, iterate over a chronologically
// ordered sequence of holidays, a numerically ordered sequence of holiday
// codes, a sequence of chronologically ordered weekend-days transitions, and a
// sequence of chronologically ordered business days.  Reverse iterators are
// also provided for each of these (forward) iterators.  As a general rule,
// calling a &#39;const&#39; method will not invalidate any iterators, and calling a
// non-&#39;const&#39; method might invalidate all of them; it is, however, guaranteed
// that attempting to add *duplicate* holidays or holiday codes will have no
// effect, and therefore will not invalidate any iterators.  It is also
// guaranteed that adding a new code for an existing holiday will not
// invalidate any &#39;HolidayConstIterator&#39; objects.
//
// Note that these iterators do *not* meet the requirements for a
// &#39;bsl::forward_iterator&#39; and should not be used in standard algorithms (e.g.,
// &#39;bsl::lower_bound&#39;).
//
///Iterator Invalidation
///---------------------
// The modification of a &#39;bdlt::Calendar&#39; will invalidate iterators referring
// to the calendar.  The following table shows the relationship between a
// calendar manipulator and the types of iterators it will invalidate if the
// invocation of the manipulator modified the calendar (e.g., using
// &#39;addHoliday&#39; with a date that is not currently a holiday in the calendar):
//..
//          Manipulator                         Invalidates
//    --------------------------            --------------------
//    &#39;operator=&#39;                           H    HC    WDT    BD
//    &#39;addHoliday&#39;                          H    HC           BD
//    &#39;addHolidayCode&#39;                           HC
//    &#39;addHolidayCodeIfInRange&#39;                  HC
//    &#39;addHolidayIfInRange&#39;                 H    HC           BD
//    &#39;addWeekendDay&#39;                                  WDT    BD
//    &#39;addWeekendDays&#39;                                 WDT    BD
//    &#39;addWeekendDaysTransition&#39;                       WDT    BD
//    &#39;intersectBusinessDays&#39;               H    HC    WDT    BD
//    &#39;intersectNonBusinessDays&#39;            H    HC    WDT    BD
//    &#39;removeAll&#39;                           H    HC    WDT    BD
//    &#39;removeHoliday&#39;                       H    HC           BD
//    &#39;removeHolidayCode&#39;                        HC
//    &#39;setValidRange&#39;                       H    HC           BD
//    &#39;unionBusinessDays&#39;                   H    HC    WDT    BD
//    &#39;unionNonBusinessDays&#39;                H    HC    WDT    BD
//
// where &quot;H&quot; represents the holiday iterators (&#39;HolidayConstIterator&#39; and
// &#39;HolidayConstReverseIterator&#39;), &quot;HC&quot; represents the holiday code iterators
// (&#39;HolidayCodeConstIterator&#39; and &#39;HolidayCodeConstReverseIterator&#39;), &quot;WDT&quot;
// represents the weekend-days transition iterators
// (&#39;WeekendDaysTransitionConstIterator&#39; and
// &#39;WeekendDaysTransitionConstReverseIterator&#39;), and &quot;BD&quot; represents the
// business day iterators (&#39;BusinessDayConstIterator&#39; and
// &#39;BusinessDayConstReverseIterator&#39;).
//..
//
///Performance and Exception-Safety Guarantees
///-------------------------------------------
// &#39;bdlt::Calendar&#39; supports &#39;O[1]&#39; (i.e., constant-time) determination of
// whether a given &#39;bdlt::Date&#39; value is or is not a business day, which is
// accomplished by augmenting the implementation of a packed calendar with a
// supplementary cache.  The invariant that this cache and the data represented
// in the underlying &#39;bdlt::PackedCalendar&#39; be maintained in a consistent
// state may add significantly to the cost of performing many manipulator
// operations, especially those that affect the calendar&#39;s valid range and add
// a new weekend-days transition.  Moreover, the cost of many of these
// operations will now be proportional to the length(s) of the valid range(s),
// as well as their respective numbers of holidays and associated holiday codes
// and weekend-days transitions.  Hence, when populating a calendar, it is
// recommended that the desired value be captured first as a
// &#39;bdlt::PackedCalendar&#39;, which can then be used efficiently to
// *value-construct* the desired &#39;bdlt::Calendar&#39; object.  See the
// component-level doc for &#39;bdlt_packedcalendar&#39; for its performance
// guarantees.
//
// All methods of the &#39;bdlt::Calendar&#39; are exception-safe, but in general
// provide only the basic guarantee (i.e., no guarantee of rollback): If an
// exception occurs (i.e., while attempting to allocate memory), the calendar
// object is left in a coherent state, but (unless otherwise specified) its
// *value* is undefined.
//
///Usage
///-----
// The two subsections below illustrate various aspects of populating and using
// calendars.
//
///Example 1: Populating Calendars
///- - - - - - - - - - - - - - - -
// &#39;bdlt::Calendars&#39; can be populated directly, but are often more efficiently
// created by first creating a corresponding &#39;bdlt::PackedCalendar&#39;, and then
// using that object to construct the calendar.  As an example, suppose we
// want to provide efficient access to a (high-performance) &#39;bdlt::Calendar&#39;
// for a variety of locales, whose raw information comes from, say, a database.
// The latency associated with fetching data for individual calendars on
// demand from a typical database can be prohibitively expensive, so it may
// make sense to acquire data for all calendars in a single query at start-up.
//
// First, we declare a &#39;MyPackedCalendarCache&#39; that, internally, is just a
// mapping from (typically short) character string names (such as &quot;NYB&quot;,
// representing New York Bank settlement days) to &#39;bdlt::PackedCalendar&#39;
// objects, containing densely packed calendar data:
//..
//  class MyPackedCalendarCache {
//      // This class maintains a space-efficient repository of calendar data
//      // associated with a (typically short) name.
//
//      // DATA
//      bsl::unordered_map&lt;bsl::string, bdlt::PackedCalendar&gt;  d_map;
//
//    public:
//      // CREATORS
//      MyPackedCalendarCache(bslma::Allocator *basicAllocator = 0);
//          // Create an empty &#39;MyPackedCalendarCache&#39;.  Optionally specify a
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//          // 0, the currently installed default allocator is used.
//
//      // MANIPULATORS
//      void assign(const bsl::string&amp;          name,
//                  const bdlt::PackedCalendar&amp; calendar);
//          // Associate the value of the specified &#39;calendar&#39; with the
//          // specified &#39;name&#39;.
//
//      // ACCESSORS
//      const bdlt::PackedCalendar *lookup(const bsl::string&amp; name) const;
//          // Return the address of calendar data associated with the
//          // specified &#39;name&#39;, or 0 if no such association exists.
//  };
//
//  // CREATORS
//  MyPackedCalendarCache::MyPackedCalendarCache(
//                                            bslma::Allocator *basicAllocator)
//  : d_map(basicAllocator)
//  {
//  }
//
//  // MANIPULATORS
//  void MyPackedCalendarCache::assign(const bsl::string&amp;          name,
//                                     const bdlt::PackedCalendar&amp; calendar)
//  {
//      d_map[name] = calendar;
//  }
//
//  // ACCESSORS
//  const bdlt::PackedCalendar *MyPackedCalendarCache::lookup(
//                                               const bsl::string&amp; name) const
//  {
//      typedef bsl::unordered_map&lt;bsl::string, bdlt::PackedCalendar&gt; Cache;
//      Cache::const_iterator iter = d_map.find(name);
//
//      if (iter == d_map.end()) {
//          return 0;                                                 // RETURN
//      }
//      return &amp;iter-&gt;second;
//  }
//..
// Then, we define an application function, &#39;loadMyPackedCalendarCache&#39;, that
// takes the address of a &#39;MyPackedCalendarCache&#39; and populates it with
// up-to-date calendar data for all known locales (which, in the future, will
// be from a well-known database location):
//..
//  int loadMyPackedCalendarCache(MyPackedCalendarCache *result)
//      // Load, into the specified &#39;result&#39;, up-to-date calendar information
//      // for every known locale.  Return 0 on success, and a non-zero value
//      // otherwise.
//  {
//      bdlt::PackedCalendar calendar;
//      calendar.setValidRange(bdlt::Date(2000,  1,  1),
//                             bdlt::Date(2020, 12, 31));
//      result-&gt;assign(&quot;NYB&quot;, calendar);
//      return 0;
//  }
//..
// We can imagine that there might be dozens, even hundreds of different
// locales, and that most applications will not need efficient access to
// calendar data from many, let alone every locale; however, many long-running
// applications may well need to obtain efficient access to the same calendar
// data repeatedly.
//
// Next, we create a second-level of cache, &#39;MyCalendarCache&#39;, that maintains
// a repository of the more runtime-efficient, but also more space-intensive,
// &#39;bdlt::Calendar&#39; objects, which are instantiated on demand from a
// packed-calendar-based data source:
//..
//  class MyCalendarCache {
//      // This class maintains a cache of runtime-efficient calendar objects
//      // created on demand from a compact packed-calendar-based data source,
//      // whose address is supplied at construction.
//
//      // DATA
//      MyPackedCalendarCache                           *d_datasource_p;
//      bsl::unordered_map&lt;bsl::string, bdlt::Calendar&gt;  d_map;
//
//    public:
//      // CREATORS
//      MyCalendarCache(MyPackedCalendarCache *dataSource,
//                      bslma::Allocator      *basicAllocator = 0);
//          // Create an empty &#39;MyCalendarCache&#39; associated with the specified
//          // &#39;dataSource&#39;.  Optionally specify a &#39;basicAllocator&#39; used to
//          // supply memory.  If &#39;basicAllocator&#39; is 0, the currently
//          // installed default allocator is used.
//
//      // MANIPULATORS
//      const bdlt::Calendar *lookup(const bsl::string&amp; name);
//          // Return the address of calendar data associated with the
//          // specified &#39;name&#39;, or 0 if no such association exists in the data
//          // source whose address was supplied at construction.  Note that
//          // this method may alter the physical state of this object (and is
//          // therefore deliberately declared non-&#39;const&#39;).
//  };
//
//  MyCalendarCache::MyCalendarCache(MyPackedCalendarCache *dataSource,
//                                   bslma::Allocator      *basicAllocator)
//  : d_datasource_p(dataSource)
//  , d_map(basicAllocator)
//  {
//  }
//
//  const bdlt::Calendar *MyCalendarCache::lookup(const bsl::string&amp; name)
//  {
//      typedef bsl::unordered_map&lt;bsl::string, bdlt::Calendar&gt; Cache;
//      Cache::const_iterator iter = d_map.find(name);
//      if (iter == d_map.end()) {
//          const bdlt::PackedCalendar *pc = d_datasource_p-&gt;lookup(name);
//          if (!pc) {
//
//              // No such name in the data source.
//
//              return 0;                                             // RETURN
//          }
//
//          // Create new entry in calendar cache.
//
//          iter = d_map.insert(bsl::make_pair(name, *pc)).first;
//      }
//
//      // An efficient calendar either already existed or was created.
//
//      return &amp;iter-&gt;second;
//   }
//..
// Now, we can create and populate the cache:
//..
//  MyPackedCalendarCache packedCalendarCache;
//  MyCalendarCache       calendarCache(&amp;packedCalendarCache);
//
//  loadMyPackedCalendarCache(&amp;packedCalendarCache);
//..
// Finally, we request the &quot;NYB&quot; calendar and verify the returned value:
//..
//  const bdlt::Calendar *calendarPtr = calendarCache.lookup(&quot;NYB&quot;);
//
//  assert(calendarPtr-&gt;firstDate() == bdlt::Date(2000,  1,  1));
//  assert(calendarPtr-&gt;lastDate()  == bdlt::Date(2020, 12, 31));
//..
//
///Example 2: Using Calendars
/// - - - - - - - - - - - - -
// What makes a &#39;bdlt::Calendar&#39; substantially different from a
// &#39;bdlt::PackedCalendar&#39; is the speed with which the &#39;bdlt::Calendar&#39; can
// report whether a given date is or is not a business day.  An important use
// of high-performance calendar objects in financial applications is to quickly
// determine the settlement date of a financial instrument.  In some
// applications (e.g., those that explore the cross product of various
// portfolios over several horizons and scenarios), the settlement date may
// need to be calculated literally billions of times.  The settlement date
// will often be determined from a periodic target date, such as the 15th or
// 30th of the month, which is then perturbed in some way to arrive at a valid
// settlement date.
//
// One very common algorithm a security may prescribe for finding a valid
// settlement date is known as *modified* *following*: Given a target day, the
// settlement date for that month is defined as the first valid business day
// at or after the given target day in the same month; if no such date exists,
// then the settlement date is the closest valid business day before the target
// day in that month.
//
// First, we create a &#39;struct&#39;, &#39;MyCalendarUtil&#39;, that provides the
// &#39;modifiedFollowing&#39; method:
//..
//  struct MyCalendarUtil {
//
//      // CLASS METHODS
//      static bdlt::Date modifiedFollowing(int                   targetDay,
//                                          int                   month,
//                                          int                   year,
//                                          const bdlt::Calendar&amp; calendar)
//          // Return the date of the first business day at or after the
//          // specified &#39;targetDay&#39; in the specified &#39;month&#39; and &#39;year&#39;
//          // according to the specified &#39;calendar&#39;, unless the resulting
//          // date would not fall within &#39;month&#39;, in which case return
//          // instead the date of the first business day before &#39;targetDay&#39;
//          // in &#39;month&#39;.  The behavior is undefined unless all candidate
//          // dates applied to &#39;calendar&#39; are within its valid range and
//          // there exists at least one business day within &#39;month&#39;.
//      {
//          BSLS_ASSERT(bdlt::Date::isValidYearMonthDay(year,
//                                                      month,
//                                                      targetDay));
//
//          // Efficiency is important so we will minimize the number of
//          // conversions between year/month/day and &#39;bdlt::Date&#39; objects.
//
//          bdlt::Date date(year, month, targetDay);
//
//          if (0 == calendar.getNextBusinessDay(&amp;date, date - 1)
//           &amp;&amp; month == date.month()) {
//              return date;                                          // RETURN
//          }
//          while (calendar.isNonBusinessDay(--date)) {
//              // empty
//          }
//          return date;
//      }
//  };
//..
// Then, we create and populate two calendars, &#39;cal1&#39; and &#39;cal2&#39;, for testing
// the &#39;modifiedFollowing&#39; method:
//..
//  bdlt::Calendar cal1(bdlt::Date(2015, 1, 1), bdlt::Date(2015,12, 31));
//  cal1.addWeekendDay(bdlt::DayOfWeek::e_SUN);
//  cal1.addWeekendDay(bdlt::DayOfWeek::e_SAT);
//  cal1.addHoliday(bdlt::Date(2015, 7, 3));
//
//  bdlt::Calendar cal2(cal1);
//  cal2.addHoliday(bdlt::Date(2015, 7, 31));
//..
// Finally, we verify the &#39;modifiedFollowing&#39; functionality:
//..
//  assert(bdlt::Date(2015, 7,  2) ==
//                       MyCalendarUtil::modifiedFollowing( 2, 7, 2015, cal1));
//  assert(bdlt::Date(2015, 7,  6) ==
//                       MyCalendarUtil::modifiedFollowing( 3, 7, 2015, cal1));
//  assert(bdlt::Date(2015, 7, 31) ==
//                       MyCalendarUtil::modifiedFollowing(31, 7, 2015, cal1));
//
//  assert(bdlt::Date(2015, 7,  2) ==
//                       MyCalendarUtil::modifiedFollowing( 2, 7, 2015, cal2));
//  assert(bdlt::Date(2015, 7,  6) ==
//                       MyCalendarUtil::modifiedFollowing( 3, 7, 2015, cal2));
//  assert(bdlt::Date(2015, 7, 30) ==
//                       MyCalendarUtil::modifiedFollowing(31, 7, 2015, cal2));
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLC_BITARRAY
#include &lt;bdlc_bitarray.h&gt;
#endif

#ifndef INCLUDED_BDLT_CALENDARREVERSEITERATORADAPTER
#include &lt;bdlt_calendarreverseiteratoradapter.h&gt;
#endif

#ifndef INCLUDED_BDLT_DATE
#include &lt;bdlt_date.h&gt;
#endif

#ifndef INCLUDED_BDLT_DAYOFWEEK
#include &lt;bdlt_dayofweek.h&gt;
#endif

#ifndef INCLUDED_BDLT_DAYOFWEEKSET
#include &lt;bdlt_dayofweekset.h&gt;
#endif

#ifndef INCLUDED_BDLT_PACKEDCALENDAR
#include &lt;bdlt_packedcalendar.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SWAPUTIL
#include &lt;bslalg_swaputil.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include &lt;bslalg_typetraits.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITUSESBSLMAALLOCATOR
#include &lt;bslalg_typetraitusesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_INTEGRALCONSTANT
#include &lt;bslmf_integralconstant.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSL_ITERATOR
#include &lt;bsl_iterator.h&gt;
#endif

namespace BloombergLP {
namespace bdlt {

class Calendar_BusinessDayConstIter;

                             // ==============
                             // class Calendar
                             // ==============

class Calendar {
    // This class implements a runtime-efficient, value-semantic repository of
    // weekend and holiday information over a *valid* *range* of dates.  This
    // valid range, &#39;[firstDate() .. lastDate()]&#39;, spans the first and last
    // dates of a calendar&#39;s accessible contents.  A calendar can be
    // &quot;populated&quot; with weekend and holiday information via a suite of &quot;add&quot;
    // methods.  Any subset of days of the week may be specified as weekend
    // (i.e., recurring non-business) days starting from a specified date by
    // adding a weekend-days transition; holidays within the valid range are
    // specified individually.  When adding a holiday, an arbitrary integer
    // &quot;holiday code&quot; may be associated with that date.  Additional holiday
    // codes for that date may subsequently be added.  Both the holidays and
    // the set of unique holiday codes associated with each holiday date are
    // maintained (internally) in order of increasing value.  Note that the
    // behavior of requesting *any* calendar information for a supplied date
    // whose value is outside the current *valid* *range* for that calendar
    // (unless otherwise noted, e.g., &#39;isWeekendDay&#39;) is undefined.

    // DATA
    PackedCalendar    d_packedCalendar;
                               // the packed calendar object, which contains
                               // the weekend day and holiday information

    bdlc::BitArray    d_nonBusinessDays;
                               // cache of non-business days; note that the end
                               // of the valid range is defined by
                               // &#39;d_packedCalendar.firstDate() + length() - 1&#39;

    // FRIENDS
    friend bool operator==(const Calendar&amp;, const Calendar&amp;);
    friend bool operator!=(const Calendar&amp;, const Calendar&amp;);

  private:
    // PRIVATE MANIPULATORS
    void synchronizeCache();
        // Synchronize this calendar&#39;s cache by first clearing the cache, then
        // repopulating it with the holiday and weekend information from this
        // calendar&#39;s &#39;d_packedCalendar&#39;.  Note that this method is only
        // *exception*-*neutral*; exception safety and rollback must be
        // handled by the caller.

    // PRIVATE ACCESSORS
    bool isCacheSynchronized() const;
        // Return &#39;true&#39; if this calendar&#39;s cache correctly represents the
        // holiday and weekend information stored in this calendar&#39;s
        // &#39;d_packedCalendar&#39;, and &#39;false&#39; otherwise.

  public:
    // TYPES
    typedef Calendar_BusinessDayConstIter            BusinessDayConstIterator;

    typedef PackedCalendar::HolidayConstIterator     HolidayConstIterator;

    typedef PackedCalendar::HolidayCodeConstIterator HolidayCodeConstIterator;

    typedef CalendarReverseIteratorAdapter&lt;BusinessDayConstIterator&gt;
                                               BusinessDayConstReverseIterator;

    typedef PackedCalendar::HolidayConstReverseIterator
                                                   HolidayConstReverseIterator;

    typedef PackedCalendar::HolidayCodeConstReverseIterator
                                               HolidayCodeConstReverseIterator;

    typedef PackedCalendar::WeekendDaysTransition WeekendDaysTransition;

    typedef PackedCalendar::WeekendDaysTransitionConstIterator
                                            WeekendDaysTransitionConstIterator;

    typedef PackedCalendar::WeekendDaysTransitionConstReverseIterator
                                     WeekendDaysTransitionConstReverseIterator;

    // CLASS METHODS

                                  // Aspects

    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that it is highly recommended that &#39;versionSelector&#39;
        // be formatted as &quot;YYYYMMDD&quot;, a date representation.  Also note that
        // &#39;versionSelector&#39; should be a *compile*-time-chosen value that
        // selects a format version supported by both externalizer and
        // unexternalizer.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    // CREATORS
    explicit Calendar(bslma::Allocator *basicAllocator = 0);
        // Create an empty calendar, i.e., a calendar having an empty valid
        // range.  Optionally specify a &#39;basicAllocator&#39; used to supply memory.
        // If &#39;basicAllocator&#39; is 0, the currently installed default allocator
        // is used.

    Calendar(const Date&amp;       firstDate,
             const Date&amp;       lastDate,
             bslma::Allocator *basicAllocator = 0);
        // Create a calendar having a valid range from the specified
        // &#39;firstDate&#39; through the specified &#39;lastDate&#39;.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.  The behavior is
        // undefined unless &#39;firstDate &lt;= lastDate&#39;.

    explicit Calendar(const bdlt::PackedCalendar&amp;  packedCalendar,
                      bslma::Allocator            *basicAllocator = 0);
        // Create a calendar having the same value as the specified
        // &#39;packedCalendar&#39;.  Optionally specify a &#39;basicAllocator&#39; used to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    Calendar(const Calendar&amp; original, bslma::Allocator *basicAllocator = 0);
        // Create a calendar having the value of the specified &#39;original&#39;
        // calendar.  Optionally specify a &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.

    ~Calendar();
        // Destroy this object.

    // MANIPULATORS
    Calendar&amp; operator=(const Calendar&amp;       rhs);
    Calendar&amp; operator=(const PackedCalendar&amp; rhs);
        // Assign to this calendar the value of the specified &#39;rhs&#39; calendar,
        // and return a reference providing modifiable access to this calendar.
        // See {Iterator Invalidation} for information regarding which
        // iterators are affected by the use of these methods.

    void addDay(const Date&amp; date);
        // Extend the valid range (if necessary) of this calendar to include
        // the specified &#39;date&#39; value.

    void addHoliday(const Date&amp; date);
        // Mark the specified &#39;date&#39; as a holiday (i.e., a non-business day)
        // in this calendar.  Extend the valid range of this calendar if
        // necessary.  If &#39;date&#39; is already marked as a holiday, this method
        // has no effect.  See {Iterator Invalidation} for information
        // regarding which iterators are affected by the use of this method.

    void addHolidayCode(const Date&amp; date, int holidayCode);
        // Mark the specified &#39;date&#39; as a holiday (i.e., a non-business day) in
        // this calendar and add the specified &#39;holidayCode&#39; (if not already
        // present) to the ordered set of codes associated with &#39;date&#39;.
        // Extend the valid range of this calendar if necessary.  If
        // &#39;holidayCode&#39; is already a code for &#39;date&#39;, this method has no
        // effect.  See {Iterator Invalidation} for information regarding
        // which iterators are affected by the use of this method.  Note that
        // this method may be called repeatedly with the same value for &#39;date&#39;
        // to build up a set of holiday codes for that date.

    int addHolidayCodeIfInRange(const Date&amp; date, int holidayCode);
        // Mark the specified &#39;date&#39; as a holiday (i.e., a non-business day)
        // in this calendar and add the specified &#39;holidayCode&#39; (if not
        // already present) to the set of codes associated with &#39;date&#39;, if
        // &#39;date&#39; is within the valid range of this calendar.  Return 0 if
        // &#39;date&#39; is in range, and a non-zero value otherwise.  If
        // &#39;holidayCode&#39; is already a code for &#39;date&#39;, or if &#39;date&#39; is not in
        // the valid range, this method has no effect.  See
        // {Iterator Invalidation} for information regarding which iterators
        // are affected by the use of this method.  Note that this method may,
        // at the expense of verifying &#39;isInRange(date)&#39; for each invocation,
        // be called repeatedly with the same value for &#39;date&#39; to build up a
        // set of holiday codes for that date.

    int addHolidayIfInRange(const Date&amp; date);
        // Mark the specified &#39;date&#39; as a holiday (i.e., a non-business day) in
        // this calendar if &#39;date&#39; is within the valid range.  Return 0 if
        // &#39;date&#39; is in range, and a non-zero value otherwise.  This method has
        // no effect if &#39;date&#39; is already marked as a holiday or is not in the
        // valid range.  See {Iterator Invalidation} for information regarding
        // which iterators are affected by the use of this method.

    void addWeekendDay(DayOfWeek::Enum weekendDay);
        // Add the specified &#39;weekendDay&#39; to the set of weekend days associated
        // with the weekend-days transition at January 1, 0001 maintained by
        // this calendar.  Create a transition at January 1, 0001 if one does
        // not exist.  See {Iterator Invalidation} for information regarding
        // which iterators are affected by the use of this method.  The
        // behavior is undefined unless no weekend-days transitions were added
        // to this calendar via the &#39;addWeekendDaysTransition&#39; method.

    void addWeekendDays(const DayOfWeekSet&amp; weekendDays);
        // Add the specified &#39;weekendDays&#39; to the set of weekend days
        // associated with the weekend-days transition at January 1, 0001
        // maintained by this calendar.  Create a transition at January 1, 0001
        // if one does not exist.  See {Iterator Invalidation} for information
        // regarding which iterators are affected by the use of this method.
        // The behavior is undefined unless no weekend-days transitions were
        // added to this calendar via the &#39;addWeekendDaysTransition&#39; method.

    void addWeekendDaysTransition(const Date&amp;         startDate,
                                  const DayOfWeekSet&amp; weekendDays);
        // Add to this calendar a weekend-days transition on the specified
        // &#39;startDate&#39; having the specified &#39;weekendDays&#39; set.  If a
        // weekend-days transition already exists on &#39;startDate&#39;, replace the
        // set of weekend days of that transition with &#39;weekendDays&#39;.  See
        // {Iterator Invalidation} for information regarding which iterators
        // are affected by the use of this method.  Note that this method does
        // not extend the valid range of the calendar.

    void intersectBusinessDays(const Calendar&amp;       other);
    void intersectBusinessDays(const PackedCalendar&amp; other);
        // Merge the specified &#39;other&#39; calendar into this calendar such that
        // the valid range of this calendar becomes the *intersection* of the
        // two calendars&#39; ranges, and the weekend days and holidays for this
        // calendar become the union of those (non-business) days from the two
        // calendars -- i.e., the valid business days of this calendar become
        // the intersection of those of the two original calendar values, over
        // the *intersection* of their ranges.  For each holiday that remains,
        // the resulting holiday codes in this calendar will be the union of
        // the corresponding original holiday codes.  See
        // {Iterator Invalidation} for information regarding which iterators
        // are affected by the use of this method.

    void intersectNonBusinessDays(const Calendar&amp;       other);
    void intersectNonBusinessDays(const PackedCalendar&amp; other);
        // Merge the specified &#39;other&#39; calendar into this calendar such that
        // the valid range of this calendar becomes the *intersection* of the
        // two calendars&#39; ranges, and the weekend days and holidays for this
        // calendar become the intersection of those (non-business) days from
        // the two calendars -- i.e., the valid business days of this calendar
        // become the union of those of the two original calendars, over the
        // *intersection* of their ranges.  For each holiday that remains, the
        // resulting holiday codes in this calendar will be the union of the
        // corresponding original holiday codes.  See {Iterator Invalidation}
        // for information regarding which iterators are affected by the use of
        // this method.

    void removeAll();
        // Remove all information from this calendar, leaving it with its
        // default constructed &quot;empty&quot; value.  See {Iterator Invalidation} for
        // information regarding which iterators are affected by the use of
        // this method.

    void removeHoliday(const Date&amp; date);
        // Remove from this calendar the holiday having the specified &#39;date&#39; if
        // such a holiday exists.  This operation has no effect if &#39;date&#39; is
        // not a holiday in this calendar.  See {Iterator Invalidation} for
        // information regarding which iterators are affected by the use of
        // this method.  Note that this method is defined for all &#39;date&#39;
        // values, not just those that fall within the valid range, and may be
        // invoked even on an empty calendar (i.e., having &#39;0 == length()&#39;).

    void removeHolidayCode(const Date&amp; date, int holidayCode);
        // Remove from this calendar the specified &#39;holidayCode&#39; for the
        // holiday having the specified &#39;date&#39; if such a holiday having
        // &#39;holidayCode&#39; exists.  This operation has no effect if &#39;date&#39; is not
        // a holiday in this calendar, or if the holiday at &#39;date&#39; does not
        // have &#39;holidayCode&#39; associated with it.  See {Iterator Invalidation}
        // for information regarding which iterators are affected by the use of
        // this method.  Note that this method is defined for all &#39;date&#39;
        // values, not just those that fall within the valid range, and may be
        // invoked even on an empty calendar (i.e., having &#39;0 == length()&#39;).

    void reserveHolidayCapacity(int numHolidays);
        // Reserve enough space to store at least the specified &#39;numHolidays&#39;
        // within this calendar.  This method has no effect if
        // &#39;numHolidays &lt;= numHolidays()&#39;.

    void reserveHolidayCodeCapacity(int numHolidayCodes);
        // Reserve enough space to store at least the specified
        // &#39;numHolidayCodes&#39; within this calendar assuming no additional
        // holidays are added to this calendar.  This method has no effect if
        // &#39;numHolidayCodes &lt;= numHolidayCodesTotal()&#39;.

    void setValidRange(const Date&amp; firstDate, const Date&amp; lastDate);
        // Set the range of this calendar using the specified &#39;firstDate&#39; and
        // &#39;lastDate&#39; as, respectively, the first date and the last date of the
        // calendar.  Any holiday that is outside the new range and its holiday
        // codes are removed.  See {Iterator Invalidation} for information
        // regarding which iterators are affected by the use of this method.
        // The behavior is undefined unless &#39;firstDate &lt;= lastDate&#39;.

    void unionBusinessDays(const Calendar&amp;       other);
    void unionBusinessDays(const PackedCalendar&amp; other);
        // Merge the specified &#39;other&#39; calendar into this calendar such that
        // the valid range of this calendar becomes the *union* of the two
        // calendars&#39; ranges (or the minimal continuous range spanning the two
        // ranges, if the ranges are non-overlapping), and the weekend days
        // and holidays for this calendar become the intersection of those
        // (non-business) days from the two calendars -- i.e., the valid
        // business days of this calendar become the union of those of the two
        // original calendar values.  For each holiday that remains, the
        // resulting holiday codes in this calendar will be the union of the
        // corresponding original holiday codes.  See {Iterator Invalidation}
        // for information regarding which iterators are affected by the use of
        // this method.

    void unionNonBusinessDays(const Calendar&amp;       other);
    void unionNonBusinessDays(const PackedCalendar&amp; other);
        // Merge the specified &#39;other&#39; calendar into this calendar such that
        // the valid range of this calendar becomes the *union* of the two
        // calendars&#39; ranges (or the minimal continuous range spanning the two
        // ranges, if the ranges are non-overlapping), and the weekend days
        // and holidays for this calendar become the union of those
        // (non-business) days from the two calendars -- i.e., the valid
        // business days of this calendar become the intersection of those of
        // the two calendars after each range is extended to cover the
        // resulting one.  For each holiday in either calendar, the resulting
        // holiday codes in this calendar will be the union of the
        // corresponding original holiday codes.  See {Iterator Invalidation}
        // for information regarding which iterators are affected by the use of
        // this method.

                                  // Aspects

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format and return a reference
        // to the modifiable &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;stream&#39; becomes invalid during this
        // operation or if &#39;version&#39; is not supported, this object is
        // unaltered.  Note that no version is read from &#39;stream&#39;.  See the
        // &#39;bdex&#39; package-level documentation for more information on &#39;bdex&#39;
        // streaming of value-semantic types and containers.

    void swap(Calendar&amp; other);
        // Efficiently exchange the value of this object with the value of the
        // specified &#39;other&#39; object.  This method provides the no-throw
        // exception-safety guarantee.  The behavior is undefined unless this
        // object was created with the same allocator as &#39;other&#39;.

    // ACCESSORS
    BusinessDayConstIterator beginBusinessDays() const;
        // Return an iterator providing non-modifiable access to the first
        // business day in this calendar.  If this calendar has no valid
        // business days, the returned iterator has the same value as that
        // returned by &#39;endBusinessDays()&#39;.

    BusinessDayConstIterator beginBusinessDays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // business day that occurs on or after the specified &#39;date&#39; in this
        // calendar.  If this calendar has no such business day, the returned
        // iterator has the same value as that returned by
        // &#39;endBusinessDays(date)&#39;.  The behavior is undefined unless &#39;date&#39; is
        // within the valid range of this calendar.

    HolidayCodeConstIterator beginHolidayCodes(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // holiday code for the specified &#39;date&#39; in this calendar.  If there is
        // no holiday code associated with &#39;date&#39;, the returned iterator has
        // the same value as that returned by &#39;endHolidayCodes(date)&#39;.  The
        // behavior is undefined unless &#39;date&#39; is marked as a holiday in this
        // calendar.

    HolidayCodeConstIterator beginHolidayCodes(
                                       const HolidayConstIterator&amp; iter) const;
        // Return an iterator providing non-modifiable access to the first
        // holiday code for the holiday referenced by the specified &#39;iter&#39;.  If
        // there is no holiday code associated with the date referenced by
        // &#39;iter&#39;, the returned iterator has the same value as that returned by
        // &#39;endHolidayCodes(iter)&#39;.  The behavior is undefined unless &#39;iter&#39;
        // refers to a valid holiday of this calendar.

    HolidayConstIterator beginHolidays() const;
        // Return an iterator providing non-modifiable access to the first
        // holiday in this calendar.  If this calendar has no holidays, the
        // returned iterator has the same value as that returned by
        // &#39;endHolidays()&#39;.

    HolidayConstIterator beginHolidays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // holiday that occurs on or after the specified &#39;date&#39; in this
        // calendar.  If this calendar has no such holiday, the returned
        // iterator has the same value as that returned by &#39;endHolidays(date)&#39;.
        // The behavior is undefined unless &#39;date&#39; is within the valid range
        // of this calendar.

    WeekendDaysTransitionConstIterator beginWeekendDaysTransitions() const;
        // Return an iterator providing non-modifiable access to the first
        // weekend-days transition in the chronological sequence of
        // weekend-days transitions maintained by this calendar.  If this
        // calendar has no weekend-days transitions, the returned iterator has
        // the same value as that returned by &#39;endWeekendDaysTransitions()&#39;.

    BusinessDayConstIterator endBusinessDays() const;
        // Return an iterator providing non-modifiable access to the
        // past-the-end business day in this calendar.

    BusinessDayConstIterator endBusinessDays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // business day that occurs after the specified &#39;date&#39; in this
        // calendar.  If this calendar has no such business day, the returned
        // iterator has the same value as that returned by
        // &#39;endBusinessDays()&#39;.  The behavior is undefined unless &#39;date&#39; is
        // within the valid range of this calendar.

    HolidayCodeConstIterator endHolidayCodes(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the
        // past-the-end holiday code associated with the specified &#39;date&#39;.  The
        // behavior is undefined unless &#39;date&#39; is marked as a holiday in this
        // calendar.

    HolidayCodeConstIterator
                       endHolidayCodes(const HolidayConstIterator&amp; iter) const;
        // Return an iterator providing non-modifiable access to the
        // past-the-end holiday code associated with the date referenced by
        // the specified &#39;iter&#39;.  The behavior is undefined unless &#39;iter&#39;
        // references a valid holiday in this calendar.

    HolidayConstIterator endHolidays() const;
        // Return an iterator providing non-modifiable access to the
        // past-the-end holiday in the chronological sequence of holidays
        // maintained by this calendar.

    HolidayConstIterator endHolidays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // holiday that occurs after the specified &#39;date&#39; in this calendar.
        // If this calendar has no such holiday, the returned iterator has the
        // same value as that returned by &#39;endHolidays()&#39;.  The behavior is
        // undefined unless &#39;date&#39; is within the valid range of this calendar.

    WeekendDaysTransitionConstIterator endWeekendDaysTransitions() const;
        // Return an iterator providing non-modifiable access to the
        // past-the-end weekend-days transition in the chronological sequence
        // of weekend-days transitions maintained by this calendar.

    const Date&amp; firstDate() const;
        // Return a reference providing non-modifiable access to the earliest
        // date in the valid range of this calendar.  The behavior is
        // undefined unless this calendar is non-empty -- i.e., unless
        // &#39;1 &lt;= length()&#39;.

    int getNextBusinessDay(Date *nextBusinessDay, const Date&amp; date) const;
        // Load, into the specified &#39;nextBusinessDay&#39;, the date of the first
        // business day in this calendar following the specified &#39;date&#39;.
        // Return 0 on success -- i.e., if such a business day exists, and a
        // non-zero value (with no effect on &#39;nextBusinessDay&#39;) otherwise.  The
        // behavior is undefined unless &#39;date + 1&#39; is both a valid &#39;bdlt::Date&#39;
        // and within the valid range of this calendar.

    int getNextBusinessDay(Date        *nextBusinessDay,
                           const Date&amp;  date,
                           int          nth) const;
        // Load, into the specified &#39;nextBusinessDay&#39;, the date of the
        // specified &#39;nth&#39; business day in this calendar following the
        // specified &#39;date&#39;.  Return 0 on success -- i.e., if such a business
        // day exists, and a non-zero value (with no effect on
        // &#39;nextBusinessDay&#39;) otherwise.  The behavior is undefined unless
        // &#39;date + 1&#39; is both a valid &#39;bdlt::Date&#39; and within the valid range
        // of this calendar, and &#39;0 &lt; nth&#39;.

    Date holiday(int index) const;
        // Return the holiday at the specified &#39;index&#39; in this calendar.  For
        // all &#39;index&#39; values from 0 to &#39;numHolidays() - 1&#39; (inclusive), a
        // unique holiday is returned.  The mapping of &#39;index&#39; to holiday is
        // invalidated when the set of holidays is modified by an invocation of
        // &#39;addHoliday&#39;, &#39;addHolidayIfInRange&#39;, &#39;intersectBusinessDays&#39;,
        // &#39;intersectNonBusinessDays&#39;, &#39;removeAll&#39;, &#39;removeHoliday&#39;,
        // &#39;setValidRange&#39;, &#39;unionBusinessDays&#39;, or &#39;unionNonBusinessDays&#39;.
        // The behavior is undefined unless &#39;0 &lt;= index &lt; numHolidays()&#39;.

    int holidayCode(const Date&amp; date, int index) const;
        // Return, for the holiday at the specified &#39;date&#39; in this calendar,
        // the holiday code at the specified &#39;index&#39;.  For all &#39;index&#39; values
        // from 0 to &#39;numHolidayCodes(date) - 1&#39; (inclusive), a unique holiday
        // code is returned.  The mapping of &#39;index&#39; to holiday code is
        // invalidated when the set of holidays or holiday codes is modified by
        // an invocation of &#39;addHoliday&#39;, &#39;addHolidayCode&#39;,
        // &#39;addHolidayCodeIfInRange&#39;, &#39;addHolidayIfInRange&#39;,
        // &#39;intersectBusinessDays&#39;, &#39;intersectNonBusinessDays&#39;, &#39;removeAll&#39;,
        // &#39;removeHoliday&#39;, &#39;removeHolidayCode&#39;, &#39;setValidRange&#39;,
        // &#39;unionBusinessDays&#39;, or &#39;unionNonBusinessDays&#39;.  The behavior is
        // undefined unless &#39;date&#39; is a holiday in this calendar and
        // &#39;0 &lt;= index &lt; numHolidayCodes(date)&#39;.  Note that this method
        // facilitates testing and generally should not be used by clients; in
        // particular, using this method to iterate over the holiday codes for
        // &#39;date&#39; is less efficient than using a &#39;HolidayCodeConstIterator&#39;.

    bool isBusinessDay(const Date&amp; date) const;
        // Return &#39;true&#39; if the specified &#39;date&#39; is a business day (i.e., not
        // a holiday or weekend day) in this calendar, and &#39;false&#39; otherwise.
        // The behavior is undefined unless &#39;date&#39; is within the valid range of
        // this calendar.

    bool isHoliday(const Date&amp; date) const;
        // Return &#39;true&#39; if the specified &#39;date&#39; is a holiday in this calendar,
        // and &#39;false&#39; otherwise.  The behavior is undefined unless &#39;date&#39; is
        // within the valid range of this calendar.

    bool isInRange(const Date&amp; date) const;
        // Return &#39;true&#39; if the specified &#39;date&#39; is within the valid range of
        // this calendar (i.e., &#39;firstDate() &lt;= date &lt;= lastDate()&#39;), and
        // &#39;false&#39; otherwise.  Note that the valid range for a &#39;Calendar&#39; is
        // empty if its length is 0.

    bool isNonBusinessDay(const Date&amp; date) const;
        // Return &#39;true&#39; if the specified &#39;date&#39; is not a business day (i.e.,
        // is either a holiday or weekend day) in this calendar, and &#39;false&#39;
        // otherwise.  The behavior is undefined unless &#39;date&#39; is within the
        // valid range of this calendar.  Note that:
        //..
        //  !isBusinessDay(date)
        //..
        // returns the same result.

    bool isWeekendDay(const Date&amp; date) const;
        // Return &#39;true&#39; if the specified &#39;date&#39; falls on a day of the week
        // that is considered a weekend day in this calendar, and &#39;false&#39;
        // otherwise.  Note that this method is defined for all &#39;date&#39; values,
        // not just those that fall within the valid range, and may be invoked
        // even on an empty calendar (i.e., having &#39;0 == length()&#39;).

    bool isWeekendDay(DayOfWeek::Enum dayOfWeek) const;
        // Return &#39;true&#39; if the specified &#39;dayOfWeek&#39; is a weekend day in this
        // calendar, and &#39;false&#39; otherwise.  The behavior is undefined unless
        // no weekend-days transitions were added to this calendar via the
        // &#39;addWeekendDaysTransition&#39; method.

    const Date&amp; lastDate() const;
        // Return a reference providing non-modifiable access to the latest
        // date in the valid range of this calendar.  The behavior is
        // undefined unless this calendar is non-empty -- i.e., unless
        // &#39;1 &lt;= length()&#39;.

    int length() const;
        // Return the number of days in the valid range of this calendar,
        // which is defined to be 0 if this calendar is empty, and
        // &#39;lastDate() - firstDate() + 1&#39; otherwise.

    int numBusinessDays() const;
        // Return the number of days in the valid range of this calendar that
        // are considered business days -- i.e., are neither holidays nor
        // weekend days.  Note that
        // &#39;numBusinessDays() == length() - numNonBusinessDays()&#39;.

    int numBusinessDays(const Date&amp; beginDate, const Date&amp; endDate) const;
        // Return the number of days in the specified range
        // &#39;[beginDate .. endDate]&#39; of this calendar that are considered
        // business days -- i.e., are neither holidays nor weekend days.  The
        // behavior is undefined unless &#39;beginDate&#39; and &#39;endDate&#39; are within
        // the valid range of this calendar, and &#39;beginDate &lt;= endDate&#39;.

    int numHolidayCodes(const Date&amp; date) const;
        // Return the number of (unique) holiday codes associated with the
        // specified &#39;date&#39; in this calendar if &#39;date&#39; is a holiday in this
        // calender, and 0 otherwise.  The behavior is undefined unless &#39;date&#39;
        // is within the valid range of this calendar.

    int numHolidayCodesTotal() const;
        // Return the total number of holiday codes for all holidays in this
        // calendar.  Note that this function is used primarily in conjunction
        // with &#39;reserveHolidayCodeCapacity&#39;.

    int numHolidays() const;
        // Return the number of days in the valid range of this calendar that
        // are individually marked as holidays, irrespective of whether or not
        // the date is also considered a weekend day.

    int numNonBusinessDays() const;
        // Return the number of days in the valid range of this calendar that
        // are *not* considered business days -- i.e., are either holidays,
        // weekend days, or both.  Note that
        // &#39;numNonBusinessDays() == length() - numBusinessDays()&#39;.

    int numWeekendDaysInRange() const;
        // Return the number of days in the valid range of this calendar that
        // are considered weekend days, irrespective of any designated
        // holidays.

    int numWeekendDaysTransitions() const;
        // Return the number of weekend-days transitions maintained by this
        // calendar.

    const PackedCalendar&amp; packedCalendar() const;
        // Return a reference providing non-modifiable access to the underlying
        // &#39;PackedCalendar&#39;, which represents the same (mathematical) value as
        // this calendar.

    BusinessDayConstReverseIterator rbeginBusinessDays() const;
        // Return an iterator providing non-modifiable access to the last
        // business day in this calendar.  If this calendar has no valid
        // business days, the returned iterator has the same value as that
        // returned by &#39;rendBusinessDays()&#39;.

    BusinessDayConstReverseIterator rbeginBusinessDays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // business day that occurs on or before the specified &#39;date&#39; in this
        // calendar.  If this calendar has no such business day, the returned
        // iterator has the same value as that returned by
        // &#39;rendBusinessDays(date)&#39;.  The behavior is undefined unless &#39;date&#39;
        // is within the valid range of this calendar.

    HolidayCodeConstReverseIterator rbeginHolidayCodes(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the last
        // holiday code associated with the specified &#39;date&#39; in this calendar.
        // If there are no holiday codes associated with &#39;date&#39;, the returned
        // iterator has the same value as that returned by
        // &#39;rendHolidayCodes(date)&#39;.  The behavior is undefined unless &#39;date&#39;
        // is marked as a holiday in this calendar.

    HolidayCodeConstReverseIterator
                    rbeginHolidayCodes(const HolidayConstIterator&amp; iter) const;
        // Return an iterator providing non-modifiable access to the last
        // holiday code associated with the holiday referenced by the specified
        // &#39;iter&#39;.  If there are no holiday codes associated with the date
        // referenced by &#39;iter&#39;, the returned iterator has the same value as
        // that returned by &#39;rendHolidayCodes(iter)&#39;.  The behavior is
        // undefined unless &#39;iter&#39; refers to a valid holiday of this calendar.

    HolidayConstReverseIterator rbeginHolidays() const;
        // Return an iterator providing non-modifiable access to the last
        // holiday in this calendar.  If this calendar has no holidays, the
        // returned iterator has the same value as that returned by
        // &#39;rendHolidays()&#39;.

    HolidayConstReverseIterator rbeginHolidays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // holiday that occurs on or before the specified &#39;date&#39; in this
        // calendar.  If this calendar has no such holiday, the returned
        // iterator has the same value as that returned by
        // &#39;rendHolidays(date)&#39;.  The behavior is undefined unless &#39;date&#39; is
        // within the valid range of this calendar.

    WeekendDaysTransitionConstReverseIterator
                                          rbeginWeekendDaysTransitions() const;
        // Return an iterator providing non-modifiable access to the last
        // weekend-days transition in the chronological sequence of
        // weekend-days transitions maintained by this calendar.  If this
        // calendar has no weekend-days transitions, the returned iterator has
        // the same value as that returned by &#39;rendWeekendDaysTransitions()&#39;.

    BusinessDayConstReverseIterator rendBusinessDays() const;
        // Return an iterator providing non-modifiable access to the element
        // one before the first business day in this calendar.

    BusinessDayConstReverseIterator rendBusinessDays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // business day that occurs before the specified &#39;date&#39; in this
        // calendar.  If this calendar has no such business day, the returned
        // iterator has the same value as that returned by
        // &#39;rendBusinessDays()&#39;.  The behavior is undefined unless &#39;date&#39; is
        // within the valid range of this calendar.

    HolidayCodeConstReverseIterator rendHolidayCodes(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the element
        // one before the first holiday code associated with the specified
        // &#39;date&#39;.  The behavior is undefined unless &#39;date&#39; is marked as a
        // holiday in this calendar.

    HolidayCodeConstReverseIterator
                      rendHolidayCodes(const HolidayConstIterator&amp; iter) const;
        // Return an iterator providing non-modifiable access to the element
        // one before the first holiday code associated with the holiday
        // referenced by the specified &#39;iter&#39;.  The behavior is undefined
        // unless &#39;iter&#39; references a valid holiday in this calendar.

    HolidayConstReverseIterator rendHolidays() const;
        // Return an iterator providing non-modifiable access to the element
        // one before the first holiday in this calendar.

    HolidayConstReverseIterator rendHolidays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // holiday that occurs before the specified &#39;date&#39; in this calendar.
        // If this calendar has no such holiday, the returned iterator has the
        // same value as that returned by &#39;rendHolidays()&#39;.  The behavior is
        // undefined unless &#39;date&#39; is within the valid range of this calendar.

    WeekendDaysTransitionConstReverseIterator
                                            rendWeekendDaysTransitions() const;
        // Return an iterator providing non-modifiable access to the element
        // one before the first weekend-days transition in the chronological
        // sequence of weekend-days transitions maintained by this calendar.

    WeekendDaysTransition weekendDaysTransition(int index) const;
        // Return the weekend-days transition at the specified &#39;index&#39; in this
        // calendar.  For all &#39;index&#39; values from 0 to
        // &#39;numWeekendDaysTransitions() - 1&#39; (inclusive), a unique weekend-days
        // transition is returned.  The mapping of &#39;index&#39; to weekend-days
        // transition is invalidated when the set of weekend-days transitions
        // is modified by an invocation of &#39;addWeekendDay&#39;, &#39;addWeekendDays&#39;,
        // &#39;addWeekendDaysTransition&#39;, &#39;intersectBusinessDays&#39;,
        // &#39;intersectNonBusinessDays&#39;, &#39;removeAll&#39;, &#39;unionBusinessDays&#39;, or
        // &#39;unionNonBusinessDays&#39;.  The behavior is undefined unless
        // &#39;0 &lt;= index &lt; numWeekendDaysTransitions()&#39;.

                                  // Aspects

    bslma::Allocator *allocator() const;
        // Return the allocator used by this object to supply memory.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write this value to the specified output &#39;stream&#39; using the
        // specified &#39;version&#39; format and return a reference to the modifiable
        // &#39;stream&#39;.  If &#39;version&#39; is not supported, &#39;stream&#39; is unmodified.
        // Note that &#39;version&#39; is not written to &#39;stream&#39;.  See the &#39;bdex&#39;
        // package-level documentation for more information on &#39;bdex&#39; streaming
        // of value-semantic types and containers.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the (absolute
        // value of) the optionally specified indentation &#39;level&#39; and return a
        // reference to the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified,
        // optionally specify &#39;spacesPerLevel&#39;, the number of spaces per
        // indentation level for this and all of its nested objects.  If
        // &#39;level&#39; is negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, format the entire output on one line,
        // suppressing all but the initial indentation (as governed by
        // &#39;level&#39;).  If &#39;stream&#39; is not valid on entry, this operation has no
        // effect.



};

// FREE OPERATORS
bool operator==(const Calendar&amp; lhs, const Calendar&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; calendars have the same
    // value, and &#39;false&#39; otherwise.  Two calendars have the same value if they
    // have the same valid range (or are both empty), the same weekend days,
    // the same holidays, and each corresponding pair of holidays has the same
    // (ordered) set of associated holiday codes.

bool operator!=(const Calendar&amp; lhs, const Calendar&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; calendars do not have the
    // same value, and &#39;false&#39; otherwise.  Two calendars do not have the same
    // value if they do not have the same valid range (and are not both empty),
    // do not have the same weekend days, do not have the same holidays, or,
    // for at least one corresponding pair of holidays, do not have the same
    // (ordered) set of associated holiday codes.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Calendar&amp; calendar);
    // Write the value of the specified &#39;calendar&#39; to the specified output
    // &#39;stream&#39;, and return a reference to the modifiable &#39;stream&#39;.

// FREE FUNCTIONS
void swap(Calendar&amp; a, Calendar&amp; b);
    // Efficiently exchange the values of the specified &#39;a&#39; and &#39;b&#39; objects.
    // This function provides the no-throw exception-safety guarantee.  The
    // behavior is undefined unless the two objects were created with the same
    // allocator.

                    // ===================================
                    // class Calendar_BusinessDayConstIter
                    // ===================================

class Calendar_BusinessDayConstIter {
    // Provide read-only, sequential access in increasing (chronological) order
    // to the business days in a &#39;Calendar&#39; object.

    // DATA
    const bdlc::BitArray *d_nonBusinessDays_p;  // pointer to the non-business
                                                // day bit array in the
                                                // calendar

    Date                  d_firstDate;          // first valid date of the
                                                // calendar

    int                   d_currentOffset;      // offset of the date to which
                                                // this iterator is pointing
                                                // (-1 indicates an &#39;end&#39;
                                                // iterator)

    // FRIENDS
    friend class Calendar;
    friend bool operator==(const Calendar_BusinessDayConstIter&amp;,
                           const Calendar_BusinessDayConstIter&amp;);
    friend bool operator!=(const Calendar_BusinessDayConstIter&amp;,
                           const Calendar_BusinessDayConstIter&amp;);

  private:
    // PRIVATE CREATORS
    Calendar_BusinessDayConstIter(const bdlc::BitArray&amp; nonBusinessDays,
                                  const Date&amp;           firstDateOfCalendar,
                                  const Date&amp;           startDate,
                                  bool                  endIterFlag);
        // Create a business day iterator for a calendar defined by the
        // specified &#39;nonBusinessDays&#39; and &#39;firstDateOfCalendar&#39;.  If the
        // specified &#39;endIterFlag&#39; is &#39;false&#39;, then this iterator references
        // the first business day on or after the specified &#39;startDate&#39;;
        // otherwise, this iterator references one business day *past* the
        // first business day on or after &#39;startDate&#39;.  If no business day
        // matching the above specification exists, then this iterator
        // references one day past the end of its range.  The behavior is
        // undefined unless &#39;startDate&#39; is within the valid range of the
        // calendar defined by &#39;nonBusinessDays&#39; and &#39;firstDateOfCalendar&#39;.

  public:
    // PUBLIC TYPES
    typedef Date                     value_type;
    typedef int                      difference_type;
    typedef PackedCalendar_DateProxy pointer;
    typedef PackedCalendar_DateRef   reference;
        // The star operator returns a &#39;PackedCalendar_DateRef&#39; *by* *value*.

    typedef bsl::bidirectional_iterator_tag iterator_category;

    // CREATORS
    Calendar_BusinessDayConstIter(
                                const Calendar_BusinessDayConstIter&amp; original);
        // Create an iterator having the value of the specified &#39;original&#39;
        // iterator.

    ~Calendar_BusinessDayConstIter();
        // Destroy this object.

    // MANIPULATORS
    Calendar_BusinessDayConstIter&amp; operator=(
                                     const Calendar_BusinessDayConstIter&amp; rhs);
        // Assign to this iterator the value of the specified &#39;rhs&#39; iterator,
        // and return a reference providing modifiable access to this object.

    Calendar_BusinessDayConstIter&amp; operator++();
        // Advance this iterator to refer to the next business day in the
        // associated calendar, and return a reference providing modifiable
        // access to this object.  The behavior is undefined unless, on entry,
        // this iterator references a valid business day.

    Calendar_BusinessDayConstIter&amp; operator--();
        // Regress this iterator to refer to the previous business day in the
        // associated calendar, and return a reference providing modifiable
        // access to this object.  The behavior is undefined unless, on entry,
        // this iterator references a valid business day that is not the first
        // business day for the associated calendar.

    // ACCESSORS
    PackedCalendar_DateRef operator*() const;
        // Return a &#39;PackedCalendar_DateRef&#39; object that contains the date
        // value of the business day referenced by this iterator.

    PackedCalendar_DateProxy operator-&gt;() const;
        // Return a date proxy for the business day referenced by this
        // iterator.
};

// FREE OPERATORS
bool operator==(const Calendar_BusinessDayConstIter&amp; lhs,
                const Calendar_BusinessDayConstIter&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; iterators refer to the
    // same element in the same calendar, and &#39;false&#39; otherwise.  The behavior
    // is undefined unless &#39;lhs&#39; and &#39;rhs&#39; both iterate over the same calendar.

bool operator!=(const Calendar_BusinessDayConstIter&amp; lhs,
                const Calendar_BusinessDayConstIter&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; iterators do not refer to
    // the same element in the same calendar, and &#39;false&#39; otherwise.  The
    // behavior is undefined unless &#39;lhs&#39; and &#39;rhs&#39; both iterate over the same
    // calendar.

Calendar_BusinessDayConstIter operator++(
                                 Calendar_BusinessDayConstIter&amp; iterator, int);
    // Advance the specified &#39;iterator&#39; to refer to the next business day in
    // the associated calendar, and return the previous value of &#39;iterator&#39;.
    // The behavior is undefined unless, on entry, &#39;iterator&#39; references a
    // valid business day.

Calendar_BusinessDayConstIter operator--(
                                 Calendar_BusinessDayConstIter&amp; iterator, int);
    // Regress the specified &#39;iterator&#39; to refer to the previous business day
    // in the associated calendar, and return the previous value of &#39;iterator&#39;.
    // The behavior is undefined unless, on entry, &#39;iterator&#39; references a
    // valid business day that is not the first business day for the associated
    // calendar.

// ============================================================================
//                          INLINE DEFINITIONS
// ============================================================================

                            // --------------
                            // class Calendar
                            // --------------

// CLASS METHODS

                                  // Aspects

inline
int Calendar::maxSupportedBdexVersion(int versionSelector)
{
    return PackedCalendar::maxSupportedBdexVersion(versionSelector);
}

// MANIPULATORS
inline
Calendar&amp; Calendar::operator=(const Calendar&amp; rhs)
{
    Calendar(rhs, d_packedCalendar.allocator()).swap(*this);
    return *this;
}

inline
Calendar&amp; Calendar::operator=(const PackedCalendar&amp; rhs)
{
    Calendar(rhs, d_packedCalendar.allocator()).swap(*this);
    return *this;
}

inline
int Calendar::addHolidayCodeIfInRange(const Date&amp; date, int holidayCode)
{
    if (isInRange(date)) {
        addHolidayCode(date, holidayCode);
        return 0;                                                     // RETURN
    }
    return -1;
}

inline
int Calendar::addHolidayIfInRange(const Date&amp; date)
{
    if (isInRange(date)) {
        addHoliday(date);
        return 0;                                                     // RETURN
    }
    return -1;
}

inline
void Calendar::addWeekendDaysTransition(const Date&amp;         startDate,
                                        const DayOfWeekSet&amp; weekendDays)
{
    d_packedCalendar.addWeekendDaysTransition(startDate, weekendDays);
    synchronizeCache();
}

inline
void Calendar::intersectBusinessDays(const PackedCalendar&amp; other)
{
    d_packedCalendar.intersectBusinessDays(other);
    synchronizeCache();
}

inline
void Calendar::intersectBusinessDays(const Calendar&amp; other)
{
    intersectBusinessDays(other.d_packedCalendar);
}

inline
void Calendar::intersectNonBusinessDays(const PackedCalendar&amp; other)
{
    d_packedCalendar.intersectNonBusinessDays(other);
    synchronizeCache();
}

inline
void Calendar::intersectNonBusinessDays(const Calendar&amp; other)
{
    intersectNonBusinessDays(other.d_packedCalendar);
}

inline
void Calendar::removeAll()
{
    d_packedCalendar.removeAll();
    d_nonBusinessDays.removeAll();
}

inline
void Calendar::removeHoliday(const Date&amp; date)
{
    d_packedCalendar.removeHoliday(date);

    if (true == isInRange(date) &amp;&amp; false == isWeekendDay(date)) {
        d_nonBusinessDays.assign0(date - firstDate());
    }
}

inline
void Calendar::removeHolidayCode(const Date&amp; date, int holidayCode)
{
    d_packedCalendar.removeHolidayCode(date, holidayCode);
}

inline
void Calendar::reserveHolidayCapacity(int numHolidays)
{
    d_packedCalendar.reserveHolidayCapacity(numHolidays);
}

inline
void Calendar::reserveHolidayCodeCapacity(int numHolidayCodes)
{
    d_packedCalendar.reserveHolidayCodeCapacity(numHolidayCodes);
}

inline
void Calendar::setValidRange(const Date&amp; firstDate, const Date&amp; lastDate)
{
    d_nonBusinessDays.reserveCapacity(lastDate - firstDate + 1);
    d_packedCalendar.setValidRange(firstDate, lastDate);
    synchronizeCache();
}

inline
void Calendar::unionBusinessDays(const Calendar&amp; other)
{
    unionBusinessDays(other.d_packedCalendar);
}

inline
void Calendar::unionNonBusinessDays(const Calendar&amp; other)
{
    unionNonBusinessDays(other.d_packedCalendar);
}

                                  // Aspects

template &lt;class STREAM&gt;
STREAM&amp; Calendar::bdexStreamIn(STREAM&amp; stream, int version)
{
    if (stream) {
        PackedCalendar inCal(allocator());
        inCal.bdexStreamIn(stream, version);
        if (!stream) {
            return stream;                                            // RETURN
        }
        d_nonBusinessDays.reserveCapacity(inCal.length());
        d_packedCalendar.swap(inCal);
        synchronizeCache();
    }
    return stream;
}

inline
void Calendar::swap(Calendar&amp; other)
{
    // &#39;swap&#39; is undefined for objects with non-equal allocators.

    BSLS_ASSERT_SAFE(d_packedCalendar.allocator() ==
                                           other.d_packedCalendar.allocator());

    bslalg::SwapUtil::swap(&amp;d_packedCalendar,  &amp;other.d_packedCalendar);
    bslalg::SwapUtil::swap(&amp;d_nonBusinessDays, &amp;other.d_nonBusinessDays);
}

// ACCESSORS
inline
Calendar::BusinessDayConstIterator Calendar::beginBusinessDays() const
{
    if (length()) {
        return Calendar_BusinessDayConstIter(d_nonBusinessDays,
                                             firstDate(),
                                             firstDate(),
                                             false);                  // RETURN
    }

    return endBusinessDays();
}

inline
Calendar::BusinessDayConstIterator
                            Calendar::beginBusinessDays(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    return Calendar_BusinessDayConstIter(d_nonBusinessDays,
                                         firstDate(),
                                         date,
                                         false);
}

inline
Calendar::HolidayCodeConstIterator
                            Calendar::beginHolidayCodes(const Date&amp; date) const
{
    return d_packedCalendar.beginHolidayCodes(date);
}

inline
Calendar::HolidayCodeConstIterator
            Calendar::beginHolidayCodes(const HolidayConstIterator&amp; iter) const
{
    return d_packedCalendar.beginHolidayCodes(iter);
}

inline
Calendar::HolidayConstIterator Calendar::beginHolidays() const
{
    return d_packedCalendar.beginHolidays();
}

inline
Calendar::HolidayConstIterator Calendar::beginHolidays(const Date&amp; date) const
{
    return d_packedCalendar.beginHolidays(date);
}

inline
Calendar::WeekendDaysTransitionConstIterator
                                  Calendar::beginWeekendDaysTransitions() const
{
    return d_packedCalendar.beginWeekendDaysTransitions();
}

inline
Calendar::BusinessDayConstIterator Calendar::endBusinessDays() const
{
    if (length()) {
        return BusinessDayConstIterator(d_nonBusinessDays,
                                        firstDate(),
                                        lastDate(),
                                        true);                        // RETURN
    }
    return BusinessDayConstIterator(d_nonBusinessDays,
                                    Date() + 1,
                                    Date(),
                                    true);
}

inline
Calendar::BusinessDayConstIterator
                              Calendar::endBusinessDays(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    return BusinessDayConstIterator(d_nonBusinessDays,
                                    firstDate(),
                                    date,
                                    true);
}

inline
Calendar::HolidayCodeConstIterator
                              Calendar::endHolidayCodes(const Date&amp; date) const
{
    return d_packedCalendar.endHolidayCodes(date);
}

inline
Calendar::HolidayCodeConstIterator
              Calendar::endHolidayCodes(const HolidayConstIterator&amp; iter) const
{
    return d_packedCalendar.endHolidayCodes(iter);
}

inline
Calendar::HolidayConstIterator Calendar::endHolidays() const
{
    return d_packedCalendar.endHolidays();
}

inline
Calendar::HolidayConstIterator Calendar::endHolidays(const Date&amp; date) const
{
    return d_packedCalendar.endHolidays(date);
}

inline
Calendar::WeekendDaysTransitionConstIterator
                                    Calendar::endWeekendDaysTransitions() const
{
    return d_packedCalendar.endWeekendDaysTransitions();
}

inline
const Date&amp; Calendar::firstDate() const
{
    return d_packedCalendar.firstDate();
}

inline
int Calendar::getNextBusinessDay(Date *nextBusinessDay, const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(nextBusinessDay);
    BSLS_ASSERT_SAFE(Date(9999, 12, 31) &gt; date);
    BSLS_ASSERT_SAFE(isInRange(date + 1));

    enum { e_SUCCESS = 0, e_FAILURE = 1 };

    int offset = d_nonBusinessDays.find0AtMinIndex(date + 1 - firstDate());
    if (0 &lt;= offset) {
        *nextBusinessDay = firstDate() + offset;
        return e_SUCCESS;                                             // RETURN
    }

    return e_FAILURE;
}


inline
Date Calendar::holiday(int index) const
{
    return d_packedCalendar.holiday(index);
}

inline
int Calendar::holidayCode(const Date&amp; date, int index) const
{
    return d_packedCalendar.holidayCode(date, index);
}

inline
bool Calendar::isBusinessDay(const Date&amp; date) const
{
    return !isNonBusinessDay(date);
}

inline
bool Calendar::isHoliday(const Date&amp; date) const
{
    return d_packedCalendar.isHoliday(date);
}

inline
bool Calendar::isInRange(const Date&amp; date) const
{
    return d_packedCalendar.isInRange(date);
}

inline
bool Calendar::isNonBusinessDay(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    return d_nonBusinessDays[date - firstDate()];
}

inline
bool Calendar::isWeekendDay(const Date&amp; date) const
{
    return d_packedCalendar.isWeekendDay(date);
}

inline
bool Calendar::isWeekendDay(DayOfWeek::Enum dayOfWeek) const
{
    return d_packedCalendar.isWeekendDay(dayOfWeek);
}

inline
const Date&amp; Calendar::lastDate() const
{
    return d_packedCalendar.lastDate();
}

inline
int Calendar::length() const
{
    return d_nonBusinessDays.length();
}

inline
int Calendar::numBusinessDays() const
{
    return d_nonBusinessDays.num0();
}

inline
int Calendar::numBusinessDays(const Date&amp; beginDate, const Date&amp; endDate) const
{
    BSLS_ASSERT_SAFE(isInRange(beginDate));
    BSLS_ASSERT_SAFE(isInRange(endDate));
    BSLS_ASSERT_SAFE(beginDate &lt;= endDate);

    return d_nonBusinessDays.num0(beginDate - firstDate(),
                                  endDate - firstDate() + 1);
}

inline
int Calendar::numHolidayCodes(const Date&amp; date) const
{
    return d_packedCalendar.numHolidayCodes(date);
}

inline
int Calendar::numHolidayCodesTotal() const
{
    return d_packedCalendar.numHolidayCodesTotal();
}

inline
int Calendar::numHolidays() const
{
    return d_packedCalendar.numHolidays();
}

inline
int Calendar::numNonBusinessDays() const
{
    return d_nonBusinessDays.num1();
}

inline
int Calendar::numWeekendDaysInRange() const
{
    return d_packedCalendar.numWeekendDaysInRange();
}

inline
int Calendar::numWeekendDaysTransitions() const
{
    return d_packedCalendar.numWeekendDaysTransitions();
}

inline
const PackedCalendar&amp; Calendar::packedCalendar() const
{
    return d_packedCalendar;
}

inline
Calendar::BusinessDayConstReverseIterator Calendar::rbeginBusinessDays() const
{
    return BusinessDayConstReverseIterator(endBusinessDays());
}

inline
Calendar::BusinessDayConstReverseIterator
                           Calendar::rbeginBusinessDays(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    return BusinessDayConstReverseIterator(endBusinessDays(date));
}

inline
Calendar::HolidayCodeConstReverseIterator
                           Calendar::rbeginHolidayCodes(const Date&amp; date) const
{
    return d_packedCalendar.rbeginHolidayCodes(date);
}

inline
Calendar::HolidayCodeConstReverseIterator
           Calendar::rbeginHolidayCodes(const HolidayConstIterator&amp; iter) const
{
    return d_packedCalendar.rbeginHolidayCodes(iter);
}

inline
Calendar::HolidayConstReverseIterator Calendar::rbeginHolidays() const
{
    return d_packedCalendar.rbeginHolidays();
}

inline
Calendar::HolidayConstReverseIterator
                               Calendar::rbeginHolidays(const Date&amp; date) const
{
    return d_packedCalendar.rbeginHolidays(date);
}

inline
Calendar::WeekendDaysTransitionConstReverseIterator
                                 Calendar::rbeginWeekendDaysTransitions() const
{
    return d_packedCalendar.rbeginWeekendDaysTransitions();
}

inline
Calendar::BusinessDayConstReverseIterator Calendar::rendBusinessDays() const
{
    return BusinessDayConstReverseIterator(beginBusinessDays());
}

inline
Calendar::BusinessDayConstReverseIterator
                             Calendar::rendBusinessDays(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    return BusinessDayConstReverseIterator(beginBusinessDays(date));
}

inline
Calendar::HolidayCodeConstReverseIterator
                             Calendar::rendHolidayCodes(const Date&amp; date) const
{
    return d_packedCalendar.rendHolidayCodes(date);
}

inline
Calendar::HolidayCodeConstReverseIterator
             Calendar::rendHolidayCodes(const HolidayConstIterator&amp; iter) const
{
    return d_packedCalendar.rendHolidayCodes(iter);
}

inline
Calendar::HolidayConstReverseIterator Calendar::rendHolidays() const
{
    return d_packedCalendar.rendHolidays();
}

inline
Calendar::HolidayConstReverseIterator
                                 Calendar::rendHolidays(const Date&amp; date) const
{
    return d_packedCalendar.rendHolidays(date);
}

inline
Calendar::WeekendDaysTransitionConstReverseIterator
                                   Calendar::rendWeekendDaysTransitions() const
{
    return d_packedCalendar.rendWeekendDaysTransitions();
}

inline
Calendar::WeekendDaysTransition
                               Calendar::weekendDaysTransition(int index) const
{
    return d_packedCalendar.weekendDaysTransition(index);
}

                                  // Aspects

inline
bslma::Allocator *Calendar::allocator() const
{
    return d_packedCalendar.allocator();
}

template &lt;class STREAM&gt;
inline
STREAM&amp; Calendar::bdexStreamOut(STREAM&amp; stream, int version) const
{

    d_packedCalendar.bdexStreamOut(stream, version);
    return stream;
}

inline
bsl::ostream&amp; Calendar::print(bsl::ostream&amp; stream,
                              int           level,
                              int           spacesPerLevel) const
{
    return d_packedCalendar.print(stream, level, spacesPerLevel);
}


}  // close package namespace

// FREE OPERATORS
inline
bool bdlt::operator==(const Calendar&amp; lhs, const Calendar&amp; rhs)
{
    return lhs.d_packedCalendar == rhs.d_packedCalendar;
}

inline
bool bdlt::operator!=(const Calendar&amp; lhs, const Calendar&amp; rhs)
{
    return lhs.d_packedCalendar != rhs.d_packedCalendar;
}

inline
bsl::ostream&amp; bdlt::operator&lt;&lt;(bsl::ostream&amp; stream, const Calendar&amp; calendar)
{
    calendar.print(stream, 0, -1);
    return stream;
}

// FREE FUNCTIONS
inline
void bdlt::swap(Calendar&amp; a, Calendar&amp; b)
{
    a.swap(b);
}

namespace bdlt {

                   // -----------------------------------
                   // class Calendar_BusinessDayConstIter
                   // -----------------------------------

// CREATORS
inline
Calendar_BusinessDayConstIter::Calendar_BusinessDayConstIter(
                                 const Calendar_BusinessDayConstIter&amp; original)
: d_nonBusinessDays_p(original.d_nonBusinessDays_p)
, d_firstDate(original.d_firstDate)
, d_currentOffset(original.d_currentOffset)
{
}

inline
Calendar_BusinessDayConstIter::~Calendar_BusinessDayConstIter()
{
}

// MANIPULATORS
inline
Calendar_BusinessDayConstIter&amp; Calendar_BusinessDayConstIter::operator=(
                                      const Calendar_BusinessDayConstIter&amp; rhs)
{
    d_nonBusinessDays_p = rhs.d_nonBusinessDays_p;
    d_firstDate         = rhs.d_firstDate;
    d_currentOffset     = rhs.d_currentOffset;
    return *this;
}

inline
Calendar_BusinessDayConstIter&amp; Calendar_BusinessDayConstIter::operator++()
{
    BSLS_ASSERT_SAFE(d_currentOffset &gt;= 0);

    d_currentOffset =
                     d_nonBusinessDays_p-&gt;find0AtMinIndex(d_currentOffset + 1);
    return *this;
}

inline
Calendar_BusinessDayConstIter&amp; Calendar_BusinessDayConstIter::operator--()
{
    if (-1 == d_currentOffset) {
        d_currentOffset = d_nonBusinessDays_p-&gt;
                             find0AtMaxIndex(0, d_nonBusinessDays_p-&gt;length());
    }
    else {
        d_currentOffset = d_nonBusinessDays_p-&gt;
                                           find0AtMaxIndex(0, d_currentOffset);
    }

    BSLS_ASSERT_SAFE(0 &lt;= d_currentOffset);

    return *this;
}

inline
Calendar_BusinessDayConstIter operator++(
                                  Calendar_BusinessDayConstIter&amp; iterator, int)
{
    Calendar_BusinessDayConstIter tmp(iterator);
    ++iterator;
    return tmp;
}

inline
Calendar_BusinessDayConstIter operator--(
                                  Calendar_BusinessDayConstIter&amp; iterator, int)
{
    Calendar_BusinessDayConstIter tmp(iterator);
    --iterator;
    return tmp;
}

// ACCESSORS
inline
PackedCalendar_DateRef Calendar_BusinessDayConstIter::operator*() const
{
    return PackedCalendar_DateRef(d_firstDate + d_currentOffset);
}

inline
PackedCalendar_DateProxy Calendar_BusinessDayConstIter::operator-&gt;() const
{
    return PackedCalendar_DateProxy(this-&gt;operator*());
}

}  // close package namespace

// FREE OPERATORS
inline
bool bdlt::operator==(const Calendar_BusinessDayConstIter&amp; lhs,
                      const Calendar_BusinessDayConstIter&amp; rhs)
{
    BSLS_ASSERT_SAFE(lhs.d_nonBusinessDays_p == rhs.d_nonBusinessDays_p);

    return lhs.d_firstDate     == rhs.d_firstDate
        &amp;&amp; lhs.d_currentOffset == rhs.d_currentOffset;
}

inline
bool bdlt::operator!=(const Calendar_BusinessDayConstIter&amp; lhs,
                      const Calendar_BusinessDayConstIter&amp; rhs)
{
    BSLS_ASSERT_SAFE(lhs.d_nonBusinessDays_p == rhs.d_nonBusinessDays_p);

    return lhs.d_firstDate     != rhs.d_firstDate
        || lhs.d_currentOffset != rhs.d_currentOffset;
}

}  // close enterprise namespace

// TRAITS
namespace BloombergLP {
namespace bslma {

template &lt;&gt;
struct UsesBslmaAllocator&lt;bdlt::Calendar&gt; : bsl::true_type {};

}  // close namespace bslma
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
