<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslstl_sharedptrallocateinplacerep.h                               -*-C++-*-
#ifndef INCLUDED_BSLSTL_SHAREDPTRALLOCATEINPLACEREP
#define INCLUDED_BSLSTL_SHAREDPTRALLOCATEINPLACEREP

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$ $CSID$&quot;)

//@PURPOSE: Provide an in-place implementation of &#39;bslma::SharedPtrRep&#39;.
//
//@CLASSES:
//  bslstl::SharedPtrAllocateInplaceRep: in-place &#39;shared_ptr&#39; implementation
//
//@SEE_ALSO: bslma_sharedptrrep, bslma_sharedptrinplacerep, bslstl_sharedptr
//
//@DESCRIPTION: This component provides a class template,
// &#39;bslstl::SharedPtrAllocateInplaceRep&#39;, proving a concrete implementation of
// &#39;bslma::SharedPtrRep&#39; for managing objects of the parameterized &#39;TYPE&#39; that
// are stored in-place in the representation, and are allocated by an allocator
// that satisfies the requirements of an Allocator type in the C++11 standard.
// Thus, only one memory allocation is required to create both the
// representation and the managed object.  When all references to the in-place
// object are released (using &#39;releaseRef&#39;), the destructor of &#39;TYPE&#39; is
// invoked.
//
///Thread-Safety
///-------------
// &#39;bslstl::SharedPtrAllocateInplaceRep&#39; is thread-safe provided that
// &#39;disposeObject&#39; and &#39;disposeRep&#39; are not called explicitly, meaning that all
// non-creator operations other than &#39;disposeObject&#39; and &#39;disposeRep&#39; on a
// given instance can be safely invoked simultaneously from multiple threads
// (&#39;disposeObject&#39; and &#39;disposeRep&#39; are meant to be invoked only by
// &#39;releaseRef&#39; and &#39;releaseWeakRef&#39;).  Note that there is no thread safety
// guarantees for operations on the managed object contained in
// &#39;bslstl::SharedPtrAllocateInplaceRep&#39;.
//
#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ALLOCATORTRAITS
#include &lt;bslstl_allocatortraits.h&gt;
#endif

#ifndef INCLUDED_BSLMA_SHAREDPTRREP
#include &lt;bslma_sharedptrrep.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_OBJECTBUFFER
#include &lt;bsls_objectbuffer.h&gt;
#endif

#ifndef INCLUDED_TYPEINFO
#include &lt;typeinfo&gt;
#define INCLUDED_TYPEINFO
#endif

namespace BloombergLP {
namespace bslstl {

                 // =================================
                 // class SharedPtrAllocateInplaceRep
                 // =================================

template &lt;class TYPE, class ALLOCATOR&gt;
class SharedPtrAllocateInplaceRep : public BloombergLP::bslma::SharedPtrRep {
    // This class provides a concrete implementation of the &#39;SharedPtrRep&#39;
    // protocol for in-place instances of the (template parameter) &#39;TYPE&#39;.
    // Upon destruction of this object, the destructor of &#39;TYPE&#39; is invoked on
    // the shared object.

    // PRIVATE TYPES
    typedef typename bsl::allocator_traits&lt;ALLOCATOR&gt;::
                            template rebind_traits&lt;SharedPtrAllocateInplaceRep&gt;
                                                                 ReboundTraits;

  public:
    // PUBLIC TYPES
    typedef typename ReboundTraits::allocator_type ReboundAllocator;

  private:
    // DATA
    ReboundAllocator         d_allocator; // copy of this object&#39;s allocator
    bsls::ObjectBuffer&lt;TYPE&gt; d_instance;  // beginning of the in-place buffer

    // Note that &#39;d_instance&#39; must be last in this layout to allow for the
    // possibility of creating an in-place uninitialized buffer, where it is
    // possible to access memory beyond the &#39;d_instance&#39; footprint (refer to
    // &#39;bsl::shared_ptr::createInplaceUninitializedBuffer&#39; for sample usage).

  private:
    // NOT IMPLEMENTED
    SharedPtrAllocateInplaceRep(const SharedPtrAllocateInplaceRep&amp;);
    SharedPtrAllocateInplaceRep&amp; operator=(const SharedPtrAllocateInplaceRep&amp;);

    // PRIVATE CREATORS
    explicit SharedPtrAllocateInplaceRep(
                                       const ReboundAllocator&amp; basicAllocator);
        // Create a &#39;SharedPtrAllocateInplaceRep&#39; object having uninitialized
        // storage for an in-place instance of the parameterized &#39;TYPE&#39;.  Use
        // the specified &#39;basicAllocator&#39; to supply memory and, upon a call to
        // &#39;disposeObject&#39;, to destroy the inplace object, and upon a call to
        // &#39;disposeRep&#39; to destroy the copy the allocator and reclaim storage
        // for this object,

    ~SharedPtrAllocateInplaceRep();  // = delete
        // The destructor for this object should never be called.  The in-place
        // &#39;TYPE&#39; object will be destroyed by a call to &#39;destroyObject&#39; and the
        // stored allocator for this object will be destroyed by a call to
        // &#39;destroyRep&#39;, which will then reclaim the storage occupied by this
        // object.

  public:
    // CLASS METHODS
    static SharedPtrAllocateInplaceRep *makeRep(
                                              ReboundAllocator basicAllocator);
        // Create a &#39;SharedPtrAllocateInplaceRep&#39; object having storage for an
        // in-place uninitialized object of (template parameter) &#39;TYPE&#39;, and
        // return its address.  Use the specified &#39;basicAllocator&#39; to supply
        // memory and, upon a call to &#39;disposeRep&#39;, to destroy this
        // representation (and the in-place shared object).  Note that the
        // function members &#39;ptr&#39; and &#39;originalPtr&#39; will return the address of
        // an uninitialized object.  This object should be explicitly
        // initialized by the caller, and it is undefined behavior to call
        // &#39;disposeRep&#39; until this object has been successfully constructed.

    // MANIPULATORS
    virtual void disposeObject();
        // Destroy the object being referred to by this representation.  This
        // method is automatically invoked by &#39;releaseRef&#39; when the number of
        // shared references reaches zero and should not be explicitly invoked
        // otherwise.

    virtual void disposeRep();
        // Destroy this representation object and deallocate the associated
        // memory.  This method is automatically invoked by &#39;releaseRef&#39; and
        // &#39;releaseWeakRef&#39; when the number of weak references and the number
        // of shared references both reach zero and should not be explicitly
        // invoked otherwise.  The behavior is undefined unless &#39;disposeObject&#39;
        // has already been called for this representation.  Note that this
        // method effectively serves as the representation object&#39;s destructor.

    void *getDeleter(const std::type_info&amp; type);
        // Ignore the specified &#39;type&#39; and return a null pointer.  Note that
        // there is no facility for the user to supply a deleter for an
        // in-place representation for a shared pointer.

    TYPE *ptr();
        // Return the address of the modifiable shared object to which this
        // object refers.  Note that in order to return a pointer to a
        // modifiable object, this function cannot be &#39;const&#39; qualified as the
        // referenced object is stored internally as a data member.

    // ACCESSORS
    virtual void *originalPtr() const;
        // Return the (untyped) address of the modifiable shared object to
        // which this object refers.
};

// ============================================================================
//                           INLINE DEFINITIONS
// ============================================================================

                  // ---------------------------------
                  // class SharedPtrAllocateInplaceRep
                  // ---------------------------------

// PRIVATE CREATORS
template &lt;class TYPE, class ALLOCATOR&gt;
inline
SharedPtrAllocateInplaceRep&lt;TYPE, ALLOCATOR&gt;::SharedPtrAllocateInplaceRep(
                                        const ReboundAllocator&amp; basicAllocator)
: d_allocator(basicAllocator)
// &#39;d_instance&#39; is intentionally left uninitialized.
{
}

template &lt;class TYPE, class ALLOCATOR&gt;
SharedPtrAllocateInplaceRep&lt;TYPE, ALLOCATOR&gt;::
~SharedPtrAllocateInplaceRep()
{
    BSLS_ASSERT_OPT(0);
}

// CLASS METHODS
template &lt;class TYPE, class ALLOCATOR&gt;
inline
SharedPtrAllocateInplaceRep&lt;TYPE, ALLOCATOR&gt; *
SharedPtrAllocateInplaceRep&lt;TYPE, ALLOCATOR&gt;::makeRep(
                                               ReboundAllocator basicAllocator)
{
    SharedPtrAllocateInplaceRep *rep_p =
                                    ReboundTraits::allocate(basicAllocator, 1);
    new(rep_p) SharedPtrAllocateInplaceRep(basicAllocator);
    return rep_p;
}

// MANIPULATORS
template &lt;class TYPE, class ALLOCATOR&gt;
inline
void SharedPtrAllocateInplaceRep&lt;TYPE, ALLOCATOR&gt;::disposeObject()
{
    ReboundTraits::destroy(d_allocator, ptr());
}

template &lt;class TYPE, class ALLOCATOR&gt;
inline
void SharedPtrAllocateInplaceRep&lt;TYPE, ALLOCATOR&gt;::disposeRep()
{
    ReboundAllocator alloc(d_allocator);
    this-&gt;d_allocator.~ReboundAllocator();
    ReboundTraits::deallocate(alloc, this, 1);
}

template &lt;class TYPE, class ALLOCATOR&gt;
inline
void *
SharedPtrAllocateInplaceRep&lt;TYPE, ALLOCATOR&gt;::getDeleter(const std::type_info&amp;)
{
    return 0;
}

template &lt;class TYPE, class ALLOCATOR&gt;
inline
TYPE *SharedPtrAllocateInplaceRep&lt;TYPE, ALLOCATOR&gt;::ptr()
{
    return reinterpret_cast&lt;TYPE *&gt;(d_instance.buffer());
}

// ACCESSORS
template &lt;class TYPE, class ALLOCATOR&gt;
inline
void *
SharedPtrAllocateInplaceRep&lt;TYPE, ALLOCATOR&gt;::originalPtr() const
{
    return const_cast&lt;void *&gt;(static_cast&lt;const void *&gt;(
                         reinterpret_cast&lt;const TYPE *&gt;(d_instance.buffer())));
}

}  // close package namespace

// ============================================================================
//                              TYPE TRAITS
// ============================================================================

namespace bslma {

template &lt;class TYPE, class ALLOCATOR&gt;
struct UsesBslmaAllocator&lt; bslstl::SharedPtrAllocateInplaceRep&lt;TYPE,
                                                               ALLOCATOR&gt; &gt;
    : bsl::false_type
{};

}  // close traits namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
