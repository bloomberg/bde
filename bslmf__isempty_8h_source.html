<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslmf_isempty.h                                                    -*-C++-*-
#ifndef INCLUDED_BSLMF_ISEMPTY
#define INCLUDED_BSLMF_ISEMPTY

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a compile-time check for detecting an empty class type.
//
//@CLASSES:
//   bsl::is_empty: standard meta-function for detecting empty classes
//
//@SEE_ALSO: bslmf_isclass.h
//
//@DESCRIPTION: This component defines a metafunction, &#39;bsl::is_empty&#39;, which
// may be used to determine whether a type is a &#39;class&#39; or &#39;struct&#39; with no
// non-static data members other than bit-fields of length 0, no virtual member
// functions, no virtual base classes, and no base class &#39;B&#39; for which
// &#39;is_empty&lt;B&gt;::value&#39; is &#39;false&#39;.  This metafunction conforms to the
// definition of the C++11 standard &#39;is_empty metafunction in section
// [meta.unary.prop].
//
// An empty class type type is *usually* stateless and, can be &quot;stored&quot; in a
// zero-length memory region.  (Hypothetically, an empty object can hold state
// by means a global address-to-state map, but such a design is rare and is
// discouraged.) When a class inherits from an empty type, the compiler is
// expected to optimize away the storage requirements of the empty base class.
// This optimization is known as the &quot;Empty Base Optimization&quot; or &quot;EBO&quot;.
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Compute Storage Requirements for a Type
/// - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we wish to create a generic function that will allocate a record
// comprising a value of specified &#39;TYPE&#39; and a description in the form of a
// null-terminated character string.  First, we declare the function prototype:
//..
//  template &lt;class TYPE&gt;
//  void *makeRecord(const TYPE&amp; value, const char* description);
//..
// Next, we implement the function so that the copy of &#39;value&#39; takes up no
// space if &#39;TYPE&#39; is an empty class.  We manage this by computing a zero
// storage requirement if &#39;is_empty&lt;TYPE&gt;::value&#39; is true:
//..
//  #include &lt;cstring&gt;
//  #include &lt;new&gt;
//
//  template &lt;class TYPE&gt;
//  void *makeRecord(const TYPE&amp; value, const char* description)
//  {
//      // &#39;ValueSize&#39; is computed at compile time.
//      static const std::size_t ValueSize = bsl::is_empty&lt;TYPE&gt;::value ?
//          0 : sizeof(TYPE);
//
//      // Allocate memory for value and description
//      const std::size_t MemSize = ValueSize + std::strlen(description) + 1;
//      void *mem = ::operator new(MemSize);
//
//      // Construct copy of value at front of allocated memory
//      ::new(mem) TYPE(value);
//
//      // Copy description into space following value.
//      std::strcpy(static_cast&lt;char*&gt;(mem) + ValueSize, description);
//
//      return mem;
//  }
//..
// Finally, we use &#39;makeRecord&#39; with both an empty and non-empty value type:
//..
//  struct EmptyMarker { };
//
//  int main()
//  {
//      void *record1 = makeRecord(9999, &quot;four nines&quot;);
//      // Value takes &#39;sizeof(int)&#39; bytes at front of record.
//      assert(9999 == *static_cast&lt;int*&gt;(record1));
//      assert(0 == std::strcmp(static_cast&lt;char*&gt;(record1) + sizeof(int),
//                              &quot;four nines&quot;));
//
//      void *record2 = makeRecord(EmptyMarker(), &quot;Empty&quot;);
//      // Value takes no space at front of record.
//      assert(0 == std::strcmp(static_cast&lt;char*&gt;(record2), &quot;Empty&quot;));
//
//      ::operator delete(record1);
//      ::operator delete(record2);
//
//      return 0;
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMF_INTEGRALCONSTANT
#include &lt;bslmf_integralconstant.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISCLASS
#include &lt;bslmf_isclass.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVECV
#include &lt;bslmf_removecv.h&gt;
#endif

namespace bsl {

                        // ============================
                        // class template Is_Empty_Size
                        // ============================

struct Is_Empty_Size {
    // Private class: do not use outside of &#39;bslmf_isempty&#39; component.  This
    // component-private class is an example of an empty type, that can be used
    // to calculate the likely size of an empty type on the current platform.
    // As the inheritance-based technique used below disallows unions with a
    // hard error, rather than a SFINAE-friendly failure, it is important to
    // avoid instantiating the &#39;Imp&#39; test unless there is a real chance that
    // the type might be empty.  While we cannot protect against testing small
    // unions, we can rule out the more common cases where at least one union
    // member has more than the smallest permissible size on the current ABI.
};

                // =================================
                // class template Is_Empty_Class_Imp
                // =================================

template &lt;class TYPE,
          bool  IS_CLASS = sizeof(TYPE) == sizeof(Is_Empty_Size)&gt;
struct Is_Empty_Class_Imp : false_type {
    // Private class: do not use outside of &#39;bslmf_isempty&#39; component.  This
    // metafunction derives from &#39;false_type&#39; unless (the template parameter)
    // &#39;TYPE&#39; is exactly the same size as a known empty type, in which case
    // the following partial specialization is chosen.  This test filters out
    // the majority of problems with &#39;union&#39; types that are classes, and would
    // produce a hard, non-SFINAEable error trying to a create a derived class
    // to compare size in the next test.
};

template &lt;class TYPE&gt;
struct Is_Empty_Class_Imp&lt;TYPE, true&gt; {
    // Private class: do not use outside of &#39;bslmf_isempty&#39; component.
    // Implementation of &#39;bsl::is_empty&#39; for class types that are small enough
    // that they might be an empty class.

  private:
    struct Derived : TYPE {
        // This &#39;struct&#39; derives from the template parameter &#39;TYPE&#39; from the
        // enclosing class template, and will have the same size as an &#39;int&#39; if
        // &#39;TYPE&#39; is an empty class, and a larger size otherwise.

        Derived();                // Declared but not defined
        Derived(const Derived&amp;);  // Declared but not defined
        ~Derived();               // Declared but not defined

        int d_data; // &#39;Derived&#39; is not empty
    };

  public:
    typedef integral_constant&lt;bool, sizeof(Derived) == sizeof(int)&gt; type;
        // &#39;true_type&#39; if (the template parameter) &#39;TYPE&#39; is an empty class,
        // and &#39;false_type&#39; otherwise.
};

                        // ===========================
                        // class template Is_Empty_Imp
                        // ===========================

template &lt;class TYPE, bool IS_CLASS = bsl::is_class&lt;TYPE&gt;::value&gt;
struct Is_Empty_Imp : false_type {
    // Private class: do not use outside of &#39;bslmf_isempty&#39; component.  This
    // metafunction provides an initial dispatch that always derives from
    // &#39;false_type&#39; unless the template parameter &#39;TYPE&#39; is a class type, as
    // only class types can be empty.  The following partial specialization
    // forwards all class types to a final test.  This two-phase dispatch is
    // necessary as some types, such as &#39;void&#39; and function types, cannot be
    // passed to a &#39;sizeof&#39; operator that is used to implement the next stage
    // of matching.
};

template &lt;class TYPE&gt;
struct Is_Empty_Imp&lt;TYPE, true&gt; : Is_Empty_Class_Imp&lt;TYPE&gt;::type {
    // Private class: do not use outside of &#39;bslmf_isempty&#39; component.
    // Implementation of &#39;bsl::is_empty&#39;.  This partial specialization derives
    // from the nested &#39;type&#39; member of the &#39;Is_Empty_Class_Imp&#39; metafunction,
    // which must be &#39;true_type&#39; if (the template parameter) &#39;TYPE&#39; is an
    // empty class, and &#39;false_type&#39; otherwise.
};

                        // =======================
                        // class template is_empty
                        // =======================

template &lt;class TYPE&gt;
struct is_empty : Is_Empty_Imp&lt;typename remove_cv&lt;TYPE&gt;::type&gt;::type
{
    // This &#39;struct&#39; is a metafunction to determine whether the (template
    // parameter) &#39;TYPE&#39; is an empty class type.  &#39;is_empty&#39; inherits from
    // &#39;true_type&#39; if &#39;TYPE&#39; is a &#39;class&#39; or &#39;struct&#39; with no non-static data
    // members other than bit-fields of length 0, no virtual member functions,
    // no virtual base classes, and no base class &#39;B&#39; for which
    // &#39;is_empty&lt;B&gt;::value&#39; is &#39;false&#39;; otherwise &#39;is_empty&#39; inherits from
    // &#39;false_type&#39;.  Note that this metafunction will fail to compile for a
    // union that is the same size as an empty class in C++03
};

}  // close namespace bsl

#endif // ! defined(INCLUDED_BSLMF_ISEMPTY)

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
