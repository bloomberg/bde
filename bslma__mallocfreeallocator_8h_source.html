<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslma_mallocfreeallocator.h                                        -*-C++-*-
#ifndef INCLUDED_BSLMA_MALLOCFREEALLOCATOR
#define INCLUDED_BSLMA_MALLOCFREEALLOCATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide malloc/free adaptor to &#39;bslma::Allocator&#39; protocol.
//
//@CLASSES:
//  bslma::MallocFreeAllocator: support malloc/free style allocate/deallocate
//
//@SEE_ALSO: bslma_newdeleteallocator, bslma_allocator
//
//@DESCRIPTION: This component provides an allocator,
// &#39;bslma::MallocFreeAllocator&#39;, that implements the &#39;bslma::Allocator&#39;
// protocol and supplies memory using the system-supplied (native)
// &#39;std::malloc&#39; and &#39;std::free&#39; operators.
//..
//   ,--------------------------.
//  ( bslma::MallocFreeAllocator )
//   `--------------------------&#39;
//                |         ctor/dtor
//                |         singleton
//                V
//        ,----------------.
//       ( bslma::Allocator )
//        `----------------&#39;
//                        allocate
//                        deallocate
//..
// The key purpose of this component is to facilitate the use of &#39;malloc&#39; and
// &#39;free&#39; when the default &#39;bslma::NewDeleteAllocator&#39; is not desirable (such
// as the case of &#39;bslma::TestAllocator&#39;).  To accomplish this goal, &#39;malloc&#39;
// and &#39;free&#39; are wrapped in a singleton object whose lifetime is guaranteed to
// exceed any possibility of its use.
//
///Thread Safety
///-------------
// A single object of &#39;bslma::MallocFreeAllocator&#39; is safe for concurrent
// access by multiple threads.  The underlying implementation of &#39;malloc&#39; and
// &#39;free&#39; will ensure that heap corruption does not occur.  Note that this
// allocator therefore has a stronger thread safety guarantee than is required
// by the base-class contract or than is provided by other allocators.
//
///Usage
///-----
// This component is intended to be used when the use of &#39;new&#39; and &#39;delete&#39; are
// not desirable, such as the case of &#39;bslma::TestAllocator&#39;.  Instead of using
// &#39;bslma::Default&#39; which uses the &#39;bslma::NewDeleteAllocator&#39;, this component
// can be used to bypass the use of &#39;new&#39; and &#39;delete&#39;.
//
// The following example demonstrates the use of this component for a user
// defined allocator instead of using the default allocator:
//..
//  // my_allocator.h
//  // ...
//
//  class my_Allocator : public bslma::Allocator {
//      // This class provides a mechanism for allocation and deallocation.
//
//      // DATA
//      bslma::Allocator *d_allocator_p;  // allocator (held, not owned)
//
//    public:
//      // CREATORS
//      my_Allocator(bslma::Allocator *basicAllocator = 0);
//          // Create a &#39;my_Allcoator&#39;.  Optionally specify &#39;basicAllocator&#39; to
//          // supply memory.  If &#39;basicAllocator&#39; is 0, the
//          // &#39;bslma::MallocFreeAllocator&#39; will be used.
//
//      ~my_Allocator();
//          // Destroy this allocator.  Note that the behavior of destroying an
//          // allocator while memory is allocated from it is not specified.
//          // (Unless you *know* that it is valid to do so, don&#39;t!)
//
//      // MANIPULATORS
//      void *allocate(size_type size);
//          // Return a newly allocated block of memory of (at least) the
//          // specified positive &#39;size&#39; (bytes).  If &#39;size&#39; is 0, a null
//          // pointer is returned with no effect.  The behavior is undefined
//          // if size &lt; 0.  Note that the alignment of the address returned is
//          // the maximum alignment for any fundamental type defined for this
//          // platform.
//
//      void deallocate(void *address);
//          // Return the memory at the specified &#39;address&#39; back to this
//          // allocator.  If &#39;address&#39; is 0, this function has no effect.  The
//          // behavior is undefined if &#39;address&#39; was not allocated using this
//          // allocator, or has already been deallocated.
//  };
//..
// The constructor is implemented using &#39;bslma::MallocFreeAllocator&#39;.
//..
//  // my_allocator.cpp
//  // ...
//
//  // CREATORS
//  my_Allocator::my_Allocator(bslma::Allocator *basicAllocator)
//  : d_allocator_p(basicAllocator
//                  ? basicAllocator
//                  : &amp;bslma::MallocFreeAllocator::singleton())
//  {
//  }
//
//  // ...
//..
// When the &#39;basicAllocator&#39; is not specified, the &#39;bslma::MallocFreeAllocator&#39;
// will be used.  That allocator then then calls &#39;std::malloc&#39; and &#39;std::free&#39;
// for allocating and deallocating memory.

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_CSTDLIB
#include &lt;cstdlib&gt;  // &#39;std::malloc&#39;, &#39;std::free&#39;
#define INCLUDED_CSTDLIB
#endif

namespace BloombergLP {

namespace bslma {

                        // =========================
                        // class MallocFreeAllocator
                        // =========================

class MallocFreeAllocator : public Allocator {
    // This class provides direct access to the system-supplied (native) global
    // &#39;std::malloc&#39; and &#39;std::free&#39;.  A &#39;static&#39; method is provided for
    // obtaining a unique, process wide object of this class, which is valid
    // from the time the method is called until after the program (not just
    // &#39;main&#39;) exits.

    // NOT IMPLEMENTED
    MallocFreeAllocator(const MallocFreeAllocator&amp;);
    MallocFreeAllocator&amp; operator=(const MallocFreeAllocator&amp;);

  public:
    // CLASS METHODS
    static MallocFreeAllocator&amp; singleton();
        // Return a reference to a valid object of this class.  Note that this
        // object is guaranteed to be valid from the time of this call onward
        // (i.e., not just until exiting &#39;main&#39;).

    // CREATORS
    MallocFreeAllocator();
        // Create an allocator that uses &#39;std::malloc&#39; and &#39;std::free&#39; to
        // supply memory.  Note that all objects of this class share the same
        // underlying resource.

    ~MallocFreeAllocator();
        // Destroy this allocator.  Note that the behavior of destroying an
        // allocator while memory is allocated from it is not specified.
        // (Unless you *know* that it is valid to do so, don&#39;t!)
        //
        // For this concrete implementation, destroying this allocator object
        // has no effect on allocated memory.

    // MANIPULATORS
    virtual void *allocate(size_type size);
        // Return a newly allocated block of memory of (at least) the specified
        // positive &#39;size&#39; (in bytes).  If &#39;size&#39; is 0, a null pointer is
        // returned with no other effect.  If this allocator cannot return the
        // requested number of bytes, then it will return a null pointer.  The
        // behavior is undefined unless &#39;0 &lt;= size&#39;.  Note that the alignment
        // of the address returned is the maximum alignment for any type
        // defined on this platform.  Also note that &#39;std::malloc&#39; is *not*
        // called when &#39;size&#39; is 0 (in order to avoid having to acquire a lock,
        // and potential contention in multi-treaded programs).

    virtual void deallocate(void *address);
        // Return the memory block at the specified &#39;address&#39; back to this
        // allocator.  If &#39;address&#39; is 0, this function has no effect.  The
        // behavior is undefined unless &#39;address&#39; was allocated using this
        // allocator object and has not already been deallocated.  Note that
        // &#39;std::free&#39; is *not* called when &#39;address&#39; is 0 (in order to avoid
        // having to acquire a lock, and potential contention in multi-treaded
        // programs).
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                        // -------------------------
                        // class MallocFreeAllocator
                        // -------------------------

// CREATORS
inline
MallocFreeAllocator::MallocFreeAllocator()
{
}

inline
MallocFreeAllocator::~MallocFreeAllocator()
{
}

// MANIPULATORS
inline
void *MallocFreeAllocator::allocate(size_type size)
{
    BSLS_ASSERT_SAFE(0 &lt;= size);

    return size == 0 ? 0 : std::malloc(size);
}

inline
void MallocFreeAllocator::deallocate(void *address)
{
    // While the C and C++ standard guarantees that calling free(0) is safe
    // (3.7.3.2 paragraph 3), some libc implementations take out a lock to deal
    // with the free(0) case, so this check can improve efficiency of threaded
    // programs.

    if (address) {
        std::free(address);
    }
}

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
