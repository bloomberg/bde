<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslx_outstreamfunctions.h                                          -*-C++-*-
#ifndef INCLUDED_BSLX_OUTSTREAMFUNCTIONS
#define INCLUDED_BSLX_OUTSTREAMFUNCTIONS

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Facilitate uniform externalization of user and fundamental types.
//
//@CLASSES:
//  bslx::OutStreamFunctions: namespace for BDEX externalization functions
//
//@SEE_ALSO: bslx_instreamfunctions, bslx_versionfunctions
//
//@DESCRIPTION: This component provides a namespace,
// &#39;bslx::OutStreamFunctions&#39;, that facilitates uniform support for BDEX
// externalization across all BDEX-compliant user-defined types, including
// template types and containers, as well as those fundamental types (and
// &#39;bsl::string&#39; and &#39;bsl::vector&#39;) for which the BDEX protocol provides direct
// support.
//
// The namespace &#39;bslx::OutStreamFunctions&#39; facilitates client externalization
// of objects in a uniform, type-independent manner.  It contains the
// &#39;bdexStreamOut&#39; function that externalizes objects of all BDEX-compliant
// types.  This function externalizes the specified &#39;object&#39; in the specified
// &#39;version&#39;.  The &#39;bdexStreamOut&#39; function is overloaded for fundamental
// types, enumeration types, &#39;bsl::string&#39;, and &#39;bsl::vector&#39;.  Note that,
// excluding &#39;bsl::vector&#39;, version information is never written to the stream
// while externalizing these types.
//
// By default, objects of enumeration type are streamed out as 32-bit &#39;int&#39;
// values.  Users can override this behavior by providing overloads of the
// &#39;OutStreamFunctions::bdexStreamOut&#39; function in the enumeration&#39;s namespace
// for their enumeration types.  The general form of this overload is:
//..
//  template &lt;class STREAM&gt;
//  STREAM&amp; bdexStreamOut(STREAM&amp; stream, const MyEnum&amp; value, int version)
//  {
//      using bslx::OutStreamFunctions::bdexStreamOut;
//
//      // Code to stream out objects of &#39;MyEnum&#39; type.
//
//      return stream;
//  }
//..
// For value-semantic types that support the BDEX protocol, the free function
// &#39;bdexStreamOut&#39; calls the &#39;bdexStreamOut&#39; member function for that type.
//
///Component Design, Anticipated Usage, and the BDEX Contract
///----------------------------------------------------------
// &#39;bslx_outstreamfunctions&#39; is an integral part of the BDEX externalization
// contract.  The BDEX contract is at least in part &quot;collaborative&quot;, which is
// to say that each developer of a given *kind* of component (e.g., a stream or
// a value-semantic container) must comply with the relevant portions of the
// contract to ensure that the &quot;system as a whole&quot; works for everybody.
// &#39;bslx_outstreamfunctions&#39; plays several related but different roles in
// helping various developers to produce BDEX-compliant components.  In this
// section we briefly highlight how and why &#39;bslx_outstreamfunctions&#39; is
// helpful (or required) for these different developers.  By discussing
// different aspects of usage, we convey the general design goals of this
// component, and, to a certain extent, the overall BDEX contract.  See the
// &#39;bslx&#39; package-level documentation for a full specification of the BDEX
// contract.
//
///Implementing BDEX Streaming in Value-Semantic Template Classes
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// The author of a non-template value-semantic type has full knowledge of the
// details of the &quot;value&quot; of that type, and may choose to use the appropriate
// output stream &#39;put&#39; methods directly when implementing the required
// &#39;bdexStreamOut&#39; method for that type.  However, if one or more aspects of
// the value are of template parameter type, then the author cannot in general
// know how to stream the value using the &#39;put&#39; methods.  For example, if a
// type has as its value one &#39;int&#39; data member:
//..
//  int d_value;
//..
// then the implementation of the &#39;bdexStreamOut&#39; method can contain:
//..
//  stream.putInt32(d_value);
//..
// However, if the data member is of (template parameter) &#39;TYPE&#39;:
//..
//  TYPE d_value;
//..
// then the implementation of the &#39;bdexStreamOut&#39; method must rely on the
// &#39;bslx::OutStreamFunctions&#39; implementation to output the value:
//..
//  using bslx::OutStreamFunctions::bdexStreamOut;
//  bdexStreamOut(stream, d_value, 1);
//..
// This call will resolve to the correct sequence of &#39;put&#39; calls no matter
// whether &#39;TYPE&#39; is a fundamental type, a BDEX-compliant &#39;enum&#39;, or a proper
// BDEX-compliant class.  In the latter two cases, the explicit specification
// of the version format (in this case, 1) guarantees the stable operation of
// this method whether or not &#39;TYPE&#39; is provided additional version formats.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Using &#39;bslx::OutStreamFunctions&#39; to Externalize Data
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// In this example we illustrate the primary intended use of the parameterized
// methods of this component, as well as a few trivial invocations just to show
// the syntax clearly.  To accomplish this, we exhibit two separate example
// &quot;components&quot;: a value-semantic point object, and an &#39;enum&#39;.  In all cases,
// the component designs are very simple, with much of the implied
// functionality omitted, in order to focus attention on the key aspects of the
// functionality of *this* component.
//
// First, consider an &#39;enum&#39; &#39;Color&#39; that enumerates a set of colors:
//..
//  enum Color {
//      RED   = 0,
//      GREEN = 1,
//      BLUE  = 2
//  };
//..
// Next, we consider a very special-purpose point that has as a data member its
// color.  Such a point provides an excellent opportunity for factoring, but
// since we are interested in highlighting BDEX streaming of various types, we
// will present a simple and unfactored design here.  In a real-world problem,
// the &#39;mypoint&#39; component would be implemented differently.
//
// Note that the &#39;MyPoint&#39; class in this example represents its coordinates as
// &#39;short&#39; integer values; this is done to make the BDEX stream output byte
// pattern somewhat easier for the reader of this example to recognize when the
// output buffer is printed.
//..
//  // mypoint.h
//
//  class MyPoint {
//      // This class provides a geometric point having integer coordinates and
//      // an enumerated color property.
//
//      short d_x;      // x coordinate
//      short d_y;      // y coordinate
//      Color d_color;  // enumerated color property
//
//    public:
//      // CLASS METHODS
//      static int maxSupportedBdexVersion(int versionSelector);
//          // Return the maximum valid BDEX format version, as indicated by
//          // the specified &#39;versionSelector&#39;, to be passed to the
//          // &#39;bdexStreamOut&#39; method.  Note that it is highly recommended that
//          // versionSelector&#39; be formatted as &quot;YYYYMMDD&quot;, a date
//          // representation.  Also note that &#39;versionSelector&#39; should be a
//          // *compile*-time-chosen value that selects a format version
//          // supported by both externalizer and unexternalizer.  See the
//          // &#39;bslx&#39; package-level documentation for more information on BDEX
//          // streaming of value-semantic types and containers.
//
//      // CREATORS
//      MyPoint();
//          // Create a default point.
//
//      MyPoint(short x, short y, Color color);
//          // Create a point having the specified &#39;x&#39; and &#39;y&#39; coordinates
//          // and the specified &#39;color&#39;.
//
//      ~MyPoint();
//          // Destroy this point.
//
//      // MANIPULATORS
//      // ...
//
//      // ACCESSORS
//      int x() const;
//          // Return the x coordinate of this point.
//
//      int y() const;
//          // Return the y coordinate of this point.
//
//      Color color() const;
//          // Return the enumerated color of this point.
//
//      template &lt;class STREAM&gt;
//      STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
//          // Write the value of this object, using the specified &#39;version&#39;
//          // format, to the specified output &#39;stream&#39;, and return a reference
//          // to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation
//          // has no effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is
//          // invalidated, but otherwise unmodified.  Note that &#39;version&#39; is
//          // not written to &#39;stream&#39;.  See the &#39;bslx&#39; package-level
//          // documentation for more information on BDEX streaming of
//          // value-semantic types and containers.
//  };
//
//  // FREE OPERATORS
//  inline
//  bool operator==(const MyPoint&amp; lhs, const MyPoint&amp; rhs);
//      // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; points have the same
//      // value, and &#39;false&#39; otherwise.  Two points have the same value if
//      // they have the same x and y coordinates and the same color.
//..
// Representative (inline) implementations of these methods are shown below:
//..
//  // ========================================================================
//  //                      INLINE FUNCTION DEFINITIONS
//  // ========================================================================
//
//  // CLASS METHODS
//  inline
//  int MyPoint::maxSupportedBdexVersion(int versionSelector)
//  {
//      if (versionSelector &gt;= 20131201) {
//          return 2;
//      }
//      return 1;
//  }
//
//  // CREATORS
//  inline
//  MyPoint::MyPoint(short x, short y, Color color)
//  : d_x(x)
//  , d_y(y)
//  , d_color(color)
//  {
//  }
//
//  inline
//  MyPoint::~MyPoint()
//  {
//  }
//
//  // ...
//
//  // MANIPULATORS
//  // ...
//
//  // ACCESSORS
//  inline
//  int MyPoint::x() const
//  {
//      return d_x;
//  }
//
//  // ...
//
//  template &lt;class STREAM&gt;
//  STREAM&amp; MyPoint::bdexStreamOut(STREAM&amp; stream, int version) const
//  {
//      switch (version) {
//        case 1: {
//          stream.putInt16(d_x);          // output the x coordinate
//          stream.putInt16(d_y);          // output the y coordinate
//          stream.putInt8(static_cast&lt;char&gt;(d_color));
//                                         // output the color enum as one byte
//        } break;
//        default: {
//          stream.invalidate();
//        } break;
//      }
//      return stream;
//  }
//
//  // FREE OPERATORS
//  inline
//  bool operator==(const MyPoint&amp; lhs, const MyPoint&amp; rhs)
//  {
//      return lhs.x()     == rhs.x()
//          &amp;&amp; lhs.y()     == rhs.y()
//          &amp;&amp; lhs.color() == rhs.color();
//  }
//..
// Then, we will implement an extremely simple output stream that supports the
// BDEX documentation-only protocol.  For simplicity, we will use a fixed-size
// buffer (usually a bad idea in any event, and more so here since the
// implementation knows the buffer size, but makes no effort to prevent
// overwriting that buffer), and will only show a few methods needed for this
// example.  See other &#39;bslx&#39; stream components for examples of
// properly-designed BDEX streams.
//..
//  // myoutstream.h
//  // ...
//
//  class MyOutStream {
//      // This class implements a limited-size fixed-buffer output stream that
//      // partially conforms to the BDEX protocol for output streams.  This
//      // class is suitable for demonstration purposes only.
//
//      char d_buffer[1000]; // externalized values stored as contiguous bytes
//
//      int  d_length;       // length of data in &#39;d_buffer&#39; (in bytes)
//
//      bool d_validFlag;    // stream validity flag; &#39;true&#39; if stream is in
//                           // valid state, &#39;false&#39; otherwise
//
//    public:
//      // CREATORS
//      MyOutStream();
//          // Create an empty output stream of limited, fixed capacity.  Note
//          // that this object is suitable for demonstration purposes only.
//
//      ~MyOutStream();
//         // Destroy this output stream.
//
//      // MANIPULATORS
//      void invalidate();
//          // Put this input stream in an invalid state.  This function has no
//          // effect if this stream is already invalid.  Note that this
//          // function should be called whenever a value extracted from this
//          // stream is determined to be invalid, inconsistent, or otherwise
//          // incorrect.
//
//      MyOutStream&amp; putVersion(int version);
//          // Write to this stream the one-byte, two&#39;s complement integer
//          // comprised of the least-significant one byte of the specified
//          // &#39;version&#39;, and return a reference to this stream.
//
//      MyOutStream&amp; putInt32(int value);
//          // Write to this stream the four-byte, two&#39;s complement integer (in
//          // network byte order) comprised of the least-significant four
//          // bytes of the specified &#39;value&#39; (in host byte order), and return
//          // a reference to this stream.
//
//      MyOutStream&amp; putInt16(int value);
//          // Write to this stream the two-byte, two&#39;s complement integer
//          // (in network byte order) comprised of the least-significant two
//          // bytes of the specified &#39;value&#39; (in host byte order), and return
//          // a reference to this stream.
//
//      MyOutStream&amp; putInt8(int value);
//          // Write to this stream the one-byte, two&#39;s complement integer
//          // comprised of the least-significant one byte of the specified
//          // &#39;value&#39;, and return a reference to this stream.
//
//      void removeAll();
//          // Remove all content in this stream.
//
//      // ACCESSORS
//      const char *data() const;
//          // Return the address of the contiguous, non-modifiable internal
//          // memory buffer of this stream.  The address will remain valid as
//          // long as this stream is not destroyed or modified.  The behavior
//          // of accessing elements outside the range
//          // &#39;[ data() .. data() + (length() - 1) ]&#39; is undefined.
//
//      int length() const;
//          // Return the number of bytes in this stream.
//  };
//
//  // FREE OPERATORS
//  inline
//  bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;      stream,
//                           const MyOutStream&amp; object);
//      // Write the specified &#39;object&#39; to the specified output &#39;stream&#39; in
//      // some reasonable (multi-line) format, and return a reference to
//      // &#39;stream&#39;.
//..
// The relevant (inline) implementations are as follows.
//..
//  // ========================================================================
//  //                      INLINE FUNCTION DEFINITIONS
//  // ========================================================================
//
//  // CREATORS
//  inline
//  MyOutStream::MyOutStream()
//  : d_length(0)
//  , d_validFlag(true)
//  {
//  }
//
//  inline
//  MyOutStream::~MyOutStream()
//  {
//  }
//
//  // MANIPULATORS
//  inline
//  void MyOutStream::invalidate()
//  {
//      d_validFlag = false;
//  }
//
//  inline
//  MyOutStream&amp; MyOutStream::putVersion(int value)
//  {
//      d_buffer[d_length] = static_cast&lt;char&gt;(value);
//      ++d_length;
//      return *this;
//  }
//
//  inline
//  MyOutStream&amp; MyOutStream::putInt32(int value)
//  {
//      d_buffer[d_length + 0] = static_cast&lt;char&gt;((value &gt;&gt; 24) &amp; 0xff);
//      d_buffer[d_length + 1] = static_cast&lt;char&gt;((value &gt;&gt; 16) &amp; 0xff);
//      d_buffer[d_length + 2] = static_cast&lt;char&gt;((value &gt;&gt;  8) &amp; 0xff);
//      d_buffer[d_length + 3] = static_cast&lt;char&gt;((value &gt;&gt;  0) &amp; 0xff);
//      d_length += 4;
//      return *this;
//  }
//
//  inline
//  MyOutStream&amp; MyOutStream::putInt16(int value)
//  {
//      d_buffer[d_length + 0] = static_cast&lt;char&gt;((value &gt;&gt; 8) &amp; 0xff);
//      d_buffer[d_length + 1] = static_cast&lt;char&gt;((value &gt;&gt; 0) &amp; 0xff);
//      d_length += 2;
//      return *this;
//  }
//
//  inline
//  MyOutStream&amp; MyOutStream::putInt8(int value)
//  {
//      d_buffer[d_length] = static_cast&lt;char&gt;(value);
//      d_length += 1;
//      return *this;
//  }
//
//  inline
//  void MyOutStream::removeAll()
//  {
//      d_length = 0;
//  }
//
//  // ACCESSORS
//  inline
//  const char *MyOutStream::data() const
//  {
//      return static_cast&lt;const char *&gt;(d_buffer);
//  }
//
//  inline
//  int MyOutStream::length() const
//  {
//      return d_length;
//  }
//..
// Finally, use the above &#39;enum&#39;, point class, and output stream to illustrate
// &#39;bslx::OutStreamFunctions&#39; functionality.  This test code does not attempt
// to do anything more useful than writing known values to a stream and
// confirming that the expected byte pattern was in fact written.
//..
//  int             i     = 168496141;  // byte pattern 0a 0b 0c 0d
//  Color           color = BLUE;       // byte pattern 02
//  MyPoint         p(0, -1, color);    // byte pattern 00 00 ff ff 02
//
//  using bslx::OutStreamFunctions::bdexStreamOut;
//
//  MyOutStream out;
//  assert(0 == out.length());
//
//  bdexStreamOut(out, i, 1);
//  assert(4 == out.length());
//  assert(0 == bsl::memcmp(out.data(), &quot;\x0a\x0b\x0c\x0d&quot;, out.length()));
//
//  out.removeAll();
//  assert(0 == out.length());
//
//  bdexStreamOut(out, i, 0);
//  assert(4 == out.length());
//  assert(0 == bsl::memcmp(out.data(), &quot;\x0a\x0b\x0c\x0d&quot;, out.length()));
//
//  out.removeAll();
//  assert(0 == out.length());
//
//  bdexStreamOut(out, color, 1);
//  assert(4 == out.length());
//  assert(0 == bsl::memcmp(out.data(), &quot;\x00\x00\x00\x02&quot;, out.length()));
//
//  out.removeAll();
//  assert(0 == out.length());
//
//  bdexStreamOut(out, color, 0);
//  assert(4 == out.length());
//  assert(0 == bsl::memcmp(out.data(), &quot;\x00\x00\x00\x02&quot;, out.length()));
//
//  out.removeAll();
//  assert(0 == out.length());
//
//  bdexStreamOut(out, p, 1);
//  assert(5 == out.length());
//  assert(0 == bsl::memcmp(out.data(), &quot;\x00\x00\xff\xff\x02&quot;, out.length()));
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLX_VERSIONFUNCTIONS
#include &lt;bslx_versionfunctions.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLMF_IF
#include &lt;bslmf_if.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISENUM
#include &lt;bslmf_isenum.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDINT
#include &lt;bsl_cstdint.h&gt;
#endif

namespace BloombergLP {
namespace bslx {

                         // ============================
                         // namespace OutStreamFunctions
                         // ============================

namespace OutStreamFunctions {
    // This namespace facilitates externalization of all BDEX-compliant types
    // in a type-independent manner.  The externalization functions are
    // overloaded for fundamental types, enumeration types, &#39;bsl::string&#39;, and
    // &#39;bsl::vector&#39;.  A compilation error will occur if the (template
    // parameter) &#39;TYPE&#39; of a non-overloaded method of
    // &#39;bslx::OutStreamFunctions&#39; does not support &#39;bdexStreamOut&#39; and
    // &#39;maxSupportedBdexVersion&#39; (with the appropriate signatures).

                         // =================
                         // struct IsEnumType
                         // =================

    struct IsEnumType {
        // This &#39;struct&#39;, together with &#39;IsNotEnumType&#39; (below), is used to
        // distinguish enumeration types from other types in function overload
        // resolution.  This &#39;struct&#39; contains no interface or implementation
        // by design, and is meant for internal use only.
    };

                         // ====================
                         // struct IsNotEnumType
                         // ====================

    struct IsNotEnumType {
        // This &#39;struct&#39;, together with &#39;IsEnumType&#39; (above), is used to
        // distinguish enumeration types from other types in function overload
        // resolution.  This &#39;struct&#39; contains no interface or implementation
        // by design, and is meant for internal use only.
    };

    // PRIVATE CLASS METHODS
    template &lt;class STREAM, class TYPE&gt;
    STREAM&amp; bdexStreamOutImp(STREAM&amp;           stream,
                             const TYPE&amp;       value,
                             int               version,
                             const IsEnumType&amp;);
        // Write the specified &#39;value&#39; to the specified output &#39;stream&#39; as a
        // 32-bit &#39;int&#39;, and return a reference to &#39;stream&#39;.  The specified
        // &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that this function is called only for
        // enumeration types and that if &#39;value&#39; is outside the range of an
        // &#39;int32_t&#39; the externalization will be lossy.  Also note that this
        // function is for internal use only.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM, class TYPE&gt;
    STREAM&amp; bdexStreamOutImp(STREAM&amp;              stream,
                             const TYPE&amp;          value,
                             int                  version,
                             const IsNotEnumType&amp;);
        // Write the specified &#39;value&#39;, using the specified &#39;version&#39; format,
        // to the specified output &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation has no
        // effect.  If &#39;version&#39; is not supported by &#39;TYPE&#39;, &#39;stream&#39; is
        // invalidated, but otherwise unmodified.  Note that &#39;version&#39; is not
        // written to &#39;stream&#39;.  Also note that this function is for internal
        // use only.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    // CLASS METHODS
    template &lt;class STREAM, class TYPE&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, const TYPE&amp; value);
        // Write the specified &#39;value&#39; to the specified output &#39;stream&#39;, and
        // return a reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  If needed, first write the computed
        // version information to the &#39;stream&#39; and if this version is not
        // supported by &#39;TYPE&#39;, &#39;stream&#39; is invalidated.  Note that the version
        // is only needed when the (template parameter) &#39;TYPE&#39; is a
        // &#39;bsl::vector&#39; or a user-defined type.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM, class TYPE&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, const TYPE&amp; value, int version);
        // Write the specified &#39;value&#39;, using the specified &#39;version&#39; format,
        // to the specified output &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation has no
        // effect.  If &#39;version&#39; is not supported by &#39;TYPE&#39;, &#39;stream&#39; is
        // invalidated, but otherwise unmodified.  Note that &#39;version&#39; is not
        // written to &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for
        // more information on BDEX streaming of value-semantic types and
        // containers.

                       /* overloads */

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, const bool&amp; value, int version = 0);
        // Write the specified &#39;bool&#39; &#39;value&#39; to the specified output &#39;stream&#39;,
        // and return a reference to &#39;stream&#39;.  The optionally specified
        // &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  See the &#39;bslx&#39; package-level documentation
        // for more information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, const char&amp; value, int version = 0);
        // Write the specified &#39;char&#39; &#39;value&#39; to the specified output &#39;stream&#39;,
        // and return a reference to &#39;stream&#39;.  The optionally specified
        // &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  See the &#39;bslx&#39; package-level documentation
        // for more information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;            stream,
                          const signed char&amp; value,
                          int                version = 0);
        // Write the specified &#39;signed char&#39; &#39;value&#39; to the specified output
        // &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The optionally
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;              stream,
                          const unsigned char&amp; value,
                          int                  version = 0);
        // Write the specified &#39;unsigned char&#39; &#39;value&#39; to the specified output
        // &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The optionally
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;      stream,
                          const short&amp; value,
                          int          version = 0);
        // Write the specified &#39;short&#39; &#39;value&#39; to the specified output
        // &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The optionally
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;               stream,
                          const unsigned short&amp; value,
                          int                   version = 0);
        // Write the specified &#39;unsigned short&#39; &#39;value&#39; to the specified output
        // &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The optionally
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, const int&amp; value, int version = 0);
        // Write the specified &#39;int&#39; &#39;value&#39; to the specified output &#39;stream&#39;,
        // and return a reference to &#39;stream&#39;.  The optionally specified
        // &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;             stream,
                          const unsigned int&amp; value,
                          int                 version = 0);
        // Write the specified &#39;unsigned int&#39; &#39;value&#39; to the specified output
        // &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The optionally
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, const long&amp; value, int version = 0);
        // Write the specified &#39;long&#39; &#39;value&#39; to the specified output &#39;stream&#39;
        // as a 32-bit &#39;int&#39;, and return a reference to &#39;stream&#39;.  The
        // optionally specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially
        // invalid, this operation has no effect.  Note that for platforms
        // where &#39;long&#39; is not equivalent to &#39;int32_t&#39;, this operation may be
        // lossy.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;              stream,
                          const unsigned long&amp; value,
                          int                  version = 0);
        // Write the specified &#39;unsigned long&#39; &#39;value&#39; to the specified output
        // &#39;stream&#39; as a 32-bit &#39;unsigned int&#39;, and return a reference to
        // &#39;stream&#39;.  The optionally specified &#39;version&#39; is ignored.  If
        // &#39;stream&#39; is initially invalid, this operation has no effect.  Note
        // that for platforms where &#39;unsigned long&#39; is not equivalent to
        // &#39;uint32_t&#39;, this operation may be lossy.  See the &#39;bslx&#39;
        // package-level documentation for more information on BDEX streaming
        // of value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;                   stream,
                          const bsls::Types::Int64&amp; value,
                          int                       version = 0);
        // Write the specified &#39;bsls::Types::Int64&#39; &#39;value&#39; to the specified
        // output &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The optionally
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;                    stream,
                          const bsls::Types::Uint64&amp; value,
                          int                        version = 0);
        // Write the specified &#39;bsls::Types::Uint64&#39; &#39;value&#39; to the specified
        // output &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The optionally
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, const float&amp; value, int version = 0);
        // Write the specified &#39;float&#39; &#39;value&#39; to the specified output
        // &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The optionally
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;       stream,
                          const double&amp; value,
                          int           version = 0);
        // Write the specified &#39;double&#39; &#39;value&#39; to the specified output
        // &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The optionally
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;            stream,
                          const bsl::string&amp; value,
                          int                version = 0);
        // Write the specified &#39;bsl::string&#39; &#39;value&#39; to the specified output
        // &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The optionally
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;                         stream,
                          const bsl::vector&lt;char, ALLOC&gt;&amp; value,
                          int                             version);
        // Write the specified &#39;bsl::vector&lt;char, ALLOC&gt;&#39; &#39;value&#39; to the
        // specified output &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;                                stream,
                          const bsl::vector&lt;signed char, ALLOC&gt;&amp; value,
                          int                                    version);
        // Write the specified &#39;bsl::vector&lt;signed char, ALLOC&gt;&#39; &#39;value&#39; to the
        // specified output &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;                                  stream,
                          const bsl::vector&lt;unsigned char, ALLOC&gt;&amp; value,
                          int                                      version);
        // Write the specified &#39;bsl::vector&lt;unsigned char, ALLOC&gt;&#39; &#39;value&#39; to
        // the specified output &#39;stream&#39;, and return a reference to &#39;stream&#39;.
        // The specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially
        // invalid, this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;                          stream,
                          const bsl::vector&lt;short, ALLOC&gt;&amp; value,
                          int                              version);
        // Write the specified &#39;bsl::vector&lt;short, ALLOC&gt;&#39; &#39;value&#39; to the
        // specified output &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;                                   stream,
                          const bsl::vector&lt;unsigned short, ALLOC&gt;&amp; value,
                          int                                       version);
        // Write the specified &#39;bsl::vector&lt;unsigned short, ALLOC&gt;&#39; &#39;value&#39; to
        // the specified output &#39;stream&#39;, and return a reference to &#39;stream&#39;.
        // The specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially
        // invalid, this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;                        stream,
                          const bsl::vector&lt;int, ALLOC&gt;&amp; value,
                          int                            version);
        // Write the specified &#39;bsl::vector&lt;int, ALLOC&gt;&#39; &#39;value&#39; to the
        // specified output &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;                                 stream,
                          const bsl::vector&lt;unsigned int, ALLOC&gt;&amp; value,
                          int                                     version);
        // Write the specified &#39;bsl::vector&lt;unsigned int, ALLOC&gt;&#39; &#39;value&#39; to
        // the specified output &#39;stream&#39;, and return a reference to &#39;stream&#39;.
        // The specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially
        // invalid, this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamOut(
                        STREAM&amp;                                       stream,
                        const bsl::vector&lt;bsls::Types::Int64, ALLOC&gt;&amp; value,
                        int                                           version);
        // Write the specified &#39;bsl::vector&lt;bsls::Types::Int64, ALLOC&gt;&#39; &#39;value&#39;
        // to the specified output &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  The specified &#39;version&#39; is ignored.  If &#39;stream&#39; is
        // initially invalid, this operation has no effect.  See the &#39;bslx&#39;
        // package-level documentation for more information on BDEX streaming
        // of value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamOut(
                       STREAM&amp;                                        stream,
                       const bsl::vector&lt;bsls::Types::Uint64, ALLOC&gt;&amp; value,
                       int                                            version);
        // Write the specified &#39;bsl::vector&lt;bsls::Types::Uint64, ALLOC&gt;&#39;
        // &#39;value&#39; to the specified output &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  The specified &#39;version&#39; is ignored.  If &#39;stream&#39; is
        // initially invalid, this operation has no effect.  See the &#39;bslx&#39;
        // package-level documentation for more information on BDEX streaming
        // of value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;                          stream,
                          const bsl::vector&lt;float, ALLOC&gt;&amp; value,
                          int                              version);
        // Write the specified &#39;bsl::vector&lt;float, ALLOC&gt;&#39; &#39;value&#39; to the
        // specified output &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM, class ALLOC&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;                           stream,
                          const bsl::vector&lt;double, ALLOC&gt;&amp; value,
                          int                               version);
        // Write the specified &#39;bsl::vector&lt;double, ALLOC&gt;&#39; &#39;value&#39; to the
        // specified output &#39;stream&#39;, and return a reference to &#39;stream&#39;.  The
        // specified &#39;version&#39; is ignored.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    template &lt;class STREAM, class TYPE, class ALLOC&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;                         stream,
                          const bsl::vector&lt;TYPE, ALLOC&gt;&amp; value);
        // Write the specified &#39;bsl::vector&lt;TYPE, ALLOC&gt;&#39; &#39;value&#39; to the
        // specified output &#39;stream&#39;, and return a reference to &#39;stream&#39;.  If
        // &#39;stream&#39; is initially invalid, this operation has no effect.  If
        // needed, first write the computed version information to the &#39;stream&#39;
        // and if this version is not supported by &#39;TYPE&#39; and the vector is not
        // empty, &#39;stream&#39; is invalidated.  Note that the version is only
        // needed when the (template parameter) &#39;TYPE&#39; is a &#39;bsl::vector&#39; or a
        // user-defined type.  See the &#39;bslx&#39; package-level documentation for
        // more information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM, class TYPE, class ALLOC&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp;                         stream,
                          const bsl::vector&lt;TYPE, ALLOC&gt;&amp; value,
                          int                             version);
        // Write the specified &#39;bsl::vector&lt;TYPE, ALLOC&gt;&#39; &#39;value&#39;, using the
        // specified &#39;version&#39; format, to the specified output &#39;stream&#39;, and
        // return a reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid,
        // this operation has no effect.  If &#39;version&#39; is not supported by
        // &#39;TYPE&#39; and the vector is not empty, &#39;stream&#39; is invalidated, but
        // otherwise unmodified.  Note that the specified &#39;TYPE&#39; might not
        // require a &#39;version&#39; to be serialized and that &#39;version&#39; is not
        // written to &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for
        // more information on BDEX streaming of value-semantic types and
        // containers.

}  // close namespace OutStreamFunctions

// ============================================================================
//                          INLINE FUNCTION DEFINITIONS
// ============================================================================

                         // ----------------------------
                         // namespace OutStreamFunctions
                         // ----------------------------

template &lt;class STREAM, class TYPE&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOutImp(STREAM&amp;           stream,
                                             const TYPE&amp;       value,
                                             int            /* version */,
                                             const IsEnumType&amp;)
{
    // A compilation error indicating the next line of code implies the &#39;TYPE&#39;
    // cannot be represented as a 32-bit &#39;int&#39; and an overload for the
    // &#39;OutStreamFunctions::bdexStreamOut&#39; function, in the enumeration&#39;s
    // namespace, should be provided.

    BSLMF_ASSERT(sizeof(TYPE) &lt;= sizeof(bsl::int32_t));

    // Stream the &#39;enum&#39; value as a 32-bit &#39;int&#39;.
    return stream.putInt32(static_cast&lt;int&gt;(value));
}

template &lt;class STREAM, class TYPE&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOutImp(STREAM&amp;              stream,
                                             const TYPE&amp;          value,
                                             int                  version,
                                             const IsNotEnumType&amp;)
{
    // A compilation error indicating the next line of code implies the class
    // of &#39;TYPE&#39; does not support the &#39;bdexStreamOut&#39; method.

    return value.bdexStreamOut(stream, version);
}

template &lt;class STREAM, class TYPE&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp; stream, const TYPE&amp; value)
{
    using VersionFunctions::maxSupportedBdexVersion;

    const int version = maxSupportedBdexVersion(&amp;value,
                                                stream.bdexVersionSelector());
    if (VersionFunctions::k_NO_VERSION != version) {
        stream.putVersion(version);
    }

    return bdexStreamOut(stream, value, version);
}

template &lt;class STREAM, class TYPE&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp;     stream,
                                          const TYPE&amp; value,
                                          int         version)
{
    typedef typename bslmf::If&lt;bslmf::IsEnum&lt;TYPE&gt;::value,
                               IsEnumType,
                               IsNotEnumType&gt;::Type dummyType;
    return bdexStreamOutImp(stream, value, version, dummyType());
}

template &lt;class STREAM&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp;     stream,
                                          const bool&amp; value,
                                          int      /* version */)
{
    return stream.putInt8(static_cast&lt;char&gt;(value));
}

template &lt;class STREAM&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp;     stream,
                                          const char&amp; value,
                                          int      /* version */)
{
    return stream.putInt8(value);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp;            stream,
                                          const signed char&amp; value,
                                          int             /* version */)
{
    return stream.putInt8(value);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp;              stream,
                                          const unsigned char&amp; value,
                                          int               /* version */)
{
    return stream.putUint8(value);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp;      stream,
                                          const short&amp; value,
                                          int       /* version */)
{
    return stream.putInt16(value);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp;               stream,
                                          const unsigned short&amp; value,
                                          int                /* version */)
{
    return stream.putUint16(value);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp;    stream,
                                          const int&amp; value,
                                          int     /* version */)
{
    return stream.putInt32(value);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp;             stream,
                                          const unsigned int&amp; value,
                                          int              /* version */)
{
    return stream.putUint32(value);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp;     stream,
                                          const long&amp; value,
                                          int      /* version */)
{
    return stream.putInt32(static_cast&lt;int&gt;(value));
}

template &lt;class STREAM&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp;              stream,
                                          const unsigned long&amp; value,
                                          int               /* version */)
{
    return stream.putUint32(static_cast&lt;unsigned int&gt;(value));
}

template &lt;class STREAM&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp;                   stream,
                                          const bsls::Types::Int64&amp; value,
                                          int                    /* version */)
{
    return stream.putInt64(value);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(
                                         STREAM&amp;                    stream,
                                         const bsls::Types::Uint64&amp; value,
                                         int                     /* version */)
{
    return stream.putUint64(value);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp;      stream,
                                          const float&amp; value,
                                          int       /* version */)
{
    return stream.putFloat32(value);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp;       stream,
                                          const double&amp; value,
                                          int        /* version */)
{
    return stream.putFloat64(value);
}

template &lt;class STREAM&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(STREAM&amp;            stream,
                                          const bsl::string&amp; value,
                                          int             /* version */)
{
    return stream.putString(value);
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(
                                    STREAM&amp;                         stream,
                                    const bsl::vector&lt;char, ALLOC&gt;&amp; value,
                                    int                          /* version */)
{
    const int length = static_cast&lt;int&gt;(value.size());
    stream.putLength(length);

    return 0 &lt; length ? stream.putArrayInt8(&amp;value[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(
                             STREAM&amp;                                stream,
                             const bsl::vector&lt;signed char, ALLOC&gt;&amp; value,
                             int                                 /* version */)
{
    const int length = static_cast&lt;int&gt;(value.size());
    stream.putLength(length);

    return 0 &lt; length ? stream.putArrayInt8(&amp;value[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(
                           STREAM&amp;                                  stream,
                           const bsl::vector&lt;unsigned char, ALLOC&gt;&amp; value,
                           int                                   /* version */)
{
    const int length = static_cast&lt;int&gt;(value.size());
    stream.putLength(length);

    return 0 &lt; length ? stream.putArrayUint8(&amp;value[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(
                                   STREAM&amp;                          stream,
                                   const bsl::vector&lt;short, ALLOC&gt;&amp; value,
                                   int                           /* version */)
{
    const int length = static_cast&lt;int&gt;(value.size());
    stream.putLength(length);

    return 0 &lt; length ? stream.putArrayInt16(&amp;value[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(
                          STREAM&amp;                                   stream,
                          const bsl::vector&lt;unsigned short, ALLOC&gt;&amp; value,
                          int                                    /* version */)
{
    const int length = static_cast&lt;int&gt;(value.size());
    stream.putLength(length);

    return 0 &lt; length ? stream.putArrayUint16(&amp;value[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(
                                     STREAM&amp;                        stream,
                                     const bsl::vector&lt;int, ALLOC&gt;&amp; value,
                                     int                         /* version */)
{
    const int length = static_cast&lt;int&gt;(value.size());
    stream.putLength(length);

    return 0 &lt; length ? stream.putArrayInt32(&amp;value[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(
                            STREAM&amp;                                 stream,
                            const bsl::vector&lt;unsigned int, ALLOC&gt;&amp; value,
                            int                                  /* version */)
{
    const int length = static_cast&lt;int&gt;(value.size());
    stream.putLength(length);

    return 0 &lt; length ? stream.putArrayUint32(&amp;value[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(
                      STREAM&amp;                                       stream,
                      const bsl::vector&lt;bsls::Types::Int64, ALLOC&gt;&amp; value,
                      int                                        /* version */)
{
    const int length = static_cast&lt;int&gt;(value.size());
    stream.putLength(length);

    return 0 &lt; length ? stream.putArrayInt64(&amp;value[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(
                     STREAM&amp;                                        stream,
                     const bsl::vector&lt;bsls::Types::Uint64, ALLOC&gt;&amp; value,
                     int                                         /* version */)
{
    const int length = static_cast&lt;int&gt;(value.size());
    stream.putLength(length);

    return 0 &lt; length ? stream.putArrayUint64(&amp;value[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(
                                   STREAM&amp;                          stream,
                                   const bsl::vector&lt;float, ALLOC&gt;&amp; value,
                                   int                           /* version */)
{
    const int length = static_cast&lt;int&gt;(value.size());
    stream.putLength(length);

    return 0 &lt; length ? stream.putArrayFloat32(&amp;value[0], length) : stream;
}

template &lt;class STREAM, class ALLOC&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(
                                  STREAM&amp;                           stream,
                                  const bsl::vector&lt;double, ALLOC&gt;&amp; value,
                                  int                            /* version */)
{
    const int length = static_cast&lt;int&gt;(value.size());
    stream.putLength(length);

    return 0 &lt; length ? stream.putArrayFloat64(&amp;value[0], length) : stream;
}

template &lt;class STREAM, class TYPE, class ALLOC&gt;
inline
STREAM&amp; OutStreamFunctions::bdexStreamOut(
                                        STREAM&amp;                         stream,
                                        const bsl::vector&lt;TYPE, ALLOC&gt;&amp; value)
{
    using VersionFunctions::maxSupportedBdexVersion;

    const int version = maxSupportedBdexVersion(&amp;value,
                                                stream.bdexVersionSelector());

    stream.putVersion(version);
    return bdexStreamOut(stream, value, version);
}

template &lt;class STREAM, class TYPE, class ALLOC&gt;
STREAM&amp; OutStreamFunctions::bdexStreamOut(
                                       STREAM&amp;                         stream,
                                       const bsl::vector&lt;TYPE, ALLOC&gt;&amp; value,
                                       int                             version)
{
    typedef typename bsl::vector&lt;TYPE, ALLOC&gt;::const_iterator Iterator;

    const int length = static_cast&lt;int&gt;(value.size());
    stream.putLength(length);

    for (Iterator it = value.begin(); it != value.end(); ++it) {
        bdexStreamOut(stream, *it, version);
    }

    return stream;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
