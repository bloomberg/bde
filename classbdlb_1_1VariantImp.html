<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlb::VariantImp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlb.html">bdlb</a>      </li>
      <li><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp&lt; TYPES &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlb::VariantImp&lt; TYPES &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlb::VariantImp" -->
<p><code>#include &lt;<a class="el" href="bdlb__variant_8h_source.html">bdlb_variant.h</a>&gt;</code></p>

<p><a href="classbdlb_1_1VariantImp-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ad4cb5a21e55a725a65df694b212153c0">BSLMF_NESTED_TRAIT_DECLARATION_IF</a> (<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>, <a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>, Traits::k_VARIANT_USES_BSLMA_ALLOCATOR)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a32cab2873477483af8131be1bc07a09b">BSLMF_NESTED_TRAIT_DECLARATION_IF</a> (<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>, <a class="el" href="structbsl_1_1is__trivially__copyable.html">bsl::is_trivially_copyable</a>, Traits::k_VARIANT_IS_BITWISE_COPYABLE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a9cd7543df79ed2407548ee42e90730de">BSLMF_NESTED_TRAIT_DECLARATION_IF</a> (<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>, <a class="el" href="structbslmf_1_1IsBitwiseMoveable.html">bslmf::IsBitwiseMoveable</a>, Traits::k_VARIANT_IS_BITWISE_MOVEABLE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a9b6c68e8c0b6ee9b71c2341b8bd0cb2e">BSLMF_NESTED_TRAIT_DECLARATION</a> (<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>, <a class="el" href="structbdlb_1_1HasPrintMethod.html">HasPrintMethod</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a312de4bb6e76ae136a3140a6e318e236">VariantImp</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE_OR_ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a3bea7eff5004b7e6dfe53f699dea3886">VariantImp</a> (const TYPE_OR_ALLOCATOR &amp;typeOrAlloc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a37888ab152f7ea8a0f1faf93d94c76d2">VariantImp</a> (const TYPE &amp;value, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a06a03f25bb6df1ccdfceeb7ee6fd558b">VariantImp</a> (const <a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a> &amp;original, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a253837e3e7ad69e778cb3729dc0641f1">~VariantImp</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a8f97697cd28feab8391f4c3ec964e490">operator=</a> (const TYPE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a1b6be2c0fb629f7b1d66d7be3ae65fe3">operator=</a> (const <a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a> &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#adb101113e18074b8505b805a41223aca">apply</a> (VISITOR &amp;visitor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a6be1807dfbad0a238ee8e86f04a602ef">apply</a> (const VISITOR &amp;visitor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ae026b1ec6ce386f79df27bcae5095e7b">apply</a> (VISITOR &amp;visitor, const TYPE &amp;defaultValue)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a4d326b36c512e898c296fc85628f1fd4">apply</a> (const VISITOR &amp;visitor, const TYPE &amp;defaultValue)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a3498eb7142531106fc2f0fcf0d2da048">apply</a> (VISITOR &amp;visitor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ac742413e7dcd96c2616c61687f47fa02">apply</a> (const VISITOR &amp;visitor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ae16dc8d814ae0526c4b01afeff2468f9">apply</a> (VISITOR &amp;visitor, const TYPE &amp;defaultValue)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a9d36ef713685b260c8f49e2f351bb10e">apply</a> (const VISITOR &amp;visitor, const TYPE &amp;defaultValue)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET_TYPE , class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#af5013ec99d595e043c7bd9c6f4848a1a">apply</a> (VISITOR &amp;visitor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET_TYPE , class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#aac0a70a70a7624c596946ce233568729">apply</a> (const VISITOR &amp;visitor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET_TYPE , class VISITOR , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a72244d9987e7cfe977d8886496b1318f">apply</a> (VISITOR &amp;visitor, const TYPE &amp;defaultValue)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET_TYPE , class VISITOR , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a1dd418efc55f677c047eaf72515a5296">apply</a> (const VISITOR &amp;visitor, const TYPE &amp;defaultValue)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a49a2f2ad828c95f4509968410065902c">applyRaw</a> (VISITOR &amp;visitor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ac3dc427ff8b114ca6d9912aeb9a70509">applyRaw</a> (const VISITOR &amp;visitor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a95eb485c396800b6ecbbd398a1028def">applyRaw</a> (VISITOR &amp;visitor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a9508f2c5f01b2e0f57f60316252b5742">applyRaw</a> (const VISITOR &amp;visitor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET_TYPE , class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a1e3fc332e52d38502782757de28fe1c2">applyRaw</a> (VISITOR &amp;visitor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET_TYPE , class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a5f375f4f3550e0edc61334141db24a83">applyRaw</a> (const VISITOR &amp;visitor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ac33e36612ea9abffc9dfa36313b28572">assign</a> (const TYPE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , class SOURCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ac9e7872b8e4a6e0d9369a28b56438e34">assignTo</a> (const SOURCE_TYPE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a439d5f8acd4b43a94d16b58131746c53">createInPlace</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , class A1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ad4f4327412acef29630615a49f3e2b49">createInPlace</a> (const A1 &amp;a1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , class A1 , class A2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#aab5f7438ce8b607a3dc2ceae5060713e">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , class A1 , class A2 , class A3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a8e2d13dfd58e838b29030bf286def834">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#acf5cf76575cc460012ccaaddcd908a9a">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a88a84dc69e6d1bfffe8ef7a0bd610ebf">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#adc1b8f2f21a1f452509e6d4734d07162">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a65c1b4932550561a75882315dbe76ab3">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ad8b1980441158ef0a50f2a14db3f6e7c">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#af394aa26741fba5094940f7643077f8f">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a9a4bc79b9a7856bc04c33a0040315ede">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a6850996bc498c51d509657e7ab586442">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a11c5fc455e6040e076764ae60306ae72">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a95b79086652841c41a73539c91a0f2b1">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a0d9b0c176c9ea1151d63d07c045e2d94">createInPlace</a> (const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a0097d0243c3e44e8ea97a2f68d2cc0f9">reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#abfeb64b810b52e56dd14ca7be3535475">swap</a> (<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a> &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">TYPE &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a85b613762bdadf870e483a9991c5e4a9">the</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#af586fd4ed208906fb5b483a5a3e083cf">apply</a> (VISITOR &amp;visitor) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#aac9e8406f3d1b84e8097e6762176c486">apply</a> (const VISITOR &amp;visitor) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a5ccf228532d68f4268f425fdee18d76d">apply</a> (VISITOR &amp;visitor, const TYPE &amp;defaultValue) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a29581a916dde16b7f173ca2cb3a70984">apply</a> (const VISITOR &amp;visitor, const TYPE &amp;defaultValue) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ab56eb7ec3868f812931515c98d923f8a">apply</a> (VISITOR &amp;visitor) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#af00bd438b8d24bd3e3aa533981e9bb5d">apply</a> (const VISITOR &amp;visitor) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ae96a144d889177e6a8d46c5a0bc5564f">apply</a> (VISITOR &amp;visitor, const TYPE &amp;defaultValue) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a98ec3a6c252c6cadf1ae9f3399c5158d">apply</a> (const VISITOR &amp;visitor, const TYPE &amp;defaultValue) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET_TYPE , class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a8efc00326eb4915f7115b267e18c6d74">apply</a> (VISITOR &amp;visitor) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET_TYPE , class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a40c0b811ebc75e498b4e19c509f7aa48">apply</a> (const VISITOR &amp;visitor) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET_TYPE , class VISITOR , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a5b463b58a2d92ef2967c58ec0a70bcae">apply</a> (VISITOR &amp;visitor, const TYPE &amp;defaultValue) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET_TYPE , class VISITOR , class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a368a2294b3fecb0c3974b47decb27d0a">apply</a> (const VISITOR &amp;visitor, const TYPE &amp;defaultValue) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a273341128334d6bd2e0dc225903fc9e2">applyRaw</a> (VISITOR &amp;visitor) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==1, <br class="typebreak"/>
typename VISITOR::ResultType &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a601e31b22354bdd8696980217d8f7ece">applyRaw</a> (const VISITOR &amp;visitor) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a62637a61fdc40f1f6cf0c59c5dcc18a0">applyRaw</a> (VISITOR &amp;visitor) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; <a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a><br class="typebreak"/>
&lt; VISITOR &gt;::value==0, void &gt;<br class="typebreak"/>
::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#afdad7a39dd5235a9857a971c7e32e773">applyRaw</a> (const VISITOR &amp;visitor) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET_TYPE , class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a9fa5a573fa079eb39e4e3c8b9f760815">applyRaw</a> (VISITOR &amp;visitor) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RET_TYPE , class VISITOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">RET_TYPE&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a399ed4ce14fc0eb57a084f2bf684ffca">applyRaw</a> (const VISITOR &amp;visitor) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a48ae24053b35755570230d2519b5057f">is</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ad651fa0b1d445834f8473b4a6579199a">isUnset</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#ac0ca6dd8afb4d29339e70c9d32705314">print</a> (bsl::ostream &amp;stream, int level=0, int spacesPerLevel=4) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const TYPE &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a1f4fc3faf86c8b1df43c82acc4d5a3c3">the</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlb_1_1VariantImp.html#a46db5dc454d69d36b323347fbea4e68e">typeIndex</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPES&gt;<br/>
 class bdlb::VariantImp&lt; TYPES &gt;</h3>

<p>This class provides the implementation of <code><a class="el" href="classbdlb_1_1Variant.html">Variant</a></code> (except for the creators) given a list of template parameter <code>TYPES</code>.</p>
<p>More generally, if each of the types in the list of <code>TYPES</code> is value-semantic, then this class also supports a complete set of <em>value</em> <em>semantic</em> operations, including copy construction, assignment, equality comparison, and <code>ostream</code> printing. A precise operational definition of when two instances have the same value can be found in the description of <code>operator==</code> for the class. This class is <em>exception</em> <em>neutral</em> with no guarantee of rollback: if an exception is thrown during the invocation of a method on a pre-existing instance, the object is left in a valid state, but its value is undefined. In no event is memory leaked. Finally, <em>aliasing</em> (e.g., using all or part of an object as both source and destination) is supported in all cases.</p>
<p>If any of the types in the list of <code>TYPES</code> does not support <code>operator==</code>, or any of the value-semantic operations mentioned above, then this variant also does not support that operation and attempts to invoke it will trigger a compilation diagnostic. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a312de4bb6e76ae136a3140a6e318e236"></a><!-- doxytag: member="bdlb::VariantImp::VariantImp" ref="a312de4bb6e76ae136a3140a6e318e236" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a variant object in the unset state that uses the currently installed default allocator to supply memory. </p>

</div>
</div>
<a class="anchor" id="a3bea7eff5004b7e6dfe53f699dea3886"></a><!-- doxytag: member="bdlb::VariantImp::VariantImp" ref="a3bea7eff5004b7e6dfe53f699dea3886" args="(const TYPE_OR_ALLOCATOR &amp;typeOrAlloc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE_OR_ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a> </td>
          <td>(</td>
          <td class="paramtype">const TYPE_OR_ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>typeOrAlloc</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a variant object with the specified <code>typeOrAlloc</code> that can be either a value of a type that the variant can hold or an allocator to supply memory. If <code>typeOrAlloc</code> is not a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>, then the variant will hold the value and type of <code>typeOrAlloc</code>, and use the currently installed default allocator to supply memory. Otherwise, the variant will be unset and use <code>typeOrAlloc</code> to supply memory. Note that this parameterized constructor is defined instead of two constructors (one taking a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code> and the other not) because template parameter arguments are always a better match than derived-to-base conversion (a concrete allocator pointer converted to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>). </p>

</div>
</div>
<a class="anchor" id="a37888ab152f7ea8a0f1faf93d94c76d2"></a><!-- doxytag: member="bdlb::VariantImp::VariantImp" ref="a37888ab152f7ea8a0f1faf93d94c76d2" args="(const TYPE &amp;value, bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a> </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a variant object having the specified <code>value</code> and that uses the specified <code>basicAllocator</code> to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a06a03f25bb6df1ccdfceeb7ee6fd558b"></a><!-- doxytag: member="bdlb::VariantImp::VariantImp" ref="a06a03f25bb6df1ccdfceeb7ee6fd558b" args="(const VariantImp &amp;original, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; TYPES &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a variant object having the type and value of the specified <code>original</code> variant. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed / default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a253837e3e7ad69e778cb3729dc0641f1"></a><!-- doxytag: member="bdlb::VariantImp::~VariantImp" ref="a253837e3e7ad69e778cb3729dc0641f1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::~<a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this variant object, invoking the destructor of the type of object contained (if any) on the value of that type. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad4cb5a21e55a725a65df694b212153c0"></a><!-- doxytag: member="bdlb::VariantImp::BSLMF_NESTED_TRAIT_DECLARATION_IF" ref="ad4cb5a21e55a725a65df694b212153c0" args="(VariantImp, bslma::UsesBslmaAllocator, Traits::k_VARIANT_USES_BSLMA_ALLOCATOR)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::BSLMF_NESTED_TRAIT_DECLARATION_IF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; TYPES &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Traits::k_VARIANT_USES_BSLMA_ALLOCATOR&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a32cab2873477483af8131be1bc07a09b"></a><!-- doxytag: member="bdlb::VariantImp::BSLMF_NESTED_TRAIT_DECLARATION_IF" ref="a32cab2873477483af8131be1bc07a09b" args="(VariantImp, bsl::is_trivially_copyable, Traits::k_VARIANT_IS_BITWISE_COPYABLE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::BSLMF_NESTED_TRAIT_DECLARATION_IF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; TYPES &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsl_1_1is__trivially__copyable.html">bsl::is_trivially_copyable</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Traits::k_VARIANT_IS_BITWISE_COPYABLE&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9cd7543df79ed2407548ee42e90730de"></a><!-- doxytag: member="bdlb::VariantImp::BSLMF_NESTED_TRAIT_DECLARATION_IF" ref="a9cd7543df79ed2407548ee42e90730de" args="(VariantImp, bslmf::IsBitwiseMoveable, Traits::k_VARIANT_IS_BITWISE_MOVEABLE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::BSLMF_NESTED_TRAIT_DECLARATION_IF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; TYPES &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1IsBitwiseMoveable.html">bslmf::IsBitwiseMoveable</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Traits::k_VARIANT_IS_BITWISE_MOVEABLE&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9b6c68e8c0b6ee9b71c2341b8bd0cb2e"></a><!-- doxytag: member="bdlb::VariantImp::BSLMF_NESTED_TRAIT_DECLARATION" ref="a9b6c68e8c0b6ee9b71c2341b8bd0cb2e" args="(VariantImp, HasPrintMethod)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; TYPES &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbdlb_1_1HasPrintMethod.html">HasPrintMethod</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8f97697cd28feab8391f4c3ec964e490"></a><!-- doxytag: member="bdlb::VariantImp::operator=" ref="a8f97697cd28feab8391f4c3ec964e490" args="(const TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&amp; <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the specified <code>value</code> of template parameter <code>TYPE</code>, and return a reference providing modifiable access to this object. The value previously held by this variant (if any) will be destroyed if the value's type is different from the template parameter <code>TYPE</code>. </p>

<p>Reimplemented in <a class="el" href="classbdlb_1_1Variant.html#a3f4c7f13ab69b4422333684183d00b16">bdlb::Variant&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20 &gt;</a>, <a class="el" href="classbdlb_1_1Variant2.html#aaf869c53913f32c736d47d51acf62e86">bdlb::Variant2&lt; A1, A2 &gt;</a>, <a class="el" href="classbdlb_1_1Variant3.html#a664c2755db6649f25e2f058ac764fa6a">bdlb::Variant3&lt; A1, A2, A3 &gt;</a>, <a class="el" href="classbdlb_1_1Variant4.html#ae2d8d741408c154e7348e81759249340">bdlb::Variant4&lt; A1, A2, A3, A4 &gt;</a>, <a class="el" href="classbdlb_1_1Variant5.html#a30b9f0a1ec25118bef8cb29fd8256f14">bdlb::Variant5&lt; A1, A2, A3, A4, A5 &gt;</a>, <a class="el" href="classbdlb_1_1Variant6.html#a980e357186fbe2134ea87faffb0ac0a3">bdlb::Variant6&lt; A1, A2, A3, A4, A5, A6 &gt;</a>, <a class="el" href="classbdlb_1_1Variant7.html#ae9d42611faeae189a65b55a130216fa7">bdlb::Variant7&lt; A1, A2, A3, A4, A5, A6, A7 &gt;</a>, <a class="el" href="classbdlb_1_1Variant8.html#a90f6ffe884b0248979c3b6826ee2307c">bdlb::Variant8&lt; A1, A2, A3, A4, A5, A6, A7, A8 &gt;</a>, <a class="el" href="classbdlb_1_1Variant9.html#af43cf645d9a3a164e92ebac09d32582d">bdlb::Variant9&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9 &gt;</a>, <a class="el" href="classbdlb_1_1Variant10.html#aac62f119a309245a63e82f8974d7ba03">bdlb::Variant10&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10 &gt;</a>, <a class="el" href="classbdlb_1_1Variant11.html#a4f69aabb2d76fa95f058aa1ec6398809">bdlb::Variant11&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11 &gt;</a>, <a class="el" href="classbdlb_1_1Variant12.html#a4cdf48b177e9909a5ec4cc0f01ffc587">bdlb::Variant12&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12 &gt;</a>, <a class="el" href="classbdlb_1_1Variant13.html#aa1588918913fec95f2ea84265d53cde9">bdlb::Variant13&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13 &gt;</a>, <a class="el" href="classbdlb_1_1Variant14.html#ada38ea5267d4082bdb31284a2c78719b">bdlb::Variant14&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14 &gt;</a>, <a class="el" href="classbdlb_1_1Variant15.html#a791d58fbe310c94b7cb793da02f49dff">bdlb::Variant15&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15 &gt;</a>, <a class="el" href="classbdlb_1_1Variant16.html#adf0905664d0c3e145e70242d701d19be">bdlb::Variant16&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16 &gt;</a>, <a class="el" href="classbdlb_1_1Variant17.html#adf666ad6408cd19af7c8c99fa3dd3e02">bdlb::Variant17&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17 &gt;</a>, <a class="el" href="classbdlb_1_1Variant18.html#a4e1e483655687a13a970d65d5a4db606">bdlb::Variant18&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18 &gt;</a>, <a class="el" href="classbdlb_1_1Variant19.html#adf8cd3961b9f712215ade22dd7741547">bdlb::Variant19&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19 &gt;</a>, <a class="el" href="classbdlb_1_1Variant.html#a3f4c7f13ab69b4422333684183d00b16">bdlb::Variant&lt; int, bsls::Types::Int64, bsl::string &gt;</a>, and <a class="el" href="classbdlb_1_1Variant.html#a3f4c7f13ab69b4422333684183d00b16">bdlb::Variant&lt; bsl::int64_t, double, bsl::string, bdlt::DatetimeTz &gt;</a>.</p>

<p>Referenced by <a class="el" href="classbdlb_1_1Variant15.html#ac42145a3e7d50509e43f8d3613cb465b">bdlb::Variant15&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15 &gt;::operator=()</a>, <a class="el" href="classbdlb_1_1Variant14.html#a47c11c47a2f11fa01620f2b858185adf">bdlb::Variant14&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14 &gt;::operator=()</a>, <a class="el" href="classbdlb_1_1Variant13.html#ad83d521180a15bd96fc88d13d35f0297">bdlb::Variant13&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13 &gt;::operator=()</a>, <a class="el" href="classbdlb_1_1Variant12.html#a904d1c1a76493f771c07510f9731825b">bdlb::Variant12&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12 &gt;::operator=()</a>, <a class="el" href="classbdlb_1_1Variant11.html#ada561d2857830ccaef94dbc738efd479">bdlb::Variant11&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11 &gt;::operator=()</a>, <a class="el" href="classbdlb_1_1Variant10.html#a5a28e4942cdd7b65f2bf8b73649b473e">bdlb::Variant10&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9, A10 &gt;::operator=()</a>, <a class="el" href="classbdlb_1_1Variant9.html#aef16bf7328ce06b5ef45c9f32530faac">bdlb::Variant9&lt; A1, A2, A3, A4, A5, A6, A7, A8, A9 &gt;::operator=()</a>, <a class="el" href="classbdlb_1_1Variant8.html#a90f6ffe884b0248979c3b6826ee2307c">bdlb::Variant8&lt; A1, A2, A3, A4, A5, A6, A7, A8 &gt;::operator=()</a>, <a class="el" href="classbdlb_1_1Variant7.html#ae9d42611faeae189a65b55a130216fa7">bdlb::Variant7&lt; A1, A2, A3, A4, A5, A6, A7 &gt;::operator=()</a>, <a class="el" href="classbdlb_1_1Variant6.html#a980e357186fbe2134ea87faffb0ac0a3">bdlb::Variant6&lt; A1, A2, A3, A4, A5, A6 &gt;::operator=()</a>, <a class="el" href="classbdlb_1_1Variant5.html#a30b9f0a1ec25118bef8cb29fd8256f14">bdlb::Variant5&lt; A1, A2, A3, A4, A5 &gt;::operator=()</a>, <a class="el" href="classbdlb_1_1Variant4.html#ae2d8d741408c154e7348e81759249340">bdlb::Variant4&lt; A1, A2, A3, A4 &gt;::operator=()</a>, <a class="el" href="classbdlb_1_1Variant3.html#a664c2755db6649f25e2f058ac764fa6a">bdlb::Variant3&lt; A1, A2, A3 &gt;::operator=()</a>, and <a class="el" href="classbdlb_1_1Variant2.html#aaf869c53913f32c736d47d51acf62e86">bdlb::Variant2&lt; A1, A2 &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a1b6be2c0fb629f7b1d66d7be3ae65fe3"></a><!-- doxytag: member="bdlb::VariantImp::operator=" ref="a1b6be2c0fb629f7b1d66d7be3ae65fe3" args="(const VariantImp &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&amp; <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; TYPES &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the type and value currently held by the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. The value previously held by this variant (if any) will be destroyed if the value's type is different from the type held by the <code>rhs</code> object. </p>

</div>
</div>
<a class="anchor" id="adb101113e18074b8505b805a41223aca"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="adb101113e18074b8505b805a41223aca" args="(VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a6be1807dfbad0a238ee8e86f04a602ef"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="a6be1807dfbad0a238ee8e86f04a602ef" args="(const VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. If If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="ae026b1ec6ce386f79df27bcae5095e7b"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="ae026b1ec6ce386f79df27bcae5095e7b" args="(VISITOR &amp;visitor, const TYPE &amp;defaultValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a4d326b36c512e898c296fc85628f1fd4"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="a4d326b36c512e898c296fc85628f1fd4" args="(const VISITOR &amp;visitor, const TYPE &amp;defaultValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a3498eb7142531106fc2f0fcf0d2da048"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="a3498eb7142531106fc2f0fcf0d2da048" args="(VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="ac742413e7dcd96c2616c61687f47fa02"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="ac742413e7dcd96c2616c61687f47fa02" args="(const VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="ae16dc8d814ae0526c4b01afeff2468f9"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="ae16dc8d814ae0526c4b01afeff2468f9" args="(VISITOR &amp;visitor, const TYPE &amp;defaultValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="a9d36ef713685b260c8f49e2f351bb10e"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="a9d36ef713685b260c8f49e2f351bb10e" args="(const VISITOR &amp;visitor, const TYPE &amp;defaultValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="af5013ec99d595e043c7bd9c6f4848a1a"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="af5013ec99d595e043c7bd9c6f4848a1a" args="(VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class RET_TYPE , class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aac0a70a70a7624c596946ce233568729"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="aac0a70a70a7624c596946ce233568729" args="(const VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class RET_TYPE , class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value (of template parameter <code>RET_TYPE</code>) returned by the <code>visitor</code>. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. </p>

</div>
</div>
<a class="anchor" id="a72244d9987e7cfe977d8886496b1318f"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="a72244d9987e7cfe977d8886496b1318f" args="(VISITOR &amp;visitor, const TYPE &amp;defaultValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class RET_TYPE , class VISITOR , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1dd418efc55f677c047eaf72515a5296"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="a1dd418efc55f677c047eaf72515a5296" args="(const VISITOR &amp;visitor, const TYPE &amp;defaultValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class RET_TYPE , class VISITOR , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value (of template parameter <code>RET_TYPE</code>) returned by the <code>visitor</code>. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. </p>

</div>
</div>
<a class="anchor" id="a49a2f2ad828c95f4509968410065902c"></a><!-- doxytag: member="bdlb::VariantImp::applyRaw" ref="a49a2f2ad828c95f4509968410065902c" args="(VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="ac3dc427ff8b114ca6d9912aeb9a70509"></a><!-- doxytag: member="bdlb::VariantImp::applyRaw" ref="ac3dc427ff8b114ca6d9912aeb9a70509" args="(const VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a95eb485c396800b6ecbbd398a1028def"></a><!-- doxytag: member="bdlb::VariantImp::applyRaw" ref="a95eb485c396800b6ecbbd398a1028def" args="(VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a9508f2c5f01b2e0f57f60316252b5742"></a><!-- doxytag: member="bdlb::VariantImp::applyRaw" ref="a9508f2c5f01b2e0f57f60316252b5742" args="(const VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a1e3fc332e52d38502782757de28fe1c2"></a><!-- doxytag: member="bdlb::VariantImp::applyRaw" ref="a1e3fc332e52d38502782757de28fe1c2" args="(VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class RET_TYPE , class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f375f4f3550e0edc61334141db24a83"></a><!-- doxytag: member="bdlb::VariantImp::applyRaw" ref="a5f375f4f3550e0edc61334141db24a83" args="(const VISITOR &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class RET_TYPE , class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the specified <code>visitor</code> to this modifiable variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value (of template parameter <code>RET_TYPE</code>) returned by the <code>visitor</code>. The behavior is undefined if this variant is unset. </p>

</div>
</div>
<a class="anchor" id="ac33e36612ea9abffc9dfa36313b28572"></a><!-- doxytag: member="bdlb::VariantImp::assign" ref="ac33e36612ea9abffc9dfa36313b28572" args="(const TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&amp; <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the specified <code>value</code> of template parameter <code>TYPE</code>, and return a reference providing modifiable access to this object. The value previously held by this variant (if any) will be destroyed if the value's type is different from <code>TYPE</code>. </p>

</div>
</div>
<a class="anchor" id="ac9e7872b8e4a6e0d9369a28b56438e34"></a><!-- doxytag: member="bdlb::VariantImp::assignTo" ref="ac9e7872b8e4a6e0d9369a28b56438e34" args="(const SOURCE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE , class SOURCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&amp; <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::assignTo </td>
          <td>(</td>
          <td class="paramtype">const SOURCE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the specified <code>value</code> of template parameter <code>SOURCE_TYPE</code>, and return a reference providing modifiable access to this object. The value previously held by this variant (if any) will be destroyed if the value's type is different from the template parameter <code>TYPE</code>. </p>

</div>
</div>
<a class="anchor" id="a439d5f8acd4b43a94d16b58131746c53"></a><!-- doxytag: member="bdlb::VariantImp::createInPlace" ref="a439d5f8acd4b43a94d16b58131746c53" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4f4327412acef29630615a49f3e2b49"></a><!-- doxytag: member="bdlb::VariantImp::createInPlace" ref="ad4f4327412acef29630615a49f3e2b49" args="(const A1 &amp;a1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE , class A1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aab5f7438ce8b607a3dc2ceae5060713e"></a><!-- doxytag: member="bdlb::VariantImp::createInPlace" ref="aab5f7438ce8b607a3dc2ceae5060713e" args="(const A1 &amp;a1, const A2 &amp;a2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE , class A1 , class A2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e2d13dfd58e838b29030bf286def834"></a><!-- doxytag: member="bdlb::VariantImp::createInPlace" ref="a8e2d13dfd58e838b29030bf286def834" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE , class A1 , class A2 , class A3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acf5cf76575cc460012ccaaddcd908a9a"></a><!-- doxytag: member="bdlb::VariantImp::createInPlace" ref="acf5cf76575cc460012ccaaddcd908a9a" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a88a84dc69e6d1bfffe8ef7a0bd610ebf"></a><!-- doxytag: member="bdlb::VariantImp::createInPlace" ref="a88a84dc69e6d1bfffe8ef7a0bd610ebf" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adc1b8f2f21a1f452509e6d4734d07162"></a><!-- doxytag: member="bdlb::VariantImp::createInPlace" ref="adc1b8f2f21a1f452509e6d4734d07162" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a65c1b4932550561a75882315dbe76ab3"></a><!-- doxytag: member="bdlb::VariantImp::createInPlace" ref="a65c1b4932550561a75882315dbe76ab3" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8b1980441158ef0a50f2a14db3f6e7c"></a><!-- doxytag: member="bdlb::VariantImp::createInPlace" ref="ad8b1980441158ef0a50f2a14db3f6e7c" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af394aa26741fba5094940f7643077f8f"></a><!-- doxytag: member="bdlb::VariantImp::createInPlace" ref="af394aa26741fba5094940f7643077f8f" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a4bc79b9a7856bc04c33a0040315ede"></a><!-- doxytag: member="bdlb::VariantImp::createInPlace" ref="a9a4bc79b9a7856bc04c33a0040315ede" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6850996bc498c51d509657e7ab586442"></a><!-- doxytag: member="bdlb::VariantImp::createInPlace" ref="a6850996bc498c51d509657e7ab586442" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a11c5fc455e6040e076764ae60306ae72"></a><!-- doxytag: member="bdlb::VariantImp::createInPlace" ref="a11c5fc455e6040e076764ae60306ae72" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a95b79086652841c41a73539c91a0f2b1"></a><!-- doxytag: member="bdlb::VariantImp::createInPlace" ref="a95b79086652841c41a73539c91a0f2b1" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0d9b0c176c9ea1151d63d07c045e2d94"></a><!-- doxytag: member="bdlb::VariantImp::createInPlace" ref="a0d9b0c176c9ea1151d63d07c045e2d94" args="(const A1 &amp;a1, const A2 &amp;a2, const A3 &amp;a3, const A4 &amp;a4, const A5 &amp;a5, const A6 &amp;a6, const A7 &amp;a7, const A8 &amp;a8, const A9 &amp;a9, const A10 &amp;a10, const A11 &amp;a11, const A12 &amp;a12, const A13 &amp;a13, const A14 &amp;a14)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 , class A10 , class A11 , class A12 , class A13 , class A14 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::createInPlace </td>
          <td>(</td>
          <td class="paramtype">const A1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A2 &amp;&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A3 &amp;&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A4 &amp;&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A5 &amp;&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A6 &amp;&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A7 &amp;&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A8 &amp;&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A9 &amp;&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A10 &amp;&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A11 &amp;&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A12 &amp;&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A13 &amp;&nbsp;</td>
          <td class="paramname"> <em>a13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A14 &amp;&nbsp;</td>
          <td class="paramname"> <em>a14</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an instance of the template parameter <code>TYPE</code> in this variant object with up to 14 parameters using the allocator currently held by this variant to supply memory. This method first destroys the current value held by the variant (even if <code>TYPE</code> is the same as the current type held). The behavior is undefined unless <code>TYPE</code> is one of the types that this variant holds. Note the order of the template arguments was chosen so that <code>TYPE</code> must always be specified. </p>

</div>
</div>
<a class="anchor" id="a0097d0243c3e44e8ea97a2f68d2cc0f9"></a><!-- doxytag: member="bdlb::VariantImp::reset" ref="a0097d0243c3e44e8ea97a2f68d2cc0f9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the current value held by this variant (if any), and reset this variant to the unset state. </p>

</div>
</div>
<a class="anchor" id="abfeb64b810b52e56dd14ca7be3535475"></a><!-- doxytag: member="bdlb::VariantImp::swap" ref="abfeb64b810b52e56dd14ca7be3535475" args="(VariantImp &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlb_1_1VariantImp.html">VariantImp</a>&lt; TYPES &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap the value of this object with the value of the specified <code>other</code> object. This method provides the no-throw guarantee if the <code>TYPE</code> template parameter has a no-throw <code>swap</code> and the two variant objects being swapped have the same type; otherwise this method provides the basic guarantee. </p>

</div>
</div>
<a class="anchor" id="a85b613762bdadf870e483a9991c5e4a9"></a><!-- doxytag: member="bdlb::VariantImp::the" ref="a85b613762bdadf870e483a9991c5e4a9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE&amp; <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::the </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the value of the template parameter <code>TYPE</code> held by this variant object. The behavior is undefined unless <code>is&lt;TYPE&gt;()</code> returns <code>true</code> and <code>TYPE</code> is not <code>void</code>. Note that <code>TYPE</code> must be specified explicitly, e.g., <code>myValue.the&lt;int&gt;()</code>. </p>

</div>
</div>
<a class="anchor" id="af586fd4ed208906fb5b483a5a3e083cf"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="af586fd4ed208906fb5b483a5a3e083cf" args="(VISITOR &amp;visitor) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="aac9e8406f3d1b84e8097e6762176c486"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="aac9e8406f3d1b84e8097e6762176c486" args="(const VISITOR &amp;visitor) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the 'visitor. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a5ccf228532d68f4268f425fdee18d76d"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="a5ccf228532d68f4268f425fdee18d76d" args="(VISITOR &amp;visitor, const TYPE &amp;defaultValue) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a29581a916dde16b7f173ca2cb3a70984"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="a29581a916dde16b7f173ca2cb3a70984" args="(const VISITOR &amp;visitor, const TYPE &amp;defaultValue) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="ab56eb7ec3868f812931515c98d923f8a"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="ab56eb7ec3868f812931515c98d923f8a" args="(VISITOR &amp;visitor) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="af00bd438b8d24bd3e3aa533981e9bb5d"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="af00bd438b8d24bd3e3aa533981e9bb5d" args="(const VISITOR &amp;visitor) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="ae96a144d889177e6a8d46c5a0bc5564f"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="ae96a144d889177e6a8d46c5a0bc5564f" args="(VISITOR &amp;visitor, const TYPE &amp;defaultValue) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="a98ec3a6c252c6cadf1ae9f3399c5158d"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="a98ec3a6c252c6cadf1ae9f3399c5158d" args="(const VISITOR &amp;visitor, const TYPE &amp;defaultValue) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
<p>RETURN </p>
</p>

</div>
</div>
<a class="anchor" id="a8efc00326eb4915f7115b267e18c6d74"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="a8efc00326eb4915f7115b267e18c6d74" args="(VISITOR &amp;visitor) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class RET_TYPE , class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a40c0b811ebc75e498b4e19c509f7aa48"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="a40c0b811ebc75e498b4e19c509f7aa48" args="(const VISITOR &amp;visitor) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class RET_TYPE , class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value (of template parameter <code>RET_TYPE</code>) returned by the <code>visitor</code>. If the variant is unset, a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the <code>visitor</code>. </p>

</div>
</div>
<a class="anchor" id="a5b463b58a2d92ef2967c58ec0a70bcae"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="a5b463b58a2d92ef2967c58ec0a70bcae" args="(VISITOR &amp;visitor, const TYPE &amp;defaultValue) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class RET_TYPE , class VISITOR , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a368a2294b3fecb0c3974b47decb27d0a"></a><!-- doxytag: member="bdlb::VariantImp::apply" ref="a368a2294b3fecb0c3974b47decb27d0a" args="(const VISITOR &amp;visitor, const TYPE &amp;defaultValue) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class RET_TYPE , class VISITOR , class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>defaultValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value (of template parameter <code>RET_TYPE</code>) returned by the <code>visitor</code>. If the variant is unset, the specified <code>defaultValue</code> is passed to the <code>visitor</code>. </p>

</div>
</div>
<a class="anchor" id="a273341128334d6bd2e0dc225903fc9e2"></a><!-- doxytag: member="bdlb::VariantImp::applyRaw" ref="a273341128334d6bd2e0dc225903fc9e2" args="(VISITOR &amp;visitor) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value (of template parameter <code>RET_TYPE</code>) returned by the <code>visitor</code>. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a601e31b22354bdd8696980217d8f7ece"></a><!-- doxytag: member="bdlb::VariantImp::applyRaw" ref="a601e31b22354bdd8696980217d8f7ece" args="(const VISITOR &amp;visitor) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 1, typename VISITOR::ResultType&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value returned by the <code>visitor</code>. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> defines a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a62637a61fdc40f1f6cf0c59c5dcc18a0"></a><!-- doxytag: member="bdlb::VariantImp::applyRaw" ref="a62637a61fdc40f1f6cf0c59c5dcc18a0" args="(VISITOR &amp;visitor) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="afdad7a39dd5235a9857a971c7e32e773"></a><!-- doxytag: member="bdlb::VariantImp::applyRaw" ref="afdad7a39dd5235a9857a971c7e32e773" args="(const VISITOR &amp;visitor) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;<a class="el" href="structbdlb_1_1Variant__ReturnValueHelper.html">Variant_ReturnValueHelper</a>&lt;VISITOR&gt;::value == 0, void&gt;::type <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>&lt; Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>. This method does not return a value. The behavior is undefined if this variant is unset. Note that this method is selected only if the template parameter type <code>VISITOR</code> does not define a <code>typedef</code> of <code>ResultType</code> in its public interface. Also note that this method is defined inline to work around a Windows compiler bug with SFINAE functions.</p>
</p>

</div>
</div>
<a class="anchor" id="a9fa5a573fa079eb39e4e3c8b9f760815"></a><!-- doxytag: member="bdlb::VariantImp::applyRaw" ref="a9fa5a573fa079eb39e4e3c8b9f760815" args="(VISITOR &amp;visitor) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class RET_TYPE , class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a399ed4ce14fc0eb57a084f2bf684ffca"></a><!-- doxytag: member="bdlb::VariantImp::applyRaw" ref="a399ed4ce14fc0eb57a084f2bf684ffca" args="(const VISITOR &amp;visitor) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class RET_TYPE , class VISITOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RET_TYPE <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::applyRaw </td>
          <td>(</td>
          <td class="paramtype">const VISITOR &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply the specified <code>visitor</code> to this variant by passing the value this variant currently holds to the <code>visitor</code> object's <code>operator()</code>, and return the value (of template parameter <code>RET_TYPE</code>) returned by the <code>visitor</code>. The behavior is undefined if this variant is unset. </p>

</div>
</div>
<a class="anchor" id="a48ae24053b35755570230d2519b5057f"></a><!-- doxytag: member="bdlb::VariantImp::is" ref="a48ae24053b35755570230d2519b5057f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::is </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the value held by this variant object is of the template parameter <code>TYPE</code>, and <code>false</code> otherwise. Note that <code>TYPE</code> must be specified explicitly, e.g., <code>myValue.is&lt;int&gt;()</code>. </p>

</div>
</div>
<a class="anchor" id="ad651fa0b1d445834f8473b4a6579199a"></a><!-- doxytag: member="bdlb::VariantImp::isUnset" ref="ad651fa0b1d445834f8473b4a6579199a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::isUnset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this variant is currently unset, and <code>false</code> otherwise. An unset variant does not hold a value or type. Note that this method should be preferred over checking the type index of the variant. </p>

</div>
</div>
<a class="anchor" id="ac0ca6dd8afb4d29339e70c9d32705314"></a><!-- doxytag: member="bdlb::VariantImp::print" ref="ac0ca6dd8afb4d29339e70c9d32705314" args="(bsl::ostream &amp;stream, int level=0, int spacesPerLevel=4) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::print </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>spacesPerLevel</em> = <code>4</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Format this object to the specified output <code>stream</code> at the (absolute value of) the optionally specified indentation <code>level</code> and return a reference to <code>stream</code>. If <code>level</code> is specified, optionally specify <code>spacesPerLevel</code>, the number of spaces per indentation level for this and all of its nested objects. If <code>level</code> is negative, suppress indentation of the first line. If <code>spacesPerLevel</code> is negative, format the entire output on one line, suppressing all but the initial indentation (as governed by <code>level</code>). If <code>stream</code> is not valid on entry, this operation has no effect. Note that the string "(* UNPRINTABLE *)" will be printed if the object held by this variant is not printable, and the string "(* NULL *)" will be printed if this variant holds no object. </p>

</div>
</div>
<a class="anchor" id="a1f4fc3faf86c8b1df43c82acc4d5a3c3"></a><!-- doxytag: member="bdlb::VariantImp::the" ref="a1f4fc3faf86c8b1df43c82acc4d5a3c3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TYPE&amp; <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::the </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the value of the template parameter <code>TYPE</code> held by this variant object. The behavior is undefined unless <code>is&lt;TYPE&gt;()</code> returns <code>true</code> and <code>TYPE</code> is not <code>void</code>. Note that <code>TYPE</code> must be specified explicitly, e.g., <code>myValue.the&lt;int&gt;()</code>. </p>

</div>
</div>
<a class="anchor" id="a46db5dc454d69d36b323347fbea4e68e"></a><!-- doxytag: member="bdlb::VariantImp::typeIndex" ref="a46db5dc454d69d36b323347fbea4e68e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt; TYPES &gt;::typeIndex </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index in the list of <code>TYPES</code> corresponding to the type of the value currently held by this variant object (starting at 1), or 0 if this object is unset. Note that instead of switching code on the type index, calling <code>apply</code> is the preferred method of manipulating different types stored inside a variant. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlb__variant_8h_source.html">bdlb_variant.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:35 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
