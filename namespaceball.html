<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Namespace ball</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>ball Namespace Reference<br/>
<small>
[<a class="el" href="group__ball__administration.html">Component ball_administration</a>,&nbsp;<a class="el" href="group__ball__asyncfileobserver.html">Component ball_asyncfileobserver</a>,&nbsp;<a class="el" href="group__ball__attribute.html">Component ball_attribute</a>,&nbsp;<a class="el" href="group__ball__attributecontainer.html">Component ball_attributecontainer</a>,&nbsp;<a class="el" href="group__ball__attributecontainerlist.html">Component ball_attributecontainerlist</a>,&nbsp;<a class="el" href="group__ball__attributecontext.html">Component ball_attributecontext</a>,&nbsp;<a class="el" href="group__ball__categorymanager.html">Component ball_categorymanager</a>,&nbsp;<a class="el" href="group__ball__context.html">Component ball_context</a>,&nbsp;<a class="el" href="group__ball__countingallocator.html">Component ball_countingallocator</a>,&nbsp;<a class="el" href="group__ball__defaultattributecontainer.html">Component ball_defaultattributecontainer</a>,&nbsp;<a class="el" href="group__ball__defaultobserver.html">Component ball_defaultobserver</a>,&nbsp;<a class="el" href="group__ball__fileobserver.html">Component ball_fileobserver</a>,&nbsp;<a class="el" href="group__ball__fileobserver2.html">Component ball_fileobserver2</a>,&nbsp;<a class="el" href="group__ball__fixedsizerecordbuffer.html">Component ball_fixedsizerecordbuffer</a>,&nbsp;<a class="el" href="group__ball__log.html">Component ball_log</a>,&nbsp;<a class="el" href="group__ball__loggercategoryutil.html">Component ball_loggercategoryutil</a>,&nbsp;<a class="el" href="group__ball__loggerfunctorpayloads.html">Component ball_loggerfunctorpayloads</a>,&nbsp;<a class="el" href="group__ball__loggermanager.html">Component ball_loggermanager</a>,&nbsp;<a class="el" href="group__ball__loggermanagerconfiguration.html">Component ball_loggermanagerconfiguration</a>,&nbsp;<a class="el" href="group__ball__loggermanagerdefaults.html">Component ball_loggermanagerdefaults</a>,&nbsp;<a class="el" href="group__ball__multiplexobserver.html">Component ball_multiplexobserver</a>,&nbsp;<a class="el" href="group__ball__observer.html">Component ball_observer</a>,&nbsp;<a class="el" href="group__ball__observeradapter.html">Component ball_observeradapter</a>,&nbsp;<a class="el" href="group__ball__patternutil.html">Component ball_patternutil</a>,&nbsp;<a class="el" href="group__ball__predicate.html">Component ball_predicate</a>,&nbsp;<a class="el" href="group__ball__predicateset.html">Component ball_predicateset</a>,&nbsp;<a class="el" href="group__ball__record.html">Component ball_record</a>,&nbsp;<a class="el" href="group__ball__recordattributes.html">Component ball_recordattributes</a>,&nbsp;<a class="el" href="group__ball__recordbuffer.html">Component ball_recordbuffer</a>,&nbsp;<a class="el" href="group__ball__recordstringformatter.html">Component ball_recordstringformatter</a>,&nbsp;<a class="el" href="group__ball__rule.html">Component ball_rule</a>,&nbsp;<a class="el" href="group__ball__ruleset.html">Component ball_ruleset</a>,&nbsp;<a class="el" href="group__ball__scopedattribute.html">Component ball_scopedattribute</a>,&nbsp;<a class="el" href="group__ball__scopedattributes.html">Component ball_scopedattributes</a>,&nbsp;<a class="el" href="group__ball__severity.html">Component ball_severity</a>,&nbsp;<a class="el" href="group__ball__severityutil.html">Component ball_severityutil</a>,&nbsp;<a class="el" href="group__ball__testobserver.html">Component ball_testobserver</a>,&nbsp;<a class="el" href="group__ball__thresholdaggregate.html">Component ball_thresholdaggregate</a>,&nbsp;<a class="el" href="group__ball__transmission.html">Component ball_transmission</a>,&nbsp;<a class="el" href="group__ball__userfields.html">Component ball_userfields</a>,&nbsp;<a class="el" href="group__ball__userfieldsschema.html">Component ball_userfieldsschema</a>,&nbsp;<a class="el" href="group__ball__userfieldtype.html">Component ball_userfieldtype</a>,&nbsp;<a class="el" href="group__ball__userfieldvalue.html">Component ball_userfieldvalue</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1Administration.html">Administration</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1AsyncFileObserver.html">AsyncFileObserver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1Attribute.html">Attribute</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1AttributeContainer.html">AttributeContainer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1AttributeContainerListIterator.html">AttributeContainerListIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1AttributeContainerList.html">AttributeContainerList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1AttributeContainerList__Node.html">AttributeContainerList_Node</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1AttributeContext__RuleEvaluationCache.html">AttributeContext_RuleEvaluationCache</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1AttributeContext.html">AttributeContext</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1AttributeContextProctor.html">AttributeContextProctor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1CategoryManager.html">CategoryManager</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1Context.html">Context</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1CountingAllocator.html">CountingAllocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1DefaultAttributeContainer.html">DefaultAttributeContainer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1DefaultObserver.html">DefaultObserver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1FileObserver.html">FileObserver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1FileObserver2.html">FileObserver2</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1FixedSizeRecordBuffer.html">FixedSizeRecordBuffer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1Log.html">Log</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1Log__Stream.html">Log_Stream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1Log__Formatter.html">Log_Formatter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1LoggerCategoryUtil.html">LoggerCategoryUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1LoggerFunctorPayloads.html">LoggerFunctorPayloads</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1Logger.html">Logger</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1LoggerManager.html">LoggerManager</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1LoggerManagerScopedGuard.html">LoggerManagerScopedGuard</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1LoggerManagerConfiguration.html">LoggerManagerConfiguration</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1LoggerManagerDefaults.html">LoggerManagerDefaults</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1MultiplexObserver.html">MultiplexObserver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1Observer.html">Observer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1ObserverAdapter.html">ObserverAdapter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1PatternUtil.html">PatternUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1Predicate.html">Predicate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1PredicateSet.html">PredicateSet</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1Record.html">Record</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RecordAttributes.html">RecordAttributes</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RecordBuffer.html">RecordBuffer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RecordStringFormatter.html">RecordStringFormatter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1Rule.html">Rule</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1RuleSet.html">RuleSet</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1ScopedAttribute__Container.html">ScopedAttribute_Container</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1ScopedAttribute.html">ScopedAttribute</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1ScopedAttributes.html">ScopedAttributes</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1Severity.html">Severity</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1SeverityUtil.html">SeverityUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1TestObserver.html">TestObserver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1ThresholdAggregate.html">ThresholdAggregate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1Transmission.html">Transmission</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1UserFields.html">UserFields</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1UserFieldsSchema.html">UserFieldsSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1UserFieldType.html">UserFieldType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classball_1_1UserFieldValue.html">UserFieldValue</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#ab251677d5a48547c5949a5d1ba55d80f">operator==</a> (const <a class="el" href="classball_1_1Attribute.html">Attribute</a> &amp;lhs, const <a class="el" href="classball_1_1Attribute.html">Attribute</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#aab8cb87f866505f08a130b815133ad9b">operator!=</a> (const <a class="el" href="classball_1_1Attribute.html">Attribute</a> &amp;lhs, const <a class="el" href="classball_1_1Attribute.html">Attribute</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a5639cbfb9daac95171eda5204c58f199">operator&lt;&lt;</a> (bsl::ostream &amp;output, const <a class="el" href="classball_1_1Attribute.html">Attribute</a> &amp;attribute)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a1012e79caa118d83bef184c35e26cf7f">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classball_1_1AttributeContainer.html">AttributeContainer</a> &amp;container)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#ac7420e2a6cae38f34f67a8ec9e0bbc73">operator==</a> (const <a class="el" href="classball_1_1AttributeContainerListIterator.html">AttributeContainerListIterator</a> &amp;lhs, const <a class="el" href="classball_1_1AttributeContainerListIterator.html">AttributeContainerListIterator</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a915a9682b36c89c11a3bfdb3d91cf109">operator!=</a> (const <a class="el" href="classball_1_1AttributeContainerListIterator.html">AttributeContainerListIterator</a> &amp;lhs, const <a class="el" href="classball_1_1AttributeContainerListIterator.html">AttributeContainerListIterator</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#add07f19dba561ceb0ad1653d58a377f9">operator==</a> (const <a class="el" href="classball_1_1AttributeContainerList.html">AttributeContainerList</a> &amp;lhs, const <a class="el" href="classball_1_1AttributeContainerList.html">AttributeContainerList</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#afb270495d27912e99d5e03ac379bf4af">operator!=</a> (const <a class="el" href="classball_1_1AttributeContainerList.html">AttributeContainerList</a> &amp;lhs, const <a class="el" href="classball_1_1AttributeContainerList.html">AttributeContainerList</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#adce97ac148b8a7d8e2ad5234f5598647">operator&lt;&lt;</a> (bsl::ostream &amp;output, const <a class="el" href="classball_1_1AttributeContainerList.html">AttributeContainerList</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a488463520fab3d5b46dc88ffc6526675">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classball_1_1AttributeContext__RuleEvaluationCache.html">AttributeContext_RuleEvaluationCache</a> &amp;cache)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a630ca3fb7e0dc95791f6de7c3edb2c9b">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classball_1_1AttributeContext.html">AttributeContext</a> &amp;context)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a52e82a518433605990d22761905a0d45">operator==</a> (const <a class="el" href="classball_1_1Context.html">Context</a> &amp;lhs, const <a class="el" href="classball_1_1Context.html">Context</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a2ea632a45935e596e50084f5ac4ada42">operator!=</a> (const <a class="el" href="classball_1_1Context.html">Context</a> &amp;lhs, const <a class="el" href="classball_1_1Context.html">Context</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a1470609e28f6cb8219e4d45fe5ce8f5d">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classball_1_1Context.html">Context</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a83db3e0a2c1dce67b099b01950664eda">operator==</a> (const <a class="el" href="classball_1_1DefaultAttributeContainer.html">DefaultAttributeContainer</a> &amp;lhs, const <a class="el" href="classball_1_1DefaultAttributeContainer.html">DefaultAttributeContainer</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a893f2a0cc2cbcb3d2d46a44f722ec0c9">operator!=</a> (const <a class="el" href="classball_1_1DefaultAttributeContainer.html">DefaultAttributeContainer</a> &amp;lhs, const <a class="el" href="classball_1_1DefaultAttributeContainer.html">DefaultAttributeContainer</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#aad1c3be23a449d5cc0d1a7c0e0bc6fe6">operator&lt;&lt;</a> (bsl::ostream &amp;output, const <a class="el" href="classball_1_1DefaultAttributeContainer.html">DefaultAttributeContainer</a> &amp;attributeContainer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#abda88586aee46e8e51b223c3b1999917">operator==</a> (const <a class="el" href="classball_1_1LoggerManagerConfiguration.html">LoggerManagerConfiguration</a> &amp;lhs, const <a class="el" href="classball_1_1LoggerManagerConfiguration.html">LoggerManagerConfiguration</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a147e114b969b0ae3a36e8c999ba4af48">operator!=</a> (const <a class="el" href="classball_1_1LoggerManagerConfiguration.html">LoggerManagerConfiguration</a> &amp;lhs, const <a class="el" href="classball_1_1LoggerManagerConfiguration.html">LoggerManagerConfiguration</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a1cb9beb73f11bcdf5948910cd9534333">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classball_1_1LoggerManagerConfiguration.html">LoggerManagerConfiguration</a> &amp;configuration)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a3eda19e2fe2609b33bf008e954f89323">operator==</a> (const <a class="el" href="classball_1_1LoggerManagerDefaults.html">LoggerManagerDefaults</a> &amp;lhs, const <a class="el" href="classball_1_1LoggerManagerDefaults.html">LoggerManagerDefaults</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#acbf7ab1f8750d1e3404d83f364aba80b">operator!=</a> (const <a class="el" href="classball_1_1LoggerManagerDefaults.html">LoggerManagerDefaults</a> &amp;lhs, const <a class="el" href="classball_1_1LoggerManagerDefaults.html">LoggerManagerDefaults</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a571124eb0aaa4379234c7c27bcdd7d34">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classball_1_1LoggerManagerDefaults.html">LoggerManagerDefaults</a> &amp;defaults)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#aa5e40d8af1174eb139c44a11470798cb">operator==</a> (const <a class="el" href="classball_1_1Predicate.html">Predicate</a> &amp;lhs, const <a class="el" href="classball_1_1Predicate.html">Predicate</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a9acc58ede6c3a8fc61b6d642880f9424">operator!=</a> (const <a class="el" href="classball_1_1Predicate.html">Predicate</a> &amp;lhs, const <a class="el" href="classball_1_1Predicate.html">Predicate</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a0038b774a873014029257e75abb961d6">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classball_1_1Predicate.html">Predicate</a> &amp;predicate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a722c42f68c273803d920c48b76605da9">operator==</a> (const <a class="el" href="classball_1_1PredicateSet.html">PredicateSet</a> &amp;lhs, const <a class="el" href="classball_1_1PredicateSet.html">PredicateSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a97578794a1e66cb37e452d509a4e90e1">operator!=</a> (const <a class="el" href="classball_1_1PredicateSet.html">PredicateSet</a> &amp;lhs, const <a class="el" href="classball_1_1PredicateSet.html">PredicateSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a7237b4a1cce1068f20df94a66ebfe500">operator&lt;&lt;</a> (bsl::ostream &amp;output, const <a class="el" href="classball_1_1PredicateSet.html">PredicateSet</a> &amp;predicateSet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#ad8fd47b65d6742a7725ba68f3c5b1175">operator==</a> (const <a class="el" href="classball_1_1Record.html">Record</a> &amp;lhs, const <a class="el" href="classball_1_1Record.html">Record</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#afdc1df5ba7ee30231eaab50bfe812f8b">operator!=</a> (const <a class="el" href="classball_1_1Record.html">Record</a> &amp;lhs, const <a class="el" href="classball_1_1Record.html">Record</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a59fb44f8fb49dc78d7244195cccc88b0">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classball_1_1Record.html">Record</a> &amp;record)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#ab9ab0e2ceaa08363ca44c7dadd5f12ef">operator==</a> (const <a class="el" href="classball_1_1RecordAttributes.html">RecordAttributes</a> &amp;lhs, const <a class="el" href="classball_1_1RecordAttributes.html">RecordAttributes</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a9ffc33126cf91ef08e1767327cdccfd7">operator!=</a> (const <a class="el" href="classball_1_1RecordAttributes.html">RecordAttributes</a> &amp;lhs, const <a class="el" href="classball_1_1RecordAttributes.html">RecordAttributes</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a5d212e9743bbd106e4b6d16f3ec01dba">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classball_1_1RecordAttributes.html">RecordAttributes</a> &amp;attributes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#aef6eea39e4c290fac8955c9c06ab96f8">operator==</a> (const <a class="el" href="classball_1_1RecordStringFormatter.html">RecordStringFormatter</a> &amp;lhs, const <a class="el" href="classball_1_1RecordStringFormatter.html">RecordStringFormatter</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#aba2da51788beec672c814ae8e1c70d9d">operator!=</a> (const <a class="el" href="classball_1_1RecordStringFormatter.html">RecordStringFormatter</a> &amp;lhs, const <a class="el" href="classball_1_1RecordStringFormatter.html">RecordStringFormatter</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a99199c76577b5a79f7a7e42e44ffe4f4">operator&lt;&lt;</a> (bsl::ostream &amp;output, const <a class="el" href="classball_1_1RecordStringFormatter.html">RecordStringFormatter</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a0481afef00e1f4697d75215dcaef694e">operator==</a> (const <a class="el" href="classball_1_1Rule.html">Rule</a> &amp;lhs, const <a class="el" href="classball_1_1Rule.html">Rule</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a14b95c30fc289965b30f6e903f46728a">operator!=</a> (const <a class="el" href="classball_1_1Rule.html">Rule</a> &amp;lhs, const <a class="el" href="classball_1_1Rule.html">Rule</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a90b9d98de4075161a4fa0a8f23c15455">operator&lt;&lt;</a> (bsl::ostream &amp;output, const <a class="el" href="classball_1_1Rule.html">Rule</a> &amp;rule)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#ad10390a9da6095f6bb1633fb6efcae62">operator==</a> (const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;lhs, const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a5e197f366a4063268227bded7db7fc2d">operator!=</a> (const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;lhs, const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a1561fbb0607fcfbab7d27473cff6bb70">operator&lt;&lt;</a> (bsl::ostream &amp;output, const <a class="el" href="classball_1_1RuleSet.html">RuleSet</a> &amp;rules)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#af476a355693cec559a6e3a32ff62e579">operator&lt;&lt;</a> (bsl::ostream &amp;stream, <a class="el" href="structball_1_1Severity.html#af49f66189615b9475c9cced03afde384">Severity::Level</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#aea4e2480e7ee666d322e15c984561c97">operator==</a> (const <a class="el" href="classball_1_1ThresholdAggregate.html">ThresholdAggregate</a> &amp;lhs, const <a class="el" href="classball_1_1ThresholdAggregate.html">ThresholdAggregate</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a28dc6b9c54e1813b215be090ff23bebe">operator!=</a> (const <a class="el" href="classball_1_1ThresholdAggregate.html">ThresholdAggregate</a> &amp;lhs, const <a class="el" href="classball_1_1ThresholdAggregate.html">ThresholdAggregate</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a898158231b34e9ff17365003922cf36a">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classball_1_1ThresholdAggregate.html">ThresholdAggregate</a> &amp;aggregate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#acf000d1cdabf90d5a3a6746cf70ee81f">operator&lt;&lt;</a> (bsl::ostream &amp;stream, <a class="el" href="structball_1_1Transmission.html#a0a918d700a10b34f454db48c83e6b884">Transmission::Cause</a> rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a38157894386a30bddcebd304526b6c84">operator==</a> (const <a class="el" href="classball_1_1UserFields.html">UserFields</a> &amp;lhs, const <a class="el" href="classball_1_1UserFields.html">UserFields</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#ad69614178aa220fe7a7054c11c067d16">operator!=</a> (const <a class="el" href="classball_1_1UserFields.html">UserFields</a> &amp;lhs, const <a class="el" href="classball_1_1UserFields.html">UserFields</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#aa58bb07e36eee360acb89446abc6373c">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classball_1_1UserFields.html">UserFields</a> &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a4f1ef43d8e35464e858a25f9cbe03dec">swap</a> (<a class="el" href="classball_1_1UserFields.html">ball::UserFields</a> &amp;a, <a class="el" href="classball_1_1UserFields.html">ball::UserFields</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#af6c6810ddc8df6fecec3cd0c37db5492">operator==</a> (const <a class="el" href="classball_1_1UserFieldsSchema.html">UserFieldsSchema</a> &amp;lhs, const <a class="el" href="classball_1_1UserFieldsSchema.html">UserFieldsSchema</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#aefc45a376d17d1366e5c94d2415a52bb">operator!=</a> (const <a class="el" href="classball_1_1UserFieldsSchema.html">UserFieldsSchema</a> &amp;lhs, const <a class="el" href="classball_1_1UserFieldsSchema.html">UserFieldsSchema</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#aaac41b45e3f2006d348c4c83da2ac030">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classball_1_1UserFieldsSchema.html">UserFieldsSchema</a> &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a5d13766983f177685e630fc8aca760de">swap</a> (<a class="el" href="classball_1_1UserFieldsSchema.html">ball::UserFieldsSchema</a> &amp;a, <a class="el" href="classball_1_1UserFieldsSchema.html">ball::UserFieldsSchema</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a6c449e02ac744dfa20d4d08f73f1874d">operator&lt;&lt;</a> (bsl::ostream &amp;stream, <a class="el" href="structball_1_1UserFieldType.html#a4ea244c928888fd9f1799fff4b53157e">UserFieldType::Enum</a> value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#ac95d9f47b8fc42143bb3a5b44efc6ced">operator==</a> (const <a class="el" href="classball_1_1UserFieldValue.html">UserFieldValue</a> &amp;lhs, const <a class="el" href="classball_1_1UserFieldValue.html">UserFieldValue</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a4d0a22836376638557274fe7dd7d1ae4">operator!=</a> (const <a class="el" href="classball_1_1UserFieldValue.html">UserFieldValue</a> &amp;lhs, const <a class="el" href="classball_1_1UserFieldValue.html">UserFieldValue</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#a2bac198e8d5dedcf0996d8af19d9e1d1">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classball_1_1UserFieldValue.html">UserFieldValue</a> &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html#abbc65b572442698617b7087cdb47a9ad">swap</a> (<a class="el" href="classball_1_1UserFieldValue.html">ball::UserFieldValue</a> &amp;a, <a class="el" href="classball_1_1UserFieldValue.html">ball::UserFieldValue</a> &amp;b)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ab251677d5a48547c5949a5d1ba55d80f"></a><!-- doxytag: member="ball::operator==" ref="ab251677d5a48547c5949a5d1ba55d80f" args="(const Attribute &amp;lhs, const Attribute &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const Attribute &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Attribute &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1Attribute.html">Attribute</a></code> objects have the same value if they have the same name (but not necessarily the identical representation in memory), the same attribute value type, and the same attribute value. </p>

</div>
</div>
<a class="anchor" id="aab8cb87f866505f08a130b815133ad9b"></a><!-- doxytag: member="ball::operator!=" ref="aab8cb87f866505f08a130b815133ad9b" args="(const Attribute &amp;lhs, const Attribute &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Attribute &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Attribute &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1Attribute.html">Attribute</a></code> objects do not have the same value if any of their respective names (value, not address), attribute value types, or attribute values differ. </p>

</div>
</div>
<a class="anchor" id="a5639cbfb9daac95171eda5204c58f199"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a5639cbfb9daac95171eda5204c58f199" args="(bsl::ostream &amp;output, const Attribute &amp;attribute)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Attribute &amp;&nbsp;</td>
          <td class="paramname"> <em>attribute</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>attribute</code> to the specified <code>output</code> stream. Return the specified <code>output</code> stream. </p>

</div>
</div>
<a class="anchor" id="a1012e79caa118d83bef184c35e26cf7f"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a1012e79caa118d83bef184c35e26cf7f" args="(bsl::ostream &amp;stream, const AttributeContainer &amp;container)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeContainer &amp;&nbsp;</td>
          <td class="paramname"> <em>container</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>container</code> to the specified output <code>stream</code> in a single-line format, and return a reference to the modifiable stream. </p>

</div>
</div>
<a class="anchor" id="ac7420e2a6cae38f34f67a8ec9e0bbc73"></a><!-- doxytag: member="ball::operator==" ref="ac7420e2a6cae38f34f67a8ec9e0bbc73" args="(const AttributeContainerListIterator &amp;lhs, const AttributeContainerListIterator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const AttributeContainerListIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeContainerListIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> iterators have the same value and <code>false</code> otherwise. Two iterators have the same value if they refer to the same position in the same list, or if both iterators are at an invalid position in the list (i.e., the "end" of the list, or the default constructed value). </p>

</div>
</div>
<a class="anchor" id="a915a9682b36c89c11a3bfdb3d91cf109"></a><!-- doxytag: member="ball::operator!=" ref="a915a9682b36c89c11a3bfdb3d91cf109" args="(const AttributeContainerListIterator &amp;lhs, const AttributeContainerListIterator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const AttributeContainerListIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeContainerListIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> iterators do not have the same value and <code>false</code> otherwise. Two iterators do not have the same value if they differ in either the list to which they refer or the position in the list object. </p>

</div>
</div>
<a class="anchor" id="add07f19dba561ceb0ad1653d58a377f9"></a><!-- doxytag: member="ball::operator==" ref="add07f19dba561ceb0ad1653d58a377f9" args="(const AttributeContainerList &amp;lhs, const AttributeContainerList &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const AttributeContainerList &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeContainerList &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> lists have the same value, and <code>false</code> otherwise. Two lists have the same value if they have the same number of attribute container addresses, and the address at each index position have the same value. </p>

</div>
</div>
<a class="anchor" id="afb270495d27912e99d5e03ac379bf4af"></a><!-- doxytag: member="ball::operator!=" ref="afb270495d27912e99d5e03ac379bf4af" args="(const AttributeContainerList &amp;lhs, const AttributeContainerList &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const AttributeContainerList &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeContainerList &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> lists do not have the same value, and <code>false</code> otherwise. Two lists do not have the same value if have differing numbers of attribute container addresses or any of the addresses at corresponding indices have different values. </p>

</div>
</div>
<a class="anchor" id="adce97ac148b8a7d8e2ad5234f5598647"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="adce97ac148b8a7d8e2ad5234f5598647" args="(bsl::ostream &amp;output, const AttributeContainerList &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeContainerList &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a formatted description of the specified <code>rhs</code> to the specified <code>stream</code> and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a488463520fab3d5b46dc88ffc6526675"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a488463520fab3d5b46dc88ffc6526675" args="(bsl::ostream &amp;stream, const AttributeContext_RuleEvaluationCache &amp;cache)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeContext_RuleEvaluationCache &amp;&nbsp;</td>
          <td class="paramname"> <em>cache</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a description of the data members of the specified <code>cache</code> to the specified <code>stream</code> in some single-line human readable format, and return the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a630ca3fb7e0dc95791f6de7c3edb2c9b"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a630ca3fb7e0dc95791f6de7c3edb2c9b" args="(bsl::ostream &amp;stream, const AttributeContext &amp;context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeContext &amp;&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a description of the data members of the specified <code>context</code> to the specified <code>stream</code> in a single-line human readable format, and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a52e82a518433605990d22761905a0d45"></a><!-- doxytag: member="ball::operator==" ref="a52e82a518433605990d22761905a0d45" args="(const Context &amp;lhs, const Context &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const Context &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> context objects have the same value, and <code>false</code> otherwise. Two context objects have the same value if each respective pair of corresponding attributes have the same value. </p>

</div>
</div>
<a class="anchor" id="a2ea632a45935e596e50084f5ac4ada42"></a><!-- doxytag: member="ball::operator!=" ref="a2ea632a45935e596e50084f5ac4ada42" args="(const Context &amp;lhs, const Context &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Context &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> context objects do not have the same value, and <code>false</code> otherwise. Two context objects do not have the same value if one or more respective attributes differ in value. </p>

</div>
</div>
<a class="anchor" id="a1470609e28f6cb8219e4d45fe5ce8f5d"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a1470609e28f6cb8219e4d45fe5ce8f5d" args="(bsl::ostream &amp;stream, const Context &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Context &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>rhs</code> context to the specified output <code>stream</code> and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a83db3e0a2c1dce67b099b01950664eda"></a><!-- doxytag: member="ball::operator==" ref="a83db3e0a2c1dce67b099b01950664eda" args="(const DefaultAttributeContainer &amp;lhs, const DefaultAttributeContainer &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const DefaultAttributeContainer &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DefaultAttributeContainer &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1DefaultAttributeContainer.html">DefaultAttributeContainer</a></code> objects have the same value if they contain the same number of (unique) attributes, and every attribute that appears in one object also appears in the other. </p>

</div>
</div>
<a class="anchor" id="a893f2a0cc2cbcb3d2d46a44f722ec0c9"></a><!-- doxytag: member="ball::operator!=" ref="a893f2a0cc2cbcb3d2d46a44f722ec0c9" args="(const DefaultAttributeContainer &amp;lhs, const DefaultAttributeContainer &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const DefaultAttributeContainer &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DefaultAttributeContainer &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1DefaultAttributeContainer.html">DefaultAttributeContainer</a></code> objects do not have the same value if they contain differing numbers of attributes or if there is at least one attribute that appears in one object, but not in the other. </p>

</div>
</div>
<a class="anchor" id="aad1c3be23a449d5cc0d1a7c0e0bc6fe6"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="aad1c3be23a449d5cc0d1a7c0e0bc6fe6" args="(bsl::ostream &amp;output, const DefaultAttributeContainer &amp;attributeContainer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DefaultAttributeContainer &amp;&nbsp;</td>
          <td class="paramname"> <em>attributeContainer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>attributeContainer</code> to the specified <code>output</code> stream in some single-line, human readable format. Return the <code>output</code> stream. </p>

</div>
</div>
<a class="anchor" id="abda88586aee46e8e51b223c3b1999917"></a><!-- doxytag: member="ball::operator==" ref="abda88586aee46e8e51b223c3b1999917" args="(const LoggerManagerConfiguration &amp;lhs, const LoggerManagerConfiguration &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const LoggerManagerConfiguration &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LoggerManagerConfiguration &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> attribute objects have the same (in-core) value, and <code>false</code> otherwise. Two attribute objects objects have the same in-core value if each respective attribute has the same in-core value. Note that functor attributes must have identically the same representation to have the same in-core value. </p>

</div>
</div>
<a class="anchor" id="a147e114b969b0ae3a36e8c999ba4af48"></a><!-- doxytag: member="ball::operator!=" ref="a147e114b969b0ae3a36e8c999ba4af48" args="(const LoggerManagerConfiguration &amp;lhs, const LoggerManagerConfiguration &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const LoggerManagerConfiguration &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LoggerManagerConfiguration &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> attribute objects do not have the same (in-core) value, and <code>false</code> otherwise. Two attribute objects do not have the same in-core value if one or more respective attributes differ in in-core values. Note that functor attributes will have different in-core values if their representations are not identical. </p>

</div>
</div>
<a class="anchor" id="a1cb9beb73f11bcdf5948910cd9534333"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a1cb9beb73f11bcdf5948910cd9534333" args="(bsl::ostream &amp;stream, const LoggerManagerConfiguration &amp;configuration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LoggerManagerConfiguration &amp;&nbsp;</td>
          <td class="paramname"> <em>configuration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a reasonable representation of the specified <code>configuration</code> object to the specified output <code>stream</code>, indicating whether the contained functors are or are not "null". </p>

</div>
</div>
<a class="anchor" id="a3eda19e2fe2609b33bf008e954f89323"></a><!-- doxytag: member="ball::operator==" ref="a3eda19e2fe2609b33bf008e954f89323" args="(const LoggerManagerDefaults &amp;lhs, const LoggerManagerDefaults &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const LoggerManagerDefaults &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LoggerManagerDefaults &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> attribute objects have the same value, and <code>false</code> otherwise. Two attribute objects objects have the same value if each respective attribute has the same value. </p>

</div>
</div>
<a class="anchor" id="acbf7ab1f8750d1e3404d83f364aba80b"></a><!-- doxytag: member="ball::operator!=" ref="acbf7ab1f8750d1e3404d83f364aba80b" args="(const LoggerManagerDefaults &amp;lhs, const LoggerManagerDefaults &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const LoggerManagerDefaults &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LoggerManagerDefaults &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> attribute objects do not have the same value, and <code>false</code> otherwise. Two attribute objects do not have the same value if one or more respective attributes differ in values. </p>

</div>
</div>
<a class="anchor" id="a571124eb0aaa4379234c7c27bcdd7d34"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a571124eb0aaa4379234c7c27bcdd7d34" args="(bsl::ostream &amp;stream, const LoggerManagerDefaults &amp;defaults)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LoggerManagerDefaults &amp;&nbsp;</td>
          <td class="paramname"> <em>defaults</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>defaults</code> object to the specified output <code>stream</code> in a reasonable multi-line format. </p>

</div>
</div>
<a class="anchor" id="aa5e40d8af1174eb139c44a11470798cb"></a><!-- doxytag: member="ball::operator==" ref="aa5e40d8af1174eb139c44a11470798cb" args="(const Predicate &amp;lhs, const Predicate &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const Predicate &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1Predicate.html">Predicate</a></code> objects have the same value if they have the same name (but not necessarily the identical representation in memory), the same attribute value type, and the same attribute value. </p>

</div>
</div>
<a class="anchor" id="a9acc58ede6c3a8fc61b6d642880f9424"></a><!-- doxytag: member="ball::operator!=" ref="a9acc58ede6c3a8fc61b6d642880f9424" args="(const Predicate &amp;lhs, const Predicate &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Predicate &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1Predicate.html">Predicate</a></code> objects do not have the same value if any of their respective names (value, not address), attribute value types, or attribute values differ. </p>

</div>
</div>
<a class="anchor" id="a0038b774a873014029257e75abb961d6"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a0038b774a873014029257e75abb961d6" args="(bsl::ostream &amp;stream, const Predicate &amp;predicate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&nbsp;</td>
          <td class="paramname"> <em>predicate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>predicate</code> to the specified output <code>stream</code>, and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a722c42f68c273803d920c48b76605da9"></a><!-- doxytag: member="ball::operator==" ref="a722c42f68c273803d920c48b76605da9" args="(const PredicateSet &amp;lhs, const PredicateSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const PredicateSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PredicateSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1PredicateSet.html">PredicateSet</a></code> objects have the same value if they have the same number of predicates and every predicate value that appears in one object also appears in the other. </p>

</div>
</div>
<a class="anchor" id="a97578794a1e66cb37e452d509a4e90e1"></a><!-- doxytag: member="ball::operator!=" ref="a97578794a1e66cb37e452d509a4e90e1" args="(const PredicateSet &amp;lhs, const PredicateSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const PredicateSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PredicateSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1PredicateSet.html">PredicateSet</a></code> objects do not have the same value if they do not have the same number of predicates or there is at least one predicate value that appears in one object, but not in the other. </p>

</div>
</div>
<a class="anchor" id="a7237b4a1cce1068f20df94a66ebfe500"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a7237b4a1cce1068f20df94a66ebfe500" args="(bsl::ostream &amp;output, const PredicateSet &amp;predicateSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PredicateSet &amp;&nbsp;</td>
          <td class="paramname"> <em>predicateSet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>predicateSet</code> to the specified <code>output</code> stream. Return the specified <code>output</code> stream. </p>

</div>
</div>
<a class="anchor" id="ad8fd47b65d6742a7725ba68f3c5b1175"></a><!-- doxytag: member="ball::operator==" ref="ad8fd47b65d6742a7725ba68f3c5b1175" args="(const Record &amp;lhs, const Record &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const Record &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Record &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> log records have the same value, and <code>false</code> otherwise. Two log records have the same value if the respective fixed fields have the same value and the respective user-defined fields have the same value. </p>

</div>
</div>
<a class="anchor" id="afdc1df5ba7ee30231eaab50bfe812f8b"></a><!-- doxytag: member="ball::operator!=" ref="afdc1df5ba7ee30231eaab50bfe812f8b" args="(const Record &amp;lhs, const Record &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Record &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Record &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> log records do not have the same value, and <code>false</code> otherwise. Two log records do not have the same value if either the respective fixed fields or user-defined fields do not have the same value. </p>

</div>
</div>
<a class="anchor" id="a59fb44f8fb49dc78d7244195cccc88b0"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a59fb44f8fb49dc78d7244195cccc88b0" args="(bsl::ostream &amp;stream, const Record &amp;record)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Record &amp;&nbsp;</td>
          <td class="paramname"> <em>record</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Format the members of the specified <code>record</code> to the specified output <code>stream</code> and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="ab9ab0e2ceaa08363ca44c7dadd5f12ef"></a><!-- doxytag: member="ball::operator==" ref="ab9ab0e2ceaa08363ca44c7dadd5f12ef" args="(const RecordAttributes &amp;lhs, const RecordAttributes &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const RecordAttributes &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RecordAttributes &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> record attributes objects have the same value, and <code>false</code> otherwise. Two record attributes objects have the same value if each respective pair of attributes have the same value. </p>

</div>
</div>
<a class="anchor" id="a9ffc33126cf91ef08e1767327cdccfd7"></a><!-- doxytag: member="ball::operator!=" ref="a9ffc33126cf91ef08e1767327cdccfd7" args="(const RecordAttributes &amp;lhs, const RecordAttributes &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const RecordAttributes &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RecordAttributes &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> record attributes objects do not have the same value, and <code>false</code> otherwise. Two record attributes objects do not have the same value if one or more respective attributes differ in value. </p>

</div>
</div>
<a class="anchor" id="a5d212e9743bbd106e4b6d16f3ec01dba"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a5d212e9743bbd106e4b6d16f3ec01dba" args="(bsl::ostream &amp;stream, const RecordAttributes &amp;attributes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RecordAttributes &amp;&nbsp;</td>
          <td class="paramname"> <em>attributes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Format the members of the specified <code>attributes</code> to the specified output <code>stream</code> and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="aef6eea39e4c290fac8955c9c06ab96f8"></a><!-- doxytag: member="ball::operator==" ref="aef6eea39e4c290fac8955c9c06ab96f8" args="(const RecordStringFormatter &amp;lhs, const RecordStringFormatter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const RecordStringFormatter &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RecordStringFormatter &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> record formatters have the same value, and <code>false</code> otherwise. Two record formatters have the same value if they have the same format specification and the same timestamp offset. </p>

</div>
</div>
<a class="anchor" id="aba2da51788beec672c814ae8e1c70d9d"></a><!-- doxytag: member="ball::operator!=" ref="aba2da51788beec672c814ae8e1c70d9d" args="(const RecordStringFormatter &amp;lhs, const RecordStringFormatter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const RecordStringFormatter &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RecordStringFormatter &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> record formatters do not have the same value, and <code>false</code> otherwise. Two record formatters differ in value if their format specifications differ or their timestamp offsets differ. </p>

</div>
</div>
<a class="anchor" id="a99199c76577b5a79f7a7e42e44ffe4f4"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a99199c76577b5a79f7a7e42e44ffe4f4" args="(bsl::ostream &amp;output, const RecordStringFormatter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RecordStringFormatter &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>rhs</code> record formatter to the specified <code>output</code> stream in some reasonable (single-line) format and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a0481afef00e1f4697d75215dcaef694e"></a><!-- doxytag: member="ball::operator==" ref="a0481afef00e1f4697d75215dcaef694e" args="(const Rule &amp;lhs, const Rule &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const Rule &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rule &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1Rule.html">Rule</a></code> objects have the same value if they have the same predicate, the same four respective threshold levels, and the same pattern. </p>

</div>
</div>
<a class="anchor" id="a14b95c30fc289965b30f6e903f46728a"></a><!-- doxytag: member="ball::operator!=" ref="a14b95c30fc289965b30f6e903f46728a" args="(const Rule &amp;lhs, const Rule &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Rule &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rule &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1Rule.html">Rule</a></code> objects do not have the same value if they have different predicates, different values for any of the four respective threshold levels, or different patterns. </p>

</div>
</div>
<a class="anchor" id="a90b9d98de4075161a4fa0a8f23c15455"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a90b9d98de4075161a4fa0a8f23c15455" args="(bsl::ostream &amp;output, const Rule &amp;rule)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rule &amp;&nbsp;</td>
          <td class="paramname"> <em>rule</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>rule</code> to the specified <code>output</code> stream. Return the specified <code>output</code> stream. </p>

</div>
</div>
<a class="anchor" id="ad10390a9da6095f6bb1633fb6efcae62"></a><!-- doxytag: member="ball::operator==" ref="ad10390a9da6095f6bb1633fb6efcae62" args="(const RuleSet &amp;lhs, const RuleSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const RuleSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RuleSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> rule sets have the same value, and <code>false</code> otherwise. Two rule sets have the same value if every rule that exists in one rule set also exists in the other. </p>

</div>
</div>
<a class="anchor" id="a5e197f366a4063268227bded7db7fc2d"></a><!-- doxytag: member="ball::operator!=" ref="a5e197f366a4063268227bded7db7fc2d" args="(const RuleSet &amp;lhs, const RuleSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const RuleSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RuleSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> rule sets do not have the same value, and <code>false</code> otherwise. Two rule sets do not have the same value if there is at least one rule that exists in one rule but does not exist in the other. </p>

</div>
</div>
<a class="anchor" id="a1561fbb0607fcfbab7d27473cff6bb70"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a1561fbb0607fcfbab7d27473cff6bb70" args="(bsl::ostream &amp;output, const RuleSet &amp;rules)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RuleSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rules</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>rules</code> to the specified <code>output</code> stream. Return the specified <code>output</code> stream </p>

</div>
</div>
<a class="anchor" id="af476a355693cec559a6e3a32ff62e579"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="af476a355693cec559a6e3a32ff62e579" args="(bsl::ostream &amp;stream, Severity::Level rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Severity::Level&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Format the specified <code>rhs</code> to the specified output <code>stream</code> and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="aea4e2480e7ee666d322e15c984561c97"></a><!-- doxytag: member="ball::operator==" ref="aea4e2480e7ee666d322e15c984561c97" args="(const ThresholdAggregate &amp;lhs, const ThresholdAggregate &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const ThresholdAggregate &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ThresholdAggregate &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> threshold aggregates have the same value, and <code>false</code> otherwise. Two threshold aggregates have the same value if all four of their respective threshold levels are the same. </p>

</div>
</div>
<a class="anchor" id="a28dc6b9c54e1813b215be090ff23bebe"></a><!-- doxytag: member="ball::operator!=" ref="a28dc6b9c54e1813b215be090ff23bebe" args="(const ThresholdAggregate &amp;lhs, const ThresholdAggregate &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const ThresholdAggregate &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ThresholdAggregate &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> threshold aggregates do not have the same value, and <code>false</code> otherwise. Two threshold aggregates do not have the same value if any of their four respective threshold levels differ. </p>

</div>
</div>
<a class="anchor" id="a898158231b34e9ff17365003922cf36a"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a898158231b34e9ff17365003922cf36a" args="(bsl::ostream &amp;stream, const ThresholdAggregate &amp;aggregate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ThresholdAggregate &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified threshold <code>aggregate</code> to the specified output <code>stream</code> and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="acf000d1cdabf90d5a3a6746cf70ee81f"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="acf000d1cdabf90d5a3a6746cf70ee81f" args="(bsl::ostream &amp;stream, Transmission::Cause rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Transmission::Cause&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Format the specified <code>rhs</code> to the specified output <code>stream</code> and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a38157894386a30bddcebd304526b6c84"></a><!-- doxytag: member="ball::operator==" ref="a38157894386a30bddcebd304526b6c84" args="(const UserFields &amp;lhs, const UserFields &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const UserFields &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UserFields &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1UserFields.html">ball::UserFields</a></code> objects have the same value if they have the same number of elements, and each element in <code>lhs</code> has the same value as corresponding element at the same index in <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="ad69614178aa220fe7a7054c11c067d16"></a><!-- doxytag: member="ball::operator!=" ref="ad69614178aa220fe7a7054c11c067d16" args="(const UserFields &amp;lhs, const UserFields &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const UserFields &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UserFields &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1UserFields.html">UserFields</a></code> objects do not have the same value if they have a different number of elements, or if any element in <code>lhs</code> has a different value from the corresponding element at the same index in <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="aa58bb07e36eee360acb89446abc6373c"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="aa58bb07e36eee360acb89446abc6373c" args="(bsl::ostream &amp;stream, const UserFields &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UserFields &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>object</code> to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified, can change without notice, and is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(stream, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a4f1ef43d8e35464e858a25f9cbe03dec"></a><!-- doxytag: member="ball::swap" ref="a4f1ef43d8e35464e858a25f9cbe03dec" args="(ball::UserFields &amp;a, ball::UserFields &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ball::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classball_1_1UserFields.html">ball::UserFields</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classball_1_1UserFields.html">ball::UserFields</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap the value of the specified <code>a</code> object with the value of the specified <code>b</code> object. This method provides the no-throw exception guarantee if <code>a.allocator()</code> is the same as <code>b.allocator()</code>, and the basic exception guarantee otherwise. </p>

</div>
</div>
<a class="anchor" id="af6c6810ddc8df6fecec3cd0c37db5492"></a><!-- doxytag: member="ball::operator==" ref="af6c6810ddc8df6fecec3cd0c37db5492" args="(const UserFieldsSchema &amp;lhs, const UserFieldsSchema &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const UserFieldsSchema &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UserFieldsSchema &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1UserFieldsSchema.html">ball::UserFieldsSchema</a></code> objects have the same value if they have the same number of field descriptions, and each field description in <code>lhs</code> has the same name and type as corresponding description at the same index in <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="aefc45a376d17d1366e5c94d2415a52bb"></a><!-- doxytag: member="ball::operator!=" ref="aefc45a376d17d1366e5c94d2415a52bb" args="(const UserFieldsSchema &amp;lhs, const UserFieldsSchema &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const UserFieldsSchema &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UserFieldsSchema &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1UserFieldsSchema.html">UserFieldsSchema</a></code> objects do not have the same value if they have a different number of field descriptions, or if any field description in <code>lhs</code> has a different name or type from the corresponding description at the same index in <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="aaac41b45e3f2006d348c4c83da2ac030"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="aaac41b45e3f2006d348c4c83da2ac030" args="(bsl::ostream &amp;stream, const UserFieldsSchema &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UserFieldsSchema &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>object</code> to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified, can change without notice, and is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(stream, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a5d13766983f177685e630fc8aca760de"></a><!-- doxytag: member="ball::swap" ref="a5d13766983f177685e630fc8aca760de" args="(ball::UserFieldsSchema &amp;a, ball::UserFieldsSchema &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ball::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classball_1_1UserFieldsSchema.html">ball::UserFieldsSchema</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classball_1_1UserFieldsSchema.html">ball::UserFieldsSchema</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap the value of the specified <code>a</code> object with the value of the specified <code>b</code> object. This method provides the no-throw exception guarantee if <code>a.allocator()</code> is the same as <code>b.allocator()</code>, and the basic exception guarantee otherwise. </p>

</div>
</div>
<a class="anchor" id="a6c449e02ac744dfa20d4d08f73f1874d"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a6c449e02ac744dfa20d4d08f73f1874d" args="(bsl::ostream &amp;stream, UserFieldType::Enum value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UserFieldType::Enum&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the string representation of the specified enumeration <code>value</code> to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. See <code>toAscii</code> for what constitutes the string representation of a <code><a class="el" href="structball_1_1UserFieldType.html#a4ea244c928888fd9f1799fff4b53157e" title="Define the list of month-of-year values.">ball::UserFieldType::Enum</a></code> value. Note that this method has the same behavior as <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">ball::UserFieldType::print</a>(stream, value, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ac95d9f47b8fc42143bb3a5b44efc6ced"></a><!-- doxytag: member="ball::operator==" ref="ac95d9f47b8fc42143bb3a5b44efc6ced" args="(const UserFieldValue &amp;lhs, const UserFieldValue &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator== </td>
          <td>(</td>
          <td class="paramtype">const UserFieldValue &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UserFieldValue &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1UserFieldValue.html">UserFieldValue</a></code> objects have the same value if they have the same <code>type</code>, and (if the type is not <code>e_VOID</code>) the value of that type (as accessed through <code>the*</code> methods) is the same. </p>

</div>
</div>
<a class="anchor" id="a4d0a22836376638557274fe7dd7d1ae4"></a><!-- doxytag: member="ball::operator!=" ref="a4d0a22836376638557274fe7dd7d1ae4" args="(const UserFieldValue &amp;lhs, const UserFieldValue &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ball::operator!= </td>
          <td>(</td>
          <td class="paramtype">const UserFieldValue &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UserFieldValue &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classball_1_1UserFieldValue.html">UserFieldValue</a></code> objects do not have the same value if their <code>type</code> is not the same, or (if their type is not <code>e_VOID</code>) the value of that type (as accessed through <code>the*</code> methods) is not the same. </p>

</div>
</div>
<a class="anchor" id="a2bac198e8d5dedcf0996d8af19d9e1d1"></a><!-- doxytag: member="ball::operator&lt;&lt;" ref="a2bac198e8d5dedcf0996d8af19d9e1d1" args="(bsl::ostream &amp;stream, const UserFieldValue &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; ball::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UserFieldValue &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>object</code> to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified, can change without notice, and is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(stream, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="abbc65b572442698617b7087cdb47a9ad"></a><!-- doxytag: member="ball::swap" ref="abbc65b572442698617b7087cdb47a9ad" args="(ball::UserFieldValue &amp;a, ball::UserFieldValue &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ball::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classball_1_1UserFieldValue.html">ball::UserFieldValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classball_1_1UserFieldValue.html">ball::UserFieldValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap the value of the specified <code>a</code> object with the value of the specified <code>b</code> object. This method provides the no-throw guarantee if <code>a.type()</code> is the same as <code>b.type()</code>; otherwise it provides the basic guarantee. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:27 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
