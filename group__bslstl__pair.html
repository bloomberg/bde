<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslstl_pair Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_pair<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a simple <code>struct</code> with two members that may use allocators.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp&lt; T1, T2, T1_USES_BSLMA, T2_USES_BSLMA &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Pair__Imp_3_01T1_00_01T2_00_011_00_010_01_4.html">bsl::Pair_Imp&lt; T1, T2, 1, 0 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Pair__Imp_3_01T1_00_01T2_00_010_00_011_01_4.html">bsl::Pair_Imp&lt; T1, T2, 0, 1 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Pair__Imp_3_01T1_00_01T2_00_011_00_011_01_4.html">bsl::Pair_Imp&lt; T1, T2, 1, 1 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1pair.html">bsl::pair&lt; T1, T2 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1is__trivially__default__constructible_3_01bsl_1_1pair_3_01T1_00_01T2_01_4_01_4.html">bsl::is_trivially_default_constructible&lt; bsl::pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmf_1_1IsBitwiseEqualityComparable_3_01bsl_1_1pair_3_01T1_00_01T2_01_4_01_4.html">bslmf::IsBitwiseEqualityComparable&lt; bsl::pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T1&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga1607d458602785df6d943b4eb9b9e188">bsl::pair::first_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gab37f96992063e347a66ed75aeea3cd1f">bsl::pair::second_type</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gab498e054372f6da3d534aad79755f22e">bsl::Pair_Imp::Pair_Imp</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga19267e0e2d7627e84f754225f14f9323">bsl::Pair_Imp::Pair_Imp</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U1 , typename U2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga86070527c52543d1cffae8fd4ca04a8f">bsl::Pair_Imp::Pair_Imp</a> (const U1 &amp;a, const U2 &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gad3fad5a7f26ea3f045978cc397688e71">bsl::Pair_Imp::~Pair_Imp</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga482e8ad20afacaa48c6b849bf40ab2a2">bsl::Pair_Imp&lt; T1, T2, 1, 0 &gt;::Pair_Imp</a> (BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga668906c0ce7e59e4a1326f51c1297f6e">bsl::Pair_Imp&lt; T1, T2, 1, 0 &gt;::Pair_Imp</a> (const T1 &amp;a, const T2 &amp;b, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U1 , typename U2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gab8628751ef7ee6371b3bf7eb62e67870">bsl::Pair_Imp&lt; T1, T2, 1, 0 &gt;::Pair_Imp</a> (const U1 &amp;a, const U2 &amp;b, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga512d1a53027696febfe18c99d283612f">bsl::Pair_Imp&lt; T1, T2, 1, 0 &gt;::~Pair_Imp</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga5e999cf4054864965dc7098ccc1e40ce">bsl::Pair_Imp&lt; T1, T2, 0, 1 &gt;::Pair_Imp</a> (BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gaab2988371f27ffb6a0d7eb813a12f212">bsl::Pair_Imp&lt; T1, T2, 0, 1 &gt;::Pair_Imp</a> (const T1 &amp;a, const T2 &amp;b, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U1 , typename U2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gad48c0574dbbc9e6ada808aad1f98710d">bsl::Pair_Imp&lt; T1, T2, 0, 1 &gt;::Pair_Imp</a> (const U1 &amp;a, const U2 &amp;b, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga2271791af374d77c9573e32b21e8a283">bsl::Pair_Imp&lt; T1, T2, 0, 1 &gt;::~Pair_Imp</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gabfb7000670eac96ed645f3914e6a1d4b">bsl::Pair_Imp&lt; T1, T2, 1, 1 &gt;::Pair_Imp</a> (BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gaa6a7c8b7cc7b6615cd9f22a26ccae7fe">bsl::Pair_Imp&lt; T1, T2, 1, 1 &gt;::Pair_Imp</a> (const T1 &amp;a, const T2 &amp;b, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U1 , typename U2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga0f3b130c2aa7c5a53725ddf84bf3f4e4">bsl::Pair_Imp&lt; T1, T2, 1, 1 &gt;::Pair_Imp</a> (const U1 &amp;a, const U2 &amp;b, BloombergLP::bslma::Allocator *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gaab0a48e9070629aaf42c754368739dc6">bsl::Pair_Imp&lt; T1, T2, 1, 1 &gt;::~Pair_Imp</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gae640a0a8189758608a064c0c1e1deec1">bsl::pair::pair</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga24269c516271f2fc71a5b18762e2e18a">bsl::pair::pair</a> (BloombergLP::bslma::Allocator *basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga55fdbe09c1a7c9f645f17ff1a18ff076">bsl::pair::pair</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gaf0cca61d59ac936dedc4b1c55d4d42c7">bsl::pair::pair</a> (const T1 &amp;a, const T2 &amp;b, BloombergLP::bslma::Allocator *basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga1a4e57de9e4d9481c2dfa1d8add1863e">bsl::pair::pair</a> (const pair &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gadef1dec3aa02c01bd4194a0314855481">bsl::pair::pair</a> (const pair &amp;rhs, BloombergLP::bslma::Allocator *basicAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U1 , typename U2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga12dbd21daf216c3d387989376c666ca9">bsl::pair::pair</a> (const pair&lt; U1, U2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U1 , typename U2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga1a2373cb1899fde967eb8366d819b04a">bsl::pair::pair</a> (const pair&lt; U1, U2 &gt; &amp;rhs, BloombergLP::bslma::Allocator *basicAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U1 , typename U2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga38becfe3678b948fd16dbcd8d179e631">bsl::pair::pair</a> (const native_std::pair&lt; U1, U2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U1 , typename U2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gaaae3e1fd5890f19d557cfb085d7bd173">bsl::pair::pair</a> (const native_std::pair&lt; U1, U2 &gt; &amp;rhs, BloombergLP::bslma::Allocator *basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga6c0c09e954cdb153267cf6a35a3b2607">bsl::pair::~pair</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pair &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga6545f413b6b7e1ea2c759b02310213bb">bsl::pair::operator=</a> (const pair &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename U1 , typename U2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">pair &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga87ead47d7766b5e4f64a3940340e66aa">bsl::pair::operator=</a> (const native_std::pair&lt; U1, U2 &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga7c1cf552d0d745d92dfaa76dd8ba4576">bsl::pair::swap</a> (pair &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga50b4aea952721acf5ad54aa2bc758c8d">bsl::operator!=</a> (const pair&lt; T1, T2 &gt; &amp;lhs, const pair&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga97c477e75c90f40b8122aa0702fb652c">bsl::operator&lt;</a> (const pair&lt; T1, T2 &gt; &amp;lhs, const pair&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gaecdfed596ebac61d4ebfda51e911b916">bsl::operator&gt;</a> (const pair&lt; T1, T2 &gt; &amp;lhs, const pair&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gade131fc530151248b67d2c88522832e3">bsl::operator&lt;=</a> (const pair&lt; T1, T2 &gt; &amp;lhs, const pair&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gaa19d2c4a4e8788af13eab13f37c5e53e">bsl::operator&gt;=</a> (const pair&lt; T1, T2 &gt; &amp;lhs, const pair&lt; T1, T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga8dd0a3f8324bcc657bc448230e8f5b4b">bsl::swap</a> (pair&lt; T1, T2 &gt; &amp;a, pair&lt; T1, T2 &gt; &amp;b)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T1&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gafff8113b0b2f4bbe5df93ce0ba30fad8">bsl::Pair_Imp::first</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#gaf89d2b38598dfb6fa42775f2e135f1d8">bsl::Pair_Imp::second</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T1&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga52bffab66534dccc96ed8aa4e5f7fe09">bsl::Pair_Imp&lt; T1, T2, 1, 0 &gt;::first</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga38b70ca829c7b7faba853e1aff1698be">bsl::Pair_Imp&lt; T1, T2, 1, 0 &gt;::second</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T1&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga71941daa05f41127a261dac8fe360316">bsl::Pair_Imp&lt; T1, T2, 0, 1 &gt;::first</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga4ebdfd6b26e36efe8252bc5fad30c690">bsl::Pair_Imp&lt; T1, T2, 0, 1 &gt;::second</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T1&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga48c316b7fbaff4cab082f67643e95a03">bsl::Pair_Imp&lt; T1, T2, 1, 1 &gt;::first</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__pair.html#ga19e3aeb0d9cf5b2bff066c8906306e19">bsl::Pair_Imp&lt; T1, T2, 1, 1 &gt;::second</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a simple <code>struct</code> with two members that may use allocators. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1pair.html">bsl::pair</a> </td><td>pair of values, each of which may use a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>*This class is for internal use only. Do not use. Use <code>&lt;bsl_utility.h&gt;</code> and <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a></code> directly instead.* </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a></code> class template is instantiated on two types, <code>T1</code> and <code>T2</code>, and provides two public data members, <code>first</code> and <code>second</code> of type <code>T1</code> and <code>T2</code>, respectively. Each data member might or might not allocate memory using <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>. Its interface is identical to <code>std::pair</code> except that it has constructors that take optional allocator arguments to correctly construct the member variables. For example, a <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;std::string, int&gt;</code> has member <code>first</code> of type <code>std::string</code> and <code>second</code> of type <code>int</code>. A client can pass a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> pointer to the pair constructor and the constructor will pass it through to the <code>first</code> member. Similarly, the copy constructor takes an optional <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> pointer and copy-constructs the <code>first</code> member using that allocator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a></code> is unusual in that its data members, <code>first</code> and <code>second</code>, are public. Once constructed, a client program accesses these members directly. This part of the interface is identical to <code>std::pair</code>, for which <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a></code> is intended to be a drop-in replacement. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a></code> has four constructors: a default constructor which default-constructs the two data members, a copy constructor which copy-constructs each data member, a constructor taking two arguments of type <code>T1</code> and <code>T2</code>, which are used to copy-construct <code>first</code> and <code>second</code> respectively, and a conversion constructor template for converting from a <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a></code> of different types, <code>U1</code> and <code>U2</code>, provided <code>U1</code> is convertible to <code>T1</code> and <code>U2</code> is convertible to <code>T2</code>. If and only if <code>T1</code> and/or <code>T2</code> is a type that uses <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> for memory allocation, then each constructor also has an optional <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> pointer argument. Whether or not a type uses <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> is determined by querying the <code><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a></code> trait for that type. This component also defines a full set of equality and relational operators which can be instantiated if <code>T1</code> and <code>T2</code> both provide those operators. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a></code> declares a set of associated type traits which are computed from the type traits of <code>T1</code> and <code>T2</code>. For each supported type trait, a given specialization of <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a></code> has that trait if and only if <em>both</em> <code>T1</code> and <code>T2</code> have that trait. Supported traits are: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbslmf_1_1IsBitwiseMoveable.html">bslmf::IsBitwiseMoveable</a>
  <a class="code" href="structbslmf_1_1IsBitwiseEqualityComparable.html">bslmf::IsBitwiseEqualityComparable</a>
  <a class="code" href="structbsl_1_1is__trivially__copyable.html">bsl::is_trivially_copyable</a>
  <a class="code" href="structbsl_1_1is__trivially__default__constructible.html">bsl::is_trivially_default_constructible</a>
</pre></div><br/>
<br/>
 In addition, a <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a></code> specialization has the <code><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a></code> trait if <em>either</em> <code>T1</code> or <code>T2</code> have that trait, or both. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><em>This class is for internal use only, do not use.</em> This usage example is here to illustrate a typical usage of this class for BDE only. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a></code> is a very simple object when used without allocators. Our usage example concentrates on the use of allocators with <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a></code>. First, we create a utility function that copies a null-terminated string into memory allocated from a supplied allocator: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">char</span> *myStrDup(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
      <span class="comment">// Copy the specified null-terminated string &#39;s&#39; into memory allocated</span>
      <span class="comment">// from &#39;basicAllocator&#39;</span>
  {
      <span class="keywordtype">char</span> *result = (<span class="keywordtype">char</span>*) basicAllocator-&gt;<a class="code" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">allocate</a>(std::strlen(s) + 1);
      <span class="keywordflow">return</span> std::strcpy(result, s);
  }
</pre></div><br/>
<br/>
 We create a simple string class that holds strings allocated from a supplied allocator. It uses <code>myStrDup</code> (above) in its implementation: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_String {
      <span class="comment">// Simple string class that uses a &#39;bslma::Allocator&#39; allocator.</span>

      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator;
      <span class="keywordtype">char</span>            *d_data;

    <span class="keyword">public</span>:
      <a class="code" href="bslmf__nestedtraitdeclaration_8h.html#a6d33ff2982d65052e0c33136bf4d74e7">BSLMF_NESTED_TRAIT_DECLARATION</a>(my_String, <a class="code" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>);

      <span class="keyword">explicit</span> my_String(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Construct an empty string using the optionally-specified</span>
          <span class="comment">// allocator &#39;basicAllocator&#39;.</span>

      my_String(<span class="keyword">const</span> <span class="keywordtype">char</span>* s, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Construct a string with contents specified in &#39;s&#39; using the</span>
          <span class="comment">// optionally-specified allocator &#39;basicAllocator&#39;.</span>

      my_String(<span class="keyword">const</span> my_String&amp; rhs, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Construct a copy of the specified &#39;rhs&#39; string using the</span>
          <span class="comment">// optionally-specified allocator &#39;basicAllocator&#39;.</span>

      ~my_String();
          <span class="comment">// Destroy this string.</span>

      my_String&amp; operator=(<span class="keyword">const</span> my_String&amp; rhs);
          <span class="comment">// Copy specified &#39;rhs&#39; string value to this string.</span>

      <span class="keyword">const</span> <span class="keywordtype">char</span>* c_str() <span class="keyword">const</span>;
          <span class="comment">// Return the null-terminated character array for this string.</span>

      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator() <span class="keyword">const</span>;
          <span class="comment">// Return the allocator used to construct this string or, if no</span>
          <span class="comment">// allocator was specified at construction, the default allocator</span>
          <span class="comment">// at the time of construction.</span>
  };

  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> my_String&amp; str1, <span class="keyword">const</span> my_String&amp; str2)
  {
      <span class="keywordflow">return</span> 0 == std::strcmp(str1.c_str(), str2.c_str());
  }

  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> my_String&amp; str, <span class="keyword">const</span> <span class="keywordtype">char</span> *p)
  {
      <span class="keywordflow">return</span> 0 == std::strcmp(p, str.c_str());
  }

  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *p, <span class="keyword">const</span> my_String&amp; str)
  {
      <span class="keywordflow">return</span> str == p;
  }

  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> my_String&amp; str1, <span class="keyword">const</span> my_String&amp; str2)
  {
      <span class="keywordflow">return</span> ! (str1 == str2);
  }

  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> my_String&amp; str, <span class="keyword">const</span> <span class="keywordtype">char</span> *p)
  {
      <span class="keywordflow">return</span> ! (str == p);
  }

  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *p, <span class="keyword">const</span> my_String&amp; str)
  {
      <span class="keywordflow">return</span> ! (str == p);
  }

  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__deque.html#ga34cf92fee7de6f434633ee726b63fb38">operator&lt;</a>(<span class="keyword">const</span> my_String&amp; str1, <span class="keyword">const</span> my_String&amp; str2)
  {
      <span class="keywordflow">return</span> std::strcmp(str1.c_str(), str2.c_str()) &lt; 0;
  }

  my_String::my_String(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_allocator(bslma::Default::allocator(basicAllocator)), d_data(0)
  {
      d_data = myStrDup(<span class="stringliteral">&quot;&quot;</span>, d_allocator);
  }

  my_String::my_String(<span class="keyword">const</span> <span class="keywordtype">char</span> *s, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_allocator(bslma::Default::allocator(basicAllocator)), d_data(0)
  {
      d_data = myStrDup(s, d_allocator);
  }

  my_String::my_String(<span class="keyword">const</span> my_String&amp;  rhs,
                       <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_allocator(bslma::Default::allocator(basicAllocator)), d_data(0)
  {
      d_data = myStrDup(rhs.d_data, d_allocator);
  }

  my_String::~my_String()
  {
      d_allocator-&gt;deallocate(d_data);
  }

  my_String&amp; my_String::operator=(<span class="keyword">const</span> my_String&amp; rhs)
  {
      <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;rhs) {
          d_allocator-&gt;deallocate(d_data);
          d_data = myStrDup(rhs.d_data, d_allocator);
      }
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">const</span> <span class="keywordtype">char</span> *my_String::c_str()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_data;
  }

  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *my_String::allocator()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_allocator;
  }
</pre></div><br/>
<br/>
 Our main program creates a mapping from strings to integers. Each node of the mapping consists of a <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;my_String, int&gt;</code>. The program allocates memory from a test allocator in order to ensure that there are no leaks: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main()
  {
      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1pair.html">bsl::pair&lt;my_String, int&gt;</a> Node;

      Node *mapping[3];
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> alloc;
</pre></div><br/>
<br/>
 When constructing a <code>Node</code>, an allocator is supplied in addition to parameters for the <code>first</code> and <code>second</code> data members. <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      mapping[0] = <span class="keyword">new</span>(basicAllocator) Node(<span class="stringliteral">&quot;One&quot;</span>, 1, &amp;basicAllocator);
      mapping[1] = <span class="keyword">new</span>(basicAllocator) Node(<span class="stringliteral">&quot;Three&quot;</span>, 3, &amp;basicAllocator);
      mapping[2] = <span class="keyword">new</span>(basicAllocator) Node(<span class="stringliteral">&quot;Two&quot;</span>, 2, &amp;basicAllocator);
      <span class="comment">// Temporaries get destroyed here, even on broken compilers.</span>
  }

  assert(<span class="stringliteral">&quot;One&quot;</span> == mapping[0]-&gt;first);
  assert(1 == mapping[0]-&gt;second);
  assert(<span class="stringliteral">&quot;Three&quot;</span> == mapping[1]-&gt;first);
  assert(3 == mapping[1]-&gt;second);
  assert(<span class="stringliteral">&quot;Two&quot;</span> == mapping[2]-&gt;first);
  assert(2 == mapping[2]-&gt;second);

  assert(6 == alloc.<a class="code" href="classbslma_1_1TestAllocator.html#af33e8b7b63178f9f1c62f55cd9da1273">numBlocksInUse</a>());
</pre></div><br/>
<br/>
 Clean up at end. <br/>
<br/>
<div class="fragment"><pre class="fragment">      alloc.<a class="code" href="classbslma_1_1Allocator.html#abeccfe6cfd8205faf528a8e12f97aebe">deleteObjectRaw</a>(mapping[0]);
      alloc.<a class="code" href="classbslma_1_1Allocator.html#abeccfe6cfd8205faf528a8e12f97aebe">deleteObjectRaw</a>(mapping[1]);
      alloc.<a class="code" href="classbslma_1_1Allocator.html#abeccfe6cfd8205faf528a8e12f97aebe">deleteObjectRaw</a>(mapping[2]);

      assert(0 == alloc.<a class="code" href="classbslma_1_1TestAllocator.html#af33e8b7b63178f9f1c62f55cd9da1273">numBlocksInUse</a>());

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga1607d458602785df6d943b4eb9b9e188"></a><!-- doxytag: member="bsl::pair::first_type" ref="ga1607d458602785df6d943b4eb9b9e188" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T1 <a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::first_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab37f96992063e347a66ed75aeea3cd1f"></a><!-- doxytag: member="bsl::pair::second_type" ref="gab37f96992063e347a66ed75aeea3cd1f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T2 <a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::second_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gab498e054372f6da3d534aad79755f22e"></a><!-- doxytag: member="bsl::Pair_Imp::Pair_Imp" ref="gab498e054372f6da3d534aad79755f22e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2, int T1_USES_BSLMA, int T2_USES_BSLMA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, T1_USES_BSLMA, T2_USES_BSLMA &gt;::Pair_Imp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <code><a class="el" href="structbsl_1_1Pair__Imp.html">Pair_Imp</a></code> object from using default constructor for <code>first</code> and <code>second</code>. </p>

</div>
</div>
<a class="anchor" id="ga19267e0e2d7627e84f754225f14f9323"></a><!-- doxytag: member="bsl::Pair_Imp::Pair_Imp" ref="ga19267e0e2d7627e84f754225f14f9323" args="(const T1 &amp;a, const T2 &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2, int T1_USES_BSLMA, int T2_USES_BSLMA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, T1_USES_BSLMA, T2_USES_BSLMA &gt;::Pair_Imp </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga86070527c52543d1cffae8fd4ca04a8f"></a><!-- doxytag: member="bsl::Pair_Imp::Pair_Imp" ref="ga86070527c52543d1cffae8fd4ca04a8f" args="(const U1 &amp;a, const U2 &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2, int T1_USES_BSLMA, int T2_USES_BSLMA&gt; </div>
<div class="memtemplate">
template&lt;typename U1 , typename U2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, T1_USES_BSLMA, T2_USES_BSLMA &gt;::Pair_Imp </td>
          <td>(</td>
          <td class="paramtype">const U1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U2 &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <code><a class="el" href="structbsl_1_1Pair__Imp.html">Pair_Imp</a></code> object from specified values <code>a</code> and <code>b</code>. </p>

</div>
</div>
<a class="anchor" id="gad3fad5a7f26ea3f045978cc397688e71"></a><!-- doxytag: member="bsl::Pair_Imp::~Pair_Imp" ref="gad3fad5a7f26ea3f045978cc397688e71" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2, int T1_USES_BSLMA, int T2_USES_BSLMA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, T1_USES_BSLMA, T2_USES_BSLMA &gt;::~Pair_Imp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga482e8ad20afacaa48c6b849bf40ab2a2"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 1, 0 &gt;::Pair_Imp" ref="ga482e8ad20afacaa48c6b849bf40ab2a2" args="(BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 1, 0 &gt;::Pair_Imp </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <code><a class="el" href="structbsl_1_1Pair__Imp.html">Pair_Imp</a></code> object. Optionally specify a <code>basicAllocator</code> used to supply memory for <code>first</code>. Note that this specialization of <code><a class="el" href="structbsl_1_1Pair__Imp.html">Pair_Imp</a></code> guarantees that <code>second</code> does not need an allocator. </p>

</div>
</div>
<a class="anchor" id="ga668906c0ce7e59e4a1326f51c1297f6e"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 1, 0 &gt;::Pair_Imp" ref="ga668906c0ce7e59e4a1326f51c1297f6e" args="(const T1 &amp;a, const T2 &amp;b, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 1, 0 &gt;::Pair_Imp </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab8628751ef7ee6371b3bf7eb62e67870"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 1, 0 &gt;::Pair_Imp" ref="gab8628751ef7ee6371b3bf7eb62e67870" args="(const U1 &amp;a, const U2 &amp;b, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<div class="memtemplate">
template&lt;typename U1 , typename U2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 1, 0 &gt;::Pair_Imp </td>
          <td>(</td>
          <td class="paramtype">const U1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U2 &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <code><a class="el" href="structbsl_1_1Pair__Imp.html">Pair_Imp</a></code> object from specified values <code>a</code> and <code>b</code>. Optionally specify a <code>basicAllocator</code> used to supply memory for <code>first</code>. Note that this specialization of <code><a class="el" href="structbsl_1_1Pair__Imp.html">Pair_Imp</a></code> guarantees that <code>second</code> does not need an allocator. </p>

</div>
</div>
<a class="anchor" id="ga512d1a53027696febfe18c99d283612f"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 1, 0 &gt;::~Pair_Imp" ref="ga512d1a53027696febfe18c99d283612f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 1, 0 &gt;::~Pair_Imp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga5e999cf4054864965dc7098ccc1e40ce"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 0, 1 &gt;::Pair_Imp" ref="ga5e999cf4054864965dc7098ccc1e40ce" args="(BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 0, 1 &gt;::Pair_Imp </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <code><a class="el" href="structbsl_1_1Pair__Imp.html">Pair_Imp</a></code> object. Optionally specify a <code>basicAllocator</code> used to supply memory for <code>second</code>. Note that this specialization of <code><a class="el" href="structbsl_1_1Pair__Imp.html">Pair_Imp</a></code> guarantees that <code>first</code> does not need an allocator. </p>

</div>
</div>
<a class="anchor" id="gaab2988371f27ffb6a0d7eb813a12f212"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 0, 1 &gt;::Pair_Imp" ref="gaab2988371f27ffb6a0d7eb813a12f212" args="(const T1 &amp;a, const T2 &amp;b, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 0, 1 &gt;::Pair_Imp </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad48c0574dbbc9e6ada808aad1f98710d"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 0, 1 &gt;::Pair_Imp" ref="gad48c0574dbbc9e6ada808aad1f98710d" args="(const U1 &amp;a, const U2 &amp;b, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<div class="memtemplate">
template&lt;typename U1 , typename U2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 0, 1 &gt;::Pair_Imp </td>
          <td>(</td>
          <td class="paramtype">const U1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U2 &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <code><a class="el" href="structbsl_1_1Pair__Imp.html">Pair_Imp</a></code> object from specified values <code>a</code> and <code>b</code>. Optionally specify a <code>basicAllocator</code> used to supply memory for <code>second</code>. Note that this specialization of <code><a class="el" href="structbsl_1_1Pair__Imp.html">Pair_Imp</a></code> guarantees that <code>second</code> does not need an allocator. </p>

</div>
</div>
<a class="anchor" id="ga2271791af374d77c9573e32b21e8a283"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 0, 1 &gt;::~Pair_Imp" ref="ga2271791af374d77c9573e32b21e8a283" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 0, 1 &gt;::~Pair_Imp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="gabfb7000670eac96ed645f3914e6a1d4b"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 1, 1 &gt;::Pair_Imp" ref="gabfb7000670eac96ed645f3914e6a1d4b" args="(BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 1, 1 &gt;::Pair_Imp </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <code><a class="el" href="structbsl_1_1Pair__Imp.html">Pair_Imp</a></code> object. Optionally specify a <code>basicAllocator</code> used to supply memory for both <code>first</code> and <code>second</code>. </p>

</div>
</div>
<a class="anchor" id="gaa6a7c8b7cc7b6615cd9f22a26ccae7fe"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 1, 1 &gt;::Pair_Imp" ref="gaa6a7c8b7cc7b6615cd9f22a26ccae7fe" args="(const T1 &amp;a, const T2 &amp;b, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 1, 1 &gt;::Pair_Imp </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0f3b130c2aa7c5a53725ddf84bf3f4e4"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 1, 1 &gt;::Pair_Imp" ref="ga0f3b130c2aa7c5a53725ddf84bf3f4e4" args="(const U1 &amp;a, const U2 &amp;b, BloombergLP::bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<div class="memtemplate">
template&lt;typename U1 , typename U2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 1, 1 &gt;::Pair_Imp </td>
          <td>(</td>
          <td class="paramtype">const U1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U2 &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <code><a class="el" href="structbsl_1_1Pair__Imp.html">Pair_Imp</a></code> object from specified values <code>a</code> and <code>b</code>. Optionally specify a <code>basicAllocator</code> used to supply memory for both <code>first</code> and <code>second</code>. </p>

</div>
</div>
<a class="anchor" id="gaab0a48e9070629aaf42c754368739dc6"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 1, 1 &gt;::~Pair_Imp" ref="gaab0a48e9070629aaf42c754368739dc6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 1, 1 &gt;::~Pair_Imp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="gae640a0a8189758608a064c0c1e1deec1"></a><!-- doxytag: member="bsl::pair::pair" ref="gae640a0a8189758608a064c0c1e1deec1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::pair </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga24269c516271f2fc71a5b18762e2e18a"></a><!-- doxytag: member="bsl::pair::pair" ref="ga24269c516271f2fc71a5b18762e2e18a" args="(BloombergLP::bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::pair </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a pair. Default construct for <code>first</code> and <code>second</code>. Optionally specify a <code>basicAllocator</code> used to supply memory for the constructor(s) of which ever data member(s) accept an allocator. Attempted use of this constructor will not compile unless <code>T1</code> and <code>T2</code> both supply default constructors. Attempted use of either version of the allocator version will not compile unless one or both of <code>T1</code> and <code>T2</code> accept an allocator. </p>

</div>
</div>
<a class="anchor" id="ga55fdbe09c1a7c9f645f17ff1a18ff076"></a><!-- doxytag: member="bsl::pair::pair" ref="ga55fdbe09c1a7c9f645f17ff1a18ff076" args="(const T1 &amp;a, const T2 &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::pair </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf0cca61d59ac936dedc4b1c55d4d42c7"></a><!-- doxytag: member="bsl::pair::pair" ref="gaf0cca61d59ac936dedc4b1c55d4d42c7" args="(const T1 &amp;a, const T2 &amp;b, BloombergLP::bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::pair </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a pair from the specified values <code>a</code> and <code>b</code>. Copy-construct <code>first</code> from <code>a</code> and <code>second</code> from <code>b</code>. Optionally specify a <code>basicAllocator</code> used to supply memory for the constructor(s) of which ever data member(s) accept an allocator. Attempted use of of either version of this constructor will not compile unless <code>T1</code> and <code>T2</code> both supply copy constructors. Attempted use of the allocator version will not compile unless one or both of <code>T1</code> and <code>T2</code> accept an allocator. </p>

</div>
</div>
<a class="anchor" id="ga1a4e57de9e4d9481c2dfa1d8add1863e"></a><!-- doxytag: member="bsl::pair::pair" ref="ga1a4e57de9e4d9481c2dfa1d8add1863e" args="(const pair &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::pair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadef1dec3aa02c01bd4194a0314855481"></a><!-- doxytag: member="bsl::pair::pair" ref="gadef1dec3aa02c01bd4194a0314855481" args="(const pair &amp;rhs, BloombergLP::bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::pair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a pair from the specified <code>rhs</code> value. Copy-construct <code>first</code> from <code>rhs.first</code> and <code>second</code> from <code>rhs.second</code>. Optionally specify a <code>basicAllocator</code> used to supply memory for the constructor(s) of which ever data member(s) accept an allocator. Attempted use of of either version of this constructor will not compile unless <code>T1</code> and <code>T2</code> both supply copy constructors. Attempted use of the allocator version will not compile unless one or both of <code>T1</code> and <code>T2</code> accept an allocator. </p>

</div>
</div>
<a class="anchor" id="ga12dbd21daf216c3d387989376c666ca9"></a><!-- doxytag: member="bsl::pair::pair" ref="ga12dbd21daf216c3d387989376c666ca9" args="(const pair&lt; U1, U2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
<div class="memtemplate">
template&lt;typename U1 , typename U2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::pair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; U1, U2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1a2373cb1899fde967eb8366d819b04a"></a><!-- doxytag: member="bsl::pair::pair" ref="ga1a2373cb1899fde967eb8366d819b04a" args="(const pair&lt; U1, U2 &gt; &amp;rhs, BloombergLP::bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
<div class="memtemplate">
template&lt;typename U1 , typename U2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::pair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; U1, U2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a pair from the specified <code>rhs</code> value. Convert-construct <code>first</code> from <code>rhs.first</code> and <code>second</code> from <code>rhs.second</code>. Optionally specify a <code>basicAllocator</code> used to supply memory for the constructor(s) of which ever data member(s) accept an allocator. Attempted use of of either version of this constructor will not compile unless <code>T1</code> is constructible from <code>U1</code> and <code>T2</code> is constructible from <code>U2</code>. Attempted use of the allocator version will not compile unless one or both of <code>T1</code> and <code>T2</code> accept an allocator. </p>

</div>
</div>
<a class="anchor" id="ga38becfe3678b948fd16dbcd8d179e631"></a><!-- doxytag: member="bsl::pair::pair" ref="ga38becfe3678b948fd16dbcd8d179e631" args="(const native_std::pair&lt; U1, U2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
<div class="memtemplate">
template&lt;typename U1 , typename U2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::pair </td>
          <td>(</td>
          <td class="paramtype">const native_std::pair&lt; U1, U2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaaae3e1fd5890f19d557cfb085d7bd173"></a><!-- doxytag: member="bsl::pair::pair" ref="gaaae3e1fd5890f19d557cfb085d7bd173" args="(const native_std::pair&lt; U1, U2 &gt; &amp;rhs, BloombergLP::bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
<div class="memtemplate">
template&lt;typename U1 , typename U2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::pair </td>
          <td>(</td>
          <td class="paramtype">const native_std::pair&lt; U1, U2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a pair that has the same value as the specified <code>rhs</code> pair, where the type <code>rhs</code> is the pair type native to the compiler's library, holding the parameterized types <code>U1</code> and <code>U2</code>. Uses the default allocator to provide memory. Optionally specify a <code>basicAllocator</code> used to supply memory for the constructor(s) of which ever data member(s) accept an allocator. The behavior is undefined unless <code>T1</code> is constructible from <code>U1</code> and <code>T2</code> is constructible from from <code>U2</code>. </p>

</div>
</div>
<a class="anchor" id="ga6c0c09e954cdb153267cf6a35a3b2607"></a><!-- doxytag: member="bsl::pair::~pair" ref="ga6c0c09e954cdb153267cf6a35a3b2607" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::~pair </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. Call destructors on <code>first</code> and <code>second</code>. </p>

</div>
</div>
<a class="anchor" id="ga6545f413b6b7e1ea2c759b02310213bb"></a><!-- doxytag: member="bsl::pair::operator=" ref="ga6545f413b6b7e1ea2c759b02310213bb" args="(const pair &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&amp; <a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this pair from the specified <code>rhs</code> value and return a modifiable reference to this object. Assign <code>first</code> the value in <code>rhs.first</code> and <code>second</code> the value in <code>rhs.second</code>. Attempted use of this assignment operator will not compile unless both <code>T1</code> and <code>T2</code> supply assignment operators. </p>

</div>
</div>
<a class="anchor" id="ga87ead47d7766b5e4f64a3940340e66aa"></a><!-- doxytag: member="bsl::pair::operator=" ref="ga87ead47d7766b5e4f64a3940340e66aa" args="(const native_std::pair&lt; U1, U2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
<div class="memtemplate">
template&lt;typename U1 , typename U2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&amp; <a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const native_std::pair&lt; U1, U2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this pair from the specified <code>rhs</code> pair, where the type <code>rhs</code> is the pair type native to the compiler's library, holding the parameterized types <code>U1</code> and <code>U2</code>, and return a modifiable reference to this object. Assign <code>first</code> the value in <code>rhs.first</code> and <code>second</code> the value in <code>rhs.second</code>. Attempted use of this assignment operator will not compile unless both <code>T1</code> and <code>T2</code> supply assignment operators, and <code>T1</code> is assignable from <code>U1</code> and <code>T2</code> is assignable from <code>U2</code>. </p>

</div>
</div>
<a class="anchor" id="ga7c1cf552d0d745d92dfaa76dd8ba4576"></a><!-- doxytag: member="bsl::pair::swap" ref="ga7c1cf552d0d745d92dfaa76dd8ba4576" args="(pair &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; T1, T2 &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap the value of this pair with the value of the specified <code>other</code> pair by applying <code>swap</code> to each of the <code>first</code> and <code>second</code> pair fields. Note that this method is no-throw only if <code>swap</code> on each field is no-throw. </p>

</div>
</div>
<a class="anchor" id="ga50b4aea952721acf5ad54aa2bc758c8d"></a><!-- doxytag: member="bsl::operator!=" ref="ga50b4aea952721acf5ad54aa2bc758c8d" args="(const pair&lt; T1, T2 &gt; &amp;lhs, const pair&lt; T1, T2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the specified <code>lhs</code> and <code>rhs</code> pair objects do not have the same value and false otherwise. <code>lhs</code> does not have the same value as <code>rhs</code> if <code>lhs == rhs</code> would return false. A call to this operator will not compile unless a call to <code>lhs == rhs</code> would compile. </p>

</div>
</div>
<a class="anchor" id="ga97c477e75c90f40b8122aa0702fb652c"></a><!-- doxytag: member="bsl::operator&lt;" ref="ga97c477e75c90f40b8122aa0702fb652c" args="(const pair&lt; T1, T2 &gt; &amp;lhs, const pair&lt; T1, T2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the specified <code>lhs</code> has a value less than the specified <code>rhs</code> and false otherwise. Whether or not <code>lhs</code> is less than <code>rhs</code> is determined by a lexicographical comparison of the <code>first</code> and <code>second</code> data members of <code>lhs</code> and <code>rhs</code>. In other words: return true if <code>lhs.first &lt; rhs.first</code> and false if <code>rhs.first &lt; lhs.first</code>, otherwise return <code>lhs.second &lt; rhs.second</code>. A call to this operator will not compile unless both <code>T1</code> and <code>T2</code> supply <code>operator&lt;</code>. </p>

</div>
</div>
<a class="anchor" id="gaecdfed596ebac61d4ebfda51e911b916"></a><!-- doxytag: member="bsl::operator&gt;" ref="gaecdfed596ebac61d4ebfda51e911b916" args="(const pair&lt; T1, T2 &gt; &amp;lhs, const pair&lt; T1, T2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the specified <code>lhs</code> has a value greater than the specified <code>rhs</code> and false otherwise. <code>lhs</code> has a value greater than <code>rhs</code> if <code>rhs</code> &lt; <code>lhs</code> would return true. A call to this operator will not compile unless a call to <code>lhs &lt; rhs</code> would compile. </p>

</div>
</div>
<a class="anchor" id="gade131fc530151248b67d2c88522832e3"></a><!-- doxytag: member="bsl::operator&lt;=" ref="gade131fc530151248b67d2c88522832e3" args="(const pair&lt; T1, T2 &gt; &amp;lhs, const pair&lt; T1, T2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the specified <code>lhs</code> has a value less than or equal to the specified <code>rhs</code> and false otherwise. <code>lhs</code> has a value less than or equal to <code>rhs</code> if <code>rhs</code> &lt; <code>lhs</code> would return false. A call to this operator will not compile unless a call to <code>lhs &lt; rhs</code> would compile. </p>

</div>
</div>
<a class="anchor" id="gaa19d2c4a4e8788af13eab13f37c5e53e"></a><!-- doxytag: member="bsl::operator&gt;=" ref="gaa19d2c4a4e8788af13eab13f37c5e53e" args="(const pair&lt; T1, T2 &gt; &amp;lhs, const pair&lt; T1, T2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the specified <code>lhs</code> has a value greater than or equal to the specified <code>rhs</code> and false otherwise. <code>lhs</code> has a value greater than or equal to <code>rhs</code> if <code>lhs</code> &lt; <code>rhs</code> would return false. A call to this operator will not compile unless a call to <code>lhs &lt; rhs</code> would compile. </p>

</div>
</div>
<a class="anchor" id="ga8dd0a3f8324bcc657bc448230e8f5b4b"></a><!-- doxytag: member="bsl::swap" ref="ga8dd0a3f8324bcc657bc448230e8f5b4b" args="(pair&lt; T1, T2 &gt; &amp;a, pair&lt; T1, T2 &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap the values of the specified <code>a</code> and <code>b</code> pairs by applying <code>swap</code> to each of the <code>first</code> and <code>second</code> pair fields. Note that this method is no-throw only if <code>swap</code> on each field is no-throw. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="gafff8113b0b2f4bbe5df93ce0ba30fad8"></a><!-- doxytag: member="bsl::Pair_Imp::first" ref="gafff8113b0b2f4bbe5df93ce0ba30fad8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2, int T1_USES_BSLMA, int T2_USES_BSLMA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T1 <a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, T1_USES_BSLMA, T2_USES_BSLMA &gt;::first<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf89d2b38598dfb6fa42775f2e135f1d8"></a><!-- doxytag: member="bsl::Pair_Imp::second" ref="gaf89d2b38598dfb6fa42775f2e135f1d8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2, int T1_USES_BSLMA, int T2_USES_BSLMA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T2 <a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, T1_USES_BSLMA, T2_USES_BSLMA &gt;::second<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga52bffab66534dccc96ed8aa4e5f7fe09"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 1, 0 &gt;::first" ref="ga52bffab66534dccc96ed8aa4e5f7fe09" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T1 <a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 1, 0 &gt;::first<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga38b70ca829c7b7faba853e1aff1698be"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 1, 0 &gt;::second" ref="ga38b70ca829c7b7faba853e1aff1698be" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T2 <a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 1, 0 &gt;::second<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga71941daa05f41127a261dac8fe360316"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 0, 1 &gt;::first" ref="ga71941daa05f41127a261dac8fe360316" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T1 <a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 0, 1 &gt;::first<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4ebdfd6b26e36efe8252bc5fad30c690"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 0, 1 &gt;::second" ref="ga4ebdfd6b26e36efe8252bc5fad30c690" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T2 <a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 0, 1 &gt;::second<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga48c316b7fbaff4cab082f67643e95a03"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 1, 1 &gt;::first" ref="ga48c316b7fbaff4cab082f67643e95a03" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T1 <a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 1, 1 &gt;::first<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga19e3aeb0d9cf5b2bff066c8906306e19"></a><!-- doxytag: member="bsl::Pair_Imp&lt; T1, T2, 1, 1 &gt;::second" ref="ga19e3aeb0d9cf5b2bff066c8906306e19" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T2 <a class="el" href="structbsl_1_1Pair__Imp.html">bsl::Pair_Imp</a>&lt; T1, T2, 1, 1 &gt;::second<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:43 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
