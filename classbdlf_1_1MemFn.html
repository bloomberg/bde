<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlf::MemFn</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlf.html">bdlf</a>      </li>
      <li><a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn&lt; PROTOTYPE &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlf::MemFn&lt; PROTOTYPE &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlf::MemFn" -->
<p><code>#include &lt;<a class="el" href="bdlf__memfn_8h_source.html">bdlf_memfn.h</a>&gt;</code></p>

<p><a href="classbdlf_1_1MemFn-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Traits::ResultType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Traits::ArgumentList&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a651b0fde2109606d8fa407942c5fe393">Args</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Traits::ClassType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#acbe26a94c3998c68093cf96cc3967f35">ObjectType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef PROTOTYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#ad6158739e108470553fbbbb093de3aae">Prototype</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef PROTOTYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a3064800bef953155d98ca4961e752f3e">ProtoType</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#ac7aab9edd4f0e3e006999353933dc9d6">BSLMF_NESTED_TRAIT_DECLARATION</a> (<a class="el" href="classbdlf_1_1MemFn.html">MemFn</a>, <a class="el" href="structbsl_1_1is__trivially__copyable.html">bsl::is_trivially_copyable</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a6332eba64c52c7225563d3d04db83b72">BSLMF_NESTED_TRAIT_DECLARATION</a> (<a class="el" href="classbdlf_1_1MemFn.html">MemFn</a>, <a class="el" href="structbslmf_1_1IsBitwiseMoveable.html">bslmf::IsBitwiseMoveable</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a714c81dd58118ebe3626efc90242807a">MemFn</a> (PROTOTYPE func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a0648afb6cb86e8807bc9ee3081f04538">MemFn</a> (const <a class="el" href="classbdlf_1_1MemFn.html">MemFn</a>&lt; PROTOTYPE &gt; &amp;original)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a1f07ec1074ad31ecaa5d873bba15b244">operator()</a> (INSTANCE &amp;object) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#ac2d82e923d9ceb1138526090c01ab0af">operator()</a> (INSTANCE &amp;object, A1 a1) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#acd03d8a90344755517b7683b7a457101">operator()</a> (INSTANCE &amp;object, A1 a1, A2 a2) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#aa00b68f50fcdddd1ea9bf04239e9b39b">operator()</a> (INSTANCE &amp;object, A1 a1, A2 a2, A3 a3) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#acd4a0129c0f8231819ae2476aca7a89b">operator()</a> (INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#af443424a79d9fd1ba0e60364e67c0eb0">operator()</a> (INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a2ee4086255e18209ee41583393149492">operator()</a> (INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#afa8685dc67ed865d2917a5bda682a87b">operator()</a> (INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#aab7cbdbd8bf2f6c5972fb8021fbbaea2">operator()</a> (INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a91232fceef2e36c13e4a81de9e96dacf">operator()</a> (INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#ad201e31ee6169ba8ef4decfafd2d4599">operator()</a> (INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a2404f31598a0072a135b0d7586850ad1">operator()</a> (INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a2d72c2f4dbcd98503a1bd40fe174795b">operator()</a> (INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#abc6d72c8b2c775d7e7a9b1d362306b8c">operator()</a> (INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a5965e1b3d8ee7fe9cdf3c68658dce382">operator()</a> (INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a219456052944665738071abe6cc11ed9">operator()</a> (const INSTANCE &amp;object) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a436ae0d94d987fe259bb6112553c0919">operator()</a> (const INSTANCE &amp;object, A1 a1) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a45330278723fb663bb0c21c5d1ccfe42">operator()</a> (const INSTANCE &amp;object, A1 a1, A2 a2) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#ad7524662324928faa10a5c5c3ef86d57">operator()</a> (const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a66715ce3765e2ea04f34aeb8eec7d9dd">operator()</a> (const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#af8a3bc895eecd779d669b5e1fc7e681f">operator()</a> (const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#ad08dadd17bc52086500496d7d7968615">operator()</a> (const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a9e493b9f34a7e226b88de670c439eb2b">operator()</a> (const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#aeef678a3290898f7d246b9988f9d2c62">operator()</a> (const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a1119b7dca68a3ad2f3457897cf987f90">operator()</a> (const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a5dbf13c1c6a7bc029909fdefc7c13fcd">operator()</a> (const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#a7f64879336a201c7ab31206aeeaa5ed5">operator()</a> (const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#afbf33f146bff6058a42ce6cf1d602dc2">operator()</a> (const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#aad9a796d57946ae095d8b21e8f933c39">operator()</a> (const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INSTANCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlf_1_1MemFn.html#aa2dccec0de0f9059c5b41669d2cf29a3">operator()</a> (const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class PROTOTYPE&gt;<br/>
 class bdlf::MemFn&lt; PROTOTYPE &gt;</h3>

<p>This class encapsulates a member function pointer having the parameterized <code>PROTOTYPE</code>, such that the member function pointer can be invoked in syntactically the same manner as a free function pointer. When invoking a member function through this wrapper, the first argument must be a pointer or reference to the instance on which to invoke the member function pointer. Zero to fourteen additional arguments may be specified depending on <code>PROTOTYPE</code>. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a47f8447e9ddbc7a5b5c4864ba7639b2b"></a><!-- doxytag: member="bdlf::MemFn::ResultType" ref="a47f8447e9ddbc7a5b5c4864ba7639b2b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Traits::ResultType <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::<a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a651b0fde2109606d8fa407942c5fe393"></a><!-- doxytag: member="bdlf::MemFn::Args" ref="a651b0fde2109606d8fa407942c5fe393" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Traits::ArgumentList <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::<a class="el" href="classbdlf_1_1MemFn.html#a651b0fde2109606d8fa407942c5fe393">Args</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acbe26a94c3998c68093cf96cc3967f35"></a><!-- doxytag: member="bdlf::MemFn::ObjectType" ref="acbe26a94c3998c68093cf96cc3967f35" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Traits::ClassType <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::<a class="el" href="classbdlf_1_1MemFn.html#acbe26a94c3998c68093cf96cc3967f35">ObjectType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad6158739e108470553fbbbb093de3aae"></a><!-- doxytag: member="bdlf::MemFn::Prototype" ref="ad6158739e108470553fbbbb093de3aae" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef PROTOTYPE <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::<a class="el" href="classbdlf_1_1MemFn.html#ad6158739e108470553fbbbb093de3aae">Prototype</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3064800bef953155d98ca4961e752f3e"></a><!-- doxytag: member="bdlf::MemFn::ProtoType" ref="a3064800bef953155d98ca4961e752f3e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef PROTOTYPE <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::<a class="el" href="classbdlf_1_1MemFn.html#a3064800bef953155d98ca4961e752f3e">ProtoType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a714c81dd58118ebe3626efc90242807a"></a><!-- doxytag: member="bdlf::MemFn::MemFn" ref="a714c81dd58118ebe3626efc90242807a" args="(PROTOTYPE func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::<a class="el" href="classbdlf_1_1MemFn.html">MemFn</a> </td>
          <td>(</td>
          <td class="paramtype">PROTOTYPE&nbsp;</td>
          <td class="paramname"> <em>func</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a member function pointer wrapper holding the address of the specified <code>func</code> member function having the parameterized <code>PROTOTYPE</code>. </p>

</div>
</div>
<a class="anchor" id="a0648afb6cb86e8807bc9ee3081f04538"></a><!-- doxytag: member="bdlf::MemFn::MemFn" ref="a0648afb6cb86e8807bc9ee3081f04538" args="(const MemFn&lt; PROTOTYPE &gt; &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::<a class="el" href="classbdlf_1_1MemFn.html">MemFn</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlf_1_1MemFn.html">MemFn</a>&lt; PROTOTYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a member function pointer wrapper holding the address of the same member function as the specified <code>original</code> object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac7aab9edd4f0e3e006999353933dc9d6"></a><!-- doxytag: member="bdlf::MemFn::BSLMF_NESTED_TRAIT_DECLARATION" ref="ac7aab9edd4f0e3e006999353933dc9d6" args="(MemFn, bsl::is_trivially_copyable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlf_1_1MemFn.html">MemFn</a>&lt; PROTOTYPE &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsl_1_1is__trivially__copyable.html">bsl::is_trivially_copyable</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6332eba64c52c7225563d3d04db83b72"></a><!-- doxytag: member="bdlf::MemFn::BSLMF_NESTED_TRAIT_DECLARATION" ref="a6332eba64c52c7225563d3d04db83b72" args="(MemFn, bslmf::IsBitwiseMoveable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlf_1_1MemFn.html">MemFn</a>&lt; PROTOTYPE &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1IsBitwiseMoveable.html">bslmf::IsBitwiseMoveable</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1f07ec1074ad31ecaa5d873bba15b244"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="a1f07ec1074ad31ecaa5d873bba15b244" args="(INSTANCE &amp;object) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a modifiable instance of the parameterized <code>INSTANCE</code> type, with no specified arguments, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="ac2d82e923d9ceb1138526090c01ab0af"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="ac2d82e923d9ceb1138526090c01ab0af" args="(INSTANCE &amp;object, A1 a1) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified argument <code>a1</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="acd03d8a90344755517b7683b7a457101"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="acd03d8a90344755517b7683b7a457101" args="(INSTANCE &amp;object, A1 a1, A2 a2) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified argument <code>a1</code> up to <code>a2</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="aa00b68f50fcdddd1ea9bf04239e9b39b"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="aa00b68f50fcdddd1ea9bf04239e9b39b" args="(INSTANCE &amp;object, A1 a1, A2 a2, A3 a3) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified argument <code>a1</code> up to <code>a3</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="acd4a0129c0f8231819ae2476aca7a89b"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="acd4a0129c0f8231819ae2476aca7a89b" args="(INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified argument <code>a1</code> up to <code>a4</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="af443424a79d9fd1ba0e60364e67c0eb0"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="af443424a79d9fd1ba0e60364e67c0eb0" args="(INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified argument <code>a1</code> up to <code>a5</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ee4086255e18209ee41583393149492"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="a2ee4086255e18209ee41583393149492" args="(INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified argument <code>a1</code> up to <code>a6</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="afa8685dc67ed865d2917a5bda682a87b"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="afa8685dc67ed865d2917a5bda682a87b" args="(INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified argument <code>a1</code> up to <code>a7</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="aab7cbdbd8bf2f6c5972fb8021fbbaea2"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="aab7cbdbd8bf2f6c5972fb8021fbbaea2" args="(INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified argument <code>a1</code> up to <code>a8</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="a91232fceef2e36c13e4a81de9e96dacf"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="a91232fceef2e36c13e4a81de9e96dacf" args="(INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified argument <code>a1</code> up to <code>a9</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="ad201e31ee6169ba8ef4decfafd2d4599"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="ad201e31ee6169ba8ef4decfafd2d4599" args="(INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A10&nbsp;</td>
          <td class="paramname"> <em>a10</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified argument <code>a1</code> up to <code>a10</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="a2404f31598a0072a135b0d7586850ad1"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="a2404f31598a0072a135b0d7586850ad1" args="(INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A10&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A11&nbsp;</td>
          <td class="paramname"> <em>a11</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified argument <code>a1</code> up to <code>a11</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d72c2f4dbcd98503a1bd40fe174795b"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="a2d72c2f4dbcd98503a1bd40fe174795b" args="(INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A10&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A11&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A12&nbsp;</td>
          <td class="paramname"> <em>a12</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified argument <code>a1</code> up to <code>a12</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="abc6d72c8b2c775d7e7a9b1d362306b8c"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="abc6d72c8b2c775d7e7a9b1d362306b8c" args="(INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A10&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A11&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A12&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A13&nbsp;</td>
          <td class="paramname"> <em>a13</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified argument <code>a1</code> up to <code>a13</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="a5965e1b3d8ee7fe9cdf3c68658dce382"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="a5965e1b3d8ee7fe9cdf3c68658dce382" args="(INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A10&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A11&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A12&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A13&nbsp;</td>
          <td class="paramname"> <em>a13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A14&nbsp;</td>
          <td class="paramname"> <em>a14</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified argument <code>a1</code> up to <code>a14</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="a219456052944665738071abe6cc11ed9"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="a219456052944665738071abe6cc11ed9" args="(const INSTANCE &amp;object) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a non-modifiable instance of the parameterized <code>INSTANCE</code> type, with no arguments, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="a436ae0d94d987fe259bb6112553c0919"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="a436ae0d94d987fe259bb6112553c0919" args="(const INSTANCE &amp;object, A1 a1) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a non-modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified argument <code>a1</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="a45330278723fb663bb0c21c5d1ccfe42"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="a45330278723fb663bb0c21c5d1ccfe42" args="(const INSTANCE &amp;object, A1 a1, A2 a2) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a non-modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified arguments <code>a1</code> up to <code>a2</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="ad7524662324928faa10a5c5c3ef86d57"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="ad7524662324928faa10a5c5c3ef86d57" args="(const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a non-modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified arguments <code>a1</code> up to <code>a3</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="a66715ce3765e2ea04f34aeb8eec7d9dd"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="a66715ce3765e2ea04f34aeb8eec7d9dd" args="(const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a non-modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified arguments <code>a1</code> up to <code>a4</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="af8a3bc895eecd779d669b5e1fc7e681f"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="af8a3bc895eecd779d669b5e1fc7e681f" args="(const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a non-modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified arguments <code>a1</code> up to <code>a5</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="ad08dadd17bc52086500496d7d7968615"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="ad08dadd17bc52086500496d7d7968615" args="(const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a non-modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified arguments <code>a1</code> up to <code>a6</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e493b9f34a7e226b88de670c439eb2b"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="a9e493b9f34a7e226b88de670c439eb2b" args="(const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a non-modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified arguments <code>a1</code> up to <code>a7</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="aeef678a3290898f7d246b9988f9d2c62"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="aeef678a3290898f7d246b9988f9d2c62" args="(const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a non-modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified arguments <code>a1</code> up to <code>a8</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="a1119b7dca68a3ad2f3457897cf987f90"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="a1119b7dca68a3ad2f3457897cf987f90" args="(const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a non-modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified arguments <code>a1</code> up to <code>a9</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="a5dbf13c1c6a7bc029909fdefc7c13fcd"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="a5dbf13c1c6a7bc029909fdefc7c13fcd" args="(const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A10&nbsp;</td>
          <td class="paramname"> <em>a10</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a non-modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified arguments <code>a1</code> up to <code>a10</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="a7f64879336a201c7ab31206aeeaa5ed5"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="a7f64879336a201c7ab31206aeeaa5ed5" args="(const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A10&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A11&nbsp;</td>
          <td class="paramname"> <em>a11</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a non-modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified arguments <code>a1</code> up to <code>a11</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="afbf33f146bff6058a42ce6cf1d602dc2"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="afbf33f146bff6058a42ce6cf1d602dc2" args="(const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A10&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A11&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A12&nbsp;</td>
          <td class="paramname"> <em>a12</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a non-modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified arguments <code>a1</code> up to <code>a12</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="aad9a796d57946ae095d8b21e8f933c39"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="aad9a796d57946ae095d8b21e8f933c39" args="(const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A10&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A11&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A12&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A13&nbsp;</td>
          <td class="paramname"> <em>a13</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a non-modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified arguments <code>a1</code> up to <code>a13</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2dccec0de0f9059c5b41669d2cf29a3"></a><!-- doxytag: member="bdlf::MemFn::operator()" ref="aa2dccec0de0f9059c5b41669d2cf29a3" args="(const INSTANCE &amp;object, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PROTOTYPE&gt; </div>
<div class="memtemplate">
template&lt;class INSTANCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlf_1_1MemFn.html#a47f8447e9ddbc7a5b5c4864ba7639b2b">ResultType</a> <a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a>&lt; PROTOTYPE &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const INSTANCE &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A1&nbsp;</td>
          <td class="paramname"> <em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A2&nbsp;</td>
          <td class="paramname"> <em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A3&nbsp;</td>
          <td class="paramname"> <em>a3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A4&nbsp;</td>
          <td class="paramname"> <em>a4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A5&nbsp;</td>
          <td class="paramname"> <em>a5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A6&nbsp;</td>
          <td class="paramname"> <em>a6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A7&nbsp;</td>
          <td class="paramname"> <em>a7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A8&nbsp;</td>
          <td class="paramname"> <em>a8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A9&nbsp;</td>
          <td class="paramname"> <em>a9</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A10&nbsp;</td>
          <td class="paramname"> <em>a10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A11&nbsp;</td>
          <td class="paramname"> <em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A12&nbsp;</td>
          <td class="paramname"> <em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A13&nbsp;</td>
          <td class="paramname"> <em>a13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A14&nbsp;</td>
          <td class="paramname"> <em>a14</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; Invoke the member function pointer held by this wrapper on the specified <code>object</code> reference to a non-modifiable instance of the parameterized <code>INSTANCE</code> type, with the specified arguments <code>a1</code> up to <code>a14</code>, and return the result of this invocation, or <code>void</code> if this member function pointer does not return a result. </p>

<p>References <a class="el" href="structbdlf_1_1MemFn__Dereference.html#ade67d53faaec049a66134e14d8a0d8e8">bdlf::MemFn_Dereference&lt; OBJTYPE &gt;::deref()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlf__memfn_8h_source.html">bdlf_memfn.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:30 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
