<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslmt_threadattributes.h                                           -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BSLMT_THREADATTRIBUTES
#define INCLUDED_BSLMT_THREADATTRIBUTES

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a description of the attributes of a thread.
//
//@CLASSES:
//  bslmt::ThreadAttributes: description of the attributes of a thread
//
//@SEE_ALSO: bslmt_threadutil, bslmt_configuration
//
//@DESCRIPTION: This component provides a simply constrained (value-semantic)
// attribute class, &#39;bslmt::ThreadAttributes&#39;, for describing attributes of a
// thread in a platform-independent way.
//
// The default values and constraints for the attributes provided by
// &#39;bslmt::ThreadAttributes&#39; are listed in the following two tables:
//..
//  Name                Type                   Default
//  ------------------  ---------------------  ----------------------
//  detachedState       enum DetachedState     e_CREATE_JOINABLE
//  stackSize           int                    e_UNSET_STACK_SIZE
//  guardSize           int                    e_UNSET_GUARD_SIZE
//  inheritSchedule     bool                   &#39;true&#39;
//  schedulingPolicy    enum SchedulingPolicy  e_SCHED_DEFAULT
//  schedulingPriority  int                    e_UNSET_PRIORITY
//
//  Name          Constraint
//  ---------     ---------------------------------------------------
//  stackSize     &#39;e_UNSET_STACK_SIZE == stackSize || 0 &lt;= stackSize&#39;
//  guardSize     &#39;e_UNSET_GUARD_SIZE == guardSize || 0 &lt;= guardSize&#39;
//..
//
///&#39;detachedState&#39; Attribute
///- - - - - - - - - - - - -
// The &#39;detachedState&#39; attribute indicates whether an associated thread should
// be created in a joinable or detached state, through the enum values
// &#39;e_CREATE_JOINABLE&#39; and &#39;e_CREATE_DETACHED&#39;, respectively.  A thread in the
// joinable state will have its exit status maintained after thread
// termination.  Any thread can join with a joinable thread (see
// &#39;bslmt_threadutil&#39;), in which case the joining thread will block, waiting
// for the joined thread&#39;s execution to complete, after which the joined
// thread&#39;s termination status will be reported back to the joining thread, and
// its resources reclaimed.  A thread in a detached state will have its
// resources claimed at thread termination, and cannot be joined.  Note that a
// joinable thread can be made detached after it is created, but not vice
// versa.
//
///&#39;stackSize&#39; Attribute
///- - - - - - - - - - -
// The &#39;stackSize&#39; attribute indicates the size, in bytes, of the stack that
// should be provided to a newly created thread.  If the stack size is
// &#39;e_UNSET_STACK_SIZE&#39; then a created thread will be provided a default stack
// size (see &#39;bslmt_configuration&#39;).  The &#39;stackSize&#39; attribute should be
// interpreted to mean that a created thread can safely define an automatic
// variable of the configured &#39;stackSize&#39; bytes in its thread-entry function.
// Note that, on some platforms, an adjusted value derived from the &#39;stackSize&#39;
// attribute may be supplied to the underlying representation by the thread
// creation function -- for example, on Itanium (HPUX), the &#39;stackSize&#39;
// attribute value must be scaled up to account for the extra stack space
// devoted to register storage.
//
///&#39;guardSize&#39; Attribute
///- - - - - - - - - - -
// The &#39;guardSize&#39; attribute indicates the size of the memory region to provide
// past the end of a created thread&#39;s stack to protect against stack overflows.
// If a thread&#39;s stack pointer overflows into a guard area, the task will
// receive an error (e.g., a signal).  If &#39;guardSize&#39; is &#39;e_UNSET_GUARD_SIZE&#39;,
// then a created thread will be provided with a default native guard size (see
// &#39;bslmt_configuration&#39;).  Note that the interpretation of &#39;guardSize&#39; may
// vary among platforms, and the value may be adjusted up (e.g., by rounding up
// to a multiple of page size) or ignored entirely (e.g., the Windows platform
// does not support this attribute).
//
///&#39;inheritSchedule&#39; Attribute
///- - - - - - - - - - - - - -
// The &#39;inheritSchedule&#39; attribute, if &#39;true&#39;, indicates that a created
// thread&#39;s &#39;schedulingPolicy&#39; and &#39;schedulingPriority&#39; attributes should be
// taken from its parent thread and the configured values of those thread
// attributes should be ignored.  If &#39;inheritSchedule&#39; is &#39;false&#39;, then the
// &#39;schedulingPolicy&#39; and &#39;schedulingPriority&#39; attribute values should be used
// to configure a thread.  See &#39;bslmt_threadutil&#39; for information about support
// for this attribute.
//
///&#39;schedulingPolicy&#39; Attribute
/// - - - - - - - - - - - - - -
// The &#39;schedulingPolicy&#39; attribute indicates the policy that should be used to
// schedule the created thread for execution.  Typically clients should use the
// default platform supplied scheduling policy, which is indicated by the
// &#39;e_SCHED_DEFAULT&#39; value.  The alternative scheduling policies,
// &#39;e_THREAD_FIFO&#39; and &#39;e_SCHED_RR&#39;, are &quot;real-time&quot; scheduling policies, and
// may not be available unless the task is run with the appropriate privileges.
// &#39;e_SCHED_FIFO&#39; indicates a thread should run until it either yields or is
// interrupted by a thread of higher priority.  &#39;e_SCHED_RR&#39; is the same as
// &#39;e_SCHED_FIFO&#39;, except that the created thread may be interrupted by a ready
// thread of equal priority after a finite time-slice.  This attribute is
// ignored unless &#39;inheritSchedule&#39; is &#39;false&#39;.  See &#39;bslmt_threadutil&#39; for
// information about support for this attribute.
//
///&#39;schedulingPriority&#39; Attribute
/// - - - - - - - - - - - - - - -
// The &#39;schedulingPriority&#39; attribute is a platform specific value whose valid
// values range from the minimum to the maximum value for the associated
// &#39;schedulingPolicy&#39;, with higher numbers indicating a more urgent priority.
// Functions to obtain the minimum and maximum values are in this component and
// &#39;bslmt_threadutil&#39;.  This attribute is ignored unless &#39;inheritSchedule&#39; is
// &#39;false&#39;.  See &#39;bslmt_threadutil&#39; for information about support for this
// attribute.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Creating and Modifying Thread Attributes Objects
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// In this example we will demonstrate creating and configuring a
// &#39;bslmt::ThreadAttributes&#39; object, then using it with a hypothetical
// thread-creation function.  Finally we show how a thread creation function
// might interpret those attributes for the underlying operating system.
//
// First we forward declare a routine that we will use to create a thread:
//..
//  void myThreadCreate(int                             *threadHandle,
//                      const bslmt::ThreadAttributes&amp;   attributes,
//                      void                           (*function)());
//      // Spawn a thread having properties described by the specified
//      // &#39;attributes&#39; and that runs the specified &#39;function&#39;, and assign a
//      // handle referring to the spawned thread to the specified
//      // &#39;*threadHandle&#39;.
//..
// Then, we declare two routines that will return the minimum and maximum
// thread priority given a scheduling policy.  Note that similar methods exist
// in &#39;bslmt_threadutil&#39;.
//..
//  int myMinPriority(bslmt::ThreadAttributes::SchedulingPolicy policy);
//  int myMaxPriority(bslmt::ThreadAttributes::SchedulingPolicy policy);
//..
// Next we define a function that we will use as our thread entry point.  This
// function declares a single variable on the stack of predetermined size.
//..
//  enum { k_BUFFER_SIZE = 128 * 1024 };
//
//  void myThreadFunction()
//  {
//      int bufferLocal[k_BUFFER_SIZE];
//
//      // Perform some calculation that involves no subroutine calls or
//      // additional automatic variables.
//  }
//..
// Then, we define our main function, in which we demonstrate configuring a
// &#39;bslmt::ThreadAttributes&#39; object describing the properties a thread we will
// create.
//..
//  void testMain()
//  {
//..
// Next, we create a thread attributes object, &#39;attributes&#39;, and set its
// &#39;stackSize&#39; attribute to a value large enough to accommodate the
// &#39;BUFFER_SIZE&#39; buffer used by &#39;myThreadFunction&#39;.  Note that we use
// &#39;BUFFER_SIZE&#39; as an illustration; in practice, it is difficult or impossible
// to gauge the exact amount of stack size required for a typical thread, and
// the value supplied should be a reasonable *upper* bound on the anticipated
// requirement.
//..
//      bslmt::ThreadAttributes attributes;
//      attributes.setStackSize(k_BUFFER_SIZE);
//..
// Then, we set the &#39;detachedState&#39; property to &#39;e_CREATE_DETACHED&#39;, indicating
// that the thread will not be joinable, and its resources will be reclaimed
// upon termination.
//..
//      attributes.setDetachedState(
//                             bslmt::ThreadAttributes::e_CREATE_DETACHED);
//..
// Now, we create a thread, using the attributes configured above:
//..
//      int handle;
//      myThreadCreate(&amp;handle, attributes, &amp;myThreadFunction);
//  }
//..
// Finally, we define the thread creation function, and show how a thread
// attributes object might be interpreted by it:
//..
//  void myThreadCreate(int                             *threadHandle,
//                      const bslmt::ThreadAttributes&amp;   attributes,
//                      void                           (*function)())
//      // Spawn a thread with properties described by the specified
//      // &#39;attributes&#39;, running the specified &#39;function&#39;, and assign a handle
//      // referring to the spawned thread to the specified &#39;*threadHandle&#39;.
//  {
//      int stackSize = attributes.stackSize();
//      if (bslmt::ThreadAttributes::e_UNSET_STACK_SIZE == stackSize) {
//          stackSize = bslmt::Configuration::defaultThreadStackSize();
//      }
//
//      // Add a &quot;fudge factor&quot; to &#39;stackSize&#39; to ensure that the client can
//      // declare an object of &#39;stackSize&#39; bytes on the stack safely.
//
//      stackSize += 8192;
//
//  #ifdef BSLS_PLATFORM_OS_HPUX
//      // The Itanium divides the stack into two sections: a variable stack
//      // and a control stack.  To make &#39;stackSize&#39; have the same meaning
//      // across platforms, we must double it on this platform.
//
//      stackSize *= 2;
//  #endif
//
//      int guardSize = attributes.guardSize();
//      if (bslmt::ThreadAttributes::e_UNSET_GUARD_SIZE == guardSize) {
//          guardSize = bslmt::Configuration::nativeDefaultThreadGuardSize();
//      }
//
//      int policy = attributes.schedulingPolicy();
//      int priority = attributes.schedulingPriority();
//
//      // the following is pseudo-code for actually creating the thread
//      /*
//      if (bslmt::ThreadAttributes::e_UNSET_PRIORITY == priority) {
//          priority = operatingSystemDefaultPriority(policy);
//      }
//
//      operatingSystemThreadCreate(threadHandle,
//                                  stackSize,
//                                  guardSize,
//                                  attributes.inheritSchedule(),
//                                  policy,
//                                  priority,
//                                  attributes.detachedState()
//                                  function);
//      */
//  }
//..
// Notice that a new value derived from the &#39;stackSize&#39; attribute is used so
// that the meaning of the attribute is platform neutral.

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSL_C_LIMITS
#include &lt;bsl_c_limits.h&gt;
#endif

namespace BloombergLP {
namespace bslmt {

                          // ======================
                          // class ThreadAttributes
                          // ======================

class ThreadAttributes {
    // This simply constrained (value-semantic) attribute class characterizes a
    // collection of thread attribute values.  See the Attributes section under
    // @DESCRIPTION in the component-level documentation.
    //
    // This class:
    //: o supports a complete set of *value* *semantic* operations
    //:   o except for &#39;bdex&#39; serialization
    //: o is *exception-neutral*
    //: o is *alias-safe*
    //: o is &#39;const&#39; *thread-safe*
    // For terminology see &#39;bsldoc_glossary&#39;.

  public:
    // PUBLIC TYPES
    enum DetachedState {
        // This enumeration provides two values used to distinguish among a
        // joinable thread and a non-joinable (detached) thread.

        e_CREATE_JOINABLE = 0,  // create a joinable thread
        e_CREATE_DETACHED = 1   // create a non-joinable thread

    };

    enum SchedulingPolicy {
        // This enumeration provides values used to distinguish between
        // different thread scheduling policies.

        e_SCHED_OTHER   = 0,  // unspecified, OS-dependent scheduling
                                  // policy

        e_SCHED_FIFO    = 1,  // first-in-first-out scheduling policy

        e_SCHED_RR      = 2,  // round-robin scheduling policy

        e_SCHED_DEFAULT = 3   // default OS scheduling policy, usually
                                  // equivalent to &#39;e_SCHED_OTHER&#39;
    };

    enum {
        // The following constants indicate that the &#39;stackSize&#39;, &#39;guardSize&#39;,
        // and &#39;schedulingPriority&#39; attributes, respectively, are unspecified
        // and the thread creation routine is use platform-specific defaults.
        // These attributes are initialized to these values when a thread
        // attributes object is default constructed.

        e_UNSET_STACK_SIZE = -1,
        e_UNSET_GUARD_SIZE = -1,
        e_UNSET_PRIORITY   = INT_MIN,

        e_SCHED_MIN        = e_SCHED_OTHER,
        e_SCHED_MAX        = e_SCHED_DEFAULT
    };

  private:
    // DATA
    DetachedState    d_detachedState;       // whether the thread is detached
                                            // or joinable

    int              d_guardSize;           // size of guard area provided
                                            // beyond the end of the configured
                                            // thread&#39;s stack

    bool             d_inheritScheduleFlag; // whether the thread inherits its
                                            // scheduling policy &amp; priority
                                            // from its parent thread

    SchedulingPolicy d_schedulingPolicy;    // policy for scheduling thread
                                            // execution

    int              d_schedulingPriority;  // thread priority (higher numbers
                                            // indicate more urgency)

    int              d_stackSize;           // size of the thread&#39;s stack

  public:
    // CLASS METHODS
    static int getMaxSchedPriority(SchedulingPolicy policy);
        // Return the maximum available priority for the specified &#39;policy&#39;,
        // where &#39;policy&#39; is of type &#39;ThreadAttributes::SchedulingPolicy&#39;.
        // Note that for some platform / policy combinations,
        // &#39;getMinSchedPriority(policy)&#39; and &#39;getMaxSchedPriority(policy)&#39;
        // return the same value.  The behavior is undefined unless &#39;policy&#39; is
        // a valid value of enum &#39;ThreadAttributes::SchedulingPolicy&#39;.
        //
        // DEPRECATED: use &#39;ThreadUtil::getMaxSchedulingPriority&#39; instead.

    static int getMinSchedPriority(SchedulingPolicy policy);
        // Return the minimum available priority for the specified &#39;policy&#39;,
        // where &#39;policy&#39; is of type &#39;ThreadAttributes::SchedulingPolicy&#39;.
        // Note that for some platform / policy combinations,
        // &#39;getMinSchedPriority(policy)&#39; and &#39;getMaxSchedPriority(policy)&#39;
        // return the same value.  The behavior is undefined unless &#39;policy&#39; is
        // a valid value of enum &#39;ThreadAttributes::SchedulingPolicy&#39;.
        //
        // DEPRECATED: use &#39;ThreadUtil::getMinSchedulingPriority&#39; instead.

    // CREATORS
    ThreadAttributes();
        // Create a &#39;ThreadAttributes&#39; object having the (default) attribute
        // values:
        //: o &#39;detachedState()      == e_CREATE_JOINABLE&#39;
        //: o &#39;guardSize()          == e_UNSET_GUARD_SIZE&#39;
        //: o &#39;inheritSchedule()    == true&#39;
        //: o &#39;schedulingPolicy()   == e_SCHED_DEFAULT&#39;
        //: o &#39;schedulingPriority() == e_UNSET_PRIORITY&#39;
        //: o &#39;stackSize()          == e_UNSET_STACK_SIZE&#39;

    ThreadAttributes(const ThreadAttributes&amp; original);
        // Create a &#39;ThreadAttributes&#39; object having the same value as the
        // specified &#39;original&#39; object.

    // MANIPULATORS
    ThreadAttributes&amp; operator=(const ThreadAttributes&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.

    // MANIPULATORS
    void setDetachedState(DetachedState value);
        // Set the &#39;detachedState&#39; attribute of this object to the specified
        // &#39;value&#39;.  A value of &#39;e_CREATE_JOINABLE&#39; (the default) indicates
        // that a thread must be joined to clean up its resources after it
        // terminates; a value of &#39;e_CREATE_DETACHED&#39; (the only other legal
        // value) indicates that the resources will be cleaned up automatically
        // upon thread termination, and that the thread must not be joined.

    void setGuardSize(int value);
        // Set the &#39;guardSize&#39; attribute of this object to the specified
        // &#39;value&#39; (in bytes).  &#39;e_UNSET_GUARD_SIZE == guardSize&#39; is intended
        // to indicate that the default value as defined by the platform is to
        // be used.  This default value is typically the size of one or two
        // pages (see &#39;bslmt_configuration&#39;).  The behavior is undefined unless
        // &#39;e_UNSET_GUARD_SIZE == guardSize&#39; or &#39;guardSize &gt;= 0&#39;.

    void setInheritSchedule(bool value);
        // Set the &#39;inheritSchedule&#39; attribute of this object to the specified
        // &#39;value&#39;.  A value of &#39;false&#39; for the inherit schedule attribute
        // indicates that a thread should *not* inherit the scheduling policy
        // and priority of the thread that created it and instead should use
        // the respective values supplied by this object; whereas a value of
        // &#39;true&#39; indicates that the thread *should* inherit these attributes
        // and ignore the respective values in this object.  See
        // &#39;bslmt_threadutil&#39; for information about support for this attribute.

    void setSchedulingPolicy(SchedulingPolicy value);
        // Set the value of the &#39;schedulingPolicy&#39; attribute of this object to
        // the specified &#39;value&#39;.  This attribute is ignored unless
        // &#39;inheritSchedule&#39; is &#39;false&#39;.  See &#39;bslmt_threadutil&#39; for
        // information about this attribute.

    void setSchedulingPriority(int value);
        // Set the &#39;schedulingPriority&#39; attribute of this object to the
        // specified &#39;value&#39;.  This attribute is ignored unless
        // &#39;inheritSchedule()&#39; is &#39;false&#39;.  Higher values of &#39;value&#39; signify
        // more urgent priorities.  Note that the valid range of priorities
        // depends upon the platform and &#39;schedulingPolicy&#39; attribute, and the
        // minimum and maximum priority values are determined by methods in
        // &#39;bslmt_threadutil&#39;.  See &#39;bslmt_threadutil&#39; for information about
        // this attribute.

    void setStackSize(int value);
        // Set the &#39;stackSize&#39; attribute of this object to the specified
        // &#39;value&#39;.  If &#39;stackSize&#39; is &#39;e_UNSET_STACK_SIZE&#39;, thread creation
        // should use the default stack size value provided by
        // &#39;bslmt_configuration&#39;.  The behavior is undefined unless
        // &#39;e_UNSET_STACK_SIZE == stackSize&#39; or &#39;0 &lt;= stackSize&#39;.

    // ACCESSORS
    DetachedState detachedState() const;
        // Return the value of the &#39;detachedState&#39; attribute of this object.  A
        // value of &#39;e_CREATE_JOINABLE&#39; indicates that a thread must be joined
        // after it terminates to clean up its resources; a value of
        // &#39;e_CREATE_DETACHED&#39; (the only other legal value) indicates that the
        // resources will be cleaned up automatically upon thread termination,
        // and that the thread must not be joined.

    int guardSize() const;
        // Return the value of the &#39;guardSize&#39; attribute of this object.  The
        // value &#39;e_UNSET_GUARD_SIZE == guardSize&#39; is intended to indicate that
        // the default value as defined by the platform (which is typically the
        // size of one or two pages) should be obtained from
        // &#39;bslmt_configuration&#39; and used.

    bool inheritSchedule() const;
        // Return the value of the &#39;inheritSchedule&#39; attribute of this object.
        // A value of &#39;false&#39; for the inherit schedule attribute indicates that
        // a thread should *not* inherit the scheduling policy and priority of
        // the thread that created it and instead should use the respective
        // values supplied by this object; whereas a value of &#39;true&#39; indicates
        // that the thread *should* inherit these attributes and ignore the
        // respective values in this object.  See &#39;bslmt_threadutil&#39; for
        // information about support for this attribute.

    SchedulingPolicy schedulingPolicy() const;
        // Return the value of the &#39;schedulingPolicy&#39; attribute of this object.
        // This attribute is ignored unless &#39;inheritSchedule&#39; is &#39;false&#39;.  See
        // &#39;bslmt_threadutil&#39; for information about this attribute.

    int schedulingPriority() const;
        // Return the value of the &#39;schedulingPriority&#39; attribute of this
        // object.  This attribute is ignored unless &#39;inheritSchedule()&#39; is
        // &#39;false&#39;.  Higher values of &#39;value&#39; signify more urgent priorities.
        // Note that the valid range of priorities depends upon the platform
        // and &#39;schedulingPolicy&#39; attribute, and the minimum and maximum
        // priority values are determined by methods in &#39;bslmt_threadutil&#39;.
        // See &#39;bslmt_threadutil&#39; for information about this attribute.

    int stackSize() const;
        // Return the value of the &#39;stackSize&#39; attribute of this object.  If
        // &#39;stackSize&#39; is &#39;e_UNSET_STACK_SIZE&#39;, thread creation should use the
        // default stack size value provided by &#39;bslmt_configuration&#39;.
};

// FREE OPERATORS
bool operator==(const ThreadAttributes&amp; lhs, const ThreadAttributes&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;ThreadAttributes&#39; objects have the
    // same value if the corresponding values of their &#39;detachedState&#39;,
    // &#39;guardSize&#39;, &#39;inheritSchedule&#39;, &#39;schedulingPolicy&#39;,
    // &#39;schedulingPriority&#39;, and &#39;stackSize&#39; attributes are the same.

bool operator!=(const ThreadAttributes&amp; lhs, const ThreadAttributes&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same value, and &#39;false&#39; otherwise.  Two &#39;baltzo::LocalTimeDescriptor&#39;
    // objects do not have the same value if the corresponding values of their
    // &#39;detachedState&#39;, &#39;guardSize&#39;, &#39;inheritSchedule&#39;, &#39;schedulingPolicy&#39;,
    // &#39;schedulingPriority&#39;, and &#39;stackSize&#39; attributes are not the same.

}  // close package namespace

// ============================================================================
//                             INLINE DEFINITIONS
// ============================================================================

                          // ----------------------
                          // class ThreadAttributes
                          // ----------------------

// CREATORS
inline
bslmt::ThreadAttributes::ThreadAttributes(const ThreadAttributes&amp; original)
: d_detachedState(original.d_detachedState)
, d_guardSize(original.d_guardSize)
, d_inheritScheduleFlag(original.d_inheritScheduleFlag)
, d_schedulingPolicy(original.d_schedulingPolicy)
, d_schedulingPriority(original.d_schedulingPriority)
, d_stackSize(original.d_stackSize)
{
}

// MANIPULATORS
inline
bslmt::ThreadAttributes&amp; bslmt::ThreadAttributes::operator=(
                                                   const ThreadAttributes&amp; rhs)
{
    d_detachedState       = rhs.d_detachedState;
    d_guardSize           = rhs.d_guardSize;
    d_inheritScheduleFlag = rhs.d_inheritScheduleFlag;
    d_schedulingPolicy    = rhs.d_schedulingPolicy;
    d_schedulingPriority  = rhs.d_schedulingPriority;
    d_stackSize           = rhs.d_stackSize;

    return *this;
}

inline
void bslmt::ThreadAttributes::setDetachedState(
                                         ThreadAttributes::DetachedState value)
{
    BSLS_ASSERT_SAFE(e_CREATE_DETACHED == value ||
                     e_CREATE_JOINABLE == value);

    d_detachedState = value;
}

inline
void bslmt::ThreadAttributes::setGuardSize(int value)
{
    BSLMF_ASSERT(-1 == e_UNSET_GUARD_SIZE);

    BSLS_ASSERT_SAFE(-1 &lt;= value);

    d_guardSize = value;
}

inline
void bslmt::ThreadAttributes::setInheritSchedule(bool value)
{
    d_inheritScheduleFlag = value;
}

inline
void bslmt::ThreadAttributes::setSchedulingPolicy(
                                      ThreadAttributes::SchedulingPolicy value)
{
    BSLS_ASSERT_SAFE(e_SCHED_MIN &lt;= (int) value);
    BSLS_ASSERT_SAFE(                   (int) value &lt;= e_SCHED_MAX);

    d_schedulingPolicy = value;
}

inline
void bslmt::ThreadAttributes::setSchedulingPriority(int value)
{
    d_schedulingPriority = value;
}

inline
void bslmt::ThreadAttributes::setStackSize(int value)
{
    BSLMF_ASSERT(-1 == e_UNSET_STACK_SIZE);

    BSLS_ASSERT_SAFE(-1 &lt;= value);

    d_stackSize = value;
}

// ACCESSORS
inline
bslmt::ThreadAttributes::DetachedState
bslmt::ThreadAttributes::detachedState() const
{
    return d_detachedState;
}

inline
int bslmt::ThreadAttributes::guardSize() const
{
    return d_guardSize;
}

inline
bool bslmt::ThreadAttributes::inheritSchedule() const
{
    return d_inheritScheduleFlag;
}

inline
bslmt::ThreadAttributes::SchedulingPolicy
bslmt::ThreadAttributes::schedulingPolicy() const
{
    return d_schedulingPolicy;
}

inline
int bslmt::ThreadAttributes::schedulingPriority() const
{
    return d_schedulingPriority;
}

inline
int bslmt::ThreadAttributes::stackSize() const
{
    return d_stackSize;
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
