<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bsls_spinlock.h                                                    -*-C++-*-
#ifndef INCLUDED_BSLS_SPINLOCK
#define INCLUDED_BSLS_SPINLOCK

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$: $&quot;)

//@PURPOSE: Provide a spin lock.
//
//@CLASSES:
//       SpinLock: A mutex using &quot;busy waiting&quot; atomic operations.
//  SpinLockGuard: Automatic locking-unlocking of SpinLock
//
//@DESCRIPTION: This component provides a &quot;busy wait&quot; mutual exclusion lock
// primitive (&quot;mutex&quot;). A &#39;SpinLock&#39; is small and statically-initializable, but
// because it &quot;spins&quot; in a tight loop rather than using system operations to
// block the thread of execution, it is unsuited for use cases involving high
// contention or long critical regions.  Additionally, this component does not
// provide any guarantee of fairness when multiple threads are contending for
// the same lock.  Use &#39;SpinLockGuard&#39; for automatic locking-unlocking in a
// scope.
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Maintaining Static Count/Max Values
/// - - - - - - - - - - - - - - - - - - - - - - -
// Suppose that we want to determine the maximum number of threads executing a
// block of code concurrently.  Note that such a use case naturally calls for
// a statically initialized lock and the critical region involves a few integer
// operations; SpinLock may be suitable.
//
// First, we define a type to manage the count within a scope:
//..
// class MaxConcurrencyCounter {
//     // This type manages a count and high-water-mark within a scope.
//     // It decrements the count in its destructor upon leaving the scope.
//
//     // DATA
//     int            *d_count_p;
//     bsls::SpinLock *d_lock_p;
//
//   public:
//     // CREATORS
//     MaxConcurrencyCounter(int *count, int *max, bsls::SpinLock *lock);
//         // Acquire the specified &#39;lock&#39; and increment the specified &#39;count&#39;.
//         // If the resulting value is larger than the specified &#39;max&#39;,
//         // load it into &#39;max&#39;. Release &#39;lock&#39; and create a scoped guard to
//         // decrement &#39;count&#39; on destruction.
//
//     ~MaxConcurrencyCounter();
//         // Acquire the lock specified at construction, decrement the count
//         // variable, and release the lock.
//   };
//
//   MaxConcurrencyCounter::MaxConcurrencyCounter(int            *count,
//                                                int            *max,
//                                                bsls::SpinLock *lock)
//   : d_count_p(count)
//   , d_lock_p(lock) {
//      bsls::SpinLockGuard guard(lock);
//      int result = ++(*count);
//      if (result &gt; *max) {
//         *max = result;
//      }
//   }
//
//   MaxConcurrencyCounter::~MaxConcurrencyCounter() {
//      bsls::SpinLockGuard guard(d_lock_p);
//      --(*d_count_p);
//   }
//..
// Next, we declare static variables to track the call count and a SpinLock to
// guard them.  &#39;SpinLock&#39; may be statically initialized using the
// &#39;BSLS_SPINLOCK_UNLOCKED&#39; constant:
//..
//   {
//      static int            threadCount = 0;
//      static int            maxThreads = 0;
//      static bsls::SpinLock threadLock = BSLS_SPINLOCK_UNLOCKED;
//..
// Next, by creating a &#39;MaxConcurrencyCounter&#39; object, each thread entering the
// block of code uses the &#39;SpinLock&#39; to synchronize manipulation of the static
// count variables:
//..
//      MaxConcurrencyCounter counter(&amp;threadCount, &amp;maxThreads, &amp;threadLock);
//..
// Finally, closing the block synchronizes on the &#39;SpinLock&#39; again to decrement
// the thread count.  Any intervening code can run in parallel.
//..
//   }
//..
//
///Example 2: Fine-Grained Locking
///- - - - - - - - - - - - - - - -
// Suppose that we have a large array of objects to be manipulated concurrently
// by multiple threads, but the size of the array itself does not change.
// (This might be because it represents an inherently fixed number of objects
// or because changes to the array size are infrequent and controlled by some
// other synchronization mechanism like a &quot;reader-writer&quot; lock).  Thus one
// thread can manipulate a particular object in the array concurrently with a
// different thread manipulating another.  If the manipulations are short and
// contention is likely to be low, SpinLock might be suitable due to its small
// size.
//
// In particular, imagine we want a threadsafe &quot;multi-queue&quot;. In this case, we
// would have an array of queues, each with a SpinLock member for fine-grained
// locking.  First, we define the type to be held in the array.
//..
//  template&lt;typename TYPE&gt;
//  class LightweightThreadsafeQueue {
//     // This type implements a threadsafe queue with a small memory
//     // footprint and low initialization costs. It is designed for
//     // low-contention use only.
//
//     // TYPES
//     struct Node {
//          TYPE  d_item;
//          Node *d_next_p;
//
//          Node(const TYPE&amp; item) : d_item(item), d_next_p(0) {}
//      };
//
//     // DATA
//     Node           *d_front_p; // Front of queue, or 0 if empty
//     Node           *d_back_p; // Back of queue, or 0 if empty
//     bsls::SpinLock  d_lock;
//
//   public:
//     // CREATORS
//     LightweightThreadsafeQueue();
//       // Create an empty queue.
//
//     ~LightweightThreadsafeQueue();
//       // Destroy this object.
//
//     // MANIPULATORS
//     int dequeue(TYPE* value);
//        // Remove the element at the front of the queue and load it into the
//        // specified &#39;value&#39;. Return &#39;0&#39; on success, or a nonzero value if
//        // the queue is empty.
//
//     void enqueue(const TYPE&amp; value);
//        // Add the specified &#39;value&#39; to the back of the queue.
//   };
//..
// Next, we implement the creators. Note that a different idiom is used to
// initialize member variables of &#39;SpinLock&#39; type than is used for static
// variables:
//..
//  template&lt;typename TYPE&gt;
//  LightweightThreadsafeQueue&lt;TYPE&gt;::LightweightThreadsafeQueue()
//  : d_front_p(0)
//  , d_back_p(0)
//  , d_lock(bsls::SpinLock::s_unlocked)
//  {}
//
//  template&lt;typename TYPE&gt;
//  LightweightThreadsafeQueue&lt;TYPE&gt;::~LightweightThreadsafeQueue() {
//     for (Node *node = d_front_p; 0 != node; ) {
//         Node *next = node-&gt;d_next_p;
//         delete node;
//         node = next;
//     }
//  }
//..
// Then we implement the manipulator functions using &#39;SpinLockGuard&#39; to ensure
// thread safety.  Note that we do memory allocation and deallocation outside
// the scope of the lock, as these may involve system calls that should be
// avoided in the scope of a SpinLock.
//..
//  template&lt;typename TYPE&gt;
//  int LightweightThreadsafeQueue&lt;TYPE&gt;::dequeue(TYPE* value) {
//     Node *front;
//     {
//        bsls::SpinLockGuard guard(&amp;d_lock);
//        front = d_front_p;
//        if (0 == front) {
//          return 1;
//        }
//
//        *value = front-&gt;d_item;
//
//        if (d_back_p == front) {
//           d_front_p = d_back_p = 0;
//        } else {
//           d_front_p = front-&gt;d_next_p;
//        }
//     }
//     delete front;
//     return 0;
//  }
//
//  template&lt;typename TYPE&gt;
//  void LightweightThreadsafeQueue&lt;TYPE&gt;::enqueue(const TYPE&amp; value) {
//     Node *node = new Node(value);
//     bsls::SpinLockGuard guard(&amp;d_lock);
//     if (0 == d_front_p &amp;&amp; 0 == d_back_p) {
//        d_front_p = d_back_p = node;
//     } else {
//        d_back_p-&gt;d_next_p = node;
//        d_back_p = node;
//     }
//  }
//..
//  To illustrate fine-grained locking with this queue, we create a thread
//  function that will manipulate queues out of a large array at random.
//  Since each element in the array is locked independently, these threads
//  will rarely contend for the same queue and can run largely in parallel.
//..
// const int NUM_QUEUES = 10000;
// const int NUM_ITERATIONS = 20000;
//
// struct QueueElement {
//    int d_threadId;
//    int d_value;
// };
//
// struct ThreadParam {
//    LightweightThreadsafeQueue&lt;QueueElement&gt; *d_queues_p;
//    int                                       d_threadId;
// };
//
// void *addToRandomQueues(void *paramAddr) {
//    ThreadParam *param = (ThreadParam*)paramAddr;
//    LightweightThreadsafeQueue&lt;QueueElement&gt; *queues = param-&gt;d_queues_p;
//    int threadId = param-&gt;d_threadId;
//    unsigned seed = threadId;
//    for (int i = 0; i &lt; NUM_ITERATIONS; ++i) {
//       int queueIndex = rand_r(&amp;seed) % NUM_QUEUES;
//       LightweightThreadsafeQueue&lt;QueueElement&gt; *queue = queues + queueIndex;
//       QueueElement value = { threadId, i };
//       queue-&gt;enqueue(value);
//    }
//    return 0;
// }
//..
// Finally, we create the &quot;multi-queue&quot; and several of these threads to
// manipulate it.  We assume the existence of a createThread() function that
// starts a new thread of execution with a parameter, and we omit details of
// &quot;joining&quot; these threads.
//..
// enum { NUM_THREADS = 3};
// LightweightThreadsafeQueue&lt;QueueElement&gt; multiQueue[NUM_QUEUES];
// ThreadParam threadParams[NUM_THREADS];
// for (int i = 0; i &lt; NUM_THREADS; ++i) {
//   threadParams[i].d_queues_p = multiQueue;
//   threadParams[i].d_threadId = i + 1;
//   createThread(addToRandomQueues, threadParams + i);
// }
//..
//


#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMICOPERATIONS
#include &lt;bsls_atomicoperations.h&gt;
#endif

#define BSLS_SPINLOCK_UNLOCKED  { {0} }
    // Use this macro as the value for initializing an object of type
    // &#39;SpinLock&#39;.  For example:
    //..
    //  SpinLock lock = BSLS_SPINLOCK_UNLOCKED;
    //..

namespace BloombergLP {
namespace bsls {

                             // ==============
                             // class SpinLock
                             // ==============
struct SpinLock {
    // A statically-initializable synchronization primitive that &quot;spins&quot;
    // (i.e., executes user instructions in a tight loop) rather than blocking
    // waiting threads using system calls.  The following idiom is used to
    // initialize &#39;SpinLock&#39; variables:
    //..
    //  SpinLock lock = BSLS_SPINLOCK_UNLOCKED;
    //..
    // A class member &#39;d_lock&#39; of type &#39;SpinLock&#39; may be initialized using the
    // following idiom:
    //..
    //  , d_lock(SpinLock::s_unlocked)
    //..

  private:
    // NOT IMPLEMENTED
    SpinLock&amp; operator=(const SpinLock&amp;);

    // We would like to prohibit copy construction, but then this class
    // would not be a POD and could not be initialized statically:
    // SpinLock(const SpinLock&amp;);

    // PRIVATE TYPES
    enum {
        e_UNLOCKED = 0, // unlocked state value
        e_LOCKED = 1    // locked state value
    };

  public:
    // PUBLIC CLASS DATA
    static const SpinLock s_unlocked;
        // This constant SpinLock is always unlocked. It is suitable for use
        // initializing class members of SpinLock type.

    // DATA
    AtomicOperations::AtomicTypes::Int d_state;
        // Public to allow this type to be a statically-initializable POD. Do
        // not use directly.

    // MANIPULATORS
    void lock();
        // Spin (repeat a loop continuously without using the system to pause
        // or reschedule the thread) until this object is unlocked, then
        // atomically acquire the lock.

    int tryLock(int numRetries = 0);
        // Attempt to acquire the lock; optionally specify the &#39;numRetries&#39;
        // times to attempt again if this object is already locked.  Return 0
        // on success,  and a non-zero value if the lock was not successfully
        // acquired.  The behavior is undefined unless &#39;0 &lt;= numRetries&#39;.

    void unlock();
        // Release the lock. The behavior is undefined unless the current
        // thread holds the lock.
};

                         // ===================
                         // class SpinLockGuard
                         // ===================
class SpinLockGuard {
    // This type implements a scoped guard for &#39;SpinLock&#39;.

    // DATA
    SpinLock *d_lock_p; // lock proctored by this object

  private:
    // NOT IMPLEMENTED
    SpinLockGuard(const SpinLockGuard&amp;);
    SpinLockGuard&amp; operator=(const SpinLockGuard&amp;);

  public:

    // CREATORS
    explicit SpinLockGuard(SpinLock *lock);
        // Create a proctor object that manages the specified &#39;lock&#39;. Invoke
        // &#39;lock-&gt;lock()&#39;.

    ~SpinLockGuard();
        // Destroy this proctor object and invoke &#39;unlock()&#39; on the lock
        // managed by this object.

    // MANIPULATORS
    SpinLock *release();
        // Return the lock pointer that was provided at construction and stop
        // managing it.  (Subsequent calls to &#39;release()&#39; will return null and
        // the destruction of this object will not affect the lock.)  The lock
        // status is not changed by this call.
};

// ============================================================================
//                             INLINE DEFINITIONS
// ============================================================================

                             // --------------
                             // class SpinLock
                             // --------------
inline
void SpinLock::lock() {
    do {
        // Implementation note: the outer &#39;if&#39; block is not logically
        // necessary but may reduce memory barrier costs when spinning.
        if (e_UNLOCKED == AtomicOperations::getIntAcquire(&amp;d_state)) {
            if (e_UNLOCKED == AtomicOperations::swapIntAcqRel(&amp;d_state,
                                                              e_LOCKED))
            {
                break;
            }
        }
    } while(1);
}

inline
int SpinLock::tryLock(int numRetries) {
    do {
        // See lock() for implementation note.
        if (e_UNLOCKED == AtomicOperations::getIntAcquire(&amp;d_state)) {
            if (e_UNLOCKED == AtomicOperations::swapIntAcqRel(&amp;d_state,
                                                              e_LOCKED))
            {
                return 0;                                             // RETURN
            }
        }
    } while(numRetries--);
    return -1;
}

inline
void SpinLock::unlock() {
    BSLS_ASSERT_SAFE(e_LOCKED == AtomicOperations::getInt(&amp;d_state));

    AtomicOperations::setIntRelease(&amp;d_state, e_UNLOCKED);
}

                          // -------------------
                          // class SpinLockGuard
                          // -------------------
inline
SpinLockGuard::SpinLockGuard(SpinLock *lock)
: d_lock_p(lock) {
    BSLS_ASSERT_SAFE(0 != lock);
    lock-&gt;lock();
}

inline
SpinLockGuard::~SpinLockGuard()
{
    if (0 != d_lock_p) {
        d_lock_p-&gt;unlock();
    }
}

// MANIPULATORS
inline
SpinLock *SpinLockGuard::release() {
    SpinLock *lock = d_lock_p;
    d_lock_p = 0;
    return lock;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
