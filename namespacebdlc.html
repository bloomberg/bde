<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Namespace bdlc</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>bdlc Namespace Reference<br/>
<small>
[<a class="el" href="group__bdlc__bitarray.html">Component bdlc_bitarray</a>,&nbsp;<a class="el" href="group__bdlc__hashtable.html">Component bdlc_hashtable</a>,&nbsp;<a class="el" href="group__bdlc__indexclerk.html">Component bdlc_indexclerk</a>,&nbsp;<a class="el" href="group__bdlc__packedintarray.html">Component bdlc_packedintarray</a>,&nbsp;<a class="el" href="group__bdlc__packedintarrayutil.html">Component bdlc_packedintarrayutil</a>,&nbsp;<a class="el" href="group__bdlc__queue.html">Component bdlc_queue</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1BitArray.html">BitArray</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html">HashTable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlc_1_1HashTableDefaultTraits.html">HashTableDefaultTraits</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlc_1_1HashTableDefaultHash1.html">HashTableDefaultHash1</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlc_1_1HashTableDefaultHash2.html">HashTableDefaultHash2</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlc_1_1HashTable__ImpUtil.html">HashTable_ImpUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1IndexClerkIter.html">IndexClerkIter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1IndexClerk.html">IndexClerk</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlc_1_1PackedIntArrayImp__Signed.html">PackedIntArrayImp_Signed</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlc_1_1PackedIntArrayImp__Unsigned.html">PackedIntArrayImp_Unsigned</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1PackedIntArrayImp.html">PackedIntArrayImp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlc_1_1PackedIntArrayImpType.html">PackedIntArrayImpType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlc_1_1PackedIntArrayUtil.html">PackedIntArrayUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1Queue.html">Queue</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a8877852717bde266f2e433abff8781dc">operator==</a> (const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;lhs, const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#aaa8ac3f08a32cf4a54cc7025691030de">operator!=</a> (const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;lhs, const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlc_1_1BitArray.html">BitArray</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#aa79c091b7a32ab9b03f56abb22d1a41f">operator~</a> (const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;array)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlc_1_1BitArray.html">BitArray</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a61c03f8633ce4608d22e6ca7b1e711b6">operator&amp;</a> (const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;lhs, const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlc_1_1BitArray.html">BitArray</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#abb779cb10513bd0b6f09ca6a5acee838">operator-</a> (const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;lhs, const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlc_1_1BitArray.html">BitArray</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a3679a3305bf56c684237524b8efd4d97">operator|</a> (const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;lhs, const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlc_1_1BitArray.html">BitArray</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#aac7ff26f8169934950e9047a850350bc">operator^</a> (const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;lhs, const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlc_1_1BitArray.html">BitArray</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#afa70555045dc5d7aa03ff8bc38e539b1">operator&lt;&lt;</a> (const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;array, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlc_1_1BitArray.html">BitArray</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#aa769ff53ac041a71ffe7140e39efb85d">operator&gt;&gt;</a> (const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;array, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a8e6890321681437f98d08aa6403a4c34">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a41599fbd00807f1b06c0618f63c723e6">swap</a> (<a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;a, <a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a56c5c1744ffff2aee8abebe03328cc93">operator==</a> (const <a class="el" href="classbdlc_1_1IndexClerkIter.html">IndexClerkIter</a> &amp;lhs, const <a class="el" href="classbdlc_1_1IndexClerkIter.html">IndexClerkIter</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#af35b1bf5bbe5a423daf163c48ebdc57f">operator!=</a> (const <a class="el" href="classbdlc_1_1IndexClerkIter.html">IndexClerkIter</a> &amp;lhs, const <a class="el" href="classbdlc_1_1IndexClerkIter.html">IndexClerkIter</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#ac103da7270e6d2fe4f89c927b148137d">operator==</a> (const <a class="el" href="classbdlc_1_1IndexClerk.html">IndexClerk</a> &amp;lhs, const <a class="el" href="classbdlc_1_1IndexClerk.html">IndexClerk</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#abdb5e99d248fbc7a25ecc036182bbf47">operator!=</a> (const <a class="el" href="classbdlc_1_1IndexClerk.html">IndexClerk</a> &amp;lhs, const <a class="el" href="classbdlc_1_1IndexClerk.html">IndexClerk</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a50d4c53fb730dfeb44561f5bf63bdf02">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlc_1_1IndexClerk.html">IndexClerk</a> &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a046295dee9bb6aa815b626402d2910cd">operator++</a> (<a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#ac907e5780fc6951e1d99a105b1218fcb">operator--</a> (<a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a699ed8e86216dee090d3b606cf323e6d">operator==</a> (const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a5ee8bbd83392f2525be8c599511dae54">operator!=</a> (const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bsl::ptrdiff_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a5068e63a06de47744b4304305c43e675">operator-</a> (const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#ab26530a1eabce342925f16a8ff02a0f2">operator&lt;</a> (const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#af9ea3d514e10a99d07def0d55cd1a85b">operator&lt;=</a> (const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a0adcead2a4dad401a6c8cbe4c66730d1">operator&gt;</a> (const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a914890161d13066f362494ab9e41a7a1">operator&gt;=</a> (const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a2698c9cad2fe0b96aa0e3d39b595e7f6">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a>&lt; TYPE &gt; &amp;array)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a781e876e0e6a4c4b6fe68eeca2866280">operator==</a> (const <a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a>&lt; TYPE &gt; &amp;lhs, const <a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a>&lt; TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a6032dcf17fd62b0a9f2ba111c6b1a43d">operator!=</a> (const <a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a>&lt; TYPE &gt; &amp;lhs, const <a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a>&lt; TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a54ef1dc153396ce08b40de28aeec64df">swap</a> (<a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a>&lt; TYPE &gt; &amp;a, <a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a>&lt; TYPE &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a302d79d598268280fc316fbed19b23e9">operator==</a> (const <a class="el" href="classbdlc_1_1Queue.html">Queue</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classbdlc_1_1Queue.html">Queue</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a69b9df6d568a3782693f8ed5441fbd0e">operator!=</a> (const <a class="el" href="classbdlc_1_1Queue.html">Queue</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classbdlc_1_1Queue.html">Queue</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#aef28b2e94443981176c382bcdbbd2691">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlc_1_1Queue.html">Queue</a>&lt; T &gt; &amp;queue)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8877852717bde266f2e433abff8781dc"></a><!-- doxytag: member="bdlc::operator==" ref="a8877852717bde266f2e433abff8781dc" args="(const BitArray &amp;lhs, const BitArray &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator== </td>
          <td>(</td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> arrays have the same value, and <code>false</code> otherwise. Two arrays have the same value if they have the same length, and corresponding bits at each bit position have the same value. </p>

</div>
</div>
<a class="anchor" id="aaa8ac3f08a32cf4a54cc7025691030de"></a><!-- doxytag: member="bdlc::operator!=" ref="aaa8ac3f08a32cf4a54cc7025691030de" args="(const BitArray &amp;lhs, const BitArray &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator!= </td>
          <td>(</td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> arrays do not have the same value, and <code>false</code> otherwise. Two arrays do not have the same value if they do not have the same length, or there is at least one valid index position at which corresponding bits do not have the same value. </p>

</div>
</div>
<a class="anchor" id="aa79c091b7a32ab9b03f56abb22d1a41f"></a><!-- doxytag: member="bdlc::operator~" ref="aa79c091b7a32ab9b03f56abb22d1a41f" args="(const BitArray &amp;array)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> bdlc::operator~ </td>
          <td>(</td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the bitwise complement ("toggle") of the specified <code>array</code>. </p>

</div>
</div>
<a class="anchor" id="a61c03f8633ce4608d22e6ca7b1e711b6"></a><!-- doxytag: member="bdlc::operator&amp;" ref="a61c03f8633ce4608d22e6ca7b1e711b6" args="(const BitArray &amp;lhs, const BitArray &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> bdlc::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the value that is the bitwise AND of the specified <code>lhs</code> and <code>rhs</code> arrays. The length of the resulting bit array will be the maximum of that of <code>lhs</code> and <code>rhs</code>, with any unmatched high-order bits set to 0. Note that this behavior is consistent with zero-extending the shorter array. </p>

</div>
</div>
<a class="anchor" id="abb779cb10513bd0b6f09ca6a5acee838"></a><!-- doxytag: member="bdlc::operator&#45;" ref="abb779cb10513bd0b6f09ca6a5acee838" args="(const BitArray &amp;lhs, const BitArray &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> bdlc::operator- </td>
          <td>(</td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the value that is the bitwise MINUS of the specified <code>lhs</code> and <code>rhs</code> arrays. The length of the resulting bit array will be the maximum of that of <code>lhs</code> and <code>rhs</code>, with any unmatched high-order <code>lhs</code> bits copied unchanged, and any unmatched high-order <code>rhs</code> bits set to 0. Note that this behavior is consistent with zero-extending the shorter array. </p>

</div>
</div>
<a class="anchor" id="a3679a3305bf56c684237524b8efd4d97"></a><!-- doxytag: member="bdlc::operator|" ref="a3679a3305bf56c684237524b8efd4d97" args="(const BitArray &amp;lhs, const BitArray &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> bdlc::operator| </td>
          <td>(</td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the value that is the bitwise OR of the specified <code>lhs</code> and <code>rhs</code> arrays. The length of the resulting bit array will be the maximum of that of <code>lhs</code> and <code>rhs</code>, with any unmatched high-order bits copied unchanged. Note that this behavior is consistent with zero-extending the shorter array. </p>

</div>
</div>
<a class="anchor" id="aac7ff26f8169934950e9047a850350bc"></a><!-- doxytag: member="bdlc::operator^" ref="aac7ff26f8169934950e9047a850350bc" args="(const BitArray &amp;lhs, const BitArray &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> bdlc::operator^ </td>
          <td>(</td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the value that is the bitwise XOR of the specified <code>lhs</code> and <code>rhs</code> arrays. The length of the resulting bit array will be the maximum of that of <code>lhs</code> and <code>rhs</code>, with any unmatched high-order bits copied unchanged. Note that this behavior is consistent with zero-extending the shorter array. </p>

</div>
</div>
<a class="anchor" id="afa70555045dc5d7aa03ff8bc38e539b1"></a><!-- doxytag: member="bdlc::operator&lt;&lt;" ref="afa70555045dc5d7aa03ff8bc38e539b1" args="(const BitArray &amp;array, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> bdlc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the value of the specified <code>array</code> left-shifted by the specified <code>numBits</code> positions, having filled the lower-index positions with zeros. The behavior is undefined unless <code>numBits &lt;= array.length()</code>. Note that the length of the result equals the length of the original array, and that the highest-order <code>numBits</code> are discarded in the result. </p>

</div>
</div>
<a class="anchor" id="aa769ff53ac041a71ffe7140e39efb85d"></a><!-- doxytag: member="bdlc::operator&gt;&gt;" ref="aa769ff53ac041a71ffe7140e39efb85d" args="(const BitArray &amp;array, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1BitArray.html">BitArray</a> bdlc::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the value of the specified <code>array</code> right-shifted by the specified <code>numBits</code> positions, having filled the higher-index positions with zeros. The behavior is undefined unless <code>numBits &lt;= array.length()</code>. Note that the length of the result equals the length of the original array, and that the lowest-order <code>numBits</code> are discarded in the result. </p>

</div>
</div>
<a class="anchor" id="a8e6890321681437f98d08aa6403a4c34"></a><!-- doxytag: member="bdlc::operator&lt;&lt;" ref="a8e6890321681437f98d08aa6403a4c34" args="(bsl::ostream &amp;stream, const BitArray &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Format the bits in the specified <code>rhs</code> bit array to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a41599fbd00807f1b06c0618f63c723e6"></a><!-- doxytag: member="bdlc::swap" ref="a41599fbd00807f1b06c0618f63c723e6" args="(BitArray &amp;a, BitArray &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlc::swap </td>
          <td>(</td>
          <td class="paramtype">BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BitArray &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the values of the specified <code>a</code> and <code>b</code> objects. This function provides the no-throw exception-safety guarantee. The behavior is undefined unless the two objects were created with the same allocator. </p>

</div>
</div>
<a class="anchor" id="a56c5c1744ffff2aee8abebe03328cc93"></a><!-- doxytag: member="bdlc::operator==" ref="a56c5c1744ffff2aee8abebe03328cc93" args="(const IndexClerkIter &amp;lhs, const IndexClerkIter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator== </td>
          <td>(</td>
          <td class="paramtype">const IndexClerkIter &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexClerkIter &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if <code>lhs</code> and <code>rhs</code> have the same value and <code>false</code> otherwise. Two iterators have the same value if they refer to the same element of the same container or if they both have the end iterator value for the same container. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> refer to the same container and are non-singular (i.e., are not default-constructed or copies of singular iterators). </p>

</div>
</div>
<a class="anchor" id="af35b1bf5bbe5a423daf163c48ebdc57f"></a><!-- doxytag: member="bdlc::operator!=" ref="af35b1bf5bbe5a423daf163c48ebdc57f" args="(const IndexClerkIter &amp;lhs, const IndexClerkIter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator!= </td>
          <td>(</td>
          <td class="paramtype">const IndexClerkIter &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexClerkIter &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if <code>lhs</code> and <code>rhs</code> do not have the same value and <code>false</code> otherwise. Two iterators do not have the same value if they do not refer to the same element of the same container or if one has the end iterator value of a container and the other refers to an element (not the end) of the same container. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> refer to the same container and are non-singular (i.e., are not default-constructed or copies of singular iterators). </p>

</div>
</div>
<a class="anchor" id="ac103da7270e6d2fe4f89c927b148137d"></a><!-- doxytag: member="bdlc::operator==" ref="ac103da7270e6d2fe4f89c927b148137d" args="(const IndexClerk &amp;lhs, const IndexClerk &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator== </td>
          <td>(</td>
          <td class="paramtype">const IndexClerk &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexClerk &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> index clerks have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlc_1_1IndexClerk.html">IndexClerk</a></code> objects have the same value if they have the same <code>nextNewIndex()</code> and would always generate the same sequence of integer indices. </p>

</div>
</div>
<a class="anchor" id="abdb5e99d248fbc7a25ecc036182bbf47"></a><!-- doxytag: member="bdlc::operator!=" ref="abdb5e99d248fbc7a25ecc036182bbf47" args="(const IndexClerk &amp;lhs, const IndexClerk &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator!= </td>
          <td>(</td>
          <td class="paramtype">const IndexClerk &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexClerk &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> index clerks do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlc_1_1IndexClerk.html">IndexClerk</a></code> objects do not have the same value if they do not have the same <code>nextNewIndex()</code>, or might generate different sequences of integer indices. </p>

</div>
</div>
<a class="anchor" id="a50d4c53fb730dfeb44561f5bf63bdf02"></a><!-- doxytag: member="bdlc::operator&lt;&lt;" ref="a50d4c53fb730dfeb44561f5bf63bdf02" args="(bsl::ostream &amp;stream, const IndexClerk &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexClerk &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>rhs</code> index clerk to the specified output <code>stream</code> in some single-line (human-readable) format, and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a046295dee9bb6aa815b626402d2910cd"></a><!-- doxytag: member="bdlc::operator++" ref="a046295dee9bb6aa815b626402d2910cd" args="(PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; bdlc::operator++ </td>
          <td>(</td>
          <td class="paramtype">PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Advance the specified iterator <code>iter</code> to refer to the next element in the referenced array, and return an iterator referring to the original element (<em>before</em> the advancement). The returned iterator, <code>it</code>, referencing an element within a <code><a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a></code>, <code>array</code>, remains valid as long as <code>0 &lt;= it - array.begin() &lt;= array.length()</code>. The behavior is undefined unless, on entry, <code>PackedIntArrayConstInterator() != iter</code> and <code>iter - array.begin() &lt; array.length()</code>. </p>

</div>
</div>
<a class="anchor" id="ac907e5780fc6951e1d99a105b1218fcb"></a><!-- doxytag: member="bdlc::operator&#45;&#45;" ref="ac907e5780fc6951e1d99a105b1218fcb" args="(PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; bdlc::operator-- </td>
          <td>(</td>
          <td class="paramtype">PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decrement the specified iterator <code>iter</code> to refer to the previous element in the referenced array, and return an iterator referring to the original element (<em>before</em> the decrementation). The returned iterator, <code>it</code>, referencing an element within a <code><a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a></code>, <code>array</code>, remains valid as long as <code>0 &lt;= it - array.begin() &lt;= array.length()</code>. The behavior is undefined unless, on entry, <code>PackedIntArrayConstInterator() != iter</code> and <code>0 &lt; iter - array.begin()</code>. </p>

</div>
</div>
<a class="anchor" id="a699ed8e86216dee090d3b606cf323e6d"></a><!-- doxytag: member="bdlc::operator==" ref="a699ed8e86216dee090d3b606cf323e6d" args="(const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator== </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a></code> iterators have the same value if they refer to the same array, and have the same index. </p>

</div>
</div>
<a class="anchor" id="a5ee8bbd83392f2525be8c599511dae54"></a><!-- doxytag: member="bdlc::operator!=" ref="a5ee8bbd83392f2525be8c599511dae54" args="(const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator!= </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators do not have the same value and <code>false</code> otherwise. Two <code><a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a></code> iterators do not have the same value if they do not refer to the same array, or do not have the same index. </p>

</div>
</div>
<a class="anchor" id="a5068e63a06de47744b4304305c43e675"></a><!-- doxytag: member="bdlc::operator&#45;" ref="a5068e63a06de47744b4304305c43e675" args="(const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::ptrdiff_t bdlc::operator- </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements between specified <code>lhs</code> and <code>rhs</code>. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> reference the same array. </p>

</div>
</div>
<a class="anchor" id="ab26530a1eabce342925f16a8ff02a0f2"></a><!-- doxytag: member="bdlc::operator&lt;" ref="ab26530a1eabce342925f16a8ff02a0f2" args="(const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than the specified <code>rhs</code>, <code>false</code> otherwise. An iterator has a value less than another if its index is less the other's index. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> refer to the same array. </p>

</div>
</div>
<a class="anchor" id="af9ea3d514e10a99d07def0d55cd1a85b"></a><!-- doxytag: member="bdlc::operator&lt;=" ref="af9ea3d514e10a99d07def0d55cd1a85b" args="(const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than or equal to the specified <code>rhs, 'false</code> otherwise. An iterator has a value less than or equal to another if its index is less or equal the other's index. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> refer to the same array. </p>

</div>
</div>
<a class="anchor" id="a0adcead2a4dad401a6c8cbe4c66730d1"></a><!-- doxytag: member="bdlc::operator&gt;" ref="a0adcead2a4dad401a6c8cbe4c66730d1" args="(const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value greater than the specified <code>rhs</code>, <code>false</code> otherwise. An iterator has a value greater than another if its index is greater the other's index. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> refer to the same array. </p>

</div>
</div>
<a class="anchor" id="a914890161d13066f362494ab9e41a7a1"></a><!-- doxytag: member="bdlc::operator&gt;=" ref="a914890161d13066f362494ab9e41a7a1" args="(const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value greater or equal than the specified <code>rhs</code>, <code>false</code> otherwise. An iterator has a value greater than or equal to another if its index is greater the other's index. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> refer to the same array. </p>

</div>
</div>
<a class="anchor" id="a2698c9cad2fe0b96aa0e3d39b595e7f6"></a><!-- doxytag: member="bdlc::operator&lt;&lt;" ref="a2698c9cad2fe0b96aa0e3d39b595e7f6" args="(bsl::ostream &amp;stream, const PackedIntArray&lt; TYPE &gt; &amp;array)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArray&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>array</code> to the specified output <code>stream</code> in a single-line format, and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified and can change without notice. </p>

</div>
</div>
<a class="anchor" id="a781e876e0e6a4c4b6fe68eeca2866280"></a><!-- doxytag: member="bdlc::operator==" ref="a781e876e0e6a4c4b6fe68eeca2866280" args="(const PackedIntArray&lt; TYPE &gt; &amp;lhs, const PackedIntArray&lt; TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator== </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArray&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArray&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> arrays have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a></code> arrays have the same value if they have the same length, and all corresponding elements (those at the same indices) have the same value. </p>

</div>
</div>
<a class="anchor" id="a6032dcf17fd62b0a9f2ba111c6b1a43d"></a><!-- doxytag: member="bdlc::operator!=" ref="a6032dcf17fd62b0a9f2ba111c6b1a43d" args="(const PackedIntArray&lt; TYPE &gt; &amp;lhs, const PackedIntArray&lt; TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator!= </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArray&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArray&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> arrays do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a></code> arrays do not have the same value if they do not have the same length, or if any corresponding elements (those at the same indices) do not have the same value. </p>

</div>
</div>
<a class="anchor" id="a54ef1dc153396ce08b40de28aeec64df"></a><!-- doxytag: member="bdlc::swap" ref="a54ef1dc153396ce08b40de28aeec64df" args="(PackedIntArray&lt; TYPE &gt; &amp;a, PackedIntArray&lt; TYPE &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlc::swap </td>
          <td>(</td>
          <td class="paramtype">PackedIntArray&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PackedIntArray&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the values of the specified <code>a</code> and <code>b</code> arrays. This method provides the no-throw exception-safety guarantee. This method invalidates previously-obtained iterators and references. The behavior is undefined unless both arrays were created with the same allocator. </p>

</div>
</div>
<a class="anchor" id="a302d79d598268280fc316fbed19b23e9"></a><!-- doxytag: member="bdlc::operator==" ref="a302d79d598268280fc316fbed19b23e9" args="(const Queue&lt; T &gt; &amp;lhs, const Queue&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator== </td>
          <td>(</td>
          <td class="paramtype">const Queue&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Queue&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> queues have the same value, and <code>false</code> otherwise. Two queues have the same value if they have the same length and the same element value at each respective index position. </p>

</div>
</div>
<a class="anchor" id="a69b9df6d568a3782693f8ed5441fbd0e"></a><!-- doxytag: member="bdlc::operator!=" ref="a69b9df6d568a3782693f8ed5441fbd0e" args="(const Queue&lt; T &gt; &amp;lhs, const Queue&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Queue&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Queue&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> queues do not have the same value, and <code>false</code> otherwise. Two queues do not have the same value if they have different lengths or differ in at least one index position. </p>

</div>
</div>
<a class="anchor" id="aef28b2e94443981176c382bcdbbd2691"></a><!-- doxytag: member="bdlc::operator&lt;&lt;" ref="aef28b2e94443981176c382bcdbbd2691" args="(bsl::ostream &amp;stream, const Queue&lt; T &gt; &amp;queue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Queue&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>queue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>queue</code> to the specified output <code>stream</code> and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:37 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
