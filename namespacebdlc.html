<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Namespace bdlc</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>bdlc Namespace Reference<br/>
<small>
[<a class="el" href="group__bdlc__packedintarray.html">Component bdlc_packedintarray</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlc_1_1PackedIntArrayImp__Signed.html">PackedIntArrayImp_Signed</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlc_1_1PackedIntArrayImp__Unsigned.html">PackedIntArrayImp_Unsigned</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1PackedIntArrayImp.html">PackedIntArrayImp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlc_1_1PackedIntArrayImpType.html">PackedIntArrayImpType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a046295dee9bb6aa815b626402d2910cd">operator++</a> (<a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#ac907e5780fc6951e1d99a105b1218fcb">operator--</a> (<a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a699ed8e86216dee090d3b606cf323e6d">operator==</a> (const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a5ee8bbd83392f2525be8c599511dae54">operator!=</a> (const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bsl::ptrdiff_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a5068e63a06de47744b4304305c43e675">operator-</a> (const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#ab26530a1eabce342925f16a8ff02a0f2">operator&lt;</a> (const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#af9ea3d514e10a99d07def0d55cd1a85b">operator&lt;=</a> (const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a0adcead2a4dad401a6c8cbe4c66730d1">operator&gt;</a> (const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a914890161d13066f362494ab9e41a7a1">operator&gt;=</a> (const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;, const <a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a2698c9cad2fe0b96aa0e3d39b595e7f6">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a>&lt; TYPE &gt; &amp;array)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a781e876e0e6a4c4b6fe68eeca2866280">operator==</a> (const <a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a>&lt; TYPE &gt; &amp;lhs, const <a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a>&lt; TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a6032dcf17fd62b0a9f2ba111c6b1a43d">operator!=</a> (const <a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a>&lt; TYPE &gt; &amp;lhs, const <a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a>&lt; TYPE &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlc.html#a54ef1dc153396ce08b40de28aeec64df">swap</a> (<a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a>&lt; TYPE &gt; &amp;a, <a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a>&lt; TYPE &gt; &amp;b)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a046295dee9bb6aa815b626402d2910cd"></a><!-- doxytag: member="bdlc::operator++" ref="a046295dee9bb6aa815b626402d2910cd" args="(PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; bdlc::operator++ </td>
          <td>(</td>
          <td class="paramtype">PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Advance the specified iterator <code>iter</code> to refer to the next element in the referenced array, and return an iterator referring to the original element (<em>before</em> the advancement). The returned iterator, <code>it</code>, referencing an element within a <code><a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a></code>, <code>array</code>, remains valid as long as <code>0 &lt;= it - array.begin() &lt;= array.length()</code>. The behavior is undefined unless, on entry, <code>PackedIntArrayConstInterator() != iter</code> and <code>iter - array.begin() &lt; array.length()</code>. </p>

</div>
</div>
<a class="anchor" id="ac907e5780fc6951e1d99a105b1218fcb"></a><!-- doxytag: member="bdlc::operator&#45;&#45;" ref="ac907e5780fc6951e1d99a105b1218fcb" args="(PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a>&lt; TYPE &gt; bdlc::operator-- </td>
          <td>(</td>
          <td class="paramtype">PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decrement the specified iterator <code>iter</code> to refer to the previous element in the referenced array, and return an iterator referring to the original element (<em>before</em> the decrementation). The returned iterator, <code>it</code>, referencing an element within a <code><a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a></code>, <code>array</code>, remains valid as long as <code>0 &lt;= it - array.begin() &lt;= array.length()</code>. The behavior is undefined unless, on entry, <code>PackedIntArrayConstInterator() != iter</code> and <code>0 &lt; iter - array.begin()</code>. </p>

</div>
</div>
<a class="anchor" id="a699ed8e86216dee090d3b606cf323e6d"></a><!-- doxytag: member="bdlc::operator==" ref="a699ed8e86216dee090d3b606cf323e6d" args="(const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator== </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a></code> iterators have the same value if they refer to the same array, and have the same index. </p>

</div>
</div>
<a class="anchor" id="a5ee8bbd83392f2525be8c599511dae54"></a><!-- doxytag: member="bdlc::operator!=" ref="a5ee8bbd83392f2525be8c599511dae54" args="(const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator!= </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators do not have the same value and <code>false</code> otherwise. Two <code><a class="el" href="classbdlc_1_1PackedIntArrayConstIterator.html">PackedIntArrayConstIterator</a></code> iterators do not have the same value if they do not refer to the same array, or do not have the same index. </p>

</div>
</div>
<a class="anchor" id="a5068e63a06de47744b4304305c43e675"></a><!-- doxytag: member="bdlc::operator&#45;" ref="a5068e63a06de47744b4304305c43e675" args="(const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::ptrdiff_t bdlc::operator- </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements between specified <code>lhs</code> and <code>rhs</code>. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> reference the same array. </p>

</div>
</div>
<a class="anchor" id="ab26530a1eabce342925f16a8ff02a0f2"></a><!-- doxytag: member="bdlc::operator&lt;" ref="ab26530a1eabce342925f16a8ff02a0f2" args="(const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than the specified <code>rhs</code>, <code>false</code> otherwise. An iterator has a value less than another if its index is less the other's index. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> refer to the same array. </p>

</div>
</div>
<a class="anchor" id="af9ea3d514e10a99d07def0d55cd1a85b"></a><!-- doxytag: member="bdlc::operator&lt;=" ref="af9ea3d514e10a99d07def0d55cd1a85b" args="(const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value less than or equal to the specified <code>rhs, 'false</code> otherwise. An iterator has a value less than or equal to another if its index is less or equal the other's index. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> refer to the same array. </p>

</div>
</div>
<a class="anchor" id="a0adcead2a4dad401a6c8cbe4c66730d1"></a><!-- doxytag: member="bdlc::operator&gt;" ref="a0adcead2a4dad401a6c8cbe4c66730d1" args="(const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value greater than the specified <code>rhs</code>, <code>false</code> otherwise. An iterator has a value greater than another if its index is greater the other's index. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> refer to the same array. </p>

</div>
</div>
<a class="anchor" id="a914890161d13066f362494ab9e41a7a1"></a><!-- doxytag: member="bdlc::operator&gt;=" ref="a914890161d13066f362494ab9e41a7a1" args="(const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;, const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArrayConstIterator&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> has a value greater or equal than the specified <code>rhs</code>, <code>false</code> otherwise. An iterator has a value greater than or equal to another if its index is greater the other's index. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> refer to the same array. </p>

</div>
</div>
<a class="anchor" id="a2698c9cad2fe0b96aa0e3d39b595e7f6"></a><!-- doxytag: member="bdlc::operator&lt;&lt;" ref="a2698c9cad2fe0b96aa0e3d39b595e7f6" args="(bsl::ostream &amp;stream, const PackedIntArray&lt; TYPE &gt; &amp;array)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArray&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>array</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>array</code> to the specified output <code>stream</code> in a single-line format, and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified and can change without notice. </p>

</div>
</div>
<a class="anchor" id="a781e876e0e6a4c4b6fe68eeca2866280"></a><!-- doxytag: member="bdlc::operator==" ref="a781e876e0e6a4c4b6fe68eeca2866280" args="(const PackedIntArray&lt; TYPE &gt; &amp;lhs, const PackedIntArray&lt; TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator== </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArray&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArray&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> arrays have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a></code> arrays have the same value if they have the same length, and all corresponding elements (those at the same indices) have the same value. </p>

</div>
</div>
<a class="anchor" id="a6032dcf17fd62b0a9f2ba111c6b1a43d"></a><!-- doxytag: member="bdlc::operator!=" ref="a6032dcf17fd62b0a9f2ba111c6b1a43d" args="(const PackedIntArray&lt; TYPE &gt; &amp;lhs, const PackedIntArray&lt; TYPE &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlc::operator!= </td>
          <td>(</td>
          <td class="paramtype">const PackedIntArray&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedIntArray&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> arrays do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlc_1_1PackedIntArray.html">PackedIntArray</a></code> arrays do not have the same value if they do not have the same length, or if any corresponding elements (those at the same indices) do not have the same value. </p>

</div>
</div>
<a class="anchor" id="a54ef1dc153396ce08b40de28aeec64df"></a><!-- doxytag: member="bdlc::swap" ref="a54ef1dc153396ce08b40de28aeec64df" args="(PackedIntArray&lt; TYPE &gt; &amp;a, PackedIntArray&lt; TYPE &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlc::swap </td>
          <td>(</td>
          <td class="paramtype">PackedIntArray&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PackedIntArray&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the values of the specified <code>a</code> and <code>b</code> arrays. This method provides the no-throw exception-safety guarantee. This method invalidates previously-obtained iterators and references. The behavior is undefined unless both arrays were created with the same allocator. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:25 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
