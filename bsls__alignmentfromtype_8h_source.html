<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bsls_alignmentfromtype.h                                           -*-C++-*-
#ifndef INCLUDED_BSLS_ALIGNMENTFROMTYPE
#define INCLUDED_BSLS_ALIGNMENTFROMTYPE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a meta-function that maps a &#39;TYPE&#39; to its alignment.
//
//@CLASSES:
//  bsls::AlignmentFromType: mechanism to compute alignment for a given &#39;TYPE&#39;
//
//@SEE_ALSO: bsls_alignmenttotype
//
//@DESCRIPTION: This component contains a template meta-function,
// &#39;bsls::AlignmentFromType&#39;, parameterized on &#39;TYPE&#39;, that defines an integral
// constant &#39;VALUE&#39; initialized (at compile-time) to the required alignment for
// &#39;TYPE&#39;.  &#39;bsls::AlignmentFromType&#39; also provides a &#39;typedef&#39;, &#39;Type&#39;, that
// is an alias for a primitive type that has the same alignment requirements as
// &#39;TYPE&#39;.
//
///Terminology
///-----------
// *Efficient* *Alignment* is any alignment that prevents the CPU from
// performing unaligned memory access.
//
// *Compiler* *Alignment* is the alignment chosen for a data type by a specific
// compiler with a specific set of compile-time options.  On most platforms,
// the compiler can be instructed to pack all structures with 1-byte alignment,
// even if inefficient memory access results.
//
// *Required* *Alignment* is synonymous with *Compiler* *Alignment*, even when
// the CPU supports unaligned access.  The terms &quot;required alignment&quot; and
// &quot;alignment requirement&quot; are in common use even though &quot;compiler alignment&quot;
// is a more precise term.
//
///Surprises and Anomalies
///-----------------------
// Note that *efficient* *alignment* for a given type and its *size* are not
// identical on all platforms.  For example, Linux on 32-bit Intel aligns an
// 8-byte &#39;double&#39; on a 4-byte boundary within a &#39;struct&#39;.
//
// On platforms with 32-bit words, there is usually no efficiency gain by using
// more than 4-byte alignment.  Yet some compilers use 8-byte alignment for
// &#39;long long&#39; or &#39;double&#39;, presumably so that the code will run faster on a
// 64-bit CPU.
//
///Usage
///-----
///Usage Example 1
///- - - - - - - -
// The following shows how &#39;bsls::AlignmentFromType&lt;T&gt;::VALUE&#39; can be used to
// create a static &quot;database&quot; of types storing their size and required
// alignment.
//
// This information can be populated into an array of &#39;my_ElemAttr&#39; elements
// below:
//..
//  enum my_ElemType { MY_CHAR, MY_INT, MY_DOUBLE, MY_POINTER };
//
//  struct my_ElemAttr {
//      my_ElemType d_type;       // type indicator
//      int         d_size;       // &#39;sizeof&#39; the type
//      int         d_alignment;  // alignment requirement for the type
//  };
//
//  static const my_ElemAttr MY_ATTRIBUTES[] = {
//     { MY_CHAR,     sizeof(char),   bsls::AlignmentFromType&lt;char&gt;::VALUE   },
//     { MY_INT,      sizeof(int),    bsls::AlignmentFromType&lt;int&gt;::VALUE    },
//     { MY_DOUBLE,   sizeof(double), bsls::AlignmentFromType&lt;double&gt;::VALUE },
//     { MY_POINTER,  sizeof(void *), bsls::AlignmentFromType&lt;void *&gt;::VALUE }
//  };
//..
///Usage Example 2
///- - - - - - - -
// Consider a parameterized type, &#39;my_AlignedBuffer&#39;, that provides aligned
// memory to store a user-defined type.  A &#39;my_AlignedBuffer&#39; object is useful
// in situations where efficient (e.g., stack-based) storage is required.
//
// The &#39;my_AlignedBuffer&#39; &#39;union&#39; (defined below) takes a template parameter
// &#39;TYPE&#39;, and provides an appropriately sized and aligned block of memory via
// the &#39;buffer&#39; functions.  Note that &#39;my_AlignedBuffer&#39; ensures that the
// returned memory is aligned correctly for the specified size by using
// &#39;bsls::AlignmentFromType&lt;TYPE&gt;::Type&#39;, which provides a primitive type
// having the same alignment requirement as &#39;TYPE&#39;.  The class definition of
// &#39;my_AlignedBuffer&#39; is as follows:
//..
//  template &lt;class TYPE&gt;
//  union my_AlignedBuffer {
//    private:
//      // DATA
//      char                                         d_buffer[sizeof(TYPE)];
//      typename bsls::AlignmentFromType&lt;TYPE&gt;::Type d_align; //force alignment
//
//    public:
//      // MANIPULATORS
//      char *buffer();
//          // Return the address of the modifiable first byte of memory
//          // contained by this object as a &#39;char *&#39; pointer.
//
//      TYPE&amp; object();
//          // Return a reference to the modifiable &#39;TYPE&#39; object stored in
//          // this buffer.  The referenced object has an undefined state
//          // unless a valid &#39;TYPE&#39; object has been constructed in this
//          // buffer.
//
//      // ACCESSORS
//      const char *buffer() const;
//          // Return the address of the non-modifiable first byte of memory
//          // contained by this object as a &#39;const char *&#39; pointer.
//
//      const TYPE&amp; object() const;
//          // Return a reference to the non-modifiable &#39;TYPE&#39; object stored in
//          // this buffer.  The referenced object has an undefined state
//          // unless a valid &#39;TYPE&#39; object has been constructed in this
//          // buffer.
//  };
//..
// The function definitions of &#39;my_AlignedBuffer&#39; are as follows:
//..
//  // MANIPULATORS
//  template &lt;class TYPE&gt;
//  inline
//  char *my_AlignedBuffer&lt;TYPE&gt;::buffer()
//  {
//      return d_buffer;
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  TYPE&amp; my_AlignedBuffer&lt;TYPE&gt;::object()
//  {
//      return *reinterpret_cast&lt;TYPE *&gt;(this);
//  }
//
//  // ACCESSORS
//  template &lt;class TYPE&gt;
//  inline
//  const char *my_AlignedBuffer&lt;TYPE&gt;::buffer() const
//  {
//      return d_buffer;
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  const TYPE&amp; my_AlignedBuffer&lt;TYPE&gt;::object() const
//  {
//      return *reinterpret_cast&lt;const TYPE *&gt;(this);
//  }
//..
// &#39;my_AlignedBuffer&#39; can be used to construct buffers for different types and
// with varied alignment requirements.  Consider that we want to construct an
// object that stores the response of a floating-point operation.  If the
// operation is successful, then the response object stores a &#39;double&#39; result;
// otherwise, it stores an error string of type &#39;string&#39;, which is based on the
// standard type &#39;string&#39; (see &#39;bslstl_string&#39;).  For the sake of brevity, the
// implementation of &#39;string&#39; is not explored here.  Here is the definition for
// the &#39;Response&#39; class:
//..
//  class Response {
//..
// Note that we use &#39;my_AlignedBuffer&#39; to allocate sufficient, aligned memory
// to store the result of the operation or an error message:
//..
//  private:
//    union {
//        my_AlignedBuffer&lt;double&gt;      d_result;
//        my_AlignedBuffer&lt;string&gt; d_errorMessage;
//    };
//..
// The &#39;isError&#39; flag indicates whether the response object stores valid data
// or an error message:
//..
//  bool d_isError;
//..
// Below we provide a simple public interface suitable for illustration only:
//..
//  public:
//    // CREATORS
//    Response(double result);
//        // Create a response object that stores the specified &#39;result&#39;.
//
//    Response(const string&amp; errorMessage);
//        // Create a response object that stores the specified
//        // &#39;errorMessage&#39;.
//
//    ~Response();
//        // Destroy this response object.
//..
// The manipulator functions allow clients to update the response object to
// store either a &#39;double&#39; result or an error message:
//..
//  // MANIPULATORS
//  void setResult(double result);
//      // Update this object to store the specified &#39;result&#39;.  After this
//      // operation &#39;isError&#39; returns &#39;false&#39;.
//
//  void setErrorMessage(const string&amp; errorMessage);
//      // Update this object to store the specified &#39;errorMessage&#39;.  After
//      // this operation &#39;isError&#39; returns &#39;true&#39;.
//..
// The &#39;isError&#39; function informs clients whether a response object stores a
// result value or an error message:
//..
//      // ACCESSORS
//      bool isError() const;
//          // Return &#39;true&#39; if this object stores an error message, and
//          // &#39;false&#39; otherwise.
//
//      double result() const;
//          // Return the result value stored by this object.  The behavior is
//          // undefined unless &#39;false == isError()&#39;.
//
//      const string&amp; errorMessage() const;
//          // Return a reference to the non-modifiable error message stored by
//          // this object.  The behavior is undefined unless
//          // &#39;true == isError()&#39;.
//  };
//..
// Below we provide the function definitions.  Note that we use the
// &#39;my_AlignedBuffer::buffer&#39; function to access correctly aligned memory.
// Also note that &#39;my_AlignedBuffer&#39; just provides the memory for an object;
// therefore, the &#39;Response&#39; class is responsible for the construction and
// destruction of the specified objects.  Since our &#39;Response&#39; class is for
// illustration purposes only, we ignore exception-safety concerns; nor do we
// supply an allocator to the string constructor, allowing the default
// allocator to be used instead:
//..
//  // CREATORS
//  Response::Response(double result)
//  {
//      new (d_result.buffer()) double(result);
//      d_isError = false;
//  }
//
//  Response::Response(const string&amp; errorMessage)
//  {
//      new (d_errorMessage.buffer()) string(errorMessage);
//      d_isError = true;
//  }
//
//  Response::~Response()
//  {
//      if (d_isError) {
//          typedef string Type;
//          d_errorMessage.object().~Type();
//      }
//  }
//
//  // MANIPULATORS
//  void Response::setResult(double result)
//  {
//      if (!d_isError) {
//          d_result.object() = result;
//      }
//      else {
//          typedef string Type;
//          d_errorMessage.object().~Type();
//          new (d_result.buffer()) double(result);
//          d_isError = false;
//      }
//  }
//
//  void Response::setErrorMessage(const string&amp; errorMessage)
//  {
//      if (d_isError) {
//          d_errorMessage.object() = errorMessage;
//      }
//      else {
//          new (d_errorMessage.buffer()) string(errorMessage);
//          d_isError = true;
//      }
//  }
//
//  // ACCESSORS
//  bool Response::isError() const
//  {
//      return d_isError;
//  }
//
//  double Response::result() const
//  {
//      assert(!d_isError);
//
//      return d_result.object();
//  }
//
//  const string&amp; Response::errorMessage() const
//  {
//      assert(d_isError);
//
//      return d_errorMessage.object();
//  }
//..
// Clients of the &#39;Response&#39; class can use it as follows:
//..
//  double value1 = 111.2, value2 = 92.5;
//
//  if (0 == value2) {
//      Response response(&quot;Division by 0&quot;);
//
//      // Return erroneous response
//  }
//  else {
//      Response response(value1 / value2);
//
//      // Process response object
//  }
//..

#ifndef INCLUDED_BSLS_ALIGNMENTIMP
#include &lt;bsls_alignmentimp.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENTTOTYPE
#include &lt;bsls_alignmenttotype.h&gt;
#endif

namespace BloombergLP {

namespace bsls {

                           // ========================
                           // struct AlignmentFromType
                           // ========================

template &lt;class TYPE&gt;
struct AlignmentFromType {
    // This &#39;struct&#39; computes (at compile time) a constant integral &#39;VALUE&#39;
    // that specifies the required alignment for &#39;TYPE&#39; objects.  Also provided
    // is a &#39;typedef&#39;, &#39;Type&#39;, that is an alias for a primitive type that has
    // the same alignment requirements as &#39;TYPE&#39;.

    // TYPES
    enum { VALUE = AlignmentImpCalc&lt;TYPE&gt;::VALUE };
        // Compile-time constant that specifies the required alignment for
        // &#39;TYPE&#39;.

    typedef typename AlignmentToType&lt;VALUE&gt;::Type Type;
        // Alias for a primitive type that has the same alignment requirement
        // as &#39;TYPE&#39;.
};

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
