<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bsltf_degeneratefunctor.h                                          -*-C++-*-
#ifndef INCLUDED_BSLTF_DEGENERATEFUNCTOR
#define INCLUDED_BSLTF_DEGENERATEFUNCTOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an awkward type to adapt a user-supplied functor.
//
//@CLASSES:
//  bsltf::DegenerateFunctor: awkward type that adapts a user-supplied functor
//
//@SEE_ALSO: bsltf_templatetestfacility
//
//@DESCRIPTION: This component provides a functor adaptor, primarily for use
// when testing templates that make use of Callable template parameters.  The
// adaptor defined in this component provides an interface that is purposefully
// as awkward as possible, yet should accepted by generic code, particularly
// code conforming to the widest interpretation of the C++ standard library.
// Many common operations that would be implicitly supplied, such as the
// address-of operator and the comma operator, are explicitly disabled.  While
// the adapter remains CopyConstructible so that it may be used as a member of
// a class, such as a standard container, it is not CopyAssignable, and so
// typically is not Swappable.  An additional boolean template argument
// optionally creates an adapter that supports swapping.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: TBD
/// - - - - - - -

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SWAPUTIL
#include &lt;bslalg_swaputil.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_UTIL
#include &lt;bsls_util.h&gt;
#endif

namespace BloombergLP {

namespace bsltf {

                       // =======================
                       // class DegenerateFunctor
                       // =======================

template &lt;class FUNCTOR, bool ENABLE_SWAP = true&gt;
class DegenerateFunctor : private FUNCTOR {
    // This test class template adapts a CopyConstructible class to offer
    // a minimal or outright obstructive interface for testing generic code.
    // To support the testing of standard containers this adapter will be
    // CopyConstructible, nothrow Destructible, and (optionally) Swappable as
    // long as the adapted &#39;FUNCTOR&#39; satisfies the same requirements.  The
    // (inherited) function call operator should be the only other available
    // method, no other operation (e.g., the unary address-of operator) should
    // be usable.  We take advantage of the fact that defining a copy
    // constructor inhibits the generation of a default constructor, and that
    // constructors are not inherited by a derived class.  &#39;DegenerateFunctor&#39;
    // objects must be created through either the copy constructor, or by
    // wrapping a &#39;FUNCTOR&#39; object through the static factory method of this
    // class, &#39;cloneBaseObject&#39;.

  private:
    // PRIVATE CREATORS
    explicit DegenerateFunctor(const FUNCTOR&amp; base);
        // Create a &#39;DegenerateFunctor&#39; wrapping a copy of the specified
        // &#39;base&#39;.

  private:
    // NOT IMPLEMENTED
    DegenerateFunctor&amp; operator=(const DegenerateFunctor&amp;); // = delete;
        // Not implemented

    void operator&amp;();  // = delete;
        // not implemented

    template&lt;class T&gt;
    void operator,(const T&amp;); // = delete;
        // not implemented

    template&lt;class T&gt;
    void operator,(T&amp;); // = delete;
        // not implemented

    template&lt;class T&gt;
    void swap(T&amp;); // = delete;
        // Not implemented.  This method hides a frequently supplied member
        // function that may be sniffed out by clever template code when it
        // is declared in the base class.  When &#39;ENABLE_SWAP&#39; is &#39;false&#39;, we
        // want to be sure that this class does not accidentally allow
        // swapping through an unexpected back door.  When &#39;ENABLE_SWAP&#39; is
        // &#39;true&#39;, we provide a differently named hook, to minimize the chance
        // that a clever template library can sniff it out.

  public:
    static DegenerateFunctor cloneBaseObject(const FUNCTOR&amp; base);
        // Create a DegenerateFunctor object wrapping a copy of the specified
        // &#39;base&#39;.  Note that this method is supplied so that the only
        // publicly accessible constructor is the copy constructor.

    // CREATORS
    DegenerateFunctor(const DegenerateFunctor&amp; original);
        // Create a &#39;DegenerateFunctor&#39; having the same value the specified
        // &#39;original&#39;.

    // MANIPULATORS
    using FUNCTOR::operator();
        // Expose the overloaded function call operator from the parameterizing
        // class &#39;FUNCTOR&#39;.

    void exchangeValues(DegenerateFunctor *other);
        // Swap the wrapped &#39;FUNCTOR&#39; object, using ADL with &#39;std::swap&#39; in
        // the lookup set, with the functor wrapper by the specified &#39;*other&#39;.
        // Note that this function is deliberately *not* named &#39;swap&#39; as some
        // &quot;clever&quot; template libraries may try to call a member-swap function
        // when they can find it, and ADL-swap is not available.  Also note
        // that this overload is needed only so that the ADL-enabling
        // free-function &#39;swap&#39; can be defined, as the native std library
        // &#39;swap&#39; function does will not accept this class on AIX or Visual C++
        // prior to VC2010.
};

template &lt;class FUNCTOR&gt;
void swap(DegenerateFunctor&lt;FUNCTOR, true&gt;&amp; lhs,
          DegenerateFunctor&lt;FUNCTOR, true&gt;&amp; rhs);
    // Exchange the values of the specified &#39;lhs&#39; and &#39;rhs&#39; objects.


// ============================================================================
//                  INLINE AND TEMPLATE FUNCTION IMPLEMENTATIONS
// ============================================================================

                       // -----------------------
                       // class DegenerateFunctor
                       // -----------------------

// CREATORS
template &lt;class FUNCTOR, bool ENABLE_SWAP&gt;
inline
DegenerateFunctor&lt;FUNCTOR, ENABLE_SWAP&gt;::DegenerateFunctor(const FUNCTOR&amp; base)
: FUNCTOR(base)
{
}

template &lt;class FUNCTOR, bool ENABLE_SWAP&gt;
inline
DegenerateFunctor&lt;FUNCTOR, ENABLE_SWAP&gt;::DegenerateFunctor(
                                             const DegenerateFunctor&amp; original)
: FUNCTOR(original)
{
}

template &lt;class FUNCTOR, bool ENABLE_SWAP&gt;
inline
DegenerateFunctor&lt;FUNCTOR, ENABLE_SWAP&gt;
DegenerateFunctor&lt;FUNCTOR, ENABLE_SWAP&gt;::cloneBaseObject(const FUNCTOR&amp; base)
{
    return DegenerateFunctor(base);
}

template &lt;class FUNCTOR, bool ENABLE_SWAP&gt;
inline
void
DegenerateFunctor&lt;FUNCTOR, ENABLE_SWAP&gt;::exchangeValues(
                                                      DegenerateFunctor *other)
{
    BSLS_ASSERT_SAFE(other);

    bslalg::SwapUtil::swap(static_cast&lt;FUNCTOR *&gt;(this),
                           static_cast&lt;FUNCTOR *&gt;(other) );
}

}  // close package namespace

template &lt;class FUNCTOR&gt;
inline
void bsltf::swap(DegenerateFunctor&lt;FUNCTOR, true&gt;&amp; lhs,
                 DegenerateFunctor&lt;FUNCTOR, true&gt;&amp; rhs)
{
    lhs.exchangeValues(bsls::Util::addressOf(rhs));
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
