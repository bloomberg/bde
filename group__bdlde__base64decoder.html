<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlde_base64decoder Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlde_base64decoder<br/>
<small>
[<a class="el" href="group__bdlde.html">Package bdlde</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide automata for converting to and from Base64 encodings.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlde.html">bdlde</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Base 64 Encoding</a> </li>
<li>
<a href="#3.2">Base 64 Decoding</a> </li>
<li>
<a href="#3.3">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide automata for converting to and from Base64 encodings. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlde_1_1Base64Decoder.html">bdlde::Base64Decoder</a> </td><td>automata performing Base64 decoding operations  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><code><a class="el" href="group__bdlde__base64encoder.html" title="Provide automata for converting to and from Base64 encodings.">Component bdlde_base64encoder</a></code> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component a <code>class</code>, <code><a class="el" href="classbdlde_1_1Base64Decoder.html">bdlde::Base64Decoder</a></code>, which provides a pair of template functions (each parameterized separately on both input and output iterators) that can be used respectively to encode and to decode byte sequences of arbitrary length into and from the printable Base64 representation described in Section 6.8 "Base64 Content Transfer Encoding" of RFC 2045, "Multipurpose Internet Mail Extensions (MIME) Part One: Format
 of Internet Message Bodies." </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Each instance of either the encoder or decoder retains the state of the conversion from one supplied input to the next, enabling the processing of segmented input -- i.e., processing resumes where it left off with the next invocation on new input. Instance methods are provided for both the encoder and decoder to (1) assert the end of input, (2) determine whether the input so far is currently acceptable, and (3) indicate whether a non-recoverable error has occurred. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="base_64_encoding"></a> <a class="anchor" id="description.base_64_encoding"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Base 64 Encoding: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The data stream is processed three bytes at a time from left to right (a final quantum consisting of one or two bytes, as discussed below, is handled specially). Each sequence of three 8-bit quantities <br/>
<br/>
<div class="fragment"><pre class="fragment">      7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |               |               |               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      `------v------<span class="stringliteral">&#39; `------v------&#39;</span> `------v------<span class="stringliteral">&#39;</span>
<span class="stringliteral">           Byte2           Byte1           Byte0</span>
</pre></div><br/>
<br/>
 is segmented into four intermediate 6-bit quantities. <br/>
<br/>
<div class="fragment"><pre class="fragment">      5 4 3 2 1 0 5 4 3 2 1 0 5 4 3 2 1 0 5 4 3 2 1 0
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |           |           |           |           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      `----v----<span class="stringliteral">&#39; `----v----&#39;</span> `----v----<span class="stringliteral">&#39; `----v----&#39;</span>
         char3       char2       char1        char0
</pre></div><br/>
<br/>
 Each 6-bit quantity is in turn used as an index into the following character table to generate an 8-bit character. The four resulting characters hence form the encoding for the original 3-byte sequence. <br/>
<br/>
<div class="fragment"><pre class="fragment">     ======================================================================
              Table of Numeric BASE-64 Encoding Characters          *
     ----------------------------------------------------------------------
     Val Enc  Val Enc  Val Enc  Val Enc  Val Enc  Val Enc  Val Enc  Val Enc
     --- ---  --- ---  --- ---  --- ---  --- ---  --- ---  --- ---  --- ---
       0 <span class="charliteral">&#39;A&#39;</span>    8 <span class="charliteral">&#39;I&#39;</span>   16 <span class="charliteral">&#39;Q&#39;</span>   24 <span class="charliteral">&#39;Y&#39;</span>   32 <span class="charliteral">&#39;g&#39;</span>   40 <span class="charliteral">&#39;o&#39;</span>   48 <span class="charliteral">&#39;w&#39;</span>   56 <span class="charliteral">&#39;4&#39;</span>
       1 <span class="charliteral">&#39;B&#39;</span>    9 <span class="charliteral">&#39;J&#39;</span>   17 <span class="charliteral">&#39;R&#39;</span>   25 <span class="charliteral">&#39;Z&#39;</span>   33 <span class="charliteral">&#39;h&#39;</span>   41 <span class="charliteral">&#39;p&#39;</span>   49 <span class="charliteral">&#39;x&#39;</span>   57 <span class="charliteral">&#39;5&#39;</span>
       2 <span class="charliteral">&#39;C&#39;</span>   10 <span class="charliteral">&#39;K&#39;</span>   18 <span class="charliteral">&#39;S&#39;</span>   26 <span class="charliteral">&#39;a&#39;</span>   34 <span class="charliteral">&#39;i&#39;</span>   42 <span class="charliteral">&#39;q&#39;</span>   50 <span class="charliteral">&#39;y&#39;</span>   58 <span class="charliteral">&#39;6&#39;</span>
       3 <span class="charliteral">&#39;D&#39;</span>   11 <span class="charliteral">&#39;L&#39;</span>   19 <span class="charliteral">&#39;T&#39;</span>   27 <span class="charliteral">&#39;b&#39;</span>   35 <span class="charliteral">&#39;j&#39;</span>   43 <span class="charliteral">&#39;r&#39;</span>   51 <span class="charliteral">&#39;z&#39;</span>   59 <span class="charliteral">&#39;7&#39;</span>
       4 <span class="charliteral">&#39;E&#39;</span>   12 <span class="charliteral">&#39;M&#39;</span>   20 <span class="charliteral">&#39;U&#39;</span>   28 <span class="charliteral">&#39;c&#39;</span>   36 <span class="charliteral">&#39;k&#39;</span>   44 <span class="charliteral">&#39;s&#39;</span>   52 <span class="charliteral">&#39;0&#39;</span>   60 <span class="charliteral">&#39;8&#39;</span>
       5 <span class="charliteral">&#39;F&#39;</span>   13 <span class="charliteral">&#39;N&#39;</span>   21 <span class="charliteral">&#39;V&#39;</span>   29 <span class="charliteral">&#39;d&#39;</span>   37 <span class="charliteral">&#39;l&#39;</span>   45 <span class="charliteral">&#39;t&#39;</span>   53 <span class="charliteral">&#39;1&#39;</span>   61 <span class="charliteral">&#39;9&#39;</span>
       6 <span class="charliteral">&#39;G&#39;</span>   14 <span class="charliteral">&#39;O&#39;</span>   21 <span class="charliteral">&#39;W&#39;</span>   30 <span class="charliteral">&#39;e&#39;</span>   38 <span class="charliteral">&#39;m&#39;</span>   46 <span class="charliteral">&#39;u&#39;</span>   54 <span class="charliteral">&#39;2&#39;</span>   62 <span class="charliteral">&#39;+&#39;</span>
       7 <span class="charliteral">&#39;H&#39;</span>   15 <span class="charliteral">&#39;P&#39;</span>   22 <span class="charliteral">&#39;X&#39;</span>   31 <span class="charliteral">&#39;f&#39;</span>   39 <span class="charliteral">&#39;n&#39;</span>   47 <span class="charliteral">&#39;v&#39;</span>   55 <span class="charliteral">&#39;3&#39;</span>   63 <span class="charliteral">&#39;/&#39;</span>
     ======================================================================
</pre></div><br/>
<br/>
 The 3-byte grouping of the input is only a design of convenience and not a requirement. When the number of bytes in the input stream is not divisible by 3, sufficient 0 bits are padded on the right to achieve an integral number of 6-bit character indices. Then one of two special cases will apply for the final processing step: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>I) There is a single byte of data, in which case there will be two Base64 encoding characters (the second of which will be one of [AQgw]) followed by two equal (<code>=</code>) signs. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>II) There are exactly two bytes of data, in which case there will be three Base64 encoding characters (the third of which will be one of [AEIMQUYcgkosw048] followed by a single equal (<code>=</code>) sign. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The MIME standard requires that the maximum line length of emitted text not exceed 76 characters exclusive of CRLF. The caller may override this default if desired. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Input values of increasing length along with their corresponding Base64 encodings are illustrated below: <br/>
<br/>
<div class="fragment"><pre class="fragment">        Data: <span class="comment">/* nothing */</span>
    Encoding: <span class="comment">/* nothing */</span>

        Data: 0x01
    Encoding: AQ==

        Data: 0x01 0x02
    Encoding: AQI=

        Data: 0x01 0x02 0x03
    Encoding: AQID

        Data: 0x01 0x02 0x03 0x04
    Encoding: AQIDBA==
</pre></div><br/>
<br/>
 In order for a Base64 encoding to be valid, the input data must be either of length a multiple of three (constituting maximal input), or have been terminated explicitly by the <code>endConvert</code> method (initiating bit padding when necessary). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="base_64_decoding"></a> <a class="anchor" id="description.base_64_decoding"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Base 64 Decoding: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The degree to which decoding detects errors can significantly affect performance. The standard permits all non-Base64 characters to be treated as whitespace. One variant mode of this decoder does just that; the other reports an error if a bad (i.e., non-whitespace) character is detected. The mode of the instance is configurable. The standard imposes a maximum of 76 characters exclusive of CRLF; however, the decoder implemented in this component will handle lines of arbitrary length. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following kinds of errors can occur during decoding and are reported with the following priority: <br/>
<br/>
<div class="fragment"><pre class="fragment"> BAD DATA: A character (other than whitespace) that is not a member of the
           Base64 character <span class="keyword">set</span> (including <span class="charliteral">&#39;=&#39;</span>).  Note that <span class="keyword">this</span> error
           is detected only <span class="keywordflow">if</span> the <span class="stringliteral">&#39;decoder&#39;</span> is explicitly configured (at
           construction) to <span class="keywordflow">do</span> so.

 BAD FORMAT: An <span class="charliteral">&#39;=&#39;</span> character precedes a valid numeric Base64 character,
               more than two <span class="charliteral">&#39;=&#39;</span> characters appear (possibly separated by
             non-Base64 characters), a numeric Base64 character other than
             [AEIMQUYcgkosw048] precedes a single terminal <span class="charliteral">&#39;=&#39;</span> character,
             or a character other than [AQgw] precedes a terminal pair of
             consecutive <span class="charliteral">&#39;=&#39;</span> characters.
</pre></div><br/>
<br/>
 The <code>isError</code> method is used to detect such anomalies, and the <code>numIn</code> output parameter (indicating the number of input characters consumed) or possibly the iterator itself (for iterators with reference-semantics) identifies the offending character. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the existence of an <code>=</code> can be used to reliably indicate the end of the valid data, but no such assurance is possible when the length (in bytes) of the initial input data sequence before encoding was evenly divisible by 3. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example shows how to use a <code><a class="el" href="classbdlde_1_1Base64Decoder.html">bdlde::Base64Decoder</a></code> object to implement a function, <code>streamconverter</code>, that reads text from a <code>bsl::istream</code>, decodes that text from base 64 representation, and writes the decoded text to a <code>bsl::ostream</code>. <code>streamconverter</code> returns 0 on success and a negative value if the input data could not be successfully decoded or if there is an I/O error. <br/>
<br/>
<div class="fragment"><pre class="fragment"> streamdecoder.h                      -*-C++-*-

 <span class="keywordtype">int</span> streamDecoder(bsl::ostream&amp; os, bsl::istream&amp; is);
     <span class="comment">// Read the entire contents of the specified input stream &#39;is&#39;, convert</span>
     <span class="comment">// the input base-64 encoding into plain text, and write the decoded</span>
     <span class="comment">// text to the specified output stream &#39;os&#39;.  Return 0 on success, and a</span>
     <span class="comment">// negative value otherwise.</span>
</pre></div><br/>
<br/>
 We will use fixed-sized input and output buffers in the implementation, but, because of the flexibility of <code>bsl::istream</code> and the output-buffer monitoring functionality of <code><a class="el" href="classbdlde_1_1Base64Decoder.html">bdlde::Base64Decoder</a></code>, the fixed buffer sizes do <em>not</em> limit the quantity of data that can be read, decoded, or written to the output stream. The implementation file is as follows. <br/>
<br/>
<div class="fragment"><pre class="fragment"> streamdecoder.cpp                    -*-C++-*-

<span class="preprocessor"> #include &lt;streamdecoder.h&gt;</span>

<span class="preprocessor"> #include &lt;<a class="code" href="bdlde__base64decoder_8h.html" title="Provide automata for converting to and from Base64 encodings.">bdlde_base64decoder.h</a>&gt;</span>

 <span class="keyword">namespace </span>BloombergLP {

 <span class="keywordtype">int</span> streamDecoder(bsl::ostream&amp; os, bsl::istream&amp; is)
 {
     <span class="keyword">enum</span> {
         SUCCESS      =  0,
         DECODE_ERROR = -1,
         IO_ERROR     = -2
     };
</pre></div><br/>
<br/>
 We declare a <code><a class="el" href="classbdlde_1_1Base64Decoder.html">bdlde::Base64Decoder</a></code> object <code>converter</code>, which will decode the input data. Note that various internal buffers and cursors are used as needed without further comment. We read as much data as is available from the user-supplied input stream <code>is</code> <em>or</em> as much as will fit in <code>inputBuffer</code> before beginning conversion. To obtain unobstructedly the output that results from decoding the entire input stream (even in the case of errors), the base64 decoder is configured not to detect errors. <br/>
<br/>
<div class="fragment"><pre class="fragment">     <a class="code" href="classbdlde_1_1Base64Decoder.html">bdlde::Base64Decoder</a> converter(<span class="keyword">false</span>);   <span class="comment">// Do not report errors.</span>

     <span class="keyword">const</span> <span class="keywordtype">int</span> INBUFFER_SIZE  = 1 &lt;&lt; 10;
     <span class="keyword">const</span> <span class="keywordtype">int</span> OUTBUFFER_SIZE = 1 &lt;&lt; 10;

     <span class="keywordtype">char</span> inputBuffer[INBUFFER_SIZE];
     <span class="keywordtype">char</span> outputBuffer[OUTBUFFER_SIZE];

     <span class="keywordtype">char</span> *output    = outputBuffer;
     <span class="keywordtype">char</span> *outputEnd = outputBuffer + <span class="keyword">sizeof</span> outputBuffer;

     <span class="keywordflow">while</span> (is.good()) {  <span class="comment">// input stream not exhausted</span>

         is.read(inputBuffer, <span class="keyword">sizeof</span> inputBuffer);
</pre></div><br/>
<br/>
 With <code>inputBuffer</code> now populated, we'll use <code>converter</code> in an inner <code>while</code> loop to decode the input and write the decoded data to <code>outputBuffer</code> (via the <code>output</code> cursor'). Note that if the call to <code>converter.convert</code> fails, our function terminates with a negative status. <br/>
<br/>
<div class="fragment"><pre class="fragment">         <span class="keyword">const</span> <span class="keywordtype">char</span> *input    = inputBuffer;
         <span class="keyword">const</span> <span class="keywordtype">char</span> *inputEnd = input + is.gcount();

         <span class="keywordflow">while</span> (input &lt; inputEnd) { <span class="comment">// input encoding not complete</span>

             <span class="keywordtype">int</span> numOut;
             <span class="keywordtype">int</span> numIn;

             <span class="keywordtype">int</span> status = converter.convert(output, &amp;numOut, &amp;numIn,
                                            input,   inputEnd,
                                            outputEnd - output);
             <span class="keywordflow">if</span> (status &lt; 0) {
                 <span class="keywordflow">return</span> DECODE_ERROR;                               <span class="comment">// RETURN</span>
             }
</pre></div><br/>
<br/>
 If the call to <code>converter.convert</code> returns successfully, we'll see if the output buffer is full, and if so, write its contents to the user-supplied output stream <code>os</code>. Note how we use the values of <code>numOut</code> and <code>numIn</code> generated by <code>convert</code> to update the relevant cursors. <br/>
<br/>
<div class="fragment"><pre class="fragment">             output += numOut;
             input  += numIn;

             <span class="keywordflow">if</span> (output == outputEnd) {  <span class="comment">// output buffer full; write data</span>
                 os.write (outputBuffer, <span class="keyword">sizeof</span> outputBuffer);
                 <span class="keywordflow">if</span> (os.fail()) {
                     <span class="keywordflow">return</span> IO_ERROR;                               <span class="comment">// RETURN</span>
                 }
                 output = outputBuffer;
             }
         }
     }
</pre></div><br/>
<br/>
 We have now exited both the input and the "decode" loops. <code>converter</code> may still hold decoded output characters, and so we call <code>converter.endConvert</code> to emit any retained output. To guarantee correct behavior, we call this method in an infinite loop, because it is possible that the retained output can fill the output buffer. In that case, we solve the problem by writing the contents of the output buffer to <code>os</code> within the loop. The most likely case, however, is that <code>endConvert</code> will return 0, in which case we exit the loop and write any data remaining in <code>outputBuffer</code> to <code>os</code>. As above, if <code>endConvert</code> fails, we exit the function with a negative return status. <br/>
<br/>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">while</span> (1) {

         <span class="keywordtype">int</span> numOut;

         <span class="keywordtype">int</span> more = converter.endConvert(output, &amp;numOut, outputEnd-output);
         <span class="keywordflow">if</span> (more &lt; 0) {
             <span class="keywordflow">return</span> DECODE_ERROR;                                   <span class="comment">// RETURN</span>
         }

         output += numOut;

         <span class="keywordflow">if</span> (!more) { <span class="comment">// no more output</span>
             <span class="keywordflow">break</span>;
         }

         assert (output == outputEnd);  <span class="comment">// output buffer is full</span>

         os.write (outputBuffer, <span class="keyword">sizeof</span> outputBuffer);  <span class="comment">// write buffer</span>
         <span class="keywordflow">if</span> (os.fail()) {
             <span class="keywordflow">return</span> IO_ERROR;                                       <span class="comment">// RETURN</span>
         }
         output = outputBuffer;
     }

     <span class="keywordflow">if</span> (output &gt; outputBuffer) { <span class="comment">// still data in output buffer; write it</span>
                                  <span class="comment">// all</span>
         os.write(outputBuffer, output - outputBuffer);
     }

     <span class="keywordflow">return</span> (is.eof() &amp;&amp; os.good()) ? SUCCESS : IO_ERROR;
 }

 } <span class="comment">// Close namespace BloombergLP</span>
</pre></div><br/>
<br/>
 For ease of reading, we repeat the full content of the <code>streamconverter.cpp</code> file without interruption. <br/>
<br/>
<div class="fragment"><pre class="fragment"> streamdecoder.cpp                    -*-C++-*-

<span class="preprocessor"> #include &lt;streamdecoder.h&gt;</span>

<span class="preprocessor"> #include &lt;<a class="code" href="bdlde__base64decoder_8h.html" title="Provide automata for converting to and from Base64 encodings.">bdlde_base64decoder.h</a>&gt;</span>

 <span class="keyword">namespace </span>BloombergLP {

 <span class="keywordtype">int</span> streamDecoder(bsl::ostream&amp; os, bsl::istream&amp; is)
 {
     <span class="keyword">enum</span> {
         SUCCESS      =  0,
         DECODE_ERROR = -1,
         IO_ERROR     = -2
     };

     <a class="code" href="classbdlde_1_1Base64Decoder.html">bdlde::Base64Decoder</a> converter(<span class="keyword">false</span>);   <span class="comment">// Do not report errors.</span>

     <span class="keyword">const</span> <span class="keywordtype">int</span> INBUFFER_SIZE  = 1 &lt;&lt; 10;
     <span class="keyword">const</span> <span class="keywordtype">int</span> OUTBUFFER_SIZE = 1 &lt;&lt; 10;

     <span class="keywordtype">char</span> inputBuffer[INBUFFER_SIZE];
     <span class="keywordtype">char</span> outputBuffer[OUTBUFFER_SIZE];

     <span class="keywordtype">char</span> *output    = outputBuffer;
     <span class="keywordtype">char</span> *outputEnd = outputBuffer + <span class="keyword">sizeof</span> outputBuffer;

     <span class="keywordflow">while</span> (is.good()) {  <span class="comment">// input stream not exhausted</span>

         is.read(inputBuffer, <span class="keyword">sizeof</span> inputBuffer);

         <span class="keyword">const</span> <span class="keywordtype">char</span> *input    = inputBuffer;
         <span class="keyword">const</span> <span class="keywordtype">char</span> *inputEnd = input + is.gcount();

         <span class="keywordflow">while</span> (input &lt; inputEnd) { <span class="comment">// input encoding not complete</span>

             <span class="keywordtype">int</span> numOut;
             <span class="keywordtype">int</span> numIn;

             <span class="keywordtype">int</span> status = converter.convert(output, &amp;numOut, &amp;numIn,
                                            input,   inputEnd,
                                            outputEnd - output);
             <span class="keywordflow">if</span> (status &lt; 0) {
                 <span class="keywordflow">return</span> DECODE_ERROR;                               <span class="comment">// RETURN</span>
             }

             output += numOut;
             input  += numIn;

             <span class="keywordflow">if</span> (output == outputEnd) {  <span class="comment">// output buffer full; write data</span>
                 os.write(outputBuffer, <span class="keyword">sizeof</span> outputBuffer);
                 <span class="keywordflow">if</span> (os.fail()) {
                     <span class="keywordflow">return</span> IO_ERROR;                               <span class="comment">// RETURN</span>
                 }
                 output = outputBuffer;
             }
         }
     }

     <span class="keywordflow">while</span> (1) {

         <span class="keywordtype">int</span> numOut;

         <span class="keywordtype">int</span> more = converter.endConvert(output, &amp;numOut, outputEnd-output);
         <span class="keywordflow">if</span> (more &lt; 0) {
             <span class="keywordflow">return</span> DECODE_ERROR;                                   <span class="comment">// RETURN</span>
         }

         output += numOut;

         <span class="keywordflow">if</span> (!more) { <span class="comment">// no more output</span>
             <span class="keywordflow">break</span>;
         }

         assert (output == outputEnd);  <span class="comment">// output buffer is full</span>

         os.write (outputBuffer, <span class="keyword">sizeof</span> outputBuffer);  <span class="comment">// write buffer</span>
         <span class="keywordflow">if</span> (os.fail()) {
             <span class="keywordflow">return</span> IO_ERROR;                                       <span class="comment">// RETURN</span>
         }
         output = outputBuffer;
     }

     <span class="keywordflow">if</span> (output &gt; outputBuffer) {
         os.write (outputBuffer, output - outputBuffer);
     }

     <span class="keywordflow">return</span> (is.eof() &amp;&amp; os.good()) ? SUCCESS : IO_ERROR;
 }

 } <span class="comment">// Close namespace BloombergLP</span>
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:43 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
