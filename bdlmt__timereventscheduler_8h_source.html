<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlmt_timereventscheduler.h                                        -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLMT_TIMEREVENTSCHEDULER
#define INCLUDED_BDLMT_TIMEREVENTSCHEDULER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a thread-safe recurring and non-recurring event scheduler.
//
//@CLASSES:
//  bdlmt::TimerEventScheduler: thread-safe event scheduler
//
//@SEE_ALSO: bdlmt_eventscheduler, bdlcc_timequeue
//
//@DESCRIPTION: This component provides a thread-safe event scheduler,
// &#39;bdlmt::TimerEventScheduler&#39;.  It provides methods to schedule and cancel
// recurring and non-recurring events.  (A recurring event is also referred to
// as a clock).  The callbacks are processed by a separate thread (called the
// dispatcher thread).  By default the callbacks are executed in the dispatcher
// thread, but this behavior can be altered by providing a dispatcher functor
// at the creation time (see the section &quot;The dispatcher thread and the
// dispatcher functor&quot;).  Use this component for implementing timeouts,
// deferred executions, calendars and reminders, and recurring tasks, among
// other time-bound behaviors.
//
///Comparison to &#39;bdlmt::EventScheduler&#39;
///- - - - - - - - - - - - - - - - - - -
// This class has been made mostly obsolete by the newer
// &#39;bdlmt_eventscheduler&#39;, which addresses two main disadvantages of this
// component: 1) &#39;bdlmt_timereventscheduler&#39; can only manage a finite number of
// events -- this limit is in the millions, but &#39;bdlmt_eventscheduler&#39; has no
// such limit; and 2) accessing the queue of a &#39;bdlmt::TimerEventScheduler&#39; is
// inefficient when there is a large number of managed events (since adding or
// removing an event involves a linear search); &#39;bdlmt_eventscheduler&#39; has a
// more sophisticated queue which can be accessed in constant or worst-case
// log(n) time.  The advantage this component provides over
// &#39;bdlmt_eventscheduler&#39; is that it provides light-weight handles to events in
// the queue, while &#39;bdlmt_eventscheduler&#39; provides more heavy-weight
// reference-counted handles that must be released.
//
///Order of Execution of Events
///----------------------------
// It is intended that recurring and non-recurring events are processed as
// close as possible to their respective time values.  Delays and unfairness in
// thread contention can sometimes delay execution, but this component
// guarantees that (1) events are processed in increasing time order, and (2)
// are never processed sooner than their corresponding time (but could be
// processed arbitrarily long afterward, if the dispatcher thread has not been
// able to gain control in the meantime, due to thread contention or to a long
// event).
//
// Note that it is possible to schedule events in a scheduler that has not been
// started yet.  When starting a scheduler, scheduled events whose times have
// already passed will be dispatched as soon as possible after the start time,
// still in order of their corresponding time.
//
// The only exception to those guarantees are when an event &#39;e1&#39; at time &#39;T&#39;
// say, is already pending while another event &#39;e2&#39; is scheduled at a time &lt;=
// &#39;T&#39;.  Then the dispatcher will complete the execution of &#39;e1&#39; before
// dispatching &#39;e2&#39;.
//
///The Dispatcher Thread and the Dispatcher Functor
///------------------------------------------------
// Between calls to &#39;start&#39; and &#39;stop&#39;, the scheduler creates a separate thread
// (called the *dispatcher thread*) to process all the callbacks.  The
// dispatcher thread executes the callbacks by passing them to the dispatcher
// functor (optionally specified at creation time).  The default dispatcher
// functor simply invokes the passed callback, effectively executing it in the
// dispatcher thread.  Users can alter this behavior by defining their own
// dispatcher functor (for example in order to use a thread pool or a separate
// thread to run the callbacks).  In that case, the user-supplied functor will
// still be run in the dispatcher thread, different from the scheduler thread.
//
///Thread Safety
///-------------
// The &#39;bdlmt::TimerEventScheduler&#39; class is both *fully thread-safe* (i.e.,
// all non-creator methods can correctly execute concurrently), and is
// *thread-enabled* (i.e., the classes does not function correctly in a
// non-multi-threading environment).  See &#39;bsldoc_glossary&#39; for complete
// definitions of *fully thread-safe* and *thread-enabled*.
//
///Supported Clock-Types
///---------------------
// The component &#39;bsls::SystemClockType&#39; supplies the enumeration indicating
// the system clock on which times supplied to other methods should be based.
// If the clock type indicated at construction is
// &#39;bsls::SystemClockType::e_REALTIME&#39;, time should be expressed as an absolute
// offset since 00:00:00 UTC, January 1, 1970 (which matches the epoch used in
// &#39;bdlt::CurrentTime::now(bsls::SystemClockType::e_REALTIME)&#39;.  If the clock
// type indicated at construction is &#39;bsls::SystemClockType::e_MONOTONIC&#39;, time
// should be expressed as an absolute offset since the epoch of this clock
// (which matches the epoch used in
// &#39;bdlt::CurrentTime::now(bsls::SystemClockType::e_MONOTONIC)&#39;.
//
///Usage
///-----
// The following example shows how to use a &#39;bdlmt::TimerEventScheduler&#39; to
// implement a timeout mechanism in a server.  &#39;my_Session&#39; maintains several
// connections.  It closes a connection if the data for it does not arrive
// before a timeout (specified at the server creation time).
//
//..
//    class my_Session{
//        // This class encapsulates the data and state associated with a
//        // connection and provides a method &#39;processData&#39; to process the
//        // incoming data for the connection.
//      public:
//        int processData(void *data, int length);
//            // Process the specified &#39;data&#39; of the specified &#39;length&#39;.
//    };
//
//    class my_Server {
//     // This class implements a server maintaining several connections.
//     // A connection is closed if the data for it does not arrive
//     // before a timeout (specified at the server creation time).
//
//     struct Connection {
//         bdlmt::TimerEventScheduler::Handle d_timerId; // handle for timeout
//                                                     // event
//
//         my_Session *d_session_p;                    // session for this
//                                                     // connection
//     };
//
//     bsl::vector&lt;Connection*&gt;     d_connections; // maintained connections
//     bdlmt::TimerEventScheduler     d_scheduler;   // timeout event scheduler
//     bsls::TimeInterval            d_ioTimeout;   // time out
//
//     void newConnection(Connection *connection);
//         // Add the specified &#39;connection&#39; to this server and schedule
//         // the timeout event that closes this connection if the data
//         // for this connection does not arrive before the timeout.
//
//     void closeConnection(Connection *connection);
//         // Close the specified &#39;connection&#39; and remove it from this server.
//
//     void dataAvailable(Connection *connection, void *data, int length);
//         // Return if the specified &#39;connection&#39; has already timed-out.
//         // If not, cancel the existing timeout event for the &#39;connection&#39;,
//         // process the specified &#39;data&#39; of the specified &#39;length&#39; and
//         // schedule a new timeout event that closes the &#39;connection&#39; if
//         // the data does not arrive before the timeout.
//
//   public:
//     my_Server(const bsls::TimeInterval&amp;  ioTimeout,
//               bslma::Allocator          *allocator = 0);
//         // Construct a &#39;my_Server&#39; object with a timeout value of
//         // &#39;ioTimeout&#39; seconds.  Optionally specify a &#39;allocator&#39; used to
//         // supply memory.  If &#39;allocator&#39; is 0, the currently installed
//         // default allocator is used.
//
//     ~my_Server();
//         // Perform the required clean-up and destroy this object.
// };
//
// my_Server::my_Server(const bsls::TimeInterval&amp;  ioTimeout,
//                      bslma::Allocator          *allocator)
// : d_connections(allocator)
// , d_scheduler(allocator)
// , d_ioTimeout(ioTimeout)
// {
//      // logic to start monitoring the arriving connections or data
//
//      d_scheduler.start();
// }
//
// my_Server::~my_Server()
// {
//     // logic to clean up
//
//     d_scheduler.stop();
// }
//
// void my_Server::newConnection(my_Server::Connection *connection)
// {
//     // logic to add &#39;connection&#39; to the &#39;d_connections&#39;
//
//     // setup the timeout for data arrival
//     connection-&gt;d_timerId = d_scheduler.scheduleEvent(
//        bdlt::CurrentTime::now() + d_ioTimeout,
//        bdlf::BindUtil::bind(&amp;my_Server::closeConnection, this, connection));
// }
//
// void my_Server::closeConnection(my_Server::Connection *connection)
// {
//     // logic to close the &#39;connection&#39; and remove it from &#39;d_ioTimeout&#39;
// }
//
// void my_Server::dataAvailable(my_Server::Connection *connection,
//                               void                  *data,
//                               int                   length)
// {
//     // If connection has already timed out and closed, simply return.
//     if (d_scheduler.cancelEvent(connection-&gt;d_timerId)) {
//         return;                                                // RETURN
//     }
//
//     // process the data
//     connection-&gt;d_session_p-&gt;processData(data, length);
//
//     // setup the timeout for data arrival
//     connection-&gt;d_timerId = d_scheduler.scheduleEvent(
//        bdlt::CurrentTime::now() + d_ioTimeout,
//        bdlf::BindUtil::bind(&amp;my_Server::closeConnection, this, connection));
// }
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLCC_OBJECTCATALOG
#include &lt;bdlcc_objectcatalog.h&gt;
#endif

#ifndef INCLUDED_BDLCC_TIMEQUEUE
#include &lt;bdlcc_timequeue.h&gt;
#endif

#ifndef INCLUDED_BDLMA_CONCURRENTPOOL
#include &lt;bdlma_concurrentpool.h&gt;
#endif

#ifndef INCLUDED_BSLMT_THREADATTRIBUTES
#include &lt;bslmt_threadattributes.h&gt;
#endif

#ifndef INCLUDED_BSLMT_CONDITION
#include &lt;bslmt_condition.h&gt;
#endif

#ifndef INCLUDED_BSLMT_MUTEX
#include &lt;bslmt_mutex.h&gt;
#endif

#ifndef INCLUDED_BSLMT_THREADUTIL
#include &lt;bslmt_threadutil.h&gt;
#endif

#ifndef INCLUDED_BSLS_TIMEINTERVAL
#include &lt;bsls_timeinterval.h&gt;
#endif

#ifndef INCLUDED_BSLS_SYSTEMCLOCKTYPE
#include &lt;bsls_systemclocktype.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include &lt;bslalg_typetraits.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSL_FUNCTIONAL
#include &lt;bsl_functional.h&gt;
#endif

#ifndef INCLUDED_BSL_MEMORY
#include &lt;bsl_memory.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {

namespace bdlmt {

struct TimerEventSchedulerDispatcher;

                         // =========================
                         // class TimerEventScheduler
                         // =========================

class TimerEventScheduler {
    // This class provides a thread-safe event scheduler.  &#39;scheduleEvent&#39;
    // schedules a non-recurring event, returning a handle of type
    // &#39;TimerEventScheduler::Handle&#39;, which can be used to cancel the scheduled
    // event by invoking &#39;cancelEvent&#39;.  Similarly, &#39;startClock&#39; schedules a
    // recurring event, returning a handle of type
    // &#39;TimerEventScheduler::Handle&#39;, which can be used to cancel the clock by
    // invoking &#39;cancelClock&#39;.  &#39;cancelAllEvents&#39; cancels all the registered
    // events and &#39;cancelAllClocks&#39; cancels all the registered clocks.  The
    // callbacks are processed by a separate thread (called dispatcher thread).
    // By default the callbacks are executed in the dispatcher thread, but this
    // behavior can be altered by providing a dispatcher functor at the
    // creation time (see the section &quot;The dispatcher thread and the dispatcher
    // functor&quot;).  &#39;start&#39; must be invoked to start dispatching the callbacks.
    // &#39;stop&#39; stops the dispatching of the callbacks without removing the
    // pending events.

  private:
    // PRIVATE TYPES
    struct ClockData {
        // This structure encapsulates the data associated with a clock.

        bsl::function&lt;void()&gt;     d_callback;          // associated callback

        bsls::TimeInterval        d_periodicInterval;  // associated periodic
                                                       // interval

        volatile bool             d_isCancelled;       // tracks if the
                                                       // associated clock has
                                                       // been cancelled

        int                       d_handle;            // handle for clock
                                                       // callback

        // TRAITS
        BSLALG_DECLARE_NESTED_TRAITS(ClockData,
                                     bslalg::TypeTraitUsesBslmaAllocator);

        // CREATORS
        ClockData(const bsl::function&lt;void()&gt;&amp;  callback,
                  const bsls::TimeInterval&amp;     interval,
                  bslma::Allocator             *basicAllocator = 0)
        : d_callback(bsl::allocator_arg_t(),
                     bsl::allocator&lt;bsl::function&lt;void()&gt; &gt;(basicAllocator),
                     callback)
        , d_periodicInterval(interval)
        , d_isCancelled(false)
        , d_handle(0)
        {
        }

        ClockData(const ClockData&amp;  original,
                  bslma::Allocator *basicAllocator = 0)
        : d_callback(bsl::allocator_arg_t(),
                     bsl::allocator&lt;bsl::function&lt;void()&gt; &gt;(basicAllocator),
                     original.d_callback)
        , d_periodicInterval(original.d_periodicInterval)
        , d_isCancelled(original.d_isCancelled)
        , d_handle(original.d_handle)
        {
        }
    };

    typedef bsl::shared_ptr&lt;ClockData&gt;                   ClockDataPtr;
    typedef bdlcc::TimeQueue&lt;ClockDataPtr&gt;               ClockTimeQueue;
    typedef bdlcc::TimeQueueItem&lt;bsl::function&lt;void()&gt; &gt; EventItem;
    typedef bdlcc::TimeQueue&lt;bsl::function&lt;void()&gt; &gt;     EventTimeQueue;

  public:
    // TYPES
    typedef int Handle;
        // Defines a type alias for a handle that identifies a scheduled clock
        // or event.

    typedef bsl::function&lt;void(const bsl::function&lt;void()&gt;&amp;)&gt; Dispatcher;
        // Defines a type alias for the dispatcher functor type.

    typedef bdlcc::TimeQueue&lt;bsl::function&lt;void()&gt; &gt;::Key     EventKey;
        // Defines a type alias for a user-supplied key for identifying events.

    // CONSTANTS
    enum {
        e_INVALID_HANDLE = -1  // value of an invalid event or clock handle
    };

  private:
    // DATA
    bslma::Allocator *d_allocator_p;        // memory allocator (held)

    bsls::SystemClockType::Enum
                      d_clockType;          // clock type used

    bdlma::ConcurrentPool
                      d_clockDataAllocator; // pool for &#39;ClockData&#39; objects

    EventTimeQueue    d_eventTimeQueue;     // time queue for non recurring
                                            // events

    ClockTimeQueue    d_clockTimeQueue;     // time queue for clock events

    bdlcc::ObjectCatalog&lt;ClockDataPtr&gt;
                      d_clocks;             // catalog of clocks

    bslmt::Mutex      d_mutex;              // mutex used to control access to
                                            // this timer event scheduler

    bslmt::Condition  d_condition;          // condition variable used to
                                            // control access to this timer
                                            // event scheduler

    bslmt::ThreadUtil::Handle
                      d_dispatcherThread;   // handle of the dispatcher thread

    Dispatcher        d_dispatcherFunctor;  // functor used to dispatch events

    volatile int      d_running;            // indicates if the timer event
                                            // scheduler is running

    volatile int      d_iterations;         // dispatcher cycle iteration
                                            // number

    bsl::vector&lt;EventItem&gt;
                      d_pendingEventItems;  // array of pending event callbacks

    int               d_currentEventIndex;  // index (in the array
                                            // &#39;d_pendingEventItems&#39;) of the
                                            // current event callback being
                                            // processed by dispatcher thread

    bsls::AtomicInt   d_numEvents;          // the number of events currently
                                            // registered and/or pending
                                            // dispatch (current callback is
                                            // NOT counted)

    bsls::AtomicInt   d_numClocks;          // number of clocks currently
                                            // registered

    // NOT IMPLEMENTED
    TimerEventScheduler(const TimerEventScheduler&amp; original);
    TimerEventScheduler&amp; operator=(const TimerEventScheduler&amp; rhs);

    // FRIENDS
    friend struct TimerEventSchedulerDispatcher;

  private:
    // PRIVATE MANIPULATORS
    void yieldToDispatcher();
        // Repeatedly wake up dispatcher thread until it noticeably starts
        // running.

  public:
    // TRAITS
    BSLALG_DECLARE_NESTED_TRAITS(TimerEventScheduler,
                                 bslalg::TypeTraitUsesBslmaAllocator);

    // CREATORS
    explicit TimerEventScheduler(bslma::Allocator *basicAllocator = 0);
        // Construct an event scheduler using the default dispatcher functor
        // (see the &quot;The dispatcher thread and the dispatcher functor&quot; section
        // in component-level doc) and use the realtime clock epoch for all
        // time intervals (see {Supported Clock-Types} in the component
        // documentation).  Optionally specify a &#39;basicAllocator&#39; used to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    explicit TimerEventScheduler(
                              bsls::SystemClockType::Enum  clockType,
                              bslma::Allocator            *basicAllocator = 0);
        // Construct an event scheduler using the default dispatcher functor
        // (see the &quot;The dispatcher thread and the dispatcher functor&quot; section
        // in component-level doc) and use the specified &#39;clockType&#39; to
        // indicate the epoch used for all time intervals (see {Supported
        // Clock-Types} in the component documentation).  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    explicit TimerEventScheduler(const Dispatcher&amp;  dispatcherFunctor,
                                 bslma::Allocator  *basicAllocator = 0);
        // Construct an event scheduler using the specified &#39;dispatcherFunctor&#39;
        // (see &quot;The dispatcher thread and the dispatcher functor&quot; section in
        // component-level doc) and use the realtime clock epoch for all time
        // intervals (see {Supported Clock-Types} in the component
        // documentation).  Optionally specify a &#39;basicAllocator&#39; used to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    explicit TimerEventScheduler(
                              const Dispatcher&amp;            dispatcherFunctor,
                              bsls::SystemClockType::Enum  clockType,
                              bslma::Allocator            *basicAllocator = 0);
        // Construct an event scheduler using the specified &#39;dispatcherFunctor&#39;
        // (see &quot;The dispatcher thread and the dispatcher functor&quot; section in
        // component-level doc) and use the specified &#39;clockType&#39; to indicate
        // the epoch used for all time intervals (see {Supported Clock-Types}
        // in the component documentation).  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    TimerEventScheduler(int               numEvents,
                        int               numClocks,
                        bslma::Allocator *basicAllocator = 0);
        // Construct a timer event scheduler using the default dispatcher
        // functor (see the &quot;The dispatcher thread and the dispatcher functor&quot;
        // section in component level doc) that has the capability to
        // concurrently schedule *at* *least* the specified &#39;numEvents&#39; and
        // &#39;numClocks&#39; and use the realtime clock epoch for all time intervals
        // (see {Supported Clock-Types} in the component documentation).
        // Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.  The behavior is undefined unless &#39;0 &lt;= numEvents &lt; 2**24&#39; and
        // &#39;0 &lt;= numClocks &lt; 2**24&#39;.

    TimerEventScheduler(int                          numEvents,
                        int                          numClocks,
                        bsls::SystemClockType::Enum  clockType,
                        bslma::Allocator            *basicAllocator = 0);
        // Construct a timer event scheduler using the default dispatcher
        // functor (see the &quot;The dispatcher thread and the dispatcher functor&quot;
        // section in component level doc) that has the capability to
        // concurrently schedule *at* *least* the specified &#39;numEvents&#39; and
        // &#39;numClocks&#39; and use the specified &#39;clockType&#39; to indicate the epoch
        // used for all time intervals (see {Supported Clock-Types} in the
        // component documentation).  Optionally specify a &#39;basicAllocator&#39;
        // used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently
        // installed default allocator is used.  The behavior is undefined
        // unless &#39;0 &lt;= numEvents &lt; 2**24&#39; and &#39;0 &lt;= numClocks &lt; 2**24&#39;.

    TimerEventScheduler(int                numEvents,
                        int                numClocks,
                        const Dispatcher&amp;  dispatcherFunctor,
                        bslma::Allocator  *basicAllocator = 0);
        // Construct a timer event scheduler using the specified
        // &#39;dispatcherFunctor&#39; (see &quot;The dispatcher thread and the dispatcher
        // functor&quot; section in component level doc) that has the capability to
        // concurrently schedule *at* *least* the specified &#39;numEvents&#39; and
        // &#39;numClocks&#39; and use the realtime clock epoch for all time intervals
        // (see {Supported Clock-Types} in the component documentation).
        // Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.  The behavior is undefined unless &#39;0 &lt;= numEvents &lt; 2**24&#39; and
        // &#39;0 &lt;= numClocks &lt; 2**24&#39;.

    TimerEventScheduler(int                          numEvents,
                        int                          numClocks,
                        const Dispatcher&amp;            dispatcherFunctor,
                        bsls::SystemClockType::Enum  clockType,
                        bslma::Allocator            *basicAllocator = 0);
        // Construct a timer event scheduler using the specified
        // &#39;dispatcherFunctor&#39; (see &quot;The dispatcher thread and the dispatcher
        // functor&quot; section in component level doc) that has the capability to
        // concurrently schedule *at* *least* the specified &#39;numEvents&#39; and
        // &#39;numClocks&#39; and use the specified &#39;clockType&#39; to indicate the epoch
        // used for all time intervals (see {Supported Clock-Types} in the
        // component documentation).  Optionally specify a &#39;basicAllocator&#39;
        // used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently
        // installed default allocator is used.  The behavior is undefined
        // unless &#39;0 &lt;= numEvents &lt; 2**24&#39; and &#39;0 &lt;= numClocks &lt; 2**24&#39;.

    ~TimerEventScheduler();
        // Stop this scheduler, discard all the unprocessed events and destroy
        // this object.

    // MANIPULATORS
    int start();
        // Start dispatching events on this scheduler.  The dispatcher thread
        // will have default attributes.  Return 0 on success, and a non-zero
        // result otherwise.  If this scheduler has already started then this
        // invocation has no effect and 0 is returned.  This scheduler can be
        // stopped by invoking &#39;stop&#39;.  Note that any event whose time has
        // already passed is pending and will be dispatched immediately.

    int start(const bslmt::ThreadAttributes&amp; threadAttributes);
        // Start dispatching events on this scheduler, using the specified
        // &#39;threadAttributes&#39; for the dispatcher thread, except the DETACHED
        // attribute will always be overridden to be joinable.  Return 0 on
        // success, and a non-zero result otherwise.  If this scheduler has
        // already started then this invocation has no effect and 0 is
        // returned.  This scheduler can be stopped by invoking &#39;stop&#39;.  Note
        // that any event whose time has already passed is pending and will be
        // dispatched immediately.

    void stop();
        // Stop dispatching events on this scheduler, but do not remove any
        // pending event.  If the dispatcher thread is in the middle of
        // dispatching some events, block until those events are disptached.
        // Then terminate the dispatcher thread and return.  If this scheduler
        // is already stopped then this invocation has no effect.  The behavior
        // is undefined if this function is called by a job enqueued to the
        // scheduler that is to be stopped.  This scheduler can be restarted by
        // invoking &#39;start&#39;.

    Handle scheduleEvent(const bsls::TimeInterval&amp;    time,
                         const bsl::function&lt;void()&gt;&amp; callback,
                         const EventKey&amp;              key = EventKey(0));
        // Schedule the specified &#39;callback&#39; to be dispatched at the specified
        // &#39;time&#39; and return a handle that can be used to cancel the &#39;callback&#39;
        // (by invoking &#39;cancelEvent&#39;).  Optionally specify &#39;key&#39; to uniquely
        // identify the event.  The &#39;time&#39; is an absolute time represented as
        // an interval from some epoch, which is detemined by the clock
        // indicated at construction (see {&#39;Supported Clock-Types&#39;} in the
        // component documentation).

    int rescheduleEvent(Handle                    handle,
                        const bsls::TimeInterval&amp; newTime,
                        bool                      wait = false);
    int rescheduleEvent(Handle                    handle,
                        const EventKey&amp;           key,
                        const bsls::TimeInterval&amp; newTime,
                        bool                      wait = false);

        // Reschedule the event having the specified &#39;handle&#39; at the specified
        // &#39;newTime&#39;.  Optionally use the specified &#39;key&#39; to uniquely identify
        // the event.  If the optionally specified &#39;wait&#39; is true, then ensure
        // that the event having the specified &#39;handle&#39; (if it is valid) is
        // either successfully rescheduled or dispatched before the call
        // returns.  Return 0 on successful reschedule, and a non-zero value if
        // the &#39;handle&#39; is invalid *or* if the event has already been
        // dispatched *or* if the event has not yet been dispatched but will
        // soon be dispatched.  If this method is being invoked from the
        // dispatcher thread then the &#39;wait&#39; is ignored to avoid deadlock.  The
        // &#39;newTime&#39; is an absolute time represented as an interval from some
        // epoch, which is detemined by the clock indicated at construction
        // (see {&#39;Supported Clock-Types&#39;} in the component documentation).

    int cancelEvent(Handle          handle,
                    bool            wait = false);
    int cancelEvent(Handle          handle,
                    const EventKey&amp; key,
                    bool            wait = false);
        // Cancel the event having the specified &#39;handle&#39;.  Optionally use the
        // specified &#39;key&#39; to uniquely identify the event.  If the optionally
        // specified &#39;wait&#39; is true, then ensure that the dispatcher thread has
        // resumed execution before returning.  Return 0 on successful
        // cancellation, and a non-zero value if the &#39;handle&#39; is invalid *or*
        // if it is too late to cancel the event.  If this method is being
        // invoked from the dispatcher thread then the &#39;wait&#39; is ignored to
        // avoid deadlock.

    void cancelAllEvents(bool wait = false);
        // Cancel all the events.  If the optionally specified &#39;wait&#39; is true,
        // then ensure any event still in this scheduler is either cancelled or
        // has been dispatched before this call returns.  If this method is
        // being invoked from the dispatcher thread then the &#39;wait&#39; is ignored
        // to avoid deadlock.

    Handle startClock(
               const bsls::TimeInterval&amp;    interval,
               const bsl::function&lt;void()&gt;&amp; callback,
               const bsls::TimeInterval&amp;    startTime = bsls::TimeInterval(0));
        // Schedule a recurring event that invokes the specified &#39;callback&#39; at
        // every specified &#39;interval&#39;, starting at the optionally specified
        // &#39;startTime&#39;.  Return an identifier that can be use to cancel the
        // clock (by invoking &#39;cancelClock&#39;).  If no start time is specified,
        // it is assumed to be the &#39;interval&#39; time from now.  The &#39;startTime&#39;
        // is an absolute time represented as an interval from some epoch,
        // which is detemined by the clock indicated at construction (see
        // {&#39;Supported Clock-Types&#39;} in the component documentation).

    int cancelClock(Handle handle, bool wait = false);
        // Cancel the clock having the specified &#39;handle&#39;.  If the optionally
        // specified &#39;wait&#39; is true, then ensure that any scheduled event for
        // the clock having &#39;handle&#39; is either cancelled or has been dispatched
        // before this call returns.  Return 0 on success, and a non-zero value
        // if the &#39;handle&#39; is invalid.  If this method is being invoked from
        // the dispatcher thread, then the &#39;wait&#39; is ignored to avoid deadlock.

    void cancelAllClocks(bool wait = false);
        // Cancel all clocks.  If the optionally specified &#39;wait&#39; is true, then
        // ensure that any clock event still in this scheduler is either
        // cancelled or has been dispatched before this call returns.  If this
        // method is being invoked from the dispatcher thread, then the &#39;wait&#39;
        // is ignored to avoid deadlock.

    // ACCESSORS
    bsls::SystemClockType::Enum clockType() const;
        // Return the value of the clock type that this object was created
        // with.

    int numClocks() const;
        // Return a *snapshot* of the number of registered clocks with this
        // scheduler.

    int numEvents() const;
        // Return a *snapshot* of the number of pending events and events being
        // dispatched in this scheduler.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                            // -------------------
                            // TimerEventScheduler
                            // -------------------

// MANIPULATORS
inline
int TimerEventScheduler::cancelEvent(TimerEventScheduler::Handle handle,
                                     bool                        wait)
{
    return cancelEvent(handle, EventKey(0), wait);
}

inline
int TimerEventScheduler::rescheduleEvent(TimerEventScheduler::Handle handle,
                                         const bsls::TimeInterval&amp;   newTime,
                                         bool                        wait)
{
    return rescheduleEvent(handle, EventKey(0), newTime, wait);
}

// ACCESSORS
inline
bsls::SystemClockType::Enum TimerEventScheduler::clockType() const
{
    return d_clockType;
}

inline
int TimerEventScheduler::numClocks() const
{
    return d_numClocks;
}

inline
int TimerEventScheduler::numEvents() const
{
    return d_numEvents;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
