<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlsc_channelallocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlsc_channelallocator<br/>
<small>
[<a class="el" href="group__btlsc.html">Package btlsc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide protocol for blocking stream-based channel allocators.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlsc.html">btlsc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Protocol Hierarchy</a> </li>
<li>
<a href="#3.2">Channel Allocation</a> </li>
<li>
<a href="#3.3">Asynchronous Events</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Server Side</a> </li>
<li>
<a href="#3.4.2">Client Side</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide protocol for blocking stream-based channel allocators. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a> </td><td>blocking stream channel allocator  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlsc__cbchannelallocator.html" title="Provide protocol for non-blocking stream-based channel allocators.">Component btlsc_cbchannelallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a class, <code><a class="el" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a></code>, that defines an abstract interface for a synchronous (i.e., blocking) mechanism that allocates and deallocates synchronous channels having timeout capability; the allocation itself does <em>not</em> have timeout capability. Each channel is an end point of a bi-directional stream-based communication connection to a peer; connection details, such as who the peer is, whether there is indeed one peer or multiple similar peers, and how the connection came to be, are not relevant to this channel-allocator protocol, and are therefore abstracted. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In particular, <code><a class="el" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a></code> can allocate channels of type <code><a class="el" href="classbtlsc_1_1Channel.html">btlsc::Channel</a></code> and <code><a class="el" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a></code>, i.e., untimed and timed blocking channels. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="protocol_hierarchy"></a> <a class="anchor" id="description.protocol_hierarchy"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Protocol Hierarchy: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a></code> forms the base of an interface hierarchy; other interfaces may be defined by direct public inheritance: <br/>
<br/>
<div class="fragment"><pre class="fragment">                     ,-----------------------.
                    ( <a class="code" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a> )
                     `-----------------------<span class="stringliteral">&#39;</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="channel_allocation"></a> <a class="anchor" id="description.channel_allocation"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Channel Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This protocol establishes methods for allocating synchronous, stream-based channels. Each allocation method blocks until (1) "success" -- the requested channel is allocated and its address returned to the user (in which case the <code>status</code> argument is not modified), (2) "interrupted" -- the operation was interrupted (e.g., via an asynchronous event), the channel address is null, and <code>status</code> is set to a non-negative value (see below), or (3) "error" -- an implementation-dependent error occurred, the channel address is null, and <code>status</code> is less than -1. The user may retry interrupted operations with a reasonable expectation of success. An "error" status implies that the allocation is unlikely to succeed if retried, but does not <em>necessarily</em> invalidate the allocator. The <code>isInvalid</code> method may be used to confirm the occurrence of a permanent error. An allocation can <em>never</em> succeed once an allocator is invalid. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The meanings of the <code>status</code> value for an unsuccessful allocation (i.e., a null channel address) are summarized as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="stringliteral">&quot;status&quot;</span>    meaning (only when returned channel address is null)
  --------    ----------------------------------------------------
  positive    Interruption by an <span class="stringliteral">&quot;asynchronous event&quot;</span>

  &lt; -1        Allocation operation unable to succeed at <span class="keyword">this</span> time
</pre></div><br/>
<br/>
 Note that unless asynchronous events are explicitly enabled (see below), they are ignored, and "status" will never be positive. Also note that, for consistency with non-blocking transport, a status of -1 is reserved for a "canceled" operation, which is not possible in this blocking protocol, and for consistency with timed allocators a status of 0 is reserved for a timeout (which also is not supported in this untimed allocator). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="asynchronous_events"></a> <a class="anchor" id="description.asynchronous_events"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Asynchronous Events: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Allocation methods in this protocol anticipate the possible occurrence of an "asynchronous event" (AE) during execution. A common example of an AE is a Unix signal, but note that a specific Unix signal, if not detected or implemented, <em>may</em> not result in an AE. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This interface cannot fully specify either the nature of or the behavior resulting from an AE, but certain restrictions can be (and are) imposed. By default, AEs are either ignored or, if that is not possible, cause an error. At the user's option, however, a concrete implementation can be authorized to return, if such occurrence is detected, with an "interrupted" status (leaving the allocator unaffected) upon the occurrence of an AE. Such authorizations are made explicitly by incorporating into the optional (trailing) integer <code>flags</code> argument to a method call the <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code> value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The purpose of the <code><a class="el" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a></code> protocol is to isolate the act of requesting a connection from details such as to whom the connection will be to and which side initiated the connection. In this example we will consider both the Server and Client sides of a <code>my_Tick</code> reporting service. Since each side of this service could potentially be a library component, we do not want to "bake" into either side the details of how connections will be established. It is sufficient that, when a tick needs to be sent or received, a channel is obtained, the tick is transmitted, and the channel is returned to its allocator. Note that this example serves to illustrate the use of the <code><a class="el" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a></code> and does not represent production-quality software. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Tick {
      <span class="keywordtype">char</span>   d_name[5];
      <span class="keywordtype">double</span> d_bestBid;
      <span class="keywordtype">double</span> d_bestOffer;

    <span class="keyword">public</span>:
      my_Tick() { }
      my_Tick(<span class="keyword">const</span> <span class="keywordtype">char</span> *ticker);
      my_Tick(<span class="keyword">const</span> <span class="keywordtype">char</span> *ticker, <span class="keywordtype">double</span> bestBid, <span class="keywordtype">double</span> bestOffer);
      ~my_Tick() { assert(d_bestBid &gt; 0); };

      <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="namespacebbldc.html#ac8267f245d1e34795846545f712d0f47">maxSupportedBdexVersion</a>(<span class="keywordtype">int</span> versionSelector) { <span class="keywordflow">return</span> 1; }

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version) <span class="keyword">const</span>;
          <span class="comment">// Write this value to the specified output &#39;stream&#39; using the</span>
          <span class="comment">// specified &#39;version&#39; format, and return a reference to &#39;stream&#39;.</span>
          <span class="comment">// If &#39;stream&#39; is initially invalid, this operation has no effect.</span>
          <span class="comment">// If &#39;version&#39; is not supported, &#39;stream&#39; is invalidated but</span>
          <span class="comment">// otherwise unmodified.  Note that &#39;version&#39; is not written to</span>
          <span class="comment">// &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for more</span>
          <span class="comment">// information on BDEX streaming of value-semantic types and</span>
          <span class="comment">// containers.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebbldc.html#a7fd2d27c8ca153888e33f4c09f0fd913">bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version);
          <span class="comment">// Assign to this object the value read from the specified input</span>
          <span class="comment">// &#39;stream&#39; using the specified &#39;version&#39; format, and return a</span>
          <span class="comment">// reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this</span>
          <span class="comment">// operation has no effect.  If &#39;version&#39; is not supported, this</span>
          <span class="comment">// object is unaltered and &#39;stream&#39; is invalidated but otherwise</span>
          <span class="comment">// unmodified.  If &#39;version&#39; is supported but &#39;stream&#39; becomes</span>
          <span class="comment">// invalid during this operation, this object has an undefined, but</span>
          <span class="comment">// valid, state.  Note that no version is read from &#39;stream&#39;.  See</span>
          <span class="comment">// the &#39;bslx&#39; package-level documentation for more information on</span>
          <span class="comment">// BDEX streaming of value-semantic types and containers.</span>

      <span class="keywordtype">void</span> <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(bsl::ostream&amp; stream) <span class="keyword">const</span>;
  };

  my_Tick::my_Tick(<span class="keyword">const</span> <span class="keywordtype">char</span> *ticker)
  : d_bestBid(0)
  , d_bestOffer(0)
  {
     snprintf(d_name, <span class="keyword">sizeof</span> d_name, <span class="stringliteral">&quot;%s&quot;</span>, ticker);
  }

  my_Tick::my_Tick(<span class="keyword">const</span> <span class="keywordtype">char</span> *ticker, <span class="keywordtype">double</span> bestBid, <span class="keywordtype">double</span> bestOffer)
  : d_bestBid(bestBid)
  , d_bestOffer(bestOffer)
  {
      snprintf(d_name, <span class="keyword">sizeof</span> d_name, <span class="stringliteral">&quot;%s&quot;</span>, ticker);
  }

  <span class="keywordtype">void</span> <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">my_Tick::print</a>(bsl::ostream&amp; stream)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      stream &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; d_name &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; d_bestBid &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; d_bestOffer
             &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; endl;
  }

  <span class="keyword">inline</span>
  bsl::ostream&amp; <a class="code" href="namespacebalb.html#a777d713a1c54d1359c8cb8144cc50b7a">operator&lt;&lt;</a>(bsl::ostream&amp; stream, <span class="keyword">const</span> my_Tick&amp; tick)
  {
      tick.print(stream);
      <span class="keywordflow">return</span> stream;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">my_Tick::bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">switch</span> (version) {
        <span class="keywordflow">case</span> 1: {
          stream.putString(d_name);
          stream.putFloat64(d_bestBid);
          stream.putFloat64(d_bestOffer);
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>: {
          stream.invalidate();
        } <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">return</span> stream;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebbldc.html#a7fd2d27c8ca153888e33f4c09f0fd913">my_Tick::bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)
  {
      <span class="keywordflow">switch</span> (version) {
        <span class="keywordflow">case</span> 1: {
          <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> temp1;
          stream.getString(temp1);
          <span class="keywordtype">int</span> maxLen = <span class="keyword">sizeof</span> d_name - 1;  <span class="comment">// the valid name length</span>
          <span class="keywordtype">int</span> len    = temp1.<a class="code" href="group__bslstl__string.html#ga3c33f63f9d195be7499bd2f7cdb085ff">length</a>();
          <span class="keywordflow">if</span> (len &lt; maxLen) {
              strcpy(d_name, temp1.<a class="code" href="group__bslstl__string.html#gae8d40a93bd2ebc7ae696c6f63b3995c9">c_str</a>());
          }
          <span class="keywordflow">else</span> {
              strncpy(d_name, temp1.<a class="code" href="group__bslstl__string.html#gae8d40a93bd2ebc7ae696c6f63b3995c9">c_str</a>(), len);
              d_name[len] = 0;
          }
          stream.getFloat64(d_bestBid);
          stream.getFloat64(d_bestOffer);
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>: {
          stream.invalidate();
        } <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">return</span> stream;
  }
</pre></div><br/>
<br/>
 Let's also assume that we have a function that knows how to print platform neutral encodings of type <code>my_Tick</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> myPrintTick(bsl::ostream&amp; stream, <span class="keyword">const</span> <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> len)
      <span class="comment">// Print the value of the specified &#39;buffer&#39; interpreted as a</span>
      <span class="comment">// BDEX byte-stream representation of a &#39;my_Tick&#39; value, to the</span>
      <span class="comment">// specified &#39;stream&#39; or report an error to &#39;stream&#39; if &#39;buffer&#39; is</span>
      <span class="comment">// determined *not* to hold an encoding of a valid &#39;my_Tick&#39; value.</span>
  {
      my_Tick tick;
      <a class="code" href="classbslx_1_1ByteInStream.html">bslx::ByteInStream</a> input(buffer, len);
      input &gt;&gt; tick;

      stream &lt;&lt; tick;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="server_side"></a> <a class="anchor" id="usage.server_side"></a> <a class="anchor" id="description.usage.server_side"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Server Side: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Let's assume that we have a function that knows how to print platform neutral encodings of type <code>my_Tick</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #define VERSION_SELECTOR 20140601</span>
<span class="preprocessor"></span>
  <span class="keyword">static</span> <span class="keywordtype">int</span> calculateMyTickMessageSize()
      <span class="comment">// Calculate and return the number of bytes in a BDEX byte-stream</span>
      <span class="comment">// encoding of a (dummy) &#39;my_Tick&#39; value (called just once, see below).</span>
  {
      my_Tick dummy;
      <a class="code" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a> bos(VERSION_SELECTOR);
      bos &lt;&lt; dummy;
      <span class="keywordflow">return</span> bos.length();
  }

  <span class="keyword">static</span> <span class="keywordtype">int</span> myTickMessageSize()
      <span class="comment">// Return the number of bytes in a BDEX byte-stream encoding of a</span>
      <span class="comment">// &#39;my_Tick&#39; value without creating a runtime-initialized file-scope</span>
      <span class="comment">// static variable (which is link-order dependent).</span>
  {
      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> MESSAGE_SIZE = calculateMyTickMessageSize();
      <span class="keywordflow">return</span> MESSAGE_SIZE;
  }
</pre></div><br/>
<br/>
 The following class illustrates how we might implement a tick-reporter server using just the <code><a class="el" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a></code> and <code><a class="el" href="classbtlsc_1_1Channel.html">btlsc::Channel</a></code> protocols. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_TickReporter {
      <span class="comment">// This class implements a server that accepts connections, extracts</span>
      <span class="comment">// from each connection a single &#39;my_Tick&#39; value, and reports that</span>
      <span class="comment">// value to a console stream.  Both the acceptor and console stream</span>
      <span class="comment">// are supplied at construction.</span>

      <a class="code" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a> *d_acceptor_p;  <span class="comment">// incoming connections</span>
      bsl::ostream&amp;            d_console;     <span class="comment">// where to put tick info</span>

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      my_TickReporter(<span class="keyword">const</span> my_TickReporter&amp;);
      my_TickReporter&amp; operator=(<span class="keyword">const</span> my_TickReporter&amp;);

    <span class="keyword">public</span>:
      my_TickReporter(bsl::ostream&amp;            console,
                      <a class="code" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a> *acceptor);
          <span class="comment">// Create a synchronous tick-reporter using the specified</span>
          <span class="comment">// &#39;acceptor&#39; to establish incoming client connections, each</span>
          <span class="comment">// transmitting a single &#39;my_Tick&#39; value; write these values to</span>
          <span class="comment">// the specified &#39;console&#39; stream.  If the &#39;acceptor&#39; is idle for</span>
          <span class="comment">// more than five minutes, print a message to the &#39;console&#39; stream</span>
          <span class="comment">// supplied at construction and continue.  To guard against</span>
          <span class="comment">// malicious clients, a connection that does not produce a tick</span>
          <span class="comment">// value within one minute will be summarily dropped.</span>

      ~my_TickReporter();
          <span class="comment">// Destroy this server object.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">int</span> reportTicker();
          <span class="comment">// Call &#39;d_acceptor_p&#39;s &#39;allocate&#39; to establish a channel.</span>
  };

  my_TickReporter::my_TickReporter(bsl::ostream&amp;            console,
                                   <a class="code" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a> *acceptor)
  : d_console(console)
  , d_acceptor_p(acceptor)
  {
      assert(&amp;d_console);
      assert(d_acceptor_p);
  }

  my_TickReporter::~my_TickReporter()
  {
      assert(&amp;d_console);
      assert(d_acceptor_p);
  }

  <span class="keywordtype">int</span> my_TickReporter::reportTicker()
  {
      <span class="keywordtype">int</span> status = 0;

      <span class="keywordflow">while</span> (1) {
          <a class="code" href="classbtlsc_1_1Channel.html">btlsc::Channel</a> *newChannel = d_acceptor_p-&gt;allocate(&amp;status);

          <span class="keywordflow">if</span> (newChannel) {     <span class="comment">// Successfully created a connection.</span>
              <span class="keyword">const</span> <span class="keywordtype">int</span> numBytes = ::myTickMessageSize();

              <span class="keyword">const</span> <span class="keywordtype">char</span> *buffer = 0;
              <span class="keywordtype">int</span> ret = newChannel-&gt;<a class="code" href="classbtlsc_1_1Channel.html#a25814ffdbbe699bf33af793c701f233f">bufferedRead</a>(&amp;status,
                                                 &amp;buffer,
                                                 numBytes);
              <span class="keywordflow">if</span> (0 &gt;= ret) {
                  d_console &lt;&lt; <span class="stringliteral">&quot;Error: The read operation timeout &quot;</span>
                               <span class="stringliteral">&quot;on this channel.&quot;</span>
                            &lt;&lt; bsl::endl;
                  d_acceptor_p-&gt;deallocate(newChannel);
              }
              <span class="keywordflow">else</span> {  <span class="comment">// Read successfully.</span>
                  ::myPrintTick(d_console, buffer, numBytes);
                  d_acceptor_p-&gt;deallocate(newChannel);
              }
          }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status &gt; 0) {   <span class="comment">// Interrupted by unspecified event.</span>
              assert(0); <span class="comment">// Impossible, &quot;async interrupts&quot; not authorized.</span>
          }
          <span class="keywordflow">else</span> {         <span class="comment">// Allocation operation is unable to succeed.</span>
              assert(status &lt; 0);

              d_console &lt;&lt; <span class="stringliteral">&quot;Error: The channel allocator is not working now.&quot;</span>
                        &lt;&lt; bsl::endl;
              assert(0);
          }
      }
  }
</pre></div><br/>
<br/>
 The following is the server driver, which first creates supporting objects to construct the <code>reporter</code>, and then invokes <code>reportTicker</code> of the <code>reporter</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[])
  {
      <span class="keyword">enum</span> { DEFAULT_PORT = 5000 };

      <span class="keyword">const</span> <span class="keywordtype">int</span> portNumber = argc &gt; 1 ? atoi(argv[1]) : DEFAULT_PORT;

      <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> address(btlso::IPv4Address::ANY, portNumber);
      btlso::Tcpipv4StreamSocketFactory sf;      <span class="comment">// concrete factory</span>
      btlsos::CbChannelAcceptor acceptor(address, &amp;sf);

      <span class="keywordflow">if</span> (acceptor.<a class="code" href="classbtlsc_1_1CbChannelAllocator.html#af1470913f03f57b1a88a3a91c1992b13">isInvalid</a>()) {
           bsl::cout &lt;&lt; <span class="stringliteral">&quot;Error: Unable to create acceptor.&quot;</span> &lt;&lt; bsl::endl;
           <span class="keywordflow">return</span> -1;                                               <span class="comment">// RETURN</span>
      }

      my_TickReporter reporter(bsl::cout, &amp;acceptor);
      reporter.reportTicker();
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="client_side"></a> <a class="anchor" id="usage.client_side"></a> <a class="anchor" id="description.usage.client_side"></a> <a class="anchor" id="3.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Client Side: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In order to use this <code>my_Tick</code> reporting service, clients will need to know where such a service resides and how to establish such connections on demand. We will use the <code><a class="el" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a></code> protocol to abstract those details out of the stable software that generates (or forwards) ticks. For the purposes of this example, let's assume that ticks are generated in some ASCII format and arrive in fixed size chunks (e.g., 80 bytes) from a separate process. The client will ask the "allocator" instance for a new channel to send each tick until all ticks are sent. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span>
  <span class="keywordtype">int</span> parseTick(my_Tick *result, <span class="keyword">const</span> <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> numBytes)
      <span class="comment">// Parse a tick value from the specified input &#39;buffer&#39; of the</span>
      <span class="comment">// specified &#39;numBytes&#39; and load that value into the specified</span>
      <span class="comment">// &#39;result&#39;.  Return 0 on success, and a non-zero value (with no effect</span>
      <span class="comment">// on &#39;result&#39;) otherwise.  The behavior is undefined unless</span>
      <span class="comment">// &#39;0 &lt;= numBytes&#39;.</span>
  {
      <span class="comment">// ...</span>

      <span class="keywordflow">return</span> 0;
  }

  <span class="keyword">class </span>my_TickerplantSimulator {
      <span class="comment">// Accept raw tick values in ASCII sent as fixed-sized packets via a</span>
      <span class="comment">// single &#39;btlsc::Channel&#39; and send them synchronously one by one to a</span>
      <span class="comment">// peer (or similar peers) connected via channels provided via a</span>
      <span class="comment">// &#39;btlsc::ChannelAllocator&#39;.  Both the output channel allocator and</span>
      <span class="comment">// the input channel are supplied at construction.</span>

      <span class="keyword">enum</span> { MAX_PARSER_ERRORS = 3 };

      <a class="code" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a> *d_connector_p;       <span class="comment">// outgoing connections</span>
      <a class="code" href="classbtlsc_1_1Channel.html">btlsc::Channel</a>          *d_input_p;           <span class="comment">// incoming packets</span>
      bsl::ostream&amp;            d_console;           <span class="comment">// where to write errors</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span>                d_inputSize;         <span class="comment">// input packet size</span>
      <span class="keywordtype">int</span>                      d_parserErrorCount;  <span class="comment">// consecutive errors</span>

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      my_TickerplantSimulator(<span class="keyword">const</span> my_TickerplantSimulator&amp;);
      my_TickerplantSimulator&amp; operator=(<span class="keyword">const</span> my_TickerplantSimulator&amp;);

    <span class="keyword">public</span>:
      my_TickerplantSimulator(bsl::ostream&amp;            console,
                              <a class="code" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a> *connector,
                              <a class="code" href="classbtlsc_1_1Channel.html">btlsc::Channel</a>          *input,
                              <span class="keywordtype">int</span>                      inputSize);
          <span class="comment">// Create a non-blocking ticker-plant simulator using the</span>
          <span class="comment">// specified &#39;input&#39; channel to read ASCII tick records of the</span>
          <span class="comment">// specified &#39;inputSize&#39; and convert each record to a &#39;My_Tick&#39;</span>
          <span class="comment">// structure; each tick value is sent synchronously to a peer via a</span>
          <span class="comment">// distinct channel obtained from the specified &#39;connector&#39;,</span>
          <span class="comment">// reporting any errors to the specified &#39;console&#39;.  If &#39;connector&#39;</span>
          <span class="comment">// fails or is unable to succeed after 30 seconds, or if</span>
          <span class="comment">// transmission itself exceeds 10 seconds, display a message on</span>
          <span class="comment">// &#39;console&#39; and abort the transmission.  If three successive reads</span>
          <span class="comment">// of the input channel fail to produce a valid ticks, invalidate</span>
          <span class="comment">// the channel and shut down this simulator.  The behavior is</span>
          <span class="comment">// undefined unless &#39;0 &lt; inputSize&#39;.</span>

      <span class="keywordtype">int</span> sendTicker();
          <span class="comment">// Build &#39;My_Tick&#39; objects by reading from channel of &#39;d_input_p&#39;</span>
          <span class="comment">// and send the built tick, if it is valid, to the peer.  Return 0</span>
          <span class="comment">// on success, and a negative value otherwise.</span>

      ~my_TickerplantSimulator();
          <span class="comment">// Destroy this simulator object.</span>
  };

  my_TickerplantSimulator::my_TickerplantSimulator(
                                          bsl::ostream&amp;            console,
                                          <a class="code" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a> *connector,
                                          <a class="code" href="classbtlsc_1_1Channel.html">btlsc::Channel</a>          *input,
                                          <span class="keywordtype">int</span>                      inputSize)
  : d_connector_p(connector)
  , d_console(console)
  , d_input_p(input)
  , d_inputSize(inputSize)
  , d_parserErrorCount(0)
  {
      assert(&amp;console);
      assert(connector);
      assert(input);
      assert(0 &lt; inputSize);
  }

  <span class="keywordtype">int</span> my_TickerplantSimulator::sendTicker()
  {
      <span class="keyword">const</span> <span class="keywordtype">char</span> *buffer    = 0;
      <span class="keywordtype">int</span>         status    = 0;
      <span class="keywordtype">int</span>         augStatus = 0;

      <span class="keywordflow">while</span> (0 &lt; d_input_p-&gt;bufferedRead(&amp;augStatus, &amp;buffer, d_inputSize)) {
          my_Tick tick;
          <span class="keywordflow">if</span> (0 == ::parseTick(&amp;tick, buffer, d_inputSize)) {
              d_parserErrorCount = 0;  <span class="comment">// Successfully parsed tick value.</span>

              <span class="comment">// Initiate a non-blocking  allocate operation.</span>

              <a class="code" href="classbtlsc_1_1Channel.html">btlsc::Channel</a> *newChannel = d_connector_p-&gt;allocate(&amp;status);
              <span class="keywordflow">if</span> (0 == newChannel) {
                  d_console &lt;&lt; <span class="stringliteral">&quot;Error: Unable to install connect operation.&quot;</span>
                            &lt;&lt; bsl::endl;
              }
              <span class="keywordflow">else</span> {
                  <a class="code" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a> bos(VERSION_SELECTOR);
                  bos &lt;&lt; tick;
                  <span class="keywordtype">int</span> msgSize = bos.length();
                  <span class="keywordflow">if</span> (0 &gt;= newChannel-&gt;<a class="code" href="classbtlsc_1_1Channel.html#a707d767695090653fcf137f77e934caa">write</a>(bos.data(), msgSize)) {
                       d_console &lt;&lt; <span class="stringliteral">&quot;Error: Unable even to register a write&quot;</span>
                                    <span class="stringliteral">&quot; operation on this channel.&quot;</span>
                                 &lt;&lt; bsl::endl;
                  }
                  d_connector_p-&gt;deallocate(newChannel);
              }
          }
          <span class="keywordflow">else</span> {  <span class="comment">// parsing error</span>
              d_console &lt;&lt; <span class="stringliteral">&quot;Error: Unable to parse tick data!&quot;</span> &lt;&lt; bsl::endl;

              ++d_parserErrorCount;

              <span class="keywordflow">if</span> (d_parserErrorCount &gt;= MAX_PARSER_ERRORS) {
                  d_console &lt;&lt; <span class="stringliteral">&quot;Reached maximum parser error limit;&quot;</span>
                               <span class="stringliteral">&quot; invalidating input channel.&quot;</span> &lt;&lt; bsl::endl;

                  d_input_p-&gt;invalidate();
              }
              <span class="keywordflow">else</span> {
                  d_console &lt;&lt; <span class="stringliteral">&quot;Continuing with next record.&quot;</span> &lt;&lt; bsl::endl;
              }
          }
      }

      <span class="keywordflow">if</span> (-1 == augStatus) {  <span class="comment">// EOF</span>
          <span class="keywordflow">return</span> 0;                                                 <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">else</span> {
          <span class="keywordflow">return</span> -1;                                                <span class="comment">// RETURN</span>
      }
  }

  my_TickerplantSimulator::~my_TickerplantSimulator()
  {
      assert(&amp;d_console);
      assert(d_connector_p);
      assert(0 &lt; d_inputSize);
      assert(0 &lt;= d_parserErrorCount);
      assert(d_parserErrorCount &lt;= MAX_PARSER_ERRORS);
  }
</pre></div><br/>
<br/>
 In order to make this <code>my_TickerplantSimulator</code> work, we will need to create those supporting objects first, then simply call <code>sendTicker</code> of the "simulator": <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[])
  {
      <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> DEFAULT_HOST = <span class="stringliteral">&quot;widget&quot;</span>;
      <span class="keyword">enum</span> { DEFAULT_PORT = 5000 };
      <span class="keyword">enum</span> { DEFAULT_SIZE = 80 };

      <span class="keyword">const</span> <span class="keywordtype">char</span> *hostName = argc &gt; 1 ? argv[1]       : DEFAULT_HOST;
      <span class="keyword">const</span> <span class="keywordtype">int</span> portNumber = argc &gt; 2 ? atoi(argv[2]) : DEFAULT_PORT;
      <span class="keyword">const</span> <span class="keywordtype">int</span> inputSize  = argc &gt; 3 ? atoi(argv[3]) : DEFAULT_SIZE;

      <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> address;
      <a class="code" href="structbtlso_1_1ResolveUtil.html#a797f7903638fd37e76bd39d9f7a43bb4">btlso::ResolveUtil&lt;btlso::IPv4Address&gt;::getAddress</a>(&amp;address, hostName);
      address.<a class="code" href="classbtlso_1_1IPv4Address.html#a0db9b6717cd8bd435caeeb46a9bbd818">setPortNumber</a>(portNumber);
      <a class="code" href="classbtlso_1_1InetStreamSocketFactory.html">btlso::InetStreamSocketFactory</a> sf;
      btlsos::CbChannelConnector connector(address, &amp;sf);

      my_TickerplantSimulator simulator(bsl::cout,
                                        &amp;connector,
                                        input,
                                        inputSize);
      assert(0 == simulator.sendTicker());

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 Please remember that these example code snippets are intended to illustrate the use of <code><a class="el" href="classbtlsc_1_1ChannelAllocator.html">btlsc::ChannelAllocator</a></code> and do not represent production-quality software. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:01 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
