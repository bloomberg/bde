<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslmt_threadutil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<h1>Component bslmt_threadutil<br/>
<small>
[<a class="el" href="group__bslmt.html">Package bslmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide platform-independent utilities related to threading.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslmt.html">bslmt</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslmt__threadutil.html#ga6d94665750b795929138ed7eb7f88b56">bslmt_ThreadFunction</a> )(void *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslmt__threadutil.html#ga730bddcc94d1a3cebc745dd23111f235">bslmt_KeyDestructorFunction</a> )(void *)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Creating a Simple Thread with Default Attributes</a> </li>
<li>
<a href="#3.2">Thread Identity</a> </li>
<li>
<a href="#3.3">Setting Thread Priorities</a> </li>
<li>
<a href="#3.4">Supported Clock-Types</a> </li>
<li>
<a href="#3.5">Usage</a> <ul>
<li>
<a href="#3.5.1">Example 1: Creating a Simple Thread with Default Attributes</a> </li>
<li>
<a href="#3.5.2">Example 2: Creating a Simple Thread with User-Specified Attributes</a> </li>
<li>
<a href="#3.5.3">Example 3: Setting Thread Priorities</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide platform-independent utilities related to threading. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbslmt_1_1ThreadUtil.html">bslmt::ThreadUtil</a> </td><td>namespace for portable thread management utilities  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslmt__threadattributes.html" title="Provide a description of the attributes of a thread.">Component bslmt_threadattributes</a>, <a class="el" href="group__bslmt__configuration.html" title="Provide utilities to allow configuration of values for BCE.">Component bslmt_configuration</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a utility <code>struct</code>, <code><a class="el" href="structbslmt_1_1ThreadUtil.html">bslmt::ThreadUtil</a></code>, that serves as a name space for a suite of pure functions to create threads, join them (make one thread block and wait for another thread to exit), manipulate thread handles, manipulate the current thread, and (on some platforms) access thread-local storage. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="creating_a_simple_thread_with_default_attributes"></a> <a class="anchor" id="description.creating_a_simple_thread_with_default_attributes"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Creating a Simple Thread with Default Attributes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Clients call <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create()</a></code> to create threads. Threads may be started using a "C" linkage function pointer (of a type defined by <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a01c7a6983e80799b2f5ed11471543dd1">bslmt::ThreadUtil::ThreadFunction</a></code>) and a <code>void</code> pointer to <code>userData</code> to be passed to the function; or an "invokable" object of parameterized type (any copy-constructible type on which <code>operator()</code> may be invoked). The invoked function becomes the main driver for the new thread; when it returns, the thread terminates. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_identity"></a> <a class="anchor" id="description.thread_identity"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Thread Identity: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A thread is identified by an object of the opaque type <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a></code>. A handle of this type is returned when a thread is created (using <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a></code>). A client can also retrieve a <code>Handle</code> for the "current" thread via the <code>self</code> method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> myHandle = <a class="code" href="structbslmt_1_1ThreadUtil.html#a3d53ab226de9b3171135cb5f77f8e14a">bslmt::ThreadUtil::self</a>();
</pre></div><br/>
<br/>
 Several thread manipulation functions in <code><a class="el" href="structbslmt_1_1ThreadUtil.html">bslmt::ThreadUtil</a></code> take a thread handle, or pointer to a thread handle, as an argument. To facilitate compatibility with existing systems and allow for non-portable operations, clients also have access to the <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a7756e09e893350902e8f1a1f74d4b853">bslmt::ThreadUtil::NativeHandle</a></code> type, which exposes the underlying, platform-specific thread identifier type: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbslmt_1_1ThreadUtil.html#a7756e09e893350902e8f1a1f74d4b853">bslmt::ThreadUtil::NativeHandle</a> myNativeHandle;
  myNativeHandle = <a class="code" href="structbslmt_1_1ThreadUtil.html#a6fc6d4a6ef865e719b7a4c50b19de845">bslmt::ThreadUtil::nativeHandle</a>();
</pre></div><br/>
<br/>
 Note that the returned native handle may not be a globally unique identifier for the thread, and, e.g., should not be converted to an integer identifier, or used as a key in a map. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="setting_thread_priorities"></a> <a class="anchor" id="description.setting_thread_priorities"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Setting Thread Priorities: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="structbslmt_1_1ThreadUtil.html">bslmt::ThreadUtil</a></code> allows clients to configure the priority of newly created threads by setting the <code>inheritSchedule</code>, <code>schedulingPolicy</code>, and <code>schedulingPriority</code> of a thread attributes object supplied to the <code>create</code> method. The range of legal values for <code>schedulingPriority</code> depends on both the platform and the value of <code>schedulingPolicy</code>, and can be obtained from the <code>getMinSchedulingPriority</code> and <code>getMaxSchedulingPriority</code> methods. Both <code>schedulingPolicy</code> and <code>schedulingPriority</code> are ignored unless <code>inheritSchedule</code> is <code>false</code> (the default value is <code>true</code>). Note that not only is effective setting of thread priorities workable on only some combinations of platforms and user privileges, but setting the thread policy and priority appropriately for one platform may cause thread creation to fail on another platform. Also note that an unset thread priority may be interpreted as being outside the valid range defined by <code>[ getMinSchedulingPriority(policy), getMaxSchedulingPriority(policy) ]</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment"> Platform      Restrictions
 ------------  --------------------------------------------------------------
 Solaris 5.10  None.

 Solaris 5.11  Spawning of threads fails <span class="keywordflow">if</span> <span class="stringliteral">&#39;schedulingPolicy&#39;</span> is
               <span class="stringliteral">&#39;BSLMT_SCHED_FIFO&#39;</span> or <span class="stringliteral">&#39;BSLMT_SCHED_RR&#39;</span>.  Note also that
               <span class="stringliteral">&#39;getMinSchedulingPriority&#39;</span> and <span class="stringliteral">&#39;getMaxSchedulingPriority&#39;</span>
               <span class="keywordflow">return</span> different values than on Solaris 5.10.  Thread
               priorities have so little effect on 5.11 that it is barely
               detectable.

 AIX           For non-privileged clients, spawning of threads fails <span class="keywordflow">if</span>
               <span class="stringliteral">&#39;schedulingPolicy&#39;</span> is <span class="stringliteral">&#39;BSLMT_SCHED_FIFO&#39;</span> or <span class="stringliteral">&#39;BSLMT_SCHED_RR&#39;</span>.

 Linux         Non-privileged clients *can* *not* make effective use of
               thread priorities -- spawning of threads fails <span class="keywordflow">if</span>
               <span class="stringliteral">&#39;schedulingPolicy&#39;</span> is <span class="stringliteral">&#39;BSLMT_SCHED_FIFO&#39;</span> or <span class="stringliteral">&#39;BSLMT_SCHED_RR&#39;</span>,
               and <span class="stringliteral">&#39;getMinSchedulingPriority == getMaxSchedulingPriority&#39;</span> <span class="keywordflow">if</span>
               the policy has any other value.

 HPUX          Non-privileged clients *can* *not* make effective use of
               thread priorities -- spawning of threads fails <span class="keywordflow">if</span>
               <span class="stringliteral">&#39;inheritSchedule&#39;</span> is <span class="stringliteral">&#39;false&#39;</span>.

 Darwin        Non-privileged clients *can* *not* make effective use of
               thread priorities -- there is no observable difference in
               urgency between high priority and low priority threads.
               Spawning of threads does succeed, however, <span class="keywordflow">for</span> all scheduling
               policies.

 Windows       Clients *can* *not* make effective use of thread priorities --
               <span class="stringliteral">&#39;schedulingPolicy&#39;</span>, <span class="stringliteral">&#39;schedulingPriority&#39;</span>, and
               <span class="stringliteral">&#39;inheritSchedule&#39;</span> are ignored <span class="keywordflow">for</span> all clients.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="supported_clock-types"></a> <a class="anchor" id="description.supported_clock-types"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Supported Clock-Types: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The component <code><a class="el" href="structbsls_1_1SystemClockType.html">bsls::SystemClockType</a></code> supplies the enumeration indicating the system clock on which timeouts supplied to other methods should be based. If the clock type indicated at construction is <code><a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56ba4b4f6a6781cc76138225ba163ed717a8">bsls::SystemClockType::e_REALTIME</a></code>, the timeout should be expressed as an absolute offset since 00:00:00 UTC, January 1, 1970 (which matches the epoch used in <code>bsls::SystemTime::now(bsls::SystemClockType::e_REALTIME)</code>. If the clock type indicated at construction is <code><a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56ba28811e3a40d5ac56aeed9bd363c12201">bsls::SystemClockType::e_MONOTONIC</a></code>, the timeout should be expressed as an absolute offset since the epoch of this clock (which matches the epoch used in <code>bsls::SystemTime::now(bsls::SystemClockType::e_MONOTONIC)</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates the intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_creating_a_simple_thread_with_default_attributes"></a> <a class="anchor" id="usage.example_1~3A_creating_a_simple_thread_with_default_attributes"></a> <a class="anchor" id="description.usage.example_1~3A_creating_a_simple_thread_with_default_attributes"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.5.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating a Simple Thread with Default Attributes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we create a thread using the default attribute settings. Upon creation, the thread executes the user-supplied C-linkage function <code>myThreadFunction</code> that counts 5 seconds before terminating: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create a function that will run in the spawned thread: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *myThreadFunction(<span class="keywordtype">void</span> *)
      <span class="comment">// Print to standard output &quot;Another second has passed&quot; every second</span>
      <span class="comment">// for five seconds, and return 0.</span>
  {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) {
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a4e6a840e495c3afa38474a2dcc073286">bslmt::ThreadUtil::microSleep</a>(0, 1);
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Another second has passed.&quot;</span> &lt;&lt; bsl::endl;
      }
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 Now, we show how to create and join the thread. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>After creating the thread, the <code>main</code> routine <em>joins</em> the thread, which, in effect, causes <code>main</code> to wait for execution of <code>myThreadFunction</code> to complete, and guarantees that the output from <code>main</code> will follow the last output from the user-supplied function: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main()
  {
      <a class="code" href="structbslmt_1_1Configuration.html#a5514518a9828c4868698b04e51b1b0a0">bslmt::Configuration::setDefaultThreadStackSize</a>(
                  <a class="code" href="structbslmt_1_1Configuration.html#ad3fecbd620d00ca0bdc3c552a21ea847">bslmt::Configuration::recommendedDefaultThreadStackSize</a>());

      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> handle;

      <a class="code" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> attr;
      attr.<a class="code" href="classbslmt_1_1ThreadAttributes.html#a968796a660b323e2c72fd365323d50c4">setStackSize</a>(1024 * 1024);

      <span class="keywordtype">int</span> rc = <a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;handle, attr, myThreadFunction, 0);
      assert(0 == rc);

      <a class="code" href="structbslmt_1_1ThreadUtil.html#a6f7c5d60c974ba25866e5e881aec98be">bslmt::ThreadUtil::yield</a>();

      rc = <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(handle);
      assert(0 == rc);

      bsl::cout &lt;&lt; <span class="stringliteral">&quot;A three second interval has elapsed\n&quot;</span>;

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 Finally, the output of this program is: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Another second has passed.
  Another second has passed.
  Another second has passed.
  <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> three second interval has elapsed.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_creating_a_simple_thread_with_user-specified_attributes"></a> <a class="anchor" id="usage.example_2~3A_creating_a_simple_thread_with_user-specified_attributes"></a> <a class="anchor" id="description.usage.example_2~3A_creating_a_simple_thread_with_user-specified_attributes"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.5.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Creating a Simple Thread with User-Specified Attributes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we will choose to override the default thread attribute values. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The attributes of a thread can be specified explicitly by supplying a <code><a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a></code> object to the <code>create</code> method. For instance, we could specify a smaller stack size for a thread to conserve system resources if we know that we will require not require the platform's default stack size. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define our thread function, noting that it doesn't need much stack space: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *mySmallStackThreadFunction(<span class="keywordtype">void</span> *threadArg)
      <span class="comment">// Initialize a small object on the stack and do some work.</span>
  {
      <span class="keywordtype">char</span> *initValue = (<span class="keywordtype">char</span> *)threadArg;
      <span class="keywordtype">char</span> Small[8];
      bsl::memset(&amp;Small[0], *initValue, 8);
      <span class="comment">// do some work ...</span>
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 Finally, we show how to create a detached thread running the function just created with a small stack size: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> createSmallStackSizeThread()
      <span class="comment">// Create a detached thread with a small stack size and perform some</span>
      <span class="comment">// work.</span>
  {
      <span class="keyword">enum</span> { k_STACK_SIZE = 16384 };
      <a class="code" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> attributes;
      attributes.<a class="code" href="classbslmt_1_1ThreadAttributes.html#afb35bfec602df986524a4e5dfd734aaa">setDetachedState</a>(
                             <a class="code" href="classbslmt_1_1ThreadAttributes.html#a660f00e1f7a7a5b30cc05956f5374110ad5c4c452ec52d312ac3c0e7c65510afb" title="create a non-joinable thread">bslmt::ThreadAttributes::e_CREATE_DETACHED</a>);
      attributes.<a class="code" href="classbslmt_1_1ThreadAttributes.html#a968796a660b323e2c72fd365323d50c4">setStackSize</a>(k_STACK_SIZE);

      <span class="keywordtype">char</span> initValue = 1;
      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> handle;
      <span class="keywordtype">int</span> status = <a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;handle,
                                            attributes,
                                            mySmallStackThreadFunction,
                                            &amp;initValue);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_setting_thread_priorities"></a> <a class="anchor" id="usage.example_3~3A_setting_thread_priorities"></a> <a class="anchor" id="description.usage.example_3~3A_setting_thread_priorities"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.5.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Setting Thread Priorities: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example we demonstrate creating 3 threads with different priorities. We use the <code>convertToSchedulingPriority</code> function to translate a normalized, floating-point priority in the range <code>[ 0.0, 1.0 ]</code> to an integer priority in the range <code>[ getMinSchedulingPriority, getMaxSchedulingPriority ]</code> to set the <code>schedulingPriority</code> attribute. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> runSeveralThreads()
      <span class="comment">// Create 3 threads with different priorities and then wait for them</span>
      <span class="comment">// all to finish.</span>
  {
      <span class="keyword">enum</span> { k_NUM_THREADS = 3 };

      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> handles[k_NUM_THREADS];
      <a class="code" href="group__bslmt__threadutil.html#ga6d94665750b795929138ed7eb7f88b56">bslmt_ThreadFunction</a> functions[k_NUM_THREADS] = {
                                                MostUrgentThreadFunction,
                                                FairlyUrgentThreadFunction,
                                                LeastUrgentThreadFunction };
      <span class="keywordtype">double</span> priorities[k_NUM_THREADS] = { 1.0, 0.5, 0.0 };

      <a class="code" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> attributes;
      attributes.<a class="code" href="classbslmt_1_1ThreadAttributes.html#a993eb551846f715665c61becc157b911">setInheritSchedule</a>(<span class="keyword">false</span>);
      <span class="keyword">const</span> <a class="code" href="classbslmt_1_1ThreadAttributes.html#a236ea307f690b2a13d387cc90e287cf6">bslmt::ThreadAttributes::SchedulingPolicy</a> policy =
                                  bslmt::ThreadAttributes::e_SCHED_OTHER;
      attributes.<a class="code" href="classbslmt_1_1ThreadAttributes.html#ab6bb4351bcf38e981cef4749b551c82e">setSchedulingPolicy</a>(policy);

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; k_NUM_THREADS; ++i) {
          attributes.<a class="code" href="classbslmt_1_1ThreadAttributes.html#ad91b46b398d89663767914fa7f546785">setSchedulingPriority</a>(
               <a class="code" href="structbslmt_1_1ThreadUtil.html#abf87f34e8ce727a1342f05476a42427b">bslmt::ThreadUtil::convertToSchedulingPriority</a>(policy,
                                                             priorities[i]));
          <span class="keywordtype">int</span> rc = <a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;handles[i],
                                             attributes,
                                             functions[i], 0);
          assert(0 == rc);
      }

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; k_NUM_THREADS; ++i) {
          <span class="keywordtype">int</span> rc = <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(handles[i]);
          assert(0 == rc);
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga6d94665750b795929138ed7eb7f88b56"></a><!-- doxytag: member="bslmt_threadutil.h::bslmt_ThreadFunction" ref="ga6d94665750b795929138ed7eb7f88b56" args=")(void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(* <a class="el" href="group__bslmt__threadutil.html#ga6d94665750b795929138ed7eb7f88b56">bslmt_ThreadFunction</a>)(void *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>bslmt_ThreadFunction</code> is an alias for a function type taking a single <code>void</code> pointer argument and returning <code>void *</code>. Such functions are suitable to be specified as thread entry-point functions to <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a></code>. Note that <code>create</code> also accepts any invokable C++ "functor" object. </p>

</div>
</div>
<a class="anchor" id="ga730bddcc94d1a3cebc745dd23111f235"></a><!-- doxytag: member="bslmt_threadutil.h::bslmt_KeyDestructorFunction" ref="ga730bddcc94d1a3cebc745dd23111f235" args=")(void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__bslmt__threadutil.html#ga730bddcc94d1a3cebc745dd23111f235">bslmt_KeyDestructorFunction</a>)(void *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>bslmt_KeyDestructorFunction</code> is an alias for a function type taking a single <code>void</code> pointer argument and returning <code>void</code>. Such functions are suitable to be specified as thread-specific key destructor functions to <code><a class="el" href="structbslmt_1_1ThreadUtil.html#aa05eafd599b7c839ceb1042997a96fdd">bslmt::ThreadUtil::createKey</a></code>. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:01 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
