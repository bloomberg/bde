<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bsltf_templatetestfacility Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bsltf_templatetestfacility<br/>
<small>
[<a class="el" href="group__bsltf.html">Package bsltf</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide utilities to help with testing templates.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsltf.html">bsltf</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Macros</a> </li>
<li>
<a href="#4">Description</a> <ul>
<li>
<a href="#4.1"><code>TemplateTestFacility</code></a> </li>
<li>
<a href="#4.2">Macros and Test Types</a> </li>
<li>
<a href="#4.3">Usage</a> <ul>
<li>
<a href="#4.3.1">Example 1: Using the <code>BSLTF_TEMPLATETESTFACILITY_RUN_EACH_TYPE</code> Macro</a> </li>
<li>
<a href="#4.3.2">Example 2: Writing a Type Independent Test Driver</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide utilities to help with testing templates. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbsltf_1_1TemplateTestFacility.html">bsltf::TemplateTestFacility</a> </td><td>namespace for template-testing utilities  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="macros"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>BSLTF_TEMPLATETESTFACILITY_RUN_EACH_TYPE(CLASS, METHOD, TYPE...) </td><td>run all  </td></tr>
<tr>
<td>BSLTF_TEMPLATETESTFACILITY_TEST_TYPES_PRIMITIVE </td><td>list of primitive types  </td></tr>
<tr>
<td>BSLTF_TEMPLATETESTFACILITY_TEST_TYPES_USER_DEFINED </td><td>list user types  </td></tr>
<tr>
<td>BSLTF_TEMPLATETESTFACILITY_TEST_TYPES_REGULAR </td><td>list of typical types  </td></tr>
<tr>
<td>BSLTF_TEMPLATETESTFACILITY_TEST_TYPES_AWKWARD </td><td>list of atypical types  </td></tr>
<tr>
<td>BSLTF_TEMPLATETESTFACILITY_TEST_TYPES_ALL </td><td>list all <code>bslmf</code> types  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bsltf__simpletesttype.html" title="Provide a non-allocating test class without type traits.">Component bsltf_simpletesttype</a>, <a class="el" href="group__bslstl__map.html" title="Provide an STL-compliant map class.">Component bslstl_map</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="4"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>When testing a container template having a type parameter, we need to ensure that the template supports its contractually specified categories of parameter types. The <code>bsltf</code> package provides a representative set of types intended for testing that can be used as template parameters for doing this kind of verification. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Creating a separate test for each category of types supported by a template would be cumbersome. Instead, writing a single templatized test is usually preferable. Unfortunately, different types often require different syntaxes for constructing an object and getting an object's value. This inconsistency makes writing generic code rather difficult. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a solution with a utility <code>struct</code>, <code>TemplateTestFacility</code>, that defines two class method templates, <code>create</code> and <code>getIdentifier</code>, that respectively have consistent syntaxes for creating objects and getting a integer value representing the state of objects of a parameterized type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component also provides a macro, <code>BSLTF_TEMPLATETESTFACILITY_RUN_EACH_TYPE</code>, that serves as a convenient way to instantiate and invoke a template (for testing) having a type parameter for a specified list of types. In addition, this component provides a set of macros referring to commonly useful lists of types intended for testing that can be used as arguments to <code>BSLTF_TEMPLATETESTFACILITY_RUN_EACH_TYPE</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The utilities and macros provided by this component, along with the types defined in the <code>bsltf</code> package, are explained in more detail in the following sections. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="templatetestfacility"></a> <a class="anchor" id="description.templatetestfacility"></a> <a class="anchor" id="4.1"></a> </dd></dl>
<dl class="user"><dt><b>TemplateTestFacility: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>TemplateTestFacility</code> <code>struct</code> provides the following static (class) method templates to construct objects and get the states of objects of a supported parameterized type (supported types are those types intended for testing defined in the <code>bsltf</code> package): </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
<code>create</code>: Return an object of the parameterized <code>TYPE</code> whose value is uniquely associated with a specified integer identifier.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
<code>getIdentifier</code>: Return the integer identifier used to create a specified object of the parameterized <code>TYPE</code>.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="macros_and_test_types"></a> <a class="anchor" id="description.macros_and_test_types"></a> <a class="anchor" id="4.2"></a> </dd></dl>
<dl class="user"><dt><b>Macros and Test Types: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>BSLTF_TEMPLATETESTFACILITY_RUN_EACH_TYPE</code> macro instantiates a specified class template for a specified list of types and call a specified class method of each instantiation. The macro takes in arguments in the following order: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
The name of the class template to be instantiated  </li>
<li>
The name of the class method to be invoked  </li>
<li>
The names of the types for which the class template will be instantiated (up 20)  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component also defines a set of macros, each providing a list of types, that can be used as the last argument to <code>BSLTF_TEMPLATETESTFACILITY_RUN_EACH_TYPE</code>. The following is a brief synopsis of these macros (note that all macros names have the <code>BSLTF_TEMPLATETESTFACILITY_</code> prefix, which is omitted for layout efficiency): </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
<code>TEST_TYPES_PRIMITIVE</code>: list of primitive types  </li>
<li>
<code>TEST_TYPES_USER_DEFINED</code>: list of user-defined types  </li>
<li>
<code>TEST_TYPES_REGULAR</code>: list of typically used types  </li>
<li>
<code>TEST_TYPES_AWKWARD</code>: list of types with odd behaviors  </li>
<li>
<code>TEST_TYPES_ALL</code>: list of all of the types  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>BSLTF_TEMPLATETESTFACILITY_TEST_TYPES_PRIMITIVE</code> macro refers to a representative set of primivite types that are useful for testing: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Type                                Description
  ----                                -----------
  <span class="keywordtype">signed</span> <span class="keywordtype">char</span>                         <span class="keywordtype">signed</span> character

  <span class="keywordtype">size_t</span>                              <span class="keywordtype">signed</span> integral type

  TemplateTestFacility::ObjectPtr     pointer to an <span class="keywordtype">object</span>

  TemplateTestFacility::FunctionPtr   pointer to a function

  TemplateTestFacility::MethodPtr     pointer to a method
</pre></div><br/>
<br/>
 The <code>BSLTF_TEMPLATETESTFACILITY_TEST_TYPES_USER_DEFINED</code> macro refers to a representative set of user-defined types that are useful for testing (note that all types described here belong to the <code>bsltf</code> namespace, which is not explicitly qualified for layout efficiency): <br/>
<br/>
<div class="fragment"><pre class="fragment">  Type                                Description
  ----                                -----------
  EnumeratedTestType::Enum            an enumeration

  UnionTestType                       a <span class="keyword">union</span>

  SimpleTestType                      <span class="keyword">class </span>with no special traits defined

  AllocTestType                       class that allocates memory, defines
                                      the
                                      &#39;bslma::UsesBslmaAllocator&#39;
                                      trait, and ensures it is not bitwise
                                      moved

  BitwiseMoveableTestType             class that is bitwise-moveable and
                                      defines the
                                      &#39;bslmf::IsBitwiseMoveable&#39;
                                      trait

  AllocatingBitwiseMoveableTestType   class that allocates memory, is
                                      bitwisemoveable, and defines the
                                      &#39;bslma::UsesBslmaAllocator&#39;
                                      and &#39;bslmf::IsBitwiseMoveable&#39;
                                      traits

  NonTypicalOverloadsTestType         class that defines and assert on
                                      invocation of certain
                                      non-typically-overloaded operators
                                      (&#39;operator new&#39;, &#39;operator delete&#39;,
                                      &#39;operator&amp;&#39;) to ensure that they are
                                      not called
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>BSLTF_TEMPLATETESTFACILITY_TEST_TYPES_REGULAR</code> macro refers to the union of the types provided by <code>BSLTF_TEMPLATETESTFACILITY_TEST_TYPES_PRIMITIVE</code> and <code>BSLTF_TEMPLATETESTFACILITY_TEST_TYPES_USER_DEFINED</code>. These types are designed to work within the regular operating conditions of a typical template. Typically, a test driver for a template instantiates its tests (using the <code>BSLTF_TEMPLATETESTFACILITY_RUN_EACH_TYPE</code> macro) for all of the types refered by <code>BSLTF_TEMPLATETESTFACILITY_TEST_TYPES_REGULAR</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>BSLTF_TEMPLATETESTFACILITY_TEST_TYPES_AWKWARD</code> macro refers to a set of types that have certain attributes that make them unlikely to work for all of the operations of a template. Typically, not all methods of a template are instantiable with these types, so these types are most often used independently in tests explicitly designed for a (single) type. <br/>
<br/>
<div class="fragment"><pre class="fragment">  Type                                Description
  ----                                -----------
  NonAssignableTestType               <span class="keyword">class </span>having no assignment operator

  NonCopyConstructibleTestType        class having no copy constructor (Note
                                      that this class can not be created with
                                      &#39;TemplateTestFacility::create&#39; because
                                      the class method returns the newly
                                      constructed object by value.)

  NonDefaultConstructibleTestType     class having no default constructor

  NonEqualComparableTestType          class having no equality comparison
                                      operators
</pre></div><br/>
<br/>
 The <code>BSLTF_TEMPLATETESTFACILITY_TEST_TYPES_ALL</code> refers to all the test types provided in the <code>bsltf</code> package. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="4.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="4.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using the BSLTF_TEMPLATETESTFACILITY_RUN_EACH_TYPE Macro: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we demonstrate how to use <code>BSLTF_TEMPLATETESTFACILITY_RUN_EACH_TYPE</code> to call a class method of a template for a list of types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a <code>struct</code> template <code>TestTemplate</code> taking in a parameterized <code>TYPE</code> that has a class method, <code>printTypeName</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">struct </span>TestTemplate {
      <span class="comment">// This &#39;struct&#39; provides a namespace for a simple test method.</span>

      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> <span class="keywordtype">void</span> printTypeName();
          <span class="comment">// Prints the name of the parameterized &#39;TYPE&#39; to the console.</span>
  };

  <span class="keyword">template</span> &lt;&gt;
  <span class="keywordtype">void</span> TestTemplate&lt;int&gt;::printTypeName()
  {
      printf(<span class="stringliteral">&quot;int\n&quot;</span>);
  }

  <span class="keyword">template</span> &lt;&gt;
  <span class="keywordtype">void</span> TestTemplate&lt;char&gt;::printTypeName()
  {
      printf(<span class="stringliteral">&quot;char\n&quot;</span>);
  }

  <span class="keyword">template</span> &lt;&gt;
  <span class="keywordtype">void</span> TestTemplate&lt;double&gt;::printTypeName()
  {
      printf(<span class="stringliteral">&quot;double\n&quot;</span>);
  }
</pre></div><br/>
<br/>
 Now, we can instantiate the <code>TestTemplate</code> class for each of the types <code>int</code>, <code>char</code>, and <code>double</code>, and call the <code>printTypeName</code> class method of each instantiation using the <code>BSLTF_TEMPLATETESTFACILITY_RUN_EACH_TYPE</code> macro: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="bsltf__templatetestfacility_8h.html#af91c24c1f28b7db32bbe32ed4683dbf1">BSLTF_TEMPLATETESTFACILITY_RUN_EACH_TYPE</a>(TestTemplate,
                                           printTypeName,
                                           <span class="keywordtype">int</span>, <span class="keywordtype">char</span>, <span class="keywordtype">double</span>);
</pre></div><br/>
<br/>
 Finally, we observe the console output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span>
  <span class="keywordtype">char</span>
  <span class="keywordtype">double</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="4.3.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Writing a Type Independent Test Driver: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we demonstrate using the <code>TemplateTestFacility</code> <code>struct</code> and the macros provided by this component to test the default constructor and primary manipulator of a class template in the context of a typical BDE-style test driver. Note that a goal of the demonstrated test is to validate the class template with a broad range of types emulating those with which the template might be instantiated. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a simple class template, <code>MyNullableValue</code>, that we will later need to test: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>MyNullableValue {
      <span class="comment">// This (value-semantic) class template extends the parameterized</span>
      <span class="comment">// &#39;TYPE&#39; to include the notion of a &quot;null&quot; value.</span>

      <span class="comment">// DATA</span>
      TYPE d_value;     <span class="comment">// non-null value</span>
      <span class="keywordtype">bool</span> d_nullFlag;  <span class="comment">// flag to indicate if the value is null</span>

    <span class="keyword">public</span>:
      MyNullableValue()
          <span class="comment">// Create a &#39;MyNullableValue&#39; that initially has a value of null.</span>
      : d_nullFlag(true)
      {
      }

      <span class="keywordtype">bool</span> isNull() const
          <span class="comment">// Return &#39;true&#39; if this object is null, and &#39;false&#39; otherwise.</span>
      {
          <span class="keywordflow">return</span> d_nullFlag;
      }

      <span class="keywordtype">void</span> makeNull()
          <span class="comment">// Set this object to the null value.</span>
      {
          d_nullFlag = <span class="keyword">true</span>;
      }

      <span class="keyword">const</span> TYPE&amp; value()<span class="keyword"> const </span>{
          <span class="comment">// Return a reference providing non-modifiable access to the</span>
          <span class="comment">// underlying object of the parameterized &#39;TYPE&#39;.  The behavior is</span>
          <span class="comment">// undefined if the object is null.</span>
          <span class="keywordflow">return</span> d_value;
      }

      <span class="keywordtype">void</span> makeValue(<span class="keyword">const</span> TYPE&amp; value)
          <span class="comment">// Set the value of this object to be that of the specified &#39;value&#39;</span>
          <span class="comment">// of the parameterized &#39;TYPE&#39;.</span>
      {
          d_nullFlag = <span class="keyword">false</span>;
          d_value = value;
      }
  };
</pre></div><br/>
<br/>
 Then, we define some aliases for the micros that will be used by the test driver: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #define RUN_EACH_TYPE BSLTF_TEMPLATETESTFACILITY_RUN_EACH_TYPE</span>
<span class="preprocessor">  #define TEST_TYPES_REGULAR BSLTF_TEMPLATETESTFACILITY_TEST_TYPES_REGULAR</span>
</pre></div><br/>
<br/>
 Next, we define a <code>struct</code> template, <code>MyTestDriver</code>, that provides a namespace containing the test cases (here, only <code>testCase2</code> is defined for brevity) of the test driver: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">struct </span>MyTestDriver {
      <span class="comment">// This &#39;struct&#39; provides a namespace for the class methods used to</span>
      <span class="comment">// implement the test driver.</span>

      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> MyNullableValue&lt;TYPE&gt; Obj;
          <span class="comment">// This &#39;typedef&#39; provides an alias to the type under testing.</span>

      <span class="keyword">static</span> <span class="keywordtype">void</span> testCase2();
          <span class="comment">// Test primary manipulators.</span>
  };
</pre></div><br/>
<br/>
 Now, we define the implementation of <code>MyTestDriver::testCase2</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> MyTestDriver&lt;TYPE&gt;::testCase2()
  {
      <span class="comment">// --------------------------------------------------------------------</span>
      <span class="comment">// DEFAULT CTOR, PRIMARY MANIPULATORS, AND DTOR</span>
      <span class="comment">//   Ensure that we can use the default constructor to create an</span>
      <span class="comment">//   object (having the default-constructed value), use the primary</span>
      <span class="comment">//   manipulators to put that object into any state relevant for</span>
      <span class="comment">//   thorough testing, and use the destructor to destroy it safely.</span>
      <span class="comment">//</span>
      <span class="comment">// Concerns:</span>
      <span class="comment">//: 1 An object created using the default constructor (with or without</span>
      <span class="comment">//:   a supplied allocator) has the contractually specified value.</span>
      <span class="comment">//:</span>
      <span class="comment">//: 2 The &#39;makeValue&#39; method sets the value of a object to any</span>
      <span class="comment">//:   specified value.</span>
      <span class="comment">//:</span>
      <span class="comment">//: 3 The &#39;makeNull&#39; method set the value of a object to null.</span>
      <span class="comment">//:</span>
      <span class="comment">//: 4 Objects of different values can coexist.</span>
      <span class="comment">//:</span>
      <span class="comment">//: 5 The destructor does not modify other objects.</span>
      <span class="comment">//</span>
      <span class="comment">// Plan:</span>
      <span class="comment">//: 1 Default-construct an object and use the (as yet unproven) salient</span>
      <span class="comment">//:   attribute accessors to verify that the value of the object is the</span>
      <span class="comment">//:   null value.  (C-1)</span>
      <span class="comment">//:</span>
      <span class="comment">//: 2 Default-construct another object, and use the &#39;makeValue&#39; method,</span>
      <span class="comment">//:   to set the value of the object to a non-null value.  Use the (as</span>
      <span class="comment">//:   yet unproven) salient attribute accessors to verify that the new</span>
      <span class="comment">//:   object has the expected value and the object created in P-1 still</span>
      <span class="comment">//:   has the same value.  (C-2, 4)</span>
      <span class="comment">//:</span>
      <span class="comment">//: 3 Using the loop-based approach, for each identifier in a range of</span>
      <span class="comment">//:   integer identifieres:</span>
      <span class="comment">//:</span>
      <span class="comment">//:   1 Default-construct a modifiable object, &#39;mL&#39;, and use the (as</span>
      <span class="comment">//:     yet unproven) salient attribute accessors to verify the value</span>
      <span class="comment">//:     of the default constructed object is the null value.  (C-1)</span>
      <span class="comment">//:</span>
      <span class="comment">//:   2 Create an object of the parameterized &#39;TYPE&#39;, &#39;LV&#39;, using the</span>
      <span class="comment">//:     &#39;TemplateTestFacility::create&#39; class method template,</span>
      <span class="comment">//:     specifying the integer loop identifier.</span>
      <span class="comment">//:</span>
      <span class="comment">//:   3 Use the &#39;makeValue&#39; method to set the value of &#39;mL&#39; to &#39;LV&#39;.</span>
      <span class="comment">//:     Use the (as yet unproven) salient attribute accessors to verify</span>
      <span class="comment">//:     &#39;mL&#39; has the expected value.  (C-2)</span>
      <span class="comment">//:</span>
      <span class="comment">//:   4 Invoke the &#39;makeNull&#39; method of &#39;mL&#39;.  Use the attribute</span>
      <span class="comment">//:     accessors to verify the value of the object is now null.  (C-3)</span>
      <span class="comment">//:</span>
      <span class="comment">//: 4 Create an object in a nested block.  Below the block, verify the</span>
      <span class="comment">//:   objects created in P-1 and P-2 still have the same value.  (C-5)</span>
      <span class="comment">//</span>
      <span class="comment">// Testing:</span>
      <span class="comment">//   MyNullableValue();</span>
      <span class="comment">//   ~MyNullableValue();</span>
      <span class="comment">//   void makeNull();</span>
      <span class="comment">//   void MakeValue(const TYPE&amp; value);</span>
      <span class="comment">// --------------------------------------------------------------------</span>

      <span class="keywordflow">if</span> (verbose)
                  printf(<span class="stringliteral">&quot;\nDEFAULT CTOR, PRIMARY MANIPULATORS, AND DTOR&quot;</span>
                         <span class="stringliteral">&quot;\n============================================\n&quot;</span>);

      <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;\nTesting default constructor.\n&quot;</span>);

      Obj mW; <span class="keyword">const</span> Obj&amp; W = mW;
      ASSERT(<span class="keyword">true</span> == W.isNull());

      Obj mX; <span class="keyword">const</span> Obj&amp; X = mX;
      <span class="keyword">const</span> TYPE XV = TemplateTestFacility::create&lt;TYPE&gt;(1);
      mX.makeValue(XV);
      ASSERT(1 == TemplateTestFacility::getIdentifier&lt;TYPE&gt;(X.value()));

      <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;\nTesting primary manipulators.\n&quot;</span>);

      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> ti = 0; ti &lt; 10; ++ti) {

          <span class="keywordflow">if</span> (veryVerbose) { T_ P(ti) }

          Obj mL; <span class="keyword">const</span> Obj&amp; L = mL;
          ASSERT(<span class="keyword">true</span> == L.isNull());

          <span class="keyword">const</span> TYPE LV = TemplateTestFacility::create&lt;TYPE&gt;(ti);

          mL.makeValue(LV);
          ASSERT(<span class="keyword">false</span> == L.isNull());
          ASSERT(LV == L.value());

          mL.makeNull();
          ASSERT(<span class="keyword">true</span> == L.isNull());
      }

      <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;\nTesting destructor.\n&quot;</span>);
      {
          Obj Z;
      }

      ASSERT(<span class="keyword">true</span> == W.isNull());
      ASSERT(XV == X.value());
  }
</pre></div><br/>
<br/>
 Notice that, we create objects of the parameterized <code>TYPE</code> using the <code>TemplateTestFacility::create</code> class method template specifying an integer identifier; the created object has a value that is uniquely associated with the integer identifier. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Also notice that we verified that an object of the parameterized <code>TYPE</code> has the expected value in two ways: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
By equal comparing (1) the integer identifier returned from calling the <code>TemplateTestFacility::getIdentifier</code> class method template (specifying the object), and (2) the integer identifier uniquely associated with the expected state of the object.  </li>
<li>
By directly using the equality comparison operator for the parameterized <code>TYPE</code>. Note that the equality comparison operator is defined for all types intended for testing in the <code>bsltf</code> package except for <code><a class="el" href="classbsltf_1_1NonEqualComparableTestType.html">bsltf::NonEqualComparableTestType</a></code>.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, we use the <code>BSLTF_TEMPLATETESTFACILITY_RUN_EACH_TYPE</code> macro to instantiate <code>MyTestDriver</code> for each of the types listed in <code>BSLTF_TEMPLATETESTFACILITY_TEST_TYPES_REGULAR</code> and invoke the <code>testCase2</code> class method of each instantiation: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">case</span> 2: {
    <span class="comment">// ----------------------------------------------------------------------</span>
    <span class="comment">// DEFAULT CTOR &amp; PRIMARY MANIPULATORS</span>
    <span class="comment">// ----------------------------------------------------------------------</span>

    <span class="keywordflow">if</span> (verbose) printf(<span class="stringliteral">&quot;\nDEFAULT CTOR &amp; PRIMARY MANIPULATORS&quot;</span>
                        <span class="stringliteral">&quot;\n===================================\n&quot;</span>);

    RUN_EACH_TYPE(MyTestDriver, testCase2, TEST_TYPES_REGULAR);
  } <span class="keywordflow">break</span>;
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:44 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
