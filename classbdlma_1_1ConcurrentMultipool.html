<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlma::ConcurrentMultipool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlma.html">bdlma</a>      </li>
      <li><a class="el" href="classbdlma_1_1ConcurrentMultipool.html">bdlma::ConcurrentMultipool</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlma::ConcurrentMultipool Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlma::ConcurrentMultipool" -->
<p><code>#include &lt;<a class="el" href="bdlma__concurrentmultipool_8h_source.html">bdlma_concurrentmultipool.h</a>&gt;</code></p>

<p><a href="classbdlma_1_1ConcurrentMultipool-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>Header</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#a8eb09ecd19f78088843ac0d2fc42c272">ConcurrentMultipool</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#a75e04c364a5b1aaaab87d230cf42571b">ConcurrentMultipool</a> (int numPools, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#a3d017b2e10502b811ba085dc2d4a95d4">ConcurrentMultipool</a> (<a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#ad968861acd3ab421e4c982575607ffc6">ConcurrentMultipool</a> (int numPools, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#affb446f633c6f1e4fad39440a108e7e8">ConcurrentMultipool</a> (int numPools, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, int maxBlocksPerChunk, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#adba3fc160842ebe98705fbeb7a1e87ef">ConcurrentMultipool</a> (int numPools, const <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> *growthStrategyArray, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#ae2aff16af12a573f09365294648cb3a6">ConcurrentMultipool</a> (int numPools, const <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> *growthStrategyArray, int maxBlocksPerChunk, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#abfc92f3363fb42ab64a1a16162579936">ConcurrentMultipool</a> (int numPools, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, const int *maxBlocksPerChunkArray, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#abd86c9a4a5958dcd6ca747a13da5d14e">ConcurrentMultipool</a> (int numPools, const <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> *growthStrategyArray, const int *maxBlocksPerChunkArray, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#aa359de6dbc1e0cc38a864a1c6ebbcd3c">~ConcurrentMultipool</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#ad339b5f8bcefdeae3d8fdf30a88881fc">allocate</a> (int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#a195200209b0fe574b8acd1ee79746317">deallocate</a> (void *address)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#a89c22885ada1e59bfbaed1c11edf1f7f">deleteObject</a> (const TYPE *object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#a74a6a5fb0432fb776926ed929524dcc5">deleteObjectRaw</a> (const TYPE *object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#af84ed0be1292422bcd27eea46c09877d">release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#a1c1ab6d1011a5a3e46c18f2a32fdf318">reserveCapacity</a> (int size, int numBlocks)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#a23ac0338dc346b47007937cb0aba49d2">numPools</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipool.html#a730bc45f16323a11c00299321d969fc3">maxPooledBlockSize</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements a memory manager that maintains a configurable number of <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code> objects, each dispensing memory blocks of a unique size. The <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> objects are placed in an array, with each successive pool managing memory blocks of size twice that of the previous pool. Each multipool allocation (deallocation) request allocates memory from (returns memory to) the internal pool having the smallest block size not less than the requested size, or, if no pool manages memory blocks of sufficient sized, from a separately managed list of memory blocks. Both the <code>release</code> method and the destructor of a <code>bdema::Multipool</code> release all memory currently allocated via the object. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8eb09ecd19f78088843ac0d2fc42c272"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::ConcurrentMultipool" ref="a8eb09ecd19f78088843ac0d2fc42c272" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipool::ConcurrentMultipool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a75e04c364a5b1aaaab87d230cf42571b"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::ConcurrentMultipool" ref="a75e04c364a5b1aaaab87d230cf42571b" args="(int numPools, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipool::ConcurrentMultipool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPools</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3d017b2e10502b811ba085dc2d4a95d4"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::ConcurrentMultipool" ref="a3d017b2e10502b811ba085dc2d4a95d4" args="(bsls::BlockGrowth::Strategy growthStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipool::ConcurrentMultipool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad968861acd3ab421e4c982575607ffc6"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::ConcurrentMultipool" ref="ad968861acd3ab421e4c982575607ffc6" args="(int numPools, bsls::BlockGrowth::Strategy growthStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipool::ConcurrentMultipool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPools</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="affb446f633c6f1e4fad39440a108e7e8"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::ConcurrentMultipool" ref="affb446f633c6f1e4fad39440a108e7e8" args="(int numPools, bsls::BlockGrowth::Strategy growthStrategy, int maxBlocksPerChunk, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipool::ConcurrentMultipool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPools</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBlocksPerChunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a multipool memory manager. Optionally specify <code>numPools</code>, indicating the number of internally created <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> objects; the block size of the first pool is 8 bytes, with the block size of each additional pool successively doubling. If <code>numPools</code> is not specified, an implementation-defined number of pools <code>N</code> -- covering memory blocks ranging in size from <code>2^3 = 8</code> to <code>2^(N+2)</code> -- are created. Optionally specify a <code>growthStrategy</code> indicating whether the number of blocks allocated at once for every internally created <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> should be either fixed or grow geometrically, starting with 1. If <code>growthStrategy</code> is not specified, the allocation strategy for each internally created <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> object is geometric, starting from 1. If <code>numPools</code> is specified, optionally specify a <code>maxBlocksPerChunk</code>, indicating the maximum number of blocks to be allocated at once when a pool must be replenished. If <code>maxBlocksPerChunk</code> is not specified, an implementation-defined value is used. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Memory allocation (and deallocation) requests will be satisfied using the internally maintained pool managing memory blocks of the smallest size not less than the requested size, or directly from the underlying allocator (supplied at construction), if no internally pool managing memory block of sufficient size exists. The behavior is undefined unless <code>1 &lt;= numPools</code> and <code>1 &lt;= maxBlocksPerChunk</code>. Note that, on platforms where <code>8 &lt; <a class="el" href="structbsls_1_1AlignmentUtil.html#a6b75b476a8862e9508d03ed9c217bb69a74bef72781f251014a813e406edabedb">bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT</a></code>, excess memory may be allocated for pools managing smaller blocks. Also note that <code>maxBlocksPerChunk</code> need not be an integral power of 2; if geometric growth would exceed the maximum value, the chunk size is capped at that value). </p>

</div>
</div>
<a class="anchor" id="adba3fc160842ebe98705fbeb7a1e87ef"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::ConcurrentMultipool" ref="adba3fc160842ebe98705fbeb7a1e87ef" args="(int numPools, const bsls::BlockGrowth::Strategy *growthStrategyArray, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipool::ConcurrentMultipool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPools</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> *&nbsp;</td>
          <td class="paramname"> <em>growthStrategyArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae2aff16af12a573f09365294648cb3a6"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::ConcurrentMultipool" ref="ae2aff16af12a573f09365294648cb3a6" args="(int numPools, const bsls::BlockGrowth::Strategy *growthStrategyArray, int maxBlocksPerChunk, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipool::ConcurrentMultipool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPools</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> *&nbsp;</td>
          <td class="paramname"> <em>growthStrategyArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBlocksPerChunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abfc92f3363fb42ab64a1a16162579936"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::ConcurrentMultipool" ref="abfc92f3363fb42ab64a1a16162579936" args="(int numPools, bsls::BlockGrowth::Strategy growthStrategy, const int *maxBlocksPerChunkArray, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipool::ConcurrentMultipool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPools</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>maxBlocksPerChunkArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abd86c9a4a5958dcd6ca747a13da5d14e"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::ConcurrentMultipool" ref="abd86c9a4a5958dcd6ca747a13da5d14e" args="(int numPools, const bsls::BlockGrowth::Strategy *growthStrategyArray, const int *maxBlocksPerChunkArray, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipool::ConcurrentMultipool </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPools</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> *&nbsp;</td>
          <td class="paramname"> <em>growthStrategyArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>maxBlocksPerChunkArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a multipool memory manager having the specified <code>numPools</code>, indicating the number of internally created <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> objects; the block size of the first pool is 8 bytes, with the block size of each additional pool successively doubling. Optionally specify a <code>growthStrategy</code> indicating whether the number of blocks allocated at once for every internally created <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> should be either fixed or grow geometrically, starting with 1. If <code>growthStrategy</code> is not specified, optionally specify <code>growthStrategyArray</code>, indicating the strategies for each individual <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> created by this object. If neither <code>growthStrategy</code> nor <code>growthStrategyArray</code> are specified, the allocation strategy for each internally created <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> object will grow geometrically, starting from 1. Optionally specify a <code>maxBlocksPerChunk</code>, indicating the maximum number of blocks to be allocated at once when a pool must be replenished. If <code>maxBlocksPerChunk</code> is not specified, optionally specify <code>maxBlocksPerChunkArray</code>, indicating the maximum number of blocks to allocate at once for each individually created <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> object. If neither <code>maxBlocksPerChunk</code> nor <code>maxBlocksPerChunkArray</code> are specified, an implementation-defined value is used. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Memory allocation (and deallocation) requests will be satisfied using the internally maintained pool managing memory blocks of the smallest size not less than the requested size, or directly from the underlying allocator (supplied at construction), if no internally pool managing memory block of sufficient size exists. The behavior is undefined unless <code>1 &lt;= numPools</code>, <code>growthStrategyArray</code> has at least <code>numPools</code> strategies, <code>1 &lt;= maxBlocksPerChunk</code> and <code>maxBlocksPerChunkArray</code> have at least <code>numPools</code> positive values. Note that, on platforms where <code>8 &lt; <a class="el" href="structbsls_1_1AlignmentUtil.html#a6b75b476a8862e9508d03ed9c217bb69a74bef72781f251014a813e406edabedb">bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT</a></code>, excess memory may be allocated for pools managing smaller blocks. Also note that the maximum need not be an integral power of 2; if geometric growth would exceed a maximum value, the chunk size is capped at that value). </p>

</div>
</div>
<a class="anchor" id="aa359de6dbc1e0cc38a864a1c6ebbcd3c"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::~ConcurrentMultipool" ref="aa359de6dbc1e0cc38a864a1c6ebbcd3c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipool::~ConcurrentMultipool </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this multipool. All memory allocated from this memory pool is released. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad339b5f8bcefdeae3d8fdf30a88881fc"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::allocate" ref="ad339b5f8bcefdeae3d8fdf30a88881fc" args="(int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bdlma::ConcurrentMultipool::allocate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a contiguous block of maximally-aligned memory of (at least) the specified <code>size</code> (in bytes). If <code>size &gt; <a class="el" href="classbdlma_1_1ConcurrentMultipool.html#a730bc45f16323a11c00299321d969fc3">maxPooledBlockSize()</a></code>, the memory allocation is managed directly by the underlying allocator, and will not be pooled, but will be deallocated when the <code>release</code> method is called, or when this object is destroyed. The behavior is undefined unless <code>1 &lt;= size</code>. </p>

</div>
</div>
<a class="anchor" id="a195200209b0fe574b8acd1ee79746317"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::deallocate" ref="a195200209b0fe574b8acd1ee79746317" args="(void *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::ConcurrentMultipool::deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Relinquish the memory block at the specified <code>address</code> back to this multipool object for reuse. The behavior is undefined unless <code>address</code> is non-zero, was allocated by this multipool object, and has not already been deallocated. </p>

</div>
</div>
<a class="anchor" id="a89c22885ada1e59bfbaed1c11edf1f7f"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::deleteObject" ref="a89c22885ada1e59bfbaed1c11edf1f7f" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::ConcurrentMultipool::deleteObject </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> based on its dynamic type and then use this multipool object to deallocate its memory footprint. This method has no effect if <code>object</code> is 0. The behavior is undefined unless <code>object</code>, when cast appropriately to <code>void *</code>, was allocated using this multipool object and has not already been deallocated. Note that <code>dynamic_cast&lt;void *&gt;(object)</code> is applied if <code>TYPE</code> is polymorphic, and <code>static_cast&lt;void *&gt;(object)</code> is applied otherwise. </p>

</div>
</div>
<a class="anchor" id="a74a6a5fb0432fb776926ed929524dcc5"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::deleteObjectRaw" ref="a74a6a5fb0432fb776926ed929524dcc5" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::ConcurrentMultipool::deleteObjectRaw </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> and then use this multipool to deallocate its memory footprint. This method has no effect if <code>object</code> is 0. The behavior is undefined unless <code>object</code> is <b>not</b> a secondary base class pointer (i.e., the address is (numerically) the same as when it was originally dispensed by this multipool), was allocated using this multipool, and has not already been deallocated. </p>

</div>
</div>
<a class="anchor" id="af84ed0be1292422bcd27eea46c09877d"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::release" ref="af84ed0be1292422bcd27eea46c09877d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::ConcurrentMultipool::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Relinquish all memory currently allocated via this multipool object. </p>

</div>
</div>
<a class="anchor" id="a1c1ab6d1011a5a3e46c18f2a32fdf318"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::reserveCapacity" ref="a1c1ab6d1011a5a3e46c18f2a32fdf318" args="(int size, int numBlocks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::ConcurrentMultipool::reserveCapacity </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBlocks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reserve memory from this multipool to satisfy memory requests for at least the specified <code>numBlocks</code> having the specified <code>size</code> (in bytes) before the pool replenishes. The behavior is undefined unless <code>1 &lt;= size &lt;= <a class="el" href="classbdlma_1_1ConcurrentMultipool.html#a730bc45f16323a11c00299321d969fc3">maxPooledBlockSize()</a></code>, and <code>0 &lt;= numBlocks</code>. </p>

</div>
</div>
<a class="anchor" id="a23ac0338dc346b47007937cb0aba49d2"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::numPools" ref="a23ac0338dc346b47007937cb0aba49d2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlma::ConcurrentMultipool::numPools </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of pools managed by this multipool object. </p>

</div>
</div>
<a class="anchor" id="a730bc45f16323a11c00299321d969fc3"></a><!-- doxytag: member="bdlma::ConcurrentMultipool::maxPooledBlockSize" ref="a730bc45f16323a11c00299321d969fc3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlma::ConcurrentMultipool::maxPooledBlockSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum size of memory blocks that are pooled by this multipool object. Note that the maximum value is defined as: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          2 ^ (<a class="code" href="classbdlma_1_1ConcurrentMultipool.html#a23ac0338dc346b47007937cb0aba49d2">numPools</a> + 2)
</pre></div><p><br/>
<br/>
 where <code>numPools</code> is either specified at construction, or an implementation-defined value. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlma__concurrentmultipool_8h_source.html">bdlma_concurrentmultipool.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:45 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
