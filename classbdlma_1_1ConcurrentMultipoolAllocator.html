<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlma::ConcurrentMultipoolAllocator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlma.html">bdlma</a>      </li>
      <li><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html">bdlma::ConcurrentMultipoolAllocator</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlma::ConcurrentMultipoolAllocator Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlma::ConcurrentMultipoolAllocator" --><!-- doxytag: inherits="bdlma::ManagedAllocator" -->
<p><code>#include &lt;<a class="el" href="bdlma__concurrentmultipoolallocator_8h_source.html">bdlma_concurrentmultipoolallocator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bdlma::ConcurrentMultipoolAllocator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbdlma_1_1ConcurrentMultipoolAllocator.png" usemap="#bdlma::ConcurrentMultipoolAllocator_map" alt=""/>
  <map id="bdlma::ConcurrentMultipoolAllocator_map" name="bdlma::ConcurrentMultipoolAllocator_map">
<area href="classbdlma_1_1ManagedAllocator.html" alt="bdlma::ManagedAllocator" shape="rect" coords="0,56,217,80"/>
<area href="classbslma_1_1Allocator.html" alt="bslma::Allocator" shape="rect" coords="0,0,217,24"/>
</map>
</div>

<p><a href="classbdlma_1_1ConcurrentMultipoolAllocator-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#ae5f37efa4e8aa28732db5ecba6873f0f">ConcurrentMultipoolAllocator</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#af036cddc5a777980667a4aaa7ea1e68d">ConcurrentMultipoolAllocator</a> (int numPools, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#a4d719cd41a66fb0077212d98e33fbdb0">ConcurrentMultipoolAllocator</a> (<a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#a5ce0bac1bc02ec4dc6dd272502568ae7">ConcurrentMultipoolAllocator</a> (int numPools, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#afbf96a69c6dcfcd45f768f83afe77b18">ConcurrentMultipoolAllocator</a> (int numPools, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, int maxBlocksPerChunk, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#abc209d4b249b429de74a98f448de871e">ConcurrentMultipoolAllocator</a> (int numPools, const <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> *growthStrategyArray, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#a23f9673bb4862b058ca5b267a942fb95">ConcurrentMultipoolAllocator</a> (int numPools, const <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> *growthStrategyArray, int maxBlocksPerChunk, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#ab977f02188972cb58354b7bbe37c0956">ConcurrentMultipoolAllocator</a> (int numPools, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, const int *maxBlocksPerChunkArray, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#aa24be525262fb66c3487ebc18e082208">ConcurrentMultipoolAllocator</a> (int numPools, const <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> *growthStrategyArray, const int *maxBlocksPerChunkArray, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#a56a14c830e911db833941691de461927">~ConcurrentMultipoolAllocator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#a377cd0657814d893dd38d8440fa02398">reserveCapacity</a> (<a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a> size, <a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a> numObjects)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#a6ad193e12f7c6c6e8095c94dd713ccc4">allocate</a> (<a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a> size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#affe442f16ac55d2ea7578839920046ca">deallocate</a> (void *address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#a50efb69ce3c3573b78f0a2437494f087">release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#a1298393f3a49e710b9e6dda704f7b1f1">numPools</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#a5bf34d4ea4c9ccd84f10e418ec3d70b7">maxPooledBlockSize</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a0e51fc2d107684523cc66bf65293dc37">deleteObject</a> (const TYPE *object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#abeccfe6cfd8205faf528a8e12f97aebe">deleteObjectRaw</a> (const TYPE *object)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements the <code><a class="el" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a></code> protocol to provide a thread-safe allocator that maintains a configurable number of <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> objects, each dispensing memory blocks of a unique size. The <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> objects are placed in an array, with each successive pool managing memory blocks of size twice that of the previous pool. Each multipool allocation (deallocation) request allocates memory from (returns memory to) the internal pool having the smallest block size not less than the requested size, or, if no pool manages memory blocks of sufficient sized, from a separately managed list of memory blocks. Both the <code>release</code> method and the destructor of a <code><a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html">ConcurrentMultipoolAllocator</a></code> release all memory currently allocated via the object. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a07cd3ddf3fba145a0469a4e867047287"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::size_type" ref="a07cd3ddf3fba145a0469a4e867047287" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a> <a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">bslma::Allocator::size_type</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae5f37efa4e8aa28732db5ecba6873f0f"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator" ref="ae5f37efa4e8aa28732db5ecba6873f0f" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af036cddc5a777980667a4aaa7ea1e68d"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator" ref="af036cddc5a777980667a4aaa7ea1e68d" args="(int numPools, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPools</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d719cd41a66fb0077212d98e33fbdb0"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator" ref="a4d719cd41a66fb0077212d98e33fbdb0" args="(bsls::BlockGrowth::Strategy growthStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ce0bac1bc02ec4dc6dd272502568ae7"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator" ref="a5ce0bac1bc02ec4dc6dd272502568ae7" args="(int numPools, bsls::BlockGrowth::Strategy growthStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPools</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afbf96a69c6dcfcd45f768f83afe77b18"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator" ref="afbf96a69c6dcfcd45f768f83afe77b18" args="(int numPools, bsls::BlockGrowth::Strategy growthStrategy, int maxBlocksPerChunk, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPools</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBlocksPerChunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a multipool allocator. Optionally specify <code>numPools</code>, indicating the number of internally created <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> objects; the block size of the first pool is 8 bytes, with the block size of each additional pool successively doubling. If <code>numPools</code> is not specified, an implementation-defined number of pools <code>N</code> -- covering memory blocks ranging in size from <code>2^3 = 8</code> to <code>2^(N+2)</code> -- are created. Optionally specify a <code>growthStrategy</code> indicating whether the number of blocks allocated at once for every internally created <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> should be either fixed or grow geometrically, starting with 1. If <code>growthStrategy</code> is not specified, the allocation strategy for each internally created <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> object is geometric, starting from 1. If <code>numPools</code> is specified, optionally specify a <code>maxBlocksPerChunk</code>, indicating the maximum number of blocks to be allocated at once when a pool must be replenished. If <code>maxBlocksPerChunk</code> is not specified, an implementation-defined value is used. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Memory allocation (and deallocation) requests will be satisfied using the internally maintained pool managing memory blocks of the smallest size not less than the requested size, or directly from the underlying allocator (supplied at construction), if no internally pool managing memory block of sufficient size exists. The behavior is undefined unless <code>1 &lt;= numPools</code> and <code>1 &lt;= maxBlocksPerChunk</code>. Note that, on platforms where <code>8 &lt; <a class="el" href="structbsls_1_1AlignmentUtil.html#a4c9252fd48f8c6f3fbdcc10e14cbda12a74bef72781f251014a813e406edabedb">bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT</a></code>, excess memory may be allocated for pools managing smaller blocks. Also note that <code>maxBlocksPerChunk</code> need not be an integral power of 2; if geometric growth would exceed the maximum value, the chunk size is capped at that value). </p>

</div>
</div>
<a class="anchor" id="abc209d4b249b429de74a98f448de871e"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator" ref="abc209d4b249b429de74a98f448de871e" args="(int numPools, const bsls::BlockGrowth::Strategy *growthStrategyArray, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPools</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> *&nbsp;</td>
          <td class="paramname"> <em>growthStrategyArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a23f9673bb4862b058ca5b267a942fb95"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator" ref="a23f9673bb4862b058ca5b267a942fb95" args="(int numPools, const bsls::BlockGrowth::Strategy *growthStrategyArray, int maxBlocksPerChunk, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPools</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> *&nbsp;</td>
          <td class="paramname"> <em>growthStrategyArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBlocksPerChunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab977f02188972cb58354b7bbe37c0956"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator" ref="ab977f02188972cb58354b7bbe37c0956" args="(int numPools, bsls::BlockGrowth::Strategy growthStrategy, const int *maxBlocksPerChunkArray, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPools</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>maxBlocksPerChunkArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa24be525262fb66c3487ebc18e082208"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator" ref="aa24be525262fb66c3487ebc18e082208" args="(int numPools, const bsls::BlockGrowth::Strategy *growthStrategyArray, const int *maxBlocksPerChunkArray, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::ConcurrentMultipoolAllocator::ConcurrentMultipoolAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numPools</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> *&nbsp;</td>
          <td class="paramname"> <em>growthStrategyArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>maxBlocksPerChunkArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a multipool allocator having the specified <code>numPools</code>, indicating the number of internally created <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> objects; the block size of the first pool is 8 bytes, with the block size of each additional pool successively doubling. Optionally specify a <code>growthStrategy</code> indicating whether the number of blocks allocated at once for every internally created <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> should be either fixed or grow geometrically, starting with 1. If <code>growthStrategy</code> is not specified, optionally specify <code>growthStrategyArray</code>, indicating the strategies for each individual <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> created by this object. If neither <code>growthStrategy</code> nor <code>growthStrategyArray</code> are specified, the allocation strategy for each internally created <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> object will grow geometrically, starting from 1. Optionally specify a <code>maxBlocksPerChunk</code>, indicating the maximum number of blocks to be allocated at once when a pool must be replenished. If <code>maxBlocksPerChunk</code> is not specified, optionally specify <code>maxBlocksPerChunkArray</code>, indicating the maximum number of blocks to allocate at once for each individually created <code><a class="el" href="classbdlma_1_1Pool.html">Pool</a></code> object. If neither <code>maxBlocksPerChunk</code> nor <code>maxBlocksPerChunkArray</code> are specified, an implementation-defined value is used. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Memory allocation (and deallocation) requests will be satisfied using the internally maintained pool managing memory blocks of the smallest size not less than the requested size, or directly from the underlying allocator (supplied at construction), if no internally pool managing memory block of sufficient size exists. The behavior is undefined unless <code>1 &lt;= numPools</code>, <code>growthStrategyArray</code> has at least <code>numPools</code> strategies, <code>1 &lt;= maxBlocksPerChunk</code> and <code>maxBlocksPerChunkArray</code> have at least <code>numPools</code> positive values. Note that, on platforms where <code>8 &lt; <a class="el" href="structbsls_1_1AlignmentUtil.html#a4c9252fd48f8c6f3fbdcc10e14cbda12a74bef72781f251014a813e406edabedb">bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT</a></code>, excess memory may be allocated for pools managing smaller blocks. Also note that the maximum need not be an integral power of 2; if geometric growth would exceed a maximum value, the chunk size is capped at that value). </p>

</div>
</div>
<a class="anchor" id="a56a14c830e911db833941691de461927"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::~ConcurrentMultipoolAllocator" ref="a56a14c830e911db833941691de461927" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bdlma::ConcurrentMultipoolAllocator::~ConcurrentMultipoolAllocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this multipool allocator. All memory allocated from this allocator is released. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a377cd0657814d893dd38d8440fa02398"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::reserveCapacity" ref="a377cd0657814d893dd38d8440fa02398" args="(size_type size, size_type numObjects)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::ConcurrentMultipoolAllocator::reserveCapacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numObjects</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reserve memory from this multipool allocator to satisfy memory requests for at least the specified <code>numObjects</code> having the specified <code>size</code> (in bytes) before the pool replenishes. If <code>size</code> is 0, this method has no effect. The behavior is undefined unless <code>0 &lt;= size</code>, <code>size &lt; <a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#a5bf34d4ea4c9ccd84f10e418ec3d70b7">maxPooledBlockSize()</a></code>, and <code>0 &lt;= numObjects</code>. </p>

</div>
</div>
<a class="anchor" id="a6ad193e12f7c6c6e8095c94dd713ccc4"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::allocate" ref="a6ad193e12f7c6c6e8095c94dd713ccc4" args="(size_type size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* bdlma::ConcurrentMultipoolAllocator::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a contiguous block of maximally aligned memory of (at least) the specified <code>size</code> (in bytes). If <code>size</code> is 0, no memory is allocated and 0 is returned. If <code>size &gt; <a class="el" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#a5bf34d4ea4c9ccd84f10e418ec3d70b7">maxPooledBlockSize()</a></code>, the memory allocation is managed directly by the underlying allocator, but will not be pooled . The behavior is undefined unless <code>0 &lt;= size</code>. </p>

<p>Implements <a class="el" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">bslma::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="affe442f16ac55d2ea7578839920046ca"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::deallocate" ref="affe442f16ac55d2ea7578839920046ca" args="(void *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bdlma::ConcurrentMultipoolAllocator::deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Relinquish the memory block at the specified <code>address</code> back to this allocator for reuse. If <code>address</code> is 0, this method has no effect. The behavior is undefined unless <code>address</code> was allocated by this allocator, and has not already been deallocated. </p>

<p>Implements <a class="el" href="classbslma_1_1Allocator.html#a5ff7b0468394849d6824be024f272968">bslma::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a50efb69ce3c3573b78f0a2437494f087"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::release" ref="a50efb69ce3c3573b78f0a2437494f087" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bdlma::ConcurrentMultipoolAllocator::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Relinquish all memory currently allocated through this multipool allocator. </p>

<p>Implements <a class="el" href="classbdlma_1_1ManagedAllocator.html#ad86110a47aaf5e53356c86b5fd240bfb">bdlma::ManagedAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="a1298393f3a49e710b9e6dda704f7b1f1"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::numPools" ref="a1298393f3a49e710b9e6dda704f7b1f1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlma::ConcurrentMultipoolAllocator::numPools </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of pools managed by this multipool allocator. </p>

</div>
</div>
<a class="anchor" id="a5bf34d4ea4c9ccd84f10e418ec3d70b7"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::maxPooledBlockSize" ref="a5bf34d4ea4c9ccd84f10e418ec3d70b7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlma::ConcurrentMultipoolAllocator::maxPooledBlockSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum size of memory blocks that are pooled by this multipool object. Note that the maximum value is defined as: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          2 ^ (<a class="code" href="classbdlma_1_1ConcurrentMultipoolAllocator.html#a1298393f3a49e710b9e6dda704f7b1f1">numPools</a> + 2)
</pre></div><p><br/>
<br/>
 where <code>numPools</code> is either specified at construction, or an implementation-defined value. </p>

</div>
</div>
<a class="anchor" id="a0e51fc2d107684523cc66bf65293dc37"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::deleteObject" ref="a0e51fc2d107684523cc66bf65293dc37" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslma::Allocator::deleteObject </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> based on its dynamic type and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is a null pointer. The behavior is undefined unless <code>object</code>, when cast appropriately to <code>void *</code>, was allocated using this allocator and has not already been deallocated. Note that <code>dynamic_cast&lt;void *&gt;(object)</code> is applied if <code>TYPE</code> is polymorphic, and <code>static_cast&lt;void *&gt;(object)</code> is applied otherwise. </p>

</div>
</div>
<a class="anchor" id="abeccfe6cfd8205faf528a8e12f97aebe"></a><!-- doxytag: member="bdlma::ConcurrentMultipoolAllocator::deleteObjectRaw" ref="abeccfe6cfd8205faf528a8e12f97aebe" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslma::Allocator::deleteObjectRaw </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is a null pointer. The behavior is undefined unless <code>object</code> was allocated using this allocator, is <b>not</b> a secondary base class pointer -- i.e., the address is (numerically) the same as when it was originally dispensed by this allocator, and has not already been deallocated. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlma__concurrentmultipoolallocator_8h_source.html">bdlma_concurrentmultipoolallocator.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:31 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
