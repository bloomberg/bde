<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlma_concurrentfixedpool Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_concurrentfixedpool<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide thread-safe pool of limited # of blocks of uniform size.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlma__concurrentfixedpool.html#gaf81ac0e79b3ec05f84139e7cf08fbe2a">operator new</a> (bsl::size_t size, BloombergLP::bdlma::ConcurrentFixedPool &amp;pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlma__concurrentfixedpool.html#gad0dc8d34abd523eb1dc3386c3f6e8df9">operator delete</a> (void *address, BloombergLP::bdlma::ConcurrentFixedPool &amp;pool)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide thread-safe pool of limited # of blocks of uniform size. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html">bdlma::ConcurrentFixedPool</a> </td><td>thread-safe pool of limited number of blocks  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlma__concurrentpool.html" title="Provide thread-safe allocation of memory blocks of uniform size.">Component bdlma_concurrentpool</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements a <em>fully thread-safe</em> memory pool that allocates and manages a limited number (specified at construction) of memory blocks of some uniform size (also specified at construction). A <code><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html">bdlma::ConcurrentFixedPool</a></code> constructed to manage up to <code>N</code> blocks also provides an association between the address of each block and an index in the range <code>[ 0 .. N - 1 ]</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Other than this mapping between block and index, and the associated limit on the maximum number of blocks that may be simultaneously allocated, this component's semantics are identical to <code><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a></code>. In particular, this component overloads global operator <code>new</code> in the same manner, and the behaviors of <code>release</code> and <code>reserveCapacity</code> are equivalent to the corresponding methods in <code><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Like <code><a class="el" href="classbdlma_1_1ConcurrentPool.html">bdlma::ConcurrentPool</a></code>, this component is intended to be used to implement <em>out-of-place</em> container classes that hold elements of uniform size. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html">bdlma::ConcurrentFixedPool</a></code> is intended to implement <em>out-of-place</em> container classes that hold up to a fixed number of elements, all of uniform size. Suppose we wish to implement a simple thread pool. We want the equivalent of a <code><a class="el" href="classbsl_1_1deque.html">bsl::deque</a>&lt;bsl::function&lt;void(void)&gt; &gt;</code>. However, to minimize the time spent performing operations on this deque - which must be carried out under a lock - we instead store just pointers in the deque, and manage memory efficiently using <code><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html">bdlma::ConcurrentFixedPool</a></code>. <code><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html">bdlma::ConcurrentFixedPool</a></code> is fully thread-safe and does not require any additional synchronization. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The example below is just for the container portion of our simple thread pool. The implementation of the worker thread, and the requisite synchronization, are omitted for clarity. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_JobQueue {

    <span class="keyword">public</span>:
      <span class="comment">// PUBLIC TYPES</span>
      <span class="keyword">typedef</span> bsl::function&lt;void(void)&gt; Job;

    <span class="keyword">private</span>:
      <span class="comment">// DATA</span>
      <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>                d_lock;
      <a class="code" href="classbsl_1_1deque.html">bsl::deque&lt;Job *&gt;</a>           d_queue;
      <a class="code" href="classbdlma_1_1ConcurrentFixedPool.html">bdlma::ConcurrentFixedPool</a>  d_pool;
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>           *d_allocator_p;

      <span class="comment">// Not implemented:</span>
      my_JobQueue(<span class="keyword">const</span> my_JobQueue&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_JobQueue(<span class="keywordtype">int</span> maxJobs, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
      ~my_JobQueue();

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> enqueueJob(<span class="keyword">const</span> Job&amp; job);

      <span class="keywordtype">int</span> tryExecuteJob();
  };

  my_JobQueue::my_JobQueue(<span class="keywordtype">int</span> maxJobs, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_queue(basicAllocator)
  , d_pool(sizeof(Job), maxJobs, basicAllocator)
  , d_allocator_p(bslma::Default::allocator(basicAllocator))
  {
  }

  my_JobQueue::~my_JobQueue()
  {
      Job *jobPtr;
      <span class="keywordflow">while</span> (!d_queue.empty()) {
          jobPtr = d_queue.front();
          jobPtr-&gt;~Job();
          d_queue.pop_front();
      }
  }

  <span class="keywordtype">void</span> my_JobQueue::enqueueJob(<span class="keyword">const</span> Job&amp; job)
  {
      Job *jobPtr = <span class="keyword">new</span> (d_pool) Job(job, d_allocator_p);
      d_lock.lock();
      d_queue.push_back(jobPtr);
      d_lock.unlock();
  }

  <span class="keywordtype">int</span> my_JobQueue::tryExecuteJob()
  {
      d_lock.lock();
      <span class="keywordflow">if</span> (d_queue.empty()) {
          d_lock.unlock();
          <span class="keywordflow">return</span> -1;                                                <span class="comment">// RETURN</span>
      }
      Job *jobPtr = d_queue.front();
      d_queue.pop_front();
      d_lock.unlock();
      (*jobPtr)();
      d_pool.<a class="code" href="classbdlma_1_1Pool.html#a53efea2b4b022fafed196208bd467e46">deleteObject</a>(jobPtr);
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 Note that in the destructor, there is no need to deallocate the individual job objects - the destructor of <code><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html">bdlma::ConcurrentFixedPool</a></code> will release any remaining allocated memory. However, it <em>is</em> necessary to invoke the destructors of all these objects, as the destructor of <code><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html">bdlma::ConcurrentFixedPool</a></code> will not do so. </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaf81ac0e79b3ec05f84139e7cf08fbe2a"></a><!-- doxytag: member="bdlma_concurrentfixedpool.h::operator new" ref="gaf81ac0e79b3ec05f84139e7cf08fbe2a" args="(bsl::size_t size, BloombergLP::bdlma::ConcurrentFixedPool &amp;pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* operator new </td>
          <td>(</td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bdlma::ConcurrentFixedPool &amp;&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate memory of the specified <code>size</code> bytes from the specified <code>pool</code>, and return the address of the allocated memory. The behavior is undefined unless <code>size</code> is the same as the <code>objectSize</code> with which <code>pool</code> was constructed. Note that an object may allocate additional memory internally within its constructor, requiring the allocator to be passed in as a constructor argument: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      my_Type *newMyType(<a class="code" href="classbdlma_1_1ConcurrentFixedPool.html">bdlma::ConcurrentFixedPool</a>  *pool,
                         <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator) {
          <span class="keywordflow">return</span> <span class="keyword">new</span> (*pool) my_Type(..., basicAllocator);
      }
</pre></div><p><br/>
<br/>
 Note also that the analogous version of operator <code>delete</code> should not be called directly. Instead, this component provides a template member function <code><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#af3cecbb01562e608b438beafa4f22333">bdlma::ConcurrentFixedPool::deleteObject</a></code> parameterized by <code>TYPE</code> that performs the equivalent of the following: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">void</span> deleteMyType(<a class="code" href="classbdlma_1_1ConcurrentFixedPool.html">bdlma::ConcurrentFixedPool</a> *pool, my_Type *t) {
          t-&gt;~my_Type();
          pool-&gt;<a class="code" href="classbdlma_1_1ConcurrentFixedPool.html#ac54bed660d00e4faa16aebf57e53e4bf">deallocate</a>(t);
      }
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="gad0dc8d34abd523eb1dc3386c3f6e8df9"></a><!-- doxytag: member="bdlma_concurrentfixedpool.h::operator delete" ref="gad0dc8d34abd523eb1dc3386c3f6e8df9" args="(void *address, BloombergLP::bdlma::ConcurrentFixedPool &amp;pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bdlma::ConcurrentFixedPool &amp;&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use the specified <code>pool</code> to deallocate the memory at the specified <code>address</code>. The behavior is undefined unless <code>address</code> was allocated using <code>pool</code> and has not already been deallocated. This operator is supplied solely to allow the compiler to arrange for it to be called in case of an exception. Client code should not call it; use <code><a class="el" href="classbdlma_1_1ConcurrentFixedPool.html#af3cecbb01562e608b438beafa4f22333">bdlma::ConcurrentFixedPool::deleteObject()</a></code> instead. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:45 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
