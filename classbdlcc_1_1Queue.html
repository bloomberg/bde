<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlcc::Queue</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlcc.html">bdlcc</a>      </li>
      <li><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue&lt; TYPE &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlcc::Queue&lt; TYPE &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlcc::Queue" -->
<p><code>#include &lt;<a class="el" href="bdlcc__queue_8h_source.html">bdlcc_queue.h</a>&gt;</code></p>

<p><a href="classbdlcc_1_1Queue-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlcc_1_1Queue_1_1InitialCapacity.html">InitialCapacity</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#ab186b9343b897a528abee2ae177a53d4">BSLALG_DECLARE_NESTED_TRAITS</a> (<a class="el" href="classbdlcc_1_1Queue.html">Queue</a>, <a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#adc03d8434e5e0fc9a71dca522a2f2f4b">Queue</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a1865906e76cc9bd40251f87b46b29b6a">Queue</a> (int highWaterMark, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a280aa95f6a36843bb647a210f1c1ffc6">Queue</a> (const <a class="el" href="structbdlcc_1_1Queue_1_1InitialCapacity.html">InitialCapacity</a> &amp;numItems, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#aebca501b2523e424dbe23fd1760ba2ca">Queue</a> (const <a class="el" href="structbdlcc_1_1Queue_1_1InitialCapacity.html">InitialCapacity</a> &amp;numItems, int highWaterMark, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a2379c6b27aba516b5fc4818361a57a73">Queue</a> (const <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; TYPE &gt; &amp;srcQueue, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a15f1e2a9e17cc8fa04536d353723aaa1">Queue</a> (const <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; TYPE &gt; &amp;srcQueue, int highWaterMark, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a2025ea98287eb3dad8f197f67e3add9c">~Queue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#ac1c0df6c508c8127d8e5354e49120c36">popBack</a> (TYPE *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#aff3b5961e61f7c74af1da1efe0d9c5e0">popBack</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#ac83aa92b685bc5839cfbe051edede460">timedPopBack</a> (TYPE *buffer, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#aba6523bb41b6af87258d7706259aceed">popFront</a> (TYPE *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a5479fb5eddaad7276b223524c8dfce9f">popFront</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#ab4986fedcc53fb2fd8410a079eb2da20">timedPopFront</a> (TYPE *buffer, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#ad8e6df9c2756e28a666eebecaf922dad">removeAll</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; TYPE &gt; *buffer=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a7835a8aad26ca5685dae884a0bc19d46">pushBack</a> (const TYPE &amp;item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a9d6b3d1187bc27c99c60d6dea0b49896">pushFront</a> (const TYPE &amp;item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#ade946a36feadb207761c2ae4f03f93ac">timedPushBack</a> (const TYPE &amp;item, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a721355524668ff617d290c2dadcd94f0">timedPushFront</a> (const TYPE &amp;item, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#adb5e35fa72cc6ef5c600004c343bb547">forcePushFront</a> (const TYPE &amp;item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a3de81a339bca072a7bb5b4634d834cdd">tryPopFront</a> (TYPE *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a433fcb8de6fa7045b5d664c146240d22">tryPopFront</a> (int maxNumItems, <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; TYPE &gt; *buffer=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a0ae483759387b4ff4f2bcf0f209bf663">tryPopBack</a> (TYPE *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a54b31adf27663727883a6ab848f1cfda">tryPopBack</a> (int maxNumItems, <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; TYPE &gt; *buffer=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslmt_1_1Condition.html">bslmt::Condition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a5b09463e7ba59700895440c10d00c552">condition</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslmt_1_1Condition.html">bslmt::Condition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#ac56f61c5ca2fb558b2b6a6a3451a7dbd">insertCondition</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#acee74ac49dd35272304f3b36d2dac369">mutex</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslmt_1_1Condition.html">bslmt::Condition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#ae15555f980577a528ec2e871b69086e5">notEmptyCondition</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslmt_1_1Condition.html">bslmt::Condition</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a994e4e7a46b79e5a3935fd729008869e">notFullCondition</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; TYPE &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a4e1d9f694b96bf24f76f5d2e56f3f894">queue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#aac9e59e4867a984c6a5e1e9675410333">highWaterMark</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1Queue.html#a52ca979f0cbe9cc3676c9d691cfd0f43">length</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TYPE&gt;<br/>
 class bdlcc::Queue&lt; TYPE &gt;</h3>

<p>This class provides a thread-enabled implementation of an efficient, in-place, indexable, double-ended queue of parameterized <code>TYPE</code> values. Very efficient access to the underlying <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code> object is provided, as well as to a <code><a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a></code> and a <code><a class="el" href="classbslmt_1_1Condition.html">bslmt::Condition</a></code> variable, to facilitate thread-safe use of the <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code>. Note that <code><a class="el" href="classbdlcc_1_1Queue.html">Queue</a></code> is not a value-semantic type, but the underlying <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code> is. In this regard, <code><a class="el" href="classbdlcc_1_1Queue.html">Queue</a></code> is a thread-enabled handle for a <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code>. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adc03d8434e5e0fc9a71dca522a2f2f4b"></a><!-- doxytag: member="bdlcc::Queue::Queue" ref="adc03d8434e5e0fc9a71dca522a2f2f4b" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::<a class="el" href="classbdlcc_1_1Queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a queue of objects of parameterized <code>TYPE</code>. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a1865906e76cc9bd40251f87b46b29b6a"></a><!-- doxytag: member="bdlcc::Queue::Queue" ref="a1865906e76cc9bd40251f87b46b29b6a" args="(int highWaterMark, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::<a class="el" href="classbdlcc_1_1Queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>highWaterMark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a queue of objects of parameterized <code>TYPE</code> having either the specified <code>highWaterMark</code> suggested maximum length if <code>highWaterMark</code> is positive, or no maximum length if <code>highWaterMark</code> is negative. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>highWaterMark != 0</code>. </p>

</div>
</div>
<a class="anchor" id="a280aa95f6a36843bb647a210f1c1ffc6"></a><!-- doxytag: member="bdlcc::Queue::Queue" ref="a280aa95f6a36843bb647a210f1c1ffc6" args="(const InitialCapacity &amp;numItems, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::<a class="el" href="classbdlcc_1_1Queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdlcc_1_1Queue_1_1InitialCapacity.html">InitialCapacity</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>numItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a queue of objects of parameterized <code>TYPE</code> with sufficient initial capacity to accommodate up to the specified <code>numItems</code> values without subsequent reallocation. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="aebca501b2523e424dbe23fd1760ba2ca"></a><!-- doxytag: member="bdlcc::Queue::Queue" ref="aebca501b2523e424dbe23fd1760ba2ca" args="(const InitialCapacity &amp;numItems, int highWaterMark, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::<a class="el" href="classbdlcc_1_1Queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbdlcc_1_1Queue_1_1InitialCapacity.html">InitialCapacity</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>numItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>highWaterMark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a queue of objects of parameterized <code>TYPE</code> with sufficient initial capacity to accommodate up to the specified <code>numItems</code> values without subsequent reallocation and having either the specified <code>highWaterMark</code> suggested maximum length if <code>highWaterMark</code> is positive, or no maximum length if <code>highWaterMark</code> is negative. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>highWaterMark != 0</code>. </p>

</div>
</div>
<a class="anchor" id="a2379c6b27aba516b5fc4818361a57a73"></a><!-- doxytag: member="bdlcc::Queue::Queue" ref="a2379c6b27aba516b5fc4818361a57a73" args="(const bdlc::Queue&lt; TYPE &gt; &amp;srcQueue, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::<a class="el" href="classbdlcc_1_1Queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>srcQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IMPLICIT: Create a queue of objects of parameterized <code>TYPE</code> containing the sequence of <code>TYPE</code> values from the specified <code>srcQueue</code>. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a15f1e2a9e17cc8fa04536d353723aaa1"></a><!-- doxytag: member="bdlcc::Queue::Queue" ref="a15f1e2a9e17cc8fa04536d353723aaa1" args="(const bdlc::Queue&lt; TYPE &gt; &amp;srcQueue, int highWaterMark, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::<a class="el" href="classbdlcc_1_1Queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt; TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>srcQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>highWaterMark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a queue of objects of parameterized <code>TYPE</code> containing the sequence of <code>TYPE</code> values from the specified <code>srcQueue</code> and having either the specified <code>highWaterMark</code> suggested maximum length if <code>highWaterMark</code> is positive, or no maximum length if <code>highWaterMark</code> is negative. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>highWaterMark != 0</code>. </p>

</div>
</div>
<a class="anchor" id="a2025ea98287eb3dad8f197f67e3add9c"></a><!-- doxytag: member="bdlcc::Queue::~Queue" ref="a2025ea98287eb3dad8f197f67e3add9c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::~<a class="el" href="classbdlcc_1_1Queue.html">Queue</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this queue. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab186b9343b897a528abee2ae177a53d4"></a><!-- doxytag: member="bdlcc::Queue::BSLALG_DECLARE_NESTED_TRAITS" ref="ab186b9343b897a528abee2ae177a53d4" args="(Queue, bslalg::TypeTraitUsesBslmaAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::BSLALG_DECLARE_NESTED_TRAITS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1Queue.html">Queue</a>&lt; TYPE &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac1c0df6c508c8127d8e5354e49120c36"></a><!-- doxytag: member="bdlcc::Queue::popBack" ref="ac1c0df6c508c8127d8e5354e49120c36" args="(TYPE *buffer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::popBack </td>
          <td>(</td>
          <td class="paramtype">TYPE *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the last item in this queue and load that item into the specified <code>buffer</code>. If this queue is empty, block until an item is available. </p>

</div>
</div>
<a class="anchor" id="aff3b5961e61f7c74af1da1efe0d9c5e0"></a><!-- doxytag: member="bdlcc::Queue::popBack" ref="aff3b5961e61f7c74af1da1efe0d9c5e0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::popBack </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the last item in this queue and return that item value. If this queue is empty, block until an item is available. </p>

</div>
</div>
<a class="anchor" id="ac83aa92b685bc5839cfbe051edede460"></a><!-- doxytag: member="bdlcc::Queue::timedPopBack" ref="ac83aa92b685bc5839cfbe051edede460" args="(TYPE *buffer, const bsls::TimeInterval &amp;timeout)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::timedPopBack </td>
          <td>(</td>
          <td class="paramtype">TYPE *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the last item in this queue and load that item value into the specified <code>buffer</code>. If this queue is empty, block until an item is available or until the specified <code>timeout</code> (expressed as the <b>ABSOLUTE</b> time from 00:00:00 UTC, January 1, 1970) expires. Return 0 on success, and a non-zero value if the call timed out before an item was available. </p>

</div>
</div>
<a class="anchor" id="aba6523bb41b6af87258d7706259aceed"></a><!-- doxytag: member="bdlcc::Queue::popFront" ref="aba6523bb41b6af87258d7706259aceed" args="(TYPE *buffer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::popFront </td>
          <td>(</td>
          <td class="paramtype">TYPE *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the first item in this queue and load that item into the specified <code>buffer</code>. If the queue is empty, block until an item is available. </p>

</div>
</div>
<a class="anchor" id="a5479fb5eddaad7276b223524c8dfce9f"></a><!-- doxytag: member="bdlcc::Queue::popFront" ref="a5479fb5eddaad7276b223524c8dfce9f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::popFront </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the first item in this queue and return that item value. If the queue is empty, block until an item is available. </p>

</div>
</div>
<a class="anchor" id="ab4986fedcc53fb2fd8410a079eb2da20"></a><!-- doxytag: member="bdlcc::Queue::timedPopFront" ref="ab4986fedcc53fb2fd8410a079eb2da20" args="(TYPE *buffer, const bsls::TimeInterval &amp;timeout)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::timedPopFront </td>
          <td>(</td>
          <td class="paramtype">TYPE *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the first item in this queue and load that item value into the specified <code>buffer</code>. If this queue is empty, block until an item is available or until the specified <code>timeout</code> (expressed as the <b>ABSOLUTE</b> time from 00:00:00 UTC, January 1, 1970) expires. Return 0 on success, and a non-zero value if the call timed out before an item was available. </p>

</div>
</div>
<a class="anchor" id="ad8e6df9c2756e28a666eebecaf922dad"></a><!-- doxytag: member="bdlcc::Queue::removeAll" ref="ad8e6df9c2756e28a666eebecaf922dad" args="(bsl::vector&lt; TYPE &gt; *buffer=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::removeAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="paramname"> <em>buffer</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all the items in this queue. If the optionally specified <code>buffer</code> is not 0, load into <code>buffer</code> a copy of the items removed in front to back order of the queue prior to <code>removeAll</code>. </p>

</div>
</div>
<a class="anchor" id="a7835a8aad26ca5685dae884a0bc19d46"></a><!-- doxytag: member="bdlcc::Queue::pushBack" ref="a7835a8aad26ca5685dae884a0bc19d46" args="(const TYPE &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::pushBack </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append the specified <code>item</code> to the back of this queue. If the high-water mark is non-negative and the number of items in this queue is greater than or equal to the high-water mark, then block until the number of items in this queue is less than the high-water mark. </p>

</div>
</div>
<a class="anchor" id="a9d6b3d1187bc27c99c60d6dea0b49896"></a><!-- doxytag: member="bdlcc::Queue::pushFront" ref="a9d6b3d1187bc27c99c60d6dea0b49896" args="(const TYPE &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::pushFront </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append the specified <code>item</code> to the front of this queue. If the high-water mark is non-negative and the number of items in this queue is greater than or equal to the high-water mark, then block until the number of items in this queue is less than the high-water mark. </p>

</div>
</div>
<a class="anchor" id="ade946a36feadb207761c2ae4f03f93ac"></a><!-- doxytag: member="bdlcc::Queue::timedPushBack" ref="ade946a36feadb207761c2ae4f03f93ac" args="(const TYPE &amp;item, const bsls::TimeInterval &amp;timeout)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::timedPushBack </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append the specified <code>item</code> to the back of this queue. If the high-water mark is non-negative and the number of items in this queue is greater than or equal to the high-water mark, then block until the number of items in this queue is less than the high-water mark or until the specified <code>timeout</code> (expressed as the <b>ABSOLUTE</b> time from 00:00:00 UTC, January 1, 1970) expires. Return 0 on success, and a non-zero value if the call timed out before the number of items in this queue fell below the high-water mark. </p>

</div>
</div>
<a class="anchor" id="a721355524668ff617d290c2dadcd94f0"></a><!-- doxytag: member="bdlcc::Queue::timedPushFront" ref="a721355524668ff617d290c2dadcd94f0" args="(const TYPE &amp;item, const bsls::TimeInterval &amp;timeout)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::timedPushFront </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append the specified <code>item</code> to the front of this queue. If the high water mark is non-negative and the number of items in this queue is greater than or equal to the high-water mark, then block until the number of items in this queue is less than the high-water mark or until the specified <code>timeout</code> (expressed as the <b>ABSOLUTE</b> time from 00:00:00 UTC, January 1, 1970) expires. Return 0 on success, and a non-zero value if the call timed out before the number of items in this queue fell below the high-water mark. </p>

</div>
</div>
<a class="anchor" id="adb5e35fa72cc6ef5c600004c343bb547"></a><!-- doxytag: member="bdlcc::Queue::forcePushFront" ref="adb5e35fa72cc6ef5c600004c343bb547" args="(const TYPE &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::forcePushFront </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append the specified <code>item</code> to the front of this queue without regard for the high-water mark. Note that this method is provided to allow high priority items to be inserted when the queue is full (i.e., has a number of items greater than or equal to its high-water mark); <code>pushFront</code> and <code>pushBack</code> should be used for general use. </p>

</div>
</div>
<a class="anchor" id="a3de81a339bca072a7bb5b4634d834cdd"></a><!-- doxytag: member="bdlcc::Queue::tryPopFront" ref="a3de81a339bca072a7bb5b4634d834cdd" args="(TYPE *buffer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::tryPopFront </td>
          <td>(</td>
          <td class="paramtype">TYPE *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this queue is non-empty, remove the first item, load that item into the specified <code>buffer</code>, and return 0 indicating success. If this queue is empty, return a non-zero value with no effect on <code>buffer</code> or the state of this queue. This method never blocks. </p>

</div>
</div>
<a class="anchor" id="a433fcb8de6fa7045b5d664c146240d22"></a><!-- doxytag: member="bdlcc::Queue::tryPopFront" ref="a433fcb8de6fa7045b5d664c146240d22" args="(int maxNumItems, bsl::vector&lt; TYPE &gt; *buffer=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::tryPopFront </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxNumItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="paramname"> <em>buffer</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove up to the specified <code>maxNumItems</code> from the front of this queue. Optionally specify a <code>buffer</code> into which the items removed from the queue are loaded. If <code>buffer</code> is non-null, the removed items are appended to it as if by repeated application of <code>buffer-&gt;push_back(<a class="el" href="classbdlcc_1_1Queue.html#a5479fb5eddaad7276b223524c8dfce9f">popFront()</a>)</code> while the queue is not empty and <code>maxNumItems</code> have not yet been removed. The behavior is undefined unless <code>maxNumItems &gt;= 0</code>. This method never blocks. </p>

</div>
</div>
<a class="anchor" id="a0ae483759387b4ff4f2bcf0f209bf663"></a><!-- doxytag: member="bdlcc::Queue::tryPopBack" ref="a0ae483759387b4ff4f2bcf0f209bf663" args="(TYPE *buffer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::tryPopBack </td>
          <td>(</td>
          <td class="paramtype">TYPE *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this queue is non-empty, remove the last item, load that item into the specified <code>buffer</code>, and return 0 indicating success. If this queue is empty, return a non-zero value with no effect on <code>buffer</code> or the state of this queue. This method never blocks. </p>

</div>
</div>
<a class="anchor" id="a54b31adf27663727883a6ab848f1cfda"></a><!-- doxytag: member="bdlcc::Queue::tryPopBack" ref="a54b31adf27663727883a6ab848f1cfda" args="(int maxNumItems, bsl::vector&lt; TYPE &gt; *buffer=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::tryPopBack </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxNumItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; TYPE &gt; *&nbsp;</td>
          <td class="paramname"> <em>buffer</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove up to the specified <code>maxNumItems</code> from the back of this queue. Optionally specify a <code>buffer</code> into which the items removed from the queue are loaded. If <code>buffer</code> is non-null, the removed items are appended to it as if by repeated application of <code>buffer-&gt;push_back(<a class="el" href="classbdlcc_1_1Queue.html#aff3b5961e61f7c74af1da1efe0d9c5e0">popBack()</a>)</code> while the queue is not empty and <code>maxNumItems</code> have not yet been removed. This method never blocks. The behavior is undefined unless <code>maxNumItems &gt;= 0</code>. Note that the ordering of the items in <code>*buffer</code> after the call is the reverse of the ordering they had in the queue. </p>

</div>
</div>
<a class="anchor" id="a5b09463e7ba59700895440c10d00c552"></a><!-- doxytag: member="bdlcc::Queue::condition" ref="a5b09463e7ba59700895440c10d00c552" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslmt_1_1Condition.html">bslmt::Condition</a>&amp; <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::condition </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable condition variable used by this queue to signal that the queue is not empty.</p>
<p><em>DEPRECATED</em> Use <code>notEmptyCondition</code> instead. </p>

</div>
</div>
<a class="anchor" id="ac56f61c5ca2fb558b2b6a6a3451a7dbd"></a><!-- doxytag: member="bdlcc::Queue::insertCondition" ref="ac56f61c5ca2fb558b2b6a6a3451a7dbd" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslmt_1_1Condition.html">bslmt::Condition</a>&amp; <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::insertCondition </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable condition variable used by this queue to signal that the queue is not full (i.e., has fewer items than its high-water mark).</p>
<p><em>DEPRECATED</em> Use <code>notFullCondition</code> instead. </p>

</div>
</div>
<a class="anchor" id="acee74ac49dd35272304f3b36d2dac369"></a><!-- doxytag: member="bdlcc::Queue::mutex" ref="acee74ac49dd35272304f3b36d2dac369" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>&amp; <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::mutex </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable mutex used by this queue to synchronize access to its underlying <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code> object. </p>

</div>
</div>
<a class="anchor" id="ae15555f980577a528ec2e871b69086e5"></a><!-- doxytag: member="bdlcc::Queue::notEmptyCondition" ref="ae15555f980577a528ec2e871b69086e5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslmt_1_1Condition.html">bslmt::Condition</a>&amp; <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::notEmptyCondition </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the condition variable used by this queue to signal that the queue is not empty. </p>

</div>
</div>
<a class="anchor" id="a994e4e7a46b79e5a3935fd729008869e"></a><!-- doxytag: member="bdlcc::Queue::notFullCondition" ref="a994e4e7a46b79e5a3935fd729008869e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslmt_1_1Condition.html">bslmt::Condition</a>&amp; <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::notFullCondition </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the condition variable used by this queue to signal that the queue is not full (i.e., has fewer items than its high-water mark). </p>

</div>
</div>
<a class="anchor" id="a4e1d9f694b96bf24f76f5d2e56f3f894"></a><!-- doxytag: member="bdlcc::Queue::queue" ref="a4e1d9f694b96bf24f76f5d2e56f3f894" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a>&lt;TYPE&gt;&amp; <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::queue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable underlying <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code> object used by this queue. Any access to the returned queue MUST first lock the associated mutex object (see the <code>mutex</code> method) in a multi-threaded environment. And when items are directly added to the queue returned by this method, the associated condition variable (see the <code>condition</code> method) should be signaled to notify any waiting threads of the availability of the new data.</p>
<p>The (error-prone) usage of this method will be replaced by an appropriate smart-pointer-like proctor object in the future. Meanwhile, use this method with caution. </p>

</div>
</div>
<a class="anchor" id="aac9e59e4867a984c6a5e1e9675410333"></a><!-- doxytag: member="bdlcc::Queue::highWaterMark" ref="aac9e59e4867a984c6a5e1e9675410333" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::highWaterMark </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the high-water mark value for this queue. Note that a negative value indicates no suggested-maximum capacity, and is not necessarily the same negative value that was passed to the constructor. </p>

</div>
</div>
<a class="anchor" id="a52ca979f0cbe9cc3676c9d691cfd0f43"></a><!-- doxytag: member="bdlcc::Queue::length" ref="a52ca979f0cbe9cc3676c9d691cfd0f43" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a>&lt; TYPE &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements in this queue. Note that if other threads are manipulating the queue, this information may be obsolete by the time it is returned. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlcc__queue_8h_source.html">bdlcc_queue.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:18 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
