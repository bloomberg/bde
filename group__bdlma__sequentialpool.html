<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlma_sequentialpool Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_sequentialpool<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide sequential memory using dynamically-allocated buffers.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlma__sequentialpool.html#ga20c98367f3d271875d6db842cf4d0a0d">operator new</a> (bsl::size_t size, BloombergLP::bdlma::SequentialPool &amp;pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlma__sequentialpool.html#ga3ef871e25838522f1ed3cde27f65a0b6">operator delete</a> (void *address, BloombergLP::bdlma::SequentialPool &amp;pool)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Optional <code>initialSize</code> Parameter</a> <ul>
<li>
<a href="#3.1.1">Optional <code>maxBufferSize</code> Parameter</a> </li>
</ul>
</li>
<li>
<a href="#3.2">Optional <code>growthStrategy</code> Parameter</a> </li>
<li>
<a href="#3.3">Optional <code>alignmentStrategy</code> Parameter</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: Using <code>bdlma::SequentialPool</code> for Efficient Allocations</a> </li>
<li>
<a href="#3.4.2">Example 2: Implementing an Allocator Using <code>bdlma::SequentialPool</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide sequential memory using dynamically-allocated buffers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1SequentialPool.html">bdlma::SequentialPool</a> </td><td>memory pool using dynamically-allocated buffers  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlma__infrequentdeleteblocklist.html" title="Provide allocation and management of infrequently deleted blocks.">Component bdlma_infrequentdeleteblocklist</a>, <a class="el" href="group__bdlma__sequentialallocator.html" title="Provide a managed allocator using dynamically-allocated buffers.">Component bdlma_sequentialallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a fast sequential memory pool, <code><a class="el" href="classbdlma_1_1SequentialPool.html">bdlma::SequentialPool</a></code>, that dispenses heterogeneous memory blocks (of varying, user-specified sizes) from a dynamically-allocated internal buffer. If an allocation request exceeds the remaining free memory space in the internal buffer, the pool either replenishes its buffer with new memory to satisfy the request, or returns a separate memory block, depending on whether the request size exceeds an optionally-specified maximum buffer size. The <code>release</code> method releases all memory allocated through the pool, as does the destructor. Note that individually allocated memory blocks cannot be separately deallocated. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbdlma_1_1SequentialPool.html">bdlma::SequentialPool</a></code> is typically used when fast allocation and deallocation is needed, but the user does not know in advance the maximum amount of memory needed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="optional_initialsize_parameter"></a> <a class="anchor" id="description.optional_initialsize_parameter"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Optional initialSize Parameter: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An optional <code>initialSize</code> parameter can be supplied at construction to specify the initial size of the internal buffer. If <code>initialSize</code> is not supplied, an implementation-defined value is used for the initial internal size of the buffer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="optional_maxbuffersize_parameter"></a> <a class="anchor" id="optional_initialsize_parameter.optional_maxbuffersize_parameter"></a> <a class="anchor" id="description.optional_initialsize_parameter.optional_maxbuffersize_parameter"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Optional maxBufferSize Parameter: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If <code>initialSize</code> is specified, an optional <code>maxBufferSize</code> parameter can be supplied at construction to specify the maximum buffer size for geometric growth. Once the internal buffer grows up to the <code>maxBufferSize</code>, further requests that exceed this size will be served by a separate memory block instead of the internal buffer. The behavior is undefined unless <code>maxBufferSize &gt;= initialSize</code>. Note that <code>reserveCapacity</code> always ensures that the requested number of bytes is available (allocating a new internal buffer if necessary) regardless of whether the size of the request exceeds <code>maxBufferSize</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="optional_growthstrategy_parameter"></a> <a class="anchor" id="description.optional_growthstrategy_parameter"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Optional growthStrategy Parameter: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An optional <code>growthStrategy</code> parameter can be supplied at construction to specify the growth rate of the dynamically-allocated buffers. The buffers can grow either geometrically or remain constant in size. If <code>growthStrategy</code> is not specified, geometric growth is used. See <code>bsls_blockgrowth</code> for more details. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="optional_alignmentstrategy_parameter"></a> <a class="anchor" id="description.optional_alignmentstrategy_parameter"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Optional alignmentStrategy Parameter: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An optional <code>alignmentStrategy</code> parameter can be supplied at construction to specify the memory alignment strategy. Allocated memory blocks can either follow maximum alignment, natural alignment, or 1-byte alignment. If <code>alignmentStrategy</code> is not specified, natural alignment is used. See <code>bsls_alignment</code> for more details. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_bdlma~3A~3Asequentialpool_for_efficient_allocations"></a> <a class="anchor" id="usage.example_1~3A_using_bdlma~3A~3Asequentialpool_for_efficient_allocations"></a> <a class="anchor" id="description.usage.example_1~3A_using_bdlma~3A~3Asequentialpool_for_efficient_allocations"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using bdlma::SequentialPool for Efficient Allocations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we define a container class, <code>my_IntDoubleArray</code>, that holds both <code>int</code> and <code>double</code> values. The class can be implemented using two parallel arrays: one storing the type information, and the other storing pointers to the <code>int</code> and <code>double</code> values. For efficient memory allocation, we can use a <code><a class="el" href="classbdlma_1_1SequentialPool.html">bdlma::SequentialPool</a></code> for memory allocation: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_intdoublearray.h</span>

  <span class="keyword">class </span>my_IntDoubleArray {
      <span class="comment">// This class implements an efficient container for an array that</span>
      <span class="comment">// stores both &#39;int&#39; and &#39;double&#39; values.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span>  *d_typeArray_p;   <span class="comment">// array indicating the type of corresponding</span>
                              <span class="comment">// values stored in &#39;d_valueArray_p&#39;</span>

      <span class="keywordtype">void</span> **d_valueArray_p;  <span class="comment">// array of pointers to the values stored</span>

      <span class="keywordtype">int</span>    d_length;        <span class="comment">// number of values stored</span>

      <span class="keywordtype">int</span>    d_capacity;      <span class="comment">// physical capacity of the type and value</span>
                              <span class="comment">// arrays</span>

      <a class="code" href="classbdlma_1_1SequentialPool.html">bdlma::SequentialPool</a>
             d_pool;          <span class="comment">// sequential memory pool used to supply memory</span>

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE MANIPULATORS</span>
      <span class="keywordtype">void</span> increaseSize();
          <span class="comment">// Increase the capacity of the internal arrays used to store</span>
          <span class="comment">// elements added to this array by at least one element.</span>

      <span class="comment">// Not implemented:</span>
      my_IntDoubleArray(<span class="keyword">const</span> my_IntDoubleArray&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">enum</span> <a class="code" href="classBind__ImplSelector_1_1Type.html">Type</a> { k_MY_INT, k_MY_DOUBLE };

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my_IntDoubleArray(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an &#39;int&#39;-&#39;double&#39; array.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      ~my_IntDoubleArray();
          <span class="comment">// Destroy this array and all elements held by it.</span>

      <span class="comment">// ...</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> appendInt(<span class="keywordtype">int</span> value);
          <span class="comment">// Append the specified &#39;int&#39; &#39;value&#39; to this array.</span>

      <span class="keywordtype">void</span> appendDouble(<span class="keywordtype">double</span> value);
          <span class="comment">// Append the specified &#39;double&#39; &#39;value&#39; to this array.</span>

      <span class="keywordtype">void</span> removeAll();
          <span class="comment">// Remove all elements from this array.</span>

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 The use of a sequential pool and the <code>release</code> method allows the <code>removeAll</code> method to quickly deallocate memory of all elements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_IntDoubleArray::removeAll()
  {
      d_pool.<a class="code" href="classbdlma_1_1Pool.html#afd51c71be6e7ab898b79e8a0b61090b0">release</a>();
      d_length = 0;
  }
</pre></div><br/>
<br/>
 The sequential pool optimizes the allocation of memory by using dynamically-allocated buffers to supply memory. This greatly reduces the amount of dynamic allocation needed: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_intdoublearray.cpp</span>

  <span class="keyword">enum</span> { k_INITIAL_SIZE = 1 };

  <span class="comment">// PRIVATE MANIPULATORS</span>
  <span class="keywordtype">void</span> my_IntDoubleArray::increaseSize()
  {
      <span class="comment">// Implementation elided.</span>
      <span class="comment">// ...</span>
  }

  <span class="comment">// CREATORS</span>
  my_IntDoubleArray::my_IntDoubleArray(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_length(0)
  , d_capacity(k_INITIAL_SIZE)
  , d_pool(basicAllocator)
  {
      d_typeArray_p  = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(
                       d_pool.<a class="code" href="classbdlma_1_1Pool.html#af8ec09fd2baf0d59ebf139e8c670577f">allocate</a>(d_capacity * <span class="keyword">sizeof</span> *d_typeArray_p));
      d_valueArray_p = <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span> **<span class="keyword">&gt;</span>(
                       d_pool.<a class="code" href="classbdlma_1_1Pool.html#af8ec09fd2baf0d59ebf139e8c670577f">allocate</a>(d_capacity * <span class="keyword">sizeof</span> *d_valueArray_p));
  }
</pre></div><br/>
<br/>
 Note that in the destructor, all outstanding memory blocks are deallocated automatically when <code>d_pool</code> is destroyed: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_IntDoubleArray::~my_IntDoubleArray()
  {
      assert(0 &lt;= d_length);
      assert(0 &lt;= d_capacity);
      assert(d_length &lt;= d_capacity);
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">void</span> my_IntDoubleArray::appendInt(<span class="keywordtype">int</span> value)
  {
      <span class="keywordflow">if</span> (d_length &gt;= d_capacity) {
          increaseSize();
      }

      <span class="keywordtype">int</span> *item = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span> *<span class="keyword">&gt;</span>(d_pool.<a class="code" href="classbdlma_1_1Pool.html#af8ec09fd2baf0d59ebf139e8c670577f">allocate</a>(<span class="keyword">sizeof</span> *item));
      *item = value;

      d_typeArray_p[d_length]  = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(k_MY_INT);
      d_valueArray_p[d_length] = item;

      ++d_length;
  }

  <span class="keywordtype">void</span> my_IntDoubleArray::appendDouble(<span class="keywordtype">double</span> value)
  {
      <span class="keywordflow">if</span> (d_length &gt;= d_capacity) {
          increaseSize();
      }

      <span class="keywordtype">double</span> *item = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span> *<span class="keyword">&gt;</span>(d_pool.<a class="code" href="classbdlma_1_1Pool.html#af8ec09fd2baf0d59ebf139e8c670577f">allocate</a>(<span class="keyword">sizeof</span> *item));
      *item = value;

      d_typeArray_p[d_length]  = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(k_MY_DOUBLE);
      d_valueArray_p[d_length] = item;

      ++d_length;
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_implementing_an_allocator_using_bdlma~3A~3Asequentialpool"></a> <a class="anchor" id="usage.example_2~3A_implementing_an_allocator_using_bdlma~3A~3Asequentialpool"></a> <a class="anchor" id="description.usage.example_2~3A_implementing_an_allocator_using_bdlma~3A~3Asequentialpool"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Implementing an Allocator Using bdlma::SequentialPool: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> is used throughout the interfaces of BDE components. Suppose we would like to create a fast allocator, <code>my_FastAllocator</code>, that allocates memory from a buffer in a similar fashion to <code><a class="el" href="classbdlma_1_1SequentialPool.html">bdlma::SequentialPool</a></code>. <code><a class="el" href="classbdlma_1_1SequentialPool.html">bdlma::SequentialPool</a></code> can be used directly to implement such an allocator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the documentation for this class is simplified for this usage example. Please see <code>bdlma_sequentialallocator</code> for full documentation of a similar class. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_SequentialAllocator : <span class="keyword">public</span> bslma::Allocator {
      <span class="comment">// This class implements the &#39;bslma::Allocator&#39; protocol to provide a</span>
      <span class="comment">// fast allocator of heterogeneous blocks of memory (of varying,</span>
      <span class="comment">// user-specified sizes) from dynamically-allocated internal buffers.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbdlma_1_1SequentialPool.html">bdlma::SequentialPool</a> d_pool;  <span class="comment">// memory manager for allocated memory</span>
                                     <span class="comment">// blocks</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my_SequentialAllocator(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an allocator for allocating memory blocks from</span>
          <span class="comment">// dynamically-allocated internal buffers.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      ~my_SequentialAllocator();
          <span class="comment">// Destroy this allocator.  All memory allocated from this</span>
          <span class="comment">// allocator is released.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> *allocate(size_type size);
          <span class="comment">// Return the address of a contiguous block of memory of the</span>
          <span class="comment">// specified &#39;size&#39; (in bytes).</span>

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *address);
          <span class="comment">// This method has no effect on the memory block at the specified</span>
          <span class="comment">// &#39;address&#39; as all memory allocated by this allocator is managed.</span>
          <span class="comment">// The behavior is undefined unless &#39;address&#39; was allocated by this</span>
          <span class="comment">// allocator, and has not already been deallocated.</span>
  };

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  my_SequentialAllocator::my_SequentialAllocator(
                                            <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_pool(basicAllocator)
  {
  }

  <span class="keyword">inline</span>
  my_SequentialAllocator::~my_SequentialAllocator()
  {
      d_pool.<a class="code" href="classbdlma_1_1Pool.html#afd51c71be6e7ab898b79e8a0b61090b0">release</a>();
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> *my_SequentialAllocator::allocate(size_type size)
  {
      <span class="keywordflow">return</span> d_pool.<a class="code" href="classbdlma_1_1Pool.html#af8ec09fd2baf0d59ebf139e8c670577f">allocate</a>(size);
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_SequentialAllocator::deallocate(<span class="keywordtype">void</span> *)
  {
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga20c98367f3d271875d6db842cf4d0a0d"></a><!-- doxytag: member="bdlma_sequentialpool.h::operator new" ref="ga20c98367f3d271875d6db842cf4d0a0d" args="(bsl::size_t size, BloombergLP::bdlma::SequentialPool &amp;pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* operator new </td>
          <td>(</td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bdlma::SequentialPool &amp;&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a block of memory of the specified <code>size</code> (in bytes) allocated from the specified <code>pool</code>. Note that an object may allocate additional memory internally, requiring the allocator to be passed in as a constructor argument: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      my_Type *newMyType(<a class="code" href="classbdlma_1_1SequentialPool.html">bdlma::SequentialPool</a> *pool,
                         <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>      *basicAllocator)
      {
          <span class="keywordflow">return</span> <span class="keyword">new</span> (*pool) my_Type(..., basicAllocator);
      }
</pre></div><p><br/>
<br/>
 Also note that the analogous version of operator <code>delete</code> should not be called directly. Instead, this component provides a static template member function, <code>deleteObject</code>, parameterized by <code>TYPE</code> that performs the following: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">void</span> deleteMyType(<a class="code" href="classbdlma_1_1SequentialPool.html">bdlma::SequentialPool</a> *pool, my_Type *t)
      {
          t-&gt;~my_Type();
      }
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ga3ef871e25838522f1ed3cde27f65a0b6"></a><!-- doxytag: member="bdlma_sequentialpool.h::operator delete" ref="ga3ef871e25838522f1ed3cde27f65a0b6" args="(void *address, BloombergLP::bdlma::SequentialPool &amp;pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bdlma::SequentialPool &amp;&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use the specified <code>pool</code> to deallocate the memory at the specified <code>address</code>. The behavior is undefined unless <code>address</code> was allocated using <code>pool</code> and has not already been deallocated. This operator is supplied solely to allow the compiler to arrange for it to be called in case of an exception. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:46 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
