<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlde_charconvertutf16 Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlde_charconvertutf16<br/>
<small>
[<a class="el" href="group__bdlde.html">Package bdlde</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide fast, safe conversion between UTF-8 and UTF-16 encodings.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlde.html">bdlde</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">History and Motivation</a> </li>
<li>
<a href="#3.2">WSTRINGS and UTF-16</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Translation to Fixed-Length Buffers</a> </li>
<li>
<a href="#3.3.2">Example 2: Translation to STL Containers</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide fast, safe conversion between UTF-8 and UTF-16 encodings. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbdlde_1_1CharConvertUtf16.html">bdlde::CharConvertUtf16</a> </td><td>namespace for conversions between UTF-8 and UTF-16  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a suite of static functions supporting the <em>fast</em> conversion of <em>valid</em> UTF-8 encoded strings to <em>valid</em> UTF-16 16-bit word arrays, wstrings, and vectors, and conversion of <em>valid</em> UTF-16 encoded word sequences to <em>valid</em> UTF-8 byte arrays, strings, and byte vectors. Invalid byte sequences and code points forbidden by either encoding are removed and (optionally) replaced by a single word or byte provided by the caller. In UTF-16 -&gt; UTF-8 conversion, the replacement word must be a non-zero byte, in the other direction, it must be a single, non-zero word. The byte or word count and code point count that are optionally returned through pointer arguments include the terminating null code point in their count. The byte order of the UTF-16 input or output can be specified via the optional <code>byteOrder</code> argument, which is assumed to be host byte order if not specified. In functions taking UTF-8, input is in the form of a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> or a null-terminated <code>const char *</code>. In functions taking UTF-16, input is either in the form of a <code><a class="el" href="namespacebslstl.html#adb41ff59615d4ad2799e48a19ed5c1b1">bslstl::StringRefWide</a></code> or a pointer to a null-terminated array of <code>unsigned short</code> or <code>wchar_t</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="history_and_motivation"></a> <a class="anchor" id="description.history_and_motivation"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>History and Motivation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>UTF-8 is an encoding that allows 32-bit character sets like Unicode to be represented using (8-bit) byte strings, while allowing "standard
 ASCII" strings to be used "as-is". Note that UTF-8 is described in detail in RFC 3629 (<a href="http://www.ietf.org/rfc/rfc3629.txt">http://www.ietf.org/rfc/rfc3629.txt</a>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>UTF-16 is a 16-bit encoding that allows Unicode code points up to 0x10ffff to be encoded using one or two 16-bit values. Note that UTF-16 is described in detail in RFC 2781 (<a href="http://www.ietf.org/rfc/rfc2781.txt">http://www.ietf.org/rfc/rfc2781.txt</a>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The functions here that translate to fixed buffers make a single pass through the data. The functions that translate to <code>bsl::string</code>s and STL containers, however, like the <code>glib</code> conversion routines, make two passes: a size estimation pass, after which the output container is sized appropriately, and then the translation pass. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The methods that output to a <code>vector</code>, <code>string</code>, or <code>wstring</code> will all grow the output object as necessary to fit the data, and in the end will exactly resize the object to the output (including the terminating 0 for <code>vector</code>, which is not included for <code>string</code> or <code>wstring</code>). Note that in the case of <code>string</code> or <code>wstring</code>, the terminating 0 code point is still included in the code point count. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Non-minimal UTF-8 encodings of code points are reported as errors. Octets and post-conversion code points in the forbidden ranges are treated as errors and removed (or replaced, if a replacement word is provided). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="wstrings_and_utf-16"></a> <a class="anchor" id="description.wstrings_and_utf-16"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>WSTRINGS and UTF-16: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>UTF-16 (or UTF-8, for that matter) can be stored in <code>wstring</code>s, but note that the size of a <code>wstring::value_type</code>, also known as a <code>wchar_t</code> word, varies across different platforms -- it is 4 bytes on Solaris, Linux, HP-UX, and Darwin, and 2 bytes on AIX and Windows. So a file of <code>wchar_t</code> words written by one platform may not be readable by another. Byte order is also a consideration, and a non-host byte order can be handled by using the optional <code>byteOrder</code> argument of these functions. Another factor is that, since UTF-16 words all fit in 2 bytes, using <code>wchar_t</code> to store UTF-16 is very wasteful of space on many platforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_translation_to_fixed-length_buffers"></a> <a class="anchor" id="usage.example_1~3A_translation_to_fixed-length_buffers"></a> <a class="anchor" id="description.usage.example_1~3A_translation_to_fixed-length_buffers"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Translation to Fixed-Length Buffers: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we will translate a string containing a non-ASCII code point from UTF-16 to UTF-8 and back using fixed-length buffers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create a UTF-16 string spelling <code>ecole</code> in French, which begins with <code>0xc9</code>, a non-ASCII <code>e</code> with an accent over it: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> utf16String[] = { 0xc9, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;o&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, 0 };
</pre></div><br/>
<br/>
 Then, we create a byte buffer to store the UTF-8 result of the translation in, and variables to monitor counts of code points and bytes translated: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">char</span> utf8String[7];
  bsl::size_t numCodePoints, numBytes;
  numCodePoints = numBytes = -1;    <span class="comment">// garbage</span>
</pre></div><br/>
<br/>
 Next, we call <code>utf16ToUtf8</code> to do the translation: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> rc = <a class="code" href="structbdlde_1_1CharConvertUtf16.html#aa8d8dd56e976d2e44746bbe5025cf898">bdlde::CharConvertUtf16::utf16ToUtf8</a>(utf8String,
                                                <span class="keyword">sizeof</span>(utf8String),
                                                utf16String,
                                                &amp;numCodePoints,
                                                &amp;numBytes);
</pre></div><br/>
<br/>
 Then, we observe that no errors or warnings occurred, and that the numbers of code points and bytes were as expected. Note that both <code>numCodePoints</code> and <code>numBytes</code> include the terminating 0: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == rc);
  assert(6 == numCodePoints);
  assert(7 == numBytes);
</pre></div><br/>
<br/>
 Next, we examine the length of the translated string: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(numBytes - 1 == bsl::strlen(utf8String));
</pre></div><br/>
<br/>
 Then, we examine the individual bytes of the translated UTF-8: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert((<span class="keywordtype">char</span>)0xc3 == utf8String[0]);
  assert((<span class="keywordtype">char</span>)0x89 == utf8String[1]);
  assert(<span class="charliteral">&#39;c&#39;</span> ==        utf8String[2]);
  assert(<span class="charliteral">&#39;o&#39;</span> ==        utf8String[3]);
  assert(<span class="charliteral">&#39;l&#39;</span> ==        utf8String[4]);
  assert(<span class="charliteral">&#39;e&#39;</span> ==        utf8String[5]);
  assert(0   ==        utf8String[6]);
</pre></div><br/>
<br/>
 Next, in preparation for translation back to UTF-16, we create a buffer of <code>short</code> values and the variable <code>numWords</code> to track the number of UTF-16 words occupied by the result: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> secondUtf16String[6];
  bsl::size_t numWords;
  numCodePoints = numWords = -1;    <span class="comment">// garbage</span>
</pre></div><br/>
<br/>
 Then, we do the reverse translation: <br/>
<br/>
<div class="fragment"><pre class="fragment">  rc = <a class="code" href="structbdlde_1_1CharConvertUtf16.html#af8825cc14b50735cfba6a9e20dc7a3e1">bdlde::CharConvertUtf16::utf8ToUtf16</a>(secondUtf16String,
                                            6,
                                            utf8String,
                                            &amp;numCodePoints,
                                            &amp;numWords);
</pre></div><br/>
<br/>
 Next, we observe that no errors or warnings were reported, and that the number of code points and words were as expected. Note that <code>numCodePoints</code> and <code>numWords</code> both include the terminating 0: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == rc);
  assert(6 == numCodePoints);
  assert(6 == numWords);
</pre></div><br/>
<br/>
 Now, we observe that our output is identical to the original UTF-16 string: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == bsl::memcmp(utf16String,
                          secondUtf16String,
                          <span class="keyword">sizeof</span>(utf16String)));
</pre></div><br/>
<br/>
 Finally, we examine the individual words of the reverse translation: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0xc9 == secondUtf16String[0]);
  assert(<span class="charliteral">&#39;c&#39;</span>  == secondUtf16String[1]);
  assert(<span class="charliteral">&#39;o&#39;</span>  == secondUtf16String[2]);
  assert(<span class="charliteral">&#39;l&#39;</span>  == secondUtf16String[3]);
  assert(<span class="charliteral">&#39;e&#39;</span>  == secondUtf16String[4]);
  assert(0    == secondUtf16String[5]);
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_translation_to_stl_containers"></a> <a class="anchor" id="usage.example_2~3A_translation_to_stl_containers"></a> <a class="anchor" id="description.usage.example_2~3A_translation_to_stl_containers"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Translation to STL Containers: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippets of code illustrate a typical use of the <code><a class="el" href="structbdlde_1_1CharConvertUtf16.html">bdlde::CharConvertUtf16</a></code> struct's utility functions, first converting from UTF-8 to UTF-16, and then converting back to make sure the round trip returns the same value, translating to STL containers in both directions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we declare a string of UTF-8 containing single-, double-, triple-, and quadruple-octet code points: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">char</span> utf8MultiLang[] = {
      <span class="stringliteral">&quot;Hello&quot;</span>                                         <span class="comment">// -- ASCII</span>
      <span class="stringliteral">&quot;\xce\x97&quot;</span>         <span class="stringliteral">&quot;\xce\x95&quot;</span>       <span class="stringliteral">&quot;\xce\xbb&quot;</span>  <span class="comment">// -- Greek</span>
      <span class="stringliteral">&quot;\xe4\xb8\xad&quot;</span>     <span class="stringliteral">&quot;\xe5\x8d\x8e&quot;</span>               <span class="comment">// -- Chinese</span>
      <span class="stringliteral">&quot;\xe0\xa4\xad&quot;</span>     <span class="stringliteral">&quot;\xe0\xa4\xbe&quot;</span>               <span class="comment">// -- Hindi</span>
      <span class="stringliteral">&quot;\xf2\x94\xb4\xa5&quot;</span> <span class="stringliteral">&quot;\xf3\xb8\xac\x83&quot;</span> };        <span class="comment">// -- Quad octets</span>
</pre></div><br/>
<br/>
 Then, we declare an <code>enum</code> summarizing the counts of code points in the string and verify that the counts add up to the length of the string: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { NUM_ASCII_CODE_POINTS   = 5,
         NUM_GREEK_CODE_POINTS   = 3,
         NUM_CHINESE_CODE_POINTS = 2,
         NUM_HINDI_CODE_POINTS   = 2,
         NUM_QUAD_CODE_POINTS    = 2 };

  assert(1 * NUM_ASCII_CODE_POINTS +
         2 * NUM_GREEK_CODE_POINTS +
         3 * NUM_CHINESE_CODE_POINTS +
         3 * NUM_HINDI_CODE_POINTS +
         4 * NUM_QUAD_CODE_POINTS == bsl::strlen(utf8MultiLang));
</pre></div><br/>
<br/>
 Next, we declare the vector where our UTF-16 output will go, and a variable into which the number of code points (not bytes or words) written will be stored. It is not necessary to initialize <code>utf16CodePointsWritten</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;unsigned short&gt;</a> v16;
  bsl::size_t utf16CodePointsWritten;
</pre></div><br/>
<br/>
 Note that for performance, we should <code>v16.reserve(sizeof(utf8MultiLang))</code>, but it's not strictly necessary -- the vector will automatically be grown to the correct size. Also note that if <code>v16</code> were not empty, that wouldn't be a problem -- any contents will be discarded. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we do the translation to UTF-16: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> retVal = <a class="code" href="structbdlde_1_1CharConvertUtf16.html#af8825cc14b50735cfba6a9e20dc7a3e1">bdlde::CharConvertUtf16::utf8ToUtf16</a>(&amp;v16,
                                                    utf8MultiLang,
                                                    &amp;utf16CodePointsWritten);

  assert(0 == retVal);        <span class="comment">// verify success</span>
  assert(0 == v16.<a class="code" href="group__bslstl__vector.html#gad737a7196152ddb07b059506a070d149">back</a>());    <span class="comment">// verify null terminated</span>
</pre></div><br/>
<br/>
 Next, we verify that the number of code points (not bytes or words) that was returned is correct: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { EXPECTED_CODE_POINTS_WRITTEN =
                      NUM_ASCII_CODE_POINTS + NUM_GREEK_CODE_POINTS +
                      NUM_CHINESE_CODE_POINTS + NUM_HINDI_CODE_POINTS +
                      NUM_QUAD_CODE_POINTS  + 1 };

  assert(EXPECTED_CODE_POINTS_WRITTEN == utf16CodePointsWritten);
</pre></div><br/>
<br/>
 Then, we verify that the number of 16-bit words written was correct. The quad octet code points each require 2 <code>short</code> words of output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { EXPECTED_UTF16_WORDS_WRITTEN =
                      NUM_ASCII_CODE_POINTS + NUM_GREEK_CODE_POINTS +
                      NUM_CHINESE_CODE_POINTS + NUM_HINDI_CODE_POINTS +
                      NUM_QUAD_CODE_POINTS * 2 + 1 };

  assert(EXPECTED_UTF16_WORDS_WRITTEN == v16.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>());
</pre></div><br/>
<br/>
 Next, we calculate and confirm the difference between the number of UTF-16 words output and the number of bytes input. The ASCII code points will take 1 16-bit word apiece, the Greek code points are double octets that will become single <code>short</code> values, the Chinese code points are encoded as UTF-8 triple octets that will turn into single 16-bit words, the same for the Hindi code points, and the quad code points are quadruple octets that will turn into double <code>short</code> values: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { SHRINKAGE = NUM_ASCII_CODE_POINTS   * (1-1) +
                     NUM_GREEK_CODE_POINTS   * (2-1) +
                     NUM_CHINESE_CODE_POINTS * (3-1) +
                     NUM_HINDI_CODE_POINTS   * (3-1) +
                     NUM_QUAD_CODE_POINTS    * (4-2) };

  assert(v16.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>() == <span class="keyword">sizeof</span>(utf8MultiLang) - SHRINKAGE);
</pre></div><br/>
<br/>
 Then, we go on to do the reverse <code>utf16ToUtf8</code> transform to turn it back into UTF-8, and we should get a result identical to our original input. We declare a <code>bsl::string</code> for our output, and a variable to count the number of code points (not bytes or words) translated: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> s;
  bsl::size_t uf8CodePointsWritten;
</pre></div><br/>
<br/>
 Again, note that for performance, we should ideally <code>s.reserve(3 * v16.size())</code> but it's not really necessary. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Now, we do the reverse transform: <br/>
<br/>
<div class="fragment"><pre class="fragment">  retVal = <a class="code" href="structbdlde_1_1CharConvertUtf16.html#aa8d8dd56e976d2e44746bbe5025cf898">bdlde::CharConvertUtf16::utf16ToUtf8</a>(&amp;s,
                                                v16.<a class="code" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a>(),
                                                &amp;uf8CodePointsWritten);
</pre></div><br/>
<br/>
 Finally, we verify that a successful status was returned, that the output of the reverse transform was identical to the original input, and that the number of code points translated was as expected: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == retVal);
  assert(utf8MultiLang == s);
  assert(s.<a class="code" href="group__bslstl__string.html#ga3c33f63f9d195be7499bd2f7cdb085ff">length</a>() + 1               == <span class="keyword">sizeof</span>(utf8MultiLang));

  assert(EXPECTED_CODE_POINTS_WRITTEN == uf8CodePointsWritten);
  assert(utf16CodePointsWritten       == uf8CodePointsWritten);
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:43 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
