<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlde_charconvertutf16 Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlde_charconvertutf16<br/>
<small>
[<a class="el" href="group__bdlde.html">Package bdlde</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide fast, safe conversion between UTF-8 and UTF-16 encodings.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlde.html">bdlde</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">History and Motivation</a> </li>
<li>
<a href="#3.2">WSTRINGS and UTF-16</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Translation to Fixed-Length Buffers</a> </li>
<li>
<a href="#3.3.2">Example 2: Translation to STL Containers</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide fast, safe conversion between UTF-8 and UTF-16 encodings. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbdlde_1_1CharConvertUtf16.html">bdlde::CharConvertUtf16</a> </td><td>namespace for conversions between UTF-8 and UTF-16  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a suite of static functions supporting the <em>fast</em> conversion of <em>valid</em> UTF-8 encoded strings to <em>valid</em> UTF-16 16-bit character arrays, wstrings, and vectors, and conversion of <em>valid</em> UTF-16 encoded strings to <em>valid</em> UTF-8 character arrays, strings, and character vectors. Invalid byte sequences and characters forbidden by either encoding are removed and (optionally) replaced by a character provided by the caller. The byte or word count and character count that are optionally returned through pointer arguments include the terminating null character, if any, in their count. The byte order of the UTF-16 input or output can be specified via the optional <code>byteOrder</code> argument, which is assumed to be host byte order if not specified. In functions taking UTF-8, input is in the form of a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> or a null-terminated <code>const char *</code>. In functions taking UTF-16, input is either in the form of a <code><a class="el" href="namespacebslstl.html#adb41ff59615d4ad2799e48a19ed5c1b1">bslstl::StringRefWide</a></code> or a pointer to a null-terminated array of <code>unsigned short</code> or <code>wchar_t</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="history_and_motivation"></a> <a class="anchor" id="description.history_and_motivation"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>History and Motivation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>UTF-8 is a character encoding that allows 32-bit character sets like Unicode to be represented using (8-bit) byte strings, while allowing "standard
 ASCII" strings to be used "as-is". Note that UTF-8 is described in detail in RFC 3629 (<a href="http://www.ietf.org/rfc/rfc3629.txt">http://www.ietf.org/rfc/rfc3629.txt</a>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>UTF-16 is a 16-bit character encoding that allows Unicode characters up to 0x10ffff to be encoded using one or two 16-bit values. Note that UTF-16 is described in detail in RFC 2781 (<a href="http://www.ietf.org/rfc/rfc2781.txt">http://www.ietf.org/rfc/rfc2781.txt</a>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The functions here that translate to fixed buffers make a single pass through the data. The functions that translate to <code>bsl::string</code>s and STL containers, however, like the <code>glib</code> conversion routines, make two passes: a size estimation pass, after which the output container is sized appropriately if necessary, and then the translation pass. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The methods that output to a <code>vector</code>, <code>string</code>, or <code>wstring</code> will all grow the output object as necessary to fit the data, and in the end will exactly resize the object to the output (including the terminating 0 for <code>vector</code>, which is not included for <code>string</code> or <code>wstring</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Non-minimal UTF-8 encodings of characters are reported as errors. Octets and post-conversion characters in the forbidden ranges are treated as errors and removed (or replaced, if a replacement character is provided). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="wstrings_and_utf-16"></a> <a class="anchor" id="description.wstrings_and_utf-16"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>WSTRINGS and UTF-16: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>UTF-16 (or UTF-8, for that matter) can be stored in <code>wstring</code>s, but note that the size of a <code>wstring::value_type</code>, also known as a <code>wchar_t</code> character, varies across different platforms -- it is 4 bytes on Solaris, Linux, HP-UX, and Darwin, and 2 bytes on AIX and Windows. So a file of <code>wchar_t</code> characters written by one platform may not be readable by another. Byte order is also a consideration, and a non-host byte order can be handled by using the optional <code>byteOrder</code> argument of these functions. Another factor is that, since UTF-16 words all fit in 2 bytes, using <code>wchar_t</code> to store UTF-16 is very wasteful of space on many platforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_translation_to_fixed-length_buffers"></a> <a class="anchor" id="usage.example_1~3A_translation_to_fixed-length_buffers"></a> <a class="anchor" id="description.usage.example_1~3A_translation_to_fixed-length_buffers"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Translation to Fixed-Length Buffers: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we will translate a string containing a non-ASCII character from UTF-16 to UTF-8 and back using fixed-length buffers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create a UTF-16 string spelling <code>ecole</code> in French, which begins with <code>0xc9</code>, a non-ASCII <code>e</code> with an accent over it: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> utf16String[] = { 0xc9, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;o&#39;</span>, <span class="charliteral">&#39;l&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, 0 };
</pre></div><br/>
<br/>
 Then, we create a byte buffer to store the UTF-8 result of the translation in, and variables to monitor counts of characters and bytes translated: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">char</span> utf8String[7];
  bsl::size_t numChars, numBytes;
  numChars = numBytes = -1;    <span class="comment">// garbage</span>
</pre></div><br/>
<br/>
 Next, we call <code>utf16ToUtf8</code> to do the translation: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> rc = <a class="code" href="structbdlde_1_1CharConvertUtf16.html#a914ab31260aa95b1f3de35111b7b43fa">bdlde::CharConvertUtf16::utf16ToUtf8</a>(utf8String,
                                               <span class="keyword">sizeof</span>(utf8String),
                                               utf16String,
                                               &amp;numChars,
                                               &amp;numBytes);
</pre></div><br/>
<br/>
 Then, we observe that no errors or warnings occurred, and that the numbers of characters and bytes were as expected. Note that both <code>numChars</code> and <code>numBytes</code> include the terminating 0: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == rc);
  assert(6 == numChars);
  assert(7 == numBytes);
</pre></div><br/>
<br/>
 Next, we examine the length of the translated string: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(numBytes - 1 == bsl::strlen(utf8String));
</pre></div><br/>
<br/>
 Then, we examine the individual bytes of the translated UTF-8: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert((<span class="keywordtype">char</span>)0xc3 == utf8String[0]);
  assert((<span class="keywordtype">char</span>)0x89 == utf8String[1]);
  assert(<span class="charliteral">&#39;c&#39;</span> ==        utf8String[2]);
  assert(<span class="charliteral">&#39;o&#39;</span> ==        utf8String[3]);
  assert(<span class="charliteral">&#39;l&#39;</span> ==        utf8String[4]);
  assert(<span class="charliteral">&#39;e&#39;</span> ==        utf8String[5]);
  assert(0   ==        utf8String[6]);
</pre></div><br/>
<br/>
 Next, in preparation for translation back to UTF-16, we create a buffer of <code>short</code> values and the variable <code>numWords</code> to track the number of UTF-16 words occupied by the result: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> secondUtf16String[6];
  bsl::size_t numWords;
  numChars = numWords = -1;    <span class="comment">// garbage</span>
</pre></div><br/>
<br/>
 Then, we do the reverse translation: <br/>
<br/>
<div class="fragment"><pre class="fragment">  rc = <a class="code" href="structbdlde_1_1CharConvertUtf16.html#aed0c2c39a68a4ab14372b8285ca9019e">bdlde::CharConvertUtf16::utf8ToUtf16</a>(secondUtf16String,
                                           6,
                                           utf8String,
                                           &amp;numChars,
                                           &amp;numWords);
</pre></div><br/>
<br/>
 Next, we observe that no errors or warnings were reported, and that the number of characters and words were as expected. Note that <code>numChars</code> and <code>numWords</code> both include the terminating 0: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == rc);
  assert(6 == numChars);
  assert(6 == numWords);
</pre></div><br/>
<br/>
 Now, we observe that our output is identical to the original UTF-16 string: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == bsl::memcmp(utf16String,
                          secondUtf16String,
                          <span class="keyword">sizeof</span>(utf16String)));
</pre></div><br/>
<br/>
 Finally, we examine the individual words of the reverse translation: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0xc9 == secondUtf16String[0]);
  assert(<span class="charliteral">&#39;c&#39;</span>  == secondUtf16String[1]);
  assert(<span class="charliteral">&#39;o&#39;</span>  == secondUtf16String[2]);
  assert(<span class="charliteral">&#39;l&#39;</span>  == secondUtf16String[3]);
  assert(<span class="charliteral">&#39;e&#39;</span>  == secondUtf16String[4]);
  assert(0    == secondUtf16String[5]);
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_translation_to_stl_containers"></a> <a class="anchor" id="usage.example_2~3A_translation_to_stl_containers"></a> <a class="anchor" id="description.usage.example_2~3A_translation_to_stl_containers"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Translation to STL Containers: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippets of code illustrate a typical use of the <code><a class="el" href="structbdlde_1_1CharConvertUtf16.html">bdlde::CharConvertUtf16</a></code> struct's utility functions, first converting from UTF-8 to UTF-16, and then converting back to make sure the round trip returns the same value, translating to STL containers in both directions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we declare a string of UTF-8 containing single-, double-, triple-, and quadruple-octet characters: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">char</span> utf8MultiLang[] = {
      <span class="stringliteral">&quot;Hello&quot;</span>                                         <span class="comment">// -- ASCII</span>
      <span class="stringliteral">&quot;\xce\x97&quot;</span>         <span class="stringliteral">&quot;\xce\x95&quot;</span>       <span class="stringliteral">&quot;\xce\xbb&quot;</span>  <span class="comment">// -- Greek</span>
      <span class="stringliteral">&quot;\xe4\xb8\xad&quot;</span>     <span class="stringliteral">&quot;\xe5\x8d\x8e&quot;</span>               <span class="comment">// -- Chinese</span>
      <span class="stringliteral">&quot;\xe0\xa4\xad&quot;</span>     <span class="stringliteral">&quot;\xe0\xa4\xbe&quot;</span>               <span class="comment">// -- Hindi</span>
      <span class="stringliteral">&quot;\xf2\x94\xb4\xa5&quot;</span> <span class="stringliteral">&quot;\xf3\xb8\xac\x83&quot;</span> };        <span class="comment">// -- Quad octets</span>
</pre></div><br/>
<br/>
 Then, we declare an <code>enum</code> summarizing the counts of characters in the string and verify that the counts add up to the length of the string: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { NUM_ASCII_CHARS   = 5,
         NUM_GREEK_CHARS   = 3,
         NUM_CHINESE_CHARS = 2,
         NUM_HINDI_CHARS   = 2,
         NUM_QUAD_CHARS    = 2 };

  assert(1 * NUM_ASCII_CHARS +
         2 * NUM_GREEK_CHARS +
         3 * NUM_CHINESE_CHARS +
         3 * NUM_HINDI_CHARS +
         4 * NUM_QUAD_CHARS == bsl::strlen(utf8MultiLang));
</pre></div><br/>
<br/>
 Next, we declare the vector where our UTF-16 output will go, and a variable into which the number of characters (characters, not bytes or words) written will be stored. It is not necessary to initialize <code>utf16CharsWritten</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;unsigned short&gt;</a> v16;
  bsl::size_t utf16CharsWritten;
</pre></div><br/>
<br/>
 Note that for performance, we should <code>v16.reserve(sizeof(utf8MultiLang))</code>, but it's not strictly necessary -- the vector will automatically be grown to the correct size. Also note that if <code>v16</code> were not empty, that wouldn't be a problem -- any contents will be discarded. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we do the translation to UTF-16: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> retVal = <a class="code" href="structbdlde_1_1CharConvertUtf16.html#aed0c2c39a68a4ab14372b8285ca9019e">bdlde::CharConvertUtf16::utf8ToUtf16</a>(&amp;v16,
                                                   utf8MultiLang,
                                                   &amp;utf16CharsWritten);

  assert(0 == retVal);        <span class="comment">// verify success</span>
  assert(0 == v16.<a class="code" href="group__bslstl__vector.html#gad737a7196152ddb07b059506a070d149">back</a>());    <span class="comment">// verify null terminated</span>
</pre></div><br/>
<br/>
 Next, we verify that the number of characters (characters, not bytes or words) that was returned is correct: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { EXPECTED_CHARS_WRITTEN =
                      NUM_ASCII_CHARS + NUM_GREEK_CHARS + NUM_CHINESE_CHARS +
                      NUM_HINDI_CHARS + NUM_QUAD_CHARS  + 1 };
  assert(EXPECTED_CHARS_WRITTEN == utf16CharsWritten);
</pre></div><br/>
<br/>
 Then, we verify that the number of 16-bit words written was correct. The quad octet characters each require 2 <code>short</code> words of output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { EXPECTED_UTF16_WORDS_WRITTEN =
                      NUM_ASCII_CHARS + NUM_GREEK_CHARS + NUM_CHINESE_CHARS +
                      NUM_HINDI_CHARS + NUM_QUAD_CHARS * 2 + 1 };

  assert(EXPECTED_UTF16_WORDS_WRITTEN == v16.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>());
</pre></div><br/>
<br/>
 Next, we calculate and confirm the difference between the number of UTF-16 words output and the number of bytes input. The ASCII characters will take 1 16-bit word apiece, the Greek characters are double octets that will become single <code>short</code> values, the Chinese characters are encoded as UTF-8 triple octets that will turn into single 16-bit words, the same for the Hindi characters, and the quad characters are quadruple octets that will turn into double <code>short</code> values: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { SHRINKAGE = NUM_ASCII_CHARS   * (1-1) + NUM_GREEK_CHARS * (2-1) +
                     NUM_CHINESE_CHARS * (3-1) + NUM_HINDI_CHARS * (3-1) +
                     NUM_QUAD_CHARS    * (4-2) };

  assert(v16.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>() == <span class="keyword">sizeof</span>(utf8MultiLang) - SHRINKAGE);
</pre></div><br/>
<br/>
 Then, we go on to do the reverse <code>utf16ToUtf8</code> transform to turn it back into UTF-8, and we should get a result identical to our original input. We declare a <code>bsl::string</code> for our output, and a variable to count the number of characters (characters, not bytes or words) translated: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> s;
  bsl::size_t utf8CharsWritten;
</pre></div><br/>
<br/>
 Again, note that for performance, we should ideally <code>s.reserve(3 * v16.size())</code> but it's not really necessary. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Now, we do the reverse transform: <br/>
<br/>
<div class="fragment"><pre class="fragment">  retVal = <a class="code" href="structbdlde_1_1CharConvertUtf16.html#a914ab31260aa95b1f3de35111b7b43fa">bdlde::CharConvertUtf16::utf16ToUtf8</a>(&amp;s,
                                               v16.<a class="code" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a>(),
                                               &amp;utf8CharsWritten);
</pre></div><br/>
<br/>
 Finally, we verify that a successful status was returned, that the output of the reverse transform was identical to the original input, and that the number of characters translated was as expected: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == retVal);
  assert(utf8MultiLang == s);
  assert(s.<a class="code" href="group__bslstl__string.html#ga3c33f63f9d195be7499bd2f7cdb085ff">length</a>() + 1         == <span class="keyword">sizeof</span>(utf8MultiLang));

  assert(EXPECTED_CHARS_WRITTEN == utf8CharsWritten);
  assert(utf16CharsWritten      == utf8CharsWritten);
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:42 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
