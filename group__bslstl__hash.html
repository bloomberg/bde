<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslstl_hash Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_hash<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a namespace for hash functions.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash.html">bsl::hash&lt; TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01const_01BSLSTL__KEY_01_4.html">bsl::hash&lt; const BSLSTL_KEY &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01bool_01_4.html">bsl::hash&lt; bool &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01char_01_4.html">bsl::hash&lt; char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01signed_01char_01_4.html">bsl::hash&lt; signed char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01unsigned_01char_01_4.html">bsl::hash&lt; unsigned char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01wchar__t_01_4.html">bsl::hash&lt; wchar_t &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01short_01_4.html">bsl::hash&lt; short &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01unsigned_01short_01_4.html">bsl::hash&lt; unsigned short &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01int_01_4.html">bsl::hash&lt; int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01unsigned_01int_01_4.html">bsl::hash&lt; unsigned int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01long_01_4.html">bsl::hash&lt; long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01unsigned_01long_01_4.html">bsl::hash&lt; unsigned long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01long_01long_01_4.html">bsl::hash&lt; long long &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1hash_3_01unsigned_01long_01long_01_4.html">bsl::hash&lt; unsigned long long &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga0fce4aba03c8d11f4b06fa6088a0b08f">bsl::hash&lt; bool &gt;::result_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga889f9944d98561842e62eab7cb434d59">bsl::hash&lt; char &gt;::result_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga001a8bf528cccf39d9e663e34454c10e">bsl::hash&lt; signed char &gt;::result_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga313b8db35282fccd4581263ebe116bda">bsl::hash&lt; unsigned char &gt;::result_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga04401e8d427f52c59f03788c53f5ebff">bsl::hash&lt; wchar_t &gt;::result_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gaf78a39c5b2112271d15c495602109091">bsl::hash&lt; short &gt;::result_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga5706dd45dc52b64c8385e5d86c2b7182">bsl::hash&lt; unsigned short &gt;::result_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gacfad0aed76f7af7a67d73b2673f87bce">bsl::hash&lt; int &gt;::result_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga9f7047490324e12dfd02ea3f037867c7">bsl::hash&lt; unsigned int &gt;::result_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga5528a188abf2c07b630d8f39b45702d5">bsl::hash&lt; long &gt;::result_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga7da1e1af882df7aebac8c3b715fed712">bsl::hash&lt; unsigned long &gt;::result_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga054a78a337e1464e93507a6aaa3d793f">bsl::hash&lt; long long &gt;::result_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gaced1104fd69e7b4d2a953adfce37898c">bsl::hash&lt; unsigned long long &gt;::result_type</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga50e9c530dd61a84ce79244dffbccf916">bsl::hash&lt; bool &gt;::hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gadf1f06f8cb641056ec6bd0c1b94ac790">bsl::hash&lt; bool &gt;::hash</a> (const hash &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gae5eb5721ac592790ff99fc1453b3ff52">bsl::hash&lt; bool &gt;::~hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hash &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga7479bdd278b4c0798e493a14aaefa83b">bsl::hash&lt; bool &gt;::operator=</a> (const hash &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga31688073287a0ed6aa2a707b47f64e92">bsl::hash&lt; bool &gt;::operator()</a> (bool x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gadaf857d99a99f7510c92a8c213422ea9">bsl::hash&lt; char &gt;::hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga15c44c96fba068a6e4469d06f3a8a810">bsl::hash&lt; char &gt;::hash</a> (const hash &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga4971fce47c3c12fe29d1cc467cceeaf4">bsl::hash&lt; char &gt;::~hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hash &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga39d210965ec47de39c4f45aa1d1b97de">bsl::hash&lt; char &gt;::operator=</a> (const hash &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga1ba276f3e34920a452d32419757898be">bsl::hash&lt; char &gt;::operator()</a> (char x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gac0cbbb3b22110097b310e9add1230a9a">bsl::hash&lt; signed char &gt;::hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga1b59d41740c08d0ef469cc2e17f76171">bsl::hash&lt; signed char &gt;::hash</a> (const hash &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga2c96a55b52a290340fcf50f04fe0a4d6">bsl::hash&lt; signed char &gt;::~hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hash &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga6da275994c944cbc73410ef36b4abb85">bsl::hash&lt; signed char &gt;::operator=</a> (const hash &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gaf3020fd8281f75f301194300e3dc39c2">bsl::hash&lt; signed char &gt;::operator()</a> (signed char x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga881f12e5a193656e38fb5144860b1d5c">bsl::hash&lt; unsigned char &gt;::hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gad3461f9237b42eb6b3a41ea19c3c8a90">bsl::hash&lt; unsigned char &gt;::hash</a> (const hash &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gac750f1094615f7db84f2924bf87f1709">bsl::hash&lt; unsigned char &gt;::~hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hash &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga12b15da342cfda224a22e1a70d8b88e0">bsl::hash&lt; unsigned char &gt;::operator=</a> (const hash &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga18b3a3003ad5103d61791a880b8fd7fd">bsl::hash&lt; unsigned char &gt;::operator()</a> (unsigned char x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga533ade165c4bb3d2a864550d875dd7a6">bsl::hash&lt; wchar_t &gt;::hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga51ef16eaf23b9ac1d34d5dde76adb21a">bsl::hash&lt; wchar_t &gt;::hash</a> (const hash &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga25fc32f277b2b11d703385c4f6228ff6">bsl::hash&lt; wchar_t &gt;::~hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hash &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga7c0a983f9517108776aa0cf94cfd577e">bsl::hash&lt; wchar_t &gt;::operator=</a> (const hash &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga34b3b3046930355218d9854b5e9fdfcb">bsl::hash&lt; wchar_t &gt;::operator()</a> (wchar_t x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gac4acb2a25de35e7b19edd1ac9d2494da">bsl::hash&lt; short &gt;::hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gac31d68aeb125f8eb807245e50cce7511">bsl::hash&lt; short &gt;::hash</a> (const hash &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga732cbd2c611c475cc8aa181928bbc180">bsl::hash&lt; short &gt;::~hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hash &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga7b849b4291985726747ef02c566e4e76">bsl::hash&lt; short &gt;::operator=</a> (const hash &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga02f5dc540d7ff4047a8678950f639485">bsl::hash&lt; short &gt;::operator()</a> (short x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga3aed18cec12c5069948626f59af1c3fe">bsl::hash&lt; unsigned short &gt;::hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga2c0104f9906dcdfa950600fdff1a71d6">bsl::hash&lt; unsigned short &gt;::hash</a> (const hash &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga12e60ad33728baae2f2c0fc28fa51a7f">bsl::hash&lt; unsigned short &gt;::~hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hash &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gacbc05697d04173217be33feba49281a6">bsl::hash&lt; unsigned short &gt;::operator=</a> (const hash &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gaf1456c38fc71fea828f2808bc6439ca2">bsl::hash&lt; unsigned short &gt;::operator()</a> (unsigned short x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga76ac234abbbeec9b496718a91798a624">bsl::hash&lt; int &gt;::hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga7fe8ad4f59ebdd7b1bdd9ec72c645161">bsl::hash&lt; int &gt;::hash</a> (const hash &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga824c0e4eea084027718116bae06ad2f9">bsl::hash&lt; int &gt;::~hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hash &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga05cf21e1ece5899eaf01629d1b5a06cc">bsl::hash&lt; int &gt;::operator=</a> (const hash &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gaa1252f2ccf9dcc93579a09382ce8de79">bsl::hash&lt; int &gt;::operator()</a> (int x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gaf373e8ee6003abe5da5477b41851b117">bsl::hash&lt; unsigned int &gt;::hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gad14c449cc79dd0d56c7b3cef70bb6d43">bsl::hash&lt; unsigned int &gt;::hash</a> (const hash &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga126597bb08531c9fb3ab06a625802ae6">bsl::hash&lt; unsigned int &gt;::~hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hash &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gada6c32193811bf1abb768adff863b03c">bsl::hash&lt; unsigned int &gt;::operator=</a> (const hash &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gabfdde9afffd6b103bd59064e7a0b73d8">bsl::hash&lt; unsigned int &gt;::operator()</a> (unsigned int x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gadb6e3fa5cb48d06c803ae95bb74c3ed5">bsl::hash&lt; long &gt;::hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gaef3296dc6c616da725be61da27aeea96">bsl::hash&lt; long &gt;::hash</a> (const hash &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga8947395f9754a436e4f8443b62febbbd">bsl::hash&lt; long &gt;::~hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hash &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga7167861fed40f00de02f0c971b31e4bd">bsl::hash&lt; long &gt;::operator=</a> (const hash &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga951f1b61404f4c229565a658ad49d43b">bsl::hash&lt; long &gt;::operator()</a> (long x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga593b8834e07ac9178b950fc2d7784c10">bsl::hash&lt; unsigned long &gt;::hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gafbecd3dd0769ec2d9031492af2614157">bsl::hash&lt; unsigned long &gt;::hash</a> (const hash &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga558101438b4131661d025aaa1610e143">bsl::hash&lt; unsigned long &gt;::~hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hash &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gaca62f43d8039734f888d7ff411a2df77">bsl::hash&lt; unsigned long &gt;::operator=</a> (const hash &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gadeb18bd3fba4f7ddd77107ced3ec596f">bsl::hash&lt; unsigned long &gt;::operator()</a> (unsigned long x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#gaf91ac9f794b4ce354acf96b86909549b">bsl::hash&lt; long long &gt;::hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga9fb87f17cb96f2b08e1da3ada2e3e25c">bsl::hash&lt; long long &gt;::hash</a> (const hash &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga4c3e488a7f20553b479cb22e12ac55ea">bsl::hash&lt; long long &gt;::~hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hash &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga78badfc16a088af5fbe0a6923c838549">bsl::hash&lt; long long &gt;::operator=</a> (const hash &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga59823e0c49cedf948b5b068aa50e0cf0">bsl::hash&lt; long long &gt;::operator()</a> (long long x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga9e299f26fea9227e9586ce9ef96b8f31">bsl::hash&lt; unsigned long long &gt;::hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga876d0cbda27ed768797eff37237fbff8">bsl::hash&lt; unsigned long long &gt;::hash</a> (const hash &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga8b2a08bbb2c71972d7ba636c98ddc0da">bsl::hash&lt; unsigned long long &gt;::~hash</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hash &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga38380a625f45f8510f8fd2700c210248">bsl::hash&lt; unsigned long long &gt;::operator=</a> (const hash &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__hash.html#ga919e68c590738a9b25b9668f56305c6b">bsl::hash&lt; unsigned long long &gt;::operator()</a> (unsigned long long x) const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Standard Hash Function</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Creating and Using a Hash Cross Reference</a> </li>
<li>
<a href="#3.2.2">Example 2: Using <code>hashAppend</code> from <code>bslh</code> with <code>HashCrossReference</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a namespace for hash functions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbsl_1_1hash.html">bsl::hash</a> </td><td>hash function for fundamental types  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bsl+stdhdrs </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a template unary functor, <code><a class="el" href="structbsl_1_1hash.html">bsl::hash</a></code>, implementing the <code>std::hash</code> functor. <code><a class="el" href="structbsl_1_1hash.html">bsl::hash</a></code> applies a C++ standard compliant, implementation defined, hash function to fundamental types returning the result of such application. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="standard_hash_function"></a> <a class="anchor" id="description.standard_hash_function"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Standard Hash Function: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>According to the C++ standard the requirements of a standard hash function <code>h</code> are: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
Return a <code>size_t</code> value between 0 and <code>numeric_limits&lt;std::size_t&gt;max()</code>.  </li>
<li>
The value returned must depend only on the argument <code>k</code>. For multiple evaluations with the same argument <code>k</code>, the value returned must be always the same.  </li>
<li>
The function should not modify its argument.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_creating_and_using_a_hash_cross_reference"></a> <a class="anchor" id="usage.example_1~3A_creating_and_using_a_hash_cross_reference"></a> <a class="anchor" id="description.usage.example_1~3A_creating_and_using_a_hash_cross_reference"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating and Using a Hash Cross Reference: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we already have an array of unique values of type <code>TYPE</code>, for which <code>operator==</code> is defined, and we want to be able to quickly look up whether an element is in the array, without exhaustively applying <code>operator==</code> to all the elements in sequence. The array itself is guaranteed not to change for the duration of our interest in it. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The problem is much simpler than building a general-purpose hash table, because we know how many elements our cross reference will contain in advance, so we will never have to dynamically grow the number of <code>buckets</code>. We do not need to copy the values into our own area, so we don't have to create storage for them, or require that a copy constructor or destructor be available. We only require that they have a transitive, symmetric equivalence operation <code>bool operator==</code> and that a hash function be provided. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We will need a hash function -- the hash function is a function that will take as input an object of the type stored in our array, and yield a <code>size_t</code> value which will be very randomized. Ideally, the slightest change in the value of the <code>TYPE</code> object will result in a large change in the value returned by the hash function. In a good hash function, typically half the bits of the return value will change for a 1-bit change in the hashed value. We then use the result of the hash function to index into our array of <code>buckets</code>. Each <code>bucket</code> is simply a pointer to a value in our original array of <code>TYPE</code> objects. We will resolve hash collisions in our array through <code>linear probing</code>, where we will search consecutive buckets following the bucket where the collision occurred, testing occupied buckets for equality with the value we are searching on, and concluding that the value is not in the table if we encounter an empty bucket before we encounter one referring to an equal element. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An important quality of the hash function is that if two values are equivalent, they must yield the same hash value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define our <code>HashCrossReference</code> template class, with the two type parameters <code>TYPE" (the type being referenced</code> and <code>HASHER</code>, which defaults to <code><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt;TYPE&gt;</code>. For common types of <code>TYPE</code> such as <code>int</code>, a specialization of <code><a class="el" href="structbsl_1_1hash.html">bsl::hash</a></code> is already defined: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE, <span class="keyword">class</span> HASHER = bsl::hash&lt;TYPE&gt; &gt;
  <span class="keyword">class </span>HashCrossReference {
      <span class="comment">// This table leverages a hash table to provide a fast lookup of an</span>
      <span class="comment">// external, non-owned, array of values of configurable type.</span>
      <span class="comment">//</span>
      <span class="comment">// The only requirement for &#39;TYPE&#39; is that it have a transitive,</span>
      <span class="comment">// symmetric &#39;operator==&#39; function.  There is no requirement that it</span>
      <span class="comment">// have any kind of creator defined.</span>
      <span class="comment">//</span>
      <span class="comment">// The &#39;HASHER&#39; template parameter type must be a functor with a</span>
      <span class="comment">// function of the following signature:</span>
      <span class="comment">//..</span>
      <span class="comment">//  size_t operator()(const TYPE)  const; or</span>
      <span class="comment">//  size_t operator()(const TYPE&amp;) const; or</span>
      <span class="comment">//..</span>
      <span class="comment">// and &#39;HASHER&#39; must have a publicly available default constructor and</span>
      <span class="comment">// destructor.</span>

      <span class="comment">// DATA</span>
      <span class="keyword">const</span> TYPE       *d_values;             <span class="comment">// Array of values table is to</span>
                                              <span class="comment">// cross-reference.  Held, not</span>
                                              <span class="comment">// owned.</span>
      <span class="keywordtype">size_t</span>            d_numValues;          <span class="comment">// Length of &#39;d_values&#39;.</span>
      <span class="keyword">const</span> TYPE      **d_bucketArray;        <span class="comment">// Contains ptrs into</span>
                                              <span class="comment">// &#39;d_values&#39;</span>
      <span class="keywordtype">unsigned</span>          d_bucketArrayMask;    <span class="comment">// Will always be &#39;2^N - 1&#39;.</span>
      HASHER            d_hasher;
      <span class="keywordtype">bool</span>              d_valid;              <span class="comment">// Object was properly</span>
                                              <span class="comment">// initialized.</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;        <span class="comment">// held, not owned</span>

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE ACCESSORS</span>
      <span class="keywordtype">bool</span> lookup(<span class="keywordtype">size_t</span>      *idx,
                  <span class="keyword">const</span> TYPE&amp;  value,
                  <span class="keywordtype">size_t</span>       hashValue) <span class="keyword">const</span>
          <span class="comment">// Look up the specified &#39;value&#39;, having hash value &#39;hashValue&#39;,</span>
          <span class="comment">// and return its index in &#39;d_bucketArray&#39;.  If not found, return</span>
          <span class="comment">// the vacant entry in &#39;d_bucketArray&#39; where it should be inserted.</span>
          <span class="comment">// Return &#39;true&#39; if &#39;value is found and &#39;false&#39; otherwise.</span>
      {
          <span class="keyword">const</span> TYPE *ptr;
          <span class="keywordflow">for</span> (*idx = hashValue &amp; d_bucketArrayMask;
                                (ptr = d_bucketArray[*idx]);
                                     *idx = (*idx + 1) &amp; d_bucketArrayMask) {
              <span class="keywordflow">if</span> (value == *ptr) {
                  <span class="keywordflow">return</span> <span class="keyword">true</span>;                                      <span class="comment">// RETURN</span>
              }
          }
          <span class="comment">// value was not found in table</span>

          <span class="keywordflow">return</span> <span class="keyword">false</span>;
      }

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      HashCrossReference(<span class="keyword">const</span> TYPE       *valuesArray,
                         <span class="keywordtype">size_t</span>            numValues,
                         <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
          <span class="comment">// Create a hash cross reference referring to the array of value.</span>
      : d_values(valuesArray)
      , d_numValues(numValues)
      , d_hasher()
      , d_valid(true)
      , d_allocator_p(bslma::Default::allocator(allocator))
      {
          <span class="keywordtype">size_t</span> bucketArrayLength = 4;
          <span class="keywordflow">while</span> (bucketArrayLength &lt; numValues * 4) {
              bucketArrayLength *= 2;
              <a class="code" href="bsls__assert_8h.html#a68505741fd0625240b1fbd8c9f40643c">BSLS_ASSERT_OPT</a>(bucketArrayLength);
          }
          d_bucketArrayMask = bucketArrayLength - 1;
          d_bucketArray = (<span class="keyword">const</span> TYPE **) d_allocator_p-&gt;allocate(
                                        bucketArrayLength * <span class="keyword">sizeof</span>(TYPE **));
          memset(d_bucketArray,  0, bucketArrayLength * <span class="keyword">sizeof</span>(TYPE *));

          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; numValues; ++i) {
              <span class="keyword">const</span> TYPE&amp; value = d_values[i];
              <span class="keywordtype">size_t</span> idx;
              <span class="keywordflow">if</span> (lookup(&amp;idx, value, d_hasher(value))) {
                  <span class="comment">// Duplicate value.  Fail.</span>

                  printf(<span class="stringliteral">&quot;Error: entries %u and %u have the same value\n&quot;</span>,
                              i, (<span class="keywordtype">unsigned</span>) (d_bucketArray[idx] - d_values));
                  d_valid = <span class="keyword">false</span>;

                  <span class="comment">// don&#39;t return, continue reporting other redundant</span>
                  <span class="comment">// entries.</span>
              }
              <span class="keywordflow">else</span> {
                  d_bucketArray[idx] = &amp;d_values[i];
              }
          }
      }

      ~HashCrossReference()
          <span class="comment">// Free up memory used by this cross-reference.</span>
      {
          d_allocator_p-&gt;deallocate(d_bucketArray);
      }

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> count(<span class="keyword">const</span> TYPE&amp; value) <span class="keyword">const</span>
          <span class="comment">// Return 1 if the specified &#39;value&#39; is found in the cross</span>
          <span class="comment">// reference and 0 otherwise.</span>
      {
          <a class="code" href="bsls__assert_8h.html#a68505741fd0625240b1fbd8c9f40643c">BSLS_ASSERT_OPT</a>(d_valid);

          <span class="keywordtype">size_t</span> idx;
          <span class="keywordflow">return</span> lookup(&amp;idx, value, d_hasher(value));
      }

      <span class="keywordtype">bool</span> isValid() const
          <span class="comment">// Return &#39;true&#39; if this cross reference was successfully</span>
          <span class="comment">// constructed and &#39;false&#39; otherwise.</span>
      {
          <span class="keywordflow">return</span> d_valid;
      }
  };
</pre></div><br/>
<br/>
 Then, In <code>main</code>, we will first use our cross-reference to cross-reference a collection of integer values. We define our array and take its length: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">int</span> ints[] = { 23, 42, 47, 56, 57, 61, 62, 63, 70, 72, 79 };
  <span class="keyword">enum</span> { NUM_INTS = <span class="keyword">sizeof</span> ints / <span class="keyword">sizeof</span> *ints };
</pre></div><br/>
<br/>
 Now, we create our cross-reference <code>hcri</code> and verify it constructed properly. Note that we don't specify the second template parameter <code>HASHER</code> and let it default to <code><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt;int&gt;</code>, which is already defined by bslstl_hash: <br/>
<br/>
<div class="fragment"><pre class="fragment">  HashCrossReference&lt;int&gt; hcri(ints, NUM_INTS);
  assert(hcri.isValid());
</pre></div><br/>
<br/>
 Finally, we use <code>hcri</code> to verify numbers that were and were not in the collection: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(1 == hcri.count(23));
  assert(1 == hcri.count(42));
  assert(1 == hcri.count(47));
  assert(1 == hcri.count(56));
  assert(0 == hcri.count( 3));
  assert(0 == hcri.count(31));
  assert(0 == hcri.count(37));
  assert(0 == hcri.count(58));
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_using_hashappend_from_bslh_with_hashcrossreference"></a> <a class="anchor" id="usage.example_2~3A_using_hashappend_from_bslh_with_hashcrossreference"></a> <a class="anchor" id="description.usage.example_2~3A_using_hashappend_from_bslh_with_hashcrossreference"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Using hashAppend from bslh with HashCrossReference: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>We want to specialize <code><a class="el" href="structbsl_1_1hash.html">bsl::hash</a></code> for a custom class. We can use the modular hashing system implemented in <code>bslh</code> rather than explicitly specializing <code><a class="el" href="structbsl_1_1hash.html">bsl::hash</a></code>. We will re-use the <code>HashCrossReference</code> template class defined in Example 1. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we declare <code>Point</code>, a class that allows us to identify a location on a two dimensional Cartesian plane. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Point {
      <span class="comment">// This class is a value-semantic type that represents a two-</span>
      <span class="comment">// dimensional location on a Cartesian plane.</span>

    <span class="keyword">private</span>:
      <span class="keywordtype">int</span>    d_x;
      <span class="keywordtype">int</span>    d_y;
      <span class="keywordtype">double</span> d_distToOrigin; <span class="comment">// This value will be accessed a lot, so we</span>
                             <span class="comment">// cache it rather than recalculating every</span>
                             <span class="comment">// time.</span>

    <span class="keyword">public</span>:
      Point (<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y);
          <span class="comment">// Create a &#39;Point&#39; with the specified &#39;x&#39; and &#39;y&#39; coordinates</span>

      <span class="keywordtype">double</span> distanceToOrigin();
          <span class="comment">// Return the distance from the origin (0, 0) to this point.</span>
</pre></div><br/>
<br/>
 Then, we declare <code>operator==</code> as a friend so that we will be able to compare two points. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> Point &amp;left, <span class="keyword">const</span> Point &amp;right);
</pre></div><br/>
<br/>
 Next, we declare <code>hashAppend</code> as a friend so that we will be able hash a <code>Point</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">template</span> &lt;<span class="keyword">class</span> HASH_ALGORITHM&gt;
      <span class="keyword">friend</span>
      <span class="keywordtype">void</span> <a class="code" href="group__bslstl__pair.html#ga7f8ed8637bd0597772928067e041cc26">hashAppend</a>(HASH_ALGORITHM &amp;hashAlg, <span class="keyword">const</span> Point &amp;point);
          <span class="comment">// Apply the specified &#39;hashAlg&#39; to the specified &#39;point&#39;</span>
  };

  Point::Point(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) : d_x(x), d_y(y) {
      d_distToOrigin = sqrt(static_cast&lt;long double&gt;(d_x * d_x) +
                            static_cast&lt;long double&gt;(d_y * d_y));
  }

  <span class="keywordtype">double</span> Point::distanceToOrigin() {
      <span class="keywordflow">return</span> d_distToOrigin;
  }
</pre></div><br/>
<br/>
 Then, we define <code>operator==</code>. Notice how it only checks salient attributes<ul>
<li>attributes that contribute to the value of the class. We ignore <code>d_distToOrigin</code> which is not required to determine equality. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> Point &amp;left, <span class="keyword">const</span> Point &amp;right)
  {
      <span class="keywordflow">return</span> (left.d_x == right.d_x) &amp;&amp; (left.d_y == right.d_y);
  }
</pre></div><br/>
<br/>
 Next, we define <code>hashAppend</code>. This method will allow any hashing algorithm to be applied to <code>Point</code>. This is the extent of the work that needs to be done by type creators. They do not need to implement any algorithms, they just need to call out the salient attributes (which have already been determined by <code>operator==</code>) by calling <code>hashAppend</code> on them. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> HASH_ALGORITHM&gt;
  <span class="keywordtype">void</span> <a class="code" href="group__bslstl__pair.html#ga7f8ed8637bd0597772928067e041cc26">hashAppend</a>(HASH_ALGORITHM &amp;hashAlg, <span class="keyword">const</span> Point &amp;point)
  {
      using ::BloombergLP::bslh::hashAppend;
      <a class="code" href="group__bslstl__pair.html#ga7f8ed8637bd0597772928067e041cc26">hashAppend</a>(hashAlg, point.d_x);
      <a class="code" href="group__bslstl__pair.html#ga7f8ed8637bd0597772928067e041cc26">hashAppend</a>(hashAlg, point.d_y);
  }
</pre></div><br/>
<br/>
 Then, we declare another value-semantic type, <code>Box</code>, that has a <code>Point</code> as one of its salient attributes. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Box {
      <span class="comment">// This class is a value-semantic type that represents a box drawn on</span>
      <span class="comment">// to a Cartesian plane.</span>

    <span class="keyword">private</span>:
      Point d_position;
      <span class="keywordtype">int</span>   d_length;
      <span class="keywordtype">int</span>   d_width;

    <span class="keyword">public</span>:
      Box(Point position, <span class="keywordtype">int</span> length, <span class="keywordtype">int</span> width);
          <span class="comment">// Create a box with the specified &#39;length&#39; and &#39;width&#39;, with its</span>
          <span class="comment">// upper left corner at the specified &#39;position&#39;</span>
</pre></div><br/>
<br/>
 Next, we declare <code>operator==</code> and <code>hashAppend</code> as we did before. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> Box &amp;left, <span class="keyword">const</span> Box &amp;right);

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> HASH_ALGORITHM&gt;
      <span class="keyword">friend</span>
      <span class="keywordtype">void</span> <a class="code" href="group__bslstl__pair.html#ga7f8ed8637bd0597772928067e041cc26">hashAppend</a>(HASH_ALGORITHM &amp;hashAlg, <span class="keyword">const</span> Box &amp;box);
          <span class="comment">// Apply the specified &#39;hashAlg&#39; to the specified &#39;box&#39;</span>
  };

  Box::Box(Point position, <span class="keywordtype">int</span> length, <span class="keywordtype">int</span> width) : d_position(position),
                                                    d_length(length),
                                                    d_width(width) { }
</pre></div><br/>
<br/>
 Then, we define <code>operator==</code>. This time all of the data members contribute to equality. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> Box &amp;left, <span class="keyword">const</span> Box &amp;right)
  {
      <span class="keywordflow">return</span> (left.d_position == right.d_position) &amp;&amp;
             (left.d_length   == right.d_length) &amp;&amp;
             (left.d_width    == right.d_width);
  }
</pre></div><br/>
<br/>
 Next, we define <code>hashAppend</code> for <code>Box</code>. Notice how as well as calling <code>hashAppend</code> on fundamental types, we can also call it on our user-defined type <code>Point</code>. Calling <code>hashAppend</code> on <code>Point</code> will propagate the hashing algorithm functor <code>hashAlg</code> down to the fundamental types that make up <code>Point</code>, and those types will then be passed into the algorithm functor. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> HASH_ALGORITHM&gt;
  <span class="keywordtype">void</span> <a class="code" href="group__bslstl__pair.html#ga7f8ed8637bd0597772928067e041cc26">hashAppend</a>(HASH_ALGORITHM &amp;hashAlg, <span class="keyword">const</span> Box &amp;box)
  {
      <a class="code" href="group__bslstl__pair.html#ga7f8ed8637bd0597772928067e041cc26">hashAppend</a>(hashAlg, box.d_position);
      <a class="code" href="group__bslstl__pair.html#ga7f8ed8637bd0597772928067e041cc26">hashAppend</a>(hashAlg, box.d_length);
      <a class="code" href="group__bslstl__pair.html#ga7f8ed8637bd0597772928067e041cc26">hashAppend</a>(hashAlg, box.d_width);
  }
</pre></div><br/>
<br/>
 Then, we want to use our cross reference on a <code>Box</code>. We create an array of unique <code>Box</code>s and take its length: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Box boxes[] = { Box(Point(0, 0), 2, 3),
                      Box(Point(1, 0), 1, 1),
                      Box(Point(0, 1), 1, 5),
                      Box(Point(1, 1), 5, 6),
                      Box(Point(2, 1), 1, 13),
                      Box(Point(0, 4), 3, 3),
                      Box(Point(3, 2), 2, 17) };
      <span class="keyword">enum</span> { NUM_BOXES = <span class="keyword">sizeof</span> boxes / <span class="keyword">sizeof</span> *boxes };
</pre></div><br/>
<br/>
 Next, we create our cross-reference <code>hcrsts</code> and verify that it constructed properly. Note we don't pass a second parameter template argument and let <code>HASHER</code> default to <code><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt;TYPE&gt;</code>. Since we have not specialized <code><a class="el" href="structbsl_1_1hash.html">bsl::hash</a></code> for <code>Box</code>, <code><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt;TYPE&gt;</code> will attempt to use <code>bslh::hash&lt;&gt;</code> to hash <code>Box</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      HashCrossReference&lt;Box&gt; hcrsts(boxes, NUM_BOXES);
      ASSERT(hcrsts.isValid());
</pre></div><br/>
<br/>
 Now, we verify that each element in our array registers with count: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; NUM_BOXES; ++i) {
          ASSERT(1 == hcrsts.count(boxes[i]));
      }
</pre></div><br/>
<br/>
 Finally, we verify that elements not in our original array are correctly identified as not being in the set: <br/>
<br/>
<div class="fragment"><pre class="fragment">      ASSERT(0 == hcrsts.count(Box(Point(3, 3), 3, 3)));
      ASSERT(0 == hcrsts.count(Box(Point(3, 2), 1, 0)));
      ASSERT(0 == hcrsts.count(Box(Point(1, 2), 3, 4)));
      ASSERT(0 == hcrsts.count(Box(Point(33, 23), 13, 3)));
      ASSERT(0 == hcrsts.count(Box(Point(30, 37), 34, 13)));
</pre></div><br/>
<br/>
 </li>
</ul>
</dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga0fce4aba03c8d11f4b06fa6088a0b08f"></a><!-- doxytag: member="bsl::hash&lt; bool &gt;::result_type" ref="ga0fce4aba03c8d11f4b06fa6088a0b08f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; bool &gt;::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga889f9944d98561842e62eab7cb434d59"></a><!-- doxytag: member="bsl::hash&lt; char &gt;::result_type" ref="ga889f9944d98561842e62eab7cb434d59" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; char &gt;::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga001a8bf528cccf39d9e663e34454c10e"></a><!-- doxytag: member="bsl::hash&lt; signed char &gt;::result_type" ref="ga001a8bf528cccf39d9e663e34454c10e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; signed char &gt;::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga313b8db35282fccd4581263ebe116bda"></a><!-- doxytag: member="bsl::hash&lt; unsigned char &gt;::result_type" ref="ga313b8db35282fccd4581263ebe116bda" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned char &gt;::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga04401e8d427f52c59f03788c53f5ebff"></a><!-- doxytag: member="bsl::hash&lt; wchar_t &gt;::result_type" ref="ga04401e8d427f52c59f03788c53f5ebff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; wchar_t &gt;::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf78a39c5b2112271d15c495602109091"></a><!-- doxytag: member="bsl::hash&lt; short &gt;::result_type" ref="gaf78a39c5b2112271d15c495602109091" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; short &gt;::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5706dd45dc52b64c8385e5d86c2b7182"></a><!-- doxytag: member="bsl::hash&lt; unsigned short &gt;::result_type" ref="ga5706dd45dc52b64c8385e5d86c2b7182" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned short &gt;::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gacfad0aed76f7af7a67d73b2673f87bce"></a><!-- doxytag: member="bsl::hash&lt; int &gt;::result_type" ref="gacfad0aed76f7af7a67d73b2673f87bce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; int &gt;::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9f7047490324e12dfd02ea3f037867c7"></a><!-- doxytag: member="bsl::hash&lt; unsigned int &gt;::result_type" ref="ga9f7047490324e12dfd02ea3f037867c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned int &gt;::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5528a188abf2c07b630d8f39b45702d5"></a><!-- doxytag: member="bsl::hash&lt; long &gt;::result_type" ref="ga5528a188abf2c07b630d8f39b45702d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; long &gt;::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7da1e1af882df7aebac8c3b715fed712"></a><!-- doxytag: member="bsl::hash&lt; unsigned long &gt;::result_type" ref="ga7da1e1af882df7aebac8c3b715fed712" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned long &gt;::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga054a78a337e1464e93507a6aaa3d793f"></a><!-- doxytag: member="bsl::hash&lt; long long &gt;::result_type" ref="ga054a78a337e1464e93507a6aaa3d793f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; long long &gt;::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaced1104fd69e7b4d2a953adfce37898c"></a><!-- doxytag: member="bsl::hash&lt; unsigned long long &gt;::result_type" ref="gaced1104fd69e7b4d2a953adfce37898c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned long long &gt;::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga50e9c530dd61a84ce79244dffbccf916"></a><!-- doxytag: member="bsl::hash&lt; bool &gt;::hash" ref="ga50e9c530dd61a84ce79244dffbccf916" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; bool &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. </p>

</div>
</div>
<a class="anchor" id="gadf1f06f8cb641056ec6bd0c1b94ac790"></a><!-- doxytag: member="bsl::hash&lt; bool &gt;::hash" ref="gadf1f06f8cb641056ec6bd0c1b94ac790" args="(const hash &amp;original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; bool &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; bool &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="gae5eb5721ac592790ff99fc1453b3ff52"></a><!-- doxytag: member="bsl::hash&lt; bool &gt;::~hash" ref="gae5eb5721ac592790ff99fc1453b3ff52" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; bool &gt;::~hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga7479bdd278b4c0798e493a14aaefa83b"></a><!-- doxytag: member="bsl::hash&lt; bool &gt;::operator=" ref="ga7479bdd278b4c0798e493a14aaefa83b" args="(const hash &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash&amp; <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; bool &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; bool &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga31688073287a0ed6aa2a707b47f64e92"></a><!-- doxytag: member="bsl::hash&lt; bool &gt;::operator()" ref="ga31688073287a0ed6aa2a707b47f64e92" args="(bool x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; bool &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value computed using the specified <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="gadaf857d99a99f7510c92a8c213422ea9"></a><!-- doxytag: member="bsl::hash&lt; char &gt;::hash" ref="gadaf857d99a99f7510c92a8c213422ea9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; char &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. </p>

</div>
</div>
<a class="anchor" id="ga15c44c96fba068a6e4469d06f3a8a810"></a><!-- doxytag: member="bsl::hash&lt; char &gt;::hash" ref="ga15c44c96fba068a6e4469d06f3a8a810" args="(const hash &amp;original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; char &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga4971fce47c3c12fe29d1cc467cceeaf4"></a><!-- doxytag: member="bsl::hash&lt; char &gt;::~hash" ref="ga4971fce47c3c12fe29d1cc467cceeaf4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; char &gt;::~hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga39d210965ec47de39c4f45aa1d1b97de"></a><!-- doxytag: member="bsl::hash&lt; char &gt;::operator=" ref="ga39d210965ec47de39c4f45aa1d1b97de" args="(const hash &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash&amp; <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; char &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga1ba276f3e34920a452d32419757898be"></a><!-- doxytag: member="bsl::hash&lt; char &gt;::operator()" ref="ga1ba276f3e34920a452d32419757898be" args="(char x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; char &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value computed using the specified <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="gac0cbbb3b22110097b310e9add1230a9a"></a><!-- doxytag: member="bsl::hash&lt; signed char &gt;::hash" ref="gac0cbbb3b22110097b310e9add1230a9a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; signed char &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. </p>

</div>
</div>
<a class="anchor" id="ga1b59d41740c08d0ef469cc2e17f76171"></a><!-- doxytag: member="bsl::hash&lt; signed char &gt;::hash" ref="ga1b59d41740c08d0ef469cc2e17f76171" args="(const hash &amp;original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; signed char &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; signed char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga2c96a55b52a290340fcf50f04fe0a4d6"></a><!-- doxytag: member="bsl::hash&lt; signed char &gt;::~hash" ref="ga2c96a55b52a290340fcf50f04fe0a4d6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; signed char &gt;::~hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga6da275994c944cbc73410ef36b4abb85"></a><!-- doxytag: member="bsl::hash&lt; signed char &gt;::operator=" ref="ga6da275994c944cbc73410ef36b4abb85" args="(const hash &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash&amp; <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; signed char &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; signed char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="gaf3020fd8281f75f301194300e3dc39c2"></a><!-- doxytag: member="bsl::hash&lt; signed char &gt;::operator()" ref="gaf3020fd8281f75f301194300e3dc39c2" args="(signed char x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; signed char &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">signed char&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value computed using the specified <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="ga881f12e5a193656e38fb5144860b1d5c"></a><!-- doxytag: member="bsl::hash&lt; unsigned char &gt;::hash" ref="ga881f12e5a193656e38fb5144860b1d5c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned char &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. </p>

</div>
</div>
<a class="anchor" id="gad3461f9237b42eb6b3a41ea19c3c8a90"></a><!-- doxytag: member="bsl::hash&lt; unsigned char &gt;::hash" ref="gad3461f9237b42eb6b3a41ea19c3c8a90" args="(const hash &amp;original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned char &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; unsigned char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="gac750f1094615f7db84f2924bf87f1709"></a><!-- doxytag: member="bsl::hash&lt; unsigned char &gt;::~hash" ref="gac750f1094615f7db84f2924bf87f1709" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned char &gt;::~hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga12b15da342cfda224a22e1a70d8b88e0"></a><!-- doxytag: member="bsl::hash&lt; unsigned char &gt;::operator=" ref="ga12b15da342cfda224a22e1a70d8b88e0" args="(const hash &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash&amp; <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned char &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; unsigned char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga18b3a3003ad5103d61791a880b8fd7fd"></a><!-- doxytag: member="bsl::hash&lt; unsigned char &gt;::operator()" ref="ga18b3a3003ad5103d61791a880b8fd7fd" args="(unsigned char x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned char &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value computed using the specified <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="ga533ade165c4bb3d2a864550d875dd7a6"></a><!-- doxytag: member="bsl::hash&lt; wchar_t &gt;::hash" ref="ga533ade165c4bb3d2a864550d875dd7a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; wchar_t &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. </p>

</div>
</div>
<a class="anchor" id="ga51ef16eaf23b9ac1d34d5dde76adb21a"></a><!-- doxytag: member="bsl::hash&lt; wchar_t &gt;::hash" ref="ga51ef16eaf23b9ac1d34d5dde76adb21a" args="(const hash &amp;original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; wchar_t &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; wchar_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga25fc32f277b2b11d703385c4f6228ff6"></a><!-- doxytag: member="bsl::hash&lt; wchar_t &gt;::~hash" ref="ga25fc32f277b2b11d703385c4f6228ff6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; wchar_t &gt;::~hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga7c0a983f9517108776aa0cf94cfd577e"></a><!-- doxytag: member="bsl::hash&lt; wchar_t &gt;::operator=" ref="ga7c0a983f9517108776aa0cf94cfd577e" args="(const hash &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash&amp; <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; wchar_t &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; wchar_t &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga34b3b3046930355218d9854b5e9fdfcb"></a><!-- doxytag: member="bsl::hash&lt; wchar_t &gt;::operator()" ref="ga34b3b3046930355218d9854b5e9fdfcb" args="(wchar_t x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; wchar_t &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value computed using the specified <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="gac4acb2a25de35e7b19edd1ac9d2494da"></a><!-- doxytag: member="bsl::hash&lt; short &gt;::hash" ref="gac4acb2a25de35e7b19edd1ac9d2494da" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; short &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. </p>

</div>
</div>
<a class="anchor" id="gac31d68aeb125f8eb807245e50cce7511"></a><!-- doxytag: member="bsl::hash&lt; short &gt;::hash" ref="gac31d68aeb125f8eb807245e50cce7511" args="(const hash &amp;original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; short &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; short &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga732cbd2c611c475cc8aa181928bbc180"></a><!-- doxytag: member="bsl::hash&lt; short &gt;::~hash" ref="ga732cbd2c611c475cc8aa181928bbc180" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; short &gt;::~hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga7b849b4291985726747ef02c566e4e76"></a><!-- doxytag: member="bsl::hash&lt; short &gt;::operator=" ref="ga7b849b4291985726747ef02c566e4e76" args="(const hash &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash&amp; <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; short &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; short &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga02f5dc540d7ff4047a8678950f639485"></a><!-- doxytag: member="bsl::hash&lt; short &gt;::operator()" ref="ga02f5dc540d7ff4047a8678950f639485" args="(short x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; short &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value computed using the specified <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="ga3aed18cec12c5069948626f59af1c3fe"></a><!-- doxytag: member="bsl::hash&lt; unsigned short &gt;::hash" ref="ga3aed18cec12c5069948626f59af1c3fe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned short &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. </p>

</div>
</div>
<a class="anchor" id="ga2c0104f9906dcdfa950600fdff1a71d6"></a><!-- doxytag: member="bsl::hash&lt; unsigned short &gt;::hash" ref="ga2c0104f9906dcdfa950600fdff1a71d6" args="(const hash &amp;original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned short &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; unsigned short &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga12e60ad33728baae2f2c0fc28fa51a7f"></a><!-- doxytag: member="bsl::hash&lt; unsigned short &gt;::~hash" ref="ga12e60ad33728baae2f2c0fc28fa51a7f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned short &gt;::~hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="gacbc05697d04173217be33feba49281a6"></a><!-- doxytag: member="bsl::hash&lt; unsigned short &gt;::operator=" ref="gacbc05697d04173217be33feba49281a6" args="(const hash &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash&amp; <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned short &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; unsigned short &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="gaf1456c38fc71fea828f2808bc6439ca2"></a><!-- doxytag: member="bsl::hash&lt; unsigned short &gt;::operator()" ref="gaf1456c38fc71fea828f2808bc6439ca2" args="(unsigned short x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned short &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value computed using the specified <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="ga76ac234abbbeec9b496718a91798a624"></a><!-- doxytag: member="bsl::hash&lt; int &gt;::hash" ref="ga76ac234abbbeec9b496718a91798a624" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; int &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. </p>

</div>
</div>
<a class="anchor" id="ga7fe8ad4f59ebdd7b1bdd9ec72c645161"></a><!-- doxytag: member="bsl::hash&lt; int &gt;::hash" ref="ga7fe8ad4f59ebdd7b1bdd9ec72c645161" args="(const hash &amp;original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; int &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga824c0e4eea084027718116bae06ad2f9"></a><!-- doxytag: member="bsl::hash&lt; int &gt;::~hash" ref="ga824c0e4eea084027718116bae06ad2f9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; int &gt;::~hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga05cf21e1ece5899eaf01629d1b5a06cc"></a><!-- doxytag: member="bsl::hash&lt; int &gt;::operator=" ref="ga05cf21e1ece5899eaf01629d1b5a06cc" args="(const hash &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash&amp; <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; int &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="gaa1252f2ccf9dcc93579a09382ce8de79"></a><!-- doxytag: member="bsl::hash&lt; int &gt;::operator()" ref="gaa1252f2ccf9dcc93579a09382ce8de79" args="(int x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; int &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value computed using the specified <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="gaf373e8ee6003abe5da5477b41851b117"></a><!-- doxytag: member="bsl::hash&lt; unsigned int &gt;::hash" ref="gaf373e8ee6003abe5da5477b41851b117" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned int &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. </p>

</div>
</div>
<a class="anchor" id="gad14c449cc79dd0d56c7b3cef70bb6d43"></a><!-- doxytag: member="bsl::hash&lt; unsigned int &gt;::hash" ref="gad14c449cc79dd0d56c7b3cef70bb6d43" args="(const hash &amp;original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned int &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; unsigned int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga126597bb08531c9fb3ab06a625802ae6"></a><!-- doxytag: member="bsl::hash&lt; unsigned int &gt;::~hash" ref="ga126597bb08531c9fb3ab06a625802ae6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned int &gt;::~hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="gada6c32193811bf1abb768adff863b03c"></a><!-- doxytag: member="bsl::hash&lt; unsigned int &gt;::operator=" ref="gada6c32193811bf1abb768adff863b03c" args="(const hash &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash&amp; <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned int &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; unsigned int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="gabfdde9afffd6b103bd59064e7a0b73d8"></a><!-- doxytag: member="bsl::hash&lt; unsigned int &gt;::operator()" ref="gabfdde9afffd6b103bd59064e7a0b73d8" args="(unsigned int x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned int &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value computed using the specified <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="gadb6e3fa5cb48d06c803ae95bb74c3ed5"></a><!-- doxytag: member="bsl::hash&lt; long &gt;::hash" ref="gadb6e3fa5cb48d06c803ae95bb74c3ed5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; long &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. </p>

</div>
</div>
<a class="anchor" id="gaef3296dc6c616da725be61da27aeea96"></a><!-- doxytag: member="bsl::hash&lt; long &gt;::hash" ref="gaef3296dc6c616da725be61da27aeea96" args="(const hash &amp;original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; long &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; long &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga8947395f9754a436e4f8443b62febbbd"></a><!-- doxytag: member="bsl::hash&lt; long &gt;::~hash" ref="ga8947395f9754a436e4f8443b62febbbd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; long &gt;::~hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga7167861fed40f00de02f0c971b31e4bd"></a><!-- doxytag: member="bsl::hash&lt; long &gt;::operator=" ref="ga7167861fed40f00de02f0c971b31e4bd" args="(const hash &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash&amp; <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; long &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; long &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga951f1b61404f4c229565a658ad49d43b"></a><!-- doxytag: member="bsl::hash&lt; long &gt;::operator()" ref="ga951f1b61404f4c229565a658ad49d43b" args="(long x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; long &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value computed using the specified <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="ga593b8834e07ac9178b950fc2d7784c10"></a><!-- doxytag: member="bsl::hash&lt; unsigned long &gt;::hash" ref="ga593b8834e07ac9178b950fc2d7784c10" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned long &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. </p>

</div>
</div>
<a class="anchor" id="gafbecd3dd0769ec2d9031492af2614157"></a><!-- doxytag: member="bsl::hash&lt; unsigned long &gt;::hash" ref="gafbecd3dd0769ec2d9031492af2614157" args="(const hash &amp;original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned long &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; unsigned long &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga558101438b4131661d025aaa1610e143"></a><!-- doxytag: member="bsl::hash&lt; unsigned long &gt;::~hash" ref="ga558101438b4131661d025aaa1610e143" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned long &gt;::~hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="gaca62f43d8039734f888d7ff411a2df77"></a><!-- doxytag: member="bsl::hash&lt; unsigned long &gt;::operator=" ref="gaca62f43d8039734f888d7ff411a2df77" args="(const hash &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash&amp; <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned long &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; unsigned long &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="gadeb18bd3fba4f7ddd77107ced3ec596f"></a><!-- doxytag: member="bsl::hash&lt; unsigned long &gt;::operator()" ref="gadeb18bd3fba4f7ddd77107ced3ec596f" args="(unsigned long x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned long &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value computed using the specified <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="gaf91ac9f794b4ce354acf96b86909549b"></a><!-- doxytag: member="bsl::hash&lt; long long &gt;::hash" ref="gaf91ac9f794b4ce354acf96b86909549b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; long long &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. </p>

</div>
</div>
<a class="anchor" id="ga9fb87f17cb96f2b08e1da3ada2e3e25c"></a><!-- doxytag: member="bsl::hash&lt; long long &gt;::hash" ref="ga9fb87f17cb96f2b08e1da3ada2e3e25c" args="(const hash &amp;original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; long long &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; long long &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga4c3e488a7f20553b479cb22e12ac55ea"></a><!-- doxytag: member="bsl::hash&lt; long long &gt;::~hash" ref="ga4c3e488a7f20553b479cb22e12ac55ea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; long long &gt;::~hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga78badfc16a088af5fbe0a6923c838549"></a><!-- doxytag: member="bsl::hash&lt; long long &gt;::operator=" ref="ga78badfc16a088af5fbe0a6923c838549" args="(const hash &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash&amp; <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; long long &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; long long &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga59823e0c49cedf948b5b068aa50e0cf0"></a><!-- doxytag: member="bsl::hash&lt; long long &gt;::operator()" ref="ga59823e0c49cedf948b5b068aa50e0cf0" args="(long long x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; long long &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">long long&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value computed using the specified <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="ga9e299f26fea9227e9586ce9ef96b8f31"></a><!-- doxytag: member="bsl::hash&lt; unsigned long long &gt;::hash" ref="ga9e299f26fea9227e9586ce9ef96b8f31" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned long long &gt;::hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. </p>

</div>
</div>
<a class="anchor" id="ga876d0cbda27ed768797eff37237fbff8"></a><!-- doxytag: member="bsl::hash&lt; unsigned long long &gt;::hash" ref="ga876d0cbda27ed768797eff37237fbff8" args="(const hash &amp;original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned long long &gt;::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; unsigned long long &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>hash</code> object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga8b2a08bbb2c71972d7ba636c98ddc0da"></a><!-- doxytag: member="bsl::hash&lt; unsigned long long &gt;::~hash" ref="ga8b2a08bbb2c71972d7ba636c98ddc0da" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned long long &gt;::~hash </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga38380a625f45f8510f8fd2700c210248"></a><!-- doxytag: member="bsl::hash&lt; unsigned long long &gt;::operator=" ref="ga38380a625f45f8510f8fd2700c210248" args="(const hash &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hash&amp; <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned long long &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbsl_1_1hash.html">hash</a>&lt; unsigned long long &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. Note that as <code>hash</code> is an empty (stateless) type, this operation has no observable effect. </p>

</div>
</div>
<a class="anchor" id="ga919e68c590738a9b25b9668f56305c6b"></a><!-- doxytag: member="bsl::hash&lt; unsigned long long &gt;::operator()" ref="ga919e68c590738a9b25b9668f56305c6b" args="(unsigned long long x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="structbsl_1_1hash.html">bsl::hash</a>&lt; unsigned long long &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hash value computed using the specified <code>x</code>. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:55 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
