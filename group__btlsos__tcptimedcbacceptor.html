<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlsos_tcptimedcbacceptor Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlsos_tcptimedcbacceptor<br/>
<small>
[<a class="el" href="group__btlsos.html">Package btlsos</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a non-blocking acceptor of TCP connections with timeout.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlso.html">btlso</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlsos.html">btlsos</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Implementing a Multi-User Echo Server</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a non-blocking acceptor of TCP connections with timeout. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlsos_1_1TcpTimedCbAcceptor.html">btlsos::TcpTimedCbAcceptor</a> </td><td>non-blocking timed channel allocator  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlsos__tcptimedcbchannel.html" title="Provide timed stream-based communication channel over TCP sockets.">Component btlsos_tcptimedcbchannel</a> <a class="el" href="group__btlso__tcptimereventmanager.html" title="Provide a multiplexer of events on sockets and timers.">Component btlso_tcptimereventmanager</a> <a class="el" href="group__btlsos__tcptimedcbconnector.html" title="Provide a non-blocking connector (with timeout) to TCP servers.">Component btlsos_tcptimedcbconnector</a> <a class="el" href="group__btlsos__tcpcbchannel.html" title="Provide stream-based communication channel over TCP sockets.">Component btlsos_tcpcbchannel</a> <a class="el" href="group__btlso__socketoptutil.html" title="Provide operations to manipulate socket options.">Component btlso_socketoptutil</a> btesos_streamsocketfactory </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a non-blocking single-port acceptor of TCP connections with timeout capability, <code><a class="el" href="classbtlsos_1_1TcpTimedCbAcceptor.html">btlsos::TcpTimedCbAcceptor</a></code>, that adheres to the <code><a class="el" href="classbtlsc_1_1TimedCbChannelAllocator.html">btlsc::TimedCbChannelAllocator</a></code> protocol. Both timed and non-timed (callback) channels can be allocated in a timed and non-timed fashion as indicated by the following table: <br/>
<br/>
<div class="fragment"><pre class="fragment">                           +=========================================+
                           |            Accept operation             |
       +=============================================================+
       |   Result channel  |        Timed         |    Non-Timed     |
       +-------------------+----------------------+------------------+
       |      Timed        | <span class="stringliteral">&#39;timedAllocateTimed&#39;</span> | <span class="stringliteral">&#39;allocateTimed&#39;</span>  |
       +-------------------+----------------------+------------------+
       |    Non-Timed      |    <span class="stringliteral">&#39;timedAllocate&#39;</span>   |    <span class="stringliteral">&#39;allocate&#39;</span>    |
       +=============================================================+
</pre></div><br/>
<br/>
 Allocations (both timed and non-timed) follow the asynchronous (callback-based) nature of the <code>btesc</code> protocol; the callbacks are invoked when an allocation succeeds or an error occurs. The acceptor uses the user-installed socket event manager in order to monitor (in a non-blocking fashion) the listening socket for incoming connection requests. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The acceptor has the flexibility of opening and closing a listening socket with no effect on any existing channels managed by this object. The enqueued (i.e., not-yet-completed) allocation requests will, however, fail (without invalidating the allocator) and the associated callbacks will be invoked when the listening port is closed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The acceptor is <em>thread</em> <em>safe</em>, meaning that any operation can be called on <em>distinct instances</em> from different threads without any side-effects (which, generally speaking, means that there is no <code>static</code> data), but not <em>thread</em> <em>enabled</em> (i.e., two threads cannot safely call methods on the <em>same</em> <em>instance</em> without external synchronization). This acceptor is not <em>async-safe</em>, meaning that one or more functions cannot be invoked safely from a signal handler. Note that the thread safety of the acceptor is subject to the thread safety of the supplied socket event manager. If distinct instances of acceptor use the <em>same</em> instance of a socket event manager, both acceptors are thread-safe if and only if that socket event manager is <em>THREAD</em> <em>ENABLED</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_implementing_a_multi-user_echo_server"></a> <a class="anchor" id="usage.example_1~3A_implementing_a_multi-user_echo_server"></a> <a class="anchor" id="description.usage.example_1~3A_implementing_a_multi-user_echo_server"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Implementing a Multi-User Echo Server: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following usage example shows a possible implementation of a multi-user echo server. An echo server accepts connections and, for every connection, sends any received data back to the client (until the connection is terminated). This server requires that data is read from an accepted connection within a certain time interval or else the connection is dropped on timeout. The echo server is implemented as a separate class (<code>my_EchoServer</code>) that owns the timed callback acceptor. Various configuration parameters such as the timeout values, the queue size and input buffer size, and the default port number (as mandated by RFC 862) are constants within this class. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_EchoServer {
      <span class="comment">// This class implements a simple multi-user echo server as</span>
      <span class="comment">// specified by the RFC 862.</span>
      <span class="keyword">enum</span> {
         k_READ_SIZE = 10,  <span class="comment">// The number of bytes to be read can be changed,</span>
                            <span class="comment">// but a larger &#39;k_READ_SIZE&#39; will require the</span>
                            <span class="comment">// client to input more data to be echoed.</span>
         k_DEFAULT_PORT_NUMBER = 1234,   <span class="comment">// As specified by the RFC 862</span>
         k_QUEUE_SIZE = 16
      };
      <a class="code" href="classbtlsos_1_1TcpTimedCbAcceptor.html">btlsos::TcpTimedCbAcceptor</a>   d_allocator;
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>           d_acceptTimeout;
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>           d_readTimeout;
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>           d_writeTimeout;

      bsl::function&lt;void(btlsc::TimedCbChannel*, int)&gt;
                                  d_allocateFunctor; <span class="comment">// callback functor</span>
    <span class="keyword">private</span>:
      <span class="comment">// Callbacks</span>
      <span class="keywordtype">void</span> allocateCb(<a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel,
                      <span class="keywordtype">int</span>                   status);
          <span class="comment">// Invoked from the socket event manager when a connection is</span>
          <span class="comment">// allocated (i.e., accepted) or an error occurs when allocating.</span>
          <span class="comment">// [...]</span>

      <span class="keywordtype">void</span> bufferedReadCb(<span class="keyword">const</span> <span class="keywordtype">char</span>           *buffer,
                          <span class="keywordtype">int</span>                   status,
                          <span class="keywordtype">int</span>                   asyncStatus,
                          <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel);
          <span class="comment">// Invoked from the socket event manager when data is read from a</span>
          <span class="comment">// channel.  [...]</span>

      <span class="keywordtype">void</span> writeCb(<span class="keywordtype">int</span>                   status,
                   <span class="keywordtype">int</span>                   asyncStatus,
                   <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel,
                   <span class="keywordtype">int</span>                   numBytes);
          <span class="comment">// Invoked from the socket event manager when data is written</span>
          <span class="comment">// into a channel.  [...]</span>

    <span class="keyword">private</span>:
      my_EchoServer(<span class="keyword">const</span> my_EchoServer&amp;);    <span class="comment">// Not implemented.</span>
      my_EchoServer&amp;
          operator=(<span class="keyword">const</span> my_EchoServer&amp;);    <span class="comment">// Not implemented.</span>
    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_EchoServer(<a class="code" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt;</a> *factory,
                    <a class="code" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a>                      *manager);
          <span class="comment">// Create an echo server that uses the specified stream socket</span>
          <span class="comment">// &#39;factory&#39; for the system sockets and the specified socket event</span>
          <span class="comment">// &#39;manager&#39; to multiplex the events on these sockets.  The</span>
          <span class="comment">// behavior is undefined if either &#39;factory&#39; or &#39;manager&#39; is 0.</span>

     ~my_EchoServer();
         <span class="comment">// Destroy this server.  The behavior is undefined unless the server</span>
         <span class="comment">// is shut down properly (i.e., via &#39;close&#39;).</span>

     <span class="comment">// MANIPULATORS</span>
     <span class="keywordtype">int</span> open(<span class="keywordtype">int</span> portNumber = k_DEFAULT_PORT_NUMBER);
         <span class="comment">// Establish a listening socket on the specified &#39;portNumber&#39;;</span>
         <span class="comment">// return 0 on success, and a non-zero value otherwise.  The</span>
         <span class="comment">// behavior is undefined unless 0 &lt;= portNumber and the listening</span>
         <span class="comment">// port is not currently open.</span>

     <span class="keywordtype">int</span> close();
         <span class="comment">// Close the listening socket; return 0 on success and a non-zero</span>
         <span class="comment">// value otherwise.  The behavior is undefined unless the listening</span>
         <span class="comment">// socket is currently open.</span>
 };
</pre></div><br/>
<br/>
 The implementation of the public methods of <code>my_EchoServer</code> is trivial. For the constructor, the socket factory and socket event manager are passed to the acceptor, and the allocate callback and (three) event timeouts are initialized. The <code>open</code> and <code>close</code> methods just invoke appropriate methods of the acceptor. The destructor ensures that the state of the acceptor is valid: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_EchoServer::my_EchoServer(
          <a class="code" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt;</a> *factory,
          <a class="code" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a>                      *manager)
  : d_allocator(factory, manager)
  , d_acceptTimeout(120, 0)
  , d_readTimeout(5, 0)
  , d_writeTimeout(5.0)
  {
      assert(factory); assert(manager);
      d_allocateFunctor = <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;allocateCb, <span class="keyword">this</span>);
  }

  my_EchoServer::~my_EchoServer() {
  }

  <span class="keywordtype">int</span> my_EchoServer::open(<span class="keywordtype">int</span> portNumber) {
      <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> serverAddress;
      serverAddress.<a class="code" href="classbtlso_1_1IPv4Address.html#a0db9b6717cd8bd435caeeb46a9bbd818">setPortNumber</a>(portNumber);

      <span class="keywordflow">if</span> (d_allocator.open(serverAddress, k_QUEUE_SIZE)) {
          <span class="keywordflow">return</span> -1;
      }
      <span class="comment">// Set reuse address socket option on the listening socket.</span>
      <span class="keywordflow">if</span> (d_allocator.setOption(<a class="code" href="structbtlso_1_1SocketOptUtil.html#a4ed4579b98bf97bb0f7dcaed4dd72c28a30cdb6b13d24538f164fd37921fe733e" title="System socket level.">btlso::SocketOptUtil::k_SOCKETLEVEL</a>,
                                <a class="code" href="structbtlso_1_1SocketOptUtil.html#a3134417992f0fab8ca89a1480b2e410da99ac2f4190ea847b084d6f2a3b772cf0" title="enable/disable local address reuse">btlso::SocketOptUtil::k_REUSEADDRESS</a>,
                                1))
      {
          d_allocator.close();
          <span class="keywordflow">return</span> -2;
      }
      <span class="keywordflow">if</span> (d_allocator.timedAllocateTimed(d_allocateFunctor,
                 <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + d_acceptTimeout))
      {
          <span class="comment">// Failed to enqueue a request -- the allocator is invalid.</span>
          d_allocator.close();
          <span class="keywordflow">return</span> -3;
      }
      <span class="keywordflow">return</span> 0;
  }

  <span class="keywordtype">int</span> my_EchoServer::close() {
      <span class="keywordflow">return</span> d_allocator.close();
  }
</pre></div><br/>
<br/>
 All the work of accepting connections and reading/writing the data is done in the (private) callback methods of <code>my_EchoServer</code>. When the connection is established and the <code>allocateCb</code> method is invoked, the buffered read with timeout is initiated on the channel and another allocation request is enqueued. If any error occurs while allocating, the acceptor is shut down. If any error, including timeout, occurs while reading or writing data, the channel is shut down. Note that the allocation functor is cached to improve performance: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> my_EchoServer::allocateCb(<a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel,
                                 <span class="keywordtype">int</span>                    status) {
      <span class="keywordflow">if</span> (channel) {
          <span class="comment">// Accepted a connection;  issue a buffered read request.</span>
          bsl::function&lt;void(const char *, int, int)&gt; callback(
                  <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;bufferedReadCb,
                                      <span class="keyword">this</span>,
                                      <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, _2, _3,
                                      channel));
          <span class="keywordflow">if</span> (channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#a1bcaa5992ed3d03f3f5e983942c6f547">timedBufferedRead</a>(k_READ_SIZE,
                  <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + d_readTimeout, callback)) {
              bsl::cout &lt;&lt; <span class="stringliteral">&quot;Failed to enqueue read request.&quot;</span> &lt;&lt; bsl::endl;
              d_allocator.deallocate(channel);
          }
          <span class="comment">// Re-register allocate callback functor.</span>
          <span class="keywordflow">if</span> (d_allocator.timedAllocateTimed(d_allocateFunctor,
                  <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + d_acceptTimeout)) {
              d_allocator.close();
          }
          <span class="keywordflow">return</span>;
      }
      <span class="keywordflow">else</span> {  <span class="comment">// !channel</span>
          assert(status &lt;= 0);
          <span class="keywordflow">if</span> (0 == status) {
              bsl::cout &lt;&lt; <span class="stringliteral">&quot;Timed out while accepting a connection.&quot;</span>
                        &lt;&lt; bsl::endl;
              <span class="comment">// Re-register the functor.</span>
              <span class="keywordflow">if</span> (d_allocator.timedAllocateTimed(d_allocateFunctor,
                      <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + d_acceptTimeout)) {
                d_allocator.close();
              }
          }
          <span class="keywordflow">else</span> {
              <span class="comment">// Hard-error accepting a connection, invalidate the allocator.</span>
              bsl::cout &lt;&lt; <span class="stringliteral">&quot;Hard error while accepting a connection.&quot;</span>
                        &lt;&lt; bsl::endl;
              d_allocator.invalidate();
              d_allocator.close();
          }
      }
  }

  <span class="keywordtype">void</span> my_EchoServer::bufferedReadCb(<span class="keyword">const</span> <span class="keywordtype">char</span>           *buffer,
                                     <span class="keywordtype">int</span>                   status,
                                     <span class="keywordtype">int</span>                   asyncStatus,
                                     <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel)
  {
      assert(channel);
      <span class="keywordflow">if</span> (status &gt; 0) {
          bsl::function&lt;void(int, int)&gt; callback(
                  <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;writeCb,
                                      <span class="keyword">this</span>,
                                      <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, _2,
                                      channel,
                                      status));
          <span class="keywordflow">if</span> (channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#aec7af32d3d17c756292f391f8c5652eb">timedBufferedWrite</a>(buffer, status,
                  <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + d_writeTimeout, callback)) {
              bsl::cout &lt;&lt; <span class="stringliteral">&quot;Failed to enqueue write request.&quot;</span> &lt;&lt; bsl::endl;
              d_allocator.deallocate(channel);
              <span class="keywordflow">return</span>;
          }

          <span class="comment">// Re-register read request</span>
          bsl::function&lt;void(const char *, int, int)&gt; readCallback(
                  <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;bufferedReadCb,
                                      <span class="keyword">this</span>,
                                      <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, _2, _3,
                                      channel));

          <span class="keywordflow">if</span> (channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#a1bcaa5992ed3d03f3f5e983942c6f547">timedBufferedRead</a>(k_READ_SIZE,
                  <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + d_readTimeout, readCallback)) {
              bsl::cout &lt;&lt; <span class="stringliteral">&quot;Failed to enqueue read request.&quot;</span> &lt;&lt; bsl::endl;
              d_allocator.deallocate(channel);
          }
      }
      <span class="keywordflow">else</span> {
          <span class="comment">// Either time out or an error on the channel</span>
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Failed to read data.&quot;</span> &lt;&lt; bsl::endl;
          d_allocator.deallocate(channel);
      }
  }

  <span class="keywordtype">void</span> my_EchoServer::writeCb(<span class="keywordtype">int</span>                  status,
                              <span class="keywordtype">int</span>                  asyncStatus,
                              <a class="code" href="classbtlsc_1_1TimedCbChannel.html">btlsc::TimedCbChannel</a> *channel,
                              <span class="keywordtype">int</span>                   numBytes)
  {
      <span class="keywordflow">if</span> (status != numBytes) {
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Failed to send data.&quot;</span> &lt;&lt; bsl::endl;
          channel-&gt;<a class="code" href="classbtlsc_1_1TimedCbChannel.html#a4864a8e61648ff1937000b69ee2c721b">invalidate</a>();
          d_allocator.deallocate(channel);
      }
  }
</pre></div><br/>
<br/>
 Finally, we define the <code>main</code> function, which will create the concrete socket factory and concrete socket event manager, create <code>my_EchoServer</code> as required, and go into "infinite" loop dispatching registered callbacks: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> main() {
     <a class="code" href="classbtlso_1_1InetStreamSocketFactory.html">btlso::InetStreamSocketFactory&lt;btlso::IPv4Address&gt;</a> factory;
     <a class="code" href="classbtlso_1_1TcpTimerEventManager.html">btlso::TcpTimerEventManager</a>                    manager;
     my_EchoServer echoServer(&amp;factory, &amp;manager);

     <span class="keywordflow">if</span> (echoServer.open()) {
         bsl::cout &lt;&lt; <span class="stringliteral">&quot;Can&#39;t open listening socket.&quot;</span> &lt;&lt; bsl::endl;
         <span class="keywordflow">return</span> -1;
     }

     <span class="keywordflow">while</span> (manager.<a class="code" href="classbtlso_1_1TcpTimerEventManager.html#a9409088774d044ab30e5bf3d82f78950">dispatch</a>(btlso::TimerEventManager::NON_INTERRUPTIBLE)) {
         <span class="comment">// Do nothing</span>
     }

     <span class="keywordflow">return</span> 0;
 }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:16 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
