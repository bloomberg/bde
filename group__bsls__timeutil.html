<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bsls_timeutil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bsls_timeutil<br/>
<small>
[<a class="el" href="group__bsls.html">Package bsls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a platform-neutral functional interface to system clocks.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Accuracy and Precision</a> <ul>
<li>
<a href="#3.1.1">Accuracy on Windows</a> <ul>
<li>
<a href="#3.1.1.1">CPU Scaling</a> </li>
<li>
<a href="#3.1.1.2">Multi-Core Issues</a> </li>
</ul>
</li>
<li>
<a href="#3.1.2">Ensuring Accurate Timers on Windows</a> </li>
</ul>
</li>
<li>
<a href="#3.2">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a platform-neutral functional interface to system clocks. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbsls_1_1TimeUtil.html">bsls::TimeUtil</a> </td><td>namespace for platform-neutral system-time pure procedures  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bsls__stopwatch.html" title="Provide access to user, system, and wall times of current process.">Component bsls_stopwatch</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a set of platform-neutral pure procedures to access real-time system clock functionality. High-resolution time functions intended for interval-timing return a time interval in nanoseconds (1 nsec = 1E-9 sec) as a 64-bit integer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="accuracy_and_precision"></a> <a class="anchor" id="description.accuracy_and_precision"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Accuracy and Precision: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="structbsls_1_1TimeUtil.html">bsls::TimeUtil</a></code> high-resolution functions return time values as absolute nanoseconds from an arbitrary reference that will <em>in many cases</em> remain fixed within a single process (and among running processes on a single machine). Absolute monotonic behavior is platform-dependent, however, as are accuracy and useful precision, despite the nominal nanosecond precision implied by the return value. The user is advised to determine the actual performance on each platform of interest. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="accuracy_on_windows"></a> <a class="anchor" id="accuracy_and_precision.accuracy_on_windows"></a> <a class="anchor" id="description.accuracy_and_precision.accuracy_on_windows"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Accuracy on Windows: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>On certain windows platform configurations, <code><a class="el" href="structbsls_1_1TimeUtil.html#a5a3f353e27dfd55ec23efbb8dfa21e80">bsls::TimeUtil::getTimer</a></code> and <code>bsls::TimeUtil::getRawTimer</code> can produce unreliable results. On some machines, these high-resolution functions have been observed to run at inconsistent speeds, with worst cases as slow as half the speed of actual wall time. This is known behavior of the underlying high-performance timer function <code>QueryPerformanceCounter</code>, upon which the Windows implementation of <code><a class="el" href="structbsls_1_1TimeUtil.html">bsls::TimeUtil</a></code> relies. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="cpu_scaling"></a> <a class="anchor" id="accuracy_on_windows.cpu_scaling"></a> <a class="anchor" id="accuracy_and_precision.accuracy_on_windows.cpu_scaling"></a> <a class="anchor" id="description.accuracy_and_precision.accuracy_on_windows.cpu_scaling"></a> <a class="anchor" id="3.1.1.1"></a> </dd></dl>
<dl class="user"><dt><b>CPU Scaling: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The behavior of the timer on windows platforms depends on the interaction of operating system, BIOS, and processor, and certain combinations of the three (particularly older ones) are vulnerable to timer inaccuracy. For example, frequently the <code>QueryPerformanceCounter</code> function that <code>TmeUtil</code> uses on Windows will utilize the CPU's timestamp counter (TSC), and CPUs with speed scaling mechanisms such as SpeedStep (frequently used for power management) will generally see the clock speed vary with the CPU frequency. However, newer processors often provide an <code>Invariant TSC</code> that solves this problem. Also versions of Windows starting with Vista may internally handle the inconsistency by automatically using a lower resolution, but accurate, counter on processors that do not provide an <code>Invariant TSC</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="multi-core_issues"></a> <a class="anchor" id="accuracy_on_windows.multi-core_issues"></a> <a class="anchor" id="accuracy_and_precision.accuracy_on_windows.multi-core_issues"></a> <a class="anchor" id="description.accuracy_and_precision.accuracy_on_windows.multi-core_issues"></a> <a class="anchor" id="3.1.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Multi-Core Issues: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition, on multi-core machines, each call to <code>QueryPerformanceCounter</code> may read the TSC from a different CPU. The TSCs of the CPUs may be out of sync, resulting in slightly inconsistent or even non-monotonic behavior. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Reference: <a href="http://support.microsoft.com/kb/895980">http://support.microsoft.com/kb/895980</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="ensuring_accurate_timers_on_windows"></a> <a class="anchor" id="accuracy_and_precision.ensuring_accurate_timers_on_windows"></a> <a class="anchor" id="description.accuracy_and_precision.ensuring_accurate_timers_on_windows"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Ensuring Accurate Timers on Windows: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If a Windows machine appears to have a slow and/or inconsistent high-resolution timer, it can be reconfigured to avoid using the TSC. On Windows XP and earlier versions, add the parameter <code>/usepmtimer</code> to the operating system's boot configuration in <code>boot.ini</code>. On Windows Vista and later, run the following command as an administrator: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bcdedit /<span class="keyword">set</span> useplatformclock <span class="keyword">true</span>
</pre></div><br/>
<br/>
 Note that unless the machine has a High Performance Event Timer (HPET) and it has been enabled in the BIOS, these steps might reduce the resolution of the <code><a class="el" href="structbsls_1_1TimeUtil.html">bsls::TimeUtil</a></code> high-resolution functions from the nanosecond range to the microsecond range (or worse). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippets of code illustrate how to use <code><a class="el" href="structbsls_1_1TimeUtil.html">bsls::TimeUtil</a></code> functions to implement a very simple timer. Only the most primitive functionality is illustrated. See the <code><a class="el" href="classbsls_1_1Stopwatch.html">bsls::Stopwatch</a></code> component for a better example of a timer interface. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_timer.h</span>

<span class="preprocessor">  #ifndef INCLUDED_BSLS_TYPES</span>
<span class="preprocessor"></span><span class="preprocessor">  #include &lt;<a class="code" href="bsls__types_8h.html" title="Provide a consistent interface for platform-dependent types.">bsls_types.h</a>&gt;</span>   <span class="comment">// bsls::Types::Int64</span>
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">  #ifndef INCLUDED_BSLS_TIMEUTIL</span>
<span class="preprocessor"></span><span class="preprocessor">  #include &lt;<a class="code" href="bsls__timeutil_8h.html" title="Provide a platform-neutral functional interface to system clocks.">bsls_timeutil.h</a>&gt;</span>
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>
 <span class="keyword">class </span>my_Timer {
     <span class="comment">// This class implements a simple interval timer that is created in</span>
     <span class="comment">// the &quot;running&quot; state, and may be queried for its cumulative</span>
     <span class="comment">// interval (as a &#39;double&#39;, in seconds) but never stopped or reset.</span>

     <a class="code" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> d_startWallTime;   <span class="comment">// time at creation (nsec)</span>
     <a class="code" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> d_startUserTime;   <span class="comment">// time at creation (nsec)</span>
     <a class="code" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> d_startSystemTime; <span class="comment">// time at creation (nsec)</span>

   <span class="keyword">public</span>:
     <span class="comment">// CREATORS</span>
     my_Timer() {
         d_startWallTime = <a class="code" href="structbsls_1_1TimeUtil.html#a5a3f353e27dfd55ec23efbb8dfa21e80">bsls::TimeUtil::getTimer</a>();
         d_startUserTime = <a class="code" href="structbsls_1_1TimeUtil.html#a68e84421ebb3c39360d5fba883dfbf13">bsls::TimeUtil::getProcessUserTimer</a>();
         d_startSystemTime = <a class="code" href="structbsls_1_1TimeUtil.html#af3453076511fc824c920e9fa802d33ff">bsls::TimeUtil::getProcessSystemTimer</a>();
     }
         <span class="comment">// Create a timer object initialized with the times at creation.</span>
         <span class="comment">// All values returned by subsequent calls to &#39;elapsed&lt;...&gt;Time()&#39;</span>
         <span class="comment">// are with respect to this creation time.</span>

     ~my_Timer() {}

     <span class="comment">// ACCESSORS</span>
     <span class="keywordtype">double</span> elapsedWallTime();
         <span class="comment">// Return the total elapsed time in seconds since the creation of</span>
         <span class="comment">// this timer object.</span>
     <span class="keywordtype">double</span> elapsedUserTime();
         <span class="comment">// Return the elapsed user time in seconds since the creation of</span>
         <span class="comment">// this timer object.</span>
     <span class="keywordtype">double</span> elapsedSystemTime();
         <span class="comment">// Return the elapsed system time in seconds since the creation of</span>
         <span class="comment">// this timer object.</span>
 };

 <span class="keyword">inline</span>
 <span class="keywordtype">double</span> my_Timer::elapsedWallTime()
 {
     <span class="keywordflow">return</span> (<span class="keywordtype">double</span>) (<a class="code" href="structbsls_1_1TimeUtil.html#a5a3f353e27dfd55ec23efbb8dfa21e80">bsls::TimeUtil::getTimer</a>() - d_startWallTime) * 1.0E-9;
 }

 <span class="keyword">inline</span>
 <span class="keywordtype">double</span> my_Timer::elapsedUserTime()
 {
     <span class="keywordflow">return</span> (<span class="keywordtype">double</span>) (<a class="code" href="structbsls_1_1TimeUtil.html#a68e84421ebb3c39360d5fba883dfbf13">bsls::TimeUtil::getProcessUserTimer</a>()
                                                 - d_startUserTime) * 1.0E-9;
 }

 <span class="keyword">inline</span>
 <span class="keywordtype">double</span> my_Timer::elapsedSystemTime()
 {
     <span class="keywordflow">return</span> (<span class="keywordtype">double</span>) (<a class="code" href="structbsls_1_1TimeUtil.html#af3453076511fc824c920e9fa802d33ff">bsls::TimeUtil::getProcessSystemTimer</a>()
                                               - d_startSystemTime) * 1.0E-9;
 }
  <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 The <code>my_Timer</code> object may be used to time some section of code at runtime as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// ...</span>
  {
      my_Timer tw;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000000; ++i) {
          <span class="comment">// ...</span>
      }
      <span class="keywordtype">double</span> dTw = tw.elapsedWallTime();
      my_Timer tu;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000000; ++i) {
          <span class="comment">// ...</span>
      }
      <span class="keywordtype">double</span> dTu = tu.elapsedUserTime();
      my_Timer ts;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000000; ++i) {
          <span class="comment">// ...</span>
      }
      <span class="keywordtype">double</span> dTs = ts.elapsedSystemTime();
      std::cout &lt;&lt; <span class="stringliteral">&quot;elapsed wall time:   &quot;</span> &lt;&lt; dTw &lt;&lt; std::endl
                &lt;&lt; <span class="stringliteral">&quot;elapsed user time:   &quot;</span> &lt;&lt; dTu &lt;&lt; std::endl
                &lt;&lt; <span class="stringliteral">&quot;elapsed system time: &quot;</span> &lt;&lt; dTs &lt;&lt; std::endl;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:43 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
