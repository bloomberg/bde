<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslmf_enableif.h                                                   -*-C++-*-
#ifndef INCLUDED_BSLMF_ENABLEIF
#define INCLUDED_BSLMF_ENABLEIF

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a utility to set up SFINAE conditions in type deduction.
//
//@CLASSES:
//  bsl::enable_if: standard meta-function to drop function templates from
//                  overload sets
//
//  bslmf::EnableIf: meta-function to drop function templates from overload
//                   sets
//
//@DESCRIPTION: This component defines two meta-functions, &#39;bsl::enable_if&#39; and
// &#39;bslmf::EnableIf&#39;, both of which may be used to conditionally remove
// (potential) template instantiations as candidates for overload resolution by
// causing a deduced template instantiation to fail in a way compatible with
// the C++ SFINAE rules.
//
// &#39;bsl::enable_if&#39; meets the requirements of the &#39;enable_if&#39; template defined
// in the C++11 standard [meta.trans.ptr], while &#39;bslmf::EnableIf&#39; was devised
// before &#39;enable_if&#39; was standardized.
//
// The two meta-functions provide identical functionality.  Both meta-functions
// provide a &#39;typedef&#39; &#39;type&#39; that is an alias to a (template parameter) type
// if a (template parameter) condition is &#39;true&#39;; otherwise, &#39;type&#39; is not
// provided.
//
// Note that &#39;bsl::enable_if&#39; should be preferred over &#39;bslmf::EnableIf&#39;, and
// in general, should be used by new components.
//
///Visual Studio Workaround
///------------------------
// Because of a Visual Studio bug, described here:
// http://connect.microsoft.com/VisualStudio/feedback/details/332179/ The
// Microsoft Visual Studio compiler may not correctly associate a function
// declaration that uses &#39;bsl::enable_if&#39; with that function&#39;s definition, if
// the definition is not inline to the declaration.  This bug effects at least
// Visual Studio 2008 and 2010.  The work-around is to implement functions
// using &#39;bsl::enable_if&#39; in-line with their declaration.
//
///Usage
///-----
// The following snippets of code illustrate basic use of the &#39;bsl::enable_if&#39;
// meta-function.  We will demonstrate how to use this utility to control
// overload sets with three increasingly complex examples.
//
///Example 1: Implementing a Simple Function with &#39;bsl::enable_if&#39;
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// For the first example we will implement a simple &#39;Swap&#39; function template to
// exchange two arbitrary values, as if declared as below:
//..
//  template&lt;class T&gt;
//  void DummySwap(T&amp; a, T&amp; b)
//      // Exchange the values of the specified objects, &#39;a&#39; and &#39;b&#39;.
//  {
//      T temp(a);
//      a = b;
//      b = temp;
//  }
//..
// However, we want to take advantage of member-swap methods supplied by user-
// defined types, so we define a trait that can be customized by a class
// implementer to indicate that their class supports an optimized member-swap
// method:
//..
//  template&lt;class T&gt;
//  struct HasMemberSwap : bsl::false_type {
//      // This traits class indicates whether the specified template type
//      // parameter &#39;T&#39; has a public &#39;swap&#39; method to exchange values.
//  };
//..
// Now we can implement a generic &#39;Swap&#39; function template that will invoke the
// member swap operation for any type that specialized our trait.  The use of
// &#39;bsl::enable_if&#39; to declare the result type causes an attempt to deduce the
// type &#39;T&#39; to fail unless the specified condition is &#39;true&#39;, and this falls
// under the &quot;Substitution Failure Is Not An Error&quot; (SFINAE) clause of the C++
// standard, so the compiler will look for a more suitable overload rather than
// fail with an error.  Note that we provide two overloaded declarations that
// appear to differ only in their return type, which would normally raise an
// ambiguity error.  This works, and is in fact required, in this case as the
// &quot;enable-if&quot; conditions are mutually exclusive, so that only one overload
// will ever be present in an overload set.
//..
//  template&lt;class T&gt;
//  typename bsl::enable_if&lt;HasMemberSwap&lt;T&gt;::value&gt;::type
//  Swap(T&amp; a, T&amp; b)
//  {
//      a.swap(b);
//  }
//
//  template&lt;class T&gt;
//  typename bsl::enable_if&lt; ! HasMemberSwap&lt;T&gt;::value&gt;::type
//  Swap(T&amp; a, T&amp; b)
//  {
//      T temp(a);
//      a = b;
//      b = temp;
//  }
//..
// Next we define a simple container template, that supports an optimized
// &#39;swap&#39; operation by merely swapping the internal pointers, rather than
// exchanging each element:
//..
//  template&lt;class T&gt;
//  class MyContainer {
//      // This is a simple container implementation for demonstration purposes
//      // that is modeled after &#39;std::vector&#39;.
//
//      // DATA
//      T           *d_storage;
//      std::size_t  d_length;
//
//      // NOT IMPLEMENTED
//      MyContainer(const MyContainer&amp;);
//      MyContainer&amp; operator=(const MyContainer&amp;);
//
//  public:
//      MyContainer(const T&amp; value, int n);
//          // Create a &#39;MyContainer&#39; object having the specified &#39;n&#39; copies of
//          // the specified &#39;value&#39;.
//
//      ~MyContainer();
//          // Destroy this container and all of its elements, reclaiming any
//          // allocated memory.
//
//      void swap(MyContainer &amp;other);
//          // Exchange the contents of &#39;this&#39; container with those of the
//          // specified &#39;other&#39;.  No memory will be allocated, and no
//          // exceptions are thrown.
//
//      const T&amp; front() const;
//          // Return a reference with &#39;const&#39; access to the first element in
//          // this container.
//
//      size_t size() const;
//          // Return the number of elements held by this container.
//  };
//..
// Then we specialize our &#39;HasMemberSwap&#39; trait for this new container type.
//..
//  template&lt;class T&gt;
//  struct HasMemberSwap&lt;MyContainer&lt;T&gt; &gt; : bsl::true_type {
//  };
//..
// Next we implement the methods of this class:
//..
//  template&lt;class T&gt;
//  MyContainer&lt;T&gt;::MyContainer(const T&amp; value, int n)
//  : d_storage(new T[n])
//  , d_length(n)
//  {
//      for (int i = 0; i !=n; ++i) {
//          d_storage[i] = value;
//      }
//  }
//
//  template&lt;class T&gt;
//  MyContainer&lt;T&gt;::~MyContainer()
//  {
//      delete[] d_storage;
//  }
//
//  template&lt;class T&gt;
//  void MyContainer&lt;T&gt;::swap(MyContainer&amp; other)
//  {
//      Swap(d_storage, other.d_storage);
//      Swap(d_length,  other.d_length);
//  }
//
//  template&lt;class T&gt;
//  const T&amp; MyContainer&lt;T&gt;::front() const
//  {
//      return d_storage[0];
//  }
//
//  template&lt;class T&gt;
//  size_t MyContainer&lt;T&gt;::size() const
//  {
//      return d_length;
//  }
//..
// Finally we can test that the member-&#39;swap&#39; method is called by the generic
// &#39;Swap&#39; function.  Note that the following code will not compile unless the
// member-function &#39;swap&#39; is used, as the copy constructor and assignment
// operator for the &#39;MyContainer&#39; class template are declared as private.
//..
//  void TestSwap()
//  {
//      MyContainer&lt;int&gt; x(3, 14);
//      MyContainer&lt;int&gt; y(2, 78);
//      assert(14 == x.size());
//      assert( 3 == x.front());
//      assert(78 == y.size());
//      assert( 2 == y.front());
//
//      Swap(x, y);
//
//      assert(78 == x.size());
//      assert( 2 == x.front());
//      assert(14 == y.size());
//      assert( 3 == y.front());
//  }
//..
//
///Example 2: Using the &#39;bsl::enable_if&#39; Result Type
///- - - - - - - - - - - - - - - - - - - - - - - - -
// For the next example, we will demonstrate the use of the second template
// parameter in the &#39;bsl::enable_if&#39; template, which serves as the &quot;result&quot;
// type if the test condition passes.  Assume we want to write a generic
// function to allow us to cast between pointers of different types.  If the
// types are polymorphic, we can use &#39;dynamic_cast&#39; to potentially cast between
// two seemingly unrelated types.  However, if either type is not polymorphic
// then the attempt to use &#39;dynamic_cast&#39; would be a compile-time failure, and
// we must use &#39;static_cast&#39; instead.
//
//..
//  template&lt;class TO, class FROM&gt;
//  typename bsl::enable_if&lt;bsl::is_polymorphic&lt;FROM&gt;::value &amp;&amp;
//                                              bsl::is_polymorphic&lt;TO&gt;::value,
//                          TO&gt;::type *
//  smart_cast(FROM *from)
//      // Returns a pointer to the specified &#39;TO&#39; type if the specified &#39;from&#39;
//      // pointer refers to an object whose complete class publicly derives,
//      // directly or indirectly, from &#39;TO&#39;, and a null pointer otherwise.
//  {
//      return dynamic_cast&lt;TO *&gt;(from);
//  }
//
//  template&lt;class TO, class FROM&gt;
//  typename bsl::enable_if&lt;not(bsl::is_polymorphic&lt;FROM&gt;::value &amp;&amp;
//                                             bsl::is_polymorphic&lt;TO&gt;::value),
//                          TO&gt;::type *
//  smart_cast(FROM *from)
//      // Return the specified &#39;from&#39; pointer value cast as a pointer to type
//      // &#39;TO&#39;.  Behavior is undefined unless such a conversion is valid.
//  {
//      return static_cast&lt;TO *&gt;(from);
//  }
//..
// Next we define a small number of classes to demonstrate that this casting
// utility works correctly:
//..
//  class A {
//     // Sample non-polymorphic class
//
//    public:
//      ~A() {}
//  };
//
//  class B {
//      // Sample polymorphic base-class
//
//    public:
//      virtual ~B() {}
//  };
//
//  class C {
//      // Sample polymorphic base-class
//
//    public:
//      virtual ~C() {}
//  };
//
//  class ABC : public A, public B, public C {
//      // Most-derived example class using multiple bases in order to
//      // demonstrate cross-casting.
//  };
//..
// Finally we demonstrate the correct behavior of the &#39;smart_cast&#39; utility:
//..
//  void TestSmartCast()
//  {
//      ABC object;
//      ABC *pABC = &amp;object;
//      A   *pA   = &amp;object;
//      B   *pB   = &amp;object;
//      C   *pC   = &amp;object;
//
//      A *pA2 = smart_cast&lt;A&gt;(pABC);
//      B *pB2 = smart_cast&lt;B&gt;(pC);
//      C *pC2 = smart_cast&lt;C&gt;(pB);
//
//      assert(&amp;object == pA2);
//      assert(&amp;object == pB2);
//      assert(&amp;object == pC2);
//
//      // These lines would fail to compile
//      // A *pA3 = smart_cast&lt;A&gt;(pB);
//      // C *pC3 = smart_cast&lt;C&gt;(pA);
//  }
//..
//
///Example 3: Controlling Constructor Selection with &#39;bsl::enable_if&#39;
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// The final example demonstrates controlling the selection of a constructor
// template in a class with (potentially) many constructors.  We define a
// simple container template based on &#39;std::vector&#39;, that illustrates a problem
// that may occur when trying to call the constructor the user expects.  For
// this example, assume we are trying to create a &#39;vector&lt;int&gt;&#39; with &#39;42&#39;
// copies of the value &#39;13&#39;.  When we pass the literal values &#39;42&#39; and &#39;13&#39; the
// compiler, the &quot;best&quot; candidate constructor should be the template
// constructor that takes two arguments of the same kind, deducing that type to
// be &#39;int&#39;.  Unfortunately, that constructor expects those values to be of an
// iterator type, forming a valid range.  We need to avoid calling this
// constructor unless the deduced type really is an iterator, otherwise a
// compile-error will occur trying to instantiate that constructor with an
// incompatible argument type.  We use &#39;bsl::enable_if&#39; to create a deduction
// context where SFINAE can kick in.  Note that we cannot deduce the &#39;::type&#39;
// result of a metafunction, and there is no result type (as with a regular
// function) to decorate, so we add an extra dummy argument using a pointer
// type (produced from &#39;bslma::EnableIf::type&#39;) with a default null argument:
//..
//  template&lt;class T&gt;
//  class MyVector {
//      // This is a simple container implementation for demonstration purposes
//      // that is modeled after &#39;std::vector&#39;.
//
//      // DATA
//      T           *d_storage;
//      std::size_t  d_length;
//
//      // NOT IMPLEMENTED
//      MyVector(const MyVector&amp;);
//      MyVector&amp; operator=(const MyVector&amp;);
//
//  public:
//      MyVector(const T&amp; value, int n);
//          // Create a &#39;MyVector&#39; object having the specified &#39;n&#39; copies of
//          // the specified &#39;value&#39;.
//
//      template&lt;typename FORWARD_ITERATOR&gt;
//      MyVector(FORWARD_ITERATOR first, FORWARD_ITERATOR last,
//                  typename bsl::enable_if&lt;
//                      !bsl::is_fundamental&lt;FORWARD_ITERATOR&gt;::value
//                                                               &gt;::type * = 0)
//          // Create a &#39;MyVector&#39; object having the same sequence of values as
//          // found in range described by the iterators &#39;[first, last)&#39;.
//          // Note that this function is currently defined inline to work
//          // around an issue with the Microsoft Visual Studio compiler.
//
//      {
//          d_length = 0;
//          for (FORWARD_ITERATOR cursor = first; cursor != last; ++cursor) {
//               ++d_length;
//          }
//
//         d_storage = new T[d_length];
//         for (int i = 0; i != d_length; ++i) {
//            d_storage[i] = *first++;
//         }
//      }
//
//      ~MyVector();
//          // Destroy this container and all of its elements, reclaiming any
//          // allocated memory.
//
//      const T&amp; operator[](int index) const;
//          // Return a reference with &#39;const&#39; access to the element held by
//          // this container at the specified &#39;index&#39;.
//
//      int size() const;
//          // Return the number of elements held by this container.
//  };
//..
// Note that there is no easy test for whether a type is an iterator, so we
// assume any attempt to call a constructor with two arguments that are not
// fundamental (such as int) must be passing iterators.  Now that we have
// defined the class template, we implement its methods:
//..
//  template&lt;class T&gt;
//  MyVector&lt;T&gt;::MyVector(const T&amp; value, int n)
//  : d_storage(new T[n])
//  , d_length(n)
//  {
//      for (int i = 0; i !=n; ++i) {
//          d_storage[i] = value;
//      }
//  }
//
//  template&lt;class T&gt;
//  MyVector&lt;T&gt;::~MyVector()
//  {
//      delete[] d_storage;
//  }
//
//  template&lt;class T&gt;
//  const T&amp; MyVector&lt;T&gt;::operator[](int index) const
//  {
//      return d_storage[index];
//  }
//
//  template&lt;class T&gt;
//  int MyVector&lt;T&gt;::size() const
//  {
//      return d_length;
//  }
//..
// Finally we demonstrate that the correct constructors are called when invoked
// with appropriate arguments.
//..
//  void TestContainerConstructor()
//  {
//      const unsigned int TEST_DATA[] = { 1, 2, 3, 4, 5 };
//
//      const MyVector&lt;unsigned int&gt; x(&amp;TEST_DATA[0], &amp;TEST_DATA[5]);
//      const MyVector&lt;unsigned int&gt; y(13, 42);
//
//      assert(5 == x.size());
//      for(int i = 0; i != 5; ++i) {
//          assert(TEST_DATA[i] == x[i]);
//      }
//
//      assert(42 == y.size());
//      for(int i = 0; i != 42; ++i) {
//          assert(13 == y[i]);
//      }
//  }
//..

namespace bsl {

                         // ================
                         // struct enable_if
                         // ================

template &lt;bool COND, typename TYPE = void&gt;
struct enable_if {
    // This &#39;struct&#39; template implements the &#39;enable_if&#39; meta-function defined
    // in the C++11 standard [meta.trans.ptr].  This &#39;struct&#39; template provide
    // a &#39;typedef&#39; &#39;type&#39; that is an alias to the (template parameter) &#39;TYPE&#39;
    // if the (template parameter) &#39;COND&#39; is &#39;true&#39;; otherwise, &#39;type&#39; is not
    // provided.  Note that this generic default template provides &#39;type&#39; for
    // when &#39;COND&#39; is &#39;true&#39;; a template specialization is sprovided (below)
    // that omits &#39;type&#39; for when &#39;COND&#39; is &#39;false&#39;.

    typedef TYPE type;
        // This &#39;typedef&#39; is an alias to the (template parameter) &#39;TYPE&#39;.
};

                         // =============================
                         // struct enable_if&lt;false, TYPE&gt;
                         // =============================

template &lt;typename TYPE&gt;
struct enable_if&lt;false, TYPE&gt; {
    // This partial specialization of the &#39;enable_if&#39; meta-function guarantees
    // that no type &#39;typedef&#39; &#39;type&#39; is supplied when the specified boolean
    // value is &#39;false&#39;.  Note that this class definition is intentionally
    // empty.
};

}  // close namespace bsl

namespace BloombergLP {

namespace bslmf {

                               // ===============
                               // struct EnableIf
                               // ===============


template&lt;bool BSLMA_CONDITION, class BSLMA_TYPE = void&gt;
struct EnableIf {
    // This metafunction class defines a type alias, &#39;type&#39;, to the specified
    // type-parameter &#39;BSLMA_TYPE&#39; if, and only if, &#39;BSLMA_CONDITION&#39; is
    // &#39;true&#39;.

    typedef BSLMA_TYPE type;
};

template&lt;class BSLMA_TYPE&gt;
struct EnableIf &lt;false, BSLMA_TYPE&gt; {
    // This partial specialization of the meta-function class guarantees that
    // no type alias &#39;type&#39; is supplied when the specified boolean value is
    // &#39;false&#39;.  Note that this class definition is intentionally empty.
};

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
