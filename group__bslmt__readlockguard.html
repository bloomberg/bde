<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslmt_readlockguard Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslmt_readlockguard<br/>
<small>
[<a class="el" href="group__bslmt.html">Package bslmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a generic proctor for read synchronization objects.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslmt.html">bslmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Behavior of the <code>release</code> Method</a> </li>
<li>
<a href="#3.2">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a generic proctor for read synchronization objects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslmt_1_1ReadLockGuard.html">bslmt::ReadLockGuard</a> </td><td>automatic locking-unlocking for read access  </td></tr>
<tr>
<td><a class="el" href="classbslmt_1_1ReadLockGuardUnlock.html">bslmt::ReadLockGuardUnlock</a> </td><td>automatic unlocking-locking for read access  </td></tr>
<tr>
<td><a class="el" href="classbslmt_1_1ReadLockGuardTryLock.html">bslmt::ReadLockGuardTryLock</a> </td><td>automatic non-blocking locking-unlocking  </td></tr>
<tr>
<td><a class="el" href="classbslmt_1_1LockReadGuard.html">bslmt::LockReadGuard</a> </td><td>DEPRECATED  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslmt__lockguard.html" title="Provide a generic proctor for synchronization objects.">Component bslmt_lockguard</a>, <a class="el" href="group__bslmt__writelockguard.html" title="Provide a generic proctor for write synchronization objects.">Component bslmt_writelockguard</a>, <a class="el" href="group__bslmt__rwmutex.html" title="Provide a platform-independent RW mutex class.">Component bslmt_rwmutex</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides generic proctors, <code><a class="el" href="classbslmt_1_1ReadLockGuard.html">bslmt::ReadLockGuard</a></code>, <code><a class="el" href="classbslmt_1_1ReadLockGuardUnlock.html">bslmt::ReadLockGuardUnlock</a></code>, <code><a class="el" href="classbslmt_1_1ReadLockGuardTryLock.html">bslmt::ReadLockGuardTryLock</a></code>, and <code><a class="el" href="classbslmt_1_1LockReadGuard.html">bslmt::LockReadGuard</a></code>, to automatically lock and unlock an external synchronization object for reading. The synchronization object can be any type (e.g., <code><a class="el" href="classbslmt_1_1ReaderWriterLock.html">bslmt::ReaderWriterLock</a></code>) that provides the following methods: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> lockRead();
  <span class="keywordtype">void</span> unlock();
</pre></div><br/>
<br/>
 Both <code><a class="el" href="classbslmt_1_1ReadLockGuard.html">bslmt::ReadLockGuard</a></code> and <code><a class="el" href="classbslmt_1_1ReadLockGuardUnlock.html">bslmt::ReadLockGuardUnlock</a></code> implement the "construction is acquisition, destruction is release" idiom. During construction, <code><a class="el" href="classbslmt_1_1ReadLockGuard.html">bslmt::ReadLockGuard</a></code> automatically calls <code>lockRead</code> on the user-supplied object, and <code>unlock</code> when it is destroyed (unless released). <code><a class="el" href="classbslmt_1_1ReadLockGuardUnlock.html">bslmt::ReadLockGuardUnlock</a></code> does the opposite -- it invokes the <code>unlock</code> method when constructed and the <code>lockRead</code> method when destroyed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A third type of guard, <code><a class="el" href="classbslmt_1_1ReadLockGuardTryLock.html">bslmt::ReadLockGuardTryLock</a></code>, attempts to acquire a lock, and if acquisition succeeds, releases it upon destruction. Since the acquisition is done at construction time, it is not possible to return a value to indicate success. Rather, the <code><a class="el" href="classbslmt_1_1ReadLockGuardTryLock.html">bslmt::ReadLockGuardTryLock</a></code> contains a pointer to the synchronization object if <code>tryLock</code> succeeds, and is null otherwise. The synchronization object can be any type (e.g., <code><a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a></code> or <code><a class="el" href="classbslmt_1_1RecursiveMutex.html">bslmt::RecursiveMutex</a></code>) that provides the following methods: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> tryLockRead();
  <span class="keywordtype">void</span> unlock();
</pre></div><br/>
<br/>
 Note that objects of none of these guard types assumes ownership of the synchronization object provided at construction. Also note that objects of all of the guard types may be constructed with a null <code>lock</code> whereby the constructed guard objects proctor no lock. The destructor of each of the guard types has no effect if no lock is under management. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="behavior_of_the_release_method"></a> <a class="anchor" id="description.behavior_of_the_release_method"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Behavior of the release Method: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Like all BDE proctor classes, each of the three <code><a class="el" href="classbslmt_1_1ReadLockGuard.html">bslmt::ReadLockGuard</a>*</code> classes provides a <code>release</code> method that terminates the proctor's management of any lock object that the proctor holds. The <code>release</code> method has <em>no</em> <em>effect</em> on the state of the lock object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In particular, <code><a class="el" href="classbslmt_1_1ReadLockGuard.html#a1d01190b21897a58426e2c896e170aae">bslmt::ReadLockGuard::release</a></code> does not unlock the lock object under management. If a user wants to release the lock object <em>and</em> unlock the lock object (because the lock is no longer required before the guard goes out of scope), the following idiom can be used: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// &#39;guard&#39; is an existing guard of type &#39;bslmt::ReadLockGuard&lt;my_RLock&gt;&#39;,</span>
  <span class="comment">// created in a scope that we do not control.</span>

  {
      <span class="comment">// ... Do work that requires the lock.</span>

      <span class="comment">// We know that the lock is no longer needed.</span>

      my_RLock *rlock = guard.release();

      <span class="comment">// &#39;rlock&#39; is no longer managed, but is *still* *locked*.</span>

      rlock-&gt;unlock();

      <span class="comment">// ... Do work that does not require the lock.</span>
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Use this component to ensure that in the event of an exception or exit from any point in a given scope, the synchronization object will be properly unlocked. The following function, <code>errorProneFunc</code>, is overly complex, not exception safe, and contains a bug. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> errorProneFunc(<span class="keyword">const</span> my_Object *obj, my_RWLock *rwlock)
  {
      rwlock-&gt;lockRead();
      <span class="keywordflow">if</span> (someCondition) {
          obj-&gt;someMethod();
          rwlock-&gt;unlock();
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (someOtherCondition) {
          obj-&gt;someOtherMethod();
          <span class="comment">// MISTAKE! forgot to unlock rwlock</span>
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      }
      obj-&gt;defaultMethod();
      rwlock-&gt;unlock();
      <span class="keywordflow">return</span>;
  }
</pre></div><br/>
<br/>
 The function can be rewritten with a cleaner and safer implementation using a guard object. The <code>safeFunc</code> function is simpler than <code>errorProneFunc</code>, is exception safe, and avoids the multiple calls to unlock that can be a source of errors. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> safeFunc(<span class="keyword">const</span> my_Object *obj, my_RWLock *rwlock)
  {
      <a class="code" href="classbslmt_1_1ReadLockGuard.html">bslmt::ReadLockGuard&lt;my_RWLock&gt;</a> guard(rwlock);
      <span class="keywordflow">if</span> (someCondition) {
          obj-&gt;someMethod();
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (someOtherCondition) {
          obj-&gt;someOtherMethod();
          <span class="comment">// OK, rwlock is automatically unlocked</span>
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      }
      obj-&gt;defaultMethod();
      <span class="keywordflow">return</span>;
  }
</pre></div><br/>
<br/>
 When blocking while acquiring the lock is not desirable, one may instead use a <code><a class="el" href="classbslmt_1_1ReadLockGuardTryLock.html">bslmt::ReadLockGuardTryLock</a></code> in the typical following fashion: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">int</span> safeButNonBlockingFunc(<span class="keyword">const</span> my_Object *obj, my_RWLock *rwlock)
      <span class="comment">// Perform task and return positive value if locking succeeds.  Return</span>
      <span class="comment">// 0 if locking fails.</span>
  {
      <span class="keyword">const</span> <span class="keywordtype">int</span> RETRIES = 1; <span class="comment">// use higher values for higher success rate</span>
      <a class="code" href="classbslmt_1_1ReadLockGuardTryLock.html">bslmt::ReadLockGuardTryLock&lt;my_RWLock&gt;</a> guard(rwlock, RETRIES);
      <span class="keywordflow">if</span> (guard.ptr()) { <span class="comment">// rwlock is locked</span>
          <span class="keywordflow">if</span> (someCondition) {
              obj-&gt;someMethod();
              <span class="keywordflow">return</span> 2;                                             <span class="comment">// RETURN</span>
          } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (someOtherCondition) {
              obj-&gt;someOtherMethod();
              <span class="keywordflow">return</span> 3;                                             <span class="comment">// RETURN</span>
          }
          obj-&gt;defaultMethod();
          <span class="keywordflow">return</span> 1;                                                 <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 If the underlying lock object provides an upgrade to a lock for write (as does <code><a class="el" href="classbslmt_1_1ReaderWriterLock.html">bslmt::ReaderWriterLock</a></code> with the <code>upgradeToWriteLock</code> function, for example), this can be safely used in conjunction with <code><a class="el" href="classbslmt_1_1ReadLockGuard.html">bslmt::ReadLockGuard</a></code>, as long as the same <code>unlock</code> method is used to release both kinds of locks. The following method illustrates this usage: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> safeUpdateFunc(my_Object *obj, my_RWLock *rwlock)
  {
      <span class="keyword">const</span> my_Object *constObj = obj;
      <a class="code" href="classbslmt_1_1ReadLockGuard.html">bslmt::ReadLockGuard&lt;my_RWLock&gt;</a> guard(rwlock);
      <span class="keywordflow">if</span> (someUpgradeCondition) {
          rwlock-&gt;upgradeToWriteLock();
          obj-&gt;someUpgradeMethod();
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (someOtherCondition) {
          constObj-&gt;someOtherMethod();
          <span class="comment">// OK, rwlock is automatically unlocked</span>
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      }
      constObj-&gt;defaultMethod();
      <span class="keywordflow">return</span>;
  }
</pre></div><br/>
<br/>
 In the above code, the call to <code>upgradeToWriteLock</code> is not necessarily atomic, as the upgrade may release the lock for read and be interrupted before getting a lock for write. It is possible to guarantee atomicity (as does <code><a class="el" href="classbslmt_1_1ReaderWriterLock.html">bslmt::ReaderWriterLock</a></code> if the <code>lockReadReserveWrite</code> function is used instead of <code>lockRead</code>, for example), but the standard constructor should not be used. Instead, the <code>lockReadReserveWrite</code> lock function should be used explicitly, and the guard constructed with an object which is already locked. The following method illustrates this usage: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> safeAtomicUpdateFunc(my_Object *obj, my_RWLock *rwlock)
  {
      <span class="keyword">const</span> my_Object *constObj = obj;
      rwlock-&gt;lockReadReserveWrite();
      <span class="keyword">const</span> <span class="keywordtype">int</span> PRELOCKED = 1;
      <a class="code" href="classbslmt_1_1ReadLockGuard.html">bslmt::ReadLockGuard&lt;my_RWLock&gt;</a> guard(rwlock, PRELOCKED);
      <span class="keywordflow">if</span> (someUpgradeCondition) {
          rwlock-&gt;upgradeToWriteLock();
          obj-&gt;someUpgradeMethod();
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (someOtherCondition) {
          constObj-&gt;someOtherMethod();
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      }
      constObj-&gt;defaultMethod();
      <span class="keywordflow">return</span>;
  }
</pre></div><br/>
<br/>
 Note that in the code above, the function <code>rwlock-&gt;lockRead()</code> is never called, but is nevertheless required for the code to compile. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Instantiations of <code><a class="el" href="classbslmt_1_1ReadLockGuardUnlock.html">bslmt::ReadLockGuardUnlock</a></code> can be interleaved with instantiations of <code><a class="el" href="classbslmt_1_1ReadLockGuard.html">bslmt::ReadLockGuard</a></code> to create both critical sections and regions where the lock is released. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> f(my_RWLock *rwlock)
  {
      <a class="code" href="classbslmt_1_1ReadLockGuard.html">bslmt::ReadLockGuard&lt;my_RWLock&gt;</a> guard(rwlock);

      <span class="comment">// critical section here</span>

      {
          <a class="code" href="classbslmt_1_1ReadLockGuardUnlock.html">bslmt::ReadLockGuardUnlock&lt;my_RWLock&gt;</a> guard(rwlock);

          <span class="comment">// rwlock is unlocked here</span>

      } <span class="comment">// rwlock is locked again here</span>

      <span class="comment">// critical section here</span>

  } <span class="comment">// rwlock is unlocked here</span>
</pre></div><br/>
<br/>
 Care must be taken so as not to interleave guard objects in such a way as to cause an illegal sequence of calls on a lock (two sequential lock calls or two sequential unlock calls on a non-recursive read/write lock). </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:01 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
