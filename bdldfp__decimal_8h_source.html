<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdldfp_decimal.h                                                   -*-C++-*-
#ifndef INCLUDED_BDLDFP_DECIMAL
#define INCLUDED_BDLDFP_DECIMAL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$&quot;)

//@PURPOSE: Provide IEEE-754 decimal floating-point types.
//
//@CLASSES:
//  bdldfp::Decimal32:   32bit IEEE-754 decimal floating-point type
//  bdldfp::Decimal64:   64bit IEEE-754 decimal floating-point type
//  bdldfp::Decimal128: 128bit IEEE-754 decimal floating-point type
//  bdldfp::DecimalNumGet: Stream Input Facet
//  bdldfp::DecimalNumPut: Stream Output Facet
//
//@MACROS:
//  BDLDFP_DECIMAL_DF: Portable Decimal32 literal macro
//  BDLDFP_DECIMAL_DD: Portable Decimal64 literal macro
//  BDLDFP_DECIMAL_DL: Portable Decimal128 literal macro
//
//@SEE_ALSO: bdldfp_decimalutil, bdldfp_decimalconvertutil,
//           bdldfp_decimalplatform
//
//@DESCRIPTION: This component provides classes that implement decimal
// floating-point types that conform in layout, encoding and operations to the
// IEEE-754 2008 standard.  This component also provides two facets to support
// standard C++ streaming operators as specified by ISO/IEC TR-24733:2009.
// These classes are &#39;bdldfp::Decimal32&#39; for 32-bit Decimal floating point
// numbers, &#39;bdldfp::Decimal64&#39; for 64-bit Decimal floating point numbers, and
// &#39;bdldfp::Decimal128&#39; for 128-bit decimal floating point numbers.
//
// Decimal encoded floating-point numbers are important where exact
// representation of decimal fractions is required, such as in financial
// transactions.  Binary encoded floating-point numbers are generally optimal
// for complex computation but cannot exactly represent commonly encountered
// numbers such as 0.1, 0.2, and 0.99.
//
// The BDE decimal floating-point system has been designed from the ground up
// to be portable and support writing portable decimal floating-point user
// code, even for systems that do not have compiler or native library support
// for it; while taking advantage of native support (such as ISO/IEC TR
// 24732 - C99 decimal TR) when available.
//
// &#39;bdldfp::DecimalNumGet&#39; and &#39;bdldfp::DecimalNumPut&#39; are IO stream facets.
//
///Floating-Point Primer
///---------------------
// There are several ways of represent numbers when using digital computers.
// The simplest would be an integer format, however such a format severely
// limits the range of numbers that can be represented; and it cannot represent
// real (non-integer) numbers directly at all.  Integers might be used to
// represent real numbers of limited precision by treating them as a multiple
// of the real value being represented; these are often known as fixed-point
// numbers.  However general computations require higher precision and a larger
// range than integer and fixed point types are able to efficiently provide.
// Floating-point numbers provide what integers cannot.  They are able to
// represent a large range of real values (although not precisely) while using
// a fixed (and reasonable) amount of storage.
//
// Floating-point numbers are constructed from a set of significant digits of a
// radix on a sliding scale, where their position is determined by an exponent
// over the same radix.  For example let&#39;s see some 32bit decimal (radix 10)
// floating-point numbers that have maximum 7 significant digits (significand):
//..
//   Significand | Exponent | Value        |
//  -------------+----------+--------------+  In the Value column you may
//       1234567 |        0 |   1234567.0  |  observer how the decimal point
//       1234567 |        1 |  12345670.0  |  is &quot;floating&quot; about the digits
//       1234567 |        2 | 123456700.0  |  of the significand.
//       1234567 |       -1 |    123456.7  |
//       1234567 |       -2 |     12345.67 |
//..
// Floating-point numbers are standardized by IEEE-754 2008, in two major
// flavors: binary and decimal.  Binary floating-point numbers are supported by
// most computer systems in the forms of the &#39;float&#39;, &#39;double&#39; and
// &#39;long double&#39; fundamental data types.  While they are not required to be
// binary that is almost always the choice on modern binary computer
// architectures.
//
///Floating-Point Peculiarities
/// - - - - - - - - - - - - - -
// Floating-point approximation of real numbers creates a deliberate illusion.
// While it looks like we are working with real numbers, floating-point
// encodings are not able to represent real numbers precisely since they have a
// restricted number of digits in the significand.  In fact, a 64 bit
// floating-point type can represent fewer distinct values than a 64 bit binary
// integer.  Yet, because floating-point encodings can represent numbers over a
// much larger range, including extremely small (fractional) numbers, they are
// useful in practice.
//
// Floating-point peculiarities may be split into three categories: those that
// are due to the (binary) radix/base, those that are inherent properties of
// any floating-point representation and finally those that are introduced by
// the IEEE-754 2008 standard.  Decimal floating-point addresses the first set
// of surprises only; so users still need to be aware of the rest.
//
//: 1 Floating-point types cannot exactly represent every number in their
//:   range.  The consequences are surprising and unexpected for the newcomer.
//:   For example: when using binary floating-point numbers, the following
//:   expression is typically *false*: &#39;0.1 + 0.2 == 0.3&#39;.  The problem is not
//:   limited to binary floating-point.  Decimal floating-point cannot
//:   represent the value of one third exactly.
//:
//: 2 Unlike with real numbers, the order of operations on floating-point
//:   numbers is significant, due to accumulation of round off errors.
//:   Therefore floating-point arithmetic is neither commutative nor
//:   transitive.  E.g., 2e-30 + 1e30 - 1e-30 - 1e30 will typically produce 0
//:   (unless your significand can hold 60 decimal digits).  Alternatively,
//:   1e30 - 1e30 + 2e-30 - 1e-30 will typically produce 1e-30.
//:
//: 3 IEEE floating-point types can have special values: negative zero,
//:   negative and positive infinity; and they can be NaN (Not a Number, in two
//:   variants: quiet or signaling).  A NaN (any variant) is never equal to
//:   anything else - including NaN or itself!
//:
//: 4 In IEEE floating-point there are at least two representations of 0, the
//:   positive zero and negative zero.  Consequently unary - operators change
//:   the sign of the value 0; therefore leading to surprising results: if
//:   &#39;f == 0.0&#39; then &#39;0 - f&#39; and &#39;-f&#39; will not result in the same value,
//:   because &#39;0 - f&#39; will be +0.0&#39; while &#39;-f&#39; will be -0.0. ** HERE WE ARE **
//:
//: 5 Most IEEE floating-point operations (like arithmetic) have implicit input
//:   parameters and output parameters (that do not show up in function
//:   signatures.  The implicit input parameters are called *attributes* by
//:   IEEE while the outputs are called status flags.  The C/C++ programming
//:   language defines a so-called floating-point environment that contains
//:   those attributes and flags (&#39;&lt;fenv.h&gt;&#39; C and &#39;&lt;cfenv&gt;&#39; C++ headers).  To
//:   learn more about the floating point environment read the subsection of
//:   the same title, but first make sure you read the next point as well.
//:
//: 6 IEEE floating-points overloads some very common programming language
//:   terms: *exception*, *signal* and *handler* with IEEE floating-point
//:   specific meanings that are not to be confused with C or C++ or Posix
//:   terms of the same spelling.  Floating-point exceptions are events that
//:   occur when a floating-point operations on the specified operands is
//:   unable to produce a perfect outcome; such as when the result of an
//:   operation is inexact.  When a floating point exception occurs the
//:   (floating-point) - and reporting it is requested by a so-called trap
//:   attribute - the implementation signals the user(*) by invoking a default
//:   or a user-defined handler.  None of the words *exception*, *signal*, and
//:   *handler* used above have nothing to do with C++ exceptions, Posix
//:   signals and the handlers of those.  (To complicate matters more, C and
//:   Posix has decided to implement IEEE floating-point exception reporting as
//:   C/Posix signals - and therefore rendered them mostly useless.)
//:
//: 7 While a 32bit integer is a quite useful type for (integer) calculations,
//:   a 32bit floating-point type has such low accuracy (its significand is so
//:   short) that it is all but useless for calculation.  Such types are called
//:   &quot;interchange formats&quot; by the IEEE standard and should not be used for
//:   calculations.  (Except in special circumstances and by floating-point
//:   experts.  Even a 16 bit binary floating-point type can be useful for an
//:   expert in special circumstances, for example in graphics acceleration
//:   hardware.)
//
// Notes:
//   (*) IEEE Floating-point user is any person, hardware or software that uses
//       the IEEE floating-point implementation.
//
///Floating-Point Environment
/// - - - - - - - - - - - - -
// NOTE: We currently do not give access to the user to the floating-point
// environment used by our decimal system, so description of it here is
// preliminary and generic.  Note that since compilers and the C library
// already provides a (possibly binary floating-point only) environment and we
// cannot change that, our decimal floating-point environment implementation
// cannot conform to the C and C++ TRs (because those require extending the
// existing standard C library functions).
//
// The floating-point environment provides implicit input and output parameters
// to floating-point operations (that are defined to use them).  IEEE defined
// those parameters in principle, but how they are provided is left up to be
// designed/defined by the implementors of the programming languages.
//
// C (and consequently C++) decided to provide a so-called floating-point
// environment that has &quot;thread storage duration&quot;, meaning that each thread of
// a multi-threaded program will have its own distinct floating-point
// environment.
//
// The C/C++ floating-point environment consists of 3 major parts: the rounding
// mode, the traps and the status flags.
//
///Rounding Direction in The Environment
///-  -  -  -  -  -  -  -  -  -  -  -  -
// A floating-point *rounding direction* determines how is the significand of a
// higher (or infinite) precision number get rounded to fit into the limited
// number of significant digits (significand) of the floating-point
// representation that needs to store it as a result of an operation.  Note
// that the rounding is done in the radix of the representation, so binary
// floating-point will do binary rounding while decimal floating-point will do
// decimal rounding - and not all rounding modes are useful with all radixes.
// An example of a generally applicable rounding mode would be &#39;FE_TOWARDZERO&#39;
// (round towards zero).
//
// Most floating point operations in C and C++ do not take a rounding direction
// parameter (and the ones that are implemented as operators simply could not).
// When such operations (that do not have an explicit rounding direction
// parameter) need to do rounding, they use the rounding direction set in the
// floating-point environment (of their thread of execution).
//
///Status Flags
///  -  -  -  -
// Floating point operations in C and C++ do not take a status flag output
// parameter.  They report an important events (such as underflow, overflow or
// in inexact (rounded) result) by setting the appropriate status flag in the
// floating-point environment (of their thread of execution).  (Note that this
// is very similar to how flags work in CPUs, and that is not a coincidence.)
// The flags work much like individual, boolean &#39;errno&#39; values.  Operations may
// set them to true.  Users may examine them (when interested) and also reset
// them (set them to 0) before an operation.
//
///Floating-Point Traps
/// -  -  -  -  -  -  -
// IEEE says that certain floating-point events are floating-point exceptions
// and they result in invoking a handler.  It may be a default handler (set a
// status flag and continue) or a user defined handler.  Floating point traps
// are a C invention to enable &quot;sort-of handlers&quot; for floating point
// exceptions, but unfortunately they all go to the same handler: the &#39;SIGFPE&#39;
// handler.  To add insult to injury, setting what traps are active (what will)
// cause a &#39;SIGFPE&#39;) is not standardized.  So floating-point exceptions and
// handlers are considered pretty much useless in C.  (All is not lost, since
// we do have the status flags.  An application that wants to know about
// floating-point events can clear the flags prior to an operation and check
// their values afterwards.)
//
///Floating-Point Terminology
/// - - - - - - - - - - - - -
// A floating-point representation of a number is defined as follows:
// &#39;sign * significand * BASE^exponent&#39;, where sign is -1 or +1, significand is
// an integer, BASE is a positive integer (but usually 2 or 10) and exponent is
// a negative or positive integer.  Concrete examples of (decimal) numbers in
// the so-called scientific notation are: 123.4567 is 1.234567e2, while
// -0.000000000000000000000000000000000000001234567 would be -1.234567e-41.
//
//: &quot;base&quot;:
//:    the number base of the scaling used by the exponent; and by the
//:    significand
//:
//: &quot;bias&quot;:
//:    the number added to the exponent before it is stored in memory; 101, 398
//:    and 6176 for the 32, 64 and 128 bit types respectively.
//:
//: &quot;exponent&quot;:
//:    the scaling applied to the significand is calculated by raising the base
//:    to the exponent (which may be also negative)
//:
//: &quot;quantum&quot;:
//:     (IEEE-754) the value of one unit at the last significant digit
//:     position; in other words the smallest difference that can be
//:     represented by a floating-point number without changing its exponent.
//:
//:     o Note that the C++ Decimal TR uses a different, not-specified, and not
//:       very useful definition, which we chose to ignore here.
//:
//: &quot;mantissa&quot;:
//:    the old name for the significand
//:
//: &quot;radix&quot;:
//:    another name for base
//:
//: &quot;sign&quot;:
//:    +1 or -1, determines if the number is positive or negative.  It is
//:    normally represented by a single sign bit.
//:
//: &quot;significand&quot;:
//:    the significant digits of the floating-point number; the value of the
//:    number is: &#39;sign * significand * base^exponent&#39;
//:
//: &quot;precision&quot;:
//:    the significant digits of the floating-point type in its base
//:
//: &quot;decimal precision&quot;:
//:    the maximum significant decimal digits of the floating-point type
//:
//: &quot;range&quot;:
//:    the smallest and largest number the type can represent.  Note that for
//:    floating-point types there are at least *two* interpretations of
//:    minimum.  It may be the largest negative number *or* the smallest number
//:    in absolute value) that can be represented.
//:
//: &quot;normalized number&quot;:
//:    &#39;1 &lt;= significand &lt;= base&#39;
//:
//: &quot;normalization&quot;:
//:    finding the exponent such as &#39;1 &lt;= significand &lt;= base&#39;
//:
//: &quot;denormal number&quot;:
//:    &#39;significand &lt; 1&#39;
//:
//: &quot;densely packed decimal&quot;:
//:    one of the two IEEE significand encoding schemes
//:
//: &quot;binary integer significand&quot;:
//:    one of the two IEEE significand encoding schemes
//:
//: &quot;cohorts&quot;:
//:    equal numbers encoded using different exponents (to signify accuracy)
//
///Decimal Floating-Point
///----------------------
// Binary floating-point formats give best accuracy, they are the fastest (on
// binary computers), and were carefully designed by IEEE to minimize rounding
// errors (errors due to the inherent imprecision of floating-point types)
// during a lengthy calculation.  This makes them the best solution for and
// serious scientific computation.  However, they have a fatal flow when it
// comes to numbers and calculations that involve humans.  Humans think in base
// 10 - decimal.  And as the example has shown earlier, binary floating-point
// formats are unable to precisely represent very common decimal real numbers;
// with binary floating-point &#39;0.1 + 0.2 != 0.3&#39;.  (Why?  Because none of the
// three numbers in that expression have an exact binary floating-point
// representation.)
//
// Financial calculations are governed by laws and expectations that are based
// on decimal (10 based) thinking.  Due to the inherent limitations of the
// binary floating-point format, doing such decimal based calculations and
// algorithms using binary floating-point numbers is so involved and hard that
// that it is considered not feasible.  The IEEE-754 committee have recognized
// the issue and added specifications for 3 decimal floating-point types into
// their 2008 standard: the 32, 64 and 128 bits decimal floating-point formats.
//
// Floating-point types are carefully designed trade-offs between saving space
// (in memory), CPU cycles (for calculations) and still provide useful accuracy
// for computations.  Decimal floating-point types represent further
// compromises (compared to binary floating-points) in being able to represent
// less numbers (than their binary counterparts) and being slower, but
// providing exact representations for the numbers humans care about.
//
// In decimal floating-point world &#39;0.1 + 0.2 == 0.3&#39;, as humans expect;
// because each of those 3 numbers can be represented *exactly* in a decimal
// floating-point format.
//
///*WARNING*: Conversions from &#39;float&#39; and &#39;double&#39;
/// - - - - - - - - - - - - - - - - - - - - - - - -
// Clients should *be* *careful* when using the conversions from &#39;float&#39; and
// &#39;double&#39; provided by this component.  In situations where a &#39;float&#39; or
// &#39;double&#39; was originally obtained from a decimal floating point
// representation (e.g., a &#39;bdldfp::Decimal&#39;, or a string, like &quot;4.1&quot;), the
// conversions in &#39;bdldfp_decimalconvertutil&#39; will provide the correct
// conversion back to a decimal floating point value.  The conversions in this
// component provide the closest decimal floating point value to the supplied
// binary floating point representation, which may replicate imprecisions
// required to initially approximate the value in a binary representation.
// The conversions in this component are typically useful when converting
// binary floating point values that have undergone mathematical operations
// that require rounding (so they are already in-exact approximations).
//
///Cohorts
///- - - -
// In the binary floating-point world the formats are optimized for the highest
// precision, range and speed.  They are stored normalized and therefore store
// no information about their accuracy.  In finances, the area that decimal
// floating-point types target, accuracy of a number is usually very important.
// We may have a number that is 1, but we know it may be 1.001 or 1.002 etc.
// And we may have another number 1, which we know to be accurate to 6
// significant digits.  We would display the former number as &#39;1.00&#39; and the
// latter number as &#39;1.00000&#39;.  The decimal floating-point types are able to
// store both numbers *and* their precision using so call cohorts.  The &#39;1.00&#39;
// will be stored as &#39;100e-2&#39; while &#39;1.00000&#39; will be stored as 100000e-5.
//
// Cohorts compare equal, and mostly behave the same way in calculation except
// when it comes to the accuracy of the result.  If I have a number that is
// accurate to 5 digits only, it would be a mistake to try to expect more than
// 5 digits accuracy from a calculation involving it.  The IEEE-754 rules of
// cohorts (in calculations) ensures that results will be a cohort that
// indicates the proper expected accuracy.
//
///Standards Conformance
///---------------------
// The component has also been designed to resemble the C++ Decimal
// Floating-Point Technical Report ISO/IEC TR-24733 of 2009 and its C++11
// updates of ISO/IEC JTC1 SC22 WG21 N3407=12-0097 of 2012 as much as it is
// possible with C++03 compilers and environments that do not provide decimal
// floating-point support in any form.
//
// At the time of writing there is just one standard about decimal-floating
// point, the IEEE-754 2008 standard and the content of this component conforms
// to it.  The component does not fully implement all required IEEE-754
// functionality because due to our architectural design guidelines some of
// these must go into a separate so-called utility component.)
//
// The component uses the ISO/IEC TR 24732 - the C Decimal Floating-Point
// TR - in its implementation where it is available.
//
// The component closely resembles ISO/IEC TR 24733 - the C++ Decimal
// Floating-Point TR - but does not fully conform to it for several reasons.
// The major reasons are: it is well known that TR 24733 has to change before
// it is included into the C++ standard; the TR would require us to change
// system header files we do not have access to.
//
// In the following subsections the differences to the C++ technical report are
// explained in detail, including a short rationale.
//
///No Namespace Level Named Functions
/// - - - - - - - - - - - - - - - - -
// BDE design guidelines do not allow namespace level functions other than
// operators and aspects.  According to BDE design principles all such
// functions are placed into a utility component.
//
///All Converting Constructors from Integer Types are Explicit
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// This change is necessary to disable the use of comparison operators without
// explicit casting.  See No Heterogeneous Comparisons Without Casting.
//
///No Heterogeneous Comparisons Without Casting
/// - - - - - - - - - - - - - - - - - - - - - -
// The C and C++ Decimal TRs refer to IEEE-754 for specifications of the
// heterogeneous comparison operators (comparing decimal floating-point types
// to binary floating-point types and integer types); however IEEE-754 does
// *not* specify such operations - leaving them unspecified.  To make matters
// worse, there are two possible ways to implement those operators (convert the
// decimal to the other type, or convert the other type to decimal first) and
// depending on which one is chosen, the result of the operator will be
// different.  Also, the C committee is considering the removal of those
// operators.  We have removed them until we know how to implement them.
// Comparing decimal types to those other types is still possible, it just
// requires explicit casting/conversion from the user code.
//
///No Arithmetic Or Computing Support For &#39;Decimal32&#39;
/// - - - - - - - - - - - - - - - - - - - - - - - - -
// IEEE-754 designates the 32 bit floating-point types &quot;interchange formats&quot;
// and does not require or recommend arithmetic or computing support of any
// kind for them.  The C (and consequently the C++) TR goes against the IEEE
// design and requires &#39;_Decimal32&#39; (and &#39;std::decimal32&#39;) to provide computing
// support, however, in a twist, allows it to be performed using one of the
// larger types (64 or 128 bits).  The rationale from the C committee is that
// small embedded systems may need to do their calculations using the small
// type (so they have made it mandatory for everyone).  Industry experience
// with the &#39;float&#39; C type (32bit floating-point type, usually binary) has
// shown that enabling computing using small floating-point types are a mistake
// that causes novice programmers to write calculations that are very slow and
// inaccurate.  There we have decided that unless a compelling use case
// presents itself we are not going to make it easy to write slow and
// inaccurate programs using our implementation.
//
// We recommend what IEEE recommends: convert your 32 bit types on receipt to a
// type with higher precision (usually 64 bit will suffice), so you
// calculations using that larger type, and convert it back to 32 bit type only
// if your output interchange format requires it.
//
///Non-Standard Member Functions
///- - - - - - - - - - - - - - -
// Due to BDE rules of design and some implementation needs we have extended
// the C++ TR mandated interface of the decimal floating-point types to include
// support for accessing the underlying data (type), to parse literals for the
// portable literal support.
//
// Note that using any of these public member functions will render your code
// non-portable to non-BDE (but standards conforming) implementations.
//
///&#39;Decimal32&#39; Type
///----------------
// An interchange format type that supports input, output, relational operators
// construction from the TR mandates data types but no arithmetic or other
// computing operations.  The type has the size of exactly 32 bits.  It
// supports 7 significant decimal digits and an exponent range of -95 to 96.
// The smallest non-zero value that can be represented is 1e-101.
//
// Portable &#39;Decimal32&#39; literals are created using the &#39;BDLDFP_DECIMAL_DF&#39;
// macro.
//
///&#39;Decimal64&#39; Type
///----------------
// A basic format type that supports input, output, relational operators
// construction from the TR mandates data types and arithmetic or operations.
// The type has the size of exactly 64 bits.  It supports 16 significant
// decimal digits and an exponent range of -383 to 384.  The smallest non-zero
// value that can be represented is 1e-398.
//
// Portable &#39;Decimal64&#39; literals are created using the &#39;BDLDFP_DECIMAL_DD&#39;
// macro.
//
///&#39;Decimal128&#39; Type
///-----------------
// A basic format type that supports input, output, relational operators
// construction from the TR mandates data types and arithmetic or operations.
// The type has the size of exactly 128 bits.  It supports 34 significant
// decimal digits and an exponent range of -6143 to 6144.  The smallest
// non-zero value that can be represented is 1e-6176.
//
// Portable &#39;Decimal128&#39; literals are created using the &#39;BDLDFP_DECIMAL_DL&#39;
// macro.
//
///Decimal Number Formatting
///-------------------------
// Streaming decimal floating point numbers to an output stream currently
// supports formatting flags for width, capitalization, and justification.
// Because of potential for future improvements in format handling, the
// operations should not be used for serialization.
//
///Preliminary Release: Known Bugs
///-------------------------------
// Stream output operators do not obey formatting flags or the precision
// algorithm as required by the TR; they instead print all significant digits
// all the time.
//
///Usage
///-----
// In this section, we show the intended usage of this component.
//
///Example 1: Portable Initialization of Non-Integer, Constant Values
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// If your compiler does not support the C Decimal TR, it does not support
// decimal floating-point literals, only binary floating-point literals.  The
// problem with binary floating-point literals is the same as with binary
// floating-point numbers in general: they cannot represent the decimal numbers
// we care about.  To solve this problem there are 3 macros provided by this
// component that can be used to initialize decimal floating-point types with
// non-integer values, precisely.  These macros will evaluate to real, C
// language literals where those are supported and to a runtime-parsed solution
// otherwise.  The following code demonstrates the use of these macros as well
// as mixed-type arithmetics and comparisons:
//..
//  bdldfp::Decimal32  d32( BDLDFP_DECIMAL_DF(0.1));
//  bdldfp::Decimal64  d64( BDLDFP_DECIMAL_DD(0.2));
//  bdldfp::Decimal128 d128(BDLDFP_DECIMAL_DL(0.3));
//
//  assert(d32 + d64 == d128);
//  assert(bdldfp::Decimal64(d32)  * 10 == bdldfp::Decimal64(1));
//  assert(d64  * 10 == bdldfp::Decimal64(2));
//  assert(d128 * 10 == bdldfp::Decimal128(3));
//..
//
///Example 2: Precise Calculations with Decimal Values
///- - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we need to add two (decimal) numbers and then tell if the result is
// a particular decimal number or not.  That can get difficult with binary
// floating-point, but easy with decimal:
//..
//  if (std::numeric_limits&lt;double&gt;::radix == 2) {
//    assert(.1 + .2 != .3);
//  }
//  assert(BDLDFP_DECIMAL_DD(0.1) + BDLDFP_DECIMAL_DD(0.2)
//      == BDLDFP_DECIMAL_DD(0.3));
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLDFP_DECIMALIMPUTIL
#include &lt;bdldfp_decimalimputil.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include &lt;bslalg_typetraits.h&gt;
#endif

#ifndef INCLUDED_BSLS_EXCEPTIONUTIL
#include &lt;bsls_exceptionutil.h&gt;
#endif

#ifndef INCLUDED_BSL_IOS
#include &lt;bsl_ios.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSL_ITERATOR
#include &lt;bsl_iterator.h&gt;
#endif

#ifndef INCLUDED_BSL_LIMITS
#include &lt;bsl_limits.h&gt;
#endif

#ifndef INCLUDED_BSL_LOCALE
#include &lt;bsl_locale.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDDEF
#include &lt;bsl_cstddef.h&gt;
#endif


               // Portable decimal floating-point literal support

#define BDLDFP_DECIMAL_DF(lit)                                                \
    BloombergLP::bdldfp::Decimal32(BDLDFP_DECIMALIMPUTIL_DF(lit))

#define BDLDFP_DECIMAL_DD(lit)                                                \
    BloombergLP::bdldfp::Decimal64(BDLDFP_DECIMALIMPUTIL_DD(lit))

#define BDLDFP_DECIMAL_DL(lit)                                                \
    BloombergLP::bdldfp::Decimal128(BDLDFP_DECIMALIMPUTIL_DL(lit))

namespace BloombergLP {
namespace bdldfp {

                            // FORWARD DECLARATIONS

class Decimal_Type32;
class Decimal_Type64;
class Decimal_Type128;
    // These are the actual (decimal floating-point) types being implemented.
    // They use a different name to cause an error if the official types are
    // forward declared: The exact definition of the decimal types is left
    // unspecified so that that can potentially be aliases for built-in types.

typedef Decimal_Type32  Decimal32;
typedef Decimal_Type64  Decimal64;
typedef Decimal_Type128 Decimal128;
    // The decimal floating-point types are typedefs to the unspecified
    // implementation types.

                      // THE DECIMAL FLOATING-POINT TYPES

                            // ====================
                            // class Decimal_Type32
                            // ====================

class Decimal_Type32 {
    // This value-semantic class implements the IEEE-754 32 bit decimal
    // floating-point interchange format type.  This class is a standard layout
    // type that is &#39;const&#39; thread-safe and exception-neutral.

  private:
    // DATA
    DecimalImpUtil::ValueType32 d_value; // The underlying IEEE representation

  public:
    // TRAITS
    BSLALG_DECLARE_NESTED_TRAITS(Decimal_Type32,
                                 bslalg::TypeTraitBitwiseCopyable);

    // CREATORS
    Decimal_Type32();
        // Create a &#39;Decimal32_Type&#39; object having the value positive zero, and
        // 0 exponent (quantum 1e-6).

    Decimal_Type32(DecimalImpUtil::ValueType32 value);              // IMPLICIT
        // Create a &#39;Decimal32_Type&#39; object having the specified &#39;value&#39;.

    explicit Decimal_Type32(Decimal_Type64 other);
        // Create a &#39;Decimal32_Type&#39; object having the value closest to the
        // value of the specified &#39;other&#39; following the conversion rules
        // defined by IEEE-754:
        //
        //: o If &#39;other&#39; is NaN, initialize this object to a NaN.
        //:
        //: o Otherwise if &#39;other&#39; is infinity (positive or negative), then
        //:   initialize this object to infinity with the same sign.
        //:
        //: o Otherwise if &#39;other&#39; has a zero value, then initialize this
        //:   object to zero with the same sign.
        //:
        //: o Otherwise if &#39;other&#39; has an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal32&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and initialize this object to infinity
        //:   with the same sign as &#39;other&#39;.
        //:
        //: o Otherwise if &#39;other&#39; has an absolute value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal32&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and initialize this object
        //:   to zero with the same sign as &#39;other&#39;.
        //:
        //: o Otherwise if &#39;other&#39; has a value that has more significant digits
        //:   than &#39;std::numeric_limits&lt;Decimal32&gt;::max_digit&#39; then raise the
        //:   &quot;inexact&quot; floating-point exception and initialize this object to
        //:   the value of &#39;other&#39; rounded according to the rounding direction.
        //:
        //: o Otherwise initialize this object to the value of the &#39;other&#39;.
        //
        // TODO: We may wish for a constructor from Decimal128.  The rounding
        // is not supported by IBM software.

    explicit Decimal_Type32(float       other);
    explicit Decimal_Type32(double      other);
        // Create a &#39;Decimal32_Type&#39; object having the value closest to the
        // value of the specified &#39;other&#39; value.  *Warning:* clients requiring
        // a conversion for an exact decimal value should use
        // &#39;bdldfp_decimalconverutil&#39; (see *WARNING*: Conversions from
        // &#39;float&#39; and &#39;double&#39;}.  This conversion follows the conversion
        // rules as defined by IEEE-754:
        //
        //: o If &#39;other&#39; is NaN, initialize this object to a NaN.
        //:
        //: o Otherwise if &#39;other&#39; is infinity (positive or negative), then
        //:   initialize this object to infinity value with the same sign.
        //:
        //: o Otherwise if &#39;other&#39; has a zero value, then initialize this
        //:   object to zero with the same sign.
        //:
        //: o Otherwise if &#39;other&#39; has an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal32&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and initialize this object to infinity
        //:   with the same sign as &#39;other&#39;.
        //:
        //: o Otherwise if &#39;other&#39; has an absolute value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal32&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and initialize this object
        //:   to zero with the same sign as &#39;other&#39;.
        //:
        //: o Otherwise if &#39;other&#39; has a value that needs more than
        //:   &#39;std::numeric_limits&lt;Decimal32&gt;::max_digit&#39; significant decimal
        //:   digits to represent then raise the &quot;inexact&quot; floating-point
        //:   exception and initialize this object to the value of &#39;other&#39;
        //:   rounded according to the rounding direction.
        //:
        //: o Otherwise initialize this object to the value of the &#39;other&#39;.

    explicit Decimal_Type32(int                other);
    explicit Decimal_Type32(unsigned int       other);
    explicit Decimal_Type32(long int           other);
    explicit Decimal_Type32(unsigned long int  other);
    explicit Decimal_Type32(long long          other);
    explicit Decimal_Type32(unsigned long long other);
        // Create a &#39;Decimal32_Type&#39; object having the value closest to the
        // value of the specified &#39;other&#39; following the conversion rules as
        // defined by IEEE-754:
        //
        //: o If &#39;other&#39; is zero then initialize this object to positive zero
        //:   with a 0 exponent (quantum 1e-6).
        //:
        //: o Otherwise if &#39;other&#39; has an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal32&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and initialize this object to infinity
        //:   with the same sign as &#39;other&#39;.
        //:
        //: o Otherwise if &#39;other&#39; has a value that is not exactly
        //:   representable using &#39;std::numeric_limits&lt;Decimal32&gt;::max_digit&#39;
        //:   decimal digits then raise the &quot;inexact&quot; floating-point exception
        //:   and initialize this object to the value of &#39;other&#39; rounded
        //:   according to the rounding direction.
        //:
        //: o Otherwise initialize this object to the value of the &#39;other&#39;.
        //
        // The exponent 0 (quantum 1e-6) is preferred during conversion unless
        // it would cause unnecessary loss of precision.

    //! Decimal32_Type(const Decimal32_Type&amp; original) = default;
        // Create a &#39;Decimal32_Type&#39; object that is a copy of the specified
        // &#39;original&#39; as defined by the &#39;copy&#39; operation of IEEE-754 2008:
        //
        //: o If &#39;other&#39; is NaN, initialize this object to a NaN.
        //:
        //: o Otherwise initialize this object to the value of the &#39;other&#39;.
        //
        // Note that since floating-point types may be NaN, and NaNs are
        // unordered (do not compare equal even to themselves) it is possible
        // that a copy of a decimal will not compare equal to the original;
        // however it will behave as the original.

    //! ~Decimal32_Type() = default;
        // Destroy this object.

    // MANIPULATORS
    //! Decimal32_Type&amp; operator=(const Decimal32_Type&amp; rhs) = default;
        // Make this object a copy of the specified &#39;rhs&#39; as defined by the
        // &#39;copy&#39; operation of IEEE-754 2008 and return a reference providing
        // modifiable access to this object.
        //
        //: o If &#39;other&#39; is NaN, set this object to a NaN.
        //:
        //: o Otherwise set this object to the value of the &#39;other&#39;.
        //
        // Note that since floating-point types may be NaN, and NaNs are
        // unordered (do not compare equal even to themselves) it is possible
        // that, after an assignment, a decimal will not compare equal to the
        // original; however it will behave as the original.

    DecimalImpUtil::ValueType32 *data();
        // Return a pointer providing modifiable access to the underlying
        // implementation.

    // ACCESSORS
    const DecimalImpUtil::ValueType32 *data() const;
        // Return a pointer providing non-modifiable access to the underlying
        // implementation.

    DecimalImpUtil::ValueType32 value() const;
        // Return the value of the underlying implementation.
};

// FREE OPERATORS
Decimal32 operator+(Decimal32 value);
    // Return a copy of the specified &#39;value&#39; if the value is not negative
    // zero, and return positive zero otherwise.

Decimal32 operator-(Decimal32 value);
    // Return the result of applying the unary - operator to the specified
    // &#39;value&#39; as described by IEEE-754, essentially reversing the sign bit.
    // Note that floating-point numbers have signed zero, so this operation is
    // not the same as &#39;0 - value&#39;.

bool operator==(Decimal32 lhs, Decimal32 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; have the same value, and
    // &#39;false&#39; otherwise.  Two &#39;Decimal32&#39; objects have the same value if the
    // &#39;compareQuietEqual&#39; operation (IEEE-754 defined, non-total ordering
    // comparison) considers the underlying IEEE representations equal.  In
    // other words, two &#39;Decimal32&#39; objects have the same value if:
    //
    //: o both have a zero value (positive or negative), or
    //: o both have the same infinity value (both positive or negative), or
    //: o both have the value of a real number that are equal, even if they are
    //:   represented differently (cohorts have the same value)
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.
    //
    // Note that a NaN is never equal to anything, including itself:
    //..
    //  Decimal32 aNaN = std::numeric_limits&lt;Decimal32&gt;::quiet_NaN();
    //  assert(!(aNan == aNan));
    //..

bool operator!=(Decimal32 lhs, Decimal32 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; do not have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;Decimal32&#39; objects do not have the
    // same value if the &#39;compareQuietEqual&#39; operation (IEEE-754 defined,
    // non-total ordering comparison) considers the underlying IEEE
    // representations not equal.  In other words, two &#39;Decimal32&#39; objects do
    // not have the same value if:
    //
    //: o both are NaN, or
    //: o one is zero (positive or negative) and the is not, or
    //: o one is positive infinity and the other is not, or
    //: o one is negative infinity and the other is not, or
    //: o both have the value of a real number that are not equal, regardless
    //:   of their representation (cohorts are equal)
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.
    //
    // Note that a NaN is never equal to anything, including itself:
    //..
    //  Decimal32 aNaN = std::numeric_limits&lt;Decimal32&gt;::quiet_NaN();
    //  assert(aNan != aNan);
    //..

bool operator&lt;(Decimal32 lhs, Decimal32 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value less than the specified
    // &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a &#39;Decimal32&#39; object &#39;lhs&#39; is
    // less than that of an object &#39;rhs&#39; if the &#39;compareQuietLess&#39; operation
    // (IEEE-754 defined, non-total ordering comparison) considers the
    // underlying IEEE representation of &#39;lhs&#39; to be less than of that of
    // &#39;rhs&#39;.  In other words, &#39;lhs&#39; is less than &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; is zero (positive or negative) and &#39;rhs&#39; positive, or
    //: o &#39;rhs&#39; is zero (positive or negative) and &#39;lhs&#39; negative, or
    //: o &#39;lhs&#39; is not positive infinity, or
    //: o &#39;lhs&#39; is negative infinity and &#39;rhs&#39; is not, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is less than that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&lt;=(Decimal32 lhs, Decimal32 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value less than or equal the
    // value of the specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a
    // &#39;Decimal32&#39; object &#39;lhs&#39; is less than or equal to the value of an object
    // &#39;rhs&#39; if the &#39;compareQuietLessEqual&#39; operation (IEEE-754 defined,
    // non-total ordering comparison) considers the underlying IEEE
    // representation of &#39;lhs&#39; to be less or equal to that of &#39;rhs&#39;.  In other
    // words, &#39;lhs&#39; is less or equal than &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; are both zero (positive or negative), or
    //: o both &#39;lhs&#39; and &#39;rhs&#39; are positive infinity, or
    //: o &#39;lhs&#39; is negative infinity, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is less or equal to that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&gt;(Decimal32 lhs, Decimal32 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a greater value than the
    // specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a &#39;Decimal32&#39;
    // object &#39;lhs&#39; is greater than that of an object &#39;rhs&#39; if the
    // &#39;compareQuietGreater&#39; operation (IEEE-754 defined, non-total ordering
    // comparison) considers the underlying IEEE representation of &#39;lhs&#39; to be
    // greater than of that of &#39;rhs&#39;.  In other words, &#39;lhs&#39; is greater than
    // &#39;rhs&#39;if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; are not both zero (positive or negative), or
    //: o &#39;lhs&#39; is not negative infinity, or
    //: o &#39;lhs&#39; is positive infinity and &#39;rhs&#39; is not, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is greater than that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&gt;=(Decimal32 lhs, Decimal32 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value greater than or equal
    // to the value of the specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of
    // a &#39;Decimal32&#39; object &#39;lhs&#39; is greater or equal to a &#39;Decimal32&#39; object
    // &#39;rhs&#39; if the &#39;compareQuietGreaterEqual&#39; operation (IEEE-754 defined,
    // non-total ordering comparison ) considers the underlying IEEE
    // representation of &#39;lhs&#39; to be greater or equal to that of &#39;rhs&#39;.  In
    // other words, &#39;lhs&#39; is greater than or equal to &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; are both zero (positive or negative), or
    //: o both &#39;lhs&#39; and &#39;rhs&#39; are negative infinity, or
    //: o &#39;lhs&#39; is positive infinity, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is greater or equal to that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

template &lt;class CHARTYPE, class TRAITS&gt;
bsl::basic_istream&lt;CHARTYPE, TRAITS&gt;&amp;
operator&gt;&gt;(bsl::basic_istream&lt;CHARTYPE, TRAITS&gt;&amp; stream, Decimal32&amp; object);
    // Read, into the specified &#39;object&#39;, from the specified input &#39;stream&#39; an
    // IEEE 32 bit decimal floating-point value as described in the IEEE-754
    // 2008 standard (5.12 Details of conversions between floating point
    // numbers and external character sequences) and return a reference
    // providing modifiable access to &#39;stream&#39;.  If &#39;stream&#39; contains a NaN
    // value, it is unspecified if &#39;object&#39; will receive a quiet or signaling
    // &#39;Nan&#39;.  If &#39;stream&#39; is not valid on entry &#39;stream.good() == false&#39;, this
    // operation has no effect other than setting &#39;stream.fail()&#39; to &#39;true&#39;.
    // If eof (end-of-file) is found before any non-whitespace characters
    // &#39;stream.fail()&#39; is set to &#39;true&#39; and &#39;object&#39; remains unchanged.  If eof
    // is detected after some characters have been read (and successfully
    // interpreted as part of the textual representation of a floating-point
    // value as specified by IEEE-754) then &#39;stream.eof()&#39; is set to true.  If
    // the first non-whitespace character sequence is not a valid textual
    // representation of a floating-point value (e.g., 12e or e12 or 1*2) the
    // &#39;stream.fail()&#39; is set to true and &#39;object&#39; will remain unchanged.  If a
    // real number value is represented by the character sequence but it is a
    // large positive or negative value that cannot be stored into &#39;object&#39; the
    // &quot;overflow&quot; floating-point exception is raised and positive or negative
    // infinity is stored into &#39;object&#39;, respectively.  If a real number value
    // is represented by the character sequence but it is a small positive or
    // negative value that cannot be stored into &#39;object&#39; the &quot;underflow&quot;
    // floating-point exception is raised and positive or negative zero is
    // stored into &#39;object&#39;, respectively.  If a real number value is
    // represented by the character sequence but it cannot be stored exactly
    // into &#39;object&#39; the &quot;inexact&quot; floating-point exception is raised, the
    // value is rounded according to the current rounding direction (of the
    // environment) and then stored into &#39;object.&#39;
    //
    // NOTE: This method does not yet fully support iostream flags or the
    // decimal floating point exception context.

template &lt;class CHARTYPE, class TRAITS&gt;
bsl::basic_ostream&lt;CHARTYPE, TRAITS&gt;&amp;
operator&lt;&lt;(bsl::basic_ostream&lt;CHARTYPE, TRAITS&gt;&amp; stream, Decimal32 object);
    // Write the value of the specified &#39;object&#39; to the specified output
    // &#39;stream&#39; in a single line format as described in the IEEE-754 2008
    // standard (5.12 Details of conversions between floating point numbers and
    // external character sequences), and return a reference providing
    // modifiable access to &#39;stream&#39;.  If &#39;stream&#39; is not valid on entry, this
    // operation has no effect.
    //
    // NOTE: This method does not yet fully support iostream flags or the
    // decimal floating point exception context.

                            // ====================
                            // class Decimal_Type64
                            // ====================

class Decimal_Type64 {
    // This value-semantic class implements the IEEE-754 64 bit decimal
    // floating-point format arithmetic type.  This class is a standard layout
    // type that is &#39;const&#39; thread-safe and exception-neutral.

  private:
    // DATA
    DecimalImpUtil::ValueType64 d_value; // The underlying IEEE representation

  public:
    // CLASS METHODS

                                  // Aspects

    static int maxSupportedBdexVersion();
    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that it is highly recommended that &#39;versionSelector&#39;
        // be formatted as &quot;YYYYMMDD&quot;, a date representation.  Also note that
        // &#39;versionSelector&#39; should be a *compile*-time-chosen value that
        // selects a format version supported by both externalizer and
        // unexternalizer.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.


    // TRAITS
    BSLALG_DECLARE_NESTED_TRAITS(Decimal_Type64,
                                 bslalg::TypeTraitBitwiseCopyable);

    // CREATORS
    Decimal_Type64();
        // Create a &#39;Decimal64_Type&#39; object having the value positive zero, and
        // 0 exponent (quantum 1e-15).

    Decimal_Type64(DecimalImpUtil::ValueType64 value);              // IMPLICIT
        // Create a &#39;Decimal64_Type&#39; object having the specified &#39;value&#39;.

    Decimal_Type64(Decimal32 other);                                // IMPLICIT
        // Create a &#39;Decimal64_Type&#39; object having the value of the specified
        // &#39;other&#39; following the conversion rules defined by IEEE-754:
        //
        //: o If &#39;other&#39; is NaN, initialize this object to a NaN.
        //:
        //: o Otherwise if &#39;other&#39; is infinity (positive or negative), then
        //:   initialize this object to infinity with the same sign.
        //:
        //: o Otherwise if &#39;other&#39; is zero, then initialize this object to zero
        //:   with the same sign.
        //:
        //: o Otherwise initialize this object to the value of the &#39;other&#39;.

    explicit Decimal_Type64(Decimal128 other);
        // Create a &#39;Decimal64_Type&#39; object having the value closest to the
        // value of the specified &#39;other&#39; following the conversion rules
        // defined by IEEE-754:
        //
        //: o If &#39;other&#39; is NaN, initialize this object to a NaN.
        //:
        //: o Otherwise if &#39;other&#39; is infinity (positive or negative), then
        //:   initialize this object to infinity with the same sign.
        //:
        //: o Otherwise if &#39;other&#39; is zero, then initialize this object to
        //:   zero with the same sign.
        //:
        //: o Otherwise if &#39;other&#39; has an absolute value that is larger
        //:   than &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the
        //:   &quot;overflow&quot; floating-point exception and initialize this
        //:   object to infinity with the same sign as &#39;other&#39;.
        //:
        //: o Otherwise if &#39;other&#39; has an absolute value that is smaller
        //:   than &#39;std::numeric_limits&lt;Decimal64&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and initialize this
        //:   object to zero with the same sign as &#39;other&#39;.
        //:
        //: o Otherwise if &#39;other&#39; has a value that has more significant
        //:   digits than &#39;std::numeric_limits&lt;Decimal64&gt;::max_digit&#39; then
        //:   raise the &quot;inexact&quot; floating-point exception and initialize
        //:   this object to the value of &#39;other&#39; rounded according to the
        //:   rounding direction.
        //:
        //: o Otherwise initialize this object to the value as the &#39;other&#39;.

    explicit Decimal_Type64(float       other);
    explicit Decimal_Type64(double      other);
        // Create a &#39;Decimal64_Type&#39; object having the value closest to the
        // value of the specified &#39;other&#39; value.  *Warning:* clients requiring
        // a conversion for an exact decimal value should use
        // &#39;bdldfp_decimalconverutil&#39; (see *WARNING*: Conversions from
        // &#39;float&#39; and &#39;double&#39;}.  This conversion follows the conversion
        // rules as defined by IEEE-754:
        //
        //: o If &#39;other&#39; is NaN, initialize this object to a NaN.
        //:
        //: o Otherwise if &#39;other&#39; is infinity (positive or negative), then
        //:   initialize this object to infinity value with the same sign.
        //:
        //: o Otherwise if &#39;other&#39; has a zero value, then initialize this
        //:   object to zero with the same sign.
        //:
        //: o Otherwise if &#39;other&#39; has an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and initialize this object to infinity
        //:   with the same sign as &#39;other&#39;.
        //:
        //: o Otherwise if &#39;other&#39; has an absolute value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and initialize this object
        //:   to zero with the same sign as &#39;other&#39;.
        //:
        //: o Otherwise if &#39;other&#39; has a value that needs more than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max_digit&#39; significant decimal
        //:   digits to represent then raise the &quot;inexact&quot; floating-point
        //:   exception and initialize this object to the value of &#39;other&#39;
        //:   rounded according to the rounding direction.
        //:
        //: o Otherwise initialize this object to the value of the &#39;other&#39;.

    explicit Decimal_Type64(int                other);
    explicit Decimal_Type64(unsigned int       other);
    explicit Decimal_Type64(long               other);
    explicit Decimal_Type64(unsigned long      other);
    explicit Decimal_Type64(long long          other);
    explicit Decimal_Type64(unsigned long long other);
        // Create a &#39;Decimal64_Type&#39; object having the value closest to the
        // value of the specified &#39;other&#39; following the conversion rules as
        // defined by IEEE-754:
        //
        //: o If &#39;other&#39; is zero then initialize this object to positive zero
        //:   with a 0 exponent (quantum 1e-15).
        //:
        //: o Otherwise if &#39;other&#39; has an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and initialize this object to infinity
        //:   with the same sign as &#39;other&#39;.
        //:
        //: o Otherwise if &#39;other&#39; has a value that is not exactly
        //:   representable using &#39;std::numeric_limits&lt;Decimal64&gt;::max_digit&#39;
        //:   decimal digits then raise the &quot;inexact&quot; floating-point exception
        //:   and initialize this object to the value of &#39;other&#39; rounded
        //:   according to the rounding direction.
        //:
        //: o Otherwise initialize this object to the value of the &#39;other&#39;.
        //
        // The exponent 0 (quantum 1e-15) is preferred during conversion unless
        // it would cause unnecessary loss of precision.

    //! Decimal64_Type(const Decimal64_Type&amp; original) = default;
        // Create a &#39;Decimal64_Type&#39; object that is a copy of the specified
        // &#39;original&#39; as defined by the &#39;copy&#39; operation of IEEE-754 2008:
        //
        //: o If &#39;other&#39; is NaN, initialize this object to a NaN.
        //:
        //: o Otherwise initialize this object to the value of the &#39;other&#39;.
        //
        // Note that since floating-point types may be NaN, and NaNs are
        // unordered (do not compare equal even to themselves) it is possible
        // that a copy of a decimal will not compare equal to the original;
        // however it will behave as the original.

    //! ~Decimal64_Type() = default;
        // Destroy this object.

    // MANIPULATORS
    //! Decimal64_Type&amp; operator=(const Decimal64_Type&amp; rhs) = default;
        // Make this object a copy of the specified &#39;rhs&#39; as defined by the
        // &#39;copy&#39; operation of IEEE-754 2008 and return a reference providing
        // modifiable access to this object.
        //
        //: o If &#39;other&#39; is NaN, set this object to a NaN.
        //:
        //: o Otherwise set this object to the value of the &#39;other&#39;.
        //
        // Note that since floating-point types may be NaN, and NaNs are
        // unordered (do not compare equal even to themselves) it is possible
        // that, after an assignment, a decimal will not compare equal to the
        // original; however it will behave as the original.

    Decimal_Type64&amp; operator++();
        // Add 1.0 to the value of this object and return a reference to it.
        // Note that this is a floating-point value so this operations may not
        // change the value of this object at all (if the value is large) or it
        // may seem to just set it to 1.0 (if the original value is small).

    Decimal_Type64&amp; operator--();
        // Add -1.0 to the value of this object and return a reference to it.
        // Note that this is a floating-point value so this operations may not
        // change the value of this object at all (if the value is large) or it
        // may seem to just set it to -1.0 (if the original value is small).

    Decimal_Type64&amp; operator+=(Decimal32  rhs);
    Decimal_Type64&amp; operator+=(Decimal64  rhs);
    Decimal_Type64&amp; operator+=(Decimal128 rhs);
        // Add the value of the specified &#39;rhs&#39; object to the value of this as
        // described by IEEE-754, store the result in this object, and return a
        // reference to this object.
        //
        //: o If either this object or &#39;rhs&#39; is NaN, then raise the &quot;invalid&quot;
        //:   floating-point exception and set this object to a NaN.
        //:
        //: o Otherwise if this object and &#39;rhs&#39; have infinite values of
        //:   differing signs, then raise the &quot;invalid&quot; floating-point
        //:   exception and set this object to a NaN.
        //:
        //: o Otherwise if this object and &#39;rhs&#39; have infinite values of the
        //:   same sign, then do not change this object.
        //:
        //: o Otherwise if &#39;rhs&#39; has a zero value (positive or negative), do
        //:   not change this object.
        //:
        //: o Otherwise if the sum of this object and &#39;rhs&#39; has an absolute
        //:   value that is larger than &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39;
        //:   then raise the &quot;overflow&quot; floating-point exception and set this
        //:   object to infinity value with the same sign as that result.
        //:
        //: o Otherwise set this object to the sum of the number represented by
        //:   &#39;rhs&#39; and the number represented by this object.
        //
        // Note that this is a floating-point value so this operations may not
        // change the value of this object at all (if the value is large) or it
        // may seem to update it to the value of the &#39;other&#39; (if the original
        // value is small).
        //
        // Note that when &#39;rhs&#39; is a &#39;Decimal128&#39;, this operation is always
        // performed with 128 bits precision to prevent loss of precision of
        // the &#39;rhs&#39; operand (prior to the operation).  The result is then
        // rounded back to 64 bits and stored to this object.  See IEEE-754
        // 2008, 5.1, first paragraph, second sentence for specification.

    Decimal_Type64&amp; operator+=(int                rhs);
    Decimal_Type64&amp; operator+=(unsigned int       rhs);
    Decimal_Type64&amp; operator+=(long               rhs);
    Decimal_Type64&amp; operator+=(unsigned long      rhs);
    Decimal_Type64&amp; operator+=(long long          rhs);
    Decimal_Type64&amp; operator+=(unsigned long long rhs);
        // Add the specified &#39;rhs&#39; to the value of this object as described by
        // IEEE-754, store the result in this object, and return a reference to
        // this object.
        //
        //: o If this object is NaN, then raise the &quot;invalid&quot; floating-point
        //:   exception and do not change this object.
        //:
        //: o Otherwise if this object is infinity, then do not change it.
        //:
        //: o Otherwise if the sum of this object and &#39;rhs&#39; has an absolute
        //:   value that is larger than &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39;
        //:   then raise the &quot;overflow&quot; floating-point exception and set this
        //:   object to infinity with the same sign as that result.
        //:
        //: o Otherwise set this object to sum of adding &#39;rhs&#39; and the number
        //:   represented by this object.
        //
        // Note that this is a floating-point value so this operations may not
        // change the value of this object at all (if the value is large) or it
        // may seem to update it to the value of the &#39;other&#39; (if the original
        // value is small).

    Decimal_Type64&amp; operator-=(Decimal32  rhs);
    Decimal_Type64&amp; operator-=(Decimal64  rhs);
    Decimal_Type64&amp; operator-=(Decimal128 rhs);
        // Subtract the value of the specified &#39;rhs&#39; from the value of this
        // object as described by IEEE-754, store the result in this object,
        // and return a reference to this object.
        //
        //: o If either this object or &#39;rhs&#39; is NaN, then raise the &quot;invalid&quot;
        //:   floating-point exception and set this object to a NaN.
        //:
        //: o Otherwise if this object and the &#39;rhs&#39; have infinite values of
        //:   the same sign, raise the &quot;invalid&quot; floating-point exception and
        //:   set this object to a NaN.
        //:
        //: o Otherwise if this object and the &#39;rhs&#39; have infinite values of
        //:   differing signs, then do not change this object.
        //:
        //: o Otherwise if the &#39;rhs&#39; has a zero value (positive or negative),
        //:   do not change this object.
        //:
        //: o Otherwise if subtracting the value of the &#39;rhs&#39; object from this
        //:   results in an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and set this object to infinity with the
        //:   same sign as that result.
        //:
        //: o Otherwise set this object to the result of subtracting the value
        //:   of &#39;rhs&#39; from the value of this object.
        //
        // Note that this is a floating-point value so this operations may not
        // change the value of this object at all (if the value is large) or it
        // may seem to update it to the value of the &#39;other&#39; (if the original
        // value is small).
        //
        // Note that when &#39;rhs&#39; is a &#39;Decimal128&#39;, this operation is always
        // performed with 128 bits precision to prevent loss of precision of
        // the &#39;rhs&#39; operand (prior to the operation).  The result is then
        // rounded back to 64 bits and stored to this object.  See IEEE-754
        // 2008, 5.1, first paragraph, second sentence for specification.

    Decimal_Type64&amp; operator-=(int                rhs);
    Decimal_Type64&amp; operator-=(unsigned int       rhs);
    Decimal_Type64&amp; operator-=(long               rhs);
    Decimal_Type64&amp; operator-=(unsigned long      rhs);
    Decimal_Type64&amp; operator-=(long long          rhs);
    Decimal_Type64&amp; operator-=(unsigned long long rhs);
        // Subtract the specified &#39;rhs&#39; from the value of this object as
        // described by IEEE-754, store the result in this object, and return a
        // reference to this object.
        //
        //: o If this object is NaN, raise the &quot;invalid&quot; floating-point
        //:   exception and do not change this object.
        //:
        //: o Otherwise if this object is infinity, then do not change it.
        //:
        //: o Otherwise if subtracting &#39;rhs&#39; from this object&#39;s value results
        //:   in an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and set this object to infinity with the
        //:   same sign as that result.
        //:
        //: o Otherwise set this object to the result of subtracting &#39;rhs&#39; from
        //:   the value of this object.
        //
        // Note that this is a floating-point value so this operations may not
        // change the value of this object at all (if the value is large) or it
        // may seem to update it to the value of the &#39;other&#39; (if the original
        // value is small).

    Decimal_Type64&amp; operator*=(Decimal32  rhs);
    Decimal_Type64&amp; operator*=(Decimal64  rhs);
    Decimal_Type64&amp; operator*=(Decimal128 rhs);
        // Multiply the value of the specified &#39;rhs&#39; object by the value of
        // this as described by IEEE-754, store the result in this object, and
        // return a reference to this object.
        //
        //: o If either this object or &#39;rhs&#39; is NaN, raise the &quot;invalid&quot;
        //:   floating-point exception and set this object to NaN.
        //:
        //: o Otherwise, if one of this object and &#39;rhs&#39; is zero (positive or
        //:   negative) and the other is infinity (positive or negative), raise
        //:   the &quot;invalid&quot; floating-point exception and set this object to a
        //:   NaN.
        //:
        //: o Otherwise, if either this object or &#39;rhs&#39; is positive or negative
        //:   infinity, set this object to infinity.  The sign of this object
        //:   will be positive if this object and &#39;rhs&#39; had the same sign, and
        //:   negative otherwise.
        //:
        //: o Otherwise, if either this object or &#39;rhs&#39; is zero, set this
        //:   object to zero.  The sign of this object will be positive if this
        //:   object and &#39;rhs&#39; had the same sign, and negative otherwise.
        //:
        //: o Otherwise if the product of this object and &#39;rhs&#39; has an absolute
        //:   value that is larger than &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39;
        //:   then raise the &quot;overflow&quot; floating-point exception and set this
        //:   object to infinity with the same sign of that result.
        //:
        //: o Otherwise if the product of this object and &#39;rhs&#39; has an absolute
        //:   value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and set this object to zero
        //:   value with the same sign as that result.
        //:
        //: o Otherwise set this object to the product of the value of &#39;rhs&#39;
        //:   and the value of this object.
        //
        // Note that when &#39;rhs&#39; is a &#39;Decimal128&#39;, this operation is always
        // performed with 128 bits precision to prevent loss of precision of
        // the &#39;rhs&#39; operand (prior to the operation).  The result is then
        // rounded back to 64 bits and stored to this object.  See IEEE-754
        // 2008, 5.1, first paragraph, second sentence for specification.

    Decimal_Type64&amp; operator*=(int                rhs);
    Decimal_Type64&amp; operator*=(unsigned int       rhs);
    Decimal_Type64&amp; operator*=(long               rhs);
    Decimal_Type64&amp; operator*=(unsigned long      rhs);
    Decimal_Type64&amp; operator*=(long long          rhs);
    Decimal_Type64&amp; operator*=(unsigned long long rhs);
        // Multiply the specified &#39;rhs&#39; by the value of this object as
        // described by IEEE-754, store the result in this object, and return a
        // reference to this object.
        //
        //: o If this object is NaN, raise the &quot;invalid&quot; floating-point
        //:   exception and set this object to a NaN.
        //:
        //: o Otherwise if this object is infinity (positive or negative), and
        //:   &#39;rhs&#39; is zero, then raise the &quot;invalid&quot; floating-point exception
        //:   and set this object to a NaN.
        //:
        //: o Otherwise if this object is infinity (positive or negative), then
        //:   do not change it.
        //:
        //: o Otherwise if &#39;rhs&#39; is zero, then set this object to zero with the
        //:   same sign as its value had prior to this operation.
        //:
        //: o Otherwise if the product of &#39;rhs&#39; and the value of this object
        //:   results in an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and set this object to infinity with the
        //:   same sign as that result.
        //:
        //: o Otherwise if the product of &#39;rhs&#39; and the value of this object
        //:   results in an absolute value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and set this object to zero
        //:   with the same sign as that result.
        //:
        //: o Otherwise set this object to the product of the value of this
        //:   object and the value &#39;rhs&#39;.

    Decimal_Type64&amp; operator/=(Decimal32  rhs);
    Decimal_Type64&amp; operator/=(Decimal64  rhs);
    Decimal_Type64&amp; operator/=(Decimal128 rhs);
        // Divide the value of this object by the value of the specified &#39;rhs&#39;
        // as described by IEEE-754, store the result in this object, and
        // return a reference to this object.
        //
        //: o If either this object or &#39;rhs&#39; is NaN, then raise the &quot;invalid&quot;
        //:   floating-point exception and set this object to a NaN.
        //:
        //: o Otherwise if this object and &#39;rhs&#39; are infinity (positive or
        //:   negative) or zero (positive or negative), then raise the
        //:   &quot;invalid&quot; floating-point exception and set this object to a NaN.
        //:
        //: o Otherwise if &#39;rhs&#39; has a positive zero value, then raise the
        //:   &quot;overflow&quot; floating-point exception and set this object to
        //:   infinity with the same sign as its original value.
        //:
        //: o Otherwise if &#39;rhs&#39; has a negative zero value, then raise the
        //:   &quot;overflow&quot; floating-point exception and set this object to
        //:   infinity with the opposite sign as its original value.
        //:
        //: o Otherwise if dividing the value of this object with the value of
        //:   &#39;rhs&#39; results in an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and set this object to infinity value
        //:   with the same sign as that result.
        //:
        //: o Otherwise if dividing the value of this object with the value of
        //:   &#39;rhs&#39; results in an absolute value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and set this object to zero
        //:   with the same sign as that result.
        //:
        //: o Otherwise set this object to the result of dividing the value of
        //:   this object with the value of &#39;rhs&#39;.
        //
        // Note that when &#39;rhs&#39; is a &#39;Decimal128&#39;, this operation is always
        // performed with 128 bits precision to prevent loss of precision of
        // the &#39;rhs&#39; operand (prior to the operation).  The result is then
        // rounded back to 64 bits and stored to this object.  See IEEE-754
        // 2008, 5.1, first paragraph, second sentence for specification.

    Decimal_Type64&amp; operator/=(int                rhs);
    Decimal_Type64&amp; operator/=(unsigned int       rhs);
    Decimal_Type64&amp; operator/=(long               rhs);
    Decimal_Type64&amp; operator/=(unsigned long      rhs);
    Decimal_Type64&amp; operator/=(long long          rhs);
    Decimal_Type64&amp; operator/=(unsigned long long rhs);
        // Divide the value of this object by the specified &#39;rhs&#39; as described
        // by IEEE-754, store the result in this object, and return a reference
        // to this object.
        //
        //: o If this object is NaN, raise the &quot;invalid&quot; floating-point
        //:   exception and set this object to a NaN.
        //:
        //: o Otherwise if this object is infinity (positive or negative), and
        //:   &#39;rhs&#39; is zero, raise the &quot;invalid&quot; floating-point exception and
        //:   set this object to a NaN.
        //:
        //: o Otherwise if this object is infinity, then do not change it.
        //:
        //: o Otherwise if &#39;rhs&#39; is zero, raise the &quot;overflow&quot; floating-point
        //:   exception and then set this object to infinity with the same sign
        //:   it had prior to this operation.
        //:
        //: o Otherwise if the quotient of the value of this object and &#39;rhs&#39;
        //:   results in an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and set this object to infinity with the
        //:   same sign as that result.
        //:
        //: o Otherwise if the quotient of the value of this object and &#39;rhs&#39;
        //:   results in an absolute value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and set this object to zero
        //:   with the same sign as that result.
        //:
        //: o Otherwise set this object to the result of dividing the number
        //:   represented by this object by &#39;rhs&#39;.

    DecimalImpUtil::ValueType64 *data();
        // Return a modifiable pointer to the underlying implementation.

                                  // Aspects

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated, but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // ACCESSORS
    const DecimalImpUtil::ValueType64 *data() const;
        // Return a non-modifiable pointer to the underlying implementation.

    DecimalImpUtil::ValueType64 value() const;
        // Return the value of the underlying implementation.

                                  // Aspects

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write the value of this object, using the specified &#39;version&#39;
        // format, to the specified output &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation has no
        // effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is invalidated, but
        // otherwise unmodified.  Note that &#39;version&#39; is not written to
        // &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Write the value of this object to the specified output &#39;stream&#39; in a
        // human-readable format, and return a reference to &#39;stream&#39;.
        // Optionally specify an initial indentation &#39;level&#39;, whose absolute
        // value is incremented recursively for nested objects.  If &#39;level&#39; is
        // specified, optionally specify &#39;spacesPerLevel&#39;, whose absolute value
        // indicates the number of spaces per indentation level for this and
        // all of its nested objects.  If &#39;level&#39; is negative, suppress
        // indentation of the first line.  If &#39;spacesPerLevel&#39; is negative,
        // format the entire output on one line, suppressing all but the
        // initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is not
        // valid on entry, this operation has no effect.  Note that this
        // human-readable format is not fully specified, and can change without
        // notice.
};

// FREE OPERATORS
Decimal64 operator+(Decimal64 value);
    // Return a copy of the specified &#39;value&#39;.

Decimal64 operator-(Decimal64 value);
    // Return the result of applying the unary - operator to the specified
    // &#39;value&#39; as described by IEEE-754.  Note that floating-point numbers have
    // signed zero, therefore this operation is not the same as &#39;0-value&#39;.

Decimal64 operator++(Decimal64&amp; value, int);
    // Apply the prefix ++ operator to the specified &#39;value&#39; and return its
    // original value.  Note that this is a floating-point value so this
    // operations may not change the value of this object at all (if the value
    // is large) or it may seem to just set it to 1.0 (if the original value is
    // small).

Decimal64 operator--(Decimal64&amp; value, int);
    // Apply the prefix -- operator to the specified &#39;value&#39; and return its
    // original value.  Note that this is a floating-point value so this
    // operations may not change the value of this object at all (if the value
    // is large) or it may seem to just set it to 1.0 (if the original value is
    // small).

Decimal64 operator+(Decimal64 lhs, Decimal64 rhs);
Decimal64 operator+(Decimal32 lhs, Decimal64 rhs);
Decimal64 operator+(Decimal64 lhs, Decimal32 rhs);
    // Add the value of the specified &#39;rhs&#39; to the value of the specified &#39;lhs&#39;
    // as described by IEEE-754 and return the result.
    //
    //: o If either of &#39;lhs&#39; or &#39;rhs&#39; is NaN, then raise the &quot;invalid&quot;
    //:   floating-point exception and return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; and &#39;rhs&#39; are infinities of differing signs, raise
    //:   the &quot;invalid&quot; floating-point exception and return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; and &#39;rhs&#39; are infinities of the same sign then
    //:   return infinity of that sign.
    //:
    //: o Otherwise if &#39;rhs&#39; is zero (positive or negative), return &#39;lhs&#39;.
    //:
    //: o Otherwise if the sum of &#39;lhs&#39; and &#39;rhs&#39; has an absolute value that is
    //:   larger than &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the
    //:   &quot;overflow&quot; floating-point exception and return infinity with the same
    //:   sign as that result.
    //:
    //: o Otherwise return the sum of the number represented by &#39;lhs&#39; and the
    //:   number represented by &#39;rhs&#39;.

Decimal64 operator+(Decimal64 lhs, int                rhs);
Decimal64 operator+(Decimal64 lhs, unsigned int       rhs);
Decimal64 operator+(Decimal64 lhs, long               rhs);
Decimal64 operator+(Decimal64 lhs, unsigned long      rhs);
Decimal64 operator+(Decimal64 lhs, long long          rhs);
Decimal64 operator+(Decimal64 lhs, unsigned long long rhs);
    // Add the specified &#39;rhs&#39; to the value of the specified &#39;lhs&#39; as described
    // by IEEE-754 and return the result.
    //
    //: o If &#39;lhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception and
    //:   return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; is infinity, then return that infinity.
    //:
    //: o Otherwise if the sum of &#39;lhs&#39; and &#39;rhs&#39; has an absolute value that is
    //:   larger than &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the
    //:   &quot;overflow&quot; floating-point exception and return infinity with the same
    //:   sign as that result.
    //:
    //: o Otherwise return the sum of &#39;rhs&#39; and the number represented by
    //:   &#39;lhs&#39;.

Decimal64 operator+(int                lhs, Decimal64 rhs);
Decimal64 operator+(unsigned int       lhs, Decimal64 rhs);
Decimal64 operator+(long               lhs, Decimal64 rhs);
Decimal64 operator+(unsigned long      lhs, Decimal64 rhs);
Decimal64 operator+(long long          lhs, Decimal64 rhs);
Decimal64 operator+(unsigned long long lhs, Decimal64 rhs);
    // Add the specified &#39;lhs&#39; to the value of the specified &#39;rhs&#39; as described
    // by IEEE-754 and return the result.
    //
    //: o If &#39;rhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception and
    //:   return a NaN.
    //:
    //: o Otherwise if &#39;rhs&#39; is infinity, then return that infinity.
    //:
    //: o Otherwise if the sum of the value of &#39;rhs&#39; and &#39;lhs&#39; has an absolute
    //:   value that is larger than &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39;
    //:   then raise the &quot;overflow&quot; floating-point exception and return
    //:   infinity with the same sign as that result.
    //:
    //: o Otherwise return the sum of &#39;lhs&#39; and the number represented by
    //:   &#39;rhs&#39;.

Decimal64 operator-(Decimal64 lhs, Decimal64 rhs);
Decimal64 operator-(Decimal32 lhs, Decimal64 rhs);
Decimal64 operator-(Decimal64 lhs, Decimal32 rhs);
    // Subtract the value of the specified &#39;rhs&#39; from the value of the
    // specified &#39;lhs&#39; as described by IEEE-754 and return the result.
    //
    //: o If either &#39;lhs&#39; or &#39;rhs&#39; is NaN, then raise the &quot;invalid&quot;
    //:   floating-point exception and return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; and the &#39;rhs&#39; have infinity values of the same
    //:   sign, then raise the &quot;invalid&quot; floating-point exception and return a
    //:   NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; and the &#39;rhs&#39; have infinity values of differing
    //:   signs, then return &#39;lhs&#39;.
    //:
    //: o Otherwise if &#39;rhs&#39; has a zero value (positive or negative), then
    //:   return &#39;lhs&#39;.
    //:
    //: o Otherwise if subtracting the value of the &#39;rhs&#39; object from the value
    //:   of &#39;lhs&#39; results in an absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise return the result of subtracting the value of &#39;rhs&#39; from
    //:   the value of &#39;lhs&#39;.

Decimal64 operator-(Decimal64 lhs, int                rhs);
Decimal64 operator-(Decimal64 lhs, unsigned int       rhs);
Decimal64 operator-(Decimal64 lhs, long               rhs);
Decimal64 operator-(Decimal64 lhs, unsigned long      rhs);
Decimal64 operator-(Decimal64 lhs, long long          rhs);
Decimal64 operator-(Decimal64 lhs, unsigned long long rhs);
    // Subtract the specified &#39;rhs&#39; from the value of the specified &#39;lhs&#39; as
    // described by IEEE-754 and return a reference to this object.
    //
    //: o If &#39;lhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception and
    //:   return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; is infinity, then return &#39;lhs&#39;.
    //:
    //: o Otherwise if subtracting &#39;rhs&#39; from the value of &#39;lhs&#39; results in an
    //:   absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise return the result of subtracting &#39;rhs&#39; from the value of
    //:   &#39;lhs&#39;.

Decimal64 operator-(int                lhs, Decimal64 rhs);
Decimal64 operator-(unsigned int       lhs, Decimal64 rhs);
Decimal64 operator-(long               lhs, Decimal64 rhs);
Decimal64 operator-(unsigned long      lhs, Decimal64 rhs);
Decimal64 operator-(long long          lhs, Decimal64 rhs);
Decimal64 operator-(unsigned long long lhs, Decimal64 rhs);
    // Subtract the specified &#39;rhs&#39; from the value of the specified &#39;lhs&#39; as
    // described by IEEE-754 and return a reference to this object.
    //
    //: o If &#39;lhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception return
    //:   a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; is infinity, then return &#39;lhs&#39;.
    //:
    //: o Otherwise if &#39;rhs&#39; is zero (positive or negative), then return &#39;lhs&#39;.
    //:
    //: o Otherwise if subtracting &#39;rhs&#39; from the value of &#39;lhs&#39; results in an
    //:   absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise return the result of subtracting the value of &#39;rhs&#39;
    // from the number &#39;lhs&#39;.

Decimal64 operator*(Decimal64 lhs, Decimal64 rhs);
Decimal64 operator*(Decimal32 lhs, Decimal64 rhs);
Decimal64 operator*(Decimal64 lhs, Decimal32 rhs);
    // Multiply the value of the specified &#39;lhs&#39; object by the value of the
    // specified &#39;rhs&#39; as described by IEEE-754 and return the result.
    //
    //: o If either of &#39;lhs&#39; or &#39;rhs&#39; is NaN, return a NaN.
    //:
    //: o Otherwise if one of the operands is infinity (positive or negative)
    //:   and the other is zero (positive or negative), then raise the
    //:   &quot;invalid&quot; floating-point exception raised and return a NaN.
    //:
    //: o Otherwise if both &#39;lhs&#39; and &#39;rhs&#39; are infinity (positive or
    //:   negative), return infinity.  The sign of the returned value will be
    //:   positive if &#39;lhs&#39; and &#39;rhs&#39; have the same sign, and negative
    //:   otherwise.
    //:
    //: o Otherwise, if either &#39;lhs&#39; or &#39;rhs&#39; is zero, return zero.  The sign
    //:   of the returned value will be positive if &#39;lhs&#39; and &#39;rhs&#39; have the
    //:   same sign, and negative otherwise.
    //:
    //: o Otherwise if the product of &#39;lhs&#39; and &#39;rhs&#39; has an absolute value
    //:   that is larger than &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then
    //:   raise the &quot;overflow&quot; floating-point exception and return infinity
    //:   with the same sign as that result.
    //:
    //: o Otherwise if the product of &#39;lhs&#39; and &#39;rhs&#39; has an absolute value
    //:   that is smaller than &#39;std::numeric_limits&lt;Decimal64&gt;::min()&#39; then
    //:   raise the &quot;underflow&quot; floating-point exception and return zero with
    //:   the same sign as that result.
    //:
    //: o Otherwise return the product of the value of &#39;rhs&#39; and the number
    //:   represented by &#39;rhs&#39;.

Decimal64 operator*(Decimal64 lhs, int                rhs);
Decimal64 operator*(Decimal64 lhs, unsigned int       rhs);
Decimal64 operator*(Decimal64 lhs, long               rhs);
Decimal64 operator*(Decimal64 lhs, unsigned long      rhs);
Decimal64 operator*(Decimal64 lhs, long long          rhs);
Decimal64 operator*(Decimal64 lhs, unsigned long long rhs);
    // Multiply the specified &#39;rhs&#39; by the value of the specified &#39;lhs&#39; as
    // described by IEEE-754, and return the result.
    //
    //: o If &#39;lhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception and
    //:   return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; is infinity (positive or negative), and &#39;rhs&#39; is
    //:   zero, then raise the &quot;invalid&quot; floating-point exception and return a
    //:   NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; is infinity (positive or negative), then return
    //:   &#39;lhs&#39;.
    //:
    //: o Otherwise if &#39;rhs&#39; is zero, then return zero with the sign of &#39;lhs&#39;.
    //:
    //: o Otherwise if the product of &#39;rhs&#39; and the value of &#39;lhs&#39; has an
    //:   absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise if the product of &#39;rhs&#39; and the value of &#39;lhs&#39; has an
    //:   absolute value that is smaller than
    //:   &#39;std::numeric_limits&lt;Decimal64&gt;::min()&#39; then raise the &quot;underflow&quot;
    //:   floating-point exception and return zero with the same sign as that
    //:   result.
    //:
    //: o Otherwise return the product of the value of &#39;lhs&#39; and value &#39;rhs&#39;.

Decimal64 operator*(int                lhs, Decimal64 rhs);
Decimal64 operator*(unsigned int       lhs, Decimal64 rhs);
Decimal64 operator*(long               lhs, Decimal64 rhs);
Decimal64 operator*(unsigned long      lhs, Decimal64 rhs);
Decimal64 operator*(long long          lhs, Decimal64 rhs);
Decimal64 operator*(unsigned long long lhs, Decimal64 rhs);
    // Multiply the specified &#39;lhs&#39; by the value of the specified &#39;rhs&#39; as
    // described by IEEE-754, and return the result.
    //
    //: o If &#39;rhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception and
    //:   return a NaN.
    //:
    //: o Otherwise if &#39;rhs&#39; is infinity (positive or negative), and &#39;lhs&#39; is
    //:   zero, then raise the &quot;invalid&quot; floating-point exception and return a
    //:   NaN.
    //:
    //: o Otherwise if &#39;rhs&#39; is infinity (positive or negative), then return
    //:   &#39;rhs&#39;.
    //:
    //: o Otherwise if &#39;lhs&#39; is zero, then return zero with the sign of &#39;rhs&#39;.
    //:
    //: o Otherwise if the product of &#39;lhs&#39; and the value of &#39;rhs&#39; has an
    //:   absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise if the product of &#39;lhs&#39; and the value of &#39;rhs&#39; has an
    //:   absolute value that is smaller than
    //:   &#39;std::numeric_limits&lt;Decimal64&gt;::min()&#39; then raise the &quot;underflow&quot;
    //:   floating-point exception and return zero with the same sign as that
    //:   result.
    //:
    //: o Otherwise return the product of the value of &#39;rhs&#39; and value &#39;lhs&#39;.

Decimal64 operator/(Decimal64 lhs, Decimal64 rhs);
Decimal64 operator/(Decimal32 lhs, Decimal64 rhs);
Decimal64 operator/(Decimal64 lhs, Decimal32 rhs);
    // Divide the value of the specified &#39;lhs&#39; by the value of the specified
    // &#39;rhs&#39; as described by IEEE-754, and return the result.
    //
    //: o If &#39;lhs&#39; or &#39;rhs&#39; is NaN, raise the &quot;invalid&quot; floating-point
    //:   exception and return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; and &#39;rhs&#39; are both infinity (positive or negative)
    //:   or both zero (positive or negative), raise the &quot;invalid&quot;
    //:   floating-point exception and return a NaN.
    //:
    //: o Otherwise if &#39;rhs&#39; has a positive zero value, raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the sign of &#39;lhs&#39;.
    //:
    //: o Otherwise if &#39;rhs&#39; has a negative zero value, raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the opposite sign
    //:   as &#39;lhs&#39;.
    //:
    //: o Otherwise if dividing the value of &#39;lhs&#39; with the value of &#39;rhs&#39;
    //:   results in an absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise if dividing the value of &#39;lhs&#39; with the value of &#39;rhs&#39;
    //:   results in an absolute value that is smaller than
    //:   &#39;std::numeric_limits&lt;Decimal64&gt;::min()&#39; then raise the &quot;underflow&quot;
    //:   floating-point exception and return zero with the same sign as that
    //:   result.
    //:
    //: o Otherwise return the result of dividing the value of &#39;lhs&#39; with the
    //:   value of &#39;rhs&#39;.

Decimal64 operator/(Decimal64 lhs, int                rhs);
Decimal64 operator/(Decimal64 lhs, unsigned int       rhs);
Decimal64 operator/(Decimal64 lhs, long               rhs);
Decimal64 operator/(Decimal64 lhs, unsigned long      rhs);
Decimal64 operator/(Decimal64 lhs, long long          rhs);
Decimal64 operator/(Decimal64 lhs, unsigned long long rhs);
    // Divide the value of the specified &#39;lhs&#39; by the specified &#39;rhs&#39; as
    // described by IEEE-754, and return the result.
    //
    //: o If &#39;lhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception and
    //:   return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; is infinity (positive or negative), and &#39;rhs&#39; is
    //:   zero, raise the &quot;invalid&quot; floating-point exception and return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; is infinity (positive or negative), then return
    //:   &#39;lhs&#39;.
    //:
    //: o Otherwise if &#39;rhs&#39; is zero, raise the &quot;overflow&quot; floating-point
    //:   exception return zero with the sign of &#39;lhs&#39;.
    //:
    //: o Otherwise if the quotient of the value of &#39;lhs&#39; and &#39;rhs&#39; results in
    //:   an absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise if the quotient of the value of &#39;lhs&#39; and &#39;rhs&#39; results in
    //:   an absolute value that is smaller than
    //:   &#39;std::numeric_limits&lt;Decimal64&gt;::min()&#39; then raise the &quot;underflow&quot;
    //:   floating-point exception and return zero with the same sign as that
    //:   result.
    //:
    //: o Otherwise return the result of dividing the value of &#39;lhs&#39; by the
    //:   value &#39;rhs&#39;.

Decimal64 operator/(int                lhs, Decimal64 rhs);
Decimal64 operator/(unsigned int       lhs, Decimal64 rhs);
Decimal64 operator/(long               lhs, Decimal64 rhs);
Decimal64 operator/(unsigned long      lhs, Decimal64 rhs);
Decimal64 operator/(long long          lhs, Decimal64 rhs);
Decimal64 operator/(unsigned long long lhs, Decimal64 rhs);
    // Divide the specified &#39;lhs&#39; by the value of the specified &#39;rhs&#39; as
    // described by IEEE-754, and return the result.
    //
    //: o If &#39;rhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception and
    //:   return a NaN.
    //:
    //: o Otherwise if &#39;rhs&#39; is infinity (positive or negative), and &#39;lhs&#39; is
    //:   zero, raise the &quot;invalid&quot; floating-point exception and return a NaN.
    //:
    //: o Otherwise if &#39;rhs&#39; is zero (positive or negative), raise the
    //:   &quot;overflow&quot; floating-point exception return zero with the sign of
    //:   &#39;lhs&#39;.
    //:
    //: o Otherwise if the quotient of &#39;rhs&#39; and the value of &#39;rhs&#39; results in
    //:   an absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise if the quotient of &#39;lhs&#39; and the value of &#39;rhs&#39; results in
    //:   an absolute value that is smaller than
    //:   &#39;std::numeric_limits&lt;Decimal64&gt;::min()&#39; then raise the &quot;underflow&quot;
    //:   floating-point exception and return zero with the same sign as that
    //:   result.
    //:
    //: o Otherwise return the result of dividing the value &#39;lhs&#39; by the value
    //:   of &#39;rhs&#39;.  Note that this is a floating-point operation, not integer.

bool operator==(Decimal64 lhs, Decimal64 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; have the same value, and
    // &#39;false&#39; otherwise.  Two &#39;Decimal64&#39; objects have the same value if the
    // &#39;compareQuietEqual&#39; operation (IEEE-754 defined, non-total ordering
    // comparison) considers the underlying IEEE representations equal.  In
    // other words, two &#39;Decimal64&#39; objects have the same value if:
    //
    //: o both have a zero value (positive or negative), or
    //: o both have the same infinity value (both positive or negative), or
    //: o both have the value of a real number that are equal, even if they are
    //:   represented differently (cohorts have the same value)
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.
    //
    // Note that a NaN is never equal to anything, including itself:
    //..
    //  Decimal64 aNaN = std::numeric_limits&lt;Decimal64&gt;::quiet_NaN();
    //  assert(!(aNan == aNan));
    //..

bool operator==(Decimal32 lhs, Decimal64 rhs);
bool operator==(Decimal64 lhs, Decimal32 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; have the same value, and
    // &#39;false&#39; otherwise.  Two decimal objects have the same value if the
    // &#39;compareQuietEqual&#39; operation (IEEE-754 defined, non-total ordering
    // comparison) considers the underlying IEEE representations equal.  In
    // other words, two decimal objects have the same value if:
    //
    //: o both have a zero value (positive or negative), or
    //: o both have the same infinity value (both positive or negative), or
    //: o both have the value of a real number that are equal, even if they are
    //:   represented differently (cohorts have the same value)
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator!=(Decimal64 lhs, Decimal64 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; do not have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;Decimal64&#39; objects do not have the
    // same value if the &#39;compareQuietEqual&#39; operation (IEEE-754 defined,
    // non-total ordering comparison) considers the underlying IEEE
    // representations not equal.  In other words, two &#39;Decimal64&#39; objects do
    // not have the same value if:
    //
    //: o both are a NaN, or
    //: o one has zero value (positive or negative) and the other does not, or
    //: o one has the value of positive infinity and the other does not, or
    //: o one has the value of negative infinity and the other does not, or
    //: o both have the value of a real number that are not equal, regardless
    //:   of their representation (cohorts are equal)
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.
    //
    // Note that a NaN is never equal to anything, including itself:
    //..
    //  Decimal64 aNaN = std::numeric_limits&lt;Decimal64&gt;::quiet_NaN();
    //  assert(aNan != aNan);
    //..

bool operator!=(Decimal32 lhs, Decimal64 rhs);
bool operator!=(Decimal64 lhs, Decimal32 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; do not have the same
    // value, and &#39;false&#39; otherwise.  Two decimal objects do not have the same
    // value if the &#39;compareQuietEqual&#39; operation (IEEE-754 defined, non-total
    // ordering comparison) considers the underlying IEEE representations not
    // equal.  In other words, two decimal objects do not have the same value
    // if:
    //
    //: o both are NaN, or
    //: o one has zero value (positive or negative) and the other does not, or
    //: o one has the value of positive infinity and the other does not, or
    //: o one has the value of negative infinity and the other does not, or
    //: o both have the value of a real number that are not equal, regardless
    //:   of their representation (cohorts are equal)
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&lt;(Decimal64 lhs, Decimal64 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value less than the specified
    // &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a &#39;Decimal64&#39; object &#39;lhs&#39; is
    // less than that of an object &#39;rhs&#39; if the &#39;compareQuietLess&#39; operation
    // (IEEE-754 defined, non-total ordering comparison) considers the
    // underlying IEEE representation of &#39;lhs&#39; to be less than of that of
    // &#39;rhs&#39;.  In other words, &#39;lhs&#39; is less than &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; is zero (positive or negative) and &#39;rhs&#39; is positive, or
    //: o &#39;rhs&#39; is zero (positive or negative) and &#39;lhs&#39; negative, or
    //: o &#39;lhs&#39; is not positive infinity, or
    //: o &#39;lhs&#39; is negative infinity and &#39;rhs&#39; is not, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is less than that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&lt;(Decimal32 lhs, Decimal64 rhs);
bool operator&lt;(Decimal64 lhs, Decimal32 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value less than the specified
    // &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a decimal object &#39;lhs&#39; is
    // less than that of an object &#39;rhs&#39; if the &#39;compareQuietLess&#39; operation
    // (IEEE-754 defined, non-total ordering comparison) considers the
    // underlying IEEE representation of &#39;lhs&#39; to be less than of that of
    // &#39;rhs&#39;.  In other words, &#39;lhs&#39; is less than &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; is zero (positive or negative) and &#39;rhs&#39; is positive, or
    //: o &#39;rhs&#39; is zero (positive or negative) and &#39;lhs&#39; negative, or
    //: o &#39;lhs&#39; is not positive infinity, or
    //: o &#39;lhs&#39; is negative infinity and &#39;rhs&#39; is not, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is less than that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&lt;=(Decimal64 lhs, Decimal64 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value less than or equal the
    // value of the specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a
    // &#39;Decimal64&#39; object &#39;lhs&#39; is less than or equal to the value of an object
    // &#39;rhs&#39; if the &#39;compareQuietLessEqual&#39; operation (IEEE-754 defined,
    // non-total ordering comparison) considers the underlying IEEE
    // representation of &#39;lhs&#39; to be less or equal to that of &#39;rhs&#39;.  In other
    // words, &#39;lhs&#39; is less or equal than &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; are both zero (positive or negative), or
    //: o both &#39;lhs&#39; and &#39;rhs&#39; are positive infinity, or
    //: o &#39;lhs&#39; is negative infinity, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is less or equal to that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&lt;=(Decimal32 lhs, Decimal64 rhs);
bool operator&lt;=(Decimal64 lhs, Decimal32 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value less than or equal the
    // value of the specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a
    // decimal object &#39;lhs&#39; is less than or equal to the value of an object
    // &#39;rhs&#39; if the &#39;compareQuietLessEqual&#39; operation (IEEE-754 defined,
    // non-total ordering comparison) considers the underlying IEEE
    // representation of &#39;lhs&#39; to be less or equal to that of &#39;rhs&#39;.  In other
    // words, &#39;lhs&#39; is less or equal than &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; are both zero (positive or negative), or
    //: o both &#39;lhs&#39; and &#39;rhs&#39; are positive infinity, or
    //: o &#39;lhs&#39; is negative infinity, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is less or equal to that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&gt;(Decimal64 lhs, Decimal64 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a greater value than the
    // specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a &#39;Decimal64&#39;
    // object &#39;lhs&#39; is greater than that of an object &#39;rhs&#39; if the
    // &#39;compareQuietGreater&#39; operation (IEEE-754 defined, non-total ordering
    // comparison) considers the underlying IEEE representation of &#39;lhs&#39; to be
    // greater than of that of &#39;rhs&#39;.  In other words, &#39;lhs&#39; is greater than
    // &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;rhs&#39; is zero (positive or negative) and &#39;lhs&#39; positive, or
    //: o &#39;lhs&#39; is zero (positive or negative) and &#39;rhs&#39; negative, or
    //: o &#39;lhs&#39; is not negative infinity, or
    //: o &#39;lhs&#39; is positive infinity and &#39;rhs&#39; is not, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is greater than that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&gt;(Decimal32 lhs, Decimal64 rhs);
bool operator&gt;(Decimal64 lhs, Decimal32 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a greater value than the
    // specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a decimal object
    // &#39;lhs&#39; is greater than that of an object &#39;rhs&#39; if the
    // &#39;compareQuietGreater&#39; operation (IEEE-754 defined, non-total ordering
    // comparison) considers the underlying IEEE representation of &#39;lhs&#39; to be
    // greater than of that of &#39;rhs&#39;.  In other words, &#39;lhs&#39; is greater than
    // &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;rhs&#39; is zero (positive or negative) and &#39;lhs&#39; positive, or
    //: o &#39;lhs&#39; is zero (positive or negative) and &#39;rhs&#39; negative, or
    //: o &#39;lhs&#39; is not negative infinity, or
    //: o &#39;lhs&#39; is positive infinity and &#39;rhs&#39; is not, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is greater than that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&gt;=(Decimal64 lhs, Decimal64 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value greater than or equal
    // to the value of the specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of
    // a &#39;Decimal64&#39; object &#39;lhs&#39; is greater or equal to a &#39;Decimal64&#39; object
    // &#39;rhs&#39; if the &#39;compareQuietGreaterEqual&#39; operation (IEEE-754 defined,
    // non-total ordering comparison ) considers the underlying IEEE
    // representation of &#39;lhs&#39; to be greater or equal to that of &#39;rhs&#39;.  In
    // other words, &#39;lhs&#39; is greater than or equal to &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; are both zero (positive or negative), or
    //: o both &#39;lhs&#39; and &#39;rhs&#39; are negative infinity, or
    //: o &#39;lhs&#39; is positive infinity, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is greater or equal to that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&gt;=(Decimal32 lhs, Decimal64 rhs);
bool operator&gt;=(Decimal64 lhs, Decimal32 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value greater than or equal
    // to the value of the specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of
    // a decimal object &#39;lhs&#39; is greater or equal to a decimal object &#39;rhs&#39; if
    // the &#39;compareQuietGreaterEqual&#39; operation (IEEE-754 defined, non-total
    // ordering comparison ) considers the underlying IEEE representation of
    // &#39;lhs&#39; to be greater or equal to that of &#39;rhs&#39;.  In other words, &#39;lhs&#39; is
    // greater than or equal to &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; are both zero (positive or negative), or
    //: o both &#39;lhs&#39; and &#39;rhs&#39; are negative infinity, or
    //: o &#39;lhs&#39; is positive infinity, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is greater or equal to that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

template &lt;class CHARTYPE, class TRAITS&gt;
bsl::basic_istream&lt;CHARTYPE, TRAITS&gt;&amp;
operator&gt;&gt; (bsl::basic_istream&lt;CHARTYPE, TRAITS&gt;&amp; stream, Decimal64&amp; object);
    // Read, into the specified &#39;object&#39;, from the specified input &#39;stream&#39; an
    // IEEE 64 bit decimal floating-point value as described in the IEEE-754
    // 2008 standard (5.12 Details of conversions between floating point
    // numbers and external character sequences) and return a reference
    // providing modifiable access to &#39;stream&#39;.  If &#39;stream&#39; contains a Nan
    // value, it is unspecified if &#39;object&#39; will receive a quiet or signaling
    // &#39;Nan&#39;.  If &#39;stream&#39; is not valid on entry &#39;stream.good() == false&#39;, this
    // operation has no effect other than setting &#39;stream.fail()&#39; to &#39;true&#39;.
    // If eof (end-of-file) is found before any non-whitespace characters
    // &#39;stream.fail()&#39; is set to &#39;true&#39; and &#39;object&#39; remains unchanged.  If eof
    // is detected after some characters have been read (and successfully
    // interpreted as part of the textual representation of a floating-point
    // value as specified by IEEE-754) then &#39;stream.eof()&#39; is set to true.  If
    // the first non-whitespace character sequence is not a valid textual
    // representation of a floating-point value (e.g., 12e or e12 or 1*2) the
    // &#39;stream.fail()&#39; is set to true and &#39;object&#39; will remain unchanged.  If a
    // real number value is represented by the character sequence but it is a
    // large positive or negative value that cannot be stored into &#39;object&#39; the
    // &quot;overflow&quot; floating-point exception is raised and positive or negative
    // infinity is stored into &#39;object&#39;, respectively.  If a real number value
    // is represented by the character sequence but it is a small positive or
    // negative value that cannot be stored into &#39;object&#39; the &quot;underflow&quot;
    // floating-point exception is raised and positive or negative zero is
    // stored into &#39;object&#39;, respectively.  If a real number value is
    // represented by the character sequence but it cannot be stored exactly
    // into &#39;object&#39; the &quot;inexact&quot; floating-point exception is raised, the
    // value is rounded according to the current rounding direction (of the
    // environment) and then stored into &#39;object.&#39;
    //
    // NOTE: This method does not yet fully support iostream flags or the
    // decimal floating point exception context.

template &lt;class CHARTYPE, class TRAITS&gt;
bsl::basic_ostream&lt;CHARTYPE, TRAITS&gt;&amp;
operator&lt;&lt; (bsl::basic_ostream&lt;CHARTYPE, TRAITS&gt;&amp; stream, Decimal64 object);
    // Write the value of the specified &#39;object&#39; to the specified output
    // &#39;stream&#39; in a single line format as described in the IEEE-754 2008
    // standard (5.12 Details of conversions between floating point numbers and
    // external character sequences), and return a reference providing
    // modifiable access to &#39;stream&#39;.  If &#39;stream&#39; is not valid on entry, this
    // operation has no effect.
    //
    // NOTE: This method does not yet fully support iostream flags or the
    // decimal floating point exception context.

                           // =====================
                           // class Decimal_Type128
                           // =====================

class Decimal_Type128 {
    // This value-semantic class implements the IEEE-754 128 bit decimal
    // floating-point format arithmetic type.  This class is a standard layout
    // type that is &#39;const&#39; thread-safe and exception-neutral.

  private:
    // DATA
    DecimalImpUtil::ValueType128 d_value;
                                          // The underlying IEEE representation

  public:
    // TRAITS
    BSLALG_DECLARE_NESTED_TRAITS(Decimal_Type128,
                                 bslalg::TypeTraitBitwiseCopyable);

    // CREATORS
    Decimal_Type128();
        // Create a &#39;Decimal128_Type&#39; object having the value positive zero,
        // and 0 exponent (quantum 1e-33).

    Decimal_Type128(DecimalImpUtil::ValueType128 value);            // IMPLICIT
        // Create a &#39;Decimal128_Type&#39; object having the specified &#39;value&#39;.

    Decimal_Type128(Decimal32 value);                               // IMPLICIT
    Decimal_Type128(Decimal64 value);                               // IMPLICIT
        // Create a &#39;Decimal128_Type&#39; object having the specified &#39;value&#39;,
        // subject to the conversion rules defined by IEEE-754:
        //
        //: o If &#39;value&#39; is NaN, initialize this object to a NaN.
        //:
        //: o Otherwise if &#39;value&#39; is infinity, then initialize this object to
        //:   infinity with the same sign.
        //:
        //: o Otherwise if &#39;value&#39; is zero, then initialize this object to zero
        //:   with the same sign.
        //:
        //: o Otherwise initialize this object to &#39;value&#39;.

    explicit Decimal_Type128(float  other);
    explicit Decimal_Type128(double other);
        // Create a &#39;Decimal128_Type&#39; object having the value closest to the
        // specified &#39;other&#39; value.  *Warning:* clients requiring a conversion
        // for an exact decimal value should use &#39;bdldfp_decimalconverutil&#39;
        // (see *WARNING*: Conversions from &#39;float&#39; and &#39;double&#39;}.  This
        // conversion follows the conversion rules as defined by IEEE-754:
        //
        //: o If &#39;value&#39; is NaN, initialize this object to a NaN.
        //:
        //: o Otherwise if &#39;value&#39; is infinity, then initialize this object to
        //:   infinity value with the same sign.
        //:
        //: o Otherwise if &#39;value&#39; has a zero value, then initialize this
        //:   object to zero with the same sign.
        //:
        //: o Otherwise if &#39;value&#39; has an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the
        //:   &quot;overflow&quot; floating-point exception and initialize this object to
        //:   infinity with the same sign as &#39;value&#39;.
        //:
        //: o Otherwise if &#39;value&#39; has an absolute value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and initialize this object
        //:   to zero with the same sign as &#39;value&#39;.
        //:
        //: o Otherwise if &#39;value&#39; has a value that needs more than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max_digit&#39; significant decimal
        //:   digits to represent then raise the &quot;inexact&quot; floating-point
        //:   exception and initialize this object to the value of &#39;value&#39;
        //:   rounded according to the rounding direction.
        //:
        //: o Otherwise initialize this object to &#39;value&#39;.

    explicit Decimal_Type128(int                value);
    explicit Decimal_Type128(unsigned int       value);
    explicit Decimal_Type128(long               value);
    explicit Decimal_Type128(unsigned long      value);
    explicit Decimal_Type128(long long          value);
    explicit Decimal_Type128(unsigned long long value);
        // Create a &#39;Decimal128_Type&#39; object having the value closest to the
        // specified &#39;value&#39; subject to the conversion rules as defined by
        // IEEE-754:
        //
        //: o If &#39;value&#39; is zero then initialize this object to positive zero
        //:   with a 0 exponent (quantum 1e-33).
        //:
        //: o Otherwise if &#39;value&#39; has an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the
        //:   &quot;overflow&quot; floating-point exception and initialize this object to
        //:   infinity with the same sign as &#39;other&#39;.
        //:
        //: o Otherwise if &#39;value&#39; has a value that is not exactly
        //:   representable using &#39;std::numeric_limits&lt;Decimal128&gt;::max_digit&#39;
        //:   decimal digits then raise the &quot;inexact&quot; floating-point exception
        //:   and initialize this object to the value of &#39;value&#39; rounded
        //:   according to the rounding direction.
        //:
        //: o Otherwise initialize this object to &#39;value&#39;.
        //
        // The exponent 0 (quantum 1e-33) is preferred during conversion unless
        // it would cause unnecessary loss of precision.

    //! Decimal128_Type(const Decimal128_Type&amp; original) = default;
        // Create a &#39;Decimal128_Type&#39; object that is a copy of the specified
        // &#39;original&#39; as defined by the &#39;copy&#39; operation of IEEE-754 2008:
        //
        //: o If &#39;original&#39; is NaN, initialize this object to a NaN.
        //:
        //: o Otherwise initialize this object to the value of the &#39;original&#39;.
        //
        // Note that since floating-point types may be NaN, and NaNs are
        // unordered (do not compare equal even to themselves) it is possible
        // that a copy of a decimal will not compare equal to the original;
        // however it will behave as the original.

    //! ~Decimal128_Type() = default;
        // Destroy this object.

    // MANIPULATORS
    //! Decimal128_Type&amp; operator=(const Decimal128_Type&amp; rhs) = default;
        // Make this object a copy of the specified &#39;rhs&#39; as defined by the
        // &#39;copy&#39; operation of IEEE-754 2008 and return a reference providing
        // modifiable access to this object.
        //
        //: o If &#39;rhs&#39; is NaN, set this object to a NaN.
        //:
        //: o Otherwise set this object to the value of the &#39;other&#39;.
        //
        // Note that since floating-point types may be NaN, and NaNs are
        // unordered (do not compare equal even to themselves) it is possible
        // that, after an assignment, a decimal will not compare equal to the
        // original; however it will behave as the original.

    Decimal_Type128&amp; operator++();
        // Add 1.0 to the value of this object and return a reference to it.
        // Note that this is a floating-point value so this operations may not
        // change the value of this object at all (if the value is large) or it
        // may seem to just set it to 1.0 (if the original value is small).

    Decimal_Type128&amp; operator--();
        // Add -1.0 to the value of this object and return a reference to it.
        // Note that this is a floating-point value so this operations may not
        // change the value of this object at all (if the value is large) or it
        // may seem to just set it to -1.0 (if the original value is small).

    Decimal_Type128&amp; operator+=(Decimal32  rhs);
    Decimal_Type128&amp; operator+=(Decimal64  rhs);
    Decimal_Type128&amp; operator+=(Decimal128 rhs);
        // Add the value of the specified &#39;rhs&#39; object to the value of this as
        // described by IEEE-754, store the result in this object, and return a
        // reference to this object.
        //
        //: o If either this object or &#39;rhs&#39; is NaN, then raise the &quot;invalid&quot;
        //:   floating-point exception and set this object to a NaN.
        //:
        //: o Otherwise if this object and &#39;rhs&#39; have infinite values of
        //:   differing signs, then raise the &quot;invalid&quot; floating-point
        //:   exception and set this object to a NaN.
        //:
        //: o Otherwise if this object and &#39;rhs&#39; have infinite values of the
        //:   same sign, then do not change this object.
        //:
        //: o Otherwise if &#39;rhs&#39; has a zero value (positive or negative), do
        //:   not change this object.
        //:
        //: o Otherwise if the sum of this object and &#39;rhs&#39; has an absolute
        //:   value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the
        //:   &quot;overflow&quot; floating-point exception and set this object to
        //:   infinity value with the same sign as that result.
        //:
        //: o Otherwise set this object to the sum of the number represented by
        //:   &#39;rhs&#39; and the number represented by this object.
        //
        // Note that this is a floating-point value so this operations may not
        // change the value of this object at all (if the value is large) or it
        // may seem to update it to the value of the &#39;other&#39; (if the original
        // value is small).

    Decimal_Type128&amp; operator+=(int                rhs);
    Decimal_Type128&amp; operator+=(unsigned int       rhs);
    Decimal_Type128&amp; operator+=(long               rhs);
    Decimal_Type128&amp; operator+=(unsigned long      rhs);
    Decimal_Type128&amp; operator+=(long long          rhs);
    Decimal_Type128&amp; operator+=(unsigned long long rhs);
        // Add the specified &#39;rhs&#39; to the value of this object as described by
        // IEEE-754, store the result in this object, and return a reference to
        // this object.
        //
        //: o If this object is NaN, then raise the &quot;invalid&quot; floating-point
        //:   exception and do not change this object.
        //:
        //: o Otherwise if this object is infinity, then do not change it.
        //:
        //: o Otherwise if the sum of this object and &#39;rhs&#39; has an absolute
        //:   value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the
        //:   &quot;overflow&quot; floating-point exception and set this object to
        //:   infinity with the same sign as that result.
        //:
        //: o Otherwise set this object to sum of adding &#39;rhs&#39; and the number
        //:   represented by this object.
        //
        // Note that this is a floating-point value so this operations may not
        // change the value of this object at all (if the value is large) or it
        // may seem to update it to the value of the &#39;other&#39; (if the original
        // value is small).

    Decimal_Type128&amp; operator-=(Decimal32  rhs);
    Decimal_Type128&amp; operator-=(Decimal64  rhs);
    Decimal_Type128&amp; operator-=(Decimal128 rhs);
        // Subtract the value of the specified &#39;rhs&#39; from the value of this
        // object as described by IEEE-754, store the result in this object,
        // and return a reference to this object.
        //
        //: o If either this object or &#39;rhs&#39; is NaN, then raise the &quot;invalid&quot;
        //:   floating-point exception and set this object to a NaN.
        //:
        //: o Otherwise if this object and the &#39;rhs&#39; have infinite values of
        //:   the same sign, raise the &quot;invalid&quot; floating-point exception and
        //:   set this object to a NaN.
        //:
        //: o Otherwise if this object and the &#39;rhs&#39; have infinite values of
        //:   differing signs, then do not change this object.
        //:
        //: o Otherwise if the &#39;rhs&#39; has a zero value (positive or negative),
        //:   do not change this object.
        //:
        //: o Otherwise if subtracting the value of the &#39;rhs&#39; object from this
        //:   results in an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the
        //:   &quot;overflow&quot; floating-point exception and set this object to
        //:   infinity with the same sign as that result.
        //:
        //: o Otherwise set this object to the result of subtracting the value
        //:   of &#39;rhs&#39; from the value of this object.
        //
        // Note that this is a floating-point value so this operations may not
        // change the value of this object at all (if the value is large) or it
        // may seem to update it to the value of the &#39;other&#39; (if the original
        // value is small).

    Decimal_Type128&amp; operator-=(int                rhs);
    Decimal_Type128&amp; operator-=(unsigned int       rhs);
    Decimal_Type128&amp; operator-=(long               rhs);
    Decimal_Type128&amp; operator-=(unsigned long      rhs);
    Decimal_Type128&amp; operator-=(long long          rhs);
    Decimal_Type128&amp; operator-=(unsigned long long rhs);
        // Subtract the specified &#39;rhs&#39; from the value of this object as
        // described by IEEE-754, store the result in this object, and return a
        // reference to this object.
        //
        //: o If this object is NaN, raise the &quot;invalid&quot; floating-point
        //:   exception and do not change this object.
        //:
        //: o Otherwise if this object is infinity, then do not change it.
        //:
        //: o Otherwise if subtracting &#39;rhs&#39; from this object&#39;s value results
        //:   in an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the
        //:   &quot;overflow&quot; floating-point exception and set this object to
        //:   infinity with the same sign as that result.
        //:
        //: o Otherwise set this object to the result of subtracting &#39;rhs&#39; from
        //:   the value of this object.
        //
        // Note that this is a floating-point value so this operations may not
        // change the value of this object at all (if the value is large) or it
        // may seem to update it to the value of the &#39;other&#39; (if the original
        // value is small).

    Decimal_Type128&amp; operator*=(Decimal32  rhs);
    Decimal_Type128&amp; operator*=(Decimal64  rhs);
    Decimal_Type128&amp; operator*=(Decimal128 rhs);
        // Multiply the value of the specified &#39;rhs&#39; object by the value of
        // this as described by IEEE-754, store the result in this object, and
        // return a reference to this object.
        //
        //: o If either this object or &#39;rhs&#39; is NaN, raise the &quot;invalid&quot;
        //:   floating-point exception and set this object to NaN.
        //:
        //: o Otherwise, if one of this object and &#39;rhs&#39; is zero (positive or
        //:   negative) and the other is infinity (positive or negative), raise
        //:   the &quot;invalid&quot; floating-point exception and set this object to a
        //:   NaN.
        //:
        //: o Otherwise, if either this object or &#39;rhs&#39; is positive or negative
        //:   infinity, set this object to infinity.  The sign of this object
        //:   will be positive if this object and &#39;rhs&#39; had the same sign, and
        //:   negative otherwise.
        //:
        //: o Otherwise, if either this object or &#39;rhs&#39; is zero, set this
        //:   object to zero.  The sign of this object will be positive if this
        //:   object and &#39;rhs&#39; had the same sign, and negative otherwise.
        //:
        //: o Otherwise if the product of this object and &#39;rhs&#39; has an absolute
        //:   value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the
        //:   &quot;overflow&quot; floating-point exception and set this object to
        //:   infinity with the same sign of that result.
        //:
        //: o Otherwise if the product of this object and &#39;rhs&#39; has an absolute
        //:   value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and set this object to zero
        //:   value with the same sign as that result.
        //:
        //: o Otherwise set this object to the product of the value of &#39;rhs&#39;
        //:   and the value of this object.

    Decimal_Type128&amp; operator*=(int                rhs);
    Decimal_Type128&amp; operator*=(unsigned int       rhs);
    Decimal_Type128&amp; operator*=(long               rhs);
    Decimal_Type128&amp; operator*=(unsigned long      rhs);
    Decimal_Type128&amp; operator*=(long long          rhs);
    Decimal_Type128&amp; operator*=(unsigned long long rhs);
        // Multiply the specified &#39;rhs&#39; by the value of this object as
        // described by IEEE-754, store the result in this object, and return a
        // reference to this object.
        //
        //: o If this object is NaN, raise the &quot;invalid&quot; floating-point
        //:   exception and set this object to a NaN.
        //:
        //: o Otherwise if this object is infinity (positive or negative), and
        //:   &#39;rhs&#39; is zero, then raise the &quot;invalid&quot; floating-point exception
        //:   and set this object to a NaN.
        //:
        //: o Otherwise if this object is infinity (positive or negative), then
        //:   do not change it.
        //:
        //: o Otherwise if &#39;rhs&#39; is zero, then set this object to zero with the
        //:   same sign as its value had prior to this operation.
        //:
        //: o Otherwise if the product of &#39;rhs&#39; and the value of this object
        //:   results in an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the
        //:   &quot;overflow&quot; floating-point exception and set this object to
        //:   infinity with the same sign as that result.
        //:
        //: o Otherwise if the product of &#39;rhs&#39; and the value of this object
        //:   results in an absolute value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and set this object to zero
        //:   with the same sign as that result.
        //:
        //: o Otherwise set this object to the product of the value of this
        //:   object and the value &#39;rhs&#39;.

    Decimal_Type128&amp; operator/=(Decimal32  rhs);
    Decimal_Type128&amp; operator/=(Decimal64  rhs);
    Decimal_Type128&amp; operator/=(Decimal128 rhs);
        // Divide the value of this object by the value of the specified &#39;rhs&#39;
        // as described by IEEE-754, store the result in this object, and
        // return a reference to this object.
        //
        //: o If either this object or &#39;rhs&#39; is NaN, then raise the &quot;invalid&quot;
        //:   floating-point exception and set this object to a NaN.
        //:
        //: o Otherwise if this object and &#39;rhs&#39; are infinity (positive or
        //:   negative) or zero (positive or negative), then raise the
        //:   &quot;invalid&quot; floating-point exception and set this object to a NaN.
        //:
        //: o Otherwise if &#39;rhs&#39; has a positive zero value, then raise the
        //:   &quot;overflow&quot; floating-point exception and set this object to
        //:   infinity with the same sign as its original value.
        //:
        //: o Otherwise if &#39;rhs&#39; has a negative zero value, then raise the
        //:   &quot;overflow&quot; floating-point exception and set this object to
        //:   infinity with the opposite sign as its original value.
        //:
        //: o Otherwise if dividing the value of this object with the value of
        //:   &#39;rhs&#39; results in an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the
        //:   &quot;overflow&quot; floating-point exception and set this object to
        //:   infinity value with the same sign as that result.
        //:
        //: o Otherwise if dividing the value of this object with the value of
        //:   &#39;rhs&#39; results in an absolute value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and set this object to zero
        //:   with the same sign as that result.
        //:
        //: o Otherwise set this object to the result of dividing the value of
        //:   this object with the value of &#39;rhs&#39;.

    Decimal_Type128&amp; operator/=(int                rhs);
    Decimal_Type128&amp; operator/=(unsigned int       rhs);
    Decimal_Type128&amp; operator/=(long               rhs);
    Decimal_Type128&amp; operator/=(unsigned long      rhs);
    Decimal_Type128&amp; operator/=(long long          rhs);
    Decimal_Type128&amp; operator/=(unsigned long long rhs);
        // Divide the value of this object by the specified &#39;rhs&#39; as described
        // by IEEE-754, store the result in this object, and return a reference
        // to this object.
        //
        //: o If this object is NaN, raise the &quot;invalid&quot; floating-point
        //:   exception and set this object to a NaN.
        //:
        //: o Otherwise if this object is infinity (positive or negative), and
        //:   &#39;rhs&#39; is zero, raise the &quot;invalid&quot; floating-point exception and
        //:   set this object to a NaN.
        //:
        //: o Otherwise if this object is infinity (positive or negative), then
        //:   do not change it.
        //:
        //: o Otherwise if &#39;rhs&#39; is zero, raise the &quot;overflow&quot; floating-point
        //:   exception and then set this object to infinity with the same sign
        //:   it had prior to this operation.
        //:
        //: o Otherwise if the quotient of the value of this object and &#39;rhs&#39;
        //:   results in an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the
        //:   &quot;overflow&quot; floating-point exception and set this object to
        //:   infinity with the same sign as that result.
        //:
        //: o Otherwise if the quotient of the value of this object and &#39;rhs&#39;
        //:   results in an absolute value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and set this object to zero
        //:   with the same sign as that result.
        //:
        //: o Otherwise set this object to the result of dividing the number
        //:   represented by this object by &#39;rhs&#39;.

    DecimalImpUtil::ValueType128 *data();
        // Return a modifiable pointer to the underlying implementation.

    // ACCESSORS
    const DecimalImpUtil::ValueType128 *data() const;
        // Return a non-modifiable pointer to the underlying implementation.

    DecimalImpUtil::ValueType128 value() const;
        // Return the value of the underlying implementation.
};

// FREE OPERATORS
Decimal128 operator+(Decimal128 value);
    // Return a copy of the specified &#39;value&#39; if the value is not negative
    // zero, and return positive zero otherwise.

Decimal128 operator-(Decimal128 value);
    // Return the result of applying the unary - operator to the specified
    // &#39;value&#39; as described by IEEE-754.  Note that floating-point numbers have
    // signed zero, therefore this operation is not the same as &#39;0-value&#39;.

Decimal128 operator++(Decimal128&amp; value, int);
    // Apply the prefix ++ operator to the specified &#39;value&#39; and return its
    // original value.  Note that this is a floating-point value so this
    // operations may not change the value of this object at all (if the value
    // is large) or it may seem to just set it to 1.0 (if the original value is
    // small).

Decimal128 operator--(Decimal128&amp; value, int);
    // Apply the prefix -- operator to the specified &#39;value&#39; and return its
    // original value.  Note that this is a floating-point value so this
    // operations may not change the value of this object at all (if the value
    // is large) or it may seem to just set it to 1.0 (if the original value is
    // small).

Decimal128 operator+(Decimal128 lhs, Decimal128 rhs);
Decimal128 operator+(Decimal32  lhs, Decimal128 rhs);
Decimal128 operator+(Decimal128 lhs, Decimal32  rhs);
Decimal128 operator+(Decimal64  lhs, Decimal128 rhs);
Decimal128 operator+(Decimal128 lhs, Decimal64  rhs);
    // Add the value of the specified &#39;rhs&#39; to the value of the specified &#39;lhs&#39;
    // as described by IEEE-754 and return the result.
    //
    //: o If either of &#39;lhs&#39; or &#39;rhs&#39; is NaN, then raise the &quot;invalid&quot;
    //:   floating-point exception and return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; and &#39;rhs&#39; are infinities of differing signs, raise
    //:   the &quot;invalid&quot; floating-point exception and return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; and &#39;rhs&#39; are infinities of the same sign then
    //:   return infinity of that sign.
    //:
    //: o Otherwise if &#39;rhs&#39; is zero (positive or negative), return &#39;lhs&#39;.
    //:
    //: o Otherwise if the sum of &#39;lhs&#39; and &#39;rhs&#39; has an absolute value that is
    //:   larger than &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the
    //:   &quot;overflow&quot; floating-point exception and return infinity with the same
    //:   sign as that result.
    //:
    //: o Otherwise return the sum of the number represented by &#39;lhs&#39; and the
    //:   number represented by &#39;rhs&#39;.

Decimal128 operator+(Decimal128 lhs, int                rhs);
Decimal128 operator+(Decimal128 lhs, unsigned int       rhs);
Decimal128 operator+(Decimal128 lhs, long               rhs);
Decimal128 operator+(Decimal128 lhs, unsigned long      rhs);
Decimal128 operator+(Decimal128 lhs, long long          rhs);
Decimal128 operator+(Decimal128 lhs, unsigned long long rhs);
    // Add the specified &#39;rhs&#39; to the value of the specified &#39;lhs&#39; as described
    // by IEEE-754 and return the result.
    //
    //: o If &#39;lhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception and
    //:   return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; is infinity, then return that infinity.
    //:
    //: o Otherwise if the sum of &#39;lhs&#39; and &#39;rhs&#39; has an absolute value that is
    //:   larger than &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the
    //:   &quot;overflow&quot; floating-point exception and return infinity with the same
    //:   sign as that result.
    //:
    //: o Otherwise return the sum of &#39;rhs&#39; and the number represented by
    //:   &#39;lhs&#39;.

Decimal128 operator+(int                lhs, Decimal128 rhs);
Decimal128 operator+(unsigned int       lhs, Decimal128 rhs);
Decimal128 operator+(long               lhs, Decimal128 rhs);
Decimal128 operator+(unsigned long      lhs, Decimal128 rhs);
Decimal128 operator+(long long          lhs, Decimal128 rhs);
Decimal128 operator+(unsigned long long lhs, Decimal128 rhs);
    // Add the specified &#39;lhs&#39; to the value of the specified &#39;rhs&#39; as described
    // by IEEE-754 and return the result.
    //
    //: o If &#39;rhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception and
    //:   return a NaN.
    //:
    //: o Otherwise if &#39;rhs&#39; is infinity, then return that infinity.
    //:
    //: o Otherwise if the sum of the value of &#39;rhs&#39; and &#39;lhs&#39; has an absolute
    //:   value that is larger than &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39;
    //:   then raise the &quot;overflow&quot; floating-point exception and return
    //:   infinity with the same sign as that result.
    //:
    //: o Otherwise return the sum of &#39;lhs&#39; and the number represented by
    //:   &#39;rhs&#39;.

Decimal128 operator-(Decimal128 lhs, Decimal128 rhs);
Decimal128 operator-(Decimal32  lhs, Decimal128 rhs);
Decimal128 operator-(Decimal128 lhs, Decimal32  rhs);
Decimal128 operator-(Decimal64  lhs, Decimal128 rhs);
Decimal128 operator-(Decimal128 lhs, Decimal64  rhs);
    // Subtract the value of the specified &#39;rhs&#39; from the value of the
    // specified &#39;lhs&#39; as described by IEEE-754 and return the result.
    //
    //: o If either &#39;lhs&#39; or &#39;rhs&#39; is NaN, then raise the &quot;invalid&quot;
    //:   floating-point exception and return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; and the &#39;rhs&#39; have infinity values of the same
    //:   sign, then raise the &quot;invalid&quot; floating-point exception and return a
    //:   NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; and the &#39;rhs&#39; have infinity values of differing
    //:   signs, then return &#39;lhs&#39;.
    //:
    //: o Otherwise if &#39;rhs&#39; has a zero value (positive or negative), then
    //:   return &#39;lhs&#39;.
    //:
    //: o Otherwise if subtracting the value of the &#39;rhs&#39; object from the value
    //:   of &#39;lhs&#39; results in an absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise return the result of subtracting the value of &#39;rhs&#39; from
    //:   the value of &#39;lhs&#39;.

Decimal128 operator-(Decimal128 lhs, int                rhs);
Decimal128 operator-(Decimal128 lhs, unsigned int       rhs);
Decimal128 operator-(Decimal128 lhs, long               rhs);
Decimal128 operator-(Decimal128 lhs, unsigned long      rhs);
Decimal128 operator-(Decimal128 lhs, long long          rhs);
Decimal128 operator-(Decimal128 lhs, unsigned long long rhs);
    // Subtract the specified &#39;rhs&#39; from the value of the specified &#39;lhs&#39; as
    // described by IEEE-754 and return a reference to this object.
    //
    //: o If &#39;lhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception and
    //:   return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; is infinity, then return &#39;lhs&#39;.
    //:
    //: o Otherwise if subtracting &#39;rhs&#39; from the value of &#39;lhs&#39; results in an
    //:   absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise return the result of subtracting &#39;rhs&#39; from the value of
    //:   &#39;lhs&#39;.

Decimal128 operator-(int                lhs, Decimal128 rhs);
Decimal128 operator-(unsigned int       lhs, Decimal128 rhs);
Decimal128 operator-(long               lhs, Decimal128 rhs);
Decimal128 operator-(unsigned long      lhs, Decimal128 rhs);
Decimal128 operator-(long long          lhs, Decimal128 rhs);
Decimal128 operator-(unsigned long long lhs, Decimal128 rhs);
    // Subtract the specified &#39;rhs&#39; from the value of the specified &#39;lhs&#39; as
    // described by IEEE-754 and return a reference to this object.
    //
    //: o If &#39;lhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception return
    //:   a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; is infinity, then return &#39;lhs&#39;.
    //:
    //: o Otherwise if &#39;rhs&#39; is zero (positive or negative), then return &#39;lhs&#39;.
    //:
    //: o Otherwise if subtracting &#39;rhs&#39; from the value of &#39;lhs&#39; results in an
    //:   absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise return the result of subtracting the value of &#39;rhs&#39;
    // from the number &#39;lhs&#39;.

Decimal128 operator*(Decimal128 lhs, Decimal128 rhs);
Decimal128 operator*(Decimal32  lhs, Decimal128 rhs);
Decimal128 operator*(Decimal128 lhs, Decimal32  rhs);
Decimal128 operator*(Decimal64  lhs, Decimal128 rhs);
Decimal128 operator*(Decimal128 lhs, Decimal64  rhs);
    // Multiply the value of the specified &#39;lhs&#39; object by the value of the
    // specified &#39;rhs&#39; as described by IEEE-754 and return the result.
    //
    //: o If either of &#39;lhs&#39; or &#39;rhs&#39; is NaN, return a NaN.
    //:
    //: o Otherwise if one of the operands is infinity (positive or negative)
    //:   and the other is zero (positive or negative), then raise the
    //:   &quot;invalid&quot; floating-point exception raised and return a NaN.
    //:
    //: o Otherwise if both &#39;lhs&#39; and &#39;rhs&#39; are infinity (positive or
    //:   negative), return infinity.  The sign of the returned value will be
    //:   positive if &#39;lhs&#39; and &#39;rhs&#39; have the same sign, and negative
    //:   otherwise.
    //:
    //: o Otherwise, if either &#39;lhs&#39; or &#39;rhs&#39; is zero, return zero.  The sign
    //:   of the returned value will be positive if &#39;lhs&#39; and &#39;rhs&#39; have the
    //:   same sign, and negative otherwise.
    //:
    //: o Otherwise if the product of &#39;lhs&#39; and &#39;rhs&#39; has an absolute value
    //:   that is larger than &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then
    //:   raise the &quot;overflow&quot; floating-point exception and return infinity
    //:   with the same sign as that result.
    //:
    //: o Otherwise if the product of &#39;lhs&#39; and &#39;rhs&#39; has an absolute value
    //:   that is smaller than &#39;std::numeric_limits&lt;Decimal128&gt;::min()&#39; then
    //:   raise the &quot;underflow&quot; floating-point exception and return zero with
    //:   the same sign as that result.
    //:
    //: o Otherwise return the product of the value of &#39;rhs&#39; and the number
    //:   represented by &#39;rhs&#39;.

Decimal128 operator*(Decimal128 lhs, int                rhs);
Decimal128 operator*(Decimal128 lhs, unsigned int       rhs);
Decimal128 operator*(Decimal128 lhs, long               rhs);
Decimal128 operator*(Decimal128 lhs, unsigned long      rhs);
Decimal128 operator*(Decimal128 lhs, long long          rhs);
Decimal128 operator*(Decimal128 lhs, unsigned long long rhs);
    // Multiply the specified &#39;rhs&#39; by the value of the specified &#39;lhs&#39; as
    // described by IEEE-754, and return the result.
    //
    //: o If &#39;lhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception and
    //:   return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; is infinity (positive or negative), and &#39;rhs&#39; is
    //:   zero, then raise the &quot;invalid&quot; floating-point exception and return a
    //:   NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; is infinity (positive or negative), then return
    //:   &#39;lhs&#39;.
    //:
    //: o Otherwise if &#39;rhs&#39; is zero, then return zero with the sign of &#39;lhs&#39;.
    //:
    //: o Otherwise if the product of &#39;rhs&#39; and the value of &#39;lhs&#39; has an
    //:   absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise if the product of &#39;rhs&#39; and the value of &#39;lhs&#39; has an
    //:   absolute value that is smaller than
    //:   &#39;std::numeric_limits&lt;Decimal128&gt;::min()&#39; then raise the &quot;underflow&quot;
    //:   floating-point exception and return zero with the same sign as that
    //:   result.
    //:
    //: o Otherwise return the product of the value of &#39;lhs&#39; and value &#39;rhs&#39;.

Decimal128 operator*(int                lhs, Decimal128 rhs);
Decimal128 operator*(unsigned int       lhs, Decimal128 rhs);
Decimal128 operator*(long               lhs, Decimal128 rhs);
Decimal128 operator*(unsigned long      lhs, Decimal128 rhs);
Decimal128 operator*(long long          lhs, Decimal128 rhs);
Decimal128 operator*(unsigned long long lhs, Decimal128 rhs);
    // Multiply the specified &#39;lhs&#39; by the value of the specified &#39;rhs&#39; as
    // described by IEEE-754, and return the result.
    //
    //: o If &#39;rhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception and
    //:   return a NaN.
    //:
    //: o Otherwise if &#39;rhs&#39; is infinity (positive or negative), and &#39;lhs&#39; is
    //:   zero, then raise the &quot;invalid&quot; floating-point exception and return a
    //:   NaN.
    //:
    //: o Otherwise if &#39;rhs&#39; is infinity (positive or negative), then return
    //:   &#39;rhs&#39;.
    //:
    //: o Otherwise if &#39;lhs&#39; is zero, then return zero with the sign of &#39;rhs&#39;.
    //:
    //: o Otherwise if the product of &#39;lhs&#39; and the value of &#39;rhs&#39; has an
    //:   absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise if the product of &#39;lhs&#39; and the value of &#39;rhs&#39; has an
    //:   absolute value that is smaller than
    //:   &#39;std::numeric_limits&lt;Decimal128&gt;::min()&#39; then raise the &quot;underflow&quot;
    //:   floating-point exception and return zero with the same sign as that
    //:   result.
    //:
    //: o Otherwise return the product of the value of &#39;rhs&#39; and value &#39;lhs&#39;.

Decimal128 operator/(Decimal128 lhs, Decimal128 rhs);
Decimal128 operator/(Decimal32  lhs, Decimal128 rhs);
Decimal128 operator/(Decimal128 lhs, Decimal32  rhs);
Decimal128 operator/(Decimal64  lhs, Decimal128 rhs);
Decimal128 operator/(Decimal128 lhs, Decimal64  rhs);
    // Divide the value of the specified &#39;lhs&#39; by the value of the specified
    // &#39;rhs&#39; as described by IEEE-754, and return the result.
    //
    //: o If &#39;lhs&#39; or &#39;rhs&#39; is NaN, raise the &quot;invalid&quot; floating-point
    //:   exception and return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; and &#39;rhs&#39; are both infinity (positive or negative)
    //:   or both zero (positive or negative), raise the &quot;invalid&quot;
    //:   floating-point exception and return a NaN.
    //:
    //: o Otherwise if &#39;rhs&#39; has a positive zero value, raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the sign of &#39;lhs&#39;.
    //:
    //: o Otherwise if &#39;rhs&#39; has a negative zero value, raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the opposite sign
    //:   as &#39;lhs&#39;.
    //:
    //: o Otherwise if dividing the value of &#39;lhs&#39; with the value of &#39;rhs&#39;
    //:   results in an absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise if dividing the value of &#39;lhs&#39; with the value of &#39;rhs&#39;
    //:   results in an absolute value that is smaller than
    //:   &#39;std::numeric_limits&lt;Decimal128&gt;::min()&#39; then raise the &quot;underflow&quot;
    //:   floating-point exception and return zero with the same sign as that
    //:   result.
    //:
    //: o Otherwise return the result of dividing the value of &#39;lhs&#39; with the
    //:   value of &#39;rhs&#39;.

Decimal128 operator/(Decimal128 lhs, int                rhs);
Decimal128 operator/(Decimal128 lhs, unsigned int       rhs);
Decimal128 operator/(Decimal128 lhs, long               rhs);
Decimal128 operator/(Decimal128 lhs, unsigned long      rhs);
Decimal128 operator/(Decimal128 lhs, long long          rhs);
Decimal128 operator/(Decimal128 lhs, unsigned long long rhs);
    // Divide the value of the specified &#39;lhs&#39; by the specified &#39;rhs&#39; as
    // described by IEEE-754, and return the result.
    //
    //: o If &#39;lhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception and
    //:   return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; is infinity (positive or negative), and &#39;rhs&#39; is
    //:   zero, raise the &quot;invalid&quot; floating-point exception and return a NaN.
    //:
    //: o Otherwise if &#39;lhs&#39; is infinity (positive or negative), then return
    //:   &#39;lhs&#39;.
    //:
    //: o Otherwise if &#39;rhs&#39; is zero, raise the &quot;overflow&quot; floating-point
    //:   exception return zero with the sign of &#39;lhs&#39;.
    //:
    //: o Otherwise if the quotient of the value of &#39;lhs&#39; and &#39;rhs&#39; results in
    //:   an absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise if the quotient of the value of &#39;lhs&#39; and &#39;rhs&#39; results in
    //:   an absolute value that is smaller than
    //:   &#39;std::numeric_limits&lt;Decimal128&gt;::min()&#39; then raise the &quot;underflow&quot;
    //:   floating-point exception and return zero with the same sign as that
    //:   result.
    //:
    //: o Otherwise return the result of dividing the value of &#39;lhs&#39; by the
    //:   value &#39;rhs&#39;.

Decimal128 operator/(int                lhs, Decimal128 rhs);
Decimal128 operator/(unsigned int       lhs, Decimal128 rhs);
Decimal128 operator/(long               lhs, Decimal128 rhs);
Decimal128 operator/(unsigned long      lhs, Decimal128 rhs);
Decimal128 operator/(long long          lhs, Decimal128 rhs);
Decimal128 operator/(unsigned long long lhs, Decimal128 rhs);
    // Divide the specified &#39;lhs&#39; by the value of the specified &#39;rhs&#39; as
    // described by IEEE-754, and return the result.
    //
    //: o If &#39;rhs&#39; is NaN, raise the &quot;invalid&quot; floating-point exception and
    //:   return a NaN.
    //:
    //: o Otherwise if &#39;rhs&#39; is infinity (positive or negative), and &#39;lhs&#39; is
    //:   zero, raise the &quot;invalid&quot; floating-point exception and return a NaN.
    //:
    //: o Otherwise if &#39;rhs&#39; is zero (positive or negative), raise the
    //:   &quot;overflow&quot; floating-point exception return zero with the sign of
    //:   &#39;lhs&#39;.
    //:
    //: o Otherwise if the quotient of &#39;rhs&#39; and the value of &#39;rhs&#39; results in
    //:   an absolute value that is larger than
    //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the &quot;overflow&quot;
    //:   floating-point exception and return infinity with the same sign as
    //:   that result.
    //:
    //: o Otherwise if the quotient of &#39;lhs&#39; and the value of &#39;rhs&#39; results in
    //:   an absolute value that is smaller than
    //:   &#39;std::numeric_limits&lt;Decimal128&gt;::min()&#39; then raise the &quot;underflow&quot;
    //:   floating-point exception and return zero with the same sign as that
    //:   result.
    //:
    //: o Otherwise return the result of dividing the value &#39;lhs&#39; by the value
    //:   of &#39;rhs&#39;.  Note that this is a floating-point operation, not integer.

bool operator==(Decimal128 lhs, Decimal128 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; have the same value, and
    // &#39;false&#39; otherwise.  Two &#39;Decimal128&#39; objects have the same value if the
    // &#39;compareQuietEqual&#39; operation (IEEE-754 defined, non-total ordering
    // comparison) considers the underlying IEEE representations equal.  In
    // other words, two &#39;Decimal128&#39; objects have the same value if:
    //
    //: o both have a zero value (positive or negative), or
    //: o both have the same infinity value (both positive or negative), or
    //: o both have the value of a real number that are equal, even if they are
    //:   represented differently (cohorts have the same value)
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.
    //
    // Note that a NaN is never equal to anything, including itself:
    //..
    //  Decimal128 aNaN = std::numeric_limits&lt;Decimal128&gt;::quiet_NaN();
    //  assert(!(aNan == aNan));
    //..

bool operator==(Decimal32  lhs, Decimal128 rhs);
bool operator==(Decimal128 lhs, Decimal32  rhs);
bool operator==(Decimal64  lhs, Decimal128 rhs);
bool operator==(Decimal128 lhs, Decimal64  rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; have the same value, and
    // &#39;false&#39; otherwise.  Two decimal objects have the same value if the
    // &#39;compareQuietEqual&#39; operation (IEEE-754 defined, non-total ordering
    // comparison) considers the underlying IEEE representations equal.  In
    // other words, two decimal objects have the same value if:
    //
    //: o both have a zero value (positive or negative), or
    //: o both have the same infinity value (both positive or negative), or
    //: o both have the value of a real number that are equal, even if they are
    //:   represented differently (cohorts have the same value)
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator!=(Decimal128 lhs, Decimal128 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; do not have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;Decimal128&#39; objects do not have the
    // same value if the &#39;compareQuietEqual&#39; operation (IEEE-754 defined,
    // non-total ordering comparison) considers the underlying IEEE
    // representations not equal.  In other words, two &#39;Decimal128&#39; objects do
    // not have the same value if:
    //
    //: o both are a NaN, or
    //: o one has zero value (positive or negative) and the other does not, or
    //: o one has the value of positive infinity and the other does not, or
    //: o one has the value of negative infinity and the other does not, or
    //: o both have the value of a real number that are not equal, regardless
    //:   of their representation (cohorts are equal)
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.
    //
    // Note that a NaN is never equal to anything, including itself:
    //..
    //  Decimal128 aNaN = std::numeric_limits&lt;Decimal128&gt;::quiet_NaN();
    //  assert(aNan != aNan);
    //..

bool operator!=(Decimal32  lhs, Decimal128 rhs);
bool operator!=(Decimal128 lhs, Decimal32  rhs);
bool operator!=(Decimal64  lhs, Decimal128 rhs);
bool operator!=(Decimal128 lhs, Decimal64  rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; do not have the same
    // value, and &#39;false&#39; otherwise.  Two decimal objects do not have the same
    // value if the &#39;compareQuietEqual&#39; operation (IEEE-754 defined, non-total
    // ordering comparison) considers the underlying IEEE representations not
    // equal.  In other words, two decimal objects do not have the same value
    // if:
    //
    //: o both are NaN, or
    //: o one has zero value (positive or negative) and the other does not, or
    //: o one has the value of positive infinity and the other does not, or
    //: o one has the value of negative infinity and the other does not, or
    //: o both have the value of a real number that are not equal, regardless
    //:   of their representation (cohorts are equal)
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&lt;(Decimal128 lhs, Decimal128 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value less than the specified
    // &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a &#39;Decimal128&#39; object &#39;lhs&#39;
    // is less than that of an object &#39;rhs&#39; if the &#39;compareQuietLess&#39; operation
    // (IEEE-754 defined, non-total ordering comparison) considers the
    // underlying IEEE representation of &#39;lhs&#39; to be less than of that of
    // &#39;rhs&#39;.  In other words, &#39;lhs&#39; is less than &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; is zero (positive or negative) and &#39;rhs&#39; is positive, or
    //: o &#39;rhs&#39; is zero (positive or negative) and &#39;lhs&#39; negative, or
    //: o &#39;lhs&#39; is not positive infinity, or
    //: o &#39;lhs&#39; is negative infinity and &#39;rhs&#39; is not, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is less than that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&lt;(Decimal32  lhs, Decimal128 rhs);
bool operator&lt;(Decimal128 lhs, Decimal32  rhs);
bool operator&lt;(Decimal64  lhs, Decimal128 rhs);
bool operator&lt;(Decimal128 lhs, Decimal64  rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value less than the specified
    // &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a decimal object &#39;lhs&#39; is
    // less than that of an object &#39;rhs&#39; if the &#39;compareQuietLess&#39; operation
    // (IEEE-754 defined, non-total ordering comparison) considers the
    // underlying IEEE representation of &#39;lhs&#39; to be less than of that of
    // &#39;rhs&#39;.  In other words, &#39;lhs&#39; is less than &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; is zero (positive or negative) and &#39;rhs&#39; is positive, or
    //: o &#39;rhs&#39; is zero (positive or negative) and &#39;lhs&#39; negative, or
    //: o &#39;lhs&#39; is not positive infinity, or
    //: o &#39;lhs&#39; is negative infinity and &#39;rhs&#39; is not, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39;is less than that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&lt;=(Decimal128 lhs, Decimal128 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value less than or equal the
    // value of the specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a
    // &#39;Decimal128&#39; object &#39;lhs&#39; is less than or equal to the value of an
    // object &#39;rhs&#39; if the &#39;compareQuietLessEqual&#39; operation (IEEE-754 defined,
    // non-total ordering comparison) considers the underlying IEEE
    // representation of &#39;lhs&#39; to be less or equal to that of &#39;rhs&#39;.  In other
    // words, &#39;lhs&#39; is less or equal than &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; are both zero (positive or negative), or
    //: o both &#39;lhs&#39; and &#39;rhs&#39; are positive infinity, or
    //: o &#39;lhs&#39; is negative infinity, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is less or equal to that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&lt;=(Decimal32  lhs, Decimal128 rhs);
bool operator&lt;=(Decimal128 lhs, Decimal32  rhs);
bool operator&lt;=(Decimal64  lhs, Decimal128 rhs);
bool operator&lt;=(Decimal128 lhs, Decimal64  rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value less than or equal the
    // value of the specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a
    // decimal object &#39;lhs&#39; is less than or equal to the value of an object
    // &#39;rhs&#39; if the &#39;compareQuietLessEqual&#39; operation (IEEE-754 defined,
    // non-total ordering comparison) considers the underlying IEEE
    // representation of &#39;lhs&#39; to be less or equal to that of &#39;rhs&#39;.  In other
    // words, &#39;lhs&#39; is less or equal than &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; are both zero (positive or negative), or
    //: o both &#39;lhs&#39; and &#39;rhs&#39; are positive infinity, or
    //: o &#39;lhs&#39; is negative infinity, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is less or equal to that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&gt;(Decimal128 lhs, Decimal128 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a greater value than the
    // specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a &#39;Decimal128&#39;
    // object &#39;lhs&#39; is greater than that of an object &#39;rhs&#39; if the
    // &#39;compareQuietGreater&#39; operation (IEEE-754 defined, non-total ordering
    // comparison) considers the underlying IEEE representation of &#39;lhs&#39; to be
    // greater than of that of &#39;rhs&#39;.  In other words, &#39;lhs&#39; is greater than
    // &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;rhs&#39; is zero (positive or negative) and &#39;lhs&#39; positive, or
    //: o &#39;lhs&#39; is zero (positive or negative) and &#39;rhs&#39; negative, or
    //: o &#39;lhs&#39; is not negative infinity, or
    //: o &#39;lhs&#39; is positive infinity and &#39;rhs&#39; is not, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is greater than that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&gt;(Decimal32  lhs, Decimal128 rhs);
bool operator&gt;(Decimal128 lhs, Decimal32  rhs);
bool operator&gt;(Decimal64  lhs, Decimal128 rhs);
bool operator&gt;(Decimal128 lhs, Decimal64  rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a greater value than the
    // specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a decimal object
    // &#39;lhs&#39; is greater than that of an object &#39;rhs&#39; if the
    // &#39;compareQuietGreater&#39; operation (IEEE-754 defined, non-total ordering
    // comparison) considers the underlying IEEE representation of &#39;lhs&#39; to be
    // greater than of that of &#39;rhs&#39;.  In other words, &#39;lhs&#39; is greater than
    // &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;rhs&#39; is zero (positive or negative) and &#39;lhs&#39; positive, or
    //: o &#39;lhs&#39; is zero (positive or negative) and &#39;rhs&#39; negative, or
    //: o &#39;lhs&#39; is not negative infinity, or
    //: o &#39;lhs&#39; is positive infinity and &#39;rhs&#39; is not, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is greater than that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&gt;=(Decimal128 lhs, Decimal128 rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value greater than or equal
    // to the value of the specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of
    // a &#39;Decimal128&#39; object &#39;lhs&#39; is greater or equal to a &#39;Decimal128&#39; object
    // &#39;rhs&#39; if the &#39;compareQuietGreaterEqual&#39; operation (IEEE-754 defined,
    // non-total ordering comparison ) considers the underlying IEEE
    // representation of &#39;lhs&#39; to be greater or equal to that of &#39;rhs&#39;.  In
    // other words, &#39;lhs&#39; is greater than or equal to &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; are both zero (positive or negative), or
    //: o both &#39;lhs&#39; and &#39;rhs&#39; are negative infinity, or
    //: o &#39;lhs&#39; is positive infinity, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is greater or equal to that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

bool operator&gt;=(Decimal32  lhs, Decimal128 rhs);
bool operator&gt;=(Decimal128 lhs, Decimal32  rhs);
bool operator&gt;=(Decimal64  lhs, Decimal128 rhs);
bool operator&gt;=(Decimal128 lhs, Decimal64  rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value greater than or equal
    // to the value of the specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of
    // a decimal object &#39;lhs&#39; is greater or equal to a decimal object &#39;rhs&#39; if
    // the &#39;compareQuietGreaterEqual&#39; operation (IEEE-754 defined, non-total
    // ordering comparison ) considers the underlying IEEE representation of
    // &#39;lhs&#39; to be greater or equal to that of &#39;rhs&#39;.  In other words, &#39;lhs&#39; is
    // greater than or equal to &#39;rhs&#39; if:
    //
    //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; are both zero (positive or negative), or
    //: o both &#39;lhs&#39; and &#39;rhs&#39; are negative infinity, or
    //: o &#39;lhs&#39; is positive infinity, or
    //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number of
    //:   &#39;lhs&#39; is greater or equal to that of &#39;rhs&#39;
    //
    // This operation raises the &quot;invalid&quot; floating-point exception if either
    // or both operands are NaN.

template &lt;class CHARTYPE, class TRAITS&gt;
bsl::basic_istream&lt;CHARTYPE, TRAITS&gt;&amp;
operator&gt;&gt; (bsl::basic_istream&lt;CHARTYPE, TRAITS&gt;&amp; stream, Decimal128&amp; object);
    // Read, into the specified &#39;object&#39;, from the specified input &#39;stream&#39; an
    // IEEE 128 bit decimal floating-point value as described in the IEEE-754
    // 2008 standard (5.12 Details of conversions between floating point
    // numbers and external character sequences) and return a reference
    // providing modifiable access to &#39;stream&#39;.  If &#39;stream&#39; contains a Nan
    // value, it is unspecified if &#39;object&#39; will receive a quiet or signaling
    // &#39;Nan&#39;.  If &#39;stream&#39; is not valid on entry &#39;stream.good() == false&#39;, this
    // operation has no effect other than setting &#39;stream.fail()&#39; to &#39;true&#39;.
    // If eof (end-of-file) is found before any non-whitespace characters
    // &#39;stream.fail()&#39; is set to &#39;true&#39; and &#39;object&#39; remains unchanged.  If eof
    // is detected after some characters have been read (and successfully
    // interpreted as part of the textual representation of a floating-point
    // value as specified by IEEE-754) then &#39;stream.eof()&#39; is set to true.  If
    // the first non-whitespace character sequence is not a valid textual
    // representation of a floating-point value (e.g., 12e or e12 or 1*2) the
    // &#39;stream.fail()&#39; is set to true and &#39;object&#39; will remain unchanged.  If a
    // real number value is represented by the character sequence but it is a
    // large positive or negative value that cannot be stored into &#39;object&#39; the
    // &quot;overflow&quot; floating-point exception is raised and positive or negative
    // infinity is stored into &#39;object&#39;, respectively.  If a real number value
    // is represented by the character sequence but it is a small positive or
    // negative value that cannot be stored into &#39;object&#39; the &quot;underflow&quot;
    // floating-point exception is raised and positive or negative zero is
    // stored into &#39;object&#39;, respectively.  If a real number value is
    // represented by the character sequence but it cannot be stored exactly
    // into &#39;object&#39; the &quot;inexact&quot; floating-point exception is raised, the
    // value is rounded according to the current rounding direction (of the
    // environment) and then stored into &#39;object.&#39;
    //
    // NOTE: This method does not yet fully support iostream flags or the
    // decimal floating point exception context.

template &lt;class CHARTYPE, class TRAITS&gt;
bsl::basic_ostream&lt;CHARTYPE, TRAITS&gt;&amp;
operator&lt;&lt; (bsl::basic_ostream&lt;CHARTYPE, TRAITS&gt;&amp; stream, Decimal128 object);
    // Write the value of the specified &#39;object&#39; to the specified output
    // &#39;stream&#39; in a single line format as described in the IEEE-754 2008
    // standard (5.12 Details of conversions between floating point numbers and
    // external character sequences), and return a reference providing
    // modifiable access to &#39;stream&#39;.  If &#39;stream&#39; is not valid on entry, this
    // operation has no effect.
    //
    // NOTE: This method does not yet fully support iostream flags or the
    // decimal floating point exception context.


                        // MISCELLANEOUS RELATED TYPES

                          // ===================
                          // class DecimalNumGet
                          // ===================

template &lt;class CHARTYPE,
          class INPUTITERATOR = bsl::istreambuf_iterator&lt;CHARTYPE&gt; &gt;
class DecimalNumGet : public bsl::locale::facet {
    // A facet type (mechanism) used in reading decimal floating-point types.
    // Note that this type does not follow BDE conventions because its content
    // is dictated by the C++ standard and native standard library
    // implementations.  See ISO/IEC TR 24733 3.10.2 for details.

#ifdef BSLS_PLATFORM_CMP_SUN
  private:
    // ACCESSORS
    bsl::locale::id&amp; __get_id() const;
         // The function __get_id() is a pure virtual function in the Rogue
         // Wave implementation of locales.  It is in violation with the
         // standard.  We have to define it as a workaround.
#endif

  public:
    // -dk:TODO make private while making the output operator a friend

    // CLASS METHODS
    static const DecimalNumGet&lt;CHARTYPE, INPUTITERATOR&gt;&amp; object();
        // TBD

  public:
    // PUBLIC TYPES
    static bsl::locale::id id; // The locale identifier

    typedef CHARTYPE      char_type;
    typedef INPUTITERATOR iter_type;

    // CREATORS
    explicit DecimalNumGet(bsl::size_t refs = 0);
        // Constructs a &#39;DecimalNumGet&#39; object as if
        //..
        // explicit DecimalNumGet(bsl::size_t refs)
        //    : bsl::locale::facet(refs), baseloc(bsl::locale()) ...
        //..
        // and optionally specify a &#39;refs&#39;, which will default to 0.

    explicit DecimalNumGet(const bsl::locale&amp; b, bsl::size_t refs = 0);
        // Constructs a &#39;DecimalNumPut&#39; object, from the specified &#39;b&#39;, as if
        //..
        // explicit DecimalNumGet(bsl::size_t refs)
        //    : bsl::locale::facet(refs), baseloc(b) ...
        //..
        // and optionally specify a &#39;refs&#39;, which will default to 0.

    // ACCESSORS
    iter_type get(iter_type               begin,
                  iter_type               end,
                  bsl::ios_base&amp;          str,
                  bsl::ios_base::iostate&amp; err,
                  Decimal32&amp;              value) const;
    iter_type get(iter_type               begin,
                  iter_type               end,
                  bsl::ios_base&amp;          str,
                  bsl::ios_base::iostate&amp; err,
                  Decimal64&amp;              value) const;
    iter_type get(iter_type               begin,
                  iter_type               end,
                  bsl::ios_base&amp;          str,
                  bsl::ios_base::iostate&amp; err,
                  Decimal128&amp;             value) const;
        // Forward to, and return using the specified &#39;begin&#39;, &#39;end&#39;, &#39;str&#39;,
        // &#39;err&#39;, and &#39;value&#39;, the results of
        // &#39;this-&gt;do_get(begin, end, str, err, value)&#39;.

  protected:
    // CREATORS
    ~DecimalNumGet();
        // Destroy this object.  Note that the destructor is virtual.

    // ACCESSORS
    virtual iter_type do_get(iter_type               begin,
                             iter_type               end,
                             bsl::ios_base&amp;          str,
                             bsl::ios_base::iostate&amp; err,
                             Decimal32&amp;              value) const;
    virtual iter_type do_get(iter_type               begin,
                             iter_type               end,
                             bsl::ios_base&amp;          str,
                             bsl::ios_base::iostate&amp; err,
                             Decimal64&amp;              value) const;
    virtual iter_type do_get(iter_type               begin,
                             iter_type               end,
                             bsl::ios_base&amp;          str,
                             bsl::ios_base::iostate&amp; err,
                             Decimal128&amp;             value) const;
        // Interpret characters from the half-open iterator range denoted by
        // the specified &#39;begin&#39; and &#39;end&#39;, generate a decimal floating-point
        // number and store it into the specified &#39;value&#39;.  During conversion
        // the formatting flags of the specified &#39;str&#39; (&#39;str.flags()&#39;) are
        // obeyed; character classifications are determined by the &#39;bsl::ctype&#39;
        // while punctuation characters are determined by the &#39;bsl::numpunct&#39;
        // facet imbued to the &#39;str&#39; stream-base.  Use the specified &#39;err&#39; to
        // report back failure or EOF streams states.  For further, more
        // detailed information please consult the section
        // [lib.facet.num.get.virtuals] of the C++ Standard.  Note that for the
        // conversions to the &#39;Decimal32&#39;, 64 and 128 types the conversion
        // specifiers are %Hg, %Dg and %DDg, respectively.  Also note that
        // these (possibly overridden) &#39;do_get&#39; virtual function are used by
        // every formatted C++ stream input operator call (&#39;in &gt;&gt; aDecNumber&#39;).
};

                          // ===================
                          // class DecimalNumPut
                          // ===================

template &lt;class CHARTYPE,
          class OUTPUTITERATOR = bsl::ostreambuf_iterator&lt;CHARTYPE&gt; &gt;
class DecimalNumPut : public bsl::locale::facet {
    // A facet type (mechanism) used in writing decimal floating-point types.
    // Note that this type does not follow BDE conventions because its content
    // is dictated by the C++ standard and native standard library
    // implementations.  See ISO/IEC TR 24733 3.10.3 for details.

#ifdef BSLS_PLATFORM_CMP_SUN
  private:
    // ACCESSORS
    bsl::locale::id&amp; __get_id() const;
        // The function __get_id() is a pure virtual function in the Rogue Wave
        // implementation of locales.  It is in violation with the standard.
        // We have to define it as a workaround.
#endif

  public:
    // -dk:TODO make private while making the output operator a friend

    // CLASS METHODS
    static const DecimalNumPut&lt;CHARTYPE, OUTPUTITERATOR&gt;&amp; object();
        // TBD

  public:
    // PUBLIC TYPES
    static bsl::locale::id id; // The locale identifier

    typedef CHARTYPE       char_type;
    typedef OUTPUTITERATOR iter_type;

    // CREATORS
    explicit DecimalNumPut(bsl::size_t refs = 0);
        // Constructs a &#39;DecimalNumPut&#39; object as if
        //..
        // explicit DecimalNumPut(bsl::size_t refs)
        //    : bsl::locale::facet(refs), baseloc(bsl::locale()) ...
        //..
        // and optionally specify &#39;refs&#39;, which will default to 0.

    explicit DecimalNumPut(const bsl::locale &amp; b, bsl::size_t refs = 0);
        // Constructs a &#39;DecimalNumPut&#39; object, using the specified &#39;b&#39;, as if
        //..
        // explicit DecimalNumPut(bsl::size_t refs)
        //    : bsl::locale::facet(refs), baseloc(b) ...
        //..
        // and optionally specify &#39;refs&#39;, which will default to 0.

    // ACCESSORS
    iter_type put(iter_type      out,
                  bsl::ios_base&amp; str,
                  char_type      fill,
                  Decimal32      value) const;
    iter_type put(iter_type      out,
                  bsl::ios_base&amp; str,
                  char_type      fill,
                  Decimal64      value) const;
    iter_type put(iter_type      out,
                  bsl::ios_base&amp; str,
                  char_type      fill,
                  Decimal128     value) const;
        // Forward to, and return using the specified &#39;out&#39;, &#39;str&#39;, &#39;fill&#39;, and
        // &#39;value&#39;, the results of &#39;this-&gt;do_put(out, str, fill, value)&#39;.

  protected:
    // CREATORS
    ~DecimalNumPut();
        // Destroy this object.  Note that the destructor is virtual.

    // ACCESSORS
    virtual iter_type do_put(iter_type      out,
                             bsl::ios_base&amp; ios_format,
                             char_type      fill,
                             Decimal32      value) const;
    virtual iter_type do_put(iter_type      out,
                             bsl::ios_base&amp; ios_format,
                             char_type      fill,
                             Decimal64      value) const;
    virtual iter_type do_put(iter_type      out,
                             bsl::ios_base&amp; ios_format,
                             char_type      fill,
                             Decimal128     value) const;
        // Write characters (of &#39;char_type&#39;) that represent the specified
        // &#39;value&#39; to the output stream determined by the specified &#39;out&#39;
        // output iterator.  Use the &#39;bsl::ctype&#39; and the &#39;bsl::numpunct&#39;
        // facets imbued to the specified stream-base &#39;ios_format&#39; as well as
        // the formatting flags of the &#39;ios_format&#39; (&#39;bsl.flags()&#39;) to generate
        // the properly localized output.  The specified &#39;fill&#39; character will
        // be used as a placeholder character in padded output.  For further,
        // more detailed information please consult the section
        // [lib.facet.num.put.virtuals] of the C++ Standard noting that the
        // length modifiers &quot;H&quot;, &quot;D&quot; and &quot;DD&quot; are added to the conversion
        // specifiers of for the types Decimal32, 64 and 128, respectively.
        // Also note that these (possibly overridden) &#39;do_put&#39; virtual function
        // are used by every formatted C++ stream output operator call
        // (&#39;out &lt;&lt; aDecNumber&#39;).  Note that currently, only the width,
        // capitalization, and justification formatting flags are supported,
        // and the operators only support code pages that include the ASCII
        // sub-range.  Because of potential future improvements to support
        // additional formatting flags, the operations should not be used for
        // serialization.
};

                   // =====================================
                   // class Decimal_StandardNamespaceCanary
                   // =====================================

class Decimal_StandardNamespaceCanary {
    // An empty class used for error detection when looking for the original
    // name of the standard namespace.  Do not use it.
};

    // =================================================================
    // template&lt;...&gt; class faux_numeric_limits&lt;NUMERIC_TYPE, DUMMY_TYPE&gt;
    // =================================================================

template&lt;class NUMERIC_TYPE, class DUMMY_TYPE = void&gt;
class faux_numeric_limits;
    // This class is used as a base-class for manifest constants in the
    // &#39;std::numeric_limits&#39; specializations to overcome a Sun compiler issue.

      // ===============================================================
      // class faux_numeric_limits&lt;Decimal_StandardNamespaceCanary, ...&gt;
      // ===============================================================

template&lt;class DUMMY_TYPE&gt;
class faux_numeric_limits&lt;Decimal_StandardNamespaceCanary, DUMMY_TYPE&gt;
{
    // Explicit full specialization of the standard &quot;traits&quot; template
    // &#39;std::numeric_limits&#39; for the type
    // &#39;BloombergLP::bdldfp::Decimal_StandardNamespaceCanary&#39;.  Note that this
    // specialization is required for technical reasons and it is identical to
    // the non-specialized default traits.

  public:
    // CLASS DATA
    static const bool is_specialized = false;
        // &#39;BloombergLP::bdldfp::Decimal_StandardNamespaceCanary&#39; is not a
        // numeric type.
};

    // ==============================================================
    // template&lt;...&gt; class faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;
    // ==============================================================

template&lt;class DUMMY_TYPE&gt;
class faux_numeric_limits&lt;BloombergLP::bdldfp::Decimal32, DUMMY_TYPE&gt; {
        // Explicit full specialization of the standard &quot;traits&quot; template
        // &#39;std::numeric_limits&#39; for the type &#39;BloombergLP::bdldfp::Decimal32&#39;.

  public:
    // CLASS DATA
    static const bool is_specialized = true;
        // The template instance
        // &#39;std::numeric_limits&lt;BloombergLP::bdldfp::Decimal32&gt;&#39; is
        // meaningfully specialized.  Also means that
        // &#39;BloombergLP::bdldfp::Decimal32&#39; is a numeric type.

    static const int digits = 7;
        // The maximum number of significant digits, in the native (10) radix
        // of the &#39;BloombergLP::bdldfp::Decimal32&#39; type that the type is able
        // to represent.  Defined to be 7 by IEEE-754.

    static const int digits10 = digits;
        // The maximum number of significant decimal digits that the
        // &#39;BloombergLP::bdldfp::Decimal32&#39; type is able to represent.  Defined
        // to be 7 by IEEE-754.

    static const int max_digits10 = digits;
        // The number of significant decimal digits necessary to uniquely
        // represent the significant digits of any
        // &#39;BloombergLP::bdldfp::Decimal32&#39; value.  Note that max_digit10 is
        // the same as digits10 for decimal floating-point values.

    static const bool is_signed = true;
        // &#39;BloombergLP::bdldfp::Decimal32&#39; is a signed type.

    static const bool is_integer = false;
        // &#39;BloombergLP::bdldfp::Decimal32&#39; is not an integer type.

    static const bool is_exact = false;
        // &#39;BloombergLP::bdldfp::Decimal32&#39; is not an exact type, i.e.:
        // calculations done on the type are not free of rounding errors.  Note
        // that integer and possibly rational types may be exact,
        // floating-point types are never exact.

    static const int radix = 10;
        // The base for &#39;BloombergLP::bdldfp::Decimal32&#39; is decimal or 10.

    static const int min_exponent = -95;
        // The lowest possible negative exponent for the native base of the
        // &#39;BloombergLP::bdldfp::Decimal32&#39; type that does not yet represent a
        // denormal number.  Defined to be -94 by IEEE-754.

    static const int min_exponent10 = min_exponent;
        // The lowest possible negative decimal exponent in the
        // &#39;BloombergLP::bdldfp::Decimal32&#39; type that does not yet represent a
        // denormal number.  Defined to be -94 by IEEE-754.  Note that
        // &#39;min_exponent10&#39; is the same as &#39;min_exponent&#39; for decimal types.

    static const int max_exponent = 96;
        // The highest possible positive exponent for the native base of the
        // &#39;BloombergLP::bdldfp::Decimal32&#39; type that represents a finite
        // value.  Defined to be 97 by IEEE-754.

    static const int max_exponent10 = max_exponent;
        // The highest possible positive decimal exponent of the
        // &#39;BloombergLP::bdldfp::Decimal32&#39; type that represents a finite
        // value.  Defined to be 97 by IEEE-754.  Note that &#39;max_exponent10&#39; is
        // the same as &#39;max_exponent&#39; for decimal types.

    static const bool has_infinity = true;
        // &#39;BloombergLP::bdldfp::Decimal32&#39; can represent infinity.

    static const bool has_quiet_NaN = true;
        // &#39;BloombergLP::bdldfp::Decimal32&#39; can be a non-signaling Not a
        // Number.

    static const bool has_signaling_NaN = true;
        // &#39;BloombergLP::bdldfp::Decimal32&#39; can be a signaling Not a Number.

    static const std::float_denorm_style has_denorm = std::denorm_present;
        // &#39;BloombergLP::bdldfp::Decimal32&#39; may contain denormal values.

    static const bool has_denorm_loss = true;
        // &#39;BloombergLP::bdldfp::Decimal32&#39; is able to distinguish loss of
        // precision (floating-point underflow) due to denormalization from
        // other causes.

    static const bool is_bounded = true;
        // Decimal floating-point types represent a finite set of values.

    static const bool is_iec559 = false;
        // Decimal floating-point is not covered by the IEC 559 standard.

    static const bool is_modulo = false;
        // Decimal floating-point types do not have modulo representation.

    static const bool tinyness_before = true;
        // Decimal floating-point types are able to detect if a value is too
        // small to represent as a normalized value before rounding it.

    static const bool traps = true;
        // Decimal floating-point types implement traps to report arithmetic
        // exceptions (required by IEEE-754).

                        // Rounding style

    static const std::float_round_style round_style = std::round_indeterminate;
        // Decimal floating-point rounding style is defined to be indeterminate
        // by the C and C++ Decimal TRs.
};

    // ==============================================================
    // template&lt;...&gt; class faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;
    // ==============================================================

template&lt;class DUMMY_TYPE&gt;
class faux_numeric_limits&lt;BloombergLP::bdldfp::Decimal64, DUMMY_TYPE&gt; {
        // Explicit full specialization of the standard &quot;traits&quot; template
        // &#39;std::numeric_limits&#39; for the type &#39;BloombergLP::bdldfp::Decimal64&#39;.

  public:
    // CLASS DATA
    static const bool is_specialized = true;
        // The template instance
        // &#39;std::numeric_limits&lt;BloombergLP::bdldfp::Decimal64&gt;&#39; is
        // meaningfully specialized.  Also means that
        // &#39;BloombergLP::bdldfp::Decimal64&#39; is a numeric type.

    static const int digits = 16;
        // The maximum number of significant digits, in the native (10) radix
        // of the &#39;BloombergLP::bdldfp::Decimal64&#39; type that the type is able
        // to represent.  Defined to be 16 by IEEE-754.

    static const int digits10 = digits;
        // The maximum number of significant decimal digits that the
        // &#39;BloombergLP::bdldfp::Decimal64&#39; type is able to represent.  Defined
        // to be 16 by IEEE-754.

    static const int max_digits10 = digits;
        // The number of significant decimal digits necessary to uniquely
        // represent the significant digits of any
        // &#39;BloombergLP::bdldfp::Decimal64&#39; value.  Note that max_digit10 is
        // the same as digits10 for decimal floating-point values.

    static const bool is_signed = true;
        // &#39;BloombergLP::bdldfp::Decimal64&#39; is a signed type.

    static const bool is_integer = false;
        // &#39;BloombergLP::bdldfp::Decimal64&#39; is not an integer type.

    static const bool is_exact = false;
        // &#39;BloombergLP::bdldfp::Decimal64&#39; is not an exact type, i.e.:
        // calculations done on the type are not free of rounding errors.  Note
        // that integer and possibly rational types may be exact,
        // floating-point types are never exact.

    static const int radix = 10;
        // The base for &#39;BloombergLP::bdldfp::Decimal64&#39; is decimal or 10.

    static const int min_exponent = -382;
        // The lowest possible negative exponent for the native base of the
        // &#39;BloombergLP::bdldfp::Decimal64&#39; type that does not yet represent a
        // denormal number.  Defined to be -382 by IEEE-754.

    static const int min_exponent10 = min_exponent;
        // The lowest possible negative decimal exponent in the
        // &#39;BloombergLP::bdldfp::Decimal64&#39; type that does not yet represent a
        // denormal number.  Defined to be -382 by IEEE-754.  Note that
        // &#39;min_exponent10&#39; is the same as &#39;min_exponent&#39; for decimal types.

    static const int max_exponent = 385;
        // The highest possible positive exponent for the native base of the
        // &#39;BloombergLP::bdldfp::Decimal64&#39; type that represents a finite
        // value.  Defined to be 385 by IEEE-754.

    static const int max_exponent10 = max_exponent;
        // The highest possible positive decimal exponent of the
        // &#39;BloombergLP::bdldfp::Decimal64&#39; type that represents a finite
        // value.  Defined to be 385 by IEEE-754.  Note that &#39;max_exponent10&#39;
        // is the same as &#39;max_exponent&#39; for decimal types.

    static const bool has_infinity = true;
        // &#39;BloombergLP::bdldfp::Decimal64&#39; can represent infinity.

    static const bool has_quiet_NaN = true;
        // &#39;BloombergLP::bdldfp::Decimal64&#39; can be a non-signaling Not a
        // Number.

    static const bool has_signaling_NaN = true;
        // &#39;BloombergLP::bdldfp::Decimal64&#39; can be a signaling Not a Number.

    static const std::float_denorm_style has_denorm = std::denorm_present;
        // &#39;BloombergLP::bdldfp::Decimal64&#39; may contain denormal values.

    static const bool has_denorm_loss = true;
        // &#39;BloombergLP::bdldfp::Decimal64&#39; is able to distinguish loss of
        // precision (floating-point underflow) due to denormalization from
        // other causes.

    static const bool is_iec559 = false;
        // Decimal floating-point is not covered by the IEC 559 standard.

    static const bool is_bounded = true;
        // Decimal floating-point types represent a finite set of values.

    static const bool is_modulo = false;
        // Decimal floating-point types do not have modulo representation.

    static const bool traps = true;
        // Decimal floating-point types implement traps to report arithmetic
        // exceptions (required by IEEE-754).

    static const bool tinyness_before = true;
        // Decimal floating-point types are able to detect if a value is too
        // small to represent as a normalized value before rounding it.

    static const std::float_round_style round_style = std::round_indeterminate;
        // Decimal floating-point rounding style is defined to be indeterminate
        // by the C and C++ Decimal TRs.
};

    // ===============================================================
    // template&lt;...&gt; class faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;
    // ===============================================================

template&lt;class DUMMY_TYPE&gt;
class faux_numeric_limits&lt;BloombergLP::bdldfp::Decimal128, DUMMY_TYPE&gt; {
        // Explicit full specialization of the standard &quot;traits&quot; template
        // &#39;std::numeric_limits&#39; for the type
        // &#39;BloombergLP::bdldfp::Decimal128&#39;.

  public:
    // CLASS DATA
    static const bool is_specialized = true;
        // The template instance
        // &#39;std::numeric_limits&lt;BloombergLP::bdldfp::Decimal128&gt;&#39; is
        // meaningfully specialized.  Also means that
        // &#39;BloombergLP::bdldfp::Decimal128&#39; is a numeric type.

    static const int digits = 34;
        // The maximum number of significant digits, in the native (10) radix
        // of the &#39;BloombergLP::bdldfp::Decimal128&#39; type that the type is able
        // to represent.  Defined to be 34 by IEEE-754.

    static const int digits10 = digits;
        // The maximum number of significant decimal digits that the
        // &#39;BloombergLP::bdldfp::Decimal128&#39; type is able to represent.
        // Defined to be 34 by IEEE-754.

    static const int max_digits10 = digits;
        // The number of significant decimal digits necessary to uniquely
        // represent the significant digits of any
        // &#39;BloombergLP::bdldfp::Decimal128&#39; value.  Note that max_digit10 is
        // the same as digits10 for decimal floating-point values.

    static const bool is_signed = true;
        // &#39;BloombergLP::bdldfp::Decimal128&#39; is a signed type.

    static const bool is_integer = false;
        // &#39;BloombergLP::bdldfp::Decimal128&#39; is not an integer type.

    static const bool is_exact = false;
        // &#39;BloombergLP::bdldfp::Decimal128&#39; is not an exact type, i.e.:
        // calculations done on the type are not free of rounding errors.  Note
        // that integer and possibly rational types may be exact,
        // floating-point types are never exact.

    static const int radix = 10;
        // The base for &#39;BloombergLP::bdldfp::Decimal128&#39; is decimal or 10.

    static const int min_exponent = -6142;
        // The lowest possible negative exponent for the native base of the
        // &#39;BloombergLP::bdldfp::Decimal128&#39; type that does not yet represent a
        // denormal number.  Defined to be -6142 by IEEE-754.

    static const int min_exponent10 = min_exponent;
        // The lowest possible negative decimal exponent in the
        // &#39;BloombergLP::bdldfp::Decimal128&#39; type that does not yet represent a
        // denormal number.  Defined to be -6142 by IEEE-754.  Note that
        // &#39;min_exponent10&#39; is the same as &#39;min_exponent&#39; for decimal types.

    static const int max_exponent = 6145;
        // The highest possible positive exponent for the native base of the
        // &#39;BloombergLP::bdldfp::Decimal128&#39; type that represents a finite
        // value.  Defined to be 385 by IEEE-754.

    static const int max_exponent10 = max_exponent;
        // The highest possible positive decimal exponent of the
        // &#39;BloombergLP::bdldfp::Decimal128&#39; type that represents a finite
        // value.  Defined to be 6145 by IEEE-754.  Note that &#39;max_exponent10&#39;
        // is the same as &#39;max_exponent&#39; for decimal types.

    static const bool has_infinity = true;
        // &#39;BloombergLP::bdldfp::Decimal128&#39; can represent infinity.

    static const bool has_quiet_NaN = true;
        // &#39;BloombergLP::bdldfp::Decimal128&#39; can be a non-signaling Not a
        // Number.

    static const bool has_signaling_NaN = true;
        // &#39;BloombergLP::bdldfp::Decimal128&#39; can be a signaling Not a Number.

    static const std::float_denorm_style has_denorm = std::denorm_present;
        // &#39;BloombergLP::bdldfp::Decimal128&#39; may contain denormal values.

    static const bool has_denorm_loss = true;
        // &#39;BloombergLP::bdldfp::Decimal128&#39; is able to distinguish loss of
        // precision (floating-point underflow) due to denormalization from
        // other causes.

    static const bool is_iec559 = false;
        // Decimal floating-point is not covered by the IEC 559 standard.

    static const bool is_bounded = true;
        // Decimal floating-point types represent a finite set of values.

    static const bool is_modulo = false;
        // Decimal floating-point types do not have modulo representation.

    static const bool traps = true;
        // Decimal floating-point types implement traps to report arithmetic
        // exceptions (required by IEEE-754).

    static const bool tinyness_before = true;
        // Decimal floating-point types are able to detect if a value is too
        // small to represent as a normalized value before rounding it.

    static const std::float_round_style round_style = std::round_indeterminate;
        // Decimal floating-point rounding style is defined to be indeterminate
        // by the C and C++ Decimal TRs.

};

             // --------------------------------------------------
             // faux_numeric_limits&lt;Decimal32, ...&gt; member storage
             // --------------------------------------------------

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::is_specialized;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::digits;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::digits10;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::max_digits10;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::is_signed;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::is_integer;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::is_exact;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::radix;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::min_exponent;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::min_exponent10;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::max_exponent;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::max_exponent10;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::has_infinity;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::has_quiet_NaN;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::has_signaling_NaN;

template&lt;class DUMMY_TYPE&gt;
const std::float_denorm_style
faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::has_denorm;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::has_denorm_loss;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::is_iec559;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::is_bounded;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::is_modulo;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::traps;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::tinyness_before;

template&lt;class DUMMY_TYPE&gt;
const std::float_round_style
faux_numeric_limits&lt;Decimal32, DUMMY_TYPE&gt;::round_style;

             // --------------------------------------------------
             // faux_numeric_limits&lt;Decimal64, ...&gt; member storage
             // --------------------------------------------------

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::is_specialized;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::digits;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::digits10;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::max_digits10;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::is_signed;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::is_integer;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::is_exact;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::radix;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::min_exponent;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::min_exponent10;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::max_exponent;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::max_exponent10;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::has_infinity;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::has_quiet_NaN;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::has_signaling_NaN;

template&lt;class DUMMY_TYPE&gt;
const std::float_denorm_style
faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::has_denorm;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::has_denorm_loss;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::is_iec559;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::is_bounded;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::is_modulo;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::traps;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::tinyness_before;

template&lt;class DUMMY_TYPE&gt;
const std::float_round_style
faux_numeric_limits&lt;Decimal64, DUMMY_TYPE&gt;::round_style;

            // ---------------------------------------------------
            // faux_numeric_limits&lt;Decimal128, ...&gt; member storage
            // ---------------------------------------------------

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::is_specialized;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::digits;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::digits10;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::max_digits10;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::is_signed;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::is_integer;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::is_exact;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::radix;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::min_exponent;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::min_exponent10;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::max_exponent;

template&lt;class DUMMY_TYPE&gt;
const int faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::max_exponent10;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::has_infinity;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::has_quiet_NaN;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::has_signaling_NaN;

template&lt;class DUMMY_TYPE&gt;
const std::float_denorm_style
faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::has_denorm;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::has_denorm_loss;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::is_iec559;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::is_bounded;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::is_modulo;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::traps;

template&lt;class DUMMY_TYPE&gt;
const bool faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::tinyness_before;

template&lt;class DUMMY_TYPE&gt;
const std::float_round_style
faux_numeric_limits&lt;Decimal128, DUMMY_TYPE&gt;::round_style;

}  // close package namespace
}  // close enterprise namespace

#if defined(BSL_OVERRIDES_STD) &amp;&amp; defined(std)
#   undef std
#   define BDLDFP_DECIMAL_RESTORE_STD
#endif
namespace std {

  // ========================================================================
  // template&lt;&gt; class numeric_limits&lt;bdldfp::Decimal_StandardNamespaceCanary&gt;
  // ========================================================================

template&lt;&gt;
class numeric_limits&lt;BloombergLP::bdldfp::Decimal_StandardNamespaceCanary&gt;
    : public BloombergLP::bdldfp::faux_numeric_limits&lt;
        BloombergLP::bdldfp::Decimal_StandardNamespaceCanary&gt; {
    // Explicit full specialization of the standard &quot;traits&quot; template
    // &#39;std::numeric_limits&#39; for the type
    // &#39;BloombergLP::bdldfp::Decimal_StandardNamespaceCanary&#39;.  Note that this
    // specialization is required for technical reasons and it is identical to
    // the non-specialized default traits.
};

             // ==================================================
             // template&lt;&gt; class numeric_limits&lt;bdldfp::Decimal32&gt;
             // ==================================================

template&lt;&gt;
class numeric_limits&lt;BloombergLP::bdldfp::Decimal32&gt;
    : public BloombergLP::bdldfp::faux_numeric_limits&lt;
        BloombergLP::bdldfp::Decimal32&gt; {
        // Explicit full specialization of the standard &quot;traits&quot; template
        // &#39;std::numeric_limits&#39; for the type &#39;BloombergLP::bdldfp::Decimal32&#39;.

  public:
    // CLASS METHODS
    static BloombergLP::bdldfp::Decimal32 min() BSLS_NOTHROW_SPEC;
        // Return the smallest positive (also non-zero) number
        // &#39;BloombergLP::bdldfp::Decimal32&#39; can represent (IEEE-754: +1e-95).

    static BloombergLP::bdldfp::Decimal32 max() BSLS_NOTHROW_SPEC;
        // Return the largest number &#39;BloombergLP::bdldfp::Decimal32&#39; can
        // represent (IEEE-754: +9.999999e+96).

    static BloombergLP::bdldfp::Decimal32 epsilon() BSLS_NOTHROW_SPEC;
        // Return the difference between 1 and the smallest value representable
        // by the &#39;BloombergLP::bdldfp::Decimal32&#39; type.  (IEEE-754: +1e-6)

    static BloombergLP::bdldfp::Decimal32 round_error() BSLS_NOTHROW_SPEC;
        // Return the maximum rounding error for the
        // &#39;BloombergLP::bdldfp::Decimal32&#39; type.  The actual value returned
        // depends on the current decimal floating point rounding setting.

    static BloombergLP::bdldfp::Decimal32 denorm_min() BSLS_NOTHROW_SPEC;
        // Return the smallest non-zero denormalized value for the
        // &#39;BloombergLP::bdldfp::Decimal32&#39; type.  (IEEE-754: +0.000001E-95)

    static BloombergLP::bdldfp::Decimal32 infinity() BSLS_NOTHROW_SPEC;
        // Return the the value that represents positive infinity for the
        // &#39;BloombergLP::bdldfp::Decimal32&#39; type.

    static BloombergLP::bdldfp::Decimal32 quiet_NaN() BSLS_NOTHROW_SPEC;
        // Return a value that represents non-signaling NaN for the
        // &#39;BloombergLP::bdldfp::Decimal32&#39; type.

    static BloombergLP::bdldfp::Decimal32 signaling_NaN() BSLS_NOTHROW_SPEC;
        // Return a value that represents signaling NaN for the
        // &#39;BloombergLP::bdldfp::Decimal32&#39; type.
};

             // ==================================================
             // template&lt;&gt; class numeric_limits&lt;bdldfp::Decimal64&gt;
             // ==================================================

template&lt;&gt;
class numeric_limits&lt;BloombergLP::bdldfp::Decimal64&gt;
    : public BloombergLP::bdldfp::faux_numeric_limits&lt;
        BloombergLP::bdldfp::Decimal64&gt; {
        // Explicit full specialization of the standard &quot;traits&quot; template
        // &#39;std::numeric_limits&#39; for the type &#39;BloombergLP::bdldfp::Decimal64&#39;.

  public:
    // CLASS METHODS
    static BloombergLP::bdldfp::Decimal64 min() BSLS_NOTHROW_SPEC;
        // Return the smallest positive (also non-zero) number
        // &#39;BloombergLP::bdldfp::Decimal64&#39; can represent (IEEE-754: +1e-383).

    static BloombergLP::bdldfp::Decimal64 max() BSLS_NOTHROW_SPEC;
        // Return the largest number &#39;BloombergLP::bdldfp::Decimal64&#39; can
        // represent (IEEE-754: +9.999999999999999e+384).

    static BloombergLP::bdldfp::Decimal64 epsilon() BSLS_NOTHROW_SPEC;
        // Return the difference between 1 and the smallest value representable
        // by the &#39;BloombergLP::bdldfp::Decimal64&#39; type.  (IEEE-754: +1e-15)

    static BloombergLP::bdldfp::Decimal64 round_error() BSLS_NOTHROW_SPEC;
        // Return the maximum rounding error for the
        // &#39;BloombergLP::bdldfp::Decimal64&#39; type.  The actual value returned
        // depends on the current decimal floating point rounding setting.

    static BloombergLP::bdldfp::Decimal64 denorm_min() BSLS_NOTHROW_SPEC;
        // Return the smallest non-zero denormalized value for the
        // &#39;BloombergLP::bdldfp::Decimal64&#39; type.  (IEEE-754:
        // +0.000000000000001e-383)

    static BloombergLP::bdldfp::Decimal64 infinity() BSLS_NOTHROW_SPEC;
        // Return the the value that represents positive infinity for the
        // &#39;BloombergLP::bdldfp::Decimal64&#39; type.

    static BloombergLP::bdldfp::Decimal64 quiet_NaN() BSLS_NOTHROW_SPEC;
        // Return a value that represents non-signaling NaN for the
        // &#39;BloombergLP::bdldfp::Decimal64&#39; type.

    static BloombergLP::bdldfp::Decimal64 signaling_NaN() BSLS_NOTHROW_SPEC;
        // Return a value that represents signaling NaN for the
        // &#39;BloombergLP::bdldfp::Decimal64&#39; type.

};

            // ===================================================
            // template&lt;&gt; class numeric_limits&lt;bdldfp::Decimal128&gt;
            // ===================================================

template&lt;&gt;
class numeric_limits&lt;BloombergLP::bdldfp::Decimal128&gt;
    : public BloombergLP::bdldfp::faux_numeric_limits&lt;
        BloombergLP::bdldfp::Decimal128&gt; {
        // Explicit full specialization of the standard &quot;traits&quot; template
        // &#39;std::numeric_limits&#39; for the type
        // &#39;BloombergLP::bdldfp::Decimal128&#39;.

  public:
    // CLASS METHODS
    static BloombergLP::bdldfp::Decimal128 min() BSLS_NOTHROW_SPEC;
        // Return the smallest positive (also non-zero) number
        // &#39;BloombergLP::bdldfp::Decimal128&#39; can represent (IEEE-754:
        // +1e-6143).

    static BloombergLP::bdldfp::Decimal128 max() BSLS_NOTHROW_SPEC;
        // Return the largest number &#39;BloombergLP::bdldfp::Decimal128&#39; can
        // represent (IEEE-754: +9.999999999999999999999999999999999e+6144).

    static BloombergLP::bdldfp::Decimal128 epsilon() BSLS_NOTHROW_SPEC;
        // Return the difference between 1 and the smallest value representable
        // by the &#39;BloombergLP::bdldfp::Decimal128&#39; type.  (IEEE-754: +1e-33)

    static BloombergLP::bdldfp::Decimal128 round_error() BSLS_NOTHROW_SPEC;
        // Return the maximum rounding error for the
        // &#39;BloombergLP::bdldfp::Decimal128&#39; type.  The actual value returned
        // depends on the current decimal floating point rounding setting.

    static BloombergLP::bdldfp::Decimal128 denorm_min() BSLS_NOTHROW_SPEC;
        // Return the smallest non-zero denormalized value for the
        // &#39;BloombergLP::bdldfp::Decimal128&#39; type.  (IEEE-754:
        // +0.000000000000000000000000000000001e-6143)

    static BloombergLP::bdldfp::Decimal128 infinity() BSLS_NOTHROW_SPEC;
        // Return the the value that represents positive infinity for the
        // &#39;BloombergLP::bdldfp::Decimal128&#39; type.

    static BloombergLP::bdldfp::Decimal128 quiet_NaN() BSLS_NOTHROW_SPEC;
        // Return a value that represents non-signaling NaN for the
        // &#39;BloombergLP::bdldfp::Decimal128&#39; type.

    static BloombergLP::bdldfp::Decimal128 signaling_NaN() BSLS_NOTHROW_SPEC;
        // Return a value that represents signaling NaN for the
        // &#39;BloombergLP::bdldfp::Decimal128&#39; type.

};

}  // close namespace std

#if defined(BDLDFP_DECIMAL_RESTORE_STD)
#   define std bsl
#   undef BDLDFP_DECIMAL_RESTORE_STD
#endif

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

namespace BloombergLP {
namespace bdldfp {

                      // THE DECIMAL FLOATING-POINT TYPES

                            // --------------------
                            // class Decimal_Type32
                            // --------------------

inline
Decimal_Type32::Decimal_Type32()
{
    bsl::memset(&amp;d_value, 0, sizeof(d_value));
}

inline
Decimal_Type32::Decimal_Type32(DecimalImpUtil::ValueType32 value)
: d_value(value)
{
}

inline
Decimal_Type32::Decimal_Type32(Decimal_Type64 other)
: d_value(DecimalImpUtil::convertToDecimal32(*other.data()))
{
}

inline
Decimal_Type32::Decimal_Type32(float other)
: d_value(DecimalImpUtil::binaryToDecimal32(other))
{
}

inline
Decimal_Type32::Decimal_Type32(double other)
: d_value(DecimalImpUtil::binaryToDecimal32(other))
{
}

inline
Decimal_Type32::Decimal_Type32(int other)
: d_value(DecimalImpUtil::int32ToDecimal32(other))
{
}

inline
Decimal_Type32::Decimal_Type32(unsigned int other)
: d_value(DecimalImpUtil::uint32ToDecimal32(other))
{
}

inline
Decimal_Type32::Decimal_Type32(long int other)
: d_value(DecimalImpUtil::int64ToDecimal32(other))
{
}

inline
Decimal_Type32::Decimal_Type32(unsigned long int other)
: d_value(DecimalImpUtil::uint64ToDecimal32(other))
{
}

inline
Decimal_Type32::Decimal_Type32(long long other)
: d_value(DecimalImpUtil::int64ToDecimal32(other))
{
}

inline
Decimal_Type32::Decimal_Type32(unsigned long long other)
: d_value(DecimalImpUtil::uint64ToDecimal32(other))
{
}



inline
DecimalImpUtil::ValueType32 *Decimal_Type32::data()
{
    return &amp;d_value;
}

inline
const DecimalImpUtil::ValueType32 *Decimal_Type32::data() const
{
    return &amp;d_value;
}

inline
DecimalImpUtil::ValueType32 Decimal_Type32::value() const
{
    return d_value;
}

                            // --------------------
                            // class Decimal_Type64
                            // --------------------

// CLASS METHODS

                                  // Aspects
inline
int Decimal_Type64::maxSupportedBdexVersion()
{
    return 1;
}

inline
int Decimal_Type64::maxSupportedBdexVersion(int /* versionSelector */)
{
    return 1;
}

// CREATORS
inline
Decimal_Type64::Decimal_Type64()
{
    bsl::memset(&amp;d_value, 0, sizeof(d_value));
}

inline
Decimal_Type64::Decimal_Type64(DecimalImpUtil::ValueType64 value)
: d_value(value)
{
}

inline
Decimal_Type64::Decimal_Type64(Decimal32 other)
: d_value(DecimalImpUtil::convertToDecimal64(*other.data()))
{
}

inline
Decimal_Type64::Decimal_Type64(Decimal128 other)
: d_value(DecimalImpUtil::convertToDecimal64(*other.data()))
{
}

                     // Numerical Conversion Constructors

inline
Decimal_Type64::Decimal_Type64(float other)
: d_value(DecimalImpUtil::binaryToDecimal64(other))
{
}

inline
Decimal_Type64::Decimal_Type64(double other)
: d_value(DecimalImpUtil::binaryToDecimal64(other))
{
}

                      // Integral Conversion Constructors

inline
Decimal_Type64::Decimal_Type64(int other)
: d_value(DecimalImpUtil::int32ToDecimal64(other))
{
}

inline
Decimal_Type64::Decimal_Type64(unsigned int other)
: d_value(DecimalImpUtil::uint32ToDecimal64(other))
{
}

inline
Decimal_Type64::Decimal_Type64(long other)
: d_value(DecimalImpUtil::int64ToDecimal64(other))
{
}

inline
Decimal_Type64::Decimal_Type64(unsigned long other)
: d_value(DecimalImpUtil::uint64ToDecimal64(other))
{
}

inline
Decimal_Type64::Decimal_Type64(long long other)
: d_value(DecimalImpUtil::int64ToDecimal64(other))
{
}

inline
Decimal_Type64::Decimal_Type64(unsigned long long other)
: d_value(DecimalImpUtil::uint64ToDecimal64(other))
{
}


// MANIPULATORS

                     // Incrementation and Decrementation

inline Decimal_Type64&amp; Decimal_Type64::operator++()
{
    return *this += Decimal64(1);
}

inline Decimal_Type64&amp; Decimal_Type64::operator--()
{
    return *this -= Decimal64(1);
}

                                  // Addition

inline Decimal_Type64&amp; Decimal_Type64::operator+=(Decimal32 rhs)
{
    return *this += Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator+=(Decimal64 rhs)
{
    this-&gt;d_value = DecimalImpUtil::add(this-&gt;d_value, rhs.d_value);
    return *this;
}

inline Decimal_Type64&amp; Decimal_Type64::operator+=(Decimal128 rhs)
{
    return *this += Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator+=(int rhs)
{
    return *this += Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator+=(unsigned int rhs)
{
    return *this += Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator+=(long rhs)
{
    return *this += Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator+=(unsigned long rhs)
{
    return *this += Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator+=(long long rhs)
{
    return *this += Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator+=(unsigned long long rhs)
{
    return *this += Decimal64(rhs);
}

                                // Subtraction

inline Decimal_Type64&amp; Decimal_Type64::operator-=(Decimal32 rhs)
{
    return *this -= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator-=(Decimal64 rhs)
{
    this-&gt;d_value = DecimalImpUtil::subtract(this-&gt;d_value, rhs.d_value);
    return *this;
}

inline Decimal_Type64&amp; Decimal_Type64::operator-=(Decimal128 rhs)
{
    return *this -= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator-=(int rhs)
{
    return *this -= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator-=(unsigned int rhs)
{
    return *this -= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator-=(long rhs)
{
    return *this -= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator-=(unsigned long rhs)
{
    return *this -= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator-=(long long rhs)
{
    return *this -= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator-=(unsigned long long rhs)
{
    return *this -= Decimal64(rhs);
}

                               // Multiplication

inline Decimal_Type64&amp; Decimal_Type64::operator*=(Decimal32 rhs)
{
    return *this *= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator*=(Decimal64 rhs)
{
    this-&gt;d_value = DecimalImpUtil::multiply(this-&gt;d_value, rhs.d_value);
    return *this;
}

inline Decimal_Type64&amp; Decimal_Type64::operator*=(Decimal128 rhs)
{
    return *this *= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator*=(int rhs)
{
    return *this *= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator*=(unsigned int rhs)
{
    return *this *= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator*=(long rhs)
{
    return *this *= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator*=(unsigned long rhs)
{
    return *this *= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator*=(long long rhs)
{
    return *this *= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator*=(unsigned long long rhs)
{
    return *this *= Decimal64(rhs);
}

                                  // Division

inline Decimal_Type64&amp; Decimal_Type64::operator/=(Decimal32 rhs)
{
    return *this /= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator/=(Decimal64 rhs)
{
    this-&gt;d_value = DecimalImpUtil::divide(this-&gt;d_value, rhs.d_value);
    return *this;
}

inline Decimal_Type64&amp; Decimal_Type64::operator/=(Decimal128 rhs)
{
    return *this /= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator/=(int rhs)
{
    return *this /= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator/=(unsigned int rhs)
{
    return *this /= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator/=(long rhs)
{
    return *this /= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator/=(unsigned long rhs)
{
    return *this /= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator/=(long long rhs)
{
    return *this /= Decimal64(rhs);
}

inline Decimal_Type64&amp; Decimal_Type64::operator/=(unsigned long long rhs)
{
    return *this /= Decimal64(rhs);
}


                                  // Aspects

template &lt;class STREAM&gt;
STREAM&amp; Decimal_Type64::bdexStreamIn(STREAM&amp; stream, int version)
{
    if (stream) {
        switch (version) { // switch on the schema version
          case 1: {
            BinaryIntegralDecimalImpUtil::StorageType64 bidVal;
            stream.getUint64(bidVal.d_raw);

            if (stream) {
                d_value = DecimalImpUtil::convertFromBID(bidVal);
            }
            else {
                stream.invalidate();
            }
          } break;
          default: {
            stream.invalidate();  // unrecognized version number
          }
        }
    }

    return stream;
}

//ACCESSORS

                            // Internals Accessors

inline DecimalImpUtil::ValueType64 *Decimal_Type64::data()
{
    return &amp;d_value;
}

inline const DecimalImpUtil::ValueType64 *Decimal_Type64::data() const
{
    return &amp;d_value;
}

inline DecimalImpUtil::ValueType64 Decimal_Type64::value() const
{
    return d_value;
}

                                  // Aspects

template &lt;class STREAM&gt;
STREAM&amp; Decimal_Type64::bdexStreamOut(STREAM&amp; stream, int version) const
{
    if (stream) {
        switch (version) { // switch on the schema version
          case 1: {
            BinaryIntegralDecimalImpUtil::StorageType64 bidVal =
                DecimalImpUtil::convertToBID(d_value);
            stream.putUint64(bidVal.d_raw);
          } break;
          default: {
            stream.invalidate();  // unrecognized version number
          }
        }
    }
    return stream;
}

                           // ---------------------
                           // class Decimal_Type128
                           // ---------------------

inline
Decimal_Type128::Decimal_Type128()
{
    bsl::memset(&amp;d_value, 0, sizeof(d_value));
}

inline
Decimal_Type128::Decimal_Type128(DecimalImpUtil::ValueType128 value)
: d_value(value)
{
}

inline
Decimal_Type128::Decimal_Type128(Decimal32 value)
: d_value(DecimalImpUtil::convertToDecimal128(*value.data()))
{
}

inline
Decimal_Type128::Decimal_Type128(Decimal64 value)
: d_value(DecimalImpUtil::convertToDecimal128(*value.data()))
{
}

inline
Decimal_Type128::Decimal_Type128(float other)
: d_value(DecimalImpUtil::binaryToDecimal128(other))
{
}

inline
Decimal_Type128::Decimal_Type128(double other)
: d_value(DecimalImpUtil::binaryToDecimal128(other))
{
}

inline
Decimal_Type128::Decimal_Type128(int value)
: d_value(DecimalImpUtil::int32ToDecimal128(value))
{
}

inline Decimal_Type128::Decimal_Type128(unsigned int value)
: d_value(DecimalImpUtil::uint32ToDecimal128(value))
{
}

inline Decimal_Type128::Decimal_Type128(long value)
: d_value(DecimalImpUtil::int64ToDecimal128(value))
{
}

inline Decimal_Type128::Decimal_Type128(unsigned long value)
: d_value(DecimalImpUtil::uint64ToDecimal128(value))
{
}

inline Decimal_Type128::Decimal_Type128(long long value)
: d_value(DecimalImpUtil::int64ToDecimal128(value))
{
}

inline Decimal_Type128::Decimal_Type128(unsigned long long value)
: d_value(DecimalImpUtil::uint64ToDecimal128(value))
{
}


inline
Decimal_Type128&amp; Decimal_Type128::operator++()
{
    return *this += Decimal128(1);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator--()
{
    return *this -= Decimal128(1);
}

                                  // Addition

inline
Decimal_Type128&amp; Decimal_Type128::operator+=(Decimal32 rhs)
{
    return *this += Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator+=(Decimal64 rhs)
{
    return *this += Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator+=(Decimal128 rhs)
{
    this-&gt;d_value = DecimalImpUtil::add(this-&gt;d_value, rhs.d_value);
    return *this;
}

inline
Decimal_Type128&amp; Decimal_Type128::operator+=(int rhs)
{
    return *this += Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator+=(unsigned int rhs)
{
    return *this += Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator+=(long rhs)
{
    return *this += Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator+=(unsigned long rhs)
{
    return *this += Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator+=(long long rhs)
{
    return *this += Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator+=(unsigned long long rhs)
{
    return *this += Decimal128(rhs);
}

                                // Subtraction

inline
Decimal_Type128&amp; Decimal_Type128::operator-=(Decimal32 rhs)
{
    return *this -= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator-=(Decimal64 rhs)
{
    return *this -= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator-=(Decimal128 rhs)
{
    this-&gt;d_value = DecimalImpUtil::subtract(this-&gt;d_value, rhs.d_value);
    return *this;
}


inline
Decimal_Type128&amp; Decimal_Type128::operator-=(int rhs)
{
    return *this -= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator-=(unsigned int rhs)
{
    return *this -= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator-=(long rhs)
{
    return *this -= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator-=(unsigned long rhs)
{
    return *this -= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator-=(long long rhs)
{
    return *this -= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator-=(unsigned long long rhs)
{
    return *this -= Decimal128(rhs);
}

                               // Multiplication

inline
Decimal_Type128&amp; Decimal_Type128::operator*=(Decimal32 rhs)
{
    return *this *= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator*=(Decimal64 rhs)
{
    return *this *= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator*=(Decimal128 rhs)
{
    this-&gt;d_value = DecimalImpUtil::multiply(this-&gt;d_value, rhs.d_value);
    return *this;
}


inline
Decimal_Type128&amp; Decimal_Type128::operator*=(int rhs)
{
    return *this *= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator*=(unsigned int rhs)
{
    return *this *= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator*=(long rhs)
{
    return *this *= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator*=(unsigned long rhs)
{
    return *this *= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator*=(long long rhs)
{
    return *this *= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator*=(unsigned long long rhs)
{
    return *this *= Decimal128(rhs);
}

                                  // Division

inline
Decimal_Type128&amp; Decimal_Type128::operator/=(Decimal32 rhs)
{
    return *this /= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator/=(Decimal64 rhs)
{
    return *this /= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator/=(Decimal128 rhs)
{
    this-&gt;d_value = DecimalImpUtil::divide(this-&gt;d_value, rhs.d_value);
    return *this;
}


inline
Decimal_Type128&amp; Decimal_Type128::operator/=(int rhs)
{
    return *this /= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator/=(unsigned int rhs)
{
    return *this /= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator/=(long rhs)
{
    return *this /= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator/=(unsigned long rhs)
{
    return *this /= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator/=(long long rhs)
{
    return *this /= Decimal128(rhs);
}

inline
Decimal_Type128&amp; Decimal_Type128::operator/=(unsigned long long rhs)
{
    return *this /= Decimal128(rhs);
}

                            // Internals Accessors

inline
DecimalImpUtil::ValueType128 *Decimal_Type128::data()
{
    return &amp;d_value;
}

inline
const DecimalImpUtil::ValueType128 *Decimal_Type128::data() const
{
    return &amp;d_value;
}

inline
DecimalImpUtil::ValueType128 Decimal_Type128::value() const
{
    return d_value;
}

}  // close package namespace

// FREE OPERATORS

inline
bdldfp::Decimal32 bdldfp::operator+(bdldfp::Decimal32 value)
{
    return value;
}

inline
bdldfp::Decimal32 bdldfp::operator-(bdldfp::Decimal32 value)
{
    return Decimal32(DecimalImpUtil::negate(value.value()));
}

inline
bool bdldfp::operator==(bdldfp::Decimal32 lhs, bdldfp::Decimal32 rhs)
{
    return DecimalImpUtil::equal(*lhs.data(), *rhs.data());
}

inline
bool bdldfp::operator!=(bdldfp::Decimal32 lhs, bdldfp::Decimal32 rhs)
{
    return DecimalImpUtil::notEqual(*lhs.data(), *rhs.data());
}

inline
bool bdldfp::operator&lt;(bdldfp::Decimal32 lhs, bdldfp::Decimal32 rhs)
{
    return DecimalImpUtil::less(*lhs.data(), *rhs.data());
}

inline
bool bdldfp::operator&lt;=(bdldfp::Decimal32 lhs, bdldfp::Decimal32 rhs)
{
    return DecimalImpUtil::lessEqual(*lhs.data(), *rhs.data());
}

inline
bool bdldfp::operator&gt;(bdldfp::Decimal32 lhs, bdldfp::Decimal32 rhs)
{
    return DecimalImpUtil::greater(*lhs.data(), *rhs.data());
}

inline
bool bdldfp::operator&gt;=(bdldfp::Decimal32 lhs, bdldfp::Decimal32 rhs)
{
    return DecimalImpUtil::greaterEqual(*lhs.data(), *rhs.data());
}

// FREE OPERATORS

inline
bdldfp::Decimal64 bdldfp::operator+(bdldfp::Decimal64 value)
{
    return value;
}

inline
bdldfp::Decimal64 bdldfp::operator-(bdldfp::Decimal64 value)
{
    return DecimalImpUtil::negate(*value.data());
}

inline
bdldfp::Decimal64 bdldfp::operator++(bdldfp::Decimal64&amp; value, int)
{
    bdldfp::Decimal64 result(value);
    ++value;
    return result;
}

inline
bdldfp::Decimal64 bdldfp::operator--(bdldfp::Decimal64&amp; value, int)
{
    bdldfp::Decimal64 result(value);
    --value;
    return result;
}

                                  // Addition

inline
bdldfp::Decimal64 bdldfp::operator+(bdldfp::Decimal64 lhs,
                                    bdldfp::Decimal64 rhs)
{
    return Decimal64(DecimalImpUtil::add(*lhs.data(), *rhs.data()));
}

inline
bdldfp::Decimal64 bdldfp::operator+(bdldfp::Decimal32 lhs,
                                    bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) + rhs;
}

inline
bdldfp::Decimal64 bdldfp::operator+(bdldfp::Decimal64 lhs,
                                    bdldfp::Decimal32 rhs)
{
    return lhs + Decimal64(rhs);
}

inline
bdldfp::Decimal64 bdldfp::operator+(bdldfp::Decimal64 lhs,
                                    int               rhs)
{
    return lhs + Decimal64(rhs);
}

inline
bdldfp::Decimal64 bdldfp::operator+(bdldfp::Decimal64 lhs,
                                    unsigned int      rhs)
{
    return lhs + Decimal64(rhs);
}

inline
bdldfp::Decimal64 bdldfp::operator+(bdldfp::Decimal64 lhs,
                                    long              rhs)
{
    return lhs + Decimal64(rhs);
}

inline
bdldfp::Decimal64 bdldfp::operator+(bdldfp::Decimal64 lhs,
                                    unsigned long     rhs)
{
    return lhs + Decimal64(rhs);
}

inline
bdldfp::Decimal64 bdldfp::operator+(bdldfp::Decimal64 lhs,
                                    long long         rhs)
{
    return lhs + Decimal64(rhs);
}

inline
bdldfp::Decimal64 bdldfp::operator+(bdldfp::Decimal64  lhs,
                                    unsigned long long rhs)
{
    return lhs + Decimal64(rhs);
}

inline
bdldfp::Decimal64 bdldfp::operator+(int               lhs,
                                    bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) + rhs;
}

inline
bdldfp::Decimal64 bdldfp::operator+(unsigned int      lhs,
                                    bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) + rhs;
}

inline
bdldfp::Decimal64 bdldfp::operator+(long              lhs,
                                    bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) + rhs;
}

inline
bdldfp::Decimal64 bdldfp::operator+(unsigned long     lhs,
                                    bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) + rhs;
}

inline
bdldfp::Decimal64 bdldfp::operator+(long long         lhs,
                                    bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) + rhs;
}

inline
bdldfp::Decimal64 bdldfp::operator+(unsigned long long lhs,
                                    bdldfp::Decimal64  rhs)
{
    return Decimal64(lhs) + rhs;
}

                                // Subtraction

inline
bdldfp::Decimal64 bdldfp::operator-(bdldfp::Decimal64 lhs,
                                    bdldfp::Decimal64 rhs)
{
    return Decimal64(DecimalImpUtil::subtract(*lhs.data(), *rhs.data()));
}

inline
bdldfp::Decimal64 bdldfp::operator-(bdldfp::Decimal32 lhs,
                                    bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) - rhs;
}

inline
bdldfp::Decimal64 bdldfp::operator-(bdldfp::Decimal64 lhs,
                                    bdldfp::Decimal32 rhs)
{
    return lhs - Decimal64(rhs);
}

inline
bdldfp::Decimal64 bdldfp::operator-(bdldfp::Decimal64 lhs,
                                    int               rhs)
{
    return lhs - Decimal64(rhs);
}

inline
bdldfp::Decimal64 bdldfp::operator-(bdldfp::Decimal64 lhs,
                                    unsigned int      rhs)
{
    return lhs - Decimal64(rhs);
}

inline
bdldfp::Decimal64 bdldfp::operator-(bdldfp::Decimal64 lhs,
                                    long              rhs)
{
    return lhs - Decimal64(rhs);
}

inline
bdldfp::Decimal64 bdldfp::operator-(bdldfp::Decimal64 lhs,
                                    unsigned long     rhs)
{
    return lhs - Decimal64(rhs);
}

inline
bdldfp::Decimal64 bdldfp::operator-(bdldfp::Decimal64 lhs,
                                    long long         rhs)
{
    return lhs - Decimal64(rhs);
}

inline
bdldfp::Decimal64 bdldfp::operator-(bdldfp::Decimal64  lhs,
                                    unsigned long long rhs)
{
    return lhs - Decimal64(rhs);
}

inline
bdldfp::Decimal64 bdldfp::operator-(int               lhs,
                                    bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) - rhs;
}

inline
bdldfp::Decimal64 bdldfp::operator-(unsigned int      lhs,
                                    bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) - rhs;
}

inline
bdldfp::Decimal64 bdldfp::operator-(long              lhs,
                                    bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) - rhs;
}

inline
bdldfp::Decimal64 bdldfp::operator-(unsigned long     lhs,
                                    bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) - rhs;
}

inline
bdldfp::Decimal64 bdldfp::operator-(long long         lhs,
                                    bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) - rhs;
}

inline
bdldfp::Decimal64 bdldfp::operator-(unsigned long long lhs,
                                    bdldfp::Decimal64  rhs)
{
    return Decimal64(lhs) - rhs;
}

                               // Multiplication

inline bdldfp::Decimal64 bdldfp::operator*(bdldfp::Decimal64 lhs,
                                           bdldfp::Decimal64 rhs)
{
    return Decimal64(DecimalImpUtil::multiply(*lhs.data(), *rhs.data()));
}

inline bdldfp::Decimal64 bdldfp::operator*(bdldfp::Decimal32 lhs,
                                           bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) * rhs;
}

inline bdldfp::Decimal64 bdldfp::operator*(bdldfp::Decimal64 lhs,
                                           bdldfp::Decimal32 rhs)
{
    return lhs * Decimal64(rhs);
}

inline bdldfp::Decimal64 bdldfp::operator*(bdldfp::Decimal64 lhs,
                                           int               rhs)
{
    return lhs * Decimal64(rhs);
}

inline bdldfp::Decimal64 bdldfp::operator*(bdldfp::Decimal64 lhs,
                                           unsigned int      rhs)
{
    return lhs * Decimal64(rhs);
}

inline bdldfp::Decimal64 bdldfp::operator*(bdldfp::Decimal64 lhs,
                                           long              rhs)
{
    return lhs * Decimal64(rhs);
}

inline bdldfp::Decimal64 bdldfp::operator*(bdldfp::Decimal64 lhs,
                                           unsigned long     rhs)
{
    return lhs * Decimal64(rhs);
}

inline bdldfp::Decimal64 bdldfp::operator*(bdldfp::Decimal64 lhs,
                                           long long         rhs)
{
    return lhs * Decimal64(rhs);
}

inline bdldfp::Decimal64 bdldfp::operator*(bdldfp::Decimal64  lhs,
                                           unsigned long long rhs)
{
    return lhs * Decimal64(rhs);
}

inline bdldfp::Decimal64 bdldfp::operator*(int               lhs,
                                           bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) * rhs;
}

inline bdldfp::Decimal64 bdldfp::operator*(unsigned int      lhs,
                                           bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) * rhs;
}

inline bdldfp::Decimal64 bdldfp::operator*(long              lhs,
                                           bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) * rhs;
}

inline bdldfp::Decimal64 bdldfp::operator*(unsigned long     lhs,
                                           bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) * rhs;
}

inline bdldfp::Decimal64 bdldfp::operator*(long long         lhs,
                                           bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) * rhs;
}

inline bdldfp::Decimal64 bdldfp::operator*(unsigned long long lhs,
                                           bdldfp::Decimal64  rhs)
{
    return Decimal64(lhs) * rhs;
}

                                  // Division

inline bdldfp::Decimal64 bdldfp::operator/(bdldfp::Decimal64 lhs,
                                           bdldfp::Decimal64 rhs)
{
    return Decimal64(DecimalImpUtil::divide(*lhs.data(), *rhs.data()));
}

inline bdldfp::Decimal64 bdldfp::operator/(bdldfp::Decimal32 lhs,
                                           bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) / rhs;
}

inline bdldfp::Decimal64 bdldfp::operator/(bdldfp::Decimal64 lhs,
                                           bdldfp::Decimal32 rhs)
{
    return lhs / Decimal64(rhs);
}

inline bdldfp::Decimal64 bdldfp::operator/(bdldfp::Decimal64 lhs,
                                           int               rhs)
{
    return lhs / Decimal64(rhs);
}

inline bdldfp::Decimal64 bdldfp::operator/(bdldfp::Decimal64 lhs,
                                           unsigned int      rhs)
{
    return lhs / Decimal64(rhs);
}

inline bdldfp::Decimal64 bdldfp::operator/(bdldfp::Decimal64 lhs,
                                           long              rhs)
{
    return lhs / Decimal64(rhs);
}

inline bdldfp::Decimal64 bdldfp::operator/(bdldfp::Decimal64 lhs,
                                           unsigned long     rhs)
{
    return lhs / Decimal64(rhs);
}

inline bdldfp::Decimal64 bdldfp::operator/(bdldfp::Decimal64 lhs,
                                           long long         rhs)
{
    return lhs / Decimal64(rhs);
}

inline bdldfp::Decimal64 bdldfp::operator/(bdldfp::Decimal64  lhs,
                                           unsigned long long rhs)
{
    return lhs / Decimal64(rhs);
}

inline bdldfp::Decimal64 bdldfp::operator/(int               lhs,
                                           bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) / rhs;
}

inline bdldfp::Decimal64 bdldfp::operator/(unsigned int      lhs,
                                           bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) / rhs;
}

inline bdldfp::Decimal64 bdldfp::operator/(long              lhs,
                                           bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) / rhs;
}

inline bdldfp::Decimal64 bdldfp::operator/(unsigned long     lhs,
                                           bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) / rhs;
}

inline bdldfp::Decimal64 bdldfp::operator/(long long         lhs,
                                           bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) / rhs;
}

inline bdldfp::Decimal64 bdldfp::operator/(unsigned long long lhs,
                                           bdldfp::Decimal64  rhs)
{
    return Decimal64(lhs) / rhs;
}

                                  // Equality

inline bool bdldfp::operator==(bdldfp::Decimal64 lhs, bdldfp::Decimal64 rhs)
{
    return DecimalImpUtil::equal(*lhs.data(), *rhs.data());
}

inline bool bdldfp::operator==(bdldfp::Decimal32 lhs, bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) == rhs;
}

inline bool bdldfp::operator==(bdldfp::Decimal64 lhs, bdldfp::Decimal32 rhs)
{
    return lhs == Decimal64(rhs);
}

                                 // Inequality

inline bool bdldfp::operator!=(bdldfp::Decimal64 lhs, bdldfp::Decimal64 rhs)
{
    return DecimalImpUtil::notEqual(*lhs.data(), *rhs.data());
}

inline bool bdldfp::operator!=(bdldfp::Decimal32 lhs, bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) != rhs;
}

inline bool bdldfp::operator!=(bdldfp::Decimal64 lhs, bdldfp::Decimal32 rhs)
{
    return lhs != Decimal64(rhs);
}

                                 // Less Than

inline bool bdldfp::operator&lt;(bdldfp::Decimal64 lhs, bdldfp::Decimal64 rhs)
{
    return DecimalImpUtil::less(*lhs.data(), *rhs.data());
}

inline bool bdldfp::operator&lt;(bdldfp::Decimal32 lhs, bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) &lt; rhs;
}

inline bool bdldfp::operator&lt;(bdldfp::Decimal64 lhs, bdldfp::Decimal32 rhs)
{
    return lhs &lt; Decimal64(rhs);
}

                                 // Less Equal

inline bool bdldfp::operator&lt;=(bdldfp::Decimal64 lhs, bdldfp::Decimal64 rhs)
{
    return DecimalImpUtil::lessEqual(*lhs.data(), *rhs.data());
}

inline bool bdldfp::operator&lt;=(bdldfp::Decimal32 lhs, bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) &lt;= rhs;
}

inline bool bdldfp::operator&lt;=(bdldfp::Decimal64 lhs, bdldfp::Decimal32 rhs)
{
    return lhs &lt;= Decimal64(rhs);
}

                                // Greater Than

inline bool bdldfp::operator&gt;(bdldfp::Decimal64 lhs, bdldfp::Decimal64 rhs)
{
    return DecimalImpUtil::greater(*lhs.data(), *rhs.data());
}

inline bool bdldfp::operator&gt;(bdldfp::Decimal32 lhs, bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) &gt; rhs;
}

inline bool bdldfp::operator&gt;(bdldfp::Decimal64 lhs, bdldfp::Decimal32 rhs)
{
    return lhs &gt; Decimal64(rhs);
}

                               // Greater Equal

inline bool bdldfp::operator&gt;=(bdldfp::Decimal64 lhs, bdldfp::Decimal64 rhs)
{
    return DecimalImpUtil::greaterEqual(*lhs.data(), *rhs.data());
}

inline bool bdldfp::operator&gt;=(bdldfp::Decimal32 lhs, bdldfp::Decimal64 rhs)
{
    return Decimal64(lhs) &gt;= rhs;
}

inline bool bdldfp::operator&gt;=(bdldfp::Decimal64 lhs, bdldfp::Decimal32 rhs)
{
    return lhs &gt;= Decimal64(rhs);
}

// FREE OPERATORS

inline
bdldfp::Decimal128 bdldfp::operator+(bdldfp::Decimal128 value)
{
    return value;
}

inline
bdldfp::Decimal128 bdldfp::operator-(bdldfp::Decimal128 value)
{
    return Decimal128(DecimalImpUtil::negate(*value.data()));
}

inline
bdldfp::Decimal128 bdldfp::operator++(bdldfp::Decimal128&amp; value, int)
{
    Decimal128 result = value;
    ++value;
    return result;
}

inline
bdldfp::Decimal128 bdldfp::operator--(bdldfp::Decimal128&amp; value, int)
{
    Decimal128 result = value;
    --value;
    return result;
}

                                  // Addition

inline
bdldfp::Decimal128 bdldfp::operator+(bdldfp::Decimal128 lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(DecimalImpUtil::add(*lhs.data(), *rhs.data()));
}

inline
bdldfp::Decimal128 bdldfp::operator+(bdldfp::Decimal32  lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) + rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator+(bdldfp::Decimal128 lhs,
                                     bdldfp::Decimal32  rhs)
{
    return lhs + Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator+(bdldfp::Decimal64  lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) + rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator+(bdldfp::Decimal128 lhs,
                                     bdldfp::Decimal64  rhs)
{
    return lhs + Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator+(bdldfp::Decimal128 lhs,
                                     int                rhs)
{
    return lhs + Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator+(bdldfp::Decimal128 lhs,
                                     unsigned int       rhs)
{
    return lhs + Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator+(bdldfp::Decimal128 lhs,
                                     long               rhs)
{
    return lhs + Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator+(bdldfp::Decimal128 lhs,
                                     unsigned long      rhs)
{
    return lhs + Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator+(bdldfp::Decimal128 lhs,
                                     long long          rhs)
{
    return lhs + Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator+(bdldfp::Decimal128 lhs,
                                     unsigned long long rhs)
{
    return lhs + Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator+(int                lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) + rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator+(unsigned int       lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) + rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator+(long               lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) + rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator+(unsigned long      lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) + rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator+(long long          lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) + rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator+(unsigned long long lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) + rhs;
}

                                // Subtraction

inline
bdldfp::Decimal128 bdldfp::operator-(bdldfp::Decimal128 lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(DecimalImpUtil::subtract(*lhs.data(), *rhs.data()));
}

inline
bdldfp::Decimal128 bdldfp::operator-(bdldfp::Decimal32  lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) - rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator-(bdldfp::Decimal128 lhs,
                                     bdldfp::Decimal32  rhs)
{
    return lhs - Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator-(bdldfp::Decimal64  lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) - rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator-(bdldfp::Decimal128 lhs,
                                     bdldfp::Decimal64  rhs)
{
    return lhs - Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator-(bdldfp::Decimal128 lhs,
                                     int                rhs)
{
    return lhs - Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator-(bdldfp::Decimal128 lhs,
                                     unsigned int       rhs)
{
    return lhs - Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator-(bdldfp::Decimal128 lhs,
                                     long               rhs)
{
    return lhs - Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator-(bdldfp::Decimal128 lhs,
                                     unsigned long      rhs)
{
    return lhs - Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator-(bdldfp::Decimal128 lhs,
                                     long long          rhs)
{
    return lhs - Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator-(bdldfp::Decimal128 lhs,
                                     unsigned long long rhs)
{
    return lhs - Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator-(int                lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) - rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator-(unsigned int       lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) - rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator-(long               lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) - rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator-(unsigned long      lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) - rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator-(long long          lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) - rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator-(unsigned long long lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) - rhs;
}

                               // Multiplication

inline
bdldfp::Decimal128 bdldfp::operator*(bdldfp::Decimal128 lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(DecimalImpUtil::multiply(*lhs.data(), *rhs.data()));
}

inline
bdldfp::Decimal128 bdldfp::operator*(bdldfp::Decimal32  lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) * rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator*(bdldfp::Decimal128 lhs,
                                     bdldfp::Decimal32  rhs)
{
    return lhs * Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator*(bdldfp::Decimal64  lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) * rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator*(bdldfp::Decimal128 lhs,
                                     bdldfp::Decimal64  rhs)
{
    return lhs * Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator*(bdldfp::Decimal128 lhs,
                                     int                rhs)
{
    return lhs * Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator*(bdldfp::Decimal128 lhs,
                                     unsigned int       rhs)
{
    return lhs * Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator*(bdldfp::Decimal128 lhs,
                                     long               rhs)
{
    return lhs * Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator*(bdldfp::Decimal128 lhs,
                                     unsigned long      rhs)
{
    return lhs * Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator*(bdldfp::Decimal128 lhs,
                                     long long          rhs)
{
    return lhs * Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator*(bdldfp::Decimal128 lhs,
                                     unsigned long long rhs)
{
    return lhs * Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator*(int                lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) * rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator*(unsigned int       lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) * rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator*(long               lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) * rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator*(unsigned long      lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) * rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator*(long long          lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) * rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator*(unsigned long long lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) * rhs;
}

                                  // Division

inline
bdldfp::Decimal128 bdldfp::operator/(bdldfp::Decimal128 lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(DecimalImpUtil::divide(*lhs.data(), *rhs.data()));
}

inline
bdldfp::Decimal128 bdldfp::operator/(bdldfp::Decimal32  lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) / rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator/(bdldfp::Decimal128 lhs,
                                     bdldfp::Decimal32  rhs)
{
    return lhs / Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator/(bdldfp::Decimal64  lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) / rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator/(bdldfp::Decimal128 lhs,
                                     bdldfp::Decimal64  rhs)
{
    return lhs / Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator/(bdldfp::Decimal128 lhs,
                                     int                rhs)
{
    return lhs / Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator/(bdldfp::Decimal128 lhs,
                                     unsigned int       rhs)
{
    return lhs / Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator/(bdldfp::Decimal128 lhs,
                                     long               rhs)
{
    return lhs / Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator/(bdldfp::Decimal128 lhs,
                                     unsigned long      rhs)
{
    return lhs / Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator/(bdldfp::Decimal128 lhs,
                                     long long          rhs)
{
    return lhs / Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator/(bdldfp::Decimal128 lhs,
                                     unsigned long long rhs)
{
    return lhs / Decimal128(rhs);
}

inline
bdldfp::Decimal128 bdldfp::operator/(int                lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) / rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator/(unsigned int       lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) / rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator/(long               lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) / rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator/(unsigned long      lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) / rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator/(long long          lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) / rhs;
}

inline
bdldfp::Decimal128 bdldfp::operator/(unsigned long long lhs,
                                     bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) / rhs;
}

                                  // Equality

inline
bool bdldfp::operator==(bdldfp::Decimal128 lhs, bdldfp::Decimal128 rhs)
{
    return DecimalImpUtil::equal(*lhs.data(), *rhs.data());
}

inline
bool bdldfp::operator==(bdldfp::Decimal32 lhs, bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) == rhs;
}

inline
bool bdldfp::operator==(bdldfp::Decimal128 lhs, bdldfp::Decimal32 rhs)
{
    return lhs == Decimal128(rhs);
}

inline
bool bdldfp::operator==(bdldfp::Decimal64 lhs, bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) == rhs;
}

inline
bool bdldfp::operator==(bdldfp::Decimal128 lhs, bdldfp::Decimal64 rhs)
{
    return lhs == Decimal128(rhs);
}

                                 // Inequality

inline
bool bdldfp::operator!=(bdldfp::Decimal128 lhs, bdldfp::Decimal128 rhs)
{
    return DecimalImpUtil::notEqual(*lhs.data(), *rhs.data());
}

inline
bool bdldfp::operator!=(bdldfp::Decimal32 lhs, bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) != rhs;
}

inline
bool bdldfp::operator!=(bdldfp::Decimal128 lhs, bdldfp::Decimal32 rhs)
{
    return lhs != Decimal128(rhs);
}

inline
bool bdldfp::operator!=(bdldfp::Decimal64 lhs, bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) != rhs;
}

inline
bool bdldfp::operator!=(bdldfp::Decimal128 lhs, bdldfp::Decimal64 rhs)
{
    return lhs != Decimal128(rhs);
}

                                 // Less Than

inline
bool bdldfp::operator&lt;(bdldfp::Decimal128 lhs, bdldfp::Decimal128 rhs)
{
    return DecimalImpUtil::less(*lhs.data(), *rhs.data());
}

inline
bool bdldfp::operator&lt;(bdldfp::Decimal32 lhs, bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) &lt; rhs;
}

inline
bool bdldfp::operator&lt;(bdldfp::Decimal128 lhs, bdldfp::Decimal32 rhs)
{
    return lhs &lt; Decimal128(rhs);
}

inline
bool bdldfp::operator&lt;(bdldfp::Decimal64 lhs, bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) &lt; rhs;
}

inline
bool bdldfp::operator&lt;(bdldfp::Decimal128 lhs, bdldfp::Decimal64 rhs)
{
    return lhs &lt; Decimal128(rhs);
}

                                 // Less Equal

inline
bool bdldfp::operator&lt;=(bdldfp::Decimal128 lhs, bdldfp::Decimal128 rhs)
{
    return DecimalImpUtil::lessEqual(*lhs.data(), *rhs.data());
}

inline
bool bdldfp::operator&lt;=(bdldfp::Decimal32 lhs, bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) &lt;= rhs;
}

inline
bool bdldfp::operator&lt;=(bdldfp::Decimal128 lhs, bdldfp::Decimal32 rhs)
{
    return lhs &lt;= Decimal128(rhs);
}

inline
bool bdldfp::operator&lt;=(bdldfp::Decimal64 lhs, bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) &lt;= rhs;
}

inline
bool bdldfp::operator&lt;=(bdldfp::Decimal128 lhs, bdldfp::Decimal64 rhs)
{
    return lhs &lt;= Decimal128(rhs);
}

                                  // Greater

inline
bool bdldfp::operator&gt;(bdldfp::Decimal128 lhs, bdldfp::Decimal128 rhs)
{
    return DecimalImpUtil::greater(*lhs.data(), *rhs.data());
}

inline
bool bdldfp::operator&gt;(bdldfp::Decimal32 lhs, bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) &gt; rhs;
}

inline
bool bdldfp::operator&gt;(bdldfp::Decimal128 lhs, bdldfp::Decimal32 rhs)
{
    return lhs &gt; Decimal128(rhs);
}

inline
bool bdldfp::operator&gt;(bdldfp::Decimal64 lhs, bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) &gt; rhs;
}

inline
bool bdldfp::operator&gt;(bdldfp::Decimal128 lhs, bdldfp::Decimal64 rhs)
{
    return lhs &gt; Decimal128(rhs);
}

                               // Greater Equal

inline
bool bdldfp::operator&gt;=(bdldfp::Decimal128 lhs, bdldfp::Decimal128 rhs)
{
    return DecimalImpUtil::greaterEqual(*lhs.data(), *rhs.data());
}

inline
bool bdldfp::operator&gt;=(bdldfp::Decimal32 lhs, bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) &gt;= rhs;
}

inline
bool bdldfp::operator&gt;=(bdldfp::Decimal128 lhs, bdldfp::Decimal32 rhs)
{
    return lhs &gt;= Decimal128(rhs);
}

inline
bool bdldfp::operator&gt;=(bdldfp::Decimal64 lhs, bdldfp::Decimal128 rhs)
{
    return Decimal128(lhs) &gt;= rhs;
}

inline
bool bdldfp::operator&gt;=(bdldfp::Decimal128 lhs, bdldfp::Decimal64 rhs)
{
    return lhs &gt;= Decimal128(rhs);
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
