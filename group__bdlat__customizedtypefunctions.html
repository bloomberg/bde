<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlat_customizedtypefunctions Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlat_customizedtypefunctions<br/>
<small>
[<a class="el" href="group__bdlat.html">Package bdlat</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a namespace defining customized type functions.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlat__CustomizedTypeFunctions__Imp.html">bdlat_CustomizedTypeFunctions_Imp</a></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlat__CustomizedTypeFunctions.html">bdlat_CustomizedTypeFunctions</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Longer Usage</a> </li>
<li>
<a href="#3.1.2">Shorter Usage</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a namespace defining customized type functions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="namespacebdlat__CustomizedTypeFunctions.html">bdlat_CustomizedTypeFunctions</a> </td><td>namespace for customized type functions  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="namespacebdlat__CustomizedTypeFunctions.html">bdlat_CustomizedTypeFunctions</a></code> <code>namespace</code> provided in this component defines parameterized functions that expose "customized type" behavior for "customized type" types. See the package-level documentation for a full description of "customized type" types. The functions in this namespace allow users to: <br/>
<br/>
<div class="fragment"><pre class="fragment">      o convert from base type to customized type (<span class="stringliteral">&#39;convertFromBaseType&#39;</span>).
      o convert from customized type to base type (<span class="stringliteral">&#39;convertToBaseType&#39;</span>).
</pre></div><br/>
<br/>
 Also, the meta-function <code>IsCustomizedType</code> contains a compile-time constant <code>VALUE</code> that is non-zero if the parameterized <code>TYPE</code> exposes "customized type" behavior through the <code><a class="el" href="namespacebdlat__CustomizedTypeFunctions.html">bdlat_CustomizedTypeFunctions</a></code> <code>namespace</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>BaseType</code> meta-function contains a typedef <code>Type</code> that specifies the base type of the value for the parameterized "customized type" type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component specializes all of these functions for types that have the <code><a class="el" href="structbdlat__TypeTraitBasicCustomizedType.html">bdlat_TypeTraitBasicCustomizedType</a></code> trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Types that do not have the <code><a class="el" href="structbdlat__TypeTraitBasicCustomizedType.html">bdlat_TypeTraitBasicCustomizedType</a></code> trait can be plugged into the <code>bdlat</code> framework. This is done by overloading the <code>bdlat_choice*</code> functions inside the namespace of the plugged in type. For example, suppose there is a type called <code>mine::Cusip</code> (defined in the example below). In order to plug this type into the <code>bdlat</code> framework as a "CustomizedType", the following functions must be declared and implemented in the <code>mine</code> namespace: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPE, <span class="keyword">typename</span> BASE_TYPE&gt;
      <span class="keywordtype">int</span> <a class="code" href="namespacebdlat__CustomizedTypeFunctions.html#aa29ccf4a304cfe4e490ce08bfe05a692">bdlat_customizedTypeConvertFromBaseType</a>(TYPE             *<span class="keywordtype">object</span>,
                                                  <span class="keyword">const</span> BASE_TYPE&amp;  value);
          <span class="comment">// Convert from the specified &#39;value&#39; to the specified customized</span>
          <span class="comment">// &#39;object&#39;.  Return 0 if successful and non-zero otherwise.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPE&gt;
      <span class="keyword">const</span> <span class="keyword">typename</span> BaseType&lt;TYPE&gt;::Type&amp;
      <a class="code" href="namespacebdlat__CustomizedTypeFunctions.html#a99fa5910302d070b64bef213eabef72b">bdlat_customizedTypeConvertToBaseType</a>(<span class="keyword">const</span> TYPE&amp; <span class="keywordtype">object</span>);
          <span class="comment">// Load into the specified &#39;result&#39; the value of the specified</span>
          <span class="comment">// &#39;object&#39;.</span>
</pre></div><br/>
<br/>
 Also, the <code>IsCustomizedType</code> meta-function must be specialized for the <code>mine::Cusip</code> type in the <code><a class="el" href="namespacebdlat__CustomizedTypeFunctions.html">bdlat_CustomizedTypeFunctions</a></code> namespace. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippets of code illustrate the usage of this component. Suppose we have a customized type called <code>Cusip</code>, holding an object of type <code>bsl::string</code> with a restriction that the length of the string cannot be longer than nine characters. We can obtain the value of the string using the following code: <br/>
<br/>
<div class="fragment"><pre class="fragment">    Cusip       myCusip = <span class="stringliteral">&quot;281C82UE&quot;</span>;
    <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> base    = <a class="code" href="namespacebdlat__CustomizedTypeFunctions.html#afd49f42b5928073afd39b29586203bf3">bdlat_CustomizedTypeFunctions::convertToBaseType</a>(
                                                                    myCusip);

    assert(<span class="stringliteral">&quot;281C82UE&quot;</span> == base);
</pre></div><br/>
<br/>
 Attempting to assign a string longer than nine characters will not succeed: <br/>
<br/>
<div class="fragment"><pre class="fragment">    <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> invalidCusip = <span class="stringliteral">&quot;1234567890&quot;</span>;

    <span class="keywordtype">int</span> retCode = <a class="code" href="namespacebdlat__CustomizedTypeFunctions.html#a7a52db17e57faba6dd99a2cd482834fb">bdlat_CustomizedTypeFunctions::convertFromBaseType</a>(
                                                               &amp;myCusip,
                                                               invalidCusip);

    assert(0 != retCode);
</pre></div><br/>
<br/>
 For the purpose of this example, the class definition is as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="bdlat__customizedtypefunctions_8h.html" title="Provide a namespace defining customized type functions.">bdlat_customizedtypefunctions.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="bdlb__string_8h.html" title="Provide utility functions on C-style and STL strings.">bdlb_string.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="bsls__assert_8h.html" title="Provide build-specific, runtime-configurable assertion macros.">bsls_assert.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;sstream&gt;</span>
<span class="preprocessor">  #include &lt;string&gt;</span>

  <span class="keyword">namespace </span>BloombergLP {

  <span class="keyword">namespace </span>mine {

  <span class="keyword">class </span>Cusip {
     <span class="comment">//  Identification number for the US and Canada.  It is a 9-digit number</span>
     <span class="comment">//  consisting of 8 digits and a check digit.  The Bloomberg ID will be</span>
     <span class="comment">// returned for Corp, Govt, Pfd if a CUSIP is not available.</span>

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE DATA MEMBERS</span>
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_value;  <span class="comment">// stored value</span>

      <span class="comment">// FRIENDS</span>
      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> Cusip&amp; lhs, <span class="keyword">const</span> Cusip&amp; rhs);
      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#af875b084e6111d26ceea345a0cc0b642">operator!=</a>(<span class="keyword">const</span> Cusip&amp; lhs, <span class="keyword">const</span> Cusip&amp; rhs);
    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> BaseType;

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> Cusip(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an object of type &#39;Cusip&#39; having the default value.</span>
          <span class="comment">// Use the optionally specified &#39;basicAllocator&#39; to supply memory.</span>
          <span class="comment">// If &#39;basicAllocator&#39; is 0, the currently installed default</span>
          <span class="comment">// allocator is used.</span>

      Cusip(<span class="keyword">const</span> Cusip&amp; original, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an object of type &#39;Cusip&#39; having the value</span>
          <span class="comment">// of the specified &#39;original&#39; object.  Use the optionally</span>
          <span class="comment">// specified &#39;basicAllocator&#39; to supply memory.  If</span>
          <span class="comment">// &#39;basicAllocator&#39; is 0, the currently installed default</span>
          <span class="comment">// allocator is used.</span>

      <span class="keyword">explicit</span> Cusip(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;  value,
                     <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *basicAllocator = 0);
          <span class="comment">// Create an object of type &#39;Cusip&#39; having the specified &#39;value&#39;.</span>
          <span class="comment">// Use the optionally specified &#39;basicAllocator&#39; to supply memory.</span>
          <span class="comment">// If &#39;basicAllocator&#39; is 0, the currently installed default</span>
          <span class="comment">// allocator is used.</span>

      ~Cusip();
          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      Cusip&amp; operator=(<span class="keyword">const</span> Cusip&amp; rhs);
          <span class="comment">// Assign to this object the value of the specified &#39;rhs&#39; object.</span>

      <span class="keywordtype">void</span> <a class="code" href="namespacebdlat__ValueTypeFunctions.html#a712743f16be0f4121bca7574c9face99">reset</a>();
          <span class="comment">// Reset this object to the default value (i.e., its value upon</span>
          <span class="comment">// default construction).</span>

      <span class="keywordtype">int</span> <a class="code" href="namespacebdlat__EnumFunctions.html#a87641f201c2ecf12ee9cc3a28ba7d61a">fromString</a>(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; value);
         <span class="comment">// Convert from the specified &#39;value&#39; to this type.  Return 0 if</span>
          <span class="comment">// successful and non-zero otherwise.</span>

      <span class="comment">// ACCESSORS</span>
      bsl::ostream&amp; <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(bsl::ostream&amp; stream,
                          <span class="keywordtype">int</span>           level = 0,
                          <span class="keywordtype">int</span>           spacesPerLevel = 4) <span class="keyword">const</span>;
          <span class="comment">// Format this object to the specified output &#39;stream&#39; at the</span>
          <span class="comment">// optionally specified indentation &#39;level&#39; and return a reference</span>
          <span class="comment">// to the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally</span>
          <span class="comment">// specify &#39;spacesPerLevel&#39;, the number of spaces per indentation</span>
          <span class="comment">// level for this and all of its nested objects.  Each line is</span>
          <span class="comment">// indented by the absolute value of &#39;level * spacesPerLevel&#39;.</span>
          <span class="comment">// If &#39;level&#39; is negative, suppress indentation of the first</span>
          <span class="comment">// line.  If &#39;spacesPerLevel&#39; is negative, suppress line breaks</span>
          <span class="comment">// and format the entire output on one line.  If &#39;stream&#39; is</span>
          <span class="comment">// initially invalid, this operation has no effect.  Note that a</span>
          <span class="comment">// trailing newline is provided in multiline mode only.</span>

      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; <a class="code" href="namespacebdlat__EnumFunctions.html#ac5cbb9dfcc2f4ac0e34dc29101a41fe7">toString</a>() <span class="keyword">const</span>;
          <span class="comment">// Convert this value to &#39;bsl::string&#39;.</span>
  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> Cusip&amp; lhs, <span class="keyword">const</span> Cusip&amp; rhs);

      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects</span>
      <span class="comment">// have the same value, and &#39;false&#39; otherwise.  Two attribute objects</span>
      <span class="comment">// have the same value if each respective attribute has the same</span>
      <span class="comment">// value.</span>

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#af875b084e6111d26ceea345a0cc0b642">operator!=</a>(<span class="keyword">const</span> Cusip&amp; lhs, <span class="keyword">const</span> Cusip&amp; rhs);

      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects</span>
      <span class="comment">// do not have the same value, and &#39;false&#39; otherwise.  Two attribute</span>
      <span class="comment">// objects do not have the same value if one or more respective</span>
      <span class="comment">// attributes differ in values.</span>

  <span class="keyword">inline</span>
  bsl::ostream&amp; <a class="code" href="namespacebalb.html#a777d713a1c54d1359c8cb8144cc50b7a">operator&lt;&lt;</a>(bsl::ostream&amp; stream, <span class="keyword">const</span> Cusip&amp; rhs);
      <span class="comment">// Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and</span>
      <span class="comment">// return a reference to the modifiable &#39;stream&#39;.</span>
</pre></div><br/>
<br/>
 The class implementation is straightforward and is deferred to the end of this usage example. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We can now make <code>Cusip</code> expose "customized type" behavior by implementing <code><a class="el" href="namespacebdlat__CustomizedTypeFunctions.html">bdlat_CustomizedTypeFunctions</a></code> for <code>Cusip</code>. The first method (the longer one) overloads all the <code>bdlat_customizedType*</code> functions. In the second method, we show how to bypass this by simply declaring the class <code>mine::Cusip</code> to have the <code><a class="el" href="structbdlat__TypeTraitBasicCustomizedType.html">bdlat_TypeTraitBasicCustomizedType</a></code> trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="longer_usage"></a> <a class="anchor" id="usage.longer_usage"></a> <a class="anchor" id="description.usage.longer_usage"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Longer Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we should forward declare all the functions that we will implement inside the <code>mine</code> namespace: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPE, <span class="keyword">typename</span> BASE_TYPE&gt;
      <span class="keywordtype">int</span> <a class="code" href="namespacebdlat__CustomizedTypeFunctions.html#aa29ccf4a304cfe4e490ce08bfe05a692">bdlat_customizedTypeConvertFromBaseType</a>(TYPE             *<span class="keywordtype">object</span>,
                                                  <span class="keyword">const</span> BASE_TYPE&amp;  value);
          <span class="comment">// Convert from the specified &#39;value&#39; to the specified customized</span>
          <span class="comment">// &#39;object&#39;.  Return 0 if successful and non-zero otherwise.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPE&gt;
      <span class="keyword">const</span> <span class="keyword">typename</span> BaseType&lt;TYPE&gt;::Type&amp;
      <a class="code" href="namespacebdlat__CustomizedTypeFunctions.html#a99fa5910302d070b64bef213eabef72b">bdlat_customizedTypeConvertToBaseType</a>(<span class="keyword">const</span> TYPE&amp; <span class="keywordtype">object</span>);
          <span class="comment">// Load into the specified &#39;result&#39; the value of the specified</span>
          <span class="comment">// &#39;object&#39;.</span>

  } <span class="comment">// close namespace &#39;mine&#39;</span>
</pre></div><br/>
<br/>
 Next, we provide the definitions for each of these functions: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="comment">// MANIPULATORS</span>
 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPE, <span class="keyword">typename</span> BASE_TYPE&gt;
 <span class="keywordtype">int</span> <a class="code" href="namespacebdlat__CustomizedTypeFunctions.html#aa29ccf4a304cfe4e490ce08bfe05a692">mine::bdlat_customizedTypeConvertFromBaseType</a>(TYPE             *<span class="keywordtype">object</span>,
                                                   <span class="keyword">const</span> BASE_TYPE&amp;  value);
 {
     <span class="keywordflow">return</span> <span class="keywordtype">object</span>-&gt;fromString(value);
 }

 <span class="comment">// ACCESSORS</span>
 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPE&gt;
 <span class="keyword">const</span> <span class="keyword">typename</span> BaseType&lt;TYPE&gt;::Type&amp;
 <a class="code" href="namespacebdlat__CustomizedTypeFunctions.html#a99fa5910302d070b64bef213eabef72b">mine::bdlat_customizedTypeConvertToBaseType</a>(<span class="keyword">const</span> TYPE&amp; <span class="keywordtype">object</span>);
 {
     <span class="keywordflow">return</span> <span class="keywordtype">object</span>.toString();
 }
</pre></div><br/>
<br/>
 Finally, we need to specialize the <code>IsCustomizedType</code> meta-function in the <code><a class="el" href="namespacebdlat__CustomizedTypeFunctions.html">bdlat_CustomizedTypeFunctions</a></code> namespace for the <code>mine::Cusip</code> type. This makes the <code>bdlat</code> infrastructure recognize <code>mine::Cusip</code> as a customized type abstraction: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">namespace </span>bdlat_CustomizedTypeFunctions {

      <span class="keyword">template</span> &lt;&gt;
      <span class="keyword">struct </span>IsCustomizedType&lt;mine::Cusip&gt; {
          <span class="keyword">enum</span> { <a class="code" href="structbdlat__CustomizedTypeFunctions_1_1IsCustomizedType.html#a81c33740d36828eee5e01131ce6c6ac1a312b227a3ce756bf084b645ab9b6ca71">VALUE</a> = 1 };
      };

  } <span class="comment">// close namespace &#39;bdlat_CustomizedTypeFunctions&#39;</span>
  } <span class="comment">// close namespace &#39;BloombergLP&#39;</span>
</pre></div><br/>
<br/>
 The <code>bdlat</code> infrastructure (and any component that uses this infrastructure) will now recognize <code>mine::Cusip</code> as a "customized" type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="shorter_usage"></a> <a class="anchor" id="usage.shorter_usage"></a> <a class="anchor" id="description.usage.shorter_usage"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Shorter Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>We can bypass all the code from the longer usage example by simply declaring <code>mine::Cusip</code> to have the <code><a class="el" href="structbdlat__TypeTraitBasicCustomizedType.html">bdlat_TypeTraitBasicCustomizedType</a></code> trait as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// TRAITS</span>

  <a class="code" href="group__bdlat__typetraits.html#gaaedb1913e0aade90c09b9b4bb087ad8a">BDLAT_DECL_CUSTOMIZEDTYPE_WITH_ALLOCATOR_TRAITS</a>(mine::Cusip)
</pre></div><br/>
<br/>
 Again, the <code>bdlat</code> infrastructure (and any component that uses this infrastructure) will now recognize <code>mine::Cusip</code> as a "customized" type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, suppose we have the following XML data: <br/>
<br/>
<div class="fragment"><pre class="fragment">  &lt;?xml version=<span class="stringliteral">&#39;1.0&#39;</span> encoding=<span class="stringliteral">&#39;UTF-8&#39;</span> ?&gt;
  &lt;Cusip&gt;
      &lt;value&gt;<span class="stringliteral">&quot;281C82UE&quot;</span>&lt;/value&gt;
  &lt;/Cusip&gt;
</pre></div><br/>
<br/>
 Using the <code>balxml_decoder</code> component, we can load this XML data into a <code>mine::Cusip</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="balxml__decoder_8h.html" title="Provide a generic translation from XML into C++ objects.">balxml_decoder.h</a>&gt;</span>

  <span class="keywordtype">void</span> decodeMyCustomizedTypeFromXML(bsl::istream&amp; inputData)
  {
      <span class="keyword">using namespace </span>BloombergLP;

      Cusip object;

      <a class="code" href="classbalxml_1_1DecoderOptions.html">balxml::DecoderOptions</a> options;
      <a class="code" href="classbalxml_1_1MiniReader.html">balxml::MiniReader</a>     reader;
      <a class="code" href="classbalxml_1_1ErrorInfo.html">balxml::ErrorInfo</a>      errInfo;

      <a class="code" href="classbalxml_1_1Decoder.html">balxml::Decoder</a> decoder(&amp;options, &amp;reader, &amp;errInfo);
      <span class="keywordtype">int</span> result = decoder.decode(inputData, &amp;<span class="keywordtype">object</span>);

      assert(0          == result);
      assert(<span class="stringliteral">&quot;281C82UE&quot;</span> == <span class="keywordtype">object</span>.<a class="code" href="namespacebdlat__EnumFunctions.html#ac5cbb9dfcc2f4ac0e34dc29101a41fe7">toString</a>());
  }
</pre></div><br/>
<br/>
 Note that the <code>bdlat</code> framework can be used for functionality other than encoding/decoding into XML. When <code>mine::Cusip</code> is plugged into the framework, then it will be automatically usable within the framework. For example, the following snippets of code will convert a string from a stream and load it into a <code>Cusip</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPE&gt;
  <span class="keywordtype">int</span> readCusip(bsl::istream&amp; stream, TYPE *<span class="keywordtype">object</span>)
  {
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> value;
      stream &gt;&gt; value;

      <span class="keywordflow">return</span> <a class="code" href="namespacebdlat__CustomizedTypeFunctions.html#a7a52db17e57faba6dd99a2cd482834fb">bdlat_CustomizedType::convertFromBaseType</a>(cusip, value);
  }
</pre></div><br/>
<br/>
 Now we have a generic function that takes an input stream and a <code>Cusip</code> object, and inputs its value. We can use this generic function as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> usageExample()
  {
      <span class="keyword">using namespace </span>BloombergLP;

      <a class="code" href="classbsl_1_1basic__stringstream.html">bsl::stringstream</a> ss;
      mine::Cusip object;

      ss &lt;&lt; <span class="stringliteral">&quot;281C82UE\n1234567890\n&quot;</span>;

      assert(0          == readCusip(ss, &amp;<span class="keywordtype">object</span>));
      assert(<span class="stringliteral">&quot;281C82UE&quot;</span> == <span class="keywordtype">object</span>.<a class="code" href="namespacebdlat__EnumFunctions.html#ac5cbb9dfcc2f4ac0e34dc29101a41fe7">toString</a>());

      assert(0          != readCusip(ss, &amp;<span class="keywordtype">object</span>));
  }
</pre></div><br/>
<br/>
 This concludes the usage example. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For completeness, we finish by providing the straightforward details of the implementation of the class <code>Cusip</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>

  <span class="keyword">inline</span>
  Cusip::Cusip(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_value(basicAllocator)
  {
  }

  <span class="keyword">inline</span>
  Cusip::Cusip(<span class="keyword">const</span> Cusip&amp; original, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_value(original.d_value, basicAllocator)
  {
  }

  <span class="keyword">inline</span>
  Cusip::Cusip(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; value, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_value(value, basicAllocator)
  {
  }

  <span class="keyword">inline</span>
  Cusip::~Cusip()
  {
  }

  <span class="comment">// MANIPULATORS</span>

  <span class="keyword">inline</span>
  Cusip&amp; Cusip::operator=(<span class="keyword">const</span> Cusip&amp; rhs)
  {
      d_value = rhs.d_value;
      <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> <a class="code" href="namespacebdlat__ValueTypeFunctions.html#a712743f16be0f4121bca7574c9face99">Cusip::reset</a>()
  {
      <span class="comment">// bdlat_ValueTypeFunctions::reset(&amp;d_value);</span>
      d_value.erase();
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> <a class="code" href="namespacebdlat__EnumFunctions.html#a87641f201c2ecf12ee9cc3a28ba7d61a">Cusip::fromString</a>(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; value)
  {
      <span class="keyword">enum</span> { SUCCESS = 0, FAILURE = -1 };

      globalFlag = 1;

      <span class="keywordflow">if</span> (9 &lt; value.<a class="code" href="group__bslstl__string.html#ga8b5592bfab066f30c8e3948106b8c9ad">size</a>()) {
          <span class="keywordflow">return</span> FAILURE;
      }

      d_value = value;

      <span class="keywordflow">return</span> SUCCESS;
  }

  <span class="comment">// ACCESSORS</span>

  <span class="keyword">inline</span>
  bsl::ostream&amp; <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">Cusip::print</a>(bsl::ostream&amp; stream,
                             <span class="keywordtype">int</span>           level,
                             <span class="keywordtype">int</span>           spacesPerLevel)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">bdlb::PrintMethods::print</a>(stream,
                                      d_value,
                                      level,
                                      spacesPerLevel);
  }

  <span class="keyword">inline</span>
  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; <a class="code" href="namespacebdlat__EnumFunctions.html#ac5cbb9dfcc2f4ac0e34dc29101a41fe7">Cusip::toString</a>()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      globalFlag = 2;

      <span class="keywordflow">return</span> d_value;
  }

  <span class="comment">// FREE OPERATORS</span>

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">geom::operator==</a>(<span class="keyword">const</span> geom::Cusip&amp; lhs,
                                   <span class="keyword">const</span> geom::Cusip&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.d_value == rhs.d_value;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#af875b084e6111d26ceea345a0cc0b642">geom::operator!=</a>(<span class="keyword">const</span> geom::Cusip&amp; lhs,
                                   <span class="keyword">const</span> geom::Cusip&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.d_value != rhs.d_value;
  }

  <span class="keyword">inline</span>
  bsl::ostream&amp; <a class="code" href="namespacebalb.html#a777d713a1c54d1359c8cb8144cc50b7a">geom::operator&lt;&lt;</a>(bsl::ostream&amp; stream,
                                            <span class="keyword">const</span> geom::Cusip&amp; rhs)
  {
      <span class="keywordflow">return</span> rhs.print(stream, 0, -1);
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:33 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
