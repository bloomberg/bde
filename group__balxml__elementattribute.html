<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: balxml_elementattribute Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component balxml_elementattribute<br/>
<small>
[<a class="el" href="group__balxml.html">Package balxml</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide the properties of an attribute in an XML element tag.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebalxml.html">balxml</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Not Value Semantic</a> </li>
<li>
<a href="#3.2">Thread Safety</a> </li>
<li>
<a href="#3.3">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide the properties of an attribute in an XML element tag. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a> </td><td>Properties of an attribute in an XML element tag.  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__balxml__reader.html" title="Provide common reader protocol for parsing XML documents.">Component balxml_reader</a>, <a class="el" href="group__balxml__prefixstack.html" title="Provide a unique integer ID for each XML namespace.">Component balxml_prefixstack</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a class, <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code>, that encapsulates the name, namespace, and value of an attribute within an element in an XML document, along with a flag indicating whether the value comes from the default value in the document's schema. There are accessors to return the attribute name as a qualified name, namespace prefix, namespace URI, namespace ID (in a namespace registry), and local name (without the prefix). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If a namespace prefix stack and a qualified name are provided at construction (or via the <code>reset</code> method), then all of the other facets of the name can be computed automatically. For efficiency reasons, these various decompositions of the attribute name are computed only when needed and cached within the <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> structure. The caller can supply any or all of these computed facets in the constructor or <code>reset</code> method. Explicitly supplying a facet prevents it from being computed, thus saving processing time. If the object is constructed with explicit values for all facets of the name, then the prefix stack is never used and may be null. If an explicitly-supplied facet differs from the value that would have been computed otherwise, then the facets returned by the accessors will be inconsistent with one-another. This inconsistency is deliberately permitted so that an program may construct a <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> even when some parts of of the name are not yet known, e.g., if the prefix URI is known but the qualified name is not. If the qualified name facet is zero, then no other facets will be computed -- their original values will be returned from the accessors. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="not_value_semantic"></a> <a class="anchor" id="description.not_value_semantic"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Not Value Semantic: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> is not a value-semantic class. It provides copy construction and assignment, but does not provide equality or persistence operators. Copying a <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> object copies all of its pointer facets but does not make copies of the pointed-to strings or objects. The presence of copy operations makes it possible to use <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> with container class templates. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> object does not own any of its pointer facets and it performs no memory management. This means that a <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> object can be invalidated by modifying or deleting any of the pointed-to entities. Calling an accessor on an invalid <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> is unsafe because the accessor may return an invalid pointer. However an invalid object may be safely destroyed or reset. Components that set or return a <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> object should provide clear documentation describing the events that will cause the resulting <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> object to become invalid (see <code><a class="el" href="classbalxml_1_1Reader.html">balxml::Reader</a></code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is safe to access or modify two <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> objects simultaneously, each from a separate thread. It is safe to access a single <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> object simultaneously from two or more separate threads, provided no other thread is simultaneously modifying the object. It is not safe to access or modify a <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> object in one thread while another thread modifies the same object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> object holds pointers to objects that it does not own and which can be modified independently of the <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> object. It is not safe to modify or delete any of these object in one thread while accessing or modifying the <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> object in another thread. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following function parses an XML-style attribute assignment in the form "qname='value'", where <code>qname</code> can be a qualified name in the form, "prefix:localName". The prefix (if any) must be registered in the specified <code>prefixStack</code> object. Either single or double quotes may be used to enclose the attribute value. The parsed attribute is stored in the specified <code>attribute</code> object of type <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code>. Note that this function modifies the input string by inserting null characters, rather than copying the component parts into allocated memory. This is a realistic interface for a function used within an XML parser that has already copied the XML stream into allocated memory. Also note that this function does not interpret character escapes such as "&amp;amp;". <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> parseAttribute(<a class="code" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a>  *attribute,
                     <span class="keywordtype">char</span>                     *attributeString,
                     <span class="keyword">const</span> <a class="code" href="classbalxml_1_1PrefixStack.html">balxml::PrefixStack</a> *prefixStack)
  {
</pre></div><br/>
<br/>
 First, find the end of the qualified name, i.e., the <code>=</code> character: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">char</span> *qname    = attributeString;
      <span class="keywordtype">char</span> *equalPtr = bsl::strchr(qname, <span class="charliteral">&#39;=&#39;</span>);
      <span class="keywordflow">if</span> (0 == equalPtr) {
          <span class="keywordflow">return</span> -1;
      }
</pre></div><br/>
<br/>
 Then find out which quote character is used to start the value string <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">char</span> quote = *(equalPtr + 1);
      <span class="keywordflow">if</span> (quote != <span class="charliteral">&#39;\&#39;&#39;</span> &amp;&amp; quote != <span class="charliteral">&#39;&quot;&#39;</span>) {
          <span class="keywordflow">return</span> -1;
      }
</pre></div><br/>
<br/>
 The value string starts after the opening quote and extends until a matching quote: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">char</span> *value    = equalPtr + 2;
      <span class="keywordtype">char</span> *endValue = bsl::strchr(value, quote);
      <span class="keywordflow">if</span> (0 == endValue) {
          <span class="keywordflow">return</span> -1;
      }
</pre></div><br/>
<br/>
 Once we have successfully parsed the string, chop it into pieces by putting a null terminator at the end of the qualified name and at the end of the value string: <br/>
<br/>
<div class="fragment"><pre class="fragment">      *equalPtr = <span class="charliteral">&#39;\0&#39;</span>;    <span class="comment">// Terminate qualified name</span>
      *endValue = <span class="charliteral">&#39;\0&#39;</span>;    <span class="comment">// Terminate value string</span>
</pre></div><br/>
<br/>
 Use the prefix stack, qname, and value to set the attribute object. All other arguments are defaulted and will be computed as needed. <br/>
<br/>
<div class="fragment"><pre class="fragment">      attribute-&gt;<a class="code" href="classbalxml_1_1ElementAttribute.html#a53e27ffce1363bb797c26ac16d2b7d96">reset</a>(prefixStack, qname, value);
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 Before calling the <code>parseAttribute</code> function, it is necessary to create a namespace registry and prefix stack, as well as to register one or more prefixes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main()
  {
      <a class="code" href="classbalxml_1_1NamespaceRegistry.html">balxml::NamespaceRegistry</a> registry;
      <a class="code" href="classbalxml_1_1PrefixStack.html">balxml::PrefixStack</a> prefixes(&amp;registry);
      <span class="keywordtype">int</span> cal = prefixes.pushPrefix(<span class="stringliteral">&quot;cal&quot;</span>,
                                <span class="stringliteral">&quot;http://www.bloomberg.com/schemas/calendar&quot;</span>);
      <span class="keywordtype">int</span> math = prefixes.pushPrefix(<span class="stringliteral">&quot;math&quot;</span>,
                                    <span class="stringliteral">&quot;http://www.bloomberg.com/schemas/math&quot;</span>);
      <span class="keywordtype">int</span> app = prefixes.pushPrefix(<span class="stringliteral">&quot;&quot;</span>,  <span class="comment">// Default namespace</span>
                                    <span class="stringliteral">&quot;http://www.bloomberg.com/schemas/app&quot;</span>);
</pre></div><br/>
<br/>
 Now we can parse an attribute string and the <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> object will provide detailed information about it. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">char</span> attrStr1[] = <span class="stringliteral">&quot;cal:date=&#39;12-07-2006&#39;&quot;</span>;
      <a class="code" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a> attribute1;
      <span class="keywordtype">int</span> ret = parseAttribute(&amp;attribute1, attrStr1, &amp;prefixes);

      assert(0 == bsl::strcmp(<span class="stringliteral">&quot;cal:date&quot;</span>, attribute1.<a class="code" href="classbalxml_1_1ElementAttribute.html#a6ba94b2462b6709c9e09473cdbc99fa9">qualifiedName</a>()));
      assert(0 == bsl::strcmp(<span class="stringliteral">&quot;12-07-2006&quot;</span>, attribute1.<a class="code" href="classbalxml_1_1ElementAttribute.html#a14a4ad60fc20edc194d6d92dcf9c7821">value</a>()));
      assert(0 == bsl::strcmp(<span class="stringliteral">&quot;date&quot;</span>, attribute1.<a class="code" href="classbalxml_1_1ElementAttribute.html#a04681af543a284e9950a4b2765a85152">localName</a>()));
      assert(0 == bsl::strcmp(<span class="stringliteral">&quot;cal&quot;</span>, attribute1.<a class="code" href="classbalxml_1_1ElementAttribute.html#ad8ebc9d957c366c35ac78637b630aaed">prefix</a>()));
      assert(cal == attribute1.<a class="code" href="classbalxml_1_1ElementAttribute.html#ab3bda7050c617e24c68c0d6ec83df729">namespaceId</a>());
      assert(0 == bsl::strcmp(<span class="stringliteral">&quot;http://www.bloomberg.com/schemas/calendar&quot;</span>,
                              attribute1.<a class="code" href="classbalxml_1_1ElementAttribute.html#ac8032a23357b1cd17f32c4ddf1594465">namespaceUri</a>()));
      assert(0 == attribute1.<a class="code" href="classbalxml_1_1ElementAttribute.html#a99ad6ed678833dadef860a7a9f76bc3c">flags</a>());
</pre></div><br/>
<br/>
 Results are slightly different when the attribute name has no prefix: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">char</span> attrStr2[] = <span class="stringliteral">&quot;name=\&quot;Bloomberg, L.P.\&quot;&quot;</span>;
      <a class="code" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a> attribute2;
      ret = parseAttribute(&amp;attribute2, attrStr2, &amp;prefixes);

      assert(0 == bsl::strcmp(<span class="stringliteral">&quot;name&quot;</span>, attribute2.<a class="code" href="classbalxml_1_1ElementAttribute.html#a6ba94b2462b6709c9e09473cdbc99fa9">qualifiedName</a>()));
      assert(0 == bsl::strcmp(<span class="stringliteral">&quot;Bloomberg, L.P.&quot;</span>, attribute2.<a class="code" href="classbalxml_1_1ElementAttribute.html#a14a4ad60fc20edc194d6d92dcf9c7821">value</a>()));
      assert(0 == bsl::strcmp(<span class="stringliteral">&quot;name&quot;</span>, attribute2.<a class="code" href="classbalxml_1_1ElementAttribute.html#a04681af543a284e9950a4b2765a85152">localName</a>()));
</pre></div><br/>
<br/>
 As per the XML namespace standard, an attribute with no namespace prefix does NOT inherit the default namespace but rather has NO namespace: <br/>
<br/>
<div class="fragment"><pre class="fragment">      assert(0 == bsl::strcmp(<span class="stringliteral">&quot;&quot;</span>, attribute2.<a class="code" href="classbalxml_1_1ElementAttribute.html#ad8ebc9d957c366c35ac78637b630aaed">prefix</a>()));
      assert(-1 == attribute2.<a class="code" href="classbalxml_1_1ElementAttribute.html#ab3bda7050c617e24c68c0d6ec83df729">namespaceId</a>());
      assert(0 == bsl::strcmp(<span class="stringliteral">&quot;&quot;</span>, attribute2.<a class="code" href="classbalxml_1_1ElementAttribute.html#ac8032a23357b1cd17f32c4ddf1594465">namespaceUri</a>()));
      assert(0 == attribute2.<a class="code" href="classbalxml_1_1ElementAttribute.html#a99ad6ed678833dadef860a7a9f76bc3c">flags</a>());
</pre></div><br/>
<br/>
 A <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> does not need to be generated by parsing XML code. If a specific facet of the object is set to a non-null value, then that value will be returned by the corresponding accessor even if it is inconsistent with the other values in the object. For example, the following constructs a valid <code><a class="el" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a></code> object, even though the prefix value does not agree with the qualified name: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbalxml_1_1ElementAttribute.html">balxml::ElementAttribute</a> attribute3(&amp;prefixes,
                                         <span class="stringliteral">&quot;math:product&quot;</span>, <span class="stringliteral">&quot;4.5&quot;</span>, <span class="stringliteral">&quot;cal&quot;</span>);
</pre></div><br/>
<br/>
 There is no consistency checking, and the mismatched prefix is simply returned by the accessor: <br/>
<br/>
<div class="fragment"><pre class="fragment">      assert(0 == bsl::strcmp(<span class="stringliteral">&quot;math:product&quot;</span>, attribute3.qualifiedName()));
      assert(0 == bsl::strcmp(<span class="stringliteral">&quot;product&quot;</span>, attribute3.localName()));
      assert(0 == bsl::strcmp(<span class="stringliteral">&quot;cal&quot;</span>, attribute3.prefix()));
</pre></div><br/>
<br/>
 Note that the ability to create inconsistent objects is a deliberate feature. It allows parsers to construct <code>balxml::Attribute</code> objects before all information is known, e.g., before the namespace is registered with the prefix stack. Consistency checking also reduces performance. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:31 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
