<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// btlsos_tcptimedcbconnector.h                                       -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BTLSOS_TCPTIMEDCBCONNECTOR
#define INCLUDED_BTLSOS_TCPTIMEDCBCONNECTOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a non-blocking connector (with timeout) to TCP servers.
//
//@CLASSES:
//  btlsos::TcpTimedCbConnector: non-blocking timed channel allocator
//
//@SEE_ALSO: btlsos_tcptimedcbchannel btlso_tcptimereventmanager
//           btlsos_tcptimedcbacceptor btlsos_tcpcbchannel
//           btlso_socketoptutil btlso_inetstreamsocketfactory
//
//@DESCRIPTION: This component provides a non-blocking single-port connector of
// TCP connections with timeout capability, &#39;btlsos::TcpTimedCbConnector&#39;, that
// adheres to the &#39;btlsc::TimedCbChannelAllocator&#39; protocol.  Both timed and
// non-timed (callback) channels can be allocated in a timed and non-timed
// fashion as indicated by the following table:
//..
//                           +=========================================+
//                           |            Accept operation             |
//       +=============================================================+
//       |   Result channel  |        Timed         |    Non-Timed     |
//       +-------------------+----------------------+------------------+
//       |      Timed        | &#39;timedAllocateTimed&#39; | &#39;allocateTimed&#39;  |
//       +-------------------+----------------------+------------------+
//       |    Non-Timed      |    &#39;timedAllocate&#39;   |    &#39;allocate&#39;    |
//       +=============================================================+
//..
// Allocations (both timed and non-timed) follow the asynchronous
// (callback-based) nature of the &#39;btesc&#39; protocol; the callbacks are invoked
// when an allocation succeeds or an error occurs.  The connector uses a
// user-installed socket event manager in order to monitor (in a non-blocking
// fashion) the connecting socket for completion of a connection.
//
// The connector has the flexibility of changing the address of the peer server
// at run-time with no effect on the state of managed channels.  The enqueued
// (i.e., not-yet-completed) allocation requests will, however, fail (without
// invalidating the allocator) and the associated callbacks will be invoked
// when the peer address is changed.
//
///Thread Safety
///-------------
// The connector is *thread* *safe*, meaning that any operation can be called
// on *distinct* *instances* from different threads without any side-effects
// (which, generally speaking, means that there is no &#39;static&#39; data), but not
// *thread* *enabled* (i.e., two threads cannot safely call methods on the
// *same* *instance* without external synchronization).  This connector is not
// *async-safe*, meaning that one or more functions cannot be invoked safely
// from a signal handler.  Note that the thread safety of the connector is
// subject to the thread safety of the supplied socket event manager.  If
// distinct instances of this connector use the *same* instance of a socket
// event manager, both connectors are thread-safe if and only if that socket
// event manager is *THREAD* *ENABLED*.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: An Example Echo Client
///- - - - - - - - - - - - - - - - -
// The following usage example shows a possible implementation of an echo
// client.  An echo client sends connection requests to an echo server, and for
// every connection, sends and receives data.  Various configuration parameters
// such as the timeout values, the number of connections, the port number, and
// the number of messages to be sent should be passed into a client object.
//..
//  class my_EchoClient {
//      enum {
//          k_BUFFER_SIZE = 100
//      };
//
//      btlsos::TcpTimedCbConnector d_allocator;
//      bsls::TimeInterval          d_connectTimeout;
//      bsls::TimeInterval          d_readTimeout;
//      bsls::TimeInterval          d_writeTimeout;
//      char                        d_controlBuffer[k_BUFFER_SIZE];
//      int                         d_numConnections;
//      int                         d_maxConnections;
//      int                         d_numMessages;
//
//      bsl::function&lt;void(btlsc::TimedCbChannel*, int)&gt;
//                                  d_allocateFunctor;
//
//      void allocateCb(btlsc::TimedCbChannel *channel, int status);
//          // Invoked by the socket event manager when a connection is
//          // accepted.
//
//      void bufferedReadCb(const char            *buffer,
//                          int                    status,
//                          int                    asyncStatus,
//                          btlsc::TimedCbChannel *channel,
//                          int                    sequence);
//
//      void writeCb(int                    status,
//                   int                    asyncStatus,
//                   btlsc::TimedCbChannel *channel,
//                   int                    sequence);
//
//    private:
//      // Not implemented:
//      my_EchoClient(const my_EchoClient&amp;);
//      my_EchoClient&amp; operator=(const my_EchoClient&amp;);
//
//    public:
//      // CREATORS
//      my_EchoClient(
//         btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt; *factory,
//         btlso::TimerEventManager                       *manager,
//         int                                             maxConnections,
//         int                                             numMessages,
//         bslma::Allocator                               *basicAllocator = 0);
//
//      ~my_EchoClient();
//
//      //  MANIPULATORS
//      int setPeer(const btlso::IPv4Address&amp; address);
//          // Set the address of the echo server to the specified &#39;address&#39;,
//          // and start sending messages to the server.
//  };
//
//  // CREATORS
//  my_EchoClient::my_EchoClient(
//              btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt; *factory,
//              btlso::TimerEventManager                       *manager,
//              int                                             maxConnections,
//              int                                             numMessages,
//              bslma::Allocator                               *basicAllocator)
//  : d_allocator(factory, manager, basicAllocator)
//  , d_connectTimeout(120, 0)
//  , d_readTimeout(20.0)
//  , d_writeTimeout(5,0)
//  , d_numConnections(0)
//  , d_maxConnections(maxConnections)
//  , d_numMessages(numMessages)
//  {
//      assert(factory);
//      assert(manager);
//      d_allocateFunctor = bdlf::MemFnUtil::memFn(&amp;my_EchoClient::allocateCb,
//                                                 this);
//
//      bsl::memset(d_controlBuffer, &#39;A&#39;, k_BUFFER_SIZE);
//      ((int*)d_controlBuffer)[0] = k_BUFFER_SIZE;
//      ((int*)d_controlBuffer)[1] = k_BUFFER_SIZE;
//  }
//
//  my_EchoClient::~my_EchoClient() {
//  }
//..
// All the work of accepting connections and reading/writing the data is done
// in the (private) callback methods of &#39;my_EchoClient&#39;.  When the connection
// is established and the &#39;allocateCb&#39; method is invoked, the buffered write
// with timeout is initiated on the channel and another allocation request is
// enqueued.  If any error occurs while allocating, the acceptor is shut down.
// If any error, including timeout, occurs while reading or writing data, the
// channel is shut down.  Note that the allocation functor is cached to improve
// performance:
//..
//  // MANIPULATORS
//  void my_EchoClient::allocateCb(btlsc::TimedCbChannel *channel,
//                                 int                    status) {
//      if (channel) {
//          // Connected to a server.  Issue a buffered write request.
//
//          bsl::function&lt;void(int, int)&gt; callback(
//                                bdlf::BindUtil::bind(&amp;my_EchoClient::writeCb,
//                                                     this,
//                                                     _1,
//                                                     _2,
//                                                     channel,
//                                                     0));
//          if (channel-&gt;timedBufferedWrite(d_controlBuffer,
//                                          k_BUFFER_SIZE,
//                                          bdlt::CurrentTime::now()
//                                               + d_writeTimeout, callback)) {
//              puts(&quot;Failed to enqueue write request.&quot;);
//              assert(channel-&gt;isInvalidWrite());
//              d_allocator.deallocate(channel);
//          }
//
//          if (d_maxConnections &gt; ++d_numConnections) {
//              int s = d_allocator.timedAllocateTimed(d_allocateFunctor,
//                                                     bdlt::CurrentTime::now()
//                                                         + d_connectTimeout);
//              assert(0 == s);
//          }
//          return;                                                   // RETURN
//      }
//
//      assert(0 &gt;= status);    // Interrupts are not enabled.
//      if (0 == status) {
//          cerr &lt;&lt; &quot;Timed out connecting to the server.&quot; &lt;&lt; endl;
//      }
//      else {
//          // Hard-error accepting a connection, invalidate the allocator.
//          printf(&quot;Non-recoverable error connecting to the server %d &quot;
//                 &quot;(Connection %d of of %d)\n&quot;,
//                 status, d_numConnections, d_maxConnections);
//          d_allocator.invalidate();
//          return;                                                   // RETURN
//      }
//      // In any case, except for hard error on allocator, enqueue another
//      // connect request
//      if (d_maxConnections &gt; ++d_numConnections) {
//          int s = d_allocator.timedAllocateTimed(d_allocateFunctor,
//                                                 bdlt::CurrentTime::now()
//                                                         + d_connectTimeout);
//          assert(0 == s);
//      }
//  }
//
//  void my_EchoClient::bufferedReadCb(const char            *buffer,
//                                     int                    status,
//                                     int                    asyncStatus,
//                                     btlsc::TimedCbChannel *channel,
//                                     int                    sequence)
//  {
//      assert(channel);
//      if (0 &lt; status) {
//          assert(k_BUFFER_SIZE == status);
//          assert(0 == bsl::memcmp(buffer, d_controlBuffer, k_BUFFER_SIZE));
//
//          // If we&#39;re not done -- enqueue another request
//          if (sequence &lt; d_numMessages) {
//              bsl::function&lt;void(int, int)&gt; callback(
//                                bdlf::BindUtil::bind(&amp;my_EchoClient::writeCb,
//                                                     this,
//                                                     _1,
//                                                     _2,
//                                                     channel,
//                                                     sequence + 1));
//              if (channel-&gt;timedBufferedWrite(d_controlBuffer,
//                                              k_BUFFER_SIZE,
//                                              bdlt::CurrentTime::now()
//                                                 + d_writeTimeout, callback))
//                  {
//                      puts(&quot;Failed to enqueue write request.&quot;);
//                      assert(channel-&gt;isInvalidWrite());
//                      d_allocator.deallocate(channel);
//                  }
//          }
//          else {
//              d_allocator.deallocate(channel);
//          }
//      }
//      else if (0 == status) {
//          if (0 &gt; asyncStatus) {
//          }
//          else {
//              printf(&quot;Timed out: Can&#39;t read data from server for more than&quot;
//                     &quot; %lld seconds\n&quot;, d_readTimeout.seconds());
//              d_allocator.deallocate(channel);
//          }
//      }
//      else {
//          printf(&quot;Failed to read data: non-recoverable error: %d\n&quot;,
//                 status);
//          d_allocator.deallocate(channel);
//      }
//  }
//
//  void my_EchoClient::writeCb(int                    status,
//                              int                    asyncStatus,
//                              btlsc::TimedCbChannel *channel,
//                              int                    sequence)
//  {
//      if (0 &lt; status) {
//          if (status != k_BUFFER_SIZE) {
//              d_allocator.deallocate(channel);
//              assert(&quot;Failed to send data to the server&quot; &amp;&amp; 0);
//          }
//          else {
//              bsl::function&lt;void(const char *, int, int)&gt; callback(
//                         bdlf::BindUtil::bind(&amp;my_EchoClient::bufferedReadCb,
//                                              this,
//                                              _1,
//                                              _2,
//                                              _3,
//                                              channel,
//                                              sequence));
//              if (channel-&gt;timedBufferedRead(k_BUFFER_SIZE,
//                                             bdlt::CurrentTime::now()
//                                                             + d_readTimeout,
//                                             callback)) {
//                  assert(channel-&gt;isInvalidRead());
//                  d_allocator.deallocate(channel);
//                  assert(&quot;Failed to enqueue read request&quot; &amp;&amp; 0);
//              }
//          }
//      }
//      else if (0 == status) {
//          if (0 &gt; asyncStatus) {
//              cout &lt;&lt; &quot;Request dequeued.&quot; &lt;&lt; endl;
//          }
//          else {
//              d_allocator.deallocate(channel);
//              assert(&quot;Timed out sending data to the server&quot; &amp;&amp; 0);
//          }
//      }
//      else {
//          d_allocator.deallocate(channel);
//          assert(&quot;Failed to send data: non-recoverable error on the channel&quot;
//                 &amp;&amp; 0);
//      }
//  }
//
//  int my_EchoClient::setPeer(const btlso::IPv4Address&amp; address) {
//      d_allocator.setPeer(address);
//      return d_allocator.timedAllocateTimed(d_allocateFunctor,
//                                            bdlt::CurrentTime::now()
//                                                         + d_connectTimeout);
//  }
//..
//
///Dual Control and Data Channels
///- - - - - - - - - - - - - -  -
// The following usage example shows a possible implementation of a client-side
// communication layer where two communication channels are established for a
// server: one is for control messages and another for the data stream.  The
// client is implemented as a separate class that owns the connector and uses a
// socket event manager and (corresponding) stream socket factory installed at
// creation.  Various configuration parameters such as the timeout values, the
// queue size, and input buffer size are constants within this class.
//..
//  class my_DataStream {
//      enum {
//          k_DEFAULT_PORT_NUMBER = 1234,
//          k_QUEUE_SIZE          =   16
//      };
//
//      btlsos::TcpTimedCbConnector  d_allocator;
//      bsls::TimeInterval           d_connectTimeout;
//      btlsc::TimedCbChannel       *d_controlChannel;
//      btlsc::TimedCbChannel       *d_dataChannel;
//
//    private:
//      // Callbacks
//      void allocateCb(btlsc::TimedCbChannel  *channel,
//                      int                     status,
//                      btlsc::TimedCbChannel **cachedChannel);
//          // Invoked from the socket event manager when a connection is
//          // allocated (i.e., established) or an error occurs when
//          // allocating.
//
//    private:
//      // Not implemented:
//      my_DataStream(const my_DataStream&amp;);
//      my_DataStream&amp; operator=(const my_DataStream&amp;);
//
//    public:
//      // CREATORS
//      my_DataStream(
//                btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt; *factory,
//                btlso::TimerEventManager                       *manager,
//                const btlso::IPv4Address&amp;                       peerAddress);
//          // Create a controlled data stream that uses the specified stream
//          // socket &#39;factory&#39; for system sockets, uses the specified socket
//          // event &#39;manager&#39; to multiplex events on these sockets, and
//          // attempts to connect to the server at the specified
//          // &#39;peerAddress&#39;.  The behavior is undefined if either &#39;factory&#39;
//          // or &#39;manager&#39; is 0.
//
//      ~my_DataStream();
//          // Destroy this server.
//
//      // MANIPULATORS
//      int setUpCallbacks();
//          // Register callbacks as required for establishing communication
//          // channels.  Return 0 on success, and a non-zero value otherwise,
//          // in which case all further registration attempts will fail (and
//          // the object can be only destroyed).
//  };
//..
// The implementation of the public methods of &#39;my_DataStream&#39; is trivial.  For
// the constructor, the socket factory and socket event manager are passed to
// the connector, and the allocate callback and (three) event timeouts are
// initialized; the peer address is passed to the connector.  The destructor
// verifies that the state of the connector is valid:
//..
//  my_DataStream::my_DataStream(
//                 btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt; *factory,
//                 btlso::TimerEventManager                       *manager,
//                 const btlso::IPv4Address&amp;                       peerAddress)
//  : d_allocator(factory, manager)
//  , d_connectTimeout(120, 0)
//  , d_controlChannel(NULL)
//  , d_dataChannel(NULL)
//  {
//      assert(factory);
//      assert(manager);
//      d_allocator.setPeer(peerAddress);
//  }
//
//  my_DataStream::~my_DataStream() {
//      assert(0 == d_allocator.numChannels());
//  }
//
//  int my_DataStream::setUpCallbacks() {
//      bsl::function&lt;void(btlsc::TimedCbChannel*, int)&gt; callback(
//                             bdlf::BindUtil::bind(&amp;my_DataStream::allocateCb,
//                                                  this,
//                                                  _1,
//                                                  _2,
//                                                  &amp;d_controlChannel));
//
//      if (d_allocator.timedAllocateTimed(callback,
//                                         bdlt::CurrentTime::now()
//                                                       + d_connectTimeout)) {
//          return -1;                                                // RETURN
//      }
//
//      callback = bdlf::BindUtil::bind(&amp;my_DataStream::allocateCb,
//                                      this,
//                                      _1,
//                                      _2,
//                                      &amp;d_dataChannel);
//      return d_allocator.timedAllocateTimed(callback,
//                                            bdlt::CurrentTime::now()
//                                                         + d_connectTimeout);
//  }
//..
// The allocate callback will cache the newly-allocated channel for future use:
//..
//  void my_DataStream::allocateCb(btlsc::TimedCbChannel  *channel,
//                                 int                     status,
//                                 btlsc::TimedCbChannel **cachedChannel) {
//      assert(cachedChannel);
//
//      if (channel) {
//          *cachedChannel = channel;
//          if (d_controlChannel &amp;&amp; d_dataChannel) {
//              // Ready to do data processing ...
//          }
//      }
//      else {
//          cout &lt;&lt; &quot;not valid channel: status: &quot; &lt;&lt; status &lt;&lt; endl;
//      }
//  }
//
//  static void connectCb(btlsc::CbChannel            *channel,
//                        int                          status,
//                        btlsos::TcpTimedCbConnector *connector,
//                        int                         *numConnections,
//                        int                          validChannel,
//                        int                          expStatus,
//                        int                          cancelFlag)
//      // Verify the result of an &quot;ACCEPT&quot; request by comparing against the
//      // expected values: If the specified &#39;validChannel&#39; is nonzero, a new
//      // &#39;btlsc::CbChannel&#39; should be established; the specified return
//      // &#39;status&#39; should be the same as the specified &#39;expStatus&#39;.  If the
//      // specified &#39;cancelFlag&#39; is nonzero, invoke the &#39;cancelAll()&#39; on the
//      // specified &#39;acceptor&#39; for test.
//  {
//      if (validChannel) {
//          assert(channel);
//      }
//      else {
//          assert(0 == channel);
//      }
//      assert(status == expStatus);
//
//      if (0 == channel) {
//      }
//      else {
//          ++(*numConnections);
//      }
//      if (cancelFlag) {
//          connector-&gt;cancelAll();
//      }
//  }
//..

#ifndef INCLUDED_BTLSCM_VERSION
#include &lt;btlscm_version.h&gt;
#endif

#ifndef INCLUDED_BTLSC_TIMEDCBCHANNELALLOCATOR
#include &lt;btlsc_timedcbchannelallocator.h&gt;
#endif

#ifndef INCLUDED_BTLSO_IPV4ADDRESS
#include &lt;btlso_ipv4address.h&gt;
#endif

#ifndef INCLUDED_BDLMA_POOL
#include &lt;bdlma_pool.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSL_DEQUE
#include &lt;bsl_deque.h&gt;
#endif

#ifndef INCLUDED_BSL_FUNCTIONAL
#include &lt;bsl_functional.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {
namespace btlso { template&lt;class ADDRESS&gt; class StreamSocketFactory; }
namespace btlso { template&lt;class ADDRESS&gt; class StreamSocket; }
namespace btlso { class TimerEventManager; }
namespace btlsos {

class TcpTimedCbConnector_Reg; // component-local class declaration

                        // =========================
                        // class TcpTimedCbConnector
                        // =========================

class TcpTimedCbConnector : public btlsc::TimedCbChannelAllocator {
    // This class implements a &#39;btesc&#39;-style timed callback-based channel
    // allocator for a single client-side TCP/IPv4 socket.  The allocation
    // requests&#39; callbacks are queued and invoked as appropriate.  The status
    // supplied to a callback is negative for failure, 0 on timeout, and
    // positive for a (restartable) interrupt on an underlying system call.  A
    // status value of -1 indicates an allocation attempt on an uninitialized
    // connector (i.e., an invalid peer address is specified), and a status
    // value of -2 to indicate failure due to changed end-points on
    // not-yet-completed (allocation) request.  This connector provides the
    // ability to change the end-points at run-time without any effect on the
    // state of any channels currently managed by this connector.

    bdlma::Pool        d_callbackPool;    // memory pool for registrations
    bdlma::Pool        d_channelPool;     // memory pool for channels

    bsl::deque&lt;TcpTimedCbConnector_Reg *&gt;
                       d_callbacks;       // registered callbacks

    bsl::vector&lt;btlsc::CbChannel*&gt;        // managed channels
                       d_channels;

    TcpTimedCbConnector_Reg
                     *d_currentRequest_p;// the address of the current request.

    btlso::TimerEventManager              // multiplexer of both socket events
                      *d_manager_p;       // and timers

    btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt;
                      *d_factory_p;       // factory used to supply sockets

    btlso::StreamSocket&lt;btlso::IPv4Address&gt;
                     *d_connectingSocket_p;

    btlso::IPv4Address d_peerAddress;     // address of peer process

    int               d_isInvalidFlag;    // set if connector is invalid

    bsl::function&lt;void()&gt;
                      d_connectFunctor;  // cached callbacks
    bsl::function&lt;void()&gt;
                      d_timeoutFunctor;

    void             *d_timerId;         // registration id from socket event
                                         // manager
    bslma::Allocator *d_allocator_p;
  private:
    // Private (implementation) methods

    template &lt;class CALLBACK_TYPE, class CHANNEL&gt;
    int initiateTimedConnection(const CALLBACK_TYPE&amp;      callback,
                                const bsls::TimeInterval&amp; timeout,
                                int                       flags,
                                int                       createRequest);
        // Initiate a non-blocking connection to the peer server, invoke the
        // specified &#39;callback&#39; if the operation completed immediately, either
        // successfully or not, (and allocate a channel, if needed), or enqueue
        // the request for a connection completion after the specified
        // &#39;timeout&#39; absolute time.  Return 0 if operation completed
        // successfully, a negative value if an error occurred and a positive
        // value if an operation could not complete immediately (and thus was
        // enqueued for further processing).

    template &lt;class CALLBACK_TYPE, class CHANNEL&gt;
    int initiateConnection(const CALLBACK_TYPE&amp; callback,
                           int                  flags,
                           int                  createRequest);
        // Initiate a non-blocking connection to the peer server, invoke the
        // specified &#39;callback&#39; if operation completed immediately, either
        // successfully or not, (and allocate a channel, if needed), or enqueue
        // the request for a connection completion.  Return 0 if operation
        // completed successfully, a negative value if an error occurred and a
        // positive value if an operation could not complete immediately (and
        // thus was enqueued for further processing).

    // Callbacks for socket event manager
    void connectCb();
        // Process the connection request at the top of the queue, and set up
        // the callbacks as required in order to process the next request, if
        // any.  Note that this method is invoked from the socket event manager
        // when an event occurs on the connecting socket.

    void deallocateCb(btlsc::CbChannel *channel);
        // Deallocate resources used by the specified &#39;channel&#39;.  Note that
        // this method is invoked from the timer event manager.

    void timerCb();
        // Process the connection request at the top of the queue, and set up
        // the callbacks as required in order to process the next request, if
        // any.  Note that this method is invoked from the socket event manager
        // when the timer is expired (and the associated request is timed out).

  private:
    // Not implemented:
    TcpTimedCbConnector(const TcpTimedCbConnector&amp;);
    TcpTimedCbConnector&amp; operator=(const TcpTimedCbConnector&amp;);

  public:
    // CREATORS
    TcpTimedCbConnector(
           btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt; *factory,
           btlso::TimerEventManager                       *manager,
           bslma::Allocator                               *basicAllocator = 0);
        // Create a timed callback connector that uses the specified &#39;factory&#39;
        // (to create stream sockets) and the specified &#39;manager&#39; (to monitor
        // for incoming connections).  Optionally specify a &#39;basicAllocator&#39;
        // used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently
        // installed default allocator is used.  The behavior is undefined if
        // either &#39;factory&#39; or &#39;manager&#39; is 0.  Note that the connector is
        // created in a valid state (as reported by the &#39;isInvalid&#39; method).

    TcpTimedCbConnector(
           btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt; *factory,
           btlso::TimerEventManager                       *manager,
           int                                             numChannels,
           bslma::Allocator                               *basicAllocator = 0);
        // Create a timed cb connector, with enough internal capacity to
        // allocate up to the specified &#39;numChannels&#39; without reallocation,
        // that uses the specified &#39;factory&#39; to create stream sockets, and the
        // specified &#39;manager&#39; to monitor for incoming connections.  Optionally
        // specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.  The behavior is undefined unless both &#39;factory&#39; and &#39;manager&#39;
        // are specified and unless &#39;0 &lt; numElements&#39;.  Note that the connector
        // is created in a valid state (as reported by the &#39;isInvalid&#39; method).

    ~TcpTimedCbConnector();
        // Destroy this connector.  The behavior is undefined unless all
        // channels allocated from this connector have been deallocated.

    // MANIPULATORS
    virtual int allocate(const Callback&amp; callback, int flags = 0);
        // Initiate a non-blocking operation to allocate a callback channel;
        // execute the specified &#39;callback&#39; functor after the allocation
        // operation terminates.  If the optionally specified &#39;flags&#39;
        // incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot;
        // are permitted to interrupt the allocation; by default, such events
        // are ignored.  Return 0 on successful initiation, and a non-zero
        // value otherwise (in which case &#39;callback&#39; will not be invoked).
        //
        // When invoked, &#39;callback&#39; is passed the (possibly null) address of a
        // callback channel and an integer &quot;status&quot;.  If that address is not 0,
        // the allocation succeeded and status has no meaning; a non-null
        // channel address will remain valid until deallocated explicitly (see
        // &#39;deallocate&#39;).  If the address is 0, a positive status indicates an
        // interruption due to an asynchronous event; subsequent allocation
        // attempts may succeed.  A status of -1 implies that the allocation
        // operation was &quot;canceled&quot; (synchronously) by the caller (see
        // &#39;cancelAll&#39;) and, often, may be retried successfully.  A status less
        // than -1 indicates a more persistent error, but not necessarily a
        // permanent one; the allocator itself may still be valid (see
        // &#39;isInvalid&#39;).  The behavior is undefined unless &#39;callback&#39; is valid.

    virtual int allocateTimed(const TimedCallback&amp; timedCallback,
                              int                  flags = 0);
        // Initiate a non-blocking operation to allocate a timed callback
        // channel; execute the specified &#39;timedCallback&#39; functor after the
        // allocation operation terminates.  If the optionally specified
        // &#39;flags&#39; incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous
        // events&quot; are permitted to interrupt the allocation; by default, such
        // events are ignored.  Return 0 on successful initiation, and a
        // non-zero value otherwise (in which case &#39;timedCallback&#39; will not be
        // invoked).
        //
        // When invoked, &#39;timedCallback&#39; is passed the (possibly null) address
        // of a timed callback channel and an integer &quot;status&quot;.  If that
        // address is not 0, the allocation succeeded and status has no
        // meaning; a non-null channel address will remain valid until
        // deallocated explicitly (see &#39;deallocate&#39;).  If the address is 0, a
        // positive status indicates an interruption due to an asynchronous
        // event; subsequent allocation attempts may succeed.  A status of -1
        // implies that the allocation operation was &quot;canceled&quot; (synchronously)
        // by the caller (see &#39;cancelAll&#39;) and, often, may be retried
        // successfully.  A status less than -1 indicates a more persistent
        // error, but not necessarily a permanent one; the allocator itself may
        // still be valid (see &#39;isInvalid&#39;).  The behavior is undefined unless
        // &#39;callback&#39; is valid.

    virtual void cancelAll();
        // Immediately cancel all pending operations on this allocator,
        // invoking each registered allocation callback in turn.  Each callback
        // will be invoked with a null channel and a status of -1.  This method
        // may be invoked successfully on an invalid allocator; however,
        // calling the method does not invalidate the allocator.  Note that
        // calling &#39;cancelAll&#39; from a callback that has itself been canceled
        // simply extends the set of canceled operations to include any new
        // ones initiated since the previous &#39;cancelAll&#39; was invoked.

    virtual void deallocate(btlsc::CbChannel *channel);
        // Terminate all operations on the specified &#39;channel&#39;, invoke each
        // pending callback with the appropriate status, and reclaim all
        // afforded channel services.  The behavior is undefined unless
        // &#39;channel&#39; is currently allocated from this allocator, (i.e., was
        // previously obtained from this instance and has not been subsequently
        // deallocated).  Note that this method can never block.

    virtual void invalidate();
        // Place this allocator in a permanently invalid state.  No subsequent
        // allocations will succeed.  Note that invalidating this allocator has
        // no effect on the state of any channel managed by it.  Also note that
        // if a connection attempt is in progress, it will *NOT* be terminated.

    void setPeer(const btlso::IPv4Address&amp; endpoint);
        // Set the address of the peer server that this connector is associated
        // with to the specified &#39;endpoint&#39;.

    virtual int timedAllocate(const Callback&amp;           callback,
                              const bsls::TimeInterval&amp; timeout,
                              int                       flags = 0);
        // Initiate a non-blocking operation to allocate a callback channel or
        // interrupt after the specified absolute &#39;timeout&#39; time is reached;
        // execute the specified &#39;callback&#39; functor after the allocation
        // operation terminates.  If the optionally specified &#39;flags&#39;
        // incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot;
        // are permitted to interrupt the allocation; by default, such events
        // are ignored.  Return 0 on successful initiation, and a non-zero
        // value otherwise (in which case &#39;callback&#39; will not be invoked).
        //
        // When invoked, &#39;callback&#39; is passed the (possibly null) address of a
        // callback channel and an integer &quot;status&quot;.  If that address is not 0,
        // the allocation succeeded and status has no meaning; a non-null
        // channel-allocator address will remain valid until deallocated
        // explicitly (see &#39;deallocate&#39;).  If the address is 0, a 0 status
        // indicates that the operation has timed out, while a positive status
        // indicates an interruption due to an asynchronous event.  In either
        // case, subsequent allocation attempts may succeed.  A status of -1
        // implies that the allocation operation was &quot;canceled&quot; (synchronously)
        // by the caller (see &#39;cancelAll&#39;) and, often, may be retried
        // successfully.  A status less than -1 indicates a more persistent
        // error, but not necessarily a permanent one; the allocator itself may
        // still be valid (see &#39;isInvalid&#39;).  Note that if the &#39;timeout&#39; value
        // has already passed, the allocation will still be attempted, but the
        // attempt will not block.

    int timedAllocateTimed(const TimedCallback&amp;      timedCallback,
                           const bsls::TimeInterval&amp; timeout,
                           int                       flags = 0);
        // Initiate a non-blocking operation to allocate a timed callback
        // channel or interrupt after the specified absolute &#39;timeout&#39; time is
        // reached; execute the specified &#39;callback&#39; functor after the
        // allocation operation terminates.  If the optionally specified
        // &#39;flags&#39; incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous
        // events&quot; are permitted to interrupt the allocation; by default, such
        // events are ignored.  Return 0 on successful initiation, and a
        // non-zero value otherwise (in which case the specified
        // &#39;timedCallback&#39; will not be invoked).
        //
        // When invoked, &#39;timedCallback&#39; is passed the (possibly null) address
        // of a timed callback channel and an integer &quot;status&quot;.  If that
        // address is not 0, the allocation succeeded and status has no
        // meaning; a non-null channel-allocator address will remain valid
        // until deallocated explicitly (see &#39;deallocate&#39;).  If the address is
        // 0, a 0 status indicates that the operation has timed out, while a
        // positive &quot;status&quot; indicates an interruption due to an asynchronous
        // event.  In either case, subsequent allocation attempts may succeed.
        // A status of -1 implies that the allocation operation was &quot;canceled&quot;
        // (synchronously) by the caller (see &#39;cancelAll&#39;) and, often, may be
        // retried successfully.  A status less than -1 indicates a more
        // persistent error, but not necessarily a permanent one; the allocator
        // itself may still be valid (see &#39;isInvalid&#39;).  Note that if the
        // &#39;timeout&#39; value has already passed, the allocation will still be
        // attempted, but the attempt will not block.

    // ACCESSORS
    const btlso::IPv4Address&amp; peer() const;
        // Return the (fully qualified) address of the peer server that is
        // associated with this connector, or an invalid address of
        // (&#39;ANY_ADDRESS&#39;, &#39;ANY_PORT&#39;) if no such server exists (see
        // &#39;bteso::IPv4address&#39;).

    virtual int isInvalid() const;
        // Return 1 if this channel allocator is *permanently* invalid (i.e.,
        // no subsequent allocation requests will succeed).

    int numChannels() const;
        // Return the number of channels currently allocated from this
        // connector.
};

// ----------------------------------------------------------------------------
//                             INLINE DEFINITIONS
// ----------------------------------------------------------------------------

inline
void TcpTimedCbConnector::setPeer(const btlso::IPv4Address&amp; endpoint)
{
    d_peerAddress = endpoint;
}

inline
const btlso::IPv4Address&amp; TcpTimedCbConnector::peer() const
{
    return d_peerAddress;
}

inline
int TcpTimedCbConnector::numChannels() const
{
    return static_cast&lt;int&gt;(d_channels.size());
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
