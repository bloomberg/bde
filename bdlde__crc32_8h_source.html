<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlde_crc32.h                                                      -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLDE_CRC32
#define INCLUDED_BDLDE_CRC32

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a mechanism for computing the CRC-32 checksum of a dataset.
//
//@CLASSES:
//  bdlde::Crc32: stores and updates a CRC-32 checksum
//
//@SEE_ALSO:
//
//@DESCRIPTION: This component implements a mechanism for computing, updating,
// and streaming a CRC-32 checksum (a cyclic redundancy check comprised of 32
// bits).  This checksum is a strong and fast technique for determining whether
// or not a message was received without errors.  Note that a CRC-32 checksum
// does not aid in error correction and is not naively useful in any sort of
// cryptographic application.  Compared to other methods such as MD5 and
// SHA-256, it is relatively easy to find alternate texts with identical
// checksum.
//
///Usage
///-----
// The following snippets of code illustrate a typical use of the
// &#39;bdlde::Crc32&#39; class.  Each function would typically execute in separate
// processes or potentially on separate machines.  The &#39;senderExample&#39; function
// below demonstrates how a message sender can write a message and its CRC-32
// checksum to a &#39;bdex&#39; output stream.  Note that &#39;Out&#39; may be a &#39;typedef&#39; of
// any class that implements the &#39;bslx::OutStream&#39; protocol:
//..
//  void senderExample(Out&amp; output)
//      // Write a message and its CRC-32 checksum to the specified &#39;output&#39;
//      // stream.
//  {
//      // prepare a message
//      bsl::string message = &quot;This is a test message.&quot;;
//
//      // generate a checksum for &#39;message&#39;
//      bdlde::Crc32 crc(message.data(), message.length());
//
//      // write the message to &#39;output&#39;
//      output &lt;&lt; message;
//
//      // write the checksum to &#39;output&#39;
//      const int VERSION = 1;
//      crc.bdexStreamOut(output, VERSION);
//  }
//..
// The &#39;receiverExample&#39; function below illustrates how a message receiver can
// read a message and its CRC-32 checksum from a &#39;bdex&#39; input stream, then
// perform a local CRC-32 computation to verify that the message was received
// intact.  Note that &#39;In&#39; may be a &#39;typedef&#39; of any class that implements the
// &#39;bslx::InStream&#39; protocol:
//..
//  void receiverExample(In&amp; input)
//      // Read a message and its CRC-32 checksum from the specified &#39;input&#39;
//      // stream, and verify the integrity of the message.
//  {
//      // read the message from &#39;input&#39;
//      bsl::string message;
//      input &gt;&gt; message;
//
//      // read the checksum from &#39;input&#39;
//      bdlde::Crc32 crc;
//      const int VERSION = 1;
//      crc.bdexStreamIn(input, VERSION);
//
//      // locally compute the checksum of the received &#39;message&#39;
//      bdlde::Crc32 crcLocal;
//      crcLocal.update(message.data(), message.length());
//
//      // verify that the received and locally-computed checksums match
//      assert(crcLocal == crc);
//  }
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif


namespace BloombergLP {
namespace bdlde {

                                // ===========
                                // class Crc32
                                // ===========

class Crc32 {
    // This class represents a CRC-32 checksum value that can be updated as
    // data is provided.
    //
    // More generally, this class supports a complete set of *value*
    // *semantic* operations, including copy construction, assignment,
    // equality comparison, &#39;ostream&#39; printing, and &#39;bdex&#39; serialization.
    // (A precise operational definition of when two objects have the same
    // value can be found in the description of &#39;operator==&#39; for the class.)
    // This class is *exception* *neutral* with no guarantee of rollback:
    // if an exception is thrown during the invocation of a method on a
    // pre-existing object, the class is left in a valid state, but its value
    // is undefined.  In no event is memory leaked.  Finally, *aliasing* (e.g.,
    // using all or part of an object as both source and destination) is
    // supported in all cases.

    // DATA
    unsigned int d_crc;  // value of the checksum ^ 0xffffffff

    // FRIENDS
    friend bool operator==(const Crc32&amp;, const Crc32&amp;);

  public:
    // CLASS METHODS
    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that the &#39;versionSelector&#39; is expected to be formatted
        // as &#39;yyyymmdd&#39;, a date representation.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // CREATORS
    Crc32();
        // Construct a checksum having the value corresponding to no data
        // having been provided (i.e., having the value 0).

    Crc32(const void *data, int length);
        // Construct a checksum corresponding to the specified &#39;data&#39; having
        // the specified &#39;length&#39; (in bytes).  The behavior is undefined unless
        // &#39;0 &lt;= length&#39;.  Note that if &#39;data&#39; is 0, then &#39;length&#39; also must
        // be 0.

    Crc32(const Crc32&amp; original);
        // Construct a checksum having the value of the specified &#39;original&#39;
        // checksum.

    // ~Crc32();
        // Destroy this checksum.  Note that this trivial destructor is
        // generated by the compiler.

    // MANIPULATORS
    Crc32&amp; operator=(const Crc32&amp; rhs);
        // Assign to this checksum the value of the specified &#39;rhs&#39; checksum,
        // and return a reference to this modifiable checksum.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    unsigned int checksumAndReset();
        // Return the current value of this checksum and set the value of this
        // checksum to the value the default constructor provides.

    void reset();
        // Reset the value of this checksum to the value the default
        // constructor provides.

    void update(const void *data, int length);
        // Update the value of this checksum to incorporate the specified
        // &#39;data&#39; having the specified &#39;length&#39;.  If the current state is the
        // default state, the resultant value of this checksum is the
        // application of the CRC-32 algorithm upon the currently given &#39;data&#39;
        // of the given &#39;length&#39;.  If this checksum has been previously
        // provided data and has not been subsequently reset, the current state
        // is not the default state and the resultant value is equivalent to
        // applying the CRC-32 algorithm upon the concatenation of all the
        // provided data.  The behavior is undefined unless &#39;0 &lt;= length&#39;.
        // Note that if &#39;data&#39; is 0, then &#39;length&#39; also must be 0.

    // ACCESSORS
    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write this value to the specified output &#39;stream&#39; using the
        // specified &#39;version&#39; format, and return a reference to &#39;stream&#39;.
        // If &#39;stream&#39; is initially invalid, this operation has no effect.
        // If &#39;version&#39; is not supported, &#39;stream&#39; is invalidated but
        // otherwise unmodified.  Note that &#39;version&#39; is not written to
        // &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    unsigned int checksum() const;
        // Return the current value of this checksum.

    bsl::ostream&amp; print(bsl::ostream&amp; stream) const;
        // Format this object to the specified output &#39;stream&#39; at the (absolute
        // value of) the optionally specified indentation &#39;level&#39; and return a
        // reference to &#39;stream&#39;.  If &#39;level&#39; is specified, optionally specify
        // &#39;spacesPerLevel&#39;, the number of spaces per indentation level for
        // this and all of its nested objects.  If &#39;level&#39; is negative,
        // suppress indentation of the first line.  If &#39;spacesPerLevel&#39; is
        // negative, format the entire output on one line, suppressing all but
        // the initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is
        // not valid on entry, this operation has no effect.


};

// FREE OPERATORS
bool operator==(const Crc32&amp; lhs, const Crc32&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; checksums have the same
    // value, and &#39;false&#39; otherwise.  Two checksums have the same value if the
    // values obtained from their &#39;checksum&#39; methods are identical.

bool operator!=(const Crc32&amp; lhs, const Crc32&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; checksums do not have the
    // same value, and &#39;false&#39; otherwise.  Two checksums do not have the same
    // value if the values obtained from their &#39;checksum&#39; methods differ.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Crc32&amp; checksum);
    // Write to the specified output &#39;stream&#39; the specified &#39;checksum&#39; value
    // and return a reference to the modifiable &#39;stream&#39;.

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

                                // -----------
                                // class Crc32
                                // -----------

// CLASS METHODS
inline
int Crc32::maxSupportedBdexVersion(int)
{
    return 1;
}

// CREATORS
inline
Crc32::Crc32()
: d_crc(0xffffffff)
{
}

inline
Crc32::Crc32(const void *data, int length)
: d_crc(0xffffffff)
{
    update(data, length);
}

inline
Crc32::Crc32(const Crc32&amp; original)
: d_crc(original.d_crc)
{
}

// MANIPULATORS
inline
Crc32&amp; Crc32::operator=(const Crc32&amp; rhs)
{
    d_crc = rhs.d_crc;
    return *this;
}

template &lt;class STREAM&gt;
STREAM&amp; Crc32::bdexStreamIn(STREAM&amp; stream, int version)
{
    if (stream) {
        switch (version) {
          case 1: {
            unsigned int crc;
            stream.getUint32(crc);
            if (!stream) {
                return stream;                                        // RETURN
            }
            d_crc = crc;
          } break;
          default: {
            stream.invalidate();
          } break;
        }
    }
    return stream;
}

inline
unsigned int Crc32::checksumAndReset()
{
    const unsigned int crc = d_crc;
    d_crc = 0xffffffff;
    return crc ^ 0xffffffff;
}

inline
void Crc32::reset()
{
    d_crc = 0xffffffff;
}

// ACCESSORS
template &lt;class STREAM&gt;
STREAM&amp; Crc32::bdexStreamOut(STREAM&amp; stream, int version) const
{
    switch (version) {
      case 1: {
        stream.putUint32(d_crc);
      } break;
      default: {
        stream.invalidate();
      } break;
    }
    return stream;
}

inline
unsigned int Crc32::checksum() const
{
    return d_crc ^ 0xffffffff;
}


// FREE OPERATORS
inline
bool operator==(const Crc32&amp; lhs, const Crc32&amp; rhs)
{
    return lhs.d_crc == rhs.d_crc;
}

inline
bool operator!=(const Crc32&amp; lhs, const Crc32&amp; rhs)
{
    return !(lhs == rhs);
}

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Crc32&amp; checksum)
{
    return checksum.print(stream);
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
