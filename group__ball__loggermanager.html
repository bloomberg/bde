<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: ball_loggermanager Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component ball_loggermanager<br/>
<small>
[<a class="el" href="group__ball.html">Package ball</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a manager of core logging functionality.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html">ball</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">General Features and Behavior</a> </li>
<li>
<a href="#3.2">Logger Manager Singleton Initialization</a> </li>
<li>
<a href="#3.3">Deprecation Notice</a> </li>
<li>
<a href="#3.4">Categories, Severities, and Threshold Levels</a> <ul>
<li>
<a href="#3.4.1">Terminology: "Factory Default" Thresholds</a> </li>
<li>
<a href="#3.4.2">Category Creation, Management, and Threshold Levels</a> </li>
</ul>
</li>
<li>
<a href="#3.5">Log Record Contents</a> </li>
<li>
<a href="#3.6">Multi-Threaded Usage</a> </li>
<li>
<a href="#3.7"><code>bsls::Log</code> Logging Redirection</a> </li>
<li>
<a href="#3.8">Usage</a> <ul>
<li>
<a href="#3.8.1">Example 1: Initialization #1</a> </li>
<li>
<a href="#3.8.2">Example 2: Initialization #2</a> </li>
<li>
<a href="#3.8.3">Example 3: Efficient Logging of <code>ostream</code>-able Objects</a> </li>
<li>
<a href="#3.8.4">Example 4: Logging Using a <code>ball::Logger</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a manager of core logging functionality. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classball_1_1Logger.html">ball::Logger</a> </td><td>log record store and publication manager  </td></tr>
<tr>
<td><a class="el" href="classball_1_1LoggerManager.html">ball::LoggerManager</a> </td><td>logger factory and category administrator  </td></tr>
<tr>
<td><a class="el" href="classball_1_1LoggerManagerScopedGuard.html">ball::LoggerManagerScopedGuard</a> </td><td>scoped guard for <code>LoggerManager</code> singleton  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__ball__record.html" title="Provide a container for all fields of a log record.">Component ball_record</a>, <a class="el" href="group__ball__recordattributes.html" title="Provide a container for a fixed set of fields suitable for logging.">Component ball_recordattributes</a>, <a class="el" href="group__ball__observer.html" title="Define a protocol for receiving and processing log records.">Component ball_observer</a>, <a class="el" href="group__ball__context.html" title="Provide a container for the context of a transmitted log record.">Component ball_context</a>, <a class="el" href="group__ball__loggermanagerdefaults.html" title="Provide constrained default attributes for the logger manager.">Component ball_loggermanagerdefaults</a>, <a class="el" href="group__ball__loggermanagerconfiguration.html" title="Provide a constrained-attribute class for the logger manager.">Component ball_loggermanagerconfiguration</a>, <a class="el" href="group__ball__severity.html" title="Enumerate a set of logging severity levels.">Component ball_severity</a>, <a class="el" href="group__ball__transmission.html" title="Enumerate the set of states for log record transmission.">Component ball_transmission</a>, <a class="el" href="group__ball__log.html" title="Provide macros and utility functions to facilitate logging.">Component ball_log</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides the core of the <code>ball</code> logging toolkit: the logger class itself, <code><a class="el" href="classball_1_1Logger.html">ball::Logger</a></code>, which manages log record storage and publication control, and the logger manager class, <code><a class="el" href="classball_1_1LoggerManager.html">ball::LoggerManager</a></code>, which is a singleton that is both a factory for loggers and a category manager. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="general_features_and_behavior"></a> <a class="anchor" id="description.general_features_and_behavior"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>General Features and Behavior: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>ball</code> logging toolkit is very flexible. A user can log messages with very little effort, and with only a superficial understanding of logger operation, in which case the logger will exhibit its "default behavior". The user can also elect to customize many aspects of logging, such as storage and publication behavior, both at start-up and dynamically during program execution. Naturally, to exercise such control, the user must become more familiar with <code>ball</code> logger operation; the user can choose more convenience or more versatility, with a reasonably fine granularity. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Log records incorporate both fixed (logger-defined) and optional (user-defined) fields, affording yet more flexibility (see "Log Record
 Contents" below). The logger directly populates certain of the required fields, and indirectly manages population of any optional fields by invoking a client-supplied callback function that sets the optional values. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Clients obtain one or more loggers from the logger manager, although at most one logger may be "active" in any one thread; a request to log a message is directed to the active logger in that thread. Each logger both stores and publishes appropriate log records. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>All loggers share a single registered observer to which log records are transmitted when they are published (see the component-level documentation of <code>ball_observer</code> for more information on observers). The shared observer must be supplied when the logger manager singleton is initialized. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A logger can achieve high performance through the use of an in-memory record buffer for storing the records logged by a program. Each logger is constructed with a record manager, which is an instance of a concrete class derived from <code><a class="el" href="classball_1_1RecordBuffer.html">ball::RecordBuffer</a></code>. The singleton logger manager supplies a "default" record manager to the default logger; loggers allocated by the logger manager's <code>allocateLogger</code> method use a record manager supplied by the client. The default log record buffer is of user-configurable static size and is circular (see the <code>ball_circularrecordbuffer</code> component for details), whereby continuous logging (without publication of logged records) can result in older records being overwritten by newer ones. A circular buffer provides an efficient "trace-back" strategy, wherein only log records proximate to a user-specified logging event (see below) are published. Such a circular buffer may not be appropriate for all situations; the user can change the behavior of the default logger by adjusting the logging threshold levels (see below) or can install a logger that uses a different kind of record buffer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="logger_manager_singleton_initialization"></a> <a class="anchor" id="description.logger_manager_singleton_initialization"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Logger Manager Singleton Initialization: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The recommended way to initialize the logger manager singleton is to create a <code><a class="el" href="classball_1_1LoggerManagerScopedGuard.html">ball::LoggerManagerScopedGuard</a></code> object in <code>main</code> (<em>before</em> creating any threads). The logger manager scoped guard constructor takes an observer, a configuration object (an instance of <code><a class="el" href="classball_1_1LoggerManagerConfiguration.html">ball::LoggerManagerConfiguration</a></code>), and an optional allocator. The logger manager singleton is created as a side-effect of creating the scoped guard object. When the guard object goes out of scope (i.e., on program exit), the logger manager singleton is automatically destroyed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classball_1_1LoggerManagerConfiguration.html">ball::LoggerManagerConfiguration</a></code> object is used to supply a set of user-defined "default" values and other options. However, to obtain the "default" logging behavior, it is sufficient to instantiate a default <code><a class="el" href="classball_1_1LoggerManagerConfiguration.html">ball::LoggerManagerConfiguration</a></code> object and pass that to the constructor of the scoped guard along with an observer. (See <a href="group__ball__loggermanager.html#usage" class="el">Usage</a> below.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As an alternative to using the scoped guard, the <code>initSingleton</code> method that takes the same arguments as the scoped guard may be used to initialize the singleton. However, in this case the <code>shutDownSingleton</code> method must be explicitly called to destroy the logger manager singleton on program exit. Unless <code>shutDownSingleton</code> is called, the singleton will not be destroyed and resources used by the singleton will leak. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="deprecation_notice"></a> <a class="anchor" id="description.deprecation_notice"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Deprecation Notice: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Direct use of the <code>public</code> logger manager constructor to initialize the logger manager singleton is <em>deprecated</em>. The constructor will be declared <code>private</code> in a future release. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Direct use of any of the 8 <code>initSingleton</code> methods that do <em>not</em> take an instance of <code><a class="el" href="classball_1_1LoggerManagerConfiguration.html">ball::LoggerManagerConfiguration</a></code> to initialize the logger manager singleton is <em>deprecated</em>. These methods will be eliminated in a future release. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="categories,_severities,_and_threshold_levels"></a> <a class="anchor" id="description.categories,_severities,_and_threshold_levels"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Categories, Severities, and Threshold Levels: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The logger supports the notions of "severity level" and "category"; every record is logged at some severity level and to some category. Categories are user-defined (except for the "default category"), and have unique names. Severity levels are integers in the range <code>[0 .. 255]</code>, and are most typically chosen from among the enumeration in the <code>ball_severity</code> component, although use of the <code>enum</code> is optional. The severity level and the category name are each among the fixed fields of the record being logged (see "Log Record Contents" below). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>From the logger's perspective, all categories are peers; there is no special significance to any sequence of characters in a category name. The user may impose a hierarchical <em>meaning</em> to category names, and the logger manager facilitates a certain degree of hierarchical <em>behavior</em> via several callback functors provided within this component (see below, and also the <code>ball_loggerfunctorpayloads</code> component). However, such hierarchy is not fundamental to categories, nor to the behavior described in this section. Similarly, there is no a priori significance to severity levels except that they are ordered and may be compared for inequality, although the enumerator names in the <code><a class="el" href="structball_1_1Severity.html#af49f66189615b9475c9cced03afde384">ball::Severity::Level</a></code> enumeration (e.g., <code>DEBUG</code>, <code>WARN</code>, <code>ERROR</code>, etc.) suggest the intended "standard" meanings. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Every category has associated with it four "severity threshold levels", which may be set explicitly by the user on category creation/registration (via the <code>addCategory</code> method) or else will default to specific values via one of several mechanisms described below (invoked by the one-argument <code>setCategory</code> method). <a class="el" href="classCategory.html">Category</a> threshold levels may also be changed during program execution via the five-argument <code>setCategory</code> method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When the user logs a record to a given category and at a given severity (via the <code><a class="el" href="classball_1_1Logger.html">ball::Logger</a></code> <code>logMessage</code> method or via the logging macros -- see the <code>ball_log</code> component), the logger manager uses the specified severity and the category's registered severity threshold levels to govern the logger's behavior; depending on the thresholds, the message may be recorded to an in-memory buffer, published to an external observer, or ignored. In addition, if thresholds are set appropriately, the entire contents of the in-memory buffer of one or more loggers may be published to external observers. Clients of the logger can use, and dynamically administer, the category threshold levels to enhance run-time performance and/or to reduce message volume while still capturing all critical log messages. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The names and exact meanings of the four severity threshold levels are as follows: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> Record: <br/>
 If the severity level of the record is at least as severe as the Record threshold level of the associated category, then the record will be stored by the logger in its log record buffer (i.e., it will be recorded).</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> Pass: <br/>
 If the severity of the record is at least as severe as the Pass threshold level of the associated category, then the record will be immediately published by the logger (i.e., it will be transmitted to the logger's downstream recipient -- the observer).</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> Trigger: <br/>
 If the severity of the record is at least as severe as the Trigger threshold level of the associated category, then the record will cause immediate publication of that record and any records in the logger's log record buffer (i.e., this record will trigger a general log record dump).</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> Trigger-All: <br/>
 If the severity of the record is at least as severe as the Trigger-All threshold level of the associated category, then the record will cause immediate publication of that record and all other log records stored by <em>all</em> active loggers.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that more than one of the above actions can apply to a given log record, since the four threshold levels are independent of one another. Note also that <em>all</em> of these actions are governed by the threshold levels of the record being logged, and not by the threshold levels of any stored records that are published as a result of a Trigger or Trigger-All event. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="terminology~3A_~22factory_default~22_thresholds"></a> <a class="anchor" id="categories,_severities,_and_threshold_levels.terminology~3A_~22factory_default~22_thresholds"></a> <a class="anchor" id="description.categories,_severities,_and_threshold_levels.terminology~3A_~22factory_default~22_thresholds"></a> <a class="anchor" id="terminology"></a> <a class="anchor" id="categories,_severities,_and_threshold_levels.terminology"></a> <a class="anchor" id="description.categories,_severities,_and_threshold_levels.terminology"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Terminology: "Factory Default" Thresholds: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The logger manager supplies "default values" for category threshold levels whenever a category is created without client-supplied values. These default values can come from any one of several possible sources, depending upon options that the user has elected; the system is flexible, but leads to a bit of confusion in terminology. This section explains the meaning of "factory default" values and introduces the various "default" threshold mechanisms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The logger manager is a "factory" for loggers; we therefore define "factory
 defaults" to be the default values that the <code><a class="el" href="classball_1_1LoggerManager.html">ball::LoggerManager</a></code> singleton is aware of at construction. Depending on the values and options in the <code><a class="el" href="classball_1_1LoggerManagerConfiguration.html">ball::LoggerManagerConfiguration</a></code> object provided to the logger manager on construction, the factory defaults may be either implementation-defined or user-defined. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In either case, the user can <em>change</em> the default values during logger operation via the <code>setDefaultThresholdLevels</code> method. These threshold levels become the "default" values for new categories, but they are not "factory defaults", which can subsequently be restored via the <code>resetDefaultThresholdLevels</code> method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A third mechanism, the <code><a class="el" href="classball_1_1LoggerManager.html#ac4dd1c5707d1f628749965d1723b29ee">ball::LoggerManager::DefaultThresholdLevelsCallback</a></code> functor, adds even more flexibility. If this callback is installed by the user at construction, or subsequently via the <code>setDefaultThresholdLevelsCallback</code> method, the callback is the source of all default thresholds, and the above mechanisms are not used. The next section covers category thresholds in more detail. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="category_creation,_management,_and_threshold_levels"></a> <a class="anchor" id="categories,_severities,_and_threshold_levels.category_creation,_management,_and_threshold_levels"></a> <a class="anchor" id="description.categories,_severities,_and_threshold_levels.category_creation,_management,_and_threshold_levels"></a> <a class="anchor" id="3.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Category Creation, Management, and Threshold Levels: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>When the logger manager singleton is created, a unique category known as the <em>default</em> <em>category</em> is created, and is given "factory-supplied" default threshold levels. The default values for the default category are each in the range <code>[0 .. 255]</code>, but are otherwise unspecified. The user can also specify default values explicitly when the logger manager singleton is constructed. This is accomplished by constructing a <code><a class="el" href="classball_1_1LoggerManagerDefaults.html">ball::LoggerManagerDefaults</a></code> object, setting the desired values, and then setting that object as an attribute of the <code><a class="el" href="classball_1_1LoggerManagerConfiguration.html">ball::LoggerManagerConfiguration</a></code> argument to the <code><a class="el" href="classball_1_1LoggerManagerScopedGuard.html">ball::LoggerManagerScopedGuard</a></code> constructor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The default category is issued to the user via the return value of the <code>setCategory(const char *categoryName)</code> method whenever a new category cannot be created due to a capacity limitation on the category registry maintained by the logger manager. The method's normal behavior is to return the category having <code>categoryName</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Categories that are added to the registry during logging through calls to the <code>setCategory(const char *)</code> method are given threshold levels by one of two means. The "default" mechanism (a slightly overloaded term in <code>ball</code>) is to use the same default thresholds as described above for the default category. The alternative is to specify a <code><a class="el" href="classball_1_1LoggerManager.html#ac4dd1c5707d1f628749965d1723b29ee">ball::LoggerManager::DefaultThresholdLevelsCallback</a></code> functor, either when the logger manager singleton is initialized or else afterwards via the <code>setDefaultThresholdLevelsCallback</code> method. This functor, if provided, is used by the logger manager to supply the four <code>int</code> threshold values; the functor may generate these values by any means that the user sees fit. See the <code>ball_loggerfunctorpayloads</code> component for an example payload function for the functor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The default threshold levels can be adjusted (<code>setDefaultThresholdLevels</code>) and reset to their original values (<code>resetDefaultThresholdLevels</code>). Note that if factory values are overridden at initialization, a reset will restore thresholds to the user-specified default values. In addition, there is a method to set the threshold levels of a given category to the current default threshold levels (<code>setCategoryThresholdsToCurrentDefaults</code>) or to the factory-supplied (or client-overridden) default values (<code>setCategoryThresholdsToFactoryDefaults</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As a final note regarding categories, a client can optionally supply to the logger manager on construction a <code><a class="el" href="classball_1_1LoggerManager.html#a509510b854e085fb9a50a552013f9d5c">ball::LoggerManager::CategoryNameFilterCallback</a></code> functor (via the <code><a class="el" href="classball_1_1LoggerManagerConfiguration.html">ball::LoggerManagerConfiguration</a></code> object) to translate category names from an external to an internal representation. For example, a project may allow programmers to refer to categories using mixed-case within an application, but provide a <code>toLower</code> <code>CategoryNameFilterCallback</code> to map all external upper-case letters to lower-case internally. In this scenario, the (hypothetical) external category names "EQUITY.MARKET.NYSE" and "equity.market.nyse" would be mapped to the same category internally by the presumed <code>toLower</code> functor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="log_record_contents"></a> <a class="anchor" id="description.log_record_contents"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Log Record Contents: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Each log record contains a set of fixed fields and a set of optional, user-definable fields. The following table lists the fixed fields in each log record (see the component-level documentation of <code>ball_recordattributes</code> for more information on the fixed fields of a log record): <br/>
<br/>
<div class="fragment"><pre class="fragment">     Field Name         <a class="code" href="classBind__ImplSelector_1_1Type.html">Type</a>                  Description
     -----------    -------------    --------------------------------
     timestamp      <a class="code" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a>    creation date and time
     process ID     <span class="keywordtype">int</span>              process ID of creator
     thread ID      <span class="keywordtype">int</span>              thread ID of creator
     filename       <span class="keywordtype">string</span>           file where created  (i.e., <span class="stringliteral">&#39;__FILE__&#39;</span>)
     line number    <span class="keywordtype">int</span>              line number in file (i.e., &#39;__LINE__&#39;)
     category       <span class="keywordtype">string</span>           category name
     severity       <span class="keywordtype">int</span>              severity of logged record
     message        <span class="keywordtype">string</span>           log message text
</pre></div><br/>
<br/>
 The user-defined fields, if any, are described by a <code><a class="el" href="classball_1_1UserFieldsSchema.html">ball::UserFieldsSchema</a></code> optionally supplied by the client when the logger manager singleton is created. If a schema is supplied by the client, a corresponding <code>ball::Logger::UserPopulatorCallback</code> functor must also be supplied. Thereafter, every logged record has its user-defined fields (indirectly) populated by an invocation of the <code>UserPopulatorCallback</code> functor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="multi-threaded_usage"></a> <a class="anchor" id="description.multi-threaded_usage"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Multi-Threaded Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>ball</code> logging toolkit may be used in single-threaded and multi-threaded library code and applications with equal ease, and with virtually no difference in coding. In particular, the same use of the <code><a class="el" href="classball_1_1LoggerManagerScopedGuard.html">ball::LoggerManagerScopedGuard</a></code> class to initialize the logger manager singleton is required in <code>main</code> in both cases, and individual calls to the <code><a class="el" href="classball_1_1Logger.html">ball::Logger</a></code> instance method <code>logMessage</code> (and logging calls via the logging macros -- see <code>ball_log</code>) are identical, from the user's perspective. <a class="el" href="classCategory.html">Category</a> threshold administration is also identical in both cases. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Differences in logger usage, or, more precisely, additional options for the multi-threaded user, arise when the user wishes to allocate one or more loggers beyond the default logger, which is owned by the singleton logger manager. If a user does <em>not</em> explicitly allocate a logger (via the logger manager instance method <code>allocateLogger</code>) and install that logger for a given thread (via the manager instance method <code>setLogger</code>), then all records from all threads in a program will be logged to the one default logger. However, since each thread of execution may have its own logger instance, multi-threaded users may choose to allocate and install multiple loggers. Note that each thread may have at most one logger, but a single logger may be used by any number of threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Multi-threaded users of logging may prefer to allocate and install one logger per thread in order to take advantage of the "trace-back" feature described above on a per-thread basis. In the event of an error condition as defined by the programmer, such a logging configuration provides a trace-back through the record buffer of the thread that caused the error, without any dilution from records from other threads. Conversely, if several threads are known to interact closely, it may be advantageous to have them share a common logger so that the trace-back log <em>does</em> include all relevant records. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bsls~3A~3Alog_logging_redirection"></a> <a class="anchor" id="description.bsls~3A~3Alog_logging_redirection"></a> <a class="anchor" id="bsls"></a> <a class="anchor" id="description.bsls"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>bsls::Log Logging Redirection: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classball_1_1LoggerManager.html">ball::LoggerManager</a></code> singleton, on construction, will redirect the <code><a class="el" href="classbsls_1_1Log.html">bsls::Log</a></code> records to <code>ball</code> in the log category <code>BSLS.LOG</code> at the severity level <code>ERROR</code>. Upon its destruction the logger manager singleton will redirect <code><a class="el" href="classbsls_1_1Log.html">bsls::Log</a></code> records back to the default <code><a class="el" href="classbsls_1_1Log.html">bsls::Log</a></code> message handler. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.8"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates instantiation of the logger manager singleton, which is required (once!) in <code>main</code>, and also shows <em>direct</em> use of the logger and logger manager interfaces, much of which is actually <em>not</em> recommended. The most basic logger functionality has been wrapped in macros defined in the <code>ball_log</code> component. See the <code>ball</code> package-level documentation and the <code>ball_log</code> component documentation for recommended real-world usage examples. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_initialization_~231"></a> <a class="anchor" id="usage.example_1~3A_initialization_~231"></a> <a class="anchor" id="description.usage.example_1~3A_initialization_~231"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.8.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Initialization #1: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Clients that perform logging must first instantiate the singleton logger manager using the <code><a class="el" href="classball_1_1LoggerManagerScopedGuard.html">ball::LoggerManagerScopedGuard</a></code> class. This example shows how to create a logger manager with the most basic "default behavior". Subsequent examples will show more customized behavior. Note that a <code><a class="el" href="classball_1_1Observer.html">ball::Observer</a></code> (which will receive the records that are published) is a required argument; we will use a <code><a class="el" href="classball_1_1DefaultObserver.html">ball::DefaultObserver</a></code> here. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippets of code illustrate the initialization sequence (typically performed near the top of <code>main</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create a <code><a class="el" href="classball_1_1DefaultObserver.html">ball::DefaultObserver</a></code> object <code>observer</code> that will publish records to <code>stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="comment">// myApp.cpp</span>

    <span class="keywordtype">int</span> main()
    {

        <span class="comment">// ...</span>

        <span class="keyword">static</span> <a class="code" href="classball_1_1DefaultObserver.html">ball::DefaultObserver</a> observer(&amp;bsl::cout);
</pre></div><br/>
<br/>
 Next, we create a <code><a class="el" href="classball_1_1LoggerManagerConfiguration.html">ball::LoggerManagerConfiguration</a></code> object, <code>configuration</code>, and set the logging "pass-through" level -- the level at which log records are published to registered observers -- to <code>WARN</code> (see <a href="group__Categories, Severities, and Threshold Levels.html" class="el"><code>Categories, Severities, and Threshold Levels</code></a>): <br/>
<br/>
<div class="fragment"><pre class="fragment">        <a class="code" href="classball_1_1LoggerManagerConfiguration.html">ball::LoggerManagerConfiguration</a> configuration;
        configuration.<a class="code" href="classball_1_1LoggerManagerConfiguration.html#ab4f80e822e0f7c7362892bba65673e88">setDefaultThresholdLevelsIfValid</a>(
                                                   <a class="code" href="structball_1_1Severity.html#af49f66189615b9475c9cced03afde384a784431e47d4121459476d62efde5b97e" title="a potentially problematic condition">ball::Severity::e_WARN</a>);
</pre></div><br/>
<br/>
 We next create a <code><a class="el" href="classball_1_1LoggerManagerScopedGuard.html">ball::LoggerManagerScopedGuard</a></code> object whose constructor takes the observer and configuration object just created. The guard will initialize the logger manager singleton on creation and destroy the singleton upon destruction. This guarantees that any resources used by the logger manager will be properly released when they are not needed: <br/>
<br/>
<div class="fragment"><pre class="fragment">        <a class="code" href="classball_1_1LoggerManagerScopedGuard.html">ball::LoggerManagerScopedGuard</a> guard(&amp;observer, configuration);
</pre></div><br/>
<br/>
 The application is now prepared to log messages using the <code>ball</code> logging subsystem: <br/>
<br/>
<div class="fragment"><pre class="fragment">        <span class="comment">// ...</span>

        <span class="keywordflow">return</span> 0;
    }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_initialization_~232"></a> <a class="anchor" id="usage.example_2~3A_initialization_~232"></a> <a class="anchor" id="description.usage.example_2~3A_initialization_~232"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.8.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Initialization #2: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we demonstrate a more elaborate initial configuration for the logger manager. In particular, we create the singleton logger manager with a configuration that has a category name filter functor, a <code>DefaultThresholdLevelsCallback</code> functor, and user-chosen values for the "factory default" threshold levels. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First we define three <code>static</code> functions that are employed by the two functors. The <code>toLower</code> function implements our category name filter. It is wrapped within a functor object and maps category names to lower-case: <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keyword">static</span>
    <span class="keywordtype">void</span> toLower(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> *buffer, <span class="keyword">const</span> <span class="keywordtype">char</span> *s)
    {
        assert(buffer);
        assert(s);

        buffer-&gt;<a class="code" href="group__bslstl__string.html#ga1bade383cf64eed66f1c43ae0aa450a5">clear</a>();
        <span class="keywordflow">while</span> (*s) {
            buffer-&gt;<a class="code" href="group__bslstl__string.html#ga6cf77eba8e1c6889f82179256b876446">push_back</a>(bsl::tolower(static_cast&lt;unsigned char&gt;(*s)));
            ++s;
        }
        buffer-&gt;<a class="code" href="group__bslstl__string.html#ga6cf77eba8e1c6889f82179256b876446">push_back</a>(0);
    }
</pre></div><br/>
<br/>
 The following two functions provide the implementation for our <code>DefaultThresholdLevelsCallback</code> functor. The <code>inheritThresholdLevels</code> function is wrapped within a functor object; the <code>getDefaultThresholdLevels</code> function is a helper that does the hard work. We assume a hierarchical category naming scheme that uses <code>.</code> to delimit the constituents of names. For example, the three categories named "x", "x.y", and "x.y.z" are related in the sense that "x" is an ancestor of both "x.y" and "x.y.z", and "x.y" is an ancestor "x.y.z". Suppose that "x" is added to the registry first. If "x.y" is then added to the registry by calling <code>setCategory(const char *)</code>, it would "inherit" threshold level values from "x". Similarly, when "x.y.z" is added to the registry by calling the 1-argument <code>setCategory</code> method, it inherits threshold level values from "x.y" (i.e., a category inherits from its nearest ancestor that exists in the registry when it is added). Note that a category named "xx.y" (for example) is not related to either of "x", "x.y", or "x.y.z": <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keyword">static</span>
    <span class="keywordtype">int</span> getDefaultThresholdLevels(
                                 <span class="keywordtype">int</span>                        *recordLevel,
                                 <span class="keywordtype">int</span>                        *passLevel,
                                 <span class="keywordtype">int</span>                        *triggerLevel,
                                 <span class="keywordtype">int</span>                        *triggerAllLevel,
                                 <span class="keywordtype">char</span>                        delimiter,
                                 <span class="keyword">const</span> <a class="code" href="classball_1_1LoggerManager.html">ball::LoggerManager</a>&amp;  loggerManager,
                                 <span class="keyword">const</span> <span class="keywordtype">char</span>                 *categoryName)
        <span class="comment">// Obtain appropriate threshold levels for the category having the</span>
        <span class="comment">// specified &#39;categoryName&#39; by searching the registry of the</span>
        <span class="comment">// specified &#39;loggerManager&#39;, and store the resulting values at the</span>
        <span class="comment">// specified &#39;recordLevel&#39;, &#39;passLevel&#39;, &#39;triggerLevel&#39;, and</span>
        <span class="comment">// &#39;triggerAllLevel&#39; addresses.  A hierarchical category naming</span>
        <span class="comment">// scheme is assumed that employs the specified &#39;delimiter&#39; to</span>
        <span class="comment">// separate the components of category names.  Return 0 on success,</span>
        <span class="comment">// and a non-zero value otherwise.  The behavior is undefined unless</span>
        <span class="comment">// &#39;recordLevel&#39;, &#39;passLevel&#39;, &#39;triggerLevel&#39;, and &#39;triggerAllLevel&#39;</span>
        <span class="comment">// are non-null, and &#39;categoryName&#39; is null-terminated.</span>
    {
        assert(recordLevel);
        assert(passLevel);
        assert(triggerLevel);
        assert(triggerAllLevel);
        assert(categoryName);

        <span class="keyword">enum</span> { SUCCESS = 0, FAILURE = -1 };

        <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> buffer(categoryName);
        <span class="keywordflow">while</span> (1) {
            <span class="keyword">const</span> ball::Category *category =
                               loggerManager.<a class="code" href="classball_1_1LoggerManager.html#a283604010005c7392eb26d7d5cf82ecd">lookupCategory</a>(buffer.<a class="code" href="group__bslstl__string.html#gae8d40a93bd2ebc7ae696c6f63b3995c9">c_str</a>());
            <span class="keywordflow">if</span> (0 != category) {
                *recordLevel     = category-&gt;<a class="code" href="classCategory.html#aa39bfc26a269570a5aa52711aa94a485">recordLevel</a>();
                *passLevel       = category-&gt;passLevel();
                *triggerLevel    = category-&gt;triggerLevel();
                *triggerAllLevel = category-&gt;triggerAllLevel();
                <span class="keywordflow">return</span> SUCCESS;                                     <span class="comment">// RETURN</span>
            }

            <span class="keyword">const</span> <span class="keywordtype">char</span> *newEnd = bsl::strrchr(buffer.<a class="code" href="group__bslstl__string.html#gae8d40a93bd2ebc7ae696c6f63b3995c9">c_str</a>(), delimiter);
            <span class="keywordflow">if</span> (0 == newEnd) {
                <span class="keywordflow">return</span> FAILURE;                                     <span class="comment">// RETURN</span>
            }
            buffer.<a class="code" href="group__bslstl__string.html#ga25b862783d3d32a02bff9aa4c9e1a4c4">resize</a>(newEnd - buffer.<a class="code" href="group__bslstl__string.html#ga18243cc2ae7fe91eee167259e0a98d0a">data</a>());
        }
    }

    <span class="keyword">static</span>
    <span class="keywordtype">void</span> inheritThresholdLevels(<span class="keywordtype">int</span>        *recordLevel,
                                <span class="keywordtype">int</span>        *passLevel,
                                <span class="keywordtype">int</span>        *triggerLevel,
                                <span class="keywordtype">int</span>        *triggerAllLevel,
                                <span class="keyword">const</span> <span class="keywordtype">char</span> *categoryName)
        <span class="comment">// Obtain appropriate threshold levels for the category having the</span>
        <span class="comment">// specified &#39;categoryName&#39;, and store the resulting values at the</span>
        <span class="comment">// specified &#39;recordLevel&#39;, &#39;passLevel&#39;, &#39;triggerLevel&#39;, and</span>
        <span class="comment">// &#39;triggerAllLevel&#39; addresses.  The behavior is undefined unless</span>
        <span class="comment">// &#39;recordLevel&#39;, &#39;passLevel&#39;, &#39;triggerLevel&#39;, and &#39;triggerAllLevel&#39;</span>
        <span class="comment">// are non-null, and &#39;categoryName&#39; is null-terminated.</span>
    {
        assert(recordLevel);
        assert(passLevel);
        assert(triggerLevel);
        assert(triggerAllLevel);
        assert(categoryName);

        <span class="keyword">const</span> <a class="code" href="classball_1_1LoggerManager.html">ball::LoggerManager</a>&amp; manager =
                                            <a class="code" href="classball_1_1LoggerManager.html#a7ff8e9a0233a7bb2849a1681f24779b5">ball::LoggerManager::singleton</a>();
        <span class="keywordflow">if</span> (0 != getDefaultThresholdLevels(recordLevel,
                                           passLevel,
                                           triggerLevel,
                                           triggerAllLevel,
                                           <span class="charliteral">&#39;.&#39;</span>,
                                           manager,
                                           categoryName)) {
            *recordLevel     = manager.<a class="code" href="classball_1_1LoggerManager.html#a96a4cb5eff2c02d9afca0e08469055dc">defaultRecordThresholdLevel</a>();
            *passLevel       = manager.<a class="code" href="classball_1_1LoggerManager.html#abf1de121e491b7366851491b038112f9">defaultPassThresholdLevel</a>();
            *triggerLevel    = manager.<a class="code" href="classball_1_1LoggerManager.html#a7e90d704d4b8981e4d6de19d43e579c4">defaultTriggerThresholdLevel</a>();
            *triggerAllLevel = manager.<a class="code" href="classball_1_1LoggerManager.html#aa092b0ba78570d863de1bf44555074ab">defaultTriggerAllThresholdLevel</a>();
        }
    }
</pre></div><br/>
<br/>
 As in <a href="group__ball__loggermanager.html#example_1" class="el">Example 1</a> above, we assume that the initialization sequence occurs somewhere near the top of <code>main</code>, and again we use a <code><a class="el" href="classball_1_1DefaultObserver.html">ball::DefaultObserver</a></code> to publish to <code>stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="comment">// myApp2.cpp</span>

    <span class="keywordtype">int</span> main() {

        <span class="comment">// ...</span>

        <span class="keyword">static</span> <a class="code" href="classball_1_1DefaultObserver.html">ball::DefaultObserver</a> observer(&amp;bsl::cout);
</pre></div><br/>
<br/>
 The following wraps the <code>toLower</code> category name filter within a <code>bsl::function</code> functor: <br/>
<br/>
<div class="fragment"><pre class="fragment">        <a class="code" href="classball_1_1LoggerManager.html#a509510b854e085fb9a50a552013f9d5c">ball::LoggerManager::CategoryNameFilterCallback</a> nameFilter(&amp;toLower);
</pre></div><br/>
<br/>
 and the following wraps the <code>inheritThresholdLevels</code> function within a <code>bsl::function</code> functor: <br/>
<br/>
<div class="fragment"><pre class="fragment">        <a class="code" href="classball_1_1LoggerManager.html#ac4dd1c5707d1f628749965d1723b29ee">ball::LoggerManager::DefaultThresholdLevelsCallback</a>
                                 thresholdsCallback(&amp;inheritThresholdLevels);
</pre></div><br/>
<br/>
 Next we define four values for our custom "factory default" thresholds. These values will be stored within the logger manager and will be available to all users whenever the "factory defaults" are needed, for the life of the logger manager. In this example, however, we will also be installing the <code>thresholdsCallback</code> defined above, so unless that functor is un-installed (by a call to <code>setDefaultThresholdLevelsCallback</code>), these four "factory
 defaults" will have no practical effect, since the callback mechanism "steps
 in front of" the default values: <br/>
<br/>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">int</span> recordLevel     = 125;
        <span class="keywordtype">int</span> passLevel       = 100;
        <span class="keywordtype">int</span> triggerLevel    =  75;
        <span class="keywordtype">int</span> triggerAllLevel =  50;
</pre></div><br/>
<br/>
 Now we can configure a <code><a class="el" href="classball_1_1LoggerManagerDefaults.html">ball::LoggerManagerDefaults</a></code> object, <code>defaults</code>, with these four threshold values. <code>defaults</code> can then be used to configure the <code><a class="el" href="classball_1_1LoggerManagerConfiguration.html">ball::LoggerManagerConfiguration</a></code> object that will be passed to the <code><a class="el" href="classball_1_1LoggerManagerScopedGuard.html">ball::LoggerManagerScopedGuard</a></code> constructor (below): <br/>
<br/>
<div class="fragment"><pre class="fragment">        <a class="code" href="classball_1_1LoggerManagerDefaults.html">ball::LoggerManagerDefaults</a> defaults;
        defaults.<a class="code" href="classball_1_1LoggerManagerDefaults.html#abb6de1706668fd5813d324308de162f3">setDefaultThresholdLevelsIfValid</a>(recordLevel,
                                                  passLevel,
                                                  triggerLevel,
                                                  triggerAllLevel);
</pre></div><br/>
<br/>
 With <code>defaults</code> and the callback functors defined above, we can now create and set the <code><a class="el" href="classball_1_1LoggerManagerConfiguration.html">ball::LoggerManagerConfiguration</a></code> object, <code>configuration</code>, that will describe our desired configuration: <br/>
<br/>
<div class="fragment"><pre class="fragment">        <a class="code" href="classball_1_1LoggerManagerConfiguration.html">ball::LoggerManagerConfiguration</a> configuration;
        configuration.<a class="code" href="classball_1_1LoggerManagerConfiguration.html#ab29b33ceb22d891a7ab41f8c478fe8ef">setDefaultValues</a>(defaults);
        configuration.<a class="code" href="classball_1_1LoggerManagerConfiguration.html#a728570d80c469d6e0976ded4afd6b2b2">setCategoryNameFilterCallback</a>(nameFilter);
        configuration.<a class="code" href="classball_1_1LoggerManagerConfiguration.html#a24409daa10c6e1de4642ede45296abb0">setDefaultThresholdLevelsCallback</a>(thresholdsCallback);
</pre></div><br/>
<br/>
 Finally, we can instantiate the singleton logger manager, passing in the <code>observer</code> and <code>configuration</code> that we have just created: <br/>
<br/>
<div class="fragment"><pre class="fragment">        <a class="code" href="classball_1_1LoggerManagerScopedGuard.html">ball::LoggerManagerScopedGuard</a> guard(&amp;observer, configuration);
        <a class="code" href="classball_1_1LoggerManager.html">ball::LoggerManager</a>&amp; manager = <a class="code" href="classball_1_1LoggerManager.html#a7ff8e9a0233a7bb2849a1681f24779b5">ball::LoggerManager::singleton</a>();
</pre></div><br/>
<br/>
 The application is now prepared to log messages using the <code>ball</code> logging subsystem, but first we will demonstrate the functors and client-supplied default threshold overrides. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, assume that we are not in the same lexical scope, and so we cannot see <code>manager</code> above. We must therefore obtain a reference to the singleton logger manager: <br/>
<br/>
<div class="fragment"><pre class="fragment">        <a class="code" href="classball_1_1LoggerManager.html">ball::LoggerManager</a>&amp; loggerManager =
                                            <a class="code" href="classball_1_1LoggerManager.html#a7ff8e9a0233a7bb2849a1681f24779b5">ball::LoggerManager::singleton</a>();
</pre></div><br/>
<br/>
 Next obtain a reference to the <em>Default</em> <em><a class="el" href="classCategory.html">Category</a></em> and <code>assert</code> that its threshold levels match the client-supplied values that overrode the "factory-supplied" default values: <br/>
<br/>
<div class="fragment"><pre class="fragment">        <span class="keyword">const</span> ball::Category&amp; defaultCategory =
                                             loggerManager.<a class="code" href="classball_1_1LoggerManager.html#a101ce51fd59ece392b5848fc7578b980">defaultCategory</a>();
        assert(125 == defaultCategory.recordLevel());
        assert(100 == defaultCategory.passLevel());
        assert( 75 == defaultCategory.triggerLevel());
        assert( 50 == defaultCategory.triggerAllLevel());
</pre></div><br/>
<br/>
 Next add a category named "BloombergLP" (by calling <code>addCategory</code>). Note that the logger manager invokes the supplied category name filter to map the category name to lower-case before the new category is added to the category registry. The name filter is also invoked by <code>lookupCategory</code> whenever a category is searched for (i.e., by name) in the registry: <br/>
<br/>
<div class="fragment"><pre class="fragment">        <span class="keyword">const</span> ball::Category *blpCategory =
                   loggerManager.<a class="code" href="classball_1_1LoggerManager.html#a53fe78b8ae4797eaf7cbe668296e7399">addCategory</a>(<span class="stringliteral">&quot;BloombergLP&quot;</span>, 128, 96, 64, 32);
        assert(blpCategory == loggerManager.<a class="code" href="classball_1_1LoggerManager.html#a283604010005c7392eb26d7d5cf82ecd">lookupCategory</a>(<span class="stringliteral">&quot;BLOOMBERGLP&quot;</span>));
        assert(  0 == bsl::strcmp(<span class="stringliteral">&quot;bloomberglp&quot;</span>,
                                  blpCategory-&gt;categoryName()));
        assert(128 == blpCategory-&gt;recordLevel());
        assert( 96 == blpCategory-&gt;passLevel());
        assert( 64 == blpCategory-&gt;triggerLevel());
        assert( 32 == blpCategory-&gt;triggerAllLevel());
</pre></div><br/>
<br/>
 Next add a second category named "BloombergLP.bal.ball" (by calling <code>setCategory</code>) and <code>assert</code> that the threshold levels are "inherited" from category "BloombergLP": <br/>
<br/>
<div class="fragment"><pre class="fragment">        <span class="keyword">const</span> ball::Category *ballCategory =
                           loggerManager.<a class="code" href="classball_1_1LoggerManager.html#af3984882f22b6db07ee6d6ff25c46bcb">setCategory</a>(<span class="stringliteral">&quot;BloombergLP.bal.ball&quot;</span>);
        assert(ballCategory ==
                       loggerManager.<a class="code" href="classball_1_1LoggerManager.html#a283604010005c7392eb26d7d5cf82ecd">lookupCategory</a>(<span class="stringliteral">&quot;bloomberglp.bal.ball&quot;</span>));
        assert(  0 == bsl::strcmp(<span class="stringliteral">&quot;bloomberglp.bal.ball&quot;</span>,
                                  ballCategory-&gt;categoryName()));
        assert(128 == ballCategory-&gt;recordLevel());
        assert( 96 == ballCategory-&gt;passLevel());
        assert( 64 == ballCategory-&gt;triggerLevel());
        assert( 32 == ballCategory-&gt;triggerAllLevel());
</pre></div><br/>
<br/>
 Finally add a third category named "Other.equities", again by calling <code>setCategory</code>. This category has no ancestor currently in the registry, so its threshold levels match those of the <em>Default</em> <em><a class="el" href="classCategory.html">Category</a></em>: <br/>
<br/>
<div class="fragment"><pre class="fragment">        <span class="keyword">const</span> ball::Category *equitiesCategory =
                           loggerManager.<a class="code" href="classball_1_1LoggerManager.html#af3984882f22b6db07ee6d6ff25c46bcb">setCategory</a>(<span class="stringliteral">&quot;Other.equities&quot;</span>);
        assert(equitiesCategory ==
                       loggerManager.<a class="code" href="classball_1_1LoggerManager.html#a283604010005c7392eb26d7d5cf82ecd">lookupCategory</a>(<span class="stringliteral">&quot;OTHER.EQUITIES&quot;</span>));
        assert(  0 == bsl::strcmp(<span class="stringliteral">&quot;other.equities&quot;</span>,
                                  equitiesCategory-&gt;categoryName()));
        assert(125 == equitiesCategory-&gt;recordLevel());
        assert(100 == equitiesCategory-&gt;passLevel());
        assert( 75 == equitiesCategory-&gt;triggerLevel());
        assert( 50 == equitiesCategory-&gt;triggerAllLevel());

        <span class="comment">// ...</span>

        <span class="keywordflow">return</span> 0;
    }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_efficient_logging_of_ostream-able_objects"></a> <a class="anchor" id="usage.example_3~3A_efficient_logging_of_ostream-able_objects"></a> <a class="anchor" id="description.usage.example_3~3A_efficient_logging_of_ostream-able_objects"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.8.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Efficient Logging of ostream-able Objects: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example demonstrates how instances of a class supporting streaming to <code>bsl::ostream</code> (via overloaded <code>operator&lt;&lt;</code>) can be logged. It also demonstrates how to use the <code>logMessage</code> method to log messages to a logger. Suppose we want to <em>efficiently</em> log instances of the following class: <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keyword">class </span>Information {
        <span class="comment">// This (incomplete) class is a simple aggregate of a &quot;heading&quot; and</span>
        <span class="comment">// &quot;contents&quot; pertaining to that heading.  It serves to illustrate</span>
        <span class="comment">// how to log the string representation of an object.</span>

        <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_heading;
        <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_contents;

      <span class="keyword">public</span>:
        Information(<span class="keyword">const</span> <span class="keywordtype">char</span> *heading, <span class="keyword">const</span> <span class="keywordtype">char</span> *contents);
        ~Information();
        <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; heading() <span class="keyword">const</span>;
        <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; contents() <span class="keyword">const</span>;
    };
</pre></div><br/>
<br/>
 In addition, we define the following free operator for streaming instances of <code>Information</code> to an <code>bsl::ostream</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">    bsl::ostream&amp; <a class="code" href="namespacebalb.html#a777d713a1c54d1359c8cb8144cc50b7a">operator&lt;&lt;</a>(bsl::ostream&amp;      stream,
                             <span class="keyword">const</span> Information&amp; information)
    {
        stream &lt;&lt; information.heading()  &lt;&lt; bsl::endl;
        stream &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>;
        stream &lt;&lt; information.contents() &lt;&lt; bsl::endl;
        <span class="keywordflow">return</span> stream;
    }
</pre></div><br/>
<br/>
 The following function logs an <code>Information</code> object to the specified <code>logger</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> logInformation(<a class="code" href="classball_1_1Logger.html">ball::Logger</a>          *logger,
                        <span class="keyword">const</span> Information&amp;     information,
                        <a class="code" href="structball_1_1Severity.html#af49f66189615b9475c9cced03afde384">ball::Severity::Level</a>  severity,
                        <span class="keyword">const</span> ball::Category&amp;  category,
                        <span class="keyword">const</span> <span class="keywordtype">char</span>            *fileName,
                        <span class="keywordtype">int</span>                    lineNumber)
    {
</pre></div><br/>
<br/>
 First, obtain a record that has its <code>fileName</code> and <code>lineNumber</code> attributes set: <br/>
<br/>
<div class="fragment"><pre class="fragment">        <a class="code" href="classball_1_1Record.html">ball::Record</a> *record = logger-&gt;<a class="code" href="classball_1_1Logger.html#a60a17bb89c6b9199685c162d82e1f37c">getRecord</a>(fileName, lineNumber);
</pre></div><br/>
<br/>
 Next, get a modifiable reference to the fixed fields of <code>record</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">        <a class="code" href="classball_1_1RecordAttributes.html">ball::RecordAttributes</a>&amp; attributes = record-&gt;<a class="code" href="classball_1_1Record.html#a9bb8119e7b614cc2afedccf02bba1aa1">fixedFields</a>();
</pre></div><br/>
<br/>
 Create a <code>bsl::ostream</code> to which the string representation <code>information</code> can be output. Note that <code>stream</code> is supplied with the stream buffer of <code>record</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">        bsl::ostream stream(&amp;attributes.<a class="code" href="classball_1_1RecordAttributes.html#aa8f5b533b4bae8e68c75e647bf670810">messageStreamBuf</a>());
</pre></div><br/>
<br/>
 Now stream <code>information</code> into our output <code>stream</code>. This will set the message attribute of <code>record</code> to the streamed data: <br/>
<br/>
<div class="fragment"><pre class="fragment">        stream &lt;&lt; information;
</pre></div><br/>
<br/>
 Finally, log <code>record</code> using <code>logger</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">        logger-&gt;logMessage(category, severity, record);
    }
</pre></div><br/>
<br/>
 Notice that we did not need to allocate a scratch buffer to stream the object contents into. That would have required an extra copy and the cost of allocation and deallocation, and thus would have been more inefficient. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_4~3A_logging_using_a_ball~3A~3Alogger"></a> <a class="anchor" id="usage.example_4~3A_logging_using_a_ball~3A~3Alogger"></a> <a class="anchor" id="description.usage.example_4~3A_logging_using_a_ball~3A~3Alogger"></a> <a class="anchor" id="example_4"></a> <a class="anchor" id="usage.example_4"></a> <a class="anchor" id="description.usage.example_4"></a> <a class="anchor" id="3.8.4"></a> </dd></dl>
<dl class="user"><dt><b>Example 4: Logging Using a ball::Logger: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates using the a <code><a class="el" href="classball_1_1Logger.html">ball::Logger</a></code> directly to log messages. In practice, clients are encouraged to use the logging macros (see <a href="group__ball__log.html" class="el"><code>ball_log</code></a>, which cannot be shown here for dependency reasons. The following example assumes logging has been correctly initialized (see prior examples). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following simple <code>factorial</code> function takes and returns values of type <code>int</code>. Note that this function has a very limited range of input, namely integers in the range <code>[0 .. 13]</code>. This limited range serves to illustrate a usage pattern of the logger, namely to log "warnings" whenever a key function is given bad input. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For this example, it is sufficient to use the severity levels defined in the <code><a class="el" href="structball_1_1Severity.html#af49f66189615b9475c9cced03afde384">ball::Severity::Level</a></code> enumeration: <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keyword">enum</span> Level {
        OFF   =   0,  <span class="comment">// disable generation of corresponding message</span>
        FATAL =  32,  <span class="comment">// a condition that will (likely) cause a *crash*</span>
        ERROR =  64,  <span class="comment">// a condition that *will* cause incorrect behavior</span>
        WARN  =  96,  <span class="comment">// a *potentially* problematic condition</span>
        INFO  = 128,  <span class="comment">// data about the running process</span>
        DEBUG = 160,  <span class="comment">// information useful while debugging</span>
        TRACE = 192   <span class="comment">// execution trace data</span>
    };
</pre></div><br/>
<br/>
 Note that the intervals left between enumerator values allow applications to define additional values in case there is a desire to log with more finely-graduated levels of severity. We will not need that granularity here; <code><a class="el" href="structball_1_1Severity.html#af49f66189615b9475c9cced03afde384a784431e47d4121459476d62efde5b97e" title="a potentially problematic condition">ball::Severity::e_WARN</a></code> is appropriate to log a warning message if the input argument to our factorial function is not in this range of values. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We will register a unique category for this function, so that logged messages from our function will be identified in the published output. Also, with a unique category name, the logging behavior of this function can be administered by resetting the various threshold levels for the category. In this example, we will accept the default thresholds. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>setCategory</code> method accepts a name and returns the address of a <code>ball::Category</code> with that name or, in some circumstances, the address of the <em>Default</em> <em><a class="el" href="classCategory.html">Category</a></em> (see the function-level documentation of <code>setCategory</code> for details). The address returned by <code>setCategory</code> is stored in a function-static pointer variable (i.e., it is fetched only once upon first use). In this example, we assume that we are writing a function for Equities Graphics that will live in that group's Math library. The dot "delimiters" (<code>.</code>) have no particular significance to the logger, but may be used by the administration methods to "induce" a hierarchical behavior on our category, should that be useful. See, e.g., the callback functor <code><a class="el" href="classball_1_1LoggerManager.html#ac4dd1c5707d1f628749965d1723b29ee">ball::LoggerManager::DefaultThresholdLevelsCallback</a></code> and its documentation, and <a href="group__ball__loggermanager.html#example_2" class="el">Example 2</a> above for information on how to use category names to customize logger behavior: <br/>
<br/>
<div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span> factorial(<span class="keywordtype">int</span> n)
       <span class="comment">// Return the factorial of the specified value &#39;n&#39; if the factorial</span>
       <span class="comment">// can be represented as an &#39;int&#39;, and a negative value otherwise.</span>
   {
       <span class="keyword">static</span> <span class="keyword">const</span> ball::Category *factorialCategory =
           <a class="code" href="classball_1_1LoggerManager.html#a7ff8e9a0233a7bb2849a1681f24779b5">ball::LoggerManager::singleton</a>().setCategory(
                                         <span class="stringliteral">&quot;equities.graphics.math.factorial&quot;</span>);
</pre></div><br/>
<br/>
 We must also obtain a reference to a logger by calling the logger manager <code>getLogger</code> method. Note that this logger may not safely be cached as a function <code>static</code> variable since our function may be called in different threads having different loggers. Even in a single-threaded program, the owner of <code>main</code> is free to install new loggers at any point, so a statically-cached logger would be a problem: <br/>
<br/>
<div class="fragment"><pre class="fragment">       <a class="code" href="classball_1_1Logger.html">ball::Logger</a>&amp; logger = <a class="code" href="classball_1_1LoggerManager.html#a7ff8e9a0233a7bb2849a1681f24779b5">ball::LoggerManager::singleton</a>().getLogger();
</pre></div><br/>
<br/>
 Now we validate the input value <code>n</code>. If <code>n</code> is either negative or too large, we will log a warning message (at severity level <code><a class="el" href="structball_1_1Severity.html#af49f66189615b9475c9cced03afde384a784431e47d4121459476d62efde5b97e" title="a potentially problematic condition">ball::Severity::e_WARN</a></code>) and return a negative value. Note that calls to <code>logMessage</code> have no run-time overhead (beyond the execution of a simple <code>if</code> test) unless <code><a class="el" href="structball_1_1Severity.html#af49f66189615b9475c9cced03afde384a784431e47d4121459476d62efde5b97e" title="a potentially problematic condition">ball::Severity::e_WARN</a></code> is at least as severe as one of the threshold levels of <code>factorialCategory</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">       <span class="keywordflow">if</span> (0 &gt; n) {
           logger.logMessage(*factorialCategory,
                             <a class="code" href="structball_1_1Severity.html#af49f66189615b9475c9cced03afde384a784431e47d4121459476d62efde5b97e" title="a potentially problematic condition">ball::Severity::e_WARN</a>,
                             __FILE__,
                             __LINE__,
                             <span class="stringliteral">&quot;Attempt to take factorial of negative value.&quot;</span>);
           <span class="keywordflow">return</span> n;
       }

       <span class="keyword">enum</span> { MAX_ARGUMENT = 13 };  <span class="comment">// maximum value accepted by &#39;factorial&#39;</span>

       <span class="keywordflow">if</span> (MAX_ARGUMENT &lt; n) {
           logger.logMessage(*factorialCategory,
                             <a class="code" href="structball_1_1Severity.html#af49f66189615b9475c9cced03afde384a784431e47d4121459476d62efde5b97e" title="a potentially problematic condition">ball::Severity::e_WARN</a>,
                             __FILE__,
                             __LINE__,
                             <span class="stringliteral">&quot;Result too large for &#39;int&#39;.&quot;</span>);
           <span class="keywordflow">return</span> -n;
       }
</pre></div><br/>
<br/>
 The remaining code proceeds mostly as expected, but adds one last message that tracks control flow when <code><a class="el" href="structball_1_1Severity.html#af49f66189615b9475c9cced03afde384a408b2a730cc5f8a215d6ebe0cfb6a8fd" title="execution trace data">ball::Severity::e_TRACE</a></code> is at least as severe as one of the threshold levels of <code>factorialCategory</code> (e.g., as might be the case during debugging): <br/>
<br/>
<div class="fragment"><pre class="fragment">       <span class="keywordtype">int</span> product = 1;
       <span class="keywordflow">while</span> (1 &lt; n) {
           product *= n;
           --n;
       }

       logger.logMessage(*factorialCategory,
                         <a class="code" href="structball_1_1Severity.html#af49f66189615b9475c9cced03afde384a408b2a730cc5f8a215d6ebe0cfb6a8fd" title="execution trace data">ball::Severity::e_TRACE</a>,
                         __FILE__,
                         __LINE__,
                         <span class="stringliteral">&quot;Exiting &#39;factorial&#39; successfully.&quot;</span>);

       <span class="keywordflow">return</span> product;
   }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:32 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
