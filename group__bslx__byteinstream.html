<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslx_byteinstream Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslx_byteinstream<br/>
<small>
[<a class="el" href="group__bslx.html">Package bslx</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a stream class for unexternalization of fundamental types.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslx.html">bslx</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Basic Unexternalization</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a stream class for unexternalization of fundamental types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslx_1_1ByteInStream.html">bslx::ByteInStream</a> </td><td>byte-array-based input stream for fundamental types  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslx__byteoutstream.html" title="Provide a stream class for externalization of fundamental types.">Component bslx_byteoutstream</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements a byte-array-based input stream class, <code><a class="el" href="classbslx_1_1ByteInStream.html">bslx::ByteInStream</a></code>, that provides platform-independent input methods ("unexternalization") on values, and arrays of values, of fundamental types, and on <code>bsl::string</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbslx_1_1ByteInStream.html">bslx::ByteInStream</a></code> type reads from a user-supplied buffer directly, with no data copying or assumption of ownership. The user must therefore make sure that the lifetime and visibility of the buffer is sufficient to satisfy the needs of the input stream. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component is intended to be used in conjunction with the <code>bslx_byteoutstream</code> "externalization" component. Each input method of <code><a class="el" href="classbslx_1_1ByteInStream.html">bslx::ByteInStream</a></code> reads either a value or a homogeneous array of values of a fundamental type, in a format that was written by the corresponding <code><a class="el" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a></code> method. In general, the user of this component cannot rely on being able to read data that was written by any mechanism other than <code><a class="el" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The supported types and required content are listed in the <code>bslx</code> package-level documentation under "Supported Types". </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that input streams can be <em>invalidated</em> explicitly and queried for <em>validity</em> and <em>emptiness</em>. Reading from an initially invalid stream has no effect. Attempting to read beyond the end of a stream will automatically invalidate the stream. Whenever an inconsistent value is detected, the stream should be invalidated explicitly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_basic_unexternalization"></a> <a class="anchor" id="usage.example_1~3A_basic_unexternalization"></a> <a class="anchor" id="description.usage.example_1~3A_basic_unexternalization"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Unexternalization: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we wish to implement a (deliberately simple) <code>MyPerson</code> class as a value-semantic object that supports BDEX externalization and unexternalization. In addition to whatever data and methods that we choose to put into our design, we must supply three methods having specific names and signatures in order to comply with the BDEX protocol: a class method <code>maxSupportedBdexVersion</code>, an accessor (i.e., a <code>const</code> method) <code>bdexStreamOut</code>, and a manipulator (i.e., a non-'const' method) <code>bdexStreamIn</code>. This example shows how to implement those three methods. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example we will not worry overly about "good design" of the <code>MyPerson</code> component, and we will declare but not implement illustrative methods and free operators, except for the three required BDEX methods, which are implemented in full. In particular, we will not make explicit use of <code>bslma</code> allocators; a more complete design would do so: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we implement <code>MyPerson</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyPerson {
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_firstName;
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_lastName;
      <span class="keywordtype">int</span>         d_age;

      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyPerson&amp;, <span class="keyword">const</span> MyPerson&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="namespacebbldc.html#ac8267f245d1e34795846545f712d0f47">maxSupportedBdexVersion</a>(<span class="keywordtype">int</span> versionSelector);
          <span class="comment">// Return the maximum valid BDEX format version, as indicated by</span>
          <span class="comment">// the specified &#39;versionSelector&#39;, to be passed to the</span>
          <span class="comment">// &#39;bdexStreamOut&#39; method.  Note that it is highly recommended that</span>
          <span class="comment">// &#39;versionSelector&#39; be formatted as &quot;YYYYMMDD&quot;, a date</span>
          <span class="comment">// representation.  Also note that &#39;versionSelector&#39; should be a</span>
          <span class="comment">// *compile*-time-chosen value that selects a format version</span>
          <span class="comment">// supported by both externalizer and unexternalizer.  See the</span>
          <span class="comment">// &#39;bslx&#39; package-level documentation for more information on BDEX</span>
          <span class="comment">// streaming of value-semantic types and containers.</span>

      <span class="comment">// CREATORS</span>
      MyPerson();
          <span class="comment">// Create a default person.</span>

      MyPerson(<span class="keyword">const</span> <span class="keywordtype">char</span> *firstName, <span class="keyword">const</span> <span class="keywordtype">char</span> *lastName, <span class="keywordtype">int</span> age);
          <span class="comment">// Create a person having the specified &#39;firstName&#39;, &#39;lastName&#39;,</span>
          <span class="comment">// and &#39;age&#39;.</span>

      MyPerson(<span class="keyword">const</span> MyPerson&amp; original);
          <span class="comment">// Create a person having the value of the specified &#39;original&#39;</span>
          <span class="comment">// person.</span>

      ~MyPerson();
          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      MyPerson&amp; operator=(<span class="keyword">const</span> MyPerson&amp; rhs);
          <span class="comment">// Assign to this person the value of the specified &#39;rhs&#39; person,</span>
          <span class="comment">// and return a reference to this person.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebbldc.html#a7fd2d27c8ca153888e33f4c09f0fd913">bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version);
          <span class="comment">// Assign to this object the value read from the specified input</span>
          <span class="comment">// &#39;stream&#39; using the specified &#39;version&#39; format, and return a</span>
          <span class="comment">// reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this</span>
          <span class="comment">// operation has no effect.  If &#39;version&#39; is not supported, this</span>
          <span class="comment">// object is unaltered and &#39;stream&#39; is invalidated, but otherwise</span>
          <span class="comment">// unmodified.  If &#39;version&#39; is supported but &#39;stream&#39; becomes</span>
          <span class="comment">// invalid during this operation, this object has an undefined, but</span>
          <span class="comment">// valid, state.  Note that no version is read from &#39;stream&#39;.  See</span>
          <span class="comment">// the &#39;bslx&#39; package-level documentation for more information on</span>
          <span class="comment">// BDEX streaming of value-semantic types and containers.</span>

      <span class="comment">//...</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> age() <span class="keyword">const</span>;
          <span class="comment">// Return the age of this person.</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
      STREAM&amp; <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version) <span class="keyword">const</span>;
          <span class="comment">// Write the value of this object, using the specified &#39;version&#39;</span>
          <span class="comment">// format, to the specified output &#39;stream&#39;, and return a reference</span>
          <span class="comment">// to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation</span>
          <span class="comment">// has no effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is</span>
          <span class="comment">// invalidated, but otherwise unmodified.  Note that &#39;version&#39; is</span>
          <span class="comment">// not written to &#39;stream&#39;.  See the &#39;bslx&#39; package-level</span>
          <span class="comment">// documentation for more information on BDEX streaming of</span>
          <span class="comment">// value-semantic types and containers.</span>

      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; firstName() <span class="keyword">const</span>;
          <span class="comment">// Return the first name of this person.</span>

      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; lastName() <span class="keyword">const</span>;
          <span class="comment">// Return the last name of this person.</span>

      <span class="comment">//...</span>

  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyPerson&amp; lhs, <span class="keyword">const</span> MyPerson&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; person objects have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  Two person objects have the</span>
      <span class="comment">// same value if they have the same first name, last name, and age.</span>

  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#af875b084e6111d26ceea345a0cc0b642">operator!=</a>(<span class="keyword">const</span> MyPerson&amp; lhs, <span class="keyword">const</span> MyPerson&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; person objects do not</span>
      <span class="comment">// have the same value, and &#39;false&#39; otherwise.  Two person objects</span>
      <span class="comment">// differ in value if they differ in first name, last name, or age.</span>

  <span class="comment">// ========================================================================</span>
  <span class="comment">//                  INLINE FUNCTION DEFINITIONS</span>
  <span class="comment">// ========================================================================</span>

  <span class="comment">// CLASS METHODS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> <a class="code" href="namespacebbldc.html#ac8267f245d1e34795846545f712d0f47">MyPerson::maxSupportedBdexVersion</a>(<span class="keywordtype">int</span> <span class="comment">/* versionSelector */</span>) {
      <span class="keywordflow">return</span> 1;
  }

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  MyPerson::MyPerson()
  : d_firstName(<span class="stringliteral">&quot;&quot;</span>)
  , d_lastName(<span class="stringliteral">&quot;&quot;</span>)
  , d_age(0)
  {
  }

  <span class="keyword">inline</span>
  MyPerson::MyPerson(<span class="keyword">const</span> <span class="keywordtype">char</span> *firstName, <span class="keyword">const</span> <span class="keywordtype">char</span> *lastName, <span class="keywordtype">int</span> age)
  : d_firstName(firstName)
  , d_lastName(lastName)
  , d_age(age)
  {
  }

  <span class="keyword">inline</span>
  MyPerson::~MyPerson()
  {
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebbldc.html#a7fd2d27c8ca153888e33f4c09f0fd913">MyPerson::bdexStreamIn</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)
  {
      <span class="keywordflow">if</span> (stream) {
          <span class="keywordflow">switch</span> (version) {  <span class="comment">// switch on the &#39;bslx&#39; version</span>
            <span class="keywordflow">case</span> 1: {
              stream.getString(d_firstName);
              <span class="keywordflow">if</span> (!stream) {
                  d_firstName = <span class="stringliteral">&quot;stream error&quot;</span>;  <span class="comment">// *might* be corrupted;</span>
                                                 <span class="comment">//  value for testing</span>
                  <span class="keywordflow">return</span> stream;                                    <span class="comment">// RETURN</span>
              }
              stream.getString(d_lastName);
              <span class="keywordflow">if</span> (!stream) {
                  d_lastName = <span class="stringliteral">&quot;stream error&quot;</span>;  <span class="comment">// *might* be corrupted;</span>
                                                <span class="comment">//  value for testing</span>
                  <span class="keywordflow">return</span> stream;                                    <span class="comment">// RETURN</span>
              }
              stream.getInt32(d_age);
              <span class="keywordflow">if</span> (!stream) {
                  d_age = 999;     <span class="comment">// *might* be corrupted; value for testing</span>
                  <span class="keywordflow">return</span> stream;                                    <span class="comment">// RETURN</span>
              }
            } <span class="keywordflow">break</span>;
            <span class="keywordflow">default</span>: {
              stream.invalidate();
            }
          }
      }
      <span class="keywordflow">return</span> stream;
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> MyPerson::age()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_age;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> STREAM&gt;
  STREAM&amp; <a class="code" href="namespacebbldc.html#a4b1bdb11d0d2a85a2f99b2fd4414b279">MyPerson::bdexStreamOut</a>(STREAM&amp; stream, <span class="keywordtype">int</span> version)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">switch</span> (version) {
        <span class="keywordflow">case</span> 1: {
          stream.putString(d_firstName);
          stream.putString(d_lastName);
          stream.putInt32(d_age);
        } <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>: {
          stream.invalidate();
        } <span class="keywordflow">break</span>;
      }
      <span class="keywordflow">return</span> stream;
  }

  <span class="keyword">inline</span>
  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; MyPerson::firstName()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_firstName;
  }

  <span class="keyword">inline</span>
  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; MyPerson::lastName()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_lastName;
  }

  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> MyPerson&amp; lhs, <span class="keyword">const</span> MyPerson&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.d_firstName == rhs.d_firstName &amp;&amp;
             lhs.d_lastName  == rhs.d_lastName  &amp;&amp;
             lhs.d_age       == rhs.d_age;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#af875b084e6111d26ceea345a0cc0b642">operator!=</a>(<span class="keyword">const</span> MyPerson&amp; lhs, <span class="keyword">const</span> MyPerson&amp; rhs)
  {
      <span class="keywordflow">return</span> !(lhs == rhs);
  }
</pre></div><br/>
<br/>
 Then, we can exercise the new <code>MyPerson</code> value-semantic class by externalizing and reconstituting an object. First, create a <code>MyPerson</code> <code>janeSmith</code> and a <code><a class="el" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a></code> <code>outStream</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyPerson            janeSmith(<span class="stringliteral">&quot;Jane&quot;</span>, <span class="stringliteral">&quot;Smith&quot;</span>, 42);
  <a class="code" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a> outStream(20131127);
  <span class="keyword">const</span> <span class="keywordtype">int</span>           VERSION = 1;
  outStream.putVersion(VERSION);
  janeSmith.bdexStreamOut(outStream, VERSION);
  assert(outStream.isValid());
</pre></div><br/>
<br/>
 Next, create a <code>MyPerson</code> <code>janeCopy</code> initialized to the default value, and assert that <code>janeCopy</code> is different from <code>janeSmith</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyPerson janeCopy;
  assert(janeCopy != janeSmith);
</pre></div><br/>
<br/>
 Then, create a <code><a class="el" href="classbslx_1_1ByteInStream.html">bslx::ByteInStream</a></code> <code>inStream</code> initialized with the buffer from the <code><a class="el" href="classbslx_1_1ByteOutStream.html">bslx::ByteOutStream</a></code> object <code>outStream</code> and unexternalize this data into <code>janeCopy</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslx_1_1ByteInStream.html">bslx::ByteInStream</a> inStream(outStream.data(), outStream.length());
  <span class="keywordtype">int</span>                version;
  inStream.getVersion(version);
  janeCopy.bdexStreamIn(inStream, version);
  assert(inStream.isValid());
</pre></div><br/>
<br/>
 Finally, <code>assert</code> the obtained values are as expected and display the results to <code>bsl::stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(version  == VERSION);
  assert(janeCopy == janeSmith);

  <span class="keywordflow">if</span> (janeCopy == janeSmith) {
      bsl::cout &lt;&lt; <span class="stringliteral">&quot;Successfully serialized and de-serialized Jane Smith:&quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;\n\tFirstName: &quot;</span> &lt;&lt; janeCopy.firstName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tLastName : &quot;</span> &lt;&lt; janeCopy.lastName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tAge      : &quot;</span> &lt;&lt; janeCopy.age() &lt;&lt; bsl::endl;
  }
  <span class="keywordflow">else</span> {
      bsl::cout &lt;&lt; <span class="stringliteral">&quot;Serialization unsuccessful.  &#39;janeCopy&#39; holds:&quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;\n\tFirstName: &quot;</span> &lt;&lt; janeCopy.firstName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tLastName : &quot;</span> &lt;&lt; janeCopy.lastName()
                &lt;&lt; <span class="stringliteral">&quot;\n\tAge      : &quot;</span> &lt;&lt; janeCopy.age() &lt;&lt; bsl::endl;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:11 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
