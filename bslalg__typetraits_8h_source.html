<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslalg_typetraits.h                                                -*-C++-*-
#ifndef INCLUDED_BSLALG_TYPETRAITS
#define INCLUDED_BSLALG_TYPETRAITS

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide facilities for associating types with compile-time traits.
//
//@DEPRECATED: See bslmf_nestedtraitdeclaration.
//
//@CLASSES:
//  bslalg::TypeTraitNil: nil type trait (no traits)
//  bslalg::TypeTraitBitwiseMoveable: bitwise-moveable trait
//  bslalg::TypeTraitBitwiseCopyable: bitwise-copyable trait
//  bslalg::TypeTraitBitwiseEqualityComparable: bitwise-eq.-comparable trait
//  bslalg::TypeTraitHasStlIterators: has STL-like iterators
//  bslalg::TypeTraitHasTrivialDefaultConstructor: has trivial default ctor
//  bslalg::TypeTraitPair: for &#39;std::pair&#39;-like classes
//  bslalg::TypeTraitUsesBslmaAllocator: uses &#39;bslma&#39; allocators
//  bslalg::TypeTraitsGroupStlSequence: for STL sequence containers
//  bslalg::TypeTraitsGroupStlOrdered: for STL ordered containers
//  bslalg::TypeTraitsGroupStlUnordered: for STL unordered containers
//  bslalg_TypeTraits: default trait computation
//
//@MACROS:
//  BSLALG_DECLARE_NESTED_TRAITS: declares a trait in a nested fashion
//  BSLALG_DECLARE_NESTED_TRAITS2: declares two traits in a nested fashion
//  BSLALG_DECLARE_NESTED_TRAITS3: declares three traits in a nested fashion
//  BSLALG_DECLARE_NESTED_TRAITS4: declares four traits in a nested fashion
//  BSLALG_DECLARE_NESTED_TRAITS5: declares five traits in a nested fashion
//  BSLALG_IMPLIES_TRAIT: computes a trait by introspection
//  BSLALG_CHECK_IMPLIED_TRAIT: detects a trait by introspection
//
//@SEE_ALSO: bslmf_typetraits, bslalg_constructorproxy, bslalg_scalarprimitives
//
//@DESCRIPTION: This component provides a set of type traits, and a set of
// macros used to assign traits to user-defined class.  Traits are used to
// enable certain optimizations or discriminations at compile-time.  For
// instance, a class having the trait &#39;bslalg::TypeTraitBitwiseMoveable&#39; may
// allow resizing an array of objects by simply calling &#39;std::memcpy&#39; instead
// of invoking a copy-constructor on every objects.  The usage example shows
// how to use the &#39;bslalg::TypeTraitUsesBslmaAllocator&#39; to propagate allocators
// to nested objects that may require them.
//
// This component should be used in conjunction with other components from the
// package &#39;bslalg&#39;.  See the package-level documentation for an overview.  The
// most useful classes and macros defined in this component are:
//..
//  Entity                                    Description
//  ------                                    -----------
//  bslalg::TypeTraitBitwiseMoveable         (See the corresponding class-level
//  bslalg::TypeTraitBitwiseCopyable                            documentation.)
//  bslalg::TypeTraitBitwiseEqualityComparable
//  bslalg::TypeTraitHasStlIterators
//  bslalg::TypeTraitHasTrivialDefaultConstructor
//  bslalg::TypeTraitPair
//  bslalg::TypeTraitUsesBslmaAllocator
//
//  BSLALG_DECLARE_NESTED_TRAITS(TYPE, TRAIT) A macro to attach a given &#39;TRAIT&#39;
//                                            to a given type &#39;T&#39; in a nested
//                                            fashion.  This macro must be used
//                                            within the &#39;public&#39; section of a
//                                            class body.
//
//  bslalg::HasTrait&lt;TYPE, TRAIT&gt;             This meta-function computes
//                                            whether the parameterized &#39;TYPE&#39;
//                                            possesses the parameterized
//                                            &#39;TRAIT&#39;.
//
//  bslalg::SelectTrait&lt;T, TRAIT1, ...&gt;       This meta-function selects the
//                                            first trait possessed by the
//                                            parameterized &#39;TYPE&#39; from the
//                                            ordered list &#39;TRAIT1&#39;, ....
//..
//
///Usage
///-----
// In this usage example, we show how to enable the &#39;bslma&#39; allocator model for
// generic containers, by implementing simplified versions of the
// &#39;bslalg_constructorproxy&#39; and &#39;bslalg_scalarprimitives&#39; components.  The
// interested reader should refer to the documentation of those components.
//
///A generic container
///- - - - - - - - - -
// Suppose we want to implement a generic container of a parameterized &#39;TYPE&#39;,
// which may or may not follow the &#39;bslma&#39; allocator model.  If it does, our
// container should pass an extra &#39;bslma::Allocator*&#39; argument to copy
// construct a value; but if it does not, then passing this extra argument is
// going to generate a compile-time error.  It thus appears we need two
// implementations of our container.  This can be done more succinctly by
// encapsulating into the constructor some utilities which will, through a
// single interface, determine whether &#39;TYPE&#39; has the trait
// &#39;bslalg::TypeTraitUsesBslmaAllocator&#39; and copy-construct it accordingly.
//
// The container contains a single data member of the parameterized &#39;TYPE&#39;.
// Since we are going to initialize this data member manually, we do not want
// it to be automatically constructed by the compiler.  For this reason, we
// encapsulate it in a &#39;bsls::ObjectBuffer&#39;.
//..
//  // my_genericcontainer.hpp          -*-C++-*-
//
//  template &lt;class TYPE&gt;
//  class MyGenericContainer {
//      // This generic container type contains a single object, always
//      // initialized, which can be replaced and accessed.  This container
//      // always takes an allocator argument and thus follows the
//      // &#39;bslalg::TypeTraitUsesBslmaAllocator&#39; protocol.
//
//      // PRIVATE DATA MEMBERS
//      bsls::ObjectBuffer&lt;TYPE&gt; d_object;
//..
// Since the container offers a uniform interface that always takes an extra
// allocator argument, regardless of whether &#39;TYPE&#39; does or not, we can declare
// it to have the &#39;bslalg::TypeTraitUsesBslmaAllocator&#39; trait:
//..
//  public:
//    // TRAITS
//    BSLALG_DECLARE_NESTED_TRAITS(MyGenericContainer,
//                                 bslalg::TypeTraitUsesBslmaAllocator);
//..
// For simplicity, we let the container contain only a single element, and
// require that an element always be initialized.
//..
//  // CREATORS
//  MyGenericContainer(const TYPE&amp; object, bslma::Allocator *allocator = 0);
//      // Create an container containing the specified &#39;object&#39;, using the
//      // optionally specified &#39;allocator&#39; to allocate memory.  If
//      // &#39;allocator&#39; is 0, the currently installed allocator is used.
//
//  MyGenericContainer(const MyGenericContainer&amp;  container,
//                     bslma::Allocator          *allocator = 0);
//      // Create an container containing the same object as the specified
//      // &#39;container&#39;, using the optionally specified &#39;allocator&#39; to
//      // allocate memory.  If &#39;allocator&#39; is 0, the currently installed
//      // allocator is used.
//
//  ~MyGenericContainer();
//      // Destroy this container.
//..
// We can also allow the container to change the object it contains, by
// granting modifiable as well as non-modifiable access to this object:
//..
//      // MANIPULATORS
//      TYPE&amp; object();
//
//      // ACCESSORS
//      const TYPE&amp; object() const;
//  };
//..
///Using the type traits
///- - - - - - - - - - -
// The challenge in the implementation lays in using the traits of the
// contained &#39;TYPE&#39; to determine whether to pass the allocator argument to its
// copy constructor.  We rely here on a property of templates that templates
// are not compiled (and thus will not generate compilation errors) until they
// are instantiated.  Hence, we can use two function templates, and let the
// overloading resolution (based on the nested traits) decide which to
// instantiate.  The generic way to create an object, passing through all
// arguments (value and allocator) is as follows.  For brevity and to avoid
// breaking the flow of this example, we have embedded the function definition
// into the class.
//..
//  // my_genericcontainer.cpp          -*-C++-*-
//
//  struct my_GenericContainerUtil {
//      // This &#39;struct&#39; provides a namespace for utilities implementing the
//      // allocator pass-through mechanism in a generic container.
//
//      template &lt;class TYPE&gt;
//      static void copyConstruct(TYPE             *location,
//                                const TYPE&amp;       value,
//                                bslma::Allocator *allocator,
//                                bslalg::TypeTraitUsesBslmaAllocator)
//          // Create a copy of the specified &#39;value&#39; at the specified
//          // &#39;location&#39;, using the specified &#39;allocator&#39; to allocate memory.
//      {
//          new (location) TYPE(value, allocator);
//      }
//..
// For types that don&#39;t use an allocator, we offer the following overload which
// will be selected if the type trait of &#39;TYPE&#39; cannot be converted to
// &#39;bslalg::TypeTraitUsesBslmaAllocator&#39;.  In that case, note that the type
// traits always inherits from &#39;bslalg::TypeTraitNil&#39;.
//..
//  template &lt;class TYPE&gt;
//  static void copyConstruct(TYPE             *location,
//                            const TYPE&amp;       value,
//                            bslma::Allocator *allocator,
//                            bslalg::TypeTraitNil)
//      // Create a copy of the specified &#39;value&#39; at the specified
//      // &#39;location&#39;.  Note that the specified &#39;allocator&#39; is ignored.
//  {
//      new (location) TYPE(value);
//  }
//..
// And finally, this function will instantiate the type trait and pass it to
// the appropriately (compiler-)chosen overload:
//..
//      template &lt;class TYPE&gt;
//      static void copyConstruct(TYPE             *location,
//                                const TYPE&amp;       value,
//                                bslma::Allocator *allocator)
//          // Create a copy of the specified &#39;value&#39; at the specified
//          // &#39;location&#39;, optionally using the specified &#39;allocator&#39; to supply
//          // memory if the parameterized &#39;TYPE&#39; possesses the
//          // &#39;bslalg::TypeTraitUsesBslmaAllocator&#39;.
//      {
//          copyConstruct(location, value, allocator,
//                        bslalg_TypeTraits&lt;TYPE&gt;());
//      }
//
//  };
//..
///Generic container implementation
///- - - - - - - - - - - - - - - -
// With these utilities, we can now implement &#39;MyGenericContainer&#39;.
//..
//  // CREATORS
//  template &lt;typename TYPE&gt;
//  MyGenericContainer&lt;TYPE&gt;::MyGenericContainer(const TYPE&amp;       object,
//                                               bslma::Allocator *allocator)
//  {
//      my_GenericContainerUtil::copyConstruct(&amp;d_object.object(),
//                                             object,
//                                             allocator);
//  }
//
//  template &lt;typename TYPE&gt;
//  MyGenericContainer&lt;TYPE&gt;::MyGenericContainer(
//                                        const MyGenericContainer&amp;  container,
//                                        bslma::Allocator          *allocator)
//  {
//      my_GenericContainerUtil::copyConstruct(&amp;d_object.object(),
//                                             container.object(),
//                                             allocator);
//  }
//..
// Note that all this machinery only affects the constructors, and not the
// destructor which only invokes the destructor of &#39;d_object&#39;.
//..
//  template &lt;typename TYPE&gt;
//  MyGenericContainer&lt;TYPE&gt;::~MyGenericContainer()
//  {
//      (&amp;d_object.object())-&gt;~TYPE();
//  }
//..
// To finish, the accessors and manipulators are trivially implemented.
//..
//  // MANIPULATORS
//  template &lt;typename TYPE&gt;
//  TYPE&amp; MyGenericContainer&lt;TYPE&gt;::object()
//  {
//      return d_object.object();
//  }
//
//  // ACCESSORS
//  template &lt;typename TYPE&gt;
//  const TYPE&amp; MyGenericContainer&lt;TYPE&gt;::object() const
//  {
//      return d_object.object();
//  }
//..
///Usage verification
///- - - - - - - - -
// We can check that our container actually forwards the correct allocator to
// its contained objects with a very simple test apparatus, consisting of two
// classes which have exactly the same signature and implementation except that
// one has the &#39;bslalg::TypeTraitUsesBslmaAllocator&#39; trait and the other has
// not:
//..
//  bslma::Allocator *allocSlot;
//
//  struct MyTestTypeWithBslmaAllocatorTraits {
//      // Class with declared traits.  Calling copy constructor without an
//      // allocator will compile, but will not set &#39;allocSlot&#39;.
//
//      // TRAITS
//      BSLALG_DECLARE_NESTED_TRAITS(MyTestTypeWithBslmaAllocatorTraits,
//                           BloombergLP::bslalg::TypeTraitUsesBslmaAllocator);
//
//      // CREATORS
//      MyTestTypeWithBslmaAllocatorTraits() {}
//
//      MyTestTypeWithBslmaAllocatorTraits(
//                       const MyTestTypeWithBslmaAllocatorTraits&amp;,
//                       bslma::Allocator                           *allocator)
//      {
//          allocSlot = allocator;
//      }
//  };
//
//  struct MyTestTypeWithNoBslmaAllocatorTraits {
//      // Class with no declared traits.  Calling copy constructor without
//      // an allocator will not set the &#39;allocSlot&#39;, but passing it by mistake
//      // will set it.
//
//      // CREATORS
//      MyTestTypeWithNoBslmaAllocatorTraits() {}
//
//      MyTestTypeWithNoBslmaAllocatorTraits(
//                    const MyTestTypeWithNoBslmaAllocatorTraits &amp;,
//                    bslma::Allocator                              *allocator)
//      {
//          allocSlot = allocator;
//      }
//  };
//..
// Our verification program simply instantiate several &#39;MyGenericContainer&#39;
// templates with the two test types above, and checks that the allocator slot
// is as expected:
//..
//  int main()
//  {
//      bslma::TestAllocator ta0;
//      bslma::TestAllocator ta1;
//..
// With &#39;MyTestTypeWithNoBslmaAllocatorTraits&#39;, the slot should never be set.
//..
//  MyTestTypeWithNoBslmaAllocatorTraits x;
//
//  allocSlot = &amp;ta0;
//  MyGenericContainer&lt;MyTestTypeWithNoBslmaAllocatorTraits&gt; x0(x);
//  assert(&amp;ta0 == allocSlot);
//
//  allocSlot = &amp;ta0;
//  MyGenericContainer&lt;MyTestTypeWithNoBslmaAllocatorTraits&gt; x1(x, &amp;ta1);
//  assert(&amp;ta0 == allocSlot);
//..
// With &#39;MyTestTypeWithBslmaAllocatorTraits&#39;, the slot should be set to the
// allocator argument, or to 0 if not specified:
//..
//      MyTestTypeWithBslmaAllocatorTraits y;
//
//      allocSlot = &amp;ta0;
//      MyGenericContainer&lt;MyTestTypeWithBslmaAllocatorTraits&gt; y0(y);
//      assert(0 == allocSlot);
//
//      allocSlot = &amp;ta0;
//      MyGenericContainer&lt;MyTestTypeWithBslmaAllocatorTraits&gt; y1(y, &amp;ta1);
//      assert(&amp;ta1 == allocSlot);
//
//      return 0;
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLALG_HASTRAIT
#include &lt;bslalg_hastrait.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITBITWISECOPYABLE
#include &lt;bslalg_typetraitbitwisecopyable.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITBITWISEEQUALITYCOMPARABLE
#include &lt;bslalg_typetraitbitwiseequalitycomparable.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITBITWISEMOVEABLE
#include &lt;bslalg_typetraitbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITHASPOINTERSEMANTICS
#include &lt;bslalg_typetraithaspointersemantics.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITHASSTLITERATORS
#include &lt;bslalg_typetraithasstliterators.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITHASTRIVIALDEFAULTCONSTRUCTOR
#include &lt;bslalg_typetraithastrivialdefaultconstructor.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITNIL
#include &lt;bslalg_typetraitnil.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITPAIR
#include &lt;bslalg_typetraitpair.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITUSESBSLMAALLOCATOR
#include &lt;bslalg_typetraitusesbslmaallocator.h&gt;
#endif

// All headers below here are not really needed, but are kept here in case
// legacy code is depending on a transitive include.
#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_IF
#include &lt;bslmf_if.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISCONVERTIBLE
#include &lt;bslmf_isconvertible.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISENUM
#include &lt;bslmf_isenum.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISFUNDAMENTAL
#include &lt;bslmf_isfundamental.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISPOINTER
#include &lt;bslmf_ispointer.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISPOINTERTOMEMBER
#include &lt;bslmf_ispointertomember.h&gt;
#endif

#ifndef INCLUDED_BSLMF_METAINT
#include &lt;bslmf_metaint.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NIL
#include &lt;bslmf_nil.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVECVQ
#include &lt;bslmf_removecvq.h&gt;
#endif

namespace BloombergLP {

                    // ========================================
                    // macros BSLALG_DECLARE_NESTED_TRAITS[1-5]
                    // ========================================

#define BSLALG_DECLARE_NESTED_TRAITS(T, TRAIT)            \
    operator TRAIT::NestedTraitDeclaration&lt;T&gt;() const {   \
        return TRAIT::NestedTraitDeclaration&lt;T&gt;();        \
    }
    // Associate the specified &#39;TRAIT&#39; tag with the specified &#39;T&#39; class.  This
    // macro must be invoked only within the public part of the definition of
    // class &#39;T&#39;.  &#39;TRAIT&#39; must name a class such that
    // &#39;TRAIT::NestedTraitDeclaration&lt;T&gt;&#39; designates a class derived from
    // &#39;bslmf::DetectNestedTrait&#39;.

#define BSLALG_DECLARE_NESTED_TRAITS2(T, TRAIT1, TRAIT2)                      \
    BSLALG_DECLARE_NESTED_TRAITS(T, TRAIT1);                                  \
    BSLALG_DECLARE_NESTED_TRAITS(T, TRAIT2)
    // Like &#39;BSLALG_DECLARE_NESTED_TRAITS&#39;, but for two traits.

#define BSLALG_DECLARE_NESTED_TRAITS3(T, TRAIT1, TRAIT2, TRAIT3)              \
    BSLALG_DECLARE_NESTED_TRAITS(T, TRAIT1);                                  \
    BSLALG_DECLARE_NESTED_TRAITS(T, TRAIT2);                                  \
    BSLALG_DECLARE_NESTED_TRAITS(T, TRAIT3)
    // Like &#39;BSLALG_DECLARE_NESTED_TRAITS&#39;, but for three traits.

#define BSLALG_DECLARE_NESTED_TRAITS4(T, TRAIT1, TRAIT2, TRAIT3, TRAIT4)      \
    BSLALG_DECLARE_NESTED_TRAITS(T, TRAIT1);                                  \
    BSLALG_DECLARE_NESTED_TRAITS(T, TRAIT2);                                  \
    BSLALG_DECLARE_NESTED_TRAITS(T, TRAIT3);                                  \
    BSLALG_DECLARE_NESTED_TRAITS(T, TRAIT4)
    // Like &#39;BSLALG_DECLARE_NESTED_TRAITS&#39;, but for four traits.

#define BSLALG_DECLARE_NESTED_TRAITS5(T, TRAIT1,TRAIT2,TRAIT3,TRAIT4,TRAIT5)  \
    BSLALG_DECLARE_NESTED_TRAITS(T, TRAIT1);                                  \
    BSLALG_DECLARE_NESTED_TRAITS(T, TRAIT2);                                  \
    BSLALG_DECLARE_NESTED_TRAITS(T, TRAIT3);                                  \
    BSLALG_DECLARE_NESTED_TRAITS(T, TRAIT4);                                  \
    BSLALG_DECLARE_NESTED_TRAITS(T, TRAIT5)
    // Like &#39;BSLALG_DECLARE_NESTED_TRAITS&#39;, but for five traits.


}  // close enterprise namespace

#endif // INCLUDED_BSLALG_TYPETRAITS

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
