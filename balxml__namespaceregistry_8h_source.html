<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// balxml_namespaceregistry.h                                         -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALXML_NAMESPACEREGISTRY
#define INCLUDED_BALXML_NAMESPACEREGISTRY

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a unique integer ID for each XML namespace.
//
//@CLASSES:
//   balxml::NamespaceRegistry: namespace-to-id mapping registry
//
//@SEE_ALSO: baexml::PrefixTable
//
//@DESCRIPTION: This component provides an in-core value-semantic type,
// &#39;balxml::NamespaceRegistry&#39;, that associates an integer ID with each
// registered namespace URI.  In typical usage, client code would call the
// &#39;lookupOrRegister&#39; method each time it encounters a namespace URI.  The
// &#39;lookupOrRegister&#39; method will return the ID corresponding to the URI,
// assigning a new ID if none already exists.  The client can also retrieve
// the ID an already-registered namespace by providing the URI to the &#39;lookup&#39;
// method and can retrieve the URI of an already-registered namespace by
// providing the ID to the &#39;lookup&#39; method.
//
// Note that namespace IDs may be negative.  Client code should not assume an
// incremental assignment of IDs starting at zero.  (See Preregistered
// Namespaces), below.
//
///Preregistered Namespaces
///------------------------
// Even before any namespaces have been registered, a
// &#39;balxml::NamespaceRegistry&#39; can be used to lookup several preregistered
// namespaces.  The IDs for these preregistered namespaces are declared as
// constants within the &#39;balxml::NamespaceRegistry&#39; class.  These constants and
// their associated URI&#39;s are as follows:
//..
//  Namespace ID               URI String
//  ============               ==========
//  BAEXML_XML                   http://www.w3.org/XML/1998/namespace
//  BAEXML_XMLNS                 http://www.w3.org/2000/xmlns/
//  BAEXML_XMLSCHEMA             http://www.w3.org/2001/XMLSchema
//  BAEXML_XMLSCHEMA_INSTANCE    http://www.w3.org/2001/XMLSchema-instance
//  BAEXML_WSDL                  http://schemas.xmlsoap.org/wsdl/
//  BAEXML_WSDL_SOAP             http://schemas.xmlsoap.org/wsdl/soap/
//  BAEXML_BDEM                  http://bloomberg.com/schemas/bdem
//..
// Note that the above constants are negative numbers.  In addition, the
// value, -1, is permanently assigned to the empty string.  The use of
// predefined namespace IDs allows client code avoid lookups of the above,
// well-known URIs.
//
///Thread Safety
///-------------
// It is safe to read or modify multiple instances of
// &#39;balxml::NamespaceRegistry&#39; simultaneously, each from a separate thread.  It
// is safe to read a single instance of &#39;balxml::NamespaceRegistry&#39; from
// multiple threads, provided no thread is modifying it at the same time.  It
// is not safe to read or modify an instance of &#39;balxml::NamespaceRegistry&#39;
// from one thread while any other thread is modifying the same instance.
//
///Usage
///-----
// Typically, a program will register namespaces as it encounters them in an
// XML document.  Alternatively, namespaces that are important to the program
// are registered in advance, as in the following code:
//..
//  const char googleUri[] = &quot;http://www.google.com/schemas/results.xsd&quot;;
//  const char yahooUri[]  = &quot;http://www.yahoo.com/xsd/searchResults.xsd&quot;;
//
//  balxml::NamespaceRegistry namespaceRegistry;
//  int googleId = namespaceRegistry.lookupOrRegister(googleUri);
//  assert(googleId &gt;= 0);
//  int yahooId = namespaceRegistry.lookupOrRegister(yahooUri);
//  assert(yahooId &gt;= 0);
//  assert(yahooId != googleId);
//..
// Later, IDs can be looked up without concern for whether they have already
// been registered.  Any new namespaces are simply given a new ID:
//..
//  char input[100];
//
//  // First input is a new namespace URI.
//  bsl::strcpy(input, &quot;http://www.bloomberg.com/schemas/example.xsd&quot;);
//  int id1 = namespaceRegistry.lookupOrRegister(input);
//  assert(id1 &gt;= 0);
//  assert(id1 != googleId);
//  assert(id1 != yahooId);
//
//  // Next input happens to be the same as yahoo.
//  bsl::strcpy(input, &quot;http://www.yahoo.com/xsd/searchResults.xsd&quot;);
//  int id2 = namespaceRegistry.lookupOrRegister(input);
//  assert(id2 == yahooId);
//..
// If one of the preregistered namespaces is presented, it&#39;s predefined ID is
// returned, even though it was never explicitly registered:
//..
//  bsl::strcpy(input, &quot;http://www.w3.org/2001/XMLSchema&quot;);
//  int id3 = namespaceRegistry.lookupOrRegister(input);
//  assert(id3 == balxml::NamespaceRegistry::BAEXML_XMLSCHEMA);
//..
// Using the &#39;lookup&#39; method, a namespace ID can be looked up without
// registering it.  In this case, an unregistered namespace will result in an
// ID of -1:
//..
//  assert(googleId  == namespaceRegistry.lookup(googleUri));
//  assert(balxml::NamespaceRegistry::BAEXML_BDEM ==
//         namespaceRegistry.lookup(&quot;http://bloomberg.com/schemas/bdem&quot;));
//  assert(-1 == namespaceRegistry.lookup(&quot;urn:1234&quot;));
//..
// There is also a &#39;lookup&#39; method for performing the reverse mapping -- from
// ID to URI:
//..
//  const char *uri = namespaceRegistry.lookup(googleId);
//  assert(0 == bsl::strcmp(uri, googleUri));
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

namespace BloombergLP {

namespace balxml {
                          // =======================
                          // class NamespaceRegistry
                          // =======================

class NamespaceRegistry {
    // Mapping that associates a unique integer with each registered namespace
    // URI.

  private:
    // PRIVATE MEMBER VARIABLES
    bsl::vector&lt;bsl::string&gt; d_namespaces; // vector of namespaces, indexed by
                                           // the namespace ID.
    friend inline
    bool operator==(const NamespaceRegistry&amp; lhs,
                    const NamespaceRegistry&amp; rhs);
        // Must be a friend for engineering reasons.  Unlike most
        // value-semantic types, there is no efficient way to read the entire
        // value of a namespace registry object.

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(NamespaceRegistry,
                                                    bslma::UsesBslmaAllocator);

    // PUBLIC TYPES
    enum {
        // Preregistered namespace IDs.
        e_NO_NAMESPACE = -1,    // (empty URI string)

        e_PREDEF_MIN = 0x40000000,

        e_XML = e_PREDEF_MIN, // http://www.w3.org/XML/1998/namespace
        e_XMLNS,              // http://www.w3.org/2000/xmlns/
        e_XMLSCHEMA,          // http://www.w3.org/2001/XMLSchema
        e_XMLSCHEMA_INSTANCE, // http://www.w3.org/2001/XMLSchema-instance
        e_WSDL,               // http://schemas.xmlsoap.org/wsdl/
        e_WSDL_SOAP,          // http://schemas.xmlsoap.org/wsdl/soap/
        e_BDEM,               // http://bloomberg.com/schemas/bdem

        BAEXML_PREDEF_MAX
    };

    // CREATORS
    NamespaceRegistry(bslma::Allocator *basicAllocator = 0);
        // Construct an empty registry.  Optionally specify a &#39;basicAllocator&#39;
        // used to supply memory.  If &#39;basicAllocator&#39; is 0, the current
        // default allocator is used.

    NamespaceRegistry(const NamespaceRegistry&amp;  other,
                      bslma::Allocator         *basicAllocator=0);
        // Construct a copy of the specified &#39;other&#39; namespace registry using
        // the (optionally) specified &#39;basicAllocator&#39;.  For a given URI, the
        // results of calling &#39;lookup&#39; by URI will produce equal results for
        // this object and for &#39;other&#39;.  For a given integer ID, the result of
        // calling &#39;lookup&#39; by ID will produce different pointers that compare
        // equal using &#39;strcmp&#39;.

    ~NamespaceRegistry();
        // Destroy this object.  Release all memory to the allocator used at
        // construction.

    // MANIPULATORS
    NamespaceRegistry&amp; operator=(const NamespaceRegistry&amp; rhs);
        // Discard the contents of this registry and assign it the contents of
        // the specified &#39;rhs&#39; registry.  For a given URI, the results of
        // calling &#39;lookup&#39; by URI will produce equal results for this object
        // and for &#39;rhs&#39;.  For a given integer ID, the result of calling
        // &#39;lookup&#39; by ID will produce different pointers that compare equal
        // using &#39;strcmp&#39;.

    int lookupOrRegister(const bslstl::StringRef&amp; namespaceUri);
        // Return the integer ID for the specified &#39;namespaceUri&#39;, assigning a
        // new ID if the &#39;namespaceUri&#39; has not been registered before.  Note
        // that the IDs for pre-registered namespaces (including the empty
        // URI) are less than zero.  (See &quot;Preregistered Namespaces&quot; in the
        // &#39;balxml_namespaceregistry component-level documentation.)

    void reset();
        // Removes all registered namespaces.  Preregistered namespaces are
        // not removed.

    // ACCESSORS
    int lookup(const bslstl::StringRef&amp; namespaceUri) const;
        // Return the integer ID for the specified &#39;namespaceUri&#39; or -1 if the
        // namespace has not been registered.  Note that not all negative
        // return values correspond to unregistered namespaces.  Preregistered
        // namespaces always have negative IDs.  (See &quot;Preregistered
        // Namespaces&quot; in the &#39;balxml_namespaceregistry&#39; component-level
        // documentation.)  Note that a return value of -1 can mean either an
        // unregistered namespace or an empty URI string.  This dual-use of -1
        // is deliberate and simplifies error handling in most clients.

    const char *lookup(int id) const;
        // Return the null-terminated string containing the URI of the
        // namespace registered with the specified &#39;id&#39; or an empty (not null)
        // string if &#39;id&#39; does not correspond to a preregistered namespace or
        // a namespace that was previously registered with this object.

    void print(bsl::ostream&amp; stream) const;
        // Print the contents of this object to the specified &#39;stream&#39; in
        // human-readable form.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

// FREE OPERATORS
inline
bool operator==(const NamespaceRegistry&amp; lhs, const NamespaceRegistry&amp; rhs);
    // Return true if the specified &#39;lhs&#39; registry has the same value as the
    // specified &#39;rhs&#39; registry and false otherwise.  The two registries have
    // the same value if, for any possible URI string, &#39;u&#39;,
    // &#39;lhs.lookup(u) == rhs.lookup(u)&#39;.

inline
bool operator!=(const NamespaceRegistry&amp; lhs, const NamespaceRegistry&amp; rhs);
    // Return true if the specified &#39;lhs&#39; registry does not have the same
    // value as the specified &#39;rhs&#39; registry and false otherwise.  The two
    // registries do not have the same value if there exists a URI string,
    // &#39;u&#39;, such that &#39;lhs.lookup(u)&#39; != &#39;rhs.lookup(u)&#39;.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; os, const NamespaceRegistry&amp; r);
    // Print the contents of the specified &#39;r&#39; registry to the specified &#39;os&#39;
    // stream in human-readable form and return a modifiable reference to
    // &#39;os&#39;.

// CREATORS
inline
NamespaceRegistry::NamespaceRegistry(bslma::Allocator *basicAllocator)
: d_namespaces(basicAllocator)
{
}

inline
NamespaceRegistry::NamespaceRegistry(const NamespaceRegistry&amp;  other,
                                     bslma::Allocator         *basicAllocator)
: d_namespaces(other.d_namespaces, basicAllocator)
{
}

inline
NamespaceRegistry::~NamespaceRegistry()
{
}

// MANIPULATORS
inline
NamespaceRegistry&amp;
NamespaceRegistry::operator=(const NamespaceRegistry&amp; rhs)
{
    d_namespaces = rhs.d_namespaces;
    return *this;
}

inline
void NamespaceRegistry::reset()
{
    d_namespaces.clear();
}
}  // close package namespace

// FREE OPERATORS
inline
bool balxml::operator==(const NamespaceRegistry&amp; lhs,
                        const NamespaceRegistry&amp; rhs)
{
    return lhs.d_namespaces == rhs.d_namespaces;
}

inline
bool balxml::operator!=(const NamespaceRegistry&amp; lhs,
                        const NamespaceRegistry&amp; rhs)
{
    return ! (lhs == rhs);
}

inline
bsl::ostream&amp; balxml::operator&lt;&lt;(bsl::ostream&amp; os, const NamespaceRegistry&amp; r)
{
    r.print(os);
    return os;
}

}  // close enterprise namespace

#endif // ! defined(INCLUDED_BAEXML_NAMESPACEREGISTRY)

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
