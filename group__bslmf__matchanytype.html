<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslmf_matchanytype Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslmf_matchanytype<br/>
<small>
[<a class="el" href="group__bslmf.html">Package bslmf</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a generic type to which any type can be converted.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslmf.html">bslmf</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage Example 1: <code>bslmf::MatchAnyType</code></a> </li>
<li>
<a href="#3.2">Usage Example 2: <code>bslmf::TypeRep</code></a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a generic type to which any type can be converted. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbslmf_1_1MatchAnyType.html">bslmf::MatchAnyType</a> </td><td>generic type to which any type can be converted  </td></tr>
<tr>
<td><a class="el" href="structbslmf_1_1TypeRep.html">bslmf::TypeRep</a> </td><td>meta-function for providing a reference to <code>TYPE</code>  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="structbslmf_1_1MatchAnyType.html">bslmf::MatchAnyType</a></code> is a type to which any type can be implicitly converted. This is useful for creating an overloaded function that is a catch-all for all types not explicitly provided for in other overloaded functions with the same name. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="structbslmf_1_1TypeRep.html">bslmf::TypeRep</a></code> allows one to create a reference to a type. In complex template programming, one is often dealing with unknown types, about the constructors of which one knows nothing. One often needs an object of the given type, but since nothing is known about the constructors, one can't just construct and object of the type. <code><a class="el" href="structbslmf_1_1TypeRep.html">bslmf::TypeRep</a></code> allows one to create a reference to the type. Note that the <code>rep</code> function in <code>bslma::TypeRep</code> is not implemented, it must never be called at run time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage_example_1"></a> <a class="anchor" id="description.usage_example_1"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage Example 1: bslmf::MatchAnyType: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>X { };
  <span class="keyword">struct </span>Y { };
  <span class="keyword">struct </span>Z : <span class="keyword">public</span> Y { };

  <span class="keyword">inline</span> <span class="keywordtype">bool</span> isY(<span class="keyword">const</span> <a class="code" href="structbslmf_1_1MatchAnyType.html">bslmf::MatchAnyType</a>&amp;) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }
  <span class="keyword">inline</span> <span class="keywordtype">bool</span> isY(<span class="keyword">const</span> Y&amp;)              { <span class="keywordflow">return</span> <span class="keyword">true</span>;  }

  assert(! isY(X()));
  assert(  isY(Y()));
  assert(  isY(Z()));
  assert(! isY(<span class="keywordtype">int</span>()));
  assert(! isY(4));
  assert(! isY(4.0));
  assert(! isY(<span class="stringliteral">&quot;The king is a fink!&quot;</span>));

  X x;
  Y y;
  Z z;
  assert(! isY(x));
  assert(  isY(y));
  assert(  isY(z));
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage_example_2"></a> <a class="anchor" id="description.usage_example_2"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage Example 2: bslmf::TypeRep: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>X {};
  <span class="keyword">struct </span>Y {};

  <span class="keyword">struct </span>HasHorridCtorX : <span class="keyword">public</span> X {
      HasHorridCtorX(<span class="keywordtype">int</span>, <span class="keywordtype">double</span>, X, <span class="keywordtype">char</span>, <span class="keywordtype">char</span> *, <span class="keywordtype">void</span> *) {}
          <span class="comment">// It&#39;s inconvenient to actually create an object of this type</span>
          <span class="comment">// because the constructor takes so many arguments.  It&#39;s also</span>
          <span class="comment">// impossible because the c&#39;tor is undefined.</span>
  };
  <span class="keyword">struct </span>HasHorridCtorY : <span class="keyword">public</span> Y {
      HasHorridCtorY(<span class="keywordtype">int</span>, <span class="keywordtype">double</span>, X, <span class="keywordtype">char</span>, <span class="keywordtype">char</span> *, <span class="keywordtype">void</span> *) {}
          <span class="comment">// It&#39;s inconvenient to actually create an object of this type</span>
          <span class="comment">// because the constructor takes so many arguments.  It&#39;s also</span>
          <span class="comment">// impossible because the c&#39;tor is undefined.</span>
  };

  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> i&gt;
  <span class="keyword">struct </span>MetaInt { <span class="keywordtype">char</span> d_array[i + 1]; };

<span class="preprocessor">  #define METAINT_TO_UINT(metaint)   (sizeof(metaint) - 1)</span>
<span class="preprocessor"></span>
  MetaInt&lt;1&gt; isX(<span class="keyword">const</span> X&amp;);
  MetaInt&lt;0&gt; isX(<span class="keyword">const</span> <a class="code" href="structbslmf_1_1MatchAnyType.html">bslmf::MatchAnyType</a>&amp;);

  assert(1 == METAINT_TO_UINT(isX(X())));
  assert(0 == METAINT_TO_UINT(isX(Y())));
  assert(1 == METAINT_TO_UINT(isX(<a class="code" href="structbslmf_1_1TypeRep.html">bslmf::TypeRep&lt;HasHorridCtorX&gt;::rep</a>())));
  assert(0 == METAINT_TO_UINT(isX(<a class="code" href="structbslmf_1_1TypeRep.html">bslmf::TypeRep&lt;HasHorridCtorY&gt;::rep</a>())));
  assert(0 == METAINT_TO_UINT(isX(3)));
  assert(0 == METAINT_TO_UINT(isX(3.0)));
  assert(0 == METAINT_TO_UINT(isX(<span class="stringliteral">&quot;The king is a fink!&quot;</span>)));
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:42 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
