<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlde_base64encoder.h                                              -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLDE_BASE64ENCODER
#define INCLUDED_BDLDE_BASE64ENCODER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide automata for converting to and from Base64 encodings.
//
//@CLASSES:
//   bdlde::Base64Encoder: automata performing Base64 encoding operations
//
//@SEE_ALSO: bdlde_base64decoder
//
//@DESCRIPTION: This component provides a &#39;class&#39;, &#39;bdlde::Base64Encoder&#39;,
// which provides a pair of template functions (each parameterized separately
// on both input and output iterators) that can be used respectively to encode
// and to decode byte sequences of arbitrary length into and from the printable
// Base64 representation described in Section 6.8 &quot;Base64 Content Transfer
// Encoding&quot; of RFC 2045, &quot;Multipurpose Internet Mail Extensions (MIME) Part
// One: Format of Internet Message Bodies.&quot;
//
// Each instance of either the encoder or decoder retains the state of the
// conversion from one supplied input to the next, enabling the processing of
// segmented input -- i.e., processing resumes where it left off with the next
// invocation on new input.  Instance methods are provided for both the encoder
// and decoder to (1) assert the end of input, (2) determine whether the input
// so far is currently acceptable, and (3) indicate whether a non-recoverable
// error has occurred.
//
///Base 64 Encoding
///----------------
// The data stream is processed three bytes at a time from left to right (a
// final quantum consisting of one or two bytes, as discussed below, is handled
// specially).  Each sequence of three 8-bit quantities
//..
//      7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |               |               |               |
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//      `------v------&#39; `------v------&#39; `------v------&#39;
//           Byte2           Byte1           Byte0
//..
// is segmented into four intermediate 6-bit quantities.
//..
//      5 4 3 2 1 0 5 4 3 2 1 0 5 4 3 2 1 0 5 4 3 2 1 0
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |           |           |           |           |
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//      `----v----&#39; `----v----&#39; `----v----&#39; `----v----&#39;
//         char3       char2       char1        char0
//..
// Each 6-bit quantity is in turn used as an index into the following character
// table to generate an 8-bit character.  The four resulting characters hence
// form the encoding for the original 3-byte sequence.
//..
//     ======================================================================
//     *              Table of Numeric BASE-64 Encoding Characters          *
//     ----------------------------------------------------------------------
//     Val Enc  Val Enc  Val Enc  Val Enc  Val Enc  Val Enc  Val Enc  Val Enc
//     --- ---  --- ---  --- ---  --- ---  --- ---  --- ---  --- ---  --- ---
//       0 &#39;A&#39;    8 &#39;I&#39;   16 &#39;Q&#39;   24 &#39;Y&#39;   32 &#39;g&#39;   40 &#39;o&#39;   48 &#39;w&#39;   56 &#39;4&#39;
//       1 &#39;B&#39;    9 &#39;J&#39;   17 &#39;R&#39;   25 &#39;Z&#39;   33 &#39;h&#39;   41 &#39;p&#39;   49 &#39;x&#39;   57 &#39;5&#39;
//       2 &#39;C&#39;   10 &#39;K&#39;   18 &#39;S&#39;   26 &#39;a&#39;   34 &#39;i&#39;   42 &#39;q&#39;   50 &#39;y&#39;   58 &#39;6&#39;
//       3 &#39;D&#39;   11 &#39;L&#39;   19 &#39;T&#39;   27 &#39;b&#39;   35 &#39;j&#39;   43 &#39;r&#39;   51 &#39;z&#39;   59 &#39;7&#39;
//       4 &#39;E&#39;   12 &#39;M&#39;   20 &#39;U&#39;   28 &#39;c&#39;   36 &#39;k&#39;   44 &#39;s&#39;   52 &#39;0&#39;   60 &#39;8&#39;
//       5 &#39;F&#39;   13 &#39;N&#39;   21 &#39;V&#39;   29 &#39;d&#39;   37 &#39;l&#39;   45 &#39;t&#39;   53 &#39;1&#39;   61 &#39;9&#39;
//       6 &#39;G&#39;   14 &#39;O&#39;   21 &#39;W&#39;   30 &#39;e&#39;   38 &#39;m&#39;   46 &#39;u&#39;   54 &#39;2&#39;   62 &#39;+&#39;
//       7 &#39;H&#39;   15 &#39;P&#39;   22 &#39;X&#39;   31 &#39;f&#39;   39 &#39;n&#39;   47 &#39;v&#39;   55 &#39;3&#39;   63 &#39;/&#39;
//     ======================================================================
//..
// The 3-byte grouping of the input is only a design of convenience and not a
// requirement.  When the number of bytes in the input stream is not divisible
// by 3, sufficient 0 bits are padded on the right to achieve an integral
// number of 6-bit character indices.  Then one of two special cases will apply
// for the final processing step:
//
// I) There is a single byte of data, in which case there will be two Base64
// encoding characters (the second of which will be one of [AQgw]) followed by
// two equal (&#39;=&#39;) signs.
//
// II) There are exactly two bytes of data, in which case there will be three
// Base64 encoding characters (the third of which will be one of
// [AEIMQUYcgkosw048] followed by a single equal (&#39;=&#39;) sign.
//
// The MIME standard requires that the maximum line length of emitted text not
// exceed 76 characters exclusive of CRLF.  The caller may override this
// default if desired.
//
// Input values of increasing length along with their corresponding Base64
// encodings are illustrated below:
//..
//        Data: /* nothing */
//    Encoding: /* nothing */
//
//        Data: 0x01
//    Encoding: AQ==
//
//        Data: 0x01 0x02
//    Encoding: AQI=
//
//        Data: 0x01 0x02 0x03
//    Encoding: AQID
//
//        Data: 0x01 0x02 0x03 0x04
//    Encoding: AQIDBA==
//..
// In order for a Base64 encoding to be valid, the input data must be either of
// length a multiple of three (constituting maximal input), or have been
// terminated explicitly by the &#39;endConvert&#39; method (initiating bit padding
// when necessary).
//
///Base 64 Decoding
///----------------
// The degree to which decoding detects errors can significantly affect
// performance.  The standard permits all non-Base64 characters to be treated
// as whitespace.  One variant mode of this decoder does just that; the other
// reports an error if a bad (i.e., non-whitespace) character is detected.  The
// mode of the instance is configurable.  The standard imposes a maximum of 76
// characters exclusive of CRLF; however, the decoder implemented in this
// component will handle lines of arbitrary length.
//
// The following kinds of errors can occur during decoding and are reported
// with the following priority:
//..
// BAD DATA: A character (other than whitespace) that is not a member of the
//           Base64 character set (including &#39;=&#39;).  Note that this error
//           is detected only if the &#39;decoder&#39; is explicitly configured (at
//           construction) to do so.
//
// BAD FORMAT: An &#39;=&#39; character precedes a valid numeric Base64 character,
//             more than two &#39;=&#39; characters appear (possibly separated by
//             non-Base64 characters), a numeric Base64 character other than
//             [AEIMQUYcgkosw048] precedes a single terminal &#39;=&#39; character,
//             or a character other than [AQgw] precedes a terminal pair of
//             consecutive &#39;=&#39; characters.
//..
// The &#39;isError&#39; method is used to detect such anomalies, and the &#39;numIn&#39;
// output parameter (indicating the number of input characters consumed) or
// possibly the iterator itself (for iterators with reference-semantics)
// identifies the offending character.
//
// Note that the existence of an &#39;=&#39; can be used to reliably indicate the end
// of the valid data, but no such assurance is possible when the length (in
// bytes) of the initial input data sequence before encoding was evenly
// divisible by 3.
//
///Usage
///-----
// The following example shows how to use a &#39;bdlde::Base64Encoder&#39; object to
// implement a function, &#39;streamEncoder&#39;, that reads text from a
// &#39;bsl::istream&#39;, encodes that text in base 64 representation, and writes the
// encoded text to a &#39;bsl::ostream&#39;.  &#39;streamEncoder&#39; returns 0 on success
// and a negative value if the input data could not be successfully encoded or
// if there is an I/O error.
//..
// streamencoder.h                    -*-C++-*-
//
// int streamEncoder(bsl::ostream&amp; os, bsl::istream&amp; is);
//     // Read the entire contents of the specified input stream &#39;is&#39;, convert
//     // the input plain text to base 64 encoding, and write the encoded text
//     // to the specified output stream &#39;os&#39;.  Return 0 on success, and a
//     // negative value otherwise.
//..
// We will use fixed-sized input and output buffers in the implementation, but,
// because of the flexibility of &#39;bsl::istream&#39; and the output-buffer
// monitoring functionality of &#39;bdlde::Base64Encoder&#39;, the fixed buffer sizes
// do *not* limit the quantity of data that can be read, encoded, or written to
// the output stream.  The implementation file is as follows.
//..
// streamencoder.cpp                  -*-C++-*-
//
// #include &lt;streamencoder.h&gt;
//
// #include &lt;bdlde_base64encoder.h&gt;
//
// namespace BloombergLP {
//
// int streamEncoder(bsl::ostream&amp; os, bsl::istream&amp; is)
// {
//     enum {
//         SUCCESS      =  0,
//         ENCODE_ERROR = -1,
//         IO_ERROR     = -2
//     };
//..
// We declare a &#39;bdlde::Base64Encoder&#39; object &#39;converter&#39;, which will encode
// the input data.  Note that various internal buffers and cursors are used as
// needed without further comment.  We read as much data as is available from
// the user-supplied input stream &#39;is&#39; *or* as much as will fit in
// &#39;inputBuffer&#39; before beginning conversion.
//..
//     bdlde::Base64Encoder converter;
//
//     const int INBUFFER_SIZE  = 1 &lt;&lt; 10;
//     const int OUTBUFFER_SIZE = 1 &lt;&lt; 10;
//
//     char inputBuffer[INBUFFER_SIZE];
//     char outputBuffer[OUTBUFFER_SIZE];
//
//     char *output    = outputBuffer;
//     char *outputEnd = outputBuffer + sizeof outputBuffer;
//
//     while (is.good()) {  // input stream not exhausted
//
//         is.read(inputBuffer, sizeof inputBuffer);
//..
// With &#39;inputBuffer&#39; now populated, we&#39;ll use &#39;converter&#39; in an inner &#39;while&#39;
// loop to encode the input and write the encoded data to &#39;outputBuffer&#39; (via
// the &#39;output&#39; cursor&#39;).  Note that if the call to &#39;converter.convert&#39; fails,
// our function terminates with a negative status.
//..
//         const char *input    = inputBuffer;
//         const char *inputEnd = input + is.gcount();
//
//         while (input &lt; inputEnd) { // input encoding not complete
//
//             int numOut;
//             int numIn;
//
//             int status = converter.convert(output, &amp;numOut, &amp;numIn,
//                                            input,   inputEnd,
//                                            outputEnd - output);
//             if (status &lt; 0) {
//                 return ENCODE_ERROR;                               // RETURN
//             }
//..
// If the call to &#39;converter.convert&#39; returns successfully, we&#39;ll see if the
// output buffer is full, and if so, write its contents to the user-supplied
// output stream &#39;os&#39;.  Note how we use the values of &#39;numOut&#39; and &#39;numIn&#39;
// generated by &#39;convert&#39; to update the relevant cursors.
//..
//             output += numOut;
//             input  += numIn;
//
//             if (output == outputEnd) {  // output buffer full; write data
//                 os.write (outputBuffer, sizeof outputBuffer);
//                 if (os.fail()) {
//                     return IO_ERROR;                               // RETURN
//                 }
//                 output = outputBuffer;
//             }
//         }
//     }
//..
// We have now exited both the input and the &quot;encode&quot; loops.  &#39;converter&#39; may
// still hold encoded output characters, and so we call &#39;converter.endConvert&#39;
// to emit any retained output.  To guarantee correct behavior, we call this
// method in an infinite loop, because it is possible that the retained output
// can fill the output buffer.  In that case, we solve the problem by writing
// the contents of the output buffer to &#39;os&#39; within the loop.  The most likely
// case, however, is that &#39;endConvert&#39; will return 0, in which case we exit the
// loop and write any data remaining in &#39;outputBuffer&#39; to &#39;os&#39;.  As above, if
// &#39;endConvert&#39; fails, we exit the function with a negative return status.
//..
//     while (1) {
//
//         int numOut;
//
//         int more = converter.endConvert(output, &amp;numOut, outputEnd-output);
//         if (more &lt; 0) {
//             return ENCODE_ERROR;                                   // RETURN
//         }
//
//         output += numOut;
//
//         if (!more) { // no more output
//             break;
//         }
//
//         assert (output == outputEnd);  // output buffer is full
//
//         os.write (outputBuffer, sizeof outputBuffer);  // write buffer
//         if (os.fail()) {
//             return IO_ERROR;                                       // RETURN
//         }
//         output = outputBuffer;
//     }
//
//     if (output &gt; outputBuffer) { // still data in output buffer; write it
//                                  // all
//         os.write(outputBuffer, output - outputBuffer);
//     }
//
//     return (is.eof() &amp;&amp; os.good()) ? SUCCESS : IO_ERROR;
// }
//
// } // Close namespace BloombergLP
//..
// For ease of reading, we repeat the full content of the &#39;streamencoder.cpp&#39;
// file without interruption.
//..
// streamencoder.cpp                  -*-C++-*-
//
// #include &lt;streamencoder.h&gt;
//
// #include &lt;bdlde_base64encoder.h&gt;
//
// namespace BloombergLP {
//
// int streamEncoder(bsl::ostream&amp; os, bsl::istream&amp; is)
// {
//     enum {
//         SUCCESS      =  0,
//         ENCODE_ERROR = -1,
//         IO_ERROR     = -2
//     };
//
//     bdlde::Base64Encoder converter;
//
//     const int INBUFFER_SIZE  = 1 &lt;&lt; 10;
//     const int OUTBUFFER_SIZE = 1 &lt;&lt; 10;
//
//     char inputBuffer[INBUFFER_SIZE];
//     char outputBuffer[OUTBUFFER_SIZE];
//
//     char *output    = outputBuffer;
//     char *outputEnd = outputBuffer + sizeof outputBuffer;
//
//     while (is.good()) {  // input stream not exhausted
//
//         is.read(inputBuffer, sizeof inputBuffer);
//
//         const char *input    = inputBuffer;
//         const char *inputEnd = input + is.gcount();
//
//         while (input &lt; inputEnd) { // input encoding not complete
//
//             int numOut;
//             int numIn;
//
//             int status = converter.convert(output, &amp;numOut, &amp;numIn,
//                                            input,   inputEnd,
//                                            outputEnd - output);
//             if (status &lt; 0) {
//                 return ENCODE_ERROR;                               // RETURN
//             }
//
//             output += numOut;
//             input  += numIn;
//
//             if (output == outputEnd) {  // output buffer full; write data
//                 os.write(outputBuffer, sizeof outputBuffer);
//                 if (os.fail()) {
//                     return IO_ERROR;                               // RETURN
//                 }
//                 output = outputBuffer;
//             }
//         }
//     }
//
//     while (1) {
//
//         int numOut;
//
//         int more = converter.endConvert(output, &amp;numOut, outputEnd-output);
//         if (more &lt; 0) {
//             return ENCODE_ERROR;                                   // RETURN
//         }
//
//         output += numOut;
//
//         if (!more) { // no more output
//             break;
//         }
//
//         assert (output == outputEnd);  // output buffer is full
//
//         os.write (outputBuffer, sizeof outputBuffer);  // write buffer
//         if (os.fail()) {
//             return IO_ERROR;                                       // RETURN
//         }
//         output = outputBuffer;
//     }
//
//     if (output &gt; outputBuffer) {
//         os.write (outputBuffer, output - outputBuffer);
//     }
//
//     return (is.eof() &amp;&amp; os.good()) ? SUCCESS : IO_ERROR;
// }
//
// }  // close namespace BloombergLP
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

namespace BloombergLP {

namespace bdlde {
                            // ===================
                            // class Base64Encoder
                            // ===================

class Base64Encoder {
    // This class implements a mechanism capable of converting data of
    // arbitrary length to its corresponding Base64 representation.

    // PRIVATE TYPES
    enum {
        // Symbolic state values.

        e_ERROR_STATE     = -1, // Input is irreparably invalid.
        e_INITIAL_STATE   =  0, // Ready to accept input.
        e_DONE_STATE      =  1  // Any additional input is an error.
    };

    // CLASS DATA
    static const char *const s_encodedChars_p;        // 6-bit map of Base64
                                                      // encodings
    static const int         s_defaultMaxLineLength;  // Default maximum line
                                                      // length

    // INSTANCE DATA
    signed char d_state;  // state as per above enum

    int d_maxLineLength;  // maximum length of output line
    int d_lineLength;     // current length of output line
    int d_outputLength;   // total number of output characters
    int d_stack;          // storage of non-emitted input
    int d_bitsInStack;    // number of bits in &#39;d_stack&#39;

  private:
    // NOT IMPLEMENTED
    Base64Encoder(const Base64Encoder&amp;);
    Base64Encoder&amp; operator=(const Base64Encoder&amp;);

    // PRIVATE MANIPULATORS
    template &lt;class OUTPUT_ITERATOR&gt;
    void append(OUTPUT_ITERATOR *out, char character, int maxLength);
        // Append a soft new line to the specified &#39;out&#39; if necessary and then
        // append the specified &#39;character&#39; without the total number of emitted
        // characters equaling the specified &#39;maxLength&#39;.  The behavior is
        // undefined unless the total number of emitted characters does not
        // equal &#39;maxLength&#39; at entry to this method.

    template &lt;class OUTPUT_ITERATOR&gt;
    void encode(OUTPUT_ITERATOR *out, int maxLength);
        // Append a soft new line to the specified &#39;out&#39; if necessary and then
        // emit an internally buffered character without the total number of
        // emitted characters equaling the specified &#39;maxLength&#39;.  The
        // behavior is undefined unless the total number of emitted characters
        // does not equal &#39;maxLength&#39; at entry to this method and the internal
        // buffer contains at least one character of output.

  public:
    // CLASS METHODS
    static int encodedLength(int inputLength);
        // Return the exact number of encoded bytes that would result from an
        // input byte sequence of the specified &#39;inputLength&#39; provided to the
        // &#39;convert&#39; method of an encoder with the maximum allowable
        // line-length of the output being 76 characters (as recommended by the
        // MIME standard).  The behavior is undefined unless
        // &#39;0 &lt;= inputLength&#39;.

    static int encodedLength(int inputLength, int maxLineLength);
        // Return the exact number of encoded bytes that would result from an
        // input byte sequence of the specified &#39;inputLength&#39; provided to the
        // &#39;convert&#39; method of an encoder configured with the specified
        // &#39;maxLineLength&#39;.  The behavior is undefined unless
        // &#39;0 &lt;= inputLength&#39; and &#39;0 &lt;= maxLineLength&#39;.  Note that if
        // &#39;maxLineLength&#39; is 0, no CRLF characters will appear in the output.
        // Note also that the number of encoded bytes need not be the number of
        // *output* bytes.

    static int encodedLines(int inputLength);
        // Return the exact number of encoded lines that would result from an
        // input byte sequence of the specified &#39;inputLength&#39; provided to the
        // &#39;convert&#39; method of an encoder with the maximum allowable
        // line-length of the output being 76 characters (as recommended by the
        // MIME standard).  The behavior is undefined unless
        // &#39;0 &lt;= inputLength&#39;.  Note also that the number of encoded bytes need
        // not be the number of *output* bytes.

    static int encodedLines(int inputLength, int maxLineLength);
        // Return the exact number of encoded lines that would result from an
        // input byte sequence of the specified &#39;inputLength&#39; provided to the
        // &#39;convert&#39; method of an encoder configured with the specified
        // &#39;maxLineLength&#39;.  The behavior is undefined unless
        // &#39;0 &lt;= inputLength&#39; and &#39;0 &lt;= maxLineLength&#39;.  Note that if
        // &#39;maxLineLength&#39; is 0, no CRLF characters will appear in the output.
        // Note also that the number of encoded bytes need not be the number of
        // *output* bytes.

    static bool isResidualOutput(int numBytes, int maxLineLength);
        // Return &#39;true&#39; if an output sequence of the specified &#39;numBytes&#39;
        // from an encoder having the specified &#39;maxLineLength&#39; would be an
        // acceptable input to a &#39;Base64Decoder&#39;, and &#39;false&#39; otherwise.

    // CREATORS
    Base64Encoder();
        // Create a Base64 encoder in the initial state, defaulting the maximum
        // allowable line-length of the output to 76 (as recommended by the
        // MIME standard).  Note that the &#39;convert&#39; and &#39;endConvert&#39; methods of
        // this encoder will insert a CRLF to prevent each line of the output
        // from exceeding 76 characters.

    explicit
    Base64Encoder(int maxLineLength);
        // Create a Base64 encoder in the initial state, setting the maximum
        // allowable line-length of the output to the specified
        // &#39;maxLineLength&#39;.  Specifying 0 for &#39;maxLineLength&#39; will result in a
        // single output line (i.e., one with no CRLF in it).  The behavior is
        // undefined unless &#39;0 &lt;= maxLineLength&#39;.  Note that when
        // &#39;maxLineLength&#39; is positive, the &#39;convert&#39; and &#39;endConvert&#39; methods
        // of this encoder will insert a CRLF to prevent each line of the
        // output from exceeding &#39;maxLineLength&#39;.

    ~Base64Encoder();
        // Destroy this object.

    // MANIPULATORS
    template &lt;class OUTPUT_ITERATOR, class INPUT_ITERATOR&gt;
    int convert(OUTPUT_ITERATOR out,
                INPUT_ITERATOR  begin,
                INPUT_ITERATOR  end);
    template &lt;class OUTPUT_ITERATOR, class INPUT_ITERATOR&gt;
    int convert(OUTPUT_ITERATOR  out,
                int             *numOut,
                int             *numIn,
                INPUT_ITERATOR   begin,
                INPUT_ITERATOR   end,
                int              maxNumOut = -1);
        // Encode the sequence of input characters starting at the specified
        // &#39;begin&#39; position up to, but not including, the specified &#39;end&#39;
        // position, writing any resulting output characters to the specified
        // &#39;out&#39; buffer.  Optionally specify the &#39;maxNumOut&#39; limit on the
        // number of bytes to output; if &#39;maxNumOut&#39; is negative, no limit is
        // imposed.  If the &#39;maxNumOut&#39; limit is reached, no further input will
        // be consumed.  Load into the (optionally) specified &#39;numOut&#39; and
        // &#39;numIn&#39; the number of output bytes produced and input bytes
        // consumed, respectively.  Return a non-negative value on success and
        // a negative value otherwise.  A positive return status indicates the
        // number of valid processed output bytes retained by this encoder and
        // not written to &#39;out&#39; because &#39;maxNumOut&#39; has been reached; these
        // bytes are available for output if this method is called with
        // appropriate input.  Note that calling this method after &#39;endConvert&#39;
        // has been invoked without an intervening &#39;resetState&#39; call will place
        // this instance in an error state, and return an error status.  Note
        // also that it is recommended that after all calls to &#39;convert&#39; are
        // finished, the &#39;endConvert&#39; method be called to complete the encoding
        // of any unprocessed input characters that do not complete a 3-byte
        // sequence.

    template &lt;class OUTPUT_ITERATOR&gt;
    int endConvert(OUTPUT_ITERATOR out);
    template &lt;class OUTPUT_ITERATOR&gt;
    int endConvert(OUTPUT_ITERATOR out, int *numOut, int maxNumOut = -1);
        // Terminate encoding for this encoder; write any retained output
        // (e.g., from a previous call to &#39;convert&#39;) to the specified &#39;out&#39;
        // buffer.  Optionally specify the &#39;maxNumOut&#39; limit on the number of
        // bytes to output; if &#39;maxNumOut&#39; is negative, no limit is imposed.
        // Load into the (optionally) specified &#39;numOut&#39; the number of output
        // bytes produced.  Return 0 on success, the positive number of bytes
        // *still* retained by this encoder if the &#39;maxNumOut&#39; limit was
        // reached, and a negative value otherwise.  Any retained bytes are
        // available on a subsequent call to &#39;endConvert&#39;.  Once this method is
        // called, no additional input may be supplied without an intervening
        // call to &#39;resetState&#39;; once this method returns a zero status, a
        // subsequent call will place this encoder in the error state, and
        // return an error status.

    void resetState();
        // Reset this instance to its initial state (i.e., as if no input had
        // been consumed).

    // ACCESSORS
    bool isAcceptable() const;
        // Return &#39;true&#39; if the input read so far is considered syntactically
        // complete and all resulting output has been emitted to &#39;out&#39;, and
        // &#39;false&#39; otherwise.  Note that &#39;endConvert&#39; must be called if the
        // total length of all data processed is not divisible by 3.

    bool isDone() const;
        // Return &#39;true&#39; if the current input is acceptable and any additional
        // input (including &#39;endConvert&#39;) would be an error, and &#39;false&#39;
        // otherwise.  Note that if this decoder &#39;isDone&#39; then all resulting
        // output has been emitted to &#39;out&#39;.

    bool isError() const;
        // Return &#39;true&#39; if the there is no possibility of achieving an
        // &quot;acceptable&quot; result, and &#39;false&#39; otherwise.

    bool isInitialState() const;
        // Return &#39;true&#39; if this instance is in the initial state (i.e., as if
        // no input had been consumed), and &#39;false&#39; otherwise.

    bool isMaximal() const;
        // Return &#39;true&#39; if the current input is acceptable and any additional
        // input (other than &#39;endConvert&#39;) would be an error, and &#39;false&#39;
        // otherwise.

    int maxLineLength() const;
        // Return the currently installed value for the maximum line length.

    int outputLength() const;
        // Return the total length of the output emitted thus far (including
        // soft line breaks where appropriate).
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                            // -------------------
                            // class Base64Encoder
                            // -------------------

// PRIVATE MANIPULATORS
template &lt;class OUTPUT_ITERATOR&gt;
void Base64Encoder::append(OUTPUT_ITERATOR *out,
                           char             value,
                           int              maxLength)
{
    BSLS_ASSERT(out);

    if (d_maxLineLength &amp;&amp; d_lineLength &gt;= d_maxLineLength) {
        if (d_lineLength == d_maxLineLength) {
            **out = &#39;\r&#39;;
            ++*out;
            ++d_outputLength;
            ++d_lineLength;
            if (d_outputLength == maxLength) {
                return;                                               // RETURN
            }
        }
        **out = &#39;\n&#39;;
        ++*out;
        ++d_outputLength;
        d_lineLength = 0;
        if (d_outputLength == maxLength) {
            return;                                                   // RETURN
        }
    }
    **out = value;
    ++*out;
    ++d_outputLength;
    ++d_lineLength;
}

template &lt;class OUTPUT_ITERATOR&gt;
void Base64Encoder::encode(OUTPUT_ITERATOR *out, int maxLength)
{
    BSLS_ASSERT(out);

    if (d_maxLineLength &amp;&amp; d_lineLength &gt;= d_maxLineLength) {
        if (d_lineLength == d_maxLineLength) {
            **out = &#39;\r&#39;;
            ++*out;
            ++d_outputLength;
            ++d_lineLength;
            if (d_outputLength == maxLength) {
                return;                                               // RETURN
            }
        }
        **out = &#39;\n&#39;;
        ++*out;
        ++d_outputLength;
        d_lineLength = 0;
        if (d_outputLength == maxLength) {
            return;                                                   // RETURN
        }
    }
    d_bitsInStack -= 6;
    **out = s_encodedChars_p[(d_stack &gt;&gt; d_bitsInStack) &amp; 0x3f];
    ++*out;
    ++d_outputLength;
    ++d_lineLength;
}

// CLASS METHODS
inline
int Base64Encoder::encodedLength(int inputLength, int maxLineLength)
{
    BSLS_ASSERT_SAFE(0 &lt;= inputLength);
    BSLS_ASSERT_SAFE(0 &lt;= maxLineLength);

    int lineLength = (inputLength + 2) / 3 * 4;

    // Note that when lineLength &gt; maxLineLength, the added cost is given by
    // n = (lineLength - maxLineLength)
    //..
    // addedCost = 2 * ((n + maxLineLength - 1) / maxLineLength)
    //           = 2 * (    lineLength - 1    ) / maxLineLength)
    //..

    return 0 == maxLineLength || lineLength &lt;= maxLineLength
           ? lineLength
           : lineLength + 2 * ((lineLength - 1) / maxLineLength);
}

inline
int Base64Encoder::encodedLength(int inputLength)
{
    BSLS_ASSERT_SAFE(0 &lt;= inputLength);

    return encodedLength(inputLength, 76);
}

inline
int Base64Encoder::encodedLines(int inputLength, int maxLineLength)
{
    BSLS_ASSERT_SAFE(0 &lt;= inputLength);
    BSLS_ASSERT_SAFE(0 &lt;= maxLineLength);

    const int length = (inputLength + 2) / 3 * 4;

    return 0 == maxLineLength ? 1 : 1 + length / maxLineLength;
}

inline
int Base64Encoder::encodedLines(int inputLength)
{
    BSLS_ASSERT_SAFE(0 &lt;= inputLength);

    return encodedLines(inputLength, 76);
}

inline
bool Base64Encoder::isResidualOutput(int numBytes, int maxLineLength)
{
    BSLS_ASSERT_SAFE(0 &lt;= numBytes);
    BSLS_ASSERT_SAFE(0 &lt;= maxLineLength);

    const int adj = maxLineLength ? 2 * (numBytes / (maxLineLength + 2)) : 0;
    return 0 != (numBytes - adj) % 4;
}

// CREATORS
inline
Base64Encoder::Base64Encoder()
: d_state(e_INITIAL_STATE)
, d_maxLineLength(s_defaultMaxLineLength)
, d_lineLength(0)
, d_outputLength(0)
, d_stack(0)
, d_bitsInStack(0)
{
}

inline
Base64Encoder::Base64Encoder(int maxLineLength)
: d_state(e_INITIAL_STATE)
, d_maxLineLength(maxLineLength)
, d_lineLength(0)
, d_outputLength(0)
, d_stack(0)
, d_bitsInStack(0)
{
    BSLS_ASSERT_SAFE(0 &lt;= maxLineLength);
}

// MANIPULATORS
template &lt;class OUTPUT_ITERATOR, class INPUT_ITERATOR&gt;
int Base64Encoder::convert(OUTPUT_ITERATOR out,
                           INPUT_ITERATOR  begin,
                           INPUT_ITERATOR  end)
{
    int dummyNumOut;
    int dummyNumIn;

    return convert(out, &amp;dummyNumOut, &amp;dummyNumIn, begin, end, -1);
}

template &lt;class OUTPUT_ITERATOR, class INPUT_ITERATOR&gt;
int Base64Encoder::convert(OUTPUT_ITERATOR  out,
                           int             *numOut,
                           int             *numIn,
                           INPUT_ITERATOR   begin,
                           INPUT_ITERATOR   end,
                           int              maxNumOut)
{
    int dummyNumOut;
    if (!numOut) {
        numOut = &amp;dummyNumOut;
    }
    int dummyNumIn;
    if (!numIn) {
        numIn  = &amp;dummyNumIn;
    }

    if (e_ERROR_STATE == d_state || e_DONE_STATE == d_state) {
        d_state = e_ERROR_STATE;
        *numOut = 0;
        *numIn  = 0;
        return -1;                                                    // RETURN
    }

    const int initialLength = d_outputLength;
    const int maxLength     = d_outputLength + maxNumOut;

    // Emit as many output bytes as possible.

    while (6 &lt;= d_bitsInStack &amp;&amp; d_outputLength != maxLength) {
        encode(&amp;out, maxLength);
    }

    // Consume as many input bytes as possible.

    int tmpNumIn = 0;

    while (4 &gt;= d_bitsInStack &amp;&amp; begin != end) {
        const unsigned char byte = static_cast&lt;unsigned char&gt;(*begin);

        ++begin;
        ++tmpNumIn;

        d_stack        = (d_stack &lt;&lt; 8) | byte;
        d_bitsInStack += 8;

        if (d_outputLength != maxLength) {
            encode(&amp;out, maxLength);
            if (6 &lt;= d_bitsInStack &amp;&amp; d_outputLength != maxLength) {
                encode(&amp;out, maxLength);
            }
        }
    }

    *numIn  = tmpNumIn;
    *numOut = d_outputLength - initialLength;

    return 0;
}

template &lt;class OUTPUT_ITERATOR&gt;
int Base64Encoder::endConvert(OUTPUT_ITERATOR out)
{
    int dummyNumOut;

    return endConvert(out, &amp;dummyNumOut, -1);
}

template &lt;class OUTPUT_ITERATOR&gt;
int Base64Encoder::endConvert(OUTPUT_ITERATOR  out,
                              int             *numOut,
                              int              maxNumOut)
{
    BSLS_ASSERT(numOut);

    if (e_ERROR_STATE == d_state || isDone()) {
        d_state = e_ERROR_STATE;
        *numOut = 0;
        return -1;                                                    // RETURN
    }

    d_state = e_DONE_STATE;

    const int initialLength = d_outputLength;
    const int maxLength = d_outputLength + maxNumOut;

    // Handle trailing bits.

    const int residualBits = d_bitsInStack % 6;
    if (residualBits) {
        const int shift = 6 - residualBits;
        d_stack = d_stack &lt;&lt; shift;
        d_bitsInStack += shift;
    }

    // Emit as many output bytes as possible.

    while (6 &lt;= d_bitsInStack &amp;&amp; d_outputLength != maxLength) {
        encode(&amp;out, maxLength);
    }

    // Append trailing &#39;=&#39; as necessary.

    if (0 == d_bitsInStack) {
        while (isResidualOutput(d_outputLength, d_maxLineLength) &amp;&amp;
                                                 d_outputLength != maxLength) {
            append(&amp;out, &#39;=&#39;, maxLength);
        }
    }

    *numOut = d_outputLength - initialLength;

    return 0;
}

inline
void Base64Encoder::resetState()
{
    d_state        = e_INITIAL_STATE;
    d_outputLength = 0;
    d_lineLength   = 0;
    d_stack        = 0;
    d_bitsInStack  = 0;
}

// ACCESSORS
inline
bool Base64Encoder::isAcceptable() const
{
    return e_ERROR_STATE != d_state;
}

inline
bool Base64Encoder::isDone() const
{
    return e_DONE_STATE == d_state
        &amp;&amp; !d_bitsInStack
        &amp;&amp; !isResidualOutput(d_outputLength, d_maxLineLength);
}

inline
bool Base64Encoder::isError() const
{
    return e_ERROR_STATE == d_state;
}

inline
bool Base64Encoder::isInitialState() const
{
    return 0 == d_outputLength &amp;&amp; e_INITIAL_STATE == d_state;
}

inline
bool Base64Encoder::isMaximal() const
{
    return e_DONE_STATE == d_state &amp;&amp;
          (d_bitsInStack || isResidualOutput(d_outputLength, d_maxLineLength));
}

inline
int Base64Encoder::maxLineLength() const
{
    return d_maxLineLength;
}

inline
int Base64Encoder::outputLength() const
{
    return d_outputLength;
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
