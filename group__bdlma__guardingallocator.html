<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bdlma_guardingallocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_guardingallocator<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a memory allocator that guards against buffer overruns.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Guard Pages</a> </li>
<li>
<a href="#3.2">Thread Safety</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Diagnosing Buffer Overflow</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a memory allocator that guards against buffer overruns. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1GuardingAllocator.html">bdlma::GuardingAllocator</a> </td><td>memory allocator that detects buffer overruns  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__allocator.html" title="Provide a pure abstract interface for memory-allocation mechanisms.">Component bslma_allocator</a>, <a class="el" href="group__bslma__testallocator.html" title="Provide instrumented malloc/free allocator to track memory usage.">Component bslma_testallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a concrete allocation mechanism, <code><a class="el" href="classbdlma_1_1GuardingAllocator.html">bdlma::GuardingAllocator</a></code>, that implements the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol and adjoins a read/write protected guard page to each block of memory returned by the <code>allocate</code> method. The guard page is located immediately following or immediately preceding the block returned from <code>allocate</code> according to an optionally-supplied constructor argument: <br/>
<br/>
<div class="fragment"><pre class="fragment">   ,------------------------.
  ( <a class="code" href="classbdlma_1_1GuardingAllocator.html">bdlma::GuardingAllocator</a> )
   `------------------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">               |         ctor/dtor</span>
<span class="stringliteral">               V</span>
<span class="stringliteral">      ,----------------.</span>
<span class="stringliteral">     ( bslma::Allocator )</span>
<span class="stringliteral">      `----------------&#39;</span>
                         allocate
                         deallocate
</pre></div><br/>
<br/>
 <em>WARNING</em>: Note that this allocator should <em>not</em> be used for production use; it is intended for debugging purposes only. In particular, clients should be aware that a multiple of the page size is allocated for <em>each</em> <code>allocate</code> invocation (unless the size of the request is 0). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Also note that, unlike many other BDE allocators, a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code> cannot be (optionally) supplied upon construction of a counting allocator; instead, a system facility is used that allocates blocks of memory in multiples of the system page size. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="guard_pages"></a> <a class="anchor" id="description.guard_pages"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Guard Pages: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code>GuardingAllocator</code> may be used to debug buffer overflow (or underflow) by protecting a memory page after (or before) each block of memory returned from <code>allocate</code>. Consequently, certain memory access outside the block returned to the client will trigger a memory protection fault. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A constructor argument of type <code>GuardingAllocator::GuardPageLocation</code>, an enumeration, determines whether guard pages are located following (<code>e_AFTER_USER_BLOCK</code>) or preceding (<code>e_BEFORE_USER_BLOCK</code>) the user block. If no value is supplied at construction, <code>e_AFTER_USER_BLOCK</code> is assumed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To illustrate, the following diagram shows the memory layout resulting from an <code>N</code>-byte allocation request from a guarding allocator, where <code>N</code> is assumed to be less than or equal to the size of a memory page. Note that two pages of memory are consumed for each such allocation request: <br/>
<br/>
<div class="fragment"><pre class="fragment">  N` - N rounded up to the least multiple of the maximum alignment
  A  - address of (2-page) block of memory returned by system allocator
  U  - address returned from &#39;allocate&#39; to user
  G  - address of the guard page
  PS - page size (in bytes)

                          e_AFTER_USER_BLOCK
                          ------------------

      [ - - - one memory page  - - - | - - - one memory page  - - - ]
      ---------------------------------------------------------------
      |                 |  N` bytes  | ******* R/W protected ****** |
      ---------------------------------------------------------------
      ^                 ^            ^
      A                 U == G - N`  G == A + PS

                          e_BEFORE_USER_BLOCK
                          -------------------

      ---------------------------------------------------------------
      | ******* R/W protected ****** |  N` bytes  |                 |
      ---------------------------------------------------------------
      ^                              ^
      A == G                         U == A + PS
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlma_1_1GuardingAllocator.html">bdlma::GuardingAllocator</a></code> class is fully thread-safe (see <code>bsldoc_glossary</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_diagnosing_buffer_overflow"></a> <a class="anchor" id="usage.example_1~3A_diagnosing_buffer_overflow"></a> <a class="anchor" id="description.usage.example_1~3A_diagnosing_buffer_overflow"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Diagnosing Buffer Overflow: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Use of a <code><a class="el" href="classbdlma_1_1GuardingAllocator.html">bdlma::GuardingAllocator</a></code> is indicated, for example, if some code under development is suspected of having a buffer overrun (or underrun) bug, and more sophisticated tools that detect such conditions are either not available, or are inconvenient to apply to the situation at hand. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This usage example illustrates a guarding allocator being brought to bear on a buffer overrun bug. The bug in question arises in the context of an artificial data handling class, <code>my_DataHandler</code>. This class makes use of a (similarly artificial) data translation utility that translates chunks of data among various data styles. In our idealized example, we assume that the length of the output resulting from some data translation is precisely determinable from the length of the input data and the respective styles of the input and the (desired) output. For simplicity, we also assume that input data comes from a trusted source. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define an enumeration of data styles: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> my_DataStyle {
      e_STYLE_NONE = 0
    , e_STYLE_A    = 1  <span class="comment">// default style</span>
    , e_STYLE_AA   = 2  <span class="comment">// style exactly twice as verbose as &#39;e_STYLE_A&#39;</span>
    <span class="comment">// etc.</span>
  };
</pre></div><br/>
<br/>
 Next, we define the (elided) interface of our data translation utility: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>my_DataTranslationUtil {
      <span class="comment">// This &#39;struct&#39; provides a namespace for data translation utilities.</span>

      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> <span class="keywordtype">int</span> outputSize(my_DataStyle outputStyle,
                            my_DataStyle inputStyle,
                            <span class="keywordtype">int</span>          inputLength);
         <span class="comment">// Return the buffer size (in bytes) required to store the result of</span>
         <span class="comment">// converting input data of the specified &#39;inputLength&#39; (in bytes),</span>
         <span class="comment">// in the specified &#39;inputStyle&#39;, into the specified &#39;outputStyle&#39;.</span>
         <span class="comment">// The behavior is undefined unless &#39;0 &lt;= inputLength&#39;.</span>

      <span class="keyword">static</span> <span class="keywordtype">int</span> translate(      <span class="keywordtype">char</span> *output, my_DataStyle outputStyle,
                           <span class="keyword">const</span> <span class="keywordtype">char</span> *input,  my_DataStyle inputStyle);
          <span class="comment">// Load into the specified &#39;output&#39; buffer the result of converting</span>
          <span class="comment">// the specified &#39;input&#39; data, in the specified &#39;inputStyle&#39;, into</span>
          <span class="comment">// the specified &#39;outputStyle&#39;.  Return 0 on success, and a</span>
          <span class="comment">// non-zero value otherwise.  The behavior is undefined unless</span>
          <span class="comment">// &#39;output&#39; has sufficient capacity to hold the translated result.</span>
          <span class="comment">// Note that this method assumes that &#39;input&#39; originated from a</span>
          <span class="comment">// trusted source.</span>
  };
</pre></div><br/>
<br/>
 Next, we define <code>my_DataHandler</code>, a simple class that makes use of <code>my_DataTranslationUtil</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_DataHandler {
      <span class="comment">// This &#39;class&#39; provides a basic data handler.</span>

      <span class="comment">// DATA</span>
      my_DataStyle      d_inStyle;     <span class="comment">// style of &#39;d_inBuffer&#39; contents</span>
      <span class="keywordtype">char</span>             *d_inBuffer;    <span class="comment">// input supplied at construction</span>
      <span class="keywordtype">int</span>               d_inCapacity;  <span class="comment">// capacity (in bytes) of &#39;d_inBuffer&#39;</span>
      my_DataStyle      d_altStyle;    <span class="comment">// alternative style (if requested)</span>
      <span class="keywordtype">char</span>             *d_altBuffer;   <span class="comment">// buffer for alternative style</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p; <span class="comment">// memory allocator (held, not owned)</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_DataHandler(<span class="keyword">const</span> <span class="keywordtype">char</span>       *input,
                     <span class="keywordtype">int</span>               inputLength,
                     my_DataStyle      inputStyle,
                     <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a data handler for the specified &#39;input&#39; data, in the</span>
          <span class="comment">// specified &#39;inputStyle&#39;, having the specified &#39;inputLength&#39; (in</span>
          <span class="comment">// bytes).  Optionally specify a &#39;basicAllocator&#39; used to supply</span>
          <span class="comment">// memory.  If &#39;basicAllocator&#39; is 0, the currently installed</span>
          <span class="comment">// default allocator is used.  The behavior is undefined unless</span>
          <span class="comment">// &#39;0 &lt;= inputLength&#39;.</span>

      ~my_DataHandler();
          <span class="comment">// Destroy this data handler.</span>

      <span class="comment">// ...</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">int</span> generateAlternate(my_DataStyle alternateStyle);
          <span class="comment">// Generate data for this data handler in the specified</span>
          <span class="comment">// &#39;alternateStyle&#39;.  Return 0 on success, and a non-zero value</span>
          <span class="comment">// otherwise.  If &#39;alternateStyle&#39; is the same as the style of data</span>
          <span class="comment">// supplied at construction, this method returns 0 with no effect.</span>

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Next, we show the definition of the <code>my_DataHandler</code> constructor: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_DataHandler::my_DataHandler(<span class="keyword">const</span> <span class="keywordtype">char</span>       *input,
                                 <span class="keywordtype">int</span>               inputLength,
                                 my_DataStyle      inputStyle,
                                 <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_inStyle(inputStyle)
  , d_inBuffer(0)
  , d_inCapacity(inputLength)
  , d_altStyle(e_STYLE_NONE)
  , d_altBuffer(0)
  , d_allocator_p(bslma::Default::allocator(basicAllocator))
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt;= inputLength);

      <span class="keywordtype">void</span> *tmp = d_allocator_p-&gt;allocate(inputLength);
      bsl::memcpy(tmp, input, inputLength);
      d_inBuffer = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(tmp);
  }
</pre></div><br/>
<br/>
 Next, we show the definition of the <code>generateAlternate</code> manipulator. Note that we have deliberately introduced a bug in <code>generateAlternate</code> to cause buffer overrun: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> my_DataHandler::generateAlternate(my_DataStyle alternateStyle)
  {
      <span class="keywordflow">if</span> (alternateStyle == d_inStyle) {
          <span class="keywordflow">return</span> 0;                                                 <span class="comment">// RETURN</span>
      }

      <span class="keywordtype">int</span> altLength = my_DataTranslationUtil::outputSize(alternateStyle,
                                                         d_inStyle,
                                                         d_inCapacity);

      <span class="comment">// Oops!  Should have used &#39;altLength&#39;.</span>
      <span class="keywordtype">char</span> *tmpAltBuffer = (<span class="keywordtype">char</span> *)d_allocator_p-&gt;allocate(d_inCapacity);
      <span class="keywordtype">int</span> rc = my_DataTranslationUtil::translate(tmpAltBuffer,
                                                 alternateStyle,
                                                 d_inBuffer,
                                                 d_inStyle);

      <span class="keywordflow">if</span> (rc) {
          d_allocator_p-&gt;deallocate(tmpAltBuffer);
          <span class="keywordflow">return</span> rc;                                                <span class="comment">// RETURN</span>
      }

      d_altStyle  = alternateStyle;
      d_altBuffer = tmpAltBuffer;

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 Next, we define some data (in <code>e_STYLE_A</code>) and define a <code>my_DataHandler</code> object, <code>handler</code>, to process that data. Note that our <code>handler</code> object uses the default allocator: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">char</span> *input = <span class="stringliteral">&quot;AAAAAAAAAAAAAAA@&quot;</span>;  <span class="comment">// data always terminated with &#39;@&#39;</span>

  my_DataHandler handler(input, 16, e_STYLE_A);
</pre></div><br/>
<br/>
 Next, we request that an alternate data style, <code>e_STYLE_AA</code>, be generated by <code>handler</code>. Unfortunately, data in style <code>e_STYLE_AA</code> is twice as large as that in style <code>e_STYLE_A</code> making it a virtual certainty that the program will crash due to the insufficiently sized buffer that is allocated in the <code>generateAlternate</code> method to accommodate the <code>e_STYLE_AA</code> data: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> rc = handler.generateAlternate(e_STYLE_AA);
  <span class="keywordflow">if</span> (!rc) {
      <span class="comment">// use data in alternate style</span>
  }
</pre></div><br/>
<br/>
 Suppose that after performing a brief post mortem on the resulting core file, we strongly suspect that a buffer overrun is the root cause, but the program crashed in a context far removed from that of the source of the problem (which is often the case with buffer overrun issues). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Consequently, we modify the code to supply a guarding allocator to the <code>handler</code> object, then rebuild and rerun the program. We have configured the guarding allocator (below) to place guard pages <em>after</em> user blocks. Note that <code>e_AFTER_USER_BLOCK</code> is the default, so it need not be specified at construction as we have (pedantically) done here: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbdlma_1_1GuardingAllocator.html">bdlma::GuardingAllocator</a> GA;
  GA guard(GA::e_AFTER_USER_BLOCK);

  my_DataHandler handler(input, 16, e_STYLE_A, &amp;guard);
</pre></div><br/>
<br/>
 With a guarding allocator now in place, a memory fault is triggered when a guard page is overwritten as a result of the buffer overrun bug. Hence, the program will dump core in a context that is more proximate to the buggy code, resulting in a core file that will be more amenable to revealing the issue when analyzed in a debugger. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:19 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
