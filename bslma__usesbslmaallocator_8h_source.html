<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslma_usesbslmaallocator.h                                         -*-C++-*-
#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#define INCLUDED_BSLMA_USESBSLMAALLOCATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a metafunction that indicates the use of bslma allocators.
//
//@CLASSES:
//  bslma::UsesBslmaAllocator&lt;TYPE&gt;: trait detection metafunction
//
//@SEE_ALSO: bslalg_typetraitusesblsmaallocator
//
//@DESCRIPTION: This component defines a meta-function,
// &#39;bslma::UsesBslmaAllocator&#39;, that may be used to associate a type with the
// uses-bslma allocator trait (i.e., declare that a type uses a bslma
// allocator), and also to detect whether a type has been associated with that
// trait (i.e., to test whether a type uses a bslma allocator, and follows the
// bslma allocator model).
//
///Properties of Types Declaring the &#39;UsesBslmaAllocator&#39; Trait
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Types that declare the &#39;UsesBslmaAllocator&#39; trait must meet some minimal
// requirements in order for that type to be usable with code that tests for
// the &#39;UsesBslmaAllocator&#39; trait (e.g., &#39;bsl&#39; containers).  In addition, types
// that use allocators must have certain properties with respect to memory
// allocation, which are not enforced by the compiler (such a type is described
// as following the bslma allocator model).
//
///Compiler Enforced Requirements of Types Declaring &#39;UsesBslmaAllocator&#39;
///-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
// Types declaring the &#39;UsesBslmaAllocator&#39; trait must provide a constructor
// variants that accepts a &#39;bslma::Allocator *&#39; as the last parameter
// (typically this is an optional parameter).  If such a type provides a
// copy-constructor, it must similarly provide a variant that takes a
// (optional) &#39;bslma::Allocator *&#39; as the last parameter.
//
// Template types (such as &#39;bsl&#39; containers), where the template parameter
// &#39;TYPE&#39; represents some element type encapsulated by the class template,
// often use the &#39;UsesBslmaAllocator&#39; trait to test if &#39;TYPE&#39; uses &#39;bslma&#39;
// allocators, and if so, to create &#39;TYPE&#39; objects using the constructor
// variant taking an allocator.  In this context, compilation will fail if a
// type declares the &#39;UsesBslmaAllocator&#39; trait, but does not provide the
// expected constructor variant accepting a &#39;bslma::Allocator *&#39; as the last
// parameter.
//
///Expected Properties of Types Declaring the &#39;UsesBslmaAllocator&#39; Trait
///  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
// Types declaring the &#39;UsesBslmaAllocator&#39; trait are expected to have certain
// properties with respect to memory allocation.  These properties are not
// enforced by the compiler, but are necessary to ensure consistent and
// comprehensible allocation behavior.
//
//: o The allocator supplied at construction of an object will be used for
//:   non-transient memory allocation during the object&#39;s lifetime.  This
//:   particularly includes allocations performed by sub-objects that
//:   themselves support the bslma allocator model (i.e., the type will provide
//:   the supplied allocator to any data-members which themselves accept an
//:   allocator).
//:
//: o The allocator used by an object is not changed after construction (e.g.,
//:   the assignment operator does not change the allocator used by a type).
//
//: o Transient memory allocations -- i.e., allocations performed within the
//:   scope of a function where the resulting memory is de-allocated before
//:   that function returns -- are generally *not* performed using the object&#39;s
//:   allocator.  Although clients may choose whichever allocator suits the
//:   specific context, most often transient memory allocations are performed
//:   using the currently installed default allocator.  For example: a
//:   temporary &#39;bsl::string&#39; that is destroyed within the scope of a method
//:   need not be explicitly supplied an allocator, since it is a transient
//:   allocation, and &#39;bsl::string&#39; will use the default allocator by default.
//:
//: o The allocator used by an object is not part of an object&#39;s value (e.g.,
//:   it is not tested by comparison operations like &#39;operator==&#39;).
//:
//: o If an allocator is not supplied at construction, then the currently
//:   installed default allocator will typically be used (see &#39;bslma_default&#39;).
//:
//: o Singleton objects, when necessary, allocate memory from the global
//:   allocator (see &#39;bslma_default&#39;)
//
///Usage
///-----
// This section illustrates intended usage of this component.
//
///Example 1: Associating the &#39;bslma&#39; Allocator Trait with a Type
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we want to declare two types that make use of a &#39;bslma&#39; allocator,
// and need to associate the &#39;UsesBslmaAllocator&#39; trait with those types (so
// that they behave correctly when inserted into a &#39;bsl&#39; container, for
// example).  In this example we will demonstrate two different mechanisms by
// which a trait may be associated with a type.
//
// First, we declare a type &#39;UsesAllocatorType1&#39;, using the
// &#39;BSLMF_NESTED_TRAIT_DECLARATION&#39; macro to associate the type with the
// &#39;UsesBslmaAllocator&#39; trait:
//..
//  namespace xyz {
//
//  class UsesAllocatorType1 {
//      // ...
//
//    public:
//      // TRAITS
//      BSLMF_NESTED_TRAIT_DECLARATION(UsesAllocatorType1,
//                                     bslma::UsesBslmaAllocator);
//      // CREATORS
//      explicit UsesAllocatorType1(bslma::Allocator *basicAllocator = 0);
//          // ...
//
//      UsesAllocatorType1(const UsesAllocatorType1&amp;  original,
//                     bslma::Allocator              *basicAllocator = 0);
//          // ...
//  };
//..
// Notice that the macro declaration is performed within the scope of the class
// declaration, and must be done with public scope.
//
// Then, we declare a type &#39;UsesAllocatorType2&#39;, and define a specialization of
// the &#39;UsesBslmaAllocator&#39; trait for &#39;UsesAllocatorType2&#39; that associates the
// &#39;UsesBslmaAllocator&#39; trait with the type (note that this is sometimes
// referred to as a &quot;C++11 style&quot; trait declaration, since it is more in
// keeping with the style of trait declarations found in the C++11 standard):
//..
//  class UsesAllocatorType2 {
//      // ...
//
//    public:
//      // CREATORS
//      explicit UsesAllocatorType2(bslma::Allocator *basicAllocator = 0);
//          // ...
//
//      UsesAllocatorType2(const UsesAllocatorType2&amp;  original,
//                         bslma::Allocator          *basicAllocator = 0);
//          // ...
//  };
//
//  }  // close package namespace
//
//  namespace BloombergLP {
//  namespace bslma {
//
//  template &lt;&gt; struct UsesBslmaAllocator&lt;xyz::UsesAllocatorType2&gt; :
//                                                               bsl::true_type
//  {};
//
//  }  // close package namespace
//  }  // close enterprise namespace
//..
// Notice that the specialization must be performed in the &#39;BloombergLP::bslma&#39;
// namespace.
//
///Example 2: Testing Whether a Types Uses a &#39;bslma&#39; Allocator
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we want to test whether each of a set of different types use a
// &#39;bslma&#39; allocator.
//
// Here, we use the &#39;UsesBslmaAllocator&#39; template to test whether the types
// &#39;DoesNotUseAnAllocatorType&#39;, &#39;UsesAllocatorType1&#39;, and &#39;UsesAllocatorType2&#39;
// (defined above) use allocators:
//..
//  assert(false ==
//         bslma::UsesBslmaAllocator&lt;DoesNotUseAnAllocatorType&gt;::value);
//
//  assert(true  ==
//         bslma::UsesBslmaAllocator&lt;UsesAllocatorType1&gt;::value);
//
//  assert(true  ==
//         bslma::UsesBslmaAllocator&lt;UsesAllocatorType2&gt;::value);
//..
// Finally, we demonstrate that the trait can be tested at compilation time, by
// testing the trait within the context of a compile-time &#39;BSLMF_ASSERT&#39;:
//..
//  BSLMF_ASSERT(false ==
//               bslma::UsesBslmaAllocator&lt;DoesNotUseAnAllocatorType&gt;::value);
//
//  BSLMF_ASSERT(true  ==
//               bslma::UsesBslmaAllocator&lt;UsesAllocatorType1&gt;::value);
//
//  BSLMF_ASSERT(true ==
//               bslma::UsesBslmaAllocator&lt;UsesAllocatorType2&gt;::value);
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLMF_DETECTNESTEDTRAIT
#include &lt;bslmf_detectnestedtrait.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISCONVERTIBLE
#include &lt;bslmf_isconvertible.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISSAME
#include &lt;bslmf_issame.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVECV
#include &lt;bslmf_removecv.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVEPOINTER
#include &lt;bslmf_removepointer.h&gt;
#endif


namespace BloombergLP {

namespace bslma {

                        // ========================
                        // class UsesBslmaAllocator
                        // ========================

template &lt;class TYPE, bool IS_NESTED&gt;
struct UsesBslmaAllocator_Imp
{
    typedef bsl::integral_constant&lt;bool, IS_NESTED&gt; Type;
};

template &lt;class TYPE&gt;
struct UsesBslmaAllocator_Imp&lt;TYPE, false&gt;
{
private:
    struct UniqueType {
        // A class convertible from this type must have a templated
        // constructor or a &#39;void*&#39; which makes it convertible from EVERY
        // pointer type.
    };

    enum {
        // Detect if &#39;TYPE&#39; is &#39;Allocator*&#39; type.
        IS_BSLMA_POINTER
            = bsl::is_same&lt;
                Allocator,
                typename bsl::remove_cv&lt;
                    typename bsl::remove_pointer&lt;TYPE&gt;::type&gt;::type&gt;::value,

        // If a pointer to &#39;Allocator&#39; is convertible to &#39;T&#39;, then &#39;T&#39; has a
        // non-explicit constructor taking an allocator.
        BSLMA_POINTER_CTOR = bsl::is_convertible&lt;Allocator *, TYPE&gt;::value,

        // If a pointer to &#39;UniqueType&#39; is convertible to &#39;T&#39;, it can only mean
        // that ANY POINTER is convertible to &#39;T&#39;.
        ANY_POINTER_CTOR = bsl::is_convertible&lt;UniqueType *, TYPE&gt;::value
    };

public:
    typedef bsl::integral_constant&lt;bool,
                                   !IS_BSLMA_POINTER
                                   &amp;&amp; BSLMA_POINTER_CTOR
                                   &amp;&amp; !ANY_POINTER_CTOR&gt;
        Type;
};

template &lt;class TYPE&gt;
struct UsesBslmaAllocator
    : UsesBslmaAllocator_Imp&lt;
        TYPE,
        bslmf::DetectNestedTrait&lt;TYPE, UsesBslmaAllocator&gt;::value&gt;::Type::type
{
    // This metafunction is derived from &#39;true_type&#39; if &#39;TYPE&#39; adheres to the
    // &#39;bslma&#39; allocator usage idiom and &#39;false_type&#39; otherwise.  Note that
    // this trait must be explicitly associated with a type in order for this
    // metafunction to return true; simply having a constructor that implicitly
    // converts &#39;bslma::Allocator*&#39; to &#39;TYPE&#39; is no longer sufficient for
    // considering a type follow the idiom.
};

template &lt;class TYPE&gt;
struct UsesBslmaAllocator&lt;const TYPE&gt; : UsesBslmaAllocator&lt;TYPE&gt;::type
{
    // Specialization that associates the same trait with &#39;const TYPE&#39; as with
    // unqualified &#39;TYPE&#39;.
};

template &lt;class TYPE&gt;
struct UsesBslmaAllocator&lt;volatile TYPE&gt; : UsesBslmaAllocator&lt;TYPE&gt;::type
{
    // Specialization that associates the same trait with &#39;volatile TYPE&#39; as
    // with unqualified &#39;TYPE&#39;.
};

template &lt;class TYPE&gt;
struct UsesBslmaAllocator&lt;const volatile TYPE&gt; : UsesBslmaAllocator&lt;TYPE&gt;::type
{
    // Specialization that associates the same trait with &#39;const volatile
    // TYPE&#39; as with unqualified &#39;TYPE&#39;.
};

}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
