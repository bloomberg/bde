<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslstl_unorderedmultimap Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_unorderedmultimap<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL-compliant <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> container.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KEY&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga2f3c53d75684dcbbe20f3d1eb1372095">bsl::unordered_multimap::key_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gaf6dad2c21aaf5f1df3ff251d3907bd5d">bsl::unordered_multimap::mapped_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; const KEY, <br class="typebreak"/>
VALUE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gadefb4991e590eaa5f5b85ab53a69571f">bsl::unordered_multimap::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef HASH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga76f55c90b8798789c980d5a149f37602">bsl::unordered_multimap::hasher</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef EQUAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga8f52aca7b7469f34641095f3f459b9a8">bsl::unordered_multimap::key_equal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga2f9fe7fe9790a29ea160fb0debbe5dc0">bsl::unordered_multimap::allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef allocator_type::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gab6e7a120cd5af2267d60026f8fd3b58c">bsl::unordered_multimap::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
allocator_type::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gae5669b2cd4f3b8579ea80b61e1c4809e">bsl::unordered_multimap::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorTraits::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gadfb9cea5ec4f52cd0831b29044081b87">bsl::unordered_multimap::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorTraits::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gaca2d4c3d7a43743f32bb3ab4f4a94390">bsl::unordered_multimap::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorTraits::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gadd311f9d0e8afa7ef54648f40711a1cf">bsl::unordered_multimap::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorTraits::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga3177d291855e3b9bacc161b2f6fbceb1">bsl::unordered_multimap::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
::<a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a><br class="typebreak"/>
&lt; value_type, difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gaf9763e68018560210af8bde69cd7b5f4">bsl::unordered_multimap::iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
::<a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a><br class="typebreak"/>
&lt; const value_type, <br class="typebreak"/>
difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga4c131b08f030f55fe54593330765c028">bsl::unordered_multimap::const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
::BloombergLP::bslstl::HashTableBucketIterator<br class="typebreak"/>
&lt; value_type, difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gae813a58f8d7bd4c55e6a4598ac469eda">bsl::unordered_multimap::local_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
::BloombergLP::bslstl::HashTableBucketIterator<br class="typebreak"/>
&lt; const value_type, <br class="typebreak"/>
difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga1fe450965cd2e865814f04f08e6d4d0e">bsl::unordered_multimap::const_local_iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gaac682fd548c4d3c1008c47976ecff937">bsl::unordered_multimap::BSLMF_NESTED_TRAIT_DECLARATION_IF</a> (unordered_multimap,::BloombergLP::bslmf::IsBitwiseMoveable,::BloombergLP::bslmf::IsBitwiseMoveable&lt; Impl &gt;::value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga0410d6fde47718fa170251c7711b9944">bsl::unordered_multimap::unordered_multimap</a> (size_type initialNumBuckets=0, const hasher &amp;hashFunction=hasher(), const key_equal &amp;keyEqual=key_equal(), const allocator_type &amp;basicAllocator=allocator_type())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga231cca18f3ee4ce03f86270fd7cb74f7">bsl::unordered_multimap::unordered_multimap</a> (const allocator_type &amp;basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gaed509e1f519998a9f5001b48d4ef4299">bsl::unordered_multimap::unordered_multimap</a> (const unordered_multimap &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga9bd3ba348ca33cea4cc26b7c8a4be99f">bsl::unordered_multimap::unordered_multimap</a> (const unordered_multimap &amp;original, const allocator_type &amp;basicAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gacd49cdf1779134ed5a1af58d68cb6132">bsl::unordered_multimap::unordered_multimap</a> (INPUT_ITERATOR first, INPUT_ITERATOR last, size_type initialNumBuckets=0, const hasher &amp;hashFunction=hasher(), const key_equal &amp;keyEqual=key_equal(), const allocator_type &amp;basicAllocator=allocator_type())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gaf6caf74f21786fbf5d03f4a3d1d2def2">bsl::unordered_multimap::~unordered_multimap</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unordered_multimap &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga135e7248c988f4402f005238ee177807">bsl::unordered_multimap::operator=</a> (const unordered_multimap &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gab74233fc1e63af8a6239d11cf5358b09">bsl::unordered_multimap::begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gaf9e1d466f0dc443794f725edcec940e1">bsl::unordered_multimap::end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga8e748b022792a1de33d1716612366b84">bsl::unordered_multimap::begin</a> (size_type index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga3bd74d50836fe749d5faa4a998a0bf02">bsl::unordered_multimap::end</a> (size_type index)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SOURCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gaf477dd97f3d770b873117db2a5b66cff">bsl::unordered_multimap::insert</a> (const SOURCE_TYPE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SOURCE_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga1887c0e3041ebc64a3ffcdee5ecbaf34">bsl::unordered_multimap::insert</a> (const_iterator hint, const SOURCE_TYPE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga120ccac5426c74bf808986b21347fb56">bsl::unordered_multimap::insert</a> (INPUT_ITERATOR first, INPUT_ITERATOR last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga8b267bf512957aef7ad57f869f64d7d3">bsl::unordered_multimap::erase</a> (const_iterator position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gaffdc9a47f3d83745061034e9870cf92b">bsl::unordered_multimap::erase</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga86f8798cd7f9fe34d833ad5dbd7e7559">bsl::unordered_multimap::erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gabd70b6e1e90e6ce2f4342a015b247e28">bsl::unordered_multimap::clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gaf662a1f8e82651f2a68ce41b1c8b3e60">bsl::unordered_multimap::find</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pair&lt; iterator, iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga83a7c4bcbb52b46a93ead7b880479182">bsl::unordered_multimap::equal_range</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga9b654ec0beee8b2ab35657c74fc97bd8">bsl::unordered_multimap::max_load_factor</a> (float newLoadFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gae3efac9ac142db3573906e912a93f4d4">bsl::unordered_multimap::rehash</a> (size_type numBuckets)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga4607cccd679a179177a3a3059f2c164a">bsl::unordered_multimap::reserve</a> (size_type numElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gae7adb7981d2b8ef8511ac105d6132a29">bsl::unordered_multimap::swap</a> (unordered_multimap &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gaf0e5cbd3ef44c21c7f6bf5e224a385d8">bsl::unordered_multimap::get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gafeddcaf9562ba0f973de55418def6295">bsl::unordered_multimap::begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga3b380567f2346058666ecf8c7b83cdc9">bsl::unordered_multimap::cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga2c4698aca5fde8b31514863defb05a1d">bsl::unordered_multimap::end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga070ba9c33597017c6f43734a051caf28">bsl::unordered_multimap::cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gaee79838527b2f66cf886b440d22f9129">bsl::unordered_multimap::begin</a> (size_type index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga528eb49256242b3ed01bafc99c55491c">bsl::unordered_multimap::cbegin</a> (size_type index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga017c70e88e46f791239358d73713b5f3">bsl::unordered_multimap::end</a> (size_type index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga6be11681ad474d95be94ef5e1c658241">bsl::unordered_multimap::cend</a> (size_type index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga44ee843e49906d46474eb2717809983d">bsl::unordered_multimap::bucket</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga466816021ed02f5acde57e4a59df1778">bsl::unordered_multimap::bucket_count</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga03fab7253da748c06d6c762397b23daf">bsl::unordered_multimap::max_bucket_count</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gabb1edc6003e4401dd92a81a92313c933">bsl::unordered_multimap::bucket_size</a> (size_type index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga85711e390197559118773821479f95ff">bsl::unordered_multimap::count</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga40167f0c6140684e6e5a063316e8365b">bsl::unordered_multimap::empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pair&lt; const_iterator, <br class="typebreak"/>
const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gacee76407a5961ea64a9ac4544952004e">bsl::unordered_multimap::equal_range</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gae6cf31b1f3b50535c0ca83657ea58ac8">bsl::unordered_multimap::find</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hasher&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga1e3d95a4e06eb7a794b24fa9e64a276d">bsl::unordered_multimap::hash_function</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">key_equal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gad99d107d54bcb8acd41d1982947b16dc">bsl::unordered_multimap::key_eq</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gafe982e3830612c4a120f799dfcaeb5d6">bsl::unordered_multimap::load_factor</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gab59777efb76a1f55aa8df96ea1d4db39">bsl::unordered_multimap::max_load_factor</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga8b0375724c5aa5bcdc47568eef8b89b0">bsl::unordered_multimap::max_size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga46765dd973cab0ed6fa55e5a018fd02d">bsl::unordered_multimap::size</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga601a88fd6f232d89827226c779166c7c">bsl::operator==</a> (const unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#gace2f15b7cbef1336dd4dd63794e3f1dd">bsl::operator!=</a> (const unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga390f9783cd0c4c7c8be26e37b2b052c6">bsl::swap</a> (unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;a, unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td colspan="2"><h2><a name="friend-members"></a>
Friends</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY2 , class VALUE2 , class HASH2 , class EQUAL2 , class ALLOCATOR2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultimap.html#ga866533046724d6161b716f56f7108c86">bsl::unordered_multimap::operator==</a> (const unordered_multimap&lt; KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;, const unordered_multimap&lt; KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Requirements on <code>KEY</code> and <code>VALUE</code></a> </li>
<li>
<a href="#3.2">Requirements on <code>HASH</code> and <code>EQUAL</code></a> </li>
<li>
<a href="#3.3">Memory Allocation</a> <ul>
<li>
<a href="#3.3.1"><code>bslma</code>-Style Allocators</a> </li>
</ul>
</li>
<li>
<a href="#3.4">Operations</a> </li>
<li>
<a href="#3.5">Iterator, Pointer, and Reference Invalidation</a> </li>
<li>
<a href="#3.6">Unordered Multi-Map Configuration</a> </li>
<li>
<a href="#3.7">Practical Requirements on <code>HASH</code></a> </li>
<li>
<a href="#3.8">Usage</a> <ul>
<li>
<a href="#3.8.1">Example 1: Creating a Concordance</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL-compliant <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> container. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>  </td><td>hashed-map container  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bsl+stdhdrs </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a single class template, <code><a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a></code>, implementing the standard container holding a collection of (possibly repeated) keys, each mapped to an associated value (with minimal guarantees on ordering). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An instantiation of <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> is an allocator-aware, value-semantic type whose salient attributes are its size (number of keys) and the set of key-value pairs the <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> contains, without regard to their order. If <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> is instantiated with a key type or mapped value-type that is not itself value-semantic, then it will not retain all of its value-semantic qualities. In particular, if the key or value type cannot be tested for equality, then an <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> containing that type cannot be tested for equality. It is even possible to instantiate <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> with type that do not have an accessible copy-constructor, in which case the <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> will not be copyable. Note that the equality operator for each key-value pair is used to determine when two <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> objects have the same value, and not the instance of the <code>EQUAL</code> template parameter supplied at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> meets the requirements of an unordered associative container with forward iterators in the C++11 standard [unord]. The <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> implemented here adheres to the C++11 standard, except that it may rehash when setting the <code>max_load_factor</code> in order to preserve the property that the value is always respected (which is a potentially throwing operation) and it does not have interfaces that take rvalue references, <code>initializer_list</code>, <code>emplace</code>, or operations taking a variadic number of template parameters. Note that excluded C++11 features are those that require (or are greatly simplified by) C++11 compiler support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_on_key_and_value"></a> <a class="anchor" id="description.requirements_on_key_and_value"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Requirements on KEY and VALUE: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> instantiation is a fully <a href="group__bsldoc__glossary.html#value-semantic_type" class="glossary">Value-Semantic Type</a> (see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>) only if the supplied <code>KEY</code> and <code>VALUE</code> template parameters are fully value-semantic. It is possible to instantiate an <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> with <code>KEY</code> and <code>VALUE</code> parameter arguments that do not provide a full set of value-semantic operations, but then some methods of the container may not be instantiable. The following terminology, adopted from the C++11 standard, is used in the function documentation of <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> to describe a function's requirements for the <code>KEY</code> and <code>VALUE</code> template parameters. These terms are also defined in section [utility.arg.requirements] of the C++11 standard. Note that, in the context of an <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> instantiation, the requirements apply specifically to the <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code>s element type, <code>value_type</code>, which is an alias for <code>std::pair&lt;const KEY, VALUE&gt;</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="default-constructible"></a> <a class="anchor" id="requirements_on_key_and_value.default-constructible"></a> <a class="anchor" id="description.requirements_on_key_and_value.default-constructible"></a> <em>default-constructible</em>: <br/>
 The type provides an accessible default constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="copy-constructible"></a> <a class="anchor" id="requirements_on_key_and_value.copy-constructible"></a> <a class="anchor" id="description.requirements_on_key_and_value.copy-constructible"></a> <em>copy-constructible</em>: <br/>
 The type provides an accessible copy constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="equality-comparable"></a> <a class="anchor" id="requirements_on_key_and_value.equality-comparable"></a> <a class="anchor" id="description.requirements_on_key_and_value.equality-comparable"></a> <em>equality-comparable</em>: <br/>
 The type provides an equality-comparison operator that defines an equivalence relationship and is both reflexive and transitive.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_on_hash_and_equal"></a> <a class="anchor" id="description.requirements_on_hash_and_equal"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Requirements on HASH and EQUAL: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The (template parameter) types <code>HASH</code> and <code>EQUAL</code> must be copy-constructible function-objects. Note that this requirement is somewhat stronger than the requirement currently in the standard; see the discussion for Issue 2215 (<a href="http://cplusplus.github.com/LWG/lwg-active.html">http://cplusplus.github.com/LWG/lwg-active.html</a>#2215); </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>HASH</code> shall support a function call operator compatible with the following statements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  HASH        hash;
  KEY         key;
  std::size_t result = hash(key);
</pre></div><br/>
<br/>
 where the definition of the called function meets the requirements of a hash function, as specified in <a href="group__bslstl__hash.html#standard_hash_function" class="el"><code>bslstl_hash</code>|Standard Hash Function</a>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>EQUAL</code> shall support the a function call operator compatible with the following statements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  EQUAL equal;
  KEY   key1, key2;
  <span class="keywordtype">bool</span>  result = equal(key1, key2);
</pre></div><br/>
<br/>
 where the definition of the called function defines an equivalence relationship on keys that is both reflexive and transitive. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>HASH</code> and <code>EQUAL</code> function-objects are further constrained, such for any two objects whose keys compare equal by the comparator, shall produce the same value from the hasher. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_allocation"></a> <a class="anchor" id="description.memory_allocation"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The type supplied as the <code>ALLOCATOR</code> template parameter determines how this container will allocate memory. The <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> template supports allocators meeting the requirements of the C++11 standard [allocator.requirements], and in addition it supports scoped-allocators derived from the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> memory allocation protocol. Clients intending to use <code>bslma</code> style allocators should use the template's default <code>ALLOCATOR</code> type: The default type for the <code>ALLOCATOR</code> template parameter, <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, provides a C++11 standard-compatible adapter for a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma-style_allocators"></a> <a class="anchor" id="memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="description.memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>bslma-Style Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the parameterized <code>ALLOCATOR</code> type of an <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> instantiation is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, then objects of that set type will conform to the standard behavior of a <code>bslma</code>-allocator-enabled type. Such a type accepts an optional <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> argument at construction. If the address of a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object is explicitly supplied at construction, it is used to supply memory for the <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> throughout its lifetime; otherwise, the <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> will use the default allocator installed at the time of the <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code>s construction (see <code>bslma_default</code>). In addition to directly allocating memory from the indicated <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, an <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> supplies that allocator's address to the constructors of contained objects of the parameterized <code>KEY</code> types with the <code><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a></code> trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="operations"></a> <a class="anchor" id="description.operations"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section describes the run-time complexity of operations on instances of <code>unsupported_multimap</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Legend
  ------
  <span class="charliteral">&#39;K&#39;</span>             - parameterized <span class="stringliteral">&#39;KEY&#39;</span> type of the unordered multi map
  <span class="charliteral">&#39;V&#39;</span>             - parameterized <span class="stringliteral">&#39;VALUE&#39;</span> type of the unordered multi map
  <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>        - two distinct objects of type <span class="stringliteral">&#39;unordered_multimap&lt;K, V&gt;&#39;</span>
  <span class="charliteral">&#39;n&#39;</span>, <span class="charliteral">&#39;m&#39;</span>        - number of elements in <span class="charliteral">&#39;a&#39;</span> and <span class="charliteral">&#39;b&#39;</span> respectively
  <span class="charliteral">&#39;w&#39;</span>             - number of buckets of <span class="charliteral">&#39;a&#39;</span>
  <span class="stringliteral">&#39;value_type&#39;</span>    - unordered_multimap&lt;K, V&gt;::value_type
  <span class="charliteral">&#39;c&#39;</span>             - comparator providing an ordering <span class="keywordflow">for</span> objects of type <span class="charliteral">&#39;K&#39;</span>
  <span class="stringliteral">&#39;al             - an STL-style memory allocator</span>
<span class="stringliteral">  &#39;</span>i1<span class="stringliteral">&#39;, &#39;</span>i2<span class="stringliteral">&#39;      - two iterators defining a sequence of &#39;</span>value_type<span class="stringliteral">&#39; objects</span>
<span class="stringliteral">  &#39;</span>k<span class="stringliteral">&#39;             - an object of type &#39;</span>K<span class="stringliteral">&#39;</span>
<span class="stringliteral">  &#39;</span>v<span class="stringliteral">&#39;             - an object of type &#39;</span>value_type<span class="stringliteral">&#39;</span>
<span class="stringliteral">  &#39;</span>p1<span class="stringliteral">&#39;, &#39;</span>p2<span class="stringliteral">&#39;      - two iterators belonging to &#39;</span>a<span class="stringliteral">&#39;</span>
<span class="stringliteral">  distance(i1,i2) - the number of elements in the range [i1, i2)</span>
<span class="stringliteral">  distance(p1,p2) - the number of elements in the range [p1, p2)</span>
<span class="stringliteral"></span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | Operation                                          | Complexity         |</span>
<span class="stringliteral">  +====================================================+====================+</span>
<span class="stringliteral">  | unordered_multimap&lt;K, V&gt; a;    (dflt construction) | O[1]               |</span>
<span class="stringliteral">  | unordered_multimap&lt;K, V&gt; a(al);                    |                    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | unordered_multimap&lt;K, V&gt; a(b); (copy construction) | Average: O[n]      |</span>
<span class="stringliteral">  | unordered_multimap&lt;K, V&gt; a(b, al);                 | Worst: O[n^2]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | unordered_multimap&lt;K, V&gt; a(w);                     | O[n]               |</span>
<span class="stringliteral">  | unordered_multimap&lt;K, V&gt; a(w, hf);                 |                    |</span>
<span class="stringliteral">  | unordered_multimap&lt;K, V&gt; a(w, hf, eq);             |                    |</span>
<span class="stringliteral">  | unordered_multimap&lt;K, V&gt; a(w, hf, eq, al);         |                    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | unordered_multimap&lt;K, V&gt; a(i1, i2);                | Average: O[N]      |</span>
<span class="stringliteral">  | unordered_multimap&lt;K, V&gt; a(i1, i2, n)              | Worst:  O[N^2]     |</span>
<span class="stringliteral">  | unordered_multimap&lt;K, V&gt; a(i1, i2, n, hf);         | where N =          |</span>
<span class="stringliteral">  | unordered_multimap&lt;K, V&gt; a(i1, i2, n, hf, eq);     |  distance(i1, i2)] |</span>
<span class="stringliteral">  | unordered_multimap&lt;K, V&gt; a(i1, i2, n, hf, eq, al); |                    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.~unordered_multimap&lt;K, V&gt;(); (destruction)       | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a = b;          (assignment)                       | Average: O[n]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n^2]    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.begin(), a.end(), a.cbegin(), a.cend(),          | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a == b, a != b                                     | Best:  O[n]        |</span>
<span class="stringliteral">  |                                                    | Worst: O[n^2]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.swap(b), swap(a, b                               | O[1] if &#39;</span>a<span class="stringliteral">&#39; and    |</span>
<span class="stringliteral">  |                                                    | &#39;</span>b<span class="stringliteral">&#39; use the same   |</span>
<span class="stringliteral">  |                                                    | allocator,         |</span>
<span class="stringliteral">  |                                                    | O[n + m] otherwise |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.key_eq()                                         | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.hash_function()                                  | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.size()                                           | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.max_size()                                       | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.empty()                                          | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.allocator()                                      | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.insert(v)                                        | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.insert(p1, v)                                    | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.insert(i1, i2)                                   | Average: O[        |</span>
<span class="stringliteral">  |                                                    |   distance(i1, i2)]|</span>
<span class="stringliteral">  |                                                    | Worst:   O[n *     |</span>
<span class="stringliteral">  |                                                    |   distance(i1, i2)]|</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(p1)                                        | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(k)                                         | Average:           |</span>
<span class="stringliteral">  |                                                    |       O[a.count(k)]|</span>
<span class="stringliteral">  |                                                    | Worst:             |</span>
<span class="stringliteral">  |                                                    |       O[n]         |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(p1, p2)                                    | Average: O[        |</span>
<span class="stringliteral">  |                                                    |   distance(p1, p2)]|</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.clear()                                          | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.find(k)                                          | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.count(k)                                         | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.equal_range(k)                                   | Average: O[        |</span>
<span class="stringliteral">  |                                                    |         a.count(k)]|</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.bucket_count()                                   | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.max_bucket_count()                               | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.bucket(k)                                        | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.bucket_size(k)                                   | O[a.bucket_size(k)]|</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.load_factor()                                    | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.max_load_factor()                                | O[1]               |</span>
<span class="stringliteral">  | a.max_load_factor(z)                               | Average: O[1]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.rehash(k)                                        | Average: O[n]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n^2]    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.reserve(k)                                       | Average: O[n]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n^2]    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="iterator,_pointer,_and_reference_invalidation"></a> <a class="anchor" id="description.iterator,_pointer,_and_reference_invalidation"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Iterator, Pointer, and Reference Invalidation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>No method of <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> invalidates a pointer or reference to an element in the set, unless it also erases that element, such as any <code>erase</code> overload, <code>clear</code>, or the destructor (that erases all elements). Pointers and references are stable through a rehash. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Iterators to elements in the container are invalidated by any rehash, so iterators may be invalidated by an <code>insert</code> or <code>emplace</code> call if it triggers a rehash (but not otherwise). Iterators to specific elements are also invalidated when that element is erased. Note that the <code>end</code> iterator is not an iterator referring to any element in the container, so may be invalidated by any non-'const' method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="unordered_multi-map_configuration"></a> <a class="anchor" id="description.unordered_multi-map_configuration"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Unordered Multi-Map Configuration: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The unordered multi-map has interfaces that can provide insight into and control of its inner workings. The syntax and semantics of these interfaces for <code>bslstl_unorderedmultimap</code> are identical to those of <code>bslstl_unorderedmap</code>. See the discussion in <a href="group__bslstl__unorderedmap.html#unordered_map_configuration" class="el"><code>bslstl_unorderedmap</code>|Unordered Map Configuration</a> and the illustrative material in <a href="group__bslstl__unorderedmap.html#example_2" class="el"><code>bslstl_unorderedmap</code>|Example 2</a>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="practical_requirements_on_hash"></a> <a class="anchor" id="description.practical_requirements_on_hash"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Practical Requirements on HASH: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An important factor in the performance an unordered multi-map (and any of the other unordered containers) is the choice of hash function. Please see the discussion in <a href="group__bslstl__unorderedmap.html#practical_requirements_on_hash" class="el"><code>bslstl_unorderedmap</code>|Practical Requirements on <code>HASH</code></a>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.8"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_creating_a_concordance"></a> <a class="anchor" id="usage.example_1~3A_creating_a_concordance"></a> <a class="anchor" id="description.usage.example_1~3A_creating_a_concordance"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.8.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating a Concordance: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Unordered multimap are useful in situations when there is no meaningful way to compare key values, when the order of the keys is irrelevant to the problem domain, or (even if there is a meaningful ordering) the benefit of ordering the results is outweighed by the higher performance provided by unordered maps (compared to ordered maps). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>One uses a multi-map (ordered or unordered) when there may be more than one mapped value associated with a key value. In this example we will use <code>bslstl_unorderedmultimap</code> to create a concordance (an index of where each unique word appears in the set of documents). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Our source of documents is a set of statically initialized arrays: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">char</span> document0[] =
  <span class="stringliteral">&quot; IN CONGRESS, July 4, 1776.\n&quot;</span>
  <span class="stringliteral">&quot;\n&quot;</span>
  <span class="stringliteral">&quot; The unanimous Declaration of the thirteen united States of America,\n&quot;</span>
  <span class="stringliteral">&quot;\n&quot;</span>
  <span class="stringliteral">&quot; When in the Course of human events, it becomes necessary for one\n&quot;</span>
  <span class="stringliteral">&quot; people to dissolve the political bands which have connected them with\n&quot;</span>
  <span class="stringliteral">&quot; another, and to assume among the powers of the earth, the separate\n&quot;</span>
  <span class="stringliteral">&quot; and equal station to which the Laws of Nature and of Nature&#39;s God\n&quot;</span>
  <span class="stringliteral">&quot; entitle them, a decent respect to the opinions of mankind requires\n&quot;</span>
  <span class="stringliteral">&quot; that they should declare the causes which impel them to the\n&quot;</span>
  <span class="stringliteral">&quot; separation.  We hold these truths to be self-evident, that all men\n&quot;</span>
  <span class="stringliteral">&quot; are created equal, that they are endowed by their Creator with\n&quot;</span>
  <span class="stringliteral">&quot; certain unalienable Rights, that among these are Life, Liberty and\n&quot;</span>
  <span class="stringliteral">&quot; the pursuit of Happiness.--That to secure these rights, Governments\n&quot;</span>
  <span class="stringliteral">&quot; are instituted among Men, deriving their just powers from the consent\n&quot;</span>
  <span class="stringliteral">&quot; of the governed, --That whenever any Form of Government becomes\n&quot;</span>
  ...
  <span class="stringliteral">&quot; States may of right do.  And for the support of this Declaration,\n&quot;</span>
  <span class="stringliteral">&quot; with a firm reliance on the protection of divine Providence, we\n&quot;</span>
  <span class="stringliteral">&quot; mutually pledge to each other our Lives, our Fortunes and our sacred\n&quot;</span>
  <span class="stringliteral">&quot; Honor.\n&quot;</span>;

  <span class="keyword">static</span> <span class="keywordtype">char</span> document1[] =
  <span class="stringliteral">&quot;/The Universal Declaration of Human Rights\n&quot;</span>
  <span class="stringliteral">&quot;/-----------------------------------------\n&quot;</span>
  <span class="stringliteral">&quot;/Preamble\n&quot;</span>
  <span class="stringliteral">&quot;/ - - - -\n&quot;</span>
  <span class="stringliteral">&quot; Whereas recognition of the inherent dignity and of the equal and\n&quot;</span>
  <span class="stringliteral">&quot; inalienable rights of all members of the human family is the\n&quot;</span>
  <span class="stringliteral">&quot; foundation of freedom, justice and peace in the world,\n&quot;</span>
  ...
  <span class="stringliteral">&quot;/Article 30\n&quot;</span>
  <span class="stringliteral">&quot;/ - - - - -\n&quot;</span>
  <span class="stringliteral">&quot; Nothing in this Declaration may be interpreted as implying for any\n&quot;</span>
  <span class="stringliteral">&quot; State, group or person any right to engage in any activity or to\n&quot;</span>
  <span class="stringliteral">&quot; perform any act aimed at the destruction of any of the rights and\n&quot;</span>
  <span class="stringliteral">&quot; freedoms set forth herein.\n&quot;</span>;

  <span class="keyword">static</span> <span class="keywordtype">char</span> document2[] =
  <span class="stringliteral">&quot;/CHARTER OF FUNDAMENTAL RIGHTS OF THE EUROPEAN UNION\n&quot;</span>
  <span class="stringliteral">&quot;/---------------------------------------------------\n&quot;</span>
  <span class="stringliteral">&quot; PREAMBLE\n&quot;</span>
  <span class="stringliteral">&quot;\n&quot;</span>
  <span class="stringliteral">&quot; The peoples of Europe, in creating an ever closer union among them,\n&quot;</span>
  <span class="stringliteral">&quot; are resolved to share a peaceful future based on common values.\n&quot;</span>
  ...
  <span class="stringliteral">&quot;/Article 54\n&quot;</span>
  <span class="stringliteral">&quot;/-  -  -  -\n&quot;</span>
  <span class="stringliteral">&quot; Prohibition of abuse of rights\n&quot;</span>
  <span class="stringliteral">&quot;\n&quot;</span>
  <span class="stringliteral">&quot; Nothing in this Charter shall be interpreted as implying any right to\n&quot;</span>
  <span class="stringliteral">&quot; engage in any activity or to perform any act aimed at the destruction\n&quot;</span>
  <span class="stringliteral">&quot; of any of the rights and freedoms recognized in this Charter or at\n&quot;</span>
  <span class="stringliteral">&quot; their limitation to a greater extent than is provided for herein.\n&quot;</span>;

  <span class="keyword">static</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> documents[]  = { document0,
                                       document1,
                                       document2
                                     };
  <span class="keyword">const</span> <span class="keywordtype">int</span>           numDocuments = <span class="keyword">sizeof</span> documents / <span class="keyword">sizeof</span> *documents;
</pre></div><br/>
<br/>
 First, we define several aliases to make our code more comprehensible. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1pair.html">bsl::pair&lt;int, int&gt;</a>                  WordLocation;
      <span class="comment">// Document code number (&#39;first&#39;) and word offset (&#39;second&#39;) in that</span>
      <span class="comment">// document specify a word location.  The first word in the document</span>
      <span class="comment">// is at word offset 0.</span>

  <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap&lt;bsl::string, WordLocation&gt;</a>
                                               Concordance;
  <span class="keyword">typedef</span> Concordance::const_iterator          ConcordanceConstItr;
</pre></div><br/>
<br/>
 Next, we create an (empty) unordered map to hold our word tallies. <br/>
<br/>
<div class="fragment"><pre class="fragment">  Concordance concordance;
</pre></div><br/>
<br/>
 Then, we define the set of characters that define word boundaries: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">char</span> *delimiters = <span class="stringliteral">&quot; \n\t,:;.()[]?!/&quot;</span>;
</pre></div><br/>
<br/>
 Next, we extract the words from our documents. Note that <code>strtok</code> modifies the document arrays (which were not made <code>const</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As each word is located, we create a map value -- a pair of the word converted to a <code>bsl::string</code> and a <code>WordLocation</code> object (itself a pair of document code and (word) offset of that word in the document) -- and insert the map value into the map. Note that (unlike maps and unordered maps) there is no status to check; the insertion succeeds even if the key is already present in the (multi) map. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idx = 0; idx &lt; numDocuments; ++idx) {
      <span class="keywordtype">int</span> wordOffset = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">char</span> *cur = strtok(documents[idx], delimiters);
                 cur;
                 cur = strtok(NULL,           delimiters)) {
          WordLocation            location(idx, wordOffset++);
          Concordance::value_type value(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>(cur), location);
          concordance.insert(value);
      }
  }
</pre></div><br/>
<br/>
 Then, we can readily print a complete concordance by iterating through the map. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (ConcordanceConstItr itr  = concordance.begin(),
                           end  = concordance.end();
                           end != itr; ++itr) {
      printf(<span class="stringliteral">&quot;\&quot;%s\&quot;, %2d, %4d\n&quot;</span>,
             itr-&gt;first.c_str(),
             itr-&gt;second.first,
             itr-&gt;second.second);
  }
</pre></div><br/>
<br/>
 Standard output shows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="stringliteral">&quot;extent&quot;</span>,  2, 3837
  <span class="stringliteral">&quot;greater&quot;</span>,  2, 3836
  <span class="stringliteral">&quot;abuse&quot;</span>,  2, 3791
  <span class="stringliteral">&quot;constitutions&quot;</span>,  2, 3782
  <span class="stringliteral">&quot;affecting&quot;</span>,  2, 3727
  ...
  <span class="stringliteral">&quot;he&quot;</span>,  1, 1746
  <span class="stringliteral">&quot;he&quot;</span>,  1,  714
  <span class="stringliteral">&quot;he&quot;</span>,  0,  401
  <span class="stringliteral">&quot;include&quot;</span>,  2,  847
</pre></div><br/>
<br/>
 Next, if there are some particular words of interest, we seek them out using the <code>equal_range</code> method of the <code>concordance</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> wordsOfInterest[] = { <span class="stringliteral">&quot;human&quot;</span>,
                                          <span class="stringliteral">&quot;rights&quot;</span>,
                                          <span class="stringliteral">&quot;unalienable&quot;</span>,
                                          <span class="stringliteral">&quot;inalienable&quot;</span>
                                        };
  <span class="keyword">const</span> <span class="keywordtype">int</span>   numWordsOfInterest = <span class="keyword">sizeof</span>  wordsOfInterest
                                 / <span class="keyword">sizeof</span> *wordsOfInterest;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idx = 0; idx &lt; numWordsOfInterest; ++idx) {
     <a class="code" href="classbsl_1_1pair.html">bsl::pair</a>&lt;ConcordanceConstItr,
               ConcordanceConstItr&gt; found = concordance.equal_range(
                                                       wordsOfInterest[idx]);
     <span class="keywordflow">for</span> (ConcordanceConstItr itr  = found.<a class="code" href="group__bslstl__pair.html#gafff8113b0b2f4bbe5df93ce0ba30fad8">first</a>,
                              end  = found.second;
                              end != itr; ++itr) {
         printf(<span class="stringliteral">&quot;\&quot;%s\&quot;, %2d, %4d\n&quot;</span>,
                itr-&gt;first.c_str(),
                itr-&gt;second.first,
                itr-&gt;second.second);
     }
     printf(<span class="stringliteral">&quot;\n&quot;</span>);
  }
</pre></div><br/>
<br/>
 Finally, we see on standard output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="stringliteral">&quot;human&quot;</span>,  2, 3492
  <span class="stringliteral">&quot;human&quot;</span>,  2, 2192
  <span class="stringliteral">&quot;human&quot;</span>,  2,  534
  ...
  <span class="stringliteral">&quot;human&quot;</span>,  1,   65
  <span class="stringliteral">&quot;human&quot;</span>,  1,   43
  <span class="stringliteral">&quot;human&quot;</span>,  1,   25
  <span class="stringliteral">&quot;human&quot;</span>,  0,   20

  <span class="stringliteral">&quot;rights&quot;</span>,  2, 3583
  <span class="stringliteral">&quot;rights&quot;</span>,  2, 3553
  <span class="stringliteral">&quot;rights&quot;</span>,  2, 3493
  ...
  <span class="stringliteral">&quot;rights&quot;</span>,  1,   44
  <span class="stringliteral">&quot;rights&quot;</span>,  1,   19
  <span class="stringliteral">&quot;rights&quot;</span>,  0,  496
  <span class="stringliteral">&quot;rights&quot;</span>,  0,  126

  <span class="stringliteral">&quot;unalienable&quot;</span>,  0,  109

  <span class="stringliteral">&quot;inalienable&quot;</span>,  1,   18
</pre></div><br/>
<br/>
 <a href="group__bslstl__unorderedmap.html#example_3" class="el"><code>bslstl_unorderedmap</code>|Example 3</a> shows how to use the concordance to create an inverse concordance, and how to use the inverse concordance to find the context (surrounding words) of a word of interest. </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga2f3c53d75684dcbbe20f3d1eb1372095"></a><!-- doxytag: member="bsl::unordered_multimap::key_type" ref="ga2f3c53d75684dcbbe20f3d1eb1372095" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KEY <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::key_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf6dad2c21aaf5f1df3ff251d3907bd5d"></a><!-- doxytag: member="bsl::unordered_multimap::mapped_type" ref="gaf6dad2c21aaf5f1df3ff251d3907bd5d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::mapped_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadefb4991e590eaa5f5b85ab53a69571f"></a><!-- doxytag: member="bsl::unordered_multimap::value_type" ref="gadefb4991e590eaa5f5b85ab53a69571f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;const KEY, VALUE&gt; <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga76f55c90b8798789c980d5a149f37602"></a><!-- doxytag: member="bsl::unordered_multimap::hasher" ref="ga76f55c90b8798789c980d5a149f37602" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HASH <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::hasher<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8f52aca7b7469f34641095f3f459b9a8"></a><!-- doxytag: member="bsl::unordered_multimap::key_equal" ref="ga8f52aca7b7469f34641095f3f459b9a8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef EQUAL <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::key_equal<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2f9fe7fe9790a29ea160fb0debbe5dc0"></a><!-- doxytag: member="bsl::unordered_multimap::allocator_type" ref="ga2f9fe7fe9790a29ea160fb0debbe5dc0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::allocator_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab6e7a120cd5af2267d60026f8fd3b58c"></a><!-- doxytag: member="bsl::unordered_multimap::reference" ref="gab6e7a120cd5af2267d60026f8fd3b58c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::reference <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae5669b2cd4f3b8579ea80b61e1c4809e"></a><!-- doxytag: member="bsl::unordered_multimap::const_reference" ref="gae5669b2cd4f3b8579ea80b61e1c4809e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::const_reference <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadfb9cea5ec4f52cd0831b29044081b87"></a><!-- doxytag: member="bsl::unordered_multimap::size_type" ref="gadfb9cea5ec4f52cd0831b29044081b87" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::size_type <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaca2d4c3d7a43743f32bb3ab4f4a94390"></a><!-- doxytag: member="bsl::unordered_multimap::difference_type" ref="gaca2d4c3d7a43743f32bb3ab4f4a94390" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::difference_type <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadd311f9d0e8afa7ef54648f40711a1cf"></a><!-- doxytag: member="bsl::unordered_multimap::pointer" ref="gadd311f9d0e8afa7ef54648f40711a1cf" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::pointer <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3177d291855e3b9bacc161b2f6fbceb1"></a><!-- doxytag: member="bsl::unordered_multimap::const_pointer" ref="ga3177d291855e3b9bacc161b2f6fbceb1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::const_pointer <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf9763e68018560210af8bde69cd7b5f4"></a><!-- doxytag: member="bsl::unordered_multimap::iterator" ref="gaf9763e68018560210af8bde69cd7b5f4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt;value_type, difference_type&gt; <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4c131b08f030f55fe54593330765c028"></a><!-- doxytag: member="bsl::unordered_multimap::const_iterator" ref="ga4c131b08f030f55fe54593330765c028" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt;const value_type, difference_type&gt; <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::const_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae813a58f8d7bd4c55e6a4598ac469eda"></a><!-- doxytag: member="bsl::unordered_multimap::local_iterator" ref="gae813a58f8d7bd4c55e6a4598ac469eda" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ::BloombergLP::bslstl::HashTableBucketIterator&lt;value_type, difference_type&gt; <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::local_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1fe450965cd2e865814f04f08e6d4d0e"></a><!-- doxytag: member="bsl::unordered_multimap::const_local_iterator" ref="ga1fe450965cd2e865814f04f08e6d4d0e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ::BloombergLP::bslstl::HashTableBucketIterator&lt;const value_type, difference_type&gt; <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::const_local_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaac682fd548c4d3c1008c47976ecff937"></a><!-- doxytag: member="bsl::unordered_multimap::BSLMF_NESTED_TRAIT_DECLARATION_IF" ref="gaac682fd548c4d3c1008c47976ecff937" args="(unordered_multimap,::BloombergLP::bslmf::IsBitwiseMoveable,::BloombergLP::bslmf::IsBitwiseMoveable&lt; Impl &gt;::value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::BSLMF_NESTED_TRAIT_DECLARATION_IF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::BloombergLP::bslmf::IsBitwiseMoveable&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::BloombergLP::bslmf::IsBitwiseMoveable&lt; Impl &gt;::value&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0410d6fde47718fa170251c7711b9944"></a><!-- doxytag: member="bsl::unordered_multimap::unordered_multimap" ref="ga0410d6fde47718fa170251c7711b9944" args="(size_type initialNumBuckets=0, const hasher &amp;hashFunction=hasher(), const key_equal &amp;keyEqual=key_equal(), const allocator_type &amp;basicAllocator=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultimap.html#gadfb9cea5ec4f52cd0831b29044081b87">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>initialNumBuckets</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultimap.html#ga76f55c90b8798789c980d5a149f37602">hasher</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hashFunction</em> = <code><a class="el" href="group__bslstl__unorderedmultimap.html#ga76f55c90b8798789c980d5a149f37602">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultimap.html#ga8f52aca7b7469f34641095f3f459b9a8">key_equal</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keyEqual</em> = <code><a class="el" href="group__bslstl__unorderedmultimap.html#ga8f52aca7b7469f34641095f3f459b9a8">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultimap.html#ga2f9fe7fe9790a29ea160fb0debbe5dc0">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code><a class="el" href="group__bslstl__unorderedmultimap.html#ga2f9fe7fe9790a29ea160fb0debbe5dc0">allocator_type</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an empty unordered multi map. Optionally specify an <code>initialNumBuckets</code> indicating the initial size of the array of buckets of this container. If <code>initialNumBuckets</code> is not supplied, an implementation defined value is used. Optionally specify a <code>hashFunction</code> used to generate the hash values associated to the key-value pairs contained in this object. If <code>hashFunction</code> is not supplied, a default-constructed object of type <code>hasher</code> is used. Optionally specify a key-equality functor <code>keyEqual</code> used to verify that two key values are the same. If <code>keyEqual</code> is not supplied, a default-constructed object of type <code>key_equal</code> is used. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>allocator_type</code> is used. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>basicAllocator</code> is not supplied, the currently installed default allocator is used to supply memory. </p>

</div>
</div>
<a class="anchor" id="ga231cca18f3ee4ce03f86270fd7cb74f7"></a><!-- doxytag: member="bsl::unordered_multimap::unordered_multimap" ref="ga231cca18f3ee4ce03f86270fd7cb74f7" args="(const allocator_type &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultimap.html#ga2f9fe7fe9790a29ea160fb0debbe5dc0">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an empty unordered multi map that uses the specified <code>basicAllocator</code> to supply memory. Use a default-constructed object of type <code>hasher</code> to generate hash values for the key-value pairs contained in this object. Also, use a default-constructed object of type <code>key_equal</code> to verify that two key values are the same. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. </p>

</div>
</div>
<a class="anchor" id="gaed509e1f519998a9f5001b48d4ef4299"></a><!-- doxytag: member="bsl::unordered_multimap::unordered_multimap" ref="gaed509e1f519998a9f5001b48d4ef4299" args="(const unordered_multimap &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9bd3ba348ca33cea4cc26b7c8a4be99f"></a><!-- doxytag: member="bsl::unordered_multimap::unordered_multimap" ref="ga9bd3ba348ca33cea4cc26b7c8a4be99f" args="(const unordered_multimap &amp;original, const allocator_type &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultimap.html#ga2f9fe7fe9790a29ea160fb0debbe5dc0">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an unordered multi map having the same value as that of the specified <code>original</code>. Use a default-constructed object of type <code>hasher</code> to generate hash values for the key-value pairs contained in this object. Also, use a default-constructed object of type <code>key_equal</code> to verify that two key values are the same. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not supplied, a default-constructed object of type <code>allocator_type</code> is used. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. </p>

</div>
</div>
<a class="anchor" id="gacd49cdf1779134ed5a1af58d68cb6132"></a><!-- doxytag: member="bsl::unordered_multimap::unordered_multimap" ref="gacd49cdf1779134ed5a1af58d68cb6132" args="(INPUT_ITERATOR first, INPUT_ITERATOR last, size_type initialNumBuckets=0, const hasher &amp;hashFunction=hasher(), const key_equal &amp;keyEqual=key_equal(), const allocator_type &amp;basicAllocator=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultimap.html#gadfb9cea5ec4f52cd0831b29044081b87">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>initialNumBuckets</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultimap.html#ga76f55c90b8798789c980d5a149f37602">hasher</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hashFunction</em> = <code><a class="el" href="group__bslstl__unorderedmultimap.html#ga76f55c90b8798789c980d5a149f37602">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultimap.html#ga8f52aca7b7469f34641095f3f459b9a8">key_equal</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keyEqual</em> = <code><a class="el" href="group__bslstl__unorderedmultimap.html#ga8f52aca7b7469f34641095f3f459b9a8">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultimap.html#ga2f9fe7fe9790a29ea160fb0debbe5dc0">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code><a class="el" href="group__bslstl__unorderedmultimap.html#ga2f9fe7fe9790a29ea160fb0debbe5dc0">allocator_type</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an empty unordered multi map and insert each <code>value_type</code> object in the sequence starting at the specified <code>first</code> element, and ending immediately before the specified <code>last</code> element. Optionally specify an <code>initialNumBuckets</code> indicating the initial size of the array of buckets of this container. If <code>initialNumBuckets</code> is not supplied, an implementation defined value is used. Optionally specify a <code>hashFunction</code> used to generate hash values for the key-value pairs contained in this object. If <code>hashFunction</code> is not supplied, a default-constructed object of type <code>hasher</code> is used. Optionally specify a key-equality functor <code>keyEqual</code> used to verify that two key values are the same. If <code>keyEqual</code> is not supplied, a default-constructed object of type <code>key_equal</code> is used. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>allocator_type</code> is used. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>basicAllocator</code> is not supplied, the currently installed default allocator is used to supply memory. The (template parameter) type <code>INPUT_ITERATOR</code> shall meet the requirements of an input iterator defined in the C++11 standard [24.2.3] providing access to values of a type convertible to <code>value_type</code>. The behavior is undefined unless <code>first</code> and <code>last</code> refer to a sequence of valid values where <code>first</code> is at a position at or before <code>last</code>. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__unorderedmultimap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__unorderedmultimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaf6caf74f21786fbf5d03f4a3d1d2def2"></a><!-- doxytag: member="bsl::unordered_multimap::~unordered_multimap" ref="gaf6caf74f21786fbf5d03f4a3d1d2def2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::~unordered_multimap </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga135e7248c988f4402f005238ee177807"></a><!-- doxytag: member="bsl::unordered_multimap::operator=" ref="ga135e7248c988f4402f005238ee177807" args="(const unordered_multimap &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unordered_multimap&amp; <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value, hasher, and key-equality functor of the specified <code>rhs</code> object, propagate to this object the allocator of <code>rhs</code> if the <code>ALLOCATOR</code> type has trait <code>propagate_on_container_copy_assignment</code>, and return a reference providing modifiable access to this object. Note that this method requires that the (template parameter types) <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__unorderedmultimap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__unorderedmultimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gab74233fc1e63af8a6239d11cf5358b09"></a><!-- doxytag: member="bsl::unordered_multimap::begin" ref="gab74233fc1e63af8a6239d11cf5358b09" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first <code>value_type</code> object (in the sequence of <code>value_type</code> objects) maintained by this multi-map, or the <code>end</code> iterator if this multi-map is empty. </p>

</div>
</div>
<a class="anchor" id="gaf9e1d466f0dc443794f725edcec940e1"></a><!-- doxytag: member="bsl::unordered_multimap::end" ref="gaf9e1d466f0dc443794f725edcec940e1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the past-the-end element in the sequence of <code>value_type</code> objects maintained by this unordered multi map. </p>

</div>
</div>
<a class="anchor" id="ga8e748b022792a1de33d1716612366b84"></a><!-- doxytag: member="bsl::unordered_multimap::begin" ref="ga8e748b022792a1de33d1716612366b84" args="(size_type index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">local_iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultimap.html#gadfb9cea5ec4f52cd0831b29044081b87">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a local iterator providing modifiable access to the first <code>value_type</code> object in the sequence of <code>value_type</code> objects of the bucket having the specified <code>index</code>, in the array of buckets maintained by this multi-map, or the <code>end(index)</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga3bd74d50836fe749d5faa4a998a0bf02"></a><!-- doxytag: member="bsl::unordered_multimap::end" ref="ga3bd74d50836fe749d5faa4a998a0bf02" args="(size_type index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">local_iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultimap.html#gadfb9cea5ec4f52cd0831b29044081b87">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a local iterator providing modifiable access to the past-the-end element in the sequence of <code>value_type</code> objects of the bucket having the specified <code>index</code>s, in the array of buckets maintained by this multi-map. </p>

</div>
</div>
<a class="anchor" id="gaf477dd97f3d770b873117db2a5b66cff"></a><!-- doxytag: member="bsl::unordered_multimap::insert" ref="gaf477dd97f3d770b873117db2a5b66cff" args="(const SOURCE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class SOURCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const SOURCE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this multi-map, and return an iterator to the newly inserted element. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> types both be <a href="group__bslstl__unorderedmultimap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__unorderedmultimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). Also note that this one template stands in for two <code>insert</code> functions in the C++11 standard. </p>

</div>
</div>
<a class="anchor" id="ga1887c0e3041ebc64a3ffcdee5ecbaf34"></a><!-- doxytag: member="bsl::unordered_multimap::insert" ref="ga1887c0e3041ebc64a3ffcdee5ecbaf34" args="(const_iterator hint, const SOURCE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class SOURCE_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SOURCE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this multi-map (in constant time if the specified <code>hint</code> is a valid element in the bucket to which <code>value</code> belongs). Return an iterator referring to the newly inserted <code>value_type</code> object in this multi-map whose key is the same as that of <code>value</code>. If <code>hint</code> is not a position in the bucket of the key of <code>value</code>, this operation has worst case <code>O[N]</code> and average case constant-time complexity, where <code>N</code> is the size of this multi-map. The behavior is undefined unless <code>hint</code> is a valid iterator into this unordered multi map. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__unorderedmultimap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__unorderedmultimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). Also note that this one template stands in for two <code>insert</code> functions in the C++11 standard. </p>

</div>
</div>
<a class="anchor" id="ga120ccac5426c74bf808986b21347fb56"></a><!-- doxytag: member="bsl::unordered_multimap::insert" ref="ga120ccac5426c74bf808986b21347fb56" args="(INPUT_ITERATOR first, INPUT_ITERATOR last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert into this multi-map the value of each <code>value_type</code> object in the range starting at the specified <code>first</code> iterator and ending immediately before the specified <code>last</code> iterator. The (template parameter) type <code>INPUT_ITERATOR</code> shall meet the requirements of an input iterator defined in the C++11 standard [24.2.3] providing access to values of a type convertible to <code>value_type</code>. The behavior is undefined unless <code>first</code> and <code>last</code> refer to a sequence of valid values where <code>first</code> is at a position at or before <code>last</code>. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__unorderedmultimap.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__unorderedmultimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga8b267bf512957aef7ad57f869f64d7d3"></a><!-- doxytag: member="bsl::unordered_multimap::erase" ref="ga8b267bf512957aef7ad57f869f64d7d3" args="(const_iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this multi-map the <code>value_type</code> object at the specified <code>position</code>, and return an iterator referring to the element immediately following the removed element, or to the past-the-end position if the removed element was the last element in the sequence of elements maintained by this container. The behavior is undefined unless <code>position</code> refers to a <code>value_type</code> object in this multi-map. </p>

</div>
</div>
<a class="anchor" id="gaffdc9a47f3d83745061034e9870cf92b"></a><!-- doxytag: member="bsl::unordered_multimap::erase" ref="gaffdc9a47f3d83745061034e9870cf92b" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultimap.html#ga2f3c53d75684dcbbe20f3d1eb1372095">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this container all objects whose keys match the specified <code>key</code>, and return the number of objects deleted. If there is no object matching <code>key</code>, return 0 with no other effect. </p>

</div>
</div>
<a class="anchor" id="ga86f8798cd7f9fe34d833ad5dbd7e7559"></a><!-- doxytag: member="bsl::unordered_multimap::erase" ref="ga86f8798cd7f9fe34d833ad5dbd7e7559" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this container the objects starting at the specified <code>first</code> position up to, but not including the specified <code>last</code> position, and return <code>last</code>. The behavior is undefined unless <code>first</code> and <code>last</code> either refer to elements in this container or are the <code>end</code> iterator, and the <code>first</code> position is at or before the <code>last</code> position in the ordered sequence provided by this container. </p>

</div>
</div>
<a class="anchor" id="gabd70b6e1e90e6ce2f4342a015b247e28"></a><!-- doxytag: member="bsl::unordered_multimap::clear" ref="gabd70b6e1e90e6ce2f4342a015b247e28" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all entries from this container. Note that the container is empty after this call, but allocated memory may be retained for future use. </p>

</div>
</div>
<a class="anchor" id="gaf662a1f8e82651f2a68ce41b1c8b3e60"></a><!-- doxytag: member="bsl::unordered_multimap::find" ref="gaf662a1f8e82651f2a68ce41b1c8b3e60" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultimap.html#ga2f3c53d75684dcbbe20f3d1eb1372095">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first <code>value_type</code> object in the sequence of all the <code>value_type</code> objects of this container matching the specified <code>key</code>, if they exist, and the past-the-end (<code>end</code>) iterator otherwise. </p>

</div>
</div>
<a class="anchor" id="ga83a7c4bcbb52b46a93ead7b880479182"></a><!-- doxytag: member="bsl::unordered_multimap::equal_range" ref="ga83a7c4bcbb52b46a93ead7b880479182" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;iterator, iterator&gt; <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultimap.html#ga2f3c53d75684dcbbe20f3d1eb1372095">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pair of iterators providing modifiable access to the sequence of <code>value_type</code> objects in this multi-map matching the specified <code>key</code>, where the the first iterator is positioned at the start of the sequence, and the second is positioned one past the end of the sequence. If this unordered multi map contains no <code>value_type</code> objects matching <code>key</code>, then the two returned iterators will have the same value. </p>

</div>
</div>
<a class="anchor" id="ga9b654ec0beee8b2ab35657c74fc97bd8"></a><!-- doxytag: member="bsl::unordered_multimap::max_load_factor" ref="ga9b654ec0beee8b2ab35657c74fc97bd8" args="(float newLoadFactor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>newLoadFactor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the maximum load factor of this container to the specified <code>newLoadFactor</code>. This operation will not do an immediate rehash of the container, if that is wanted, it is recommended that this call be followed by a call to <code>reserve</code>. </p>

</div>
</div>
<a class="anchor" id="gae3efac9ac142db3573906e912a93f4d4"></a><!-- doxytag: member="bsl::unordered_multimap::rehash" ref="gae3efac9ac142db3573906e912a93f4d4" args="(size_type numBuckets)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultimap.html#gadfb9cea5ec4f52cd0831b29044081b87">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numBuckets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the size of the array of buckets maintained by this container to the specified <code>numBuckets</code>, and redistribute all the contained elements into the new sequence of buckets, according to their hash values. Note that this operation has no effect if rehashing the elements into <code>numBuckets</code> would cause this multi-map to exceed its <code>max_load_factor</code>. </p>

</div>
</div>
<a class="anchor" id="ga4607cccd679a179177a3a3059f2c164a"></a><!-- doxytag: member="bsl::unordered_multimap::reserve" ref="ga4607cccd679a179177a3a3059f2c164a" args="(size_type numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultimap.html#gadfb9cea5ec4f52cd0831b29044081b87">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increase the number of buckets of this set to a quantity such that the ratio between the specified <code>numElements</code> and this quantity does not exceed <code>max_load_factor</code>. Note that this guarantees that, after the reserve, elements can be inserted to grow the container to <code><a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a> == numElements</code> without rehashing. Also note that memory allocations may still occur when growing the container to <code><a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a> == numElements</code>. Also note that this operation has no effect if <code>numElements &lt;= <a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a></code>. </p>

</div>
</div>
<a class="anchor" id="gae7adb7981d2b8ef8511ac105d6132a29"></a><!-- doxytag: member="bsl::unordered_multimap::swap" ref="gae7adb7981d2b8ef8511ac105d6132a29" args="(unordered_multimap &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this object as well as its hasher and key-equality functor with those of the specified <code>other</code> object. Additionally, if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code>, then exchange the allocator of this object with that of the <code>other</code> object, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee and guarantees <code>O[1]</code> complexity. The behavior is undefined unless either this object was created with the same allocator as <code>other</code> or <code>propagate_on_container_swap</code> is <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="gaf0e5cbd3ef44c21c7f6bf5e224a385d8"></a><!-- doxytag: member="bsl::unordered_multimap::get_allocator" ref="gaf0e5cbd3ef44c21c7f6bf5e224a385d8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return (a copy of) the allocator used for memory allocation by this multi-map. </p>

</div>
</div>
<a class="anchor" id="gafeddcaf9562ba0f973de55418def6295"></a><!-- doxytag: member="bsl::unordered_multimap::begin" ref="gafeddcaf9562ba0f973de55418def6295" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3b380567f2346058666ecf8c7b83cdc9"></a><!-- doxytag: member="bsl::unordered_multimap::cbegin" ref="ga3b380567f2346058666ecf8c7b83cdc9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> object (in the sequence of <code>value_type</code> objects) maintained by this multi-map, or the <code>end</code> iterator if this multi-map is empty. </p>

</div>
</div>
<a class="anchor" id="ga2c4698aca5fde8b31514863defb05a1d"></a><!-- doxytag: member="bsl::unordered_multimap::end" ref="ga2c4698aca5fde8b31514863defb05a1d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga070ba9c33597017c6f43734a051caf28"></a><!-- doxytag: member="bsl::unordered_multimap::cend" ref="ga070ba9c33597017c6f43734a051caf28" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the past-the-end element (in the sequence of <code>value_type</code> objects) maintained by this multi-map. </p>

</div>
</div>
<a class="anchor" id="gaee79838527b2f66cf886b440d22f9129"></a><!-- doxytag: member="bsl::unordered_multimap::begin" ref="gaee79838527b2f66cf886b440d22f9129" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_local_iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultimap.html#gadfb9cea5ec4f52cd0831b29044081b87">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga528eb49256242b3ed01bafc99c55491c"></a><!-- doxytag: member="bsl::unordered_multimap::cbegin" ref="ga528eb49256242b3ed01bafc99c55491c" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_local_iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultimap.html#gadfb9cea5ec4f52cd0831b29044081b87">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a local iterator providing non-modifiable access to the first <code>value_type</code> object (in the sequence of <code>value_type</code> objects) of the bucket having the specified <code>index</code> in the array of buckets maintained by this container, or the <code>end(index)</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga017c70e88e46f791239358d73713b5f3"></a><!-- doxytag: member="bsl::unordered_multimap::end" ref="ga017c70e88e46f791239358d73713b5f3" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_local_iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultimap.html#gadfb9cea5ec4f52cd0831b29044081b87">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6be11681ad474d95be94ef5e1c658241"></a><!-- doxytag: member="bsl::unordered_multimap::cend" ref="ga6be11681ad474d95be94ef5e1c658241" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_local_iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultimap.html#gadfb9cea5ec4f52cd0831b29044081b87">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a local iterator providing non-modifiable access to the past-the-end element (in the sequence of <code>value_type</code> objects) of the bucket having the specified <code>index</code> in the array of buckets maintained by this container. </p>

</div>
</div>
<a class="anchor" id="ga44ee843e49906d46474eb2717809983d"></a><!-- doxytag: member="bsl::unordered_multimap::bucket" ref="ga44ee843e49906d46474eb2717809983d" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::bucket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultimap.html#ga2f3c53d75684dcbbe20f3d1eb1372095">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the bucket, in the array of buckets of this container, where values matching the specified <code>key</code> would be inserted. </p>

</div>
</div>
<a class="anchor" id="ga466816021ed02f5acde57e4a59df1778"></a><!-- doxytag: member="bsl::unordered_multimap::bucket_count" ref="ga466816021ed02f5acde57e4a59df1778" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of buckets in the array of buckets maintained by this container. </p>

</div>
</div>
<a class="anchor" id="ga03fab7253da748c06d6c762397b23daf"></a><!-- doxytag: member="bsl::unordered_multimap::max_bucket_count" ref="ga03fab7253da748c06d6c762397b23daf" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a theoretical upper bound on the largest number of buckets that this container could possibly manage. Note that there is no guarantee that the container can successfully grow to the returned size, or even close to that size without running out of resources. </p>

</div>
</div>
<a class="anchor" id="gabb1edc6003e4401dd92a81a92313c933"></a><!-- doxytag: member="bsl::unordered_multimap::bucket_size" ref="gabb1edc6003e4401dd92a81a92313c933" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::bucket_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultimap.html#gadfb9cea5ec4f52cd0831b29044081b87">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements contained in the bucket at the specified <code>index</code> in the array of buckets maintained by this container. </p>

</div>
</div>
<a class="anchor" id="ga85711e390197559118773821479f95ff"></a><!-- doxytag: member="bsl::unordered_multimap::count" ref="ga85711e390197559118773821479f95ff" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultimap.html#ga2f3c53d75684dcbbe20f3d1eb1372095">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of <code>value_type</code> objects within this container matching the specified <code>key</code>. </p>

</div>
</div>
<a class="anchor" id="ga40167f0c6140684e6e5a063316e8365b"></a><!-- doxytag: member="bsl::unordered_multimap::empty" ref="ga40167f0c6140684e6e5a063316e8365b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this container contains no elements, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gacee76407a5961ea64a9ac4544952004e"></a><!-- doxytag: member="bsl::unordered_multimap::equal_range" ref="gacee76407a5961ea64a9ac4544952004e" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;const_iterator, const_iterator&gt; <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultimap.html#ga2f3c53d75684dcbbe20f3d1eb1372095">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pair of iterators providing non-modifiable access to the sequence of <code>value_type</code> objects in this container matching the specified <code>key</code>, where the the first iterator is positioned at the start of the sequence and the second iterator is positioned one past the end of the sequence. If this container contains no <code>value_type</code> objects matching <code>key</code>, then the two returned iterators will have the same value. </p>

</div>
</div>
<a class="anchor" id="gae6cf31b1f3b50535c0ca83657ea58ac8"></a><!-- doxytag: member="bsl::unordered_multimap::find" ref="gae6cf31b1f3b50535c0ca83657ea58ac8" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultimap.html#ga2f3c53d75684dcbbe20f3d1eb1372095">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> object in the sequence of all the <code>value_type</code> objects of this container matching the specified <code>key</code>, if they exist, and the past-the-end (<code>end</code>) iterator otherwise. If multiple elements match <code>key</code>, they are guaranteed to be adjacent to each other, and this function will return the first in the sequence. </p>

</div>
</div>
<a class="anchor" id="ga1e3d95a4e06eb7a794b24fa9e64a276d"></a><!-- doxytag: member="bsl::unordered_multimap::hash_function" ref="ga1e3d95a4e06eb7a794b24fa9e64a276d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hasher <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return (a copy of) the hash unary functor used by this container to generate a hash value (of type <code>size_t</code>) for a <code>key_type</code> object. </p>

</div>
</div>
<a class="anchor" id="gad99d107d54bcb8acd41d1982947b16dc"></a><!-- doxytag: member="bsl::unordered_multimap::key_eq" ref="gad99d107d54bcb8acd41d1982947b16dc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">key_equal <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return (a copy of) the key-equality binary functor that returns <code>true</code> if the value of two <code>key_type</code> objects is the same, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gafe982e3830612c4a120f799dfcaeb5d6"></a><!-- doxytag: member="bsl::unordered_multimap::load_factor" ref="gafe982e3830612c4a120f799dfcaeb5d6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current ratio between the <code>size</code> of this container and the number of buckets. The <code>load_factor</code> is a measure of how full the container is, and a higher load factor leads to an increased number of collisions, thus resulting in a loss performance. </p>

</div>
</div>
<a class="anchor" id="gab59777efb76a1f55aa8df96ea1d4db39"></a><!-- doxytag: member="bsl::unordered_multimap::max_load_factor" ref="gab59777efb76a1f55aa8df96ea1d4db39" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum load factor allowed for this container. If an insert operation would cause <code>load_factor</code> to exceed the <code>max_load_factor</code>, that same insert operation will increase the number of buckets and rehash the elements of the container into those buckets the (see rehash). Note that it is possible for the load factor of this container to exceed <code>max_load_factor</code>, especially after <code>max_load_factor(newLoadFactor)</code> is called. </p>

</div>
</div>
<a class="anchor" id="ga8b0375724c5aa5bcdc47568eef8b89b0"></a><!-- doxytag: member="bsl::unordered_multimap::max_size" ref="ga8b0375724c5aa5bcdc47568eef8b89b0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a theoretical upper bound on the largest number of elements that this container could possibly hold. Note that there is no guarantee that the container can successfully grow to the returned size, or even close to that size without running out of resources. </p>

</div>
</div>
<a class="anchor" id="ga46765dd973cab0ed6fa55e5a018fd02d"></a><!-- doxytag: member="bsl::unordered_multimap::size" ref="ga46765dd973cab0ed6fa55e5a018fd02d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multimap.html">bsl::unordered_multimap</a>&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements in this container. </p>

</div>
</div>
<a class="anchor" id="ga601a88fd6f232d89827226c779166c7c"></a><!-- doxytag: member="bsl::operator==" ref="ga601a88fd6f232d89827226c779166c7c" args="(const unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> objects have the same value if they have the same number of key-value pairs, and for each key-value pair that is contained in <code>lhs</code> there is a pair value-key contained in <code>rhs</code> having the same value, and vice-versa. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__unorderedmultimap.html#requirements_on_key_and_value.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__unorderedmultimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gace2f15b7cbef1336dd4dd63794e3f1dd"></a><!-- doxytag: member="bsl::operator!=" ref="gace2f15b7cbef1336dd4dd63794e3f1dd" args="(const unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a></code> objects do not have the same value if they do not have the same number of key-value pairs, or that for some key-value pair that is contained in <code>lhs</code> there is not a key-value pair in <code>rhs</code> having the same value, and vice-versa. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__unorderedmultimap.html#requirements_on_key_and_value.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__unorderedmultimap.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga390f9783cd0c4c7c8be26e37b2b052c6"></a><!-- doxytag: member="bsl::swap" ref="ga390f9783cd0c4c7c8be26e37b2b052c6" args="(unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;a, unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class HASH , class EQUAL , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_multimap&lt; KEY, VALUE, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap both the value and the comparator of the specified <code>a</code> object with the value and comparator of the specified <code>b</code> object. Additionally, if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code>, then exchange the allocator of <code>a</code> with that of <code>b</code>, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee and guarantees <code>O[1]</code> complexity. The behavior is undefined unless either this object was created with the same allocator as <code>other</code> or <code>propagate_on_container_swap</code> is <code>true</code>. </p>

</div>
</div>
<hr/><h2>Friends</h2>
<a class="anchor" id="ga866533046724d6161b716f56f7108c86"></a><!-- doxytag: member="bsl::unordered_multimap::operator==" ref="ga866533046724d6161b716f56f7108c86" args="(const unordered_multimap&lt; KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;, const unordered_multimap&lt; KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class KEY2 , class VALUE2 , class HASH2 , class EQUAL2 , class ALLOCATOR2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__multimap.html">unordered_multimap</a>&lt; KEY2, VALUE2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:10 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
