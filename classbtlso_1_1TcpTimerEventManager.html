<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlso::TcpTimerEventManager</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlso.html">btlso</a>      </li>
      <li><a class="el" href="classbtlso_1_1TcpTimerEventManager.html">btlso::TcpTimerEventManager</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlso::TcpTimerEventManager Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlso::TcpTimerEventManager" --><!-- doxytag: inherits="btlso::TimerEventManager" -->
<p><code>#include &lt;<a class="el" href="btlso__tcptimereventmanager_8h_source.html">btlso_tcptimereventmanager.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlso::TcpTimerEventManager:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlso_1_1TcpTimerEventManager.png" usemap="#btlso::TcpTimerEventManager_map" alt=""/>
  <map id="btlso::TcpTimerEventManager_map" name="btlso::TcpTimerEventManager_map">
<area href="classbtlso_1_1TimerEventManager.html" alt="btlso::TimerEventManager" shape="rect" coords="0,0,179,24"/>
</map>
</div>

<p><a href="classbtlso_1_1TcpTimerEventManager-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a5f18754df0ff6cb6af8302df3245a2cf">Hint</a> { <a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a5f18754df0ff6cb6af8302df3245a2cfa273adf2dc9600facb7287fc21006cd7e">e_NO_HINT</a>, 
<a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a5f18754df0ff6cb6af8302df3245a2cfaf94fa267f4b3b3062d9774d58ecffece">e_INFREQUENT_REGISTRATION</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void()&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">Callback</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#aeb8f05155a2c221b79dbe85b23ef13c4">TcpTimerEventManager</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#aee8b7e72b0bdf88c3f10add28e7deb36">TcpTimerEventManager</a> (<a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a5f18754df0ff6cb6af8302df3245a2cf">Hint</a> hint, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a084c45dce8cb51964a74ee02fa9ce872">TcpTimerEventManager</a> (<a class="el" href="classbtlso_1_1EventManager.html">EventManager</a> *manager, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#ac88dbded9f4bff3bf38d831f4e897ba1">~TcpTimerEventManager</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a9409088774d044ab30e5bf3d82f78950">dispatch</a> (int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#af90c9e1cb7b4ed18d5c8064d679472fb">registerSocketEvent</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;handle, <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a> event, const <a class="el" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">Callback</a> &amp;callBack)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a18f42abe47d1ebef067878e42a8c732c">registerTimer</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, const <a class="el" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">Callback</a> &amp;callBack)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a54d4776a9de5c416e9975a19a4ca89a4">rescheduleTimer</a> (const void *timerId, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;expiryTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a4164692c244cb7fa467ada382de04b3c">deregisterSocketEvent</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;handle, <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a> event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a72430631bb41c7864538673218ee5b71">deregisterSocket</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a5f59d3dfae0851ca96acdd570505d622">deregisterAllSocketEvents</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a6f1ccee9fcbefa465395a70a915a4b75">deregisterTimer</a> (const void *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a0938fae002e17023ce1a158e0262a485">deregisterAllTimers</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a2e7ab490a6bc1cab6531e4ac5a7a5231">deregisterAll</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtlso_1_1TimeMetrics.html">TimeMetrics</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a04330208d7456fcc0138dc116246eca1">timeMetrics</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a13bc5fcc10efb8ae65b35b4c71f8ddd8">hasLimitedSocketCapacity</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a7cc87761071f6760ba0c79b0d8360331">isRegistered</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;handle, <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a> eventType) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a30d076b1f20a4bc0edff58f44221345c">numEvents</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a6729d6cbbdeaa5c949783caf4c6d45ef">numTimers</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a93becc7346547b45655c21da5f503f19">numSocketEvents</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;handle) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbtlso_1_1EventManager.html">EventManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#ab46ef9f5c435bb91541da9af95c3ffd1">socketEventManager</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides a concrete implementation of a timer event manager for sockets. The supported event types for sockets are ACCEPT, CONNECT, READ, and WRITE, and only READ and WRITE can be registered simultaneously on a single socket. Timers are stable (i.e., the relative order of registrations is maintained). A (registered) callback can only be invoked from the <code>dispatch</code> method. The performance of <code>dispatch</code> can be optimized based on user hints. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a721dbe10938308965a8a70b1430029af"></a><!-- doxytag: member="btlso::TcpTimerEventManager::Callback" ref="a721dbe10938308965a8a70b1430029af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void()&gt; <a class="el" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">btlso::TimerEventManager::Callback</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a5f18754df0ff6cb6af8302df3245a2cf"></a><!-- doxytag: member="btlso::TcpTimerEventManager::Hint" ref="a5f18754df0ff6cb6af8302df3245a2cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a5f18754df0ff6cb6af8302df3245a2cf">btlso::TcpTimerEventManager::Hint</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a5f18754df0ff6cb6af8302df3245a2cfa273adf2dc9600facb7287fc21006cd7e"></a><!-- doxytag: member="e_NO_HINT" ref="a5f18754df0ff6cb6af8302df3245a2cfa273adf2dc9600facb7287fc21006cd7e" args="" -->e_NO_HINT</em>&nbsp;</td><td>
<p>the registrations may be frequent </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5f18754df0ff6cb6af8302df3245a2cfaf94fa267f4b3b3062d9774d58ecffece"></a><!-- doxytag: member="e_INFREQUENT_REGISTRATION" ref="a5f18754df0ff6cb6af8302df3245a2cfaf94fa267f4b3b3062d9774d58ecffece" args="" -->e_INFREQUENT_REGISTRATION</em>&nbsp;</td><td>
<p>the (de)registrations will be infrequent </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aeb8f05155a2c221b79dbe85b23ef13c4"></a><!-- doxytag: member="btlso::TcpTimerEventManager::TcpTimerEventManager" ref="aeb8f05155a2c221b79dbe85b23ef13c4" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlso::TcpTimerEventManager::TcpTimerEventManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an event manager with timer support optimized for frequent registrations (<code>e_NO_HINT</code>). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="aee8b7e72b0bdf88c3f10add28e7deb36"></a><!-- doxytag: member="btlso::TcpTimerEventManager::TcpTimerEventManager" ref="aee8b7e72b0bdf88c3f10add28e7deb36" args="(Hint hint, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlso::TcpTimerEventManager::TcpTimerEventManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a5f18754df0ff6cb6af8302df3245a2cf">Hint</a>&nbsp;</td>
          <td class="paramname"> <em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an event manager with timer support optimized for the registration frequency as hinted by <code>hint</code>. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a084c45dce8cb51964a74ee02fa9ce872"></a><!-- doxytag: member="btlso::TcpTimerEventManager::TcpTimerEventManager" ref="a084c45dce8cb51964a74ee02fa9ce872" args="(EventManager *manager, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlso::TcpTimerEventManager::TcpTimerEventManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1EventManager.html">EventManager</a> *&nbsp;</td>
          <td class="paramname"> <em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a timer event manager that uses the specified <code>manager</code> for monitoring socket events. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>manager</code> is not 0. Note that <code>manager</code> must remain valid (i.e., not destroyed) for the lifetime of this (newly-created) timer event manager and when this object is destroyed the object addressed by <code>manager</code> is not destroyed. </p>

</div>
</div>
<a class="anchor" id="ac88dbded9f4bff3bf38d831f4e897ba1"></a><!-- doxytag: member="btlso::TcpTimerEventManager::~TcpTimerEventManager" ref="ac88dbded9f4bff3bf38d831f4e897ba1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlso::TcpTimerEventManager::~TcpTimerEventManager </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this event manager without invoking registered callbacks. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9409088774d044ab30e5bf3d82f78950"></a><!-- doxytag: member="btlso::TcpTimerEventManager::dispatch" ref="a9409088774d044ab30e5bf3d82f78950" args="(int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlso::TcpTimerEventManager::dispatch </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each socket event pending on this event manager, and for each expired timer , invoke the corresponding callback registered with this timer event manager. If no event is pending, wait until either (1) at least one event occurs (in which case the corresponding callback(s) is invoked), (2) a timer expires or (3) provided that the specified <code>flags</code> contains <code>bteso_Flag::k_ASYNC_INTERRUPT</code>, an underlying system call is interrupted by a signal. If no socket and no timer is registered with this event manager, this call will return (with 0) immediately. Return the number of dispatched callbacks on success, and a negative value otherwise; -1 is reserved to indicate that an underlying system call was interrupted. When such an interruption occurs this method will return -1 if <code>flags</code> contains <code>bteso_Flag::k_ASYNC_INTERRUPT</code> and otherwise will automatically restart (i.e., reissue the identical system call). Note that the order of invocation, relative to the order of registration, is unspecified and that -1 is never returned if <code>flags</code> does not contain <code>bteso_Flag::k_ASYNC_INTERRUPT</code>. Calling this method from a callback invoked through this method will result in undefined behavior. </p>

</div>
</div>
<a class="anchor" id="af90c9e1cb7b4ed18d5c8064d679472fb"></a><!-- doxytag: member="btlso::TcpTimerEventManager::registerSocketEvent" ref="af90c9e1cb7b4ed18d5c8064d679472fb" args="(const SocketHandle::Handle &amp;handle, EventType::Type event, const Callback &amp;callBack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlso::TcpTimerEventManager::registerSocketEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a>&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">Callback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callBack</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register with this event manager the specified <code>cb</code> functor to be invoked whenever the specified <code>event</code> occurs on the socket specified by <code>handle</code>. Return 0 on success and a negative number on error. No two different socket events can have callbacks registered with the same socket handle other than read and write. Any invocation of this method that would cause this to occur will result in an error and the callback will not be registered. The callback is recurring (i.e., it remains registered until it is explicitly deregistered). </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#aaf9e2a2c3cbe722101a53d20b3621bae">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a18f42abe47d1ebef067878e42a8c732c"></a><!-- doxytag: member="btlso::TcpTimerEventManager::registerTimer" ref="a18f42abe47d1ebef067878e42a8c732c" args="(const bsls::TimeInterval &amp;timeout, const Callback &amp;callBack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* btlso::TcpTimerEventManager::registerTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">Callback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callBack</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register with this event manager the specified <code>cb</code> functor to be invoked when the absolute time of the specified <code>timeout</code> is reached or exceeded. Return a timer handle which can be used to deregister this timer before expiration. Note that specifying a <code>timeout</code> prior to the current time will result in the associated <code>cb</code> being executed on the next invocation of <code>dispatch</code>. Note also that the callback is not recurring (i.e., after being invoked it is deregistered automatically). </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#a069d2261a617c5158ff70f298687b1df">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a54d4776a9de5c416e9975a19a4ca89a4"></a><!-- doxytag: member="btlso::TcpTimerEventManager::rescheduleTimer" ref="a54d4776a9de5c416e9975a19a4ca89a4" args="(const void *timerId, const bsls::TimeInterval &amp;expiryTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlso::TcpTimerEventManager::rescheduleTimer </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>timerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expiryTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reschedule the timer indicated by the specified <code>timerId</code> such that the callback function supplied to <code>registerTimer</code> will be invoked after the specified <code>expiryTime</code> is reached. Return 0 on success, and a negative value otherwise. <code>expiryTime</code> is expressed as the absolute time from 00:00:00 UTC, January 1, 1970 (the epoch time defined by <code>bdetu_epoch</code>). The behavior is undefined unless <code>timerId</code> is a timer id returned from <code>registerTimer</code>, and has not subsequently been deregistered. Note that if <code>expiryTime</code> is earlier than the current time (<code><a class="el" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now()</a></code>) the associated callback will be invoked the first time that the callbacks are dispatched. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#ae6b96a1530a80e9ba161dd76fda7cd7e">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a4164692c244cb7fa467ada382de04b3c"></a><!-- doxytag: member="btlso::TcpTimerEventManager::deregisterSocketEvent" ref="a4164692c244cb7fa467ada382de04b3c" args="(const SocketHandle::Handle &amp;handle, EventType::Type event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlso::TcpTimerEventManager::deregisterSocketEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a>&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister from this event manager the callback associated with the specified <code>event</code> on the specified <code>handle</code> so that said callback will not be invoked if the <code>event</code> occurs. The behavior is undefined unless there is a callback registered for <code>event</code> on the socket <code>handle</code>. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#a9e56ec1e396bf7fb1c4c66661456a050">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a72430631bb41c7864538673218ee5b71"></a><!-- doxytag: member="btlso::TcpTimerEventManager::deregisterSocket" ref="a72430631bb41c7864538673218ee5b71" args="(const SocketHandle::Handle &amp;handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlso::TcpTimerEventManager::deregisterSocket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister from this event manager all callbacks associated with any event on the specified <code>handle</code> such that no callback will be invoked if an event occurs on the <code>handle</code>. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#a8c5ae36b8a8ac616a8a2bfc714d79054">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a5f59d3dfae0851ca96acdd570505d622"></a><!-- doxytag: member="btlso::TcpTimerEventManager::deregisterAllSocketEvents" ref="a5f59d3dfae0851ca96acdd570505d622" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlso::TcpTimerEventManager::deregisterAllSocketEvents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister from this event manager all callbacks associated with any event on any socket handle so that no callbacks are invoked when any event occurs on any handle. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#a3f9ed24912c0776c7da945f75a8fcd43">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a6f1ccee9fcbefa465395a70a915a4b75"></a><!-- doxytag: member="btlso::TcpTimerEventManager::deregisterTimer" ref="a6f1ccee9fcbefa465395a70a915a4b75" args="(const void *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlso::TcpTimerEventManager::deregisterTimer </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister from this event manager the timer callback associated with the specified timer <code>handle</code> (returned when the timer callback was registered) so that no callback will be invoked at the appointed time. The behavior is undefined unless <code>handle</code> was not obtained from this event manager through <code>registerTimer</code> method. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#a9bb2b4408ccc5baa21bbfa9b7e52c75b">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a0938fae002e17023ce1a158e0262a485"></a><!-- doxytag: member="btlso::TcpTimerEventManager::deregisterAllTimers" ref="a0938fae002e17023ce1a158e0262a485" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlso::TcpTimerEventManager::deregisterAllTimers </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister from this event manager all timer callbacks currently registered. The number of timers (as reported by <code>numTimers</code>) is 0 after this method is completed. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#ab1d57adeb86b60497515cfd11654a1d5">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a2e7ab490a6bc1cab6531e4ac5a7a5231"></a><!-- doxytag: member="btlso::TcpTimerEventManager::deregisterAll" ref="a2e7ab490a6bc1cab6531e4ac5a7a5231" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlso::TcpTimerEventManager::deregisterAll </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister from this event manager all callbacks currently registered. Note that the behavior is equivalent to the sequence of <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <a class="code" href="classbtlso_1_1TcpTimerEventManager.html#a0938fae002e17023ce1a158e0262a485">deregisterAllTimers</a>();
          <a class="code" href="classbtlso_1_1TcpTimerEventManager.html#a5f59d3dfae0851ca96acdd570505d622">deregisterAllSocketEvents</a>();
</pre></div><p><br/>
<br/>
 </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#a810bbb83036ccf6d140dc0428df5194a">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a04330208d7456fcc0138dc116246eca1"></a><!-- doxytag: member="btlso::TcpTimerEventManager::timeMetrics" ref="a04330208d7456fcc0138dc116246eca1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlso_1_1TimeMetrics.html">TimeMetrics</a>* btlso::TcpTimerEventManager::timeMetrics </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of modifiable metrics that reflect the workload of this event manager as a percentage of time spent in CPU bound operations vs. total time (see <code>btlso_timemetrics</code>). </p>

</div>
</div>
<a class="anchor" id="a13bc5fcc10efb8ae65b35b4c71f8ddd8"></a><!-- doxytag: member="btlso::TcpTimerEventManager::hasLimitedSocketCapacity" ref="a13bc5fcc10efb8ae65b35b4c71f8ddd8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool btlso::TcpTimerEventManager::hasLimitedSocketCapacity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this event manager has a limited socket capacity, and <code>false</code> otherwise. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#ae450cb4cae93242ef11d419f61cd9ab9">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a7cc87761071f6760ba0c79b0d8360331"></a><!-- doxytag: member="btlso::TcpTimerEventManager::isRegistered" ref="a7cc87761071f6760ba0c79b0d8360331" args="(const SocketHandle::Handle &amp;handle, EventType::Type eventType) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlso::TcpTimerEventManager::isRegistered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a>&nbsp;</td>
          <td class="paramname"> <em>eventType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if a callback is registered with this event manager to be invoked when a socket event of the specified <code>eventType</code> occurs on the specified socket <code>handle</code>, and 0 otherwise. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#aa9ca3d3c934a9f6c7c2d747a1dc84acd">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a30d076b1f20a4bc0edff58f44221345c"></a><!-- doxytag: member="btlso::TcpTimerEventManager::numEvents" ref="a30d076b1f20a4bc0edff58f44221345c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlso::TcpTimerEventManager::numEvents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the total number of callbacks registered with this event manager for either timers or sockets. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#ab2a349c2c66e5647300a30f0c3abf586">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a6729d6cbbdeaa5c949783caf4c6d45ef"></a><!-- doxytag: member="btlso::TcpTimerEventManager::numTimers" ref="a6729d6cbbdeaa5c949783caf4c6d45ef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlso::TcpTimerEventManager::numTimers </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of timers that are currently registered with this event manager. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#a233cec4ccaab3ecd5536f80aed3d53c0">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a93becc7346547b45655c21da5f503f19"></a><!-- doxytag: member="btlso::TcpTimerEventManager::numSocketEvents" ref="a93becc7346547b45655c21da5f503f19" args="(const SocketHandle::Handle &amp;handle) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlso::TcpTimerEventManager::numSocketEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of callbacks registered with this event manager, associated with the specified socket <code>handle</code>. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#aa414b377a1fe2cf979811c46a64e90c2">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="ab46ef9f5c435bb91541da9af95c3ffd1"></a><!-- doxytag: member="btlso::TcpTimerEventManager::socketEventManager" ref="ab46ef9f5c435bb91541da9af95c3ffd1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbtlso_1_1EventManager.html">EventManager</a>* btlso::TcpTimerEventManager::socketEventManager </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the non-modifiable event manager used for monitoring for socket events. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlso__tcptimereventmanager_8h_source.html">btlso_tcptimereventmanager.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:16 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
