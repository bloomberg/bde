<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlcc::TimeQueue</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlcc.html">bdlcc</a>      </li>
      <li><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue&lt; DATA &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlcc::TimeQueue&lt; DATA &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlcc::TimeQueue" -->
<p><code>#include &lt;<a class="el" href="bdlcc__timequeue_8h_source.html">bdlcc_timequeue.h</a>&gt;</code></p>

<p><a href="classbdlcc_1_1TimeQueue-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">Key</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>Node</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#a866d05c0c28356403df7d666db29a623">TimeQueue</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#a59ffdfd940804a4d4239eb9055cddfbc">TimeQueue</a> (int numIndexBits, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#a40c9c57ebb48c1f3a939363d422b8c99">TimeQueue</a> (bool poolTimerMemory, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#a0126b44c607de3fe1aafea236fb08935">TimeQueue</a> (int numIndexBits, bool poolTimerMemory, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#a497ac05c2b517a0f4e5a4f3f8225ae10">~TimeQueue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#a6042227d922eef1964d44f4e50f33f05">add</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;time, const DATA &amp;data, int *isNewTop=0, int *newLength=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#aed34e79d0af44f1fd04d52d2000850da">add</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;time, const DATA &amp;data, const <a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">Key</a> &amp;key, int *isNewTop=0, int *newLength=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#a67e7abe7b0fc30e6bc15c8c9fc24965e">add</a> (const <a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a>&lt; DATA &gt; &amp;item, int *isNewTop=0, int *newLength=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#aa89fe3949be4e188e308de51fe5e8eb0">popFront</a> (<a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a>&lt; DATA &gt; *buffer=0, int *newLength=0, <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> *newMinTime=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#a57870c3780165e3000d9a074c235377e">popLE</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;time, <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a>&lt; DATA &gt; &gt; *buffer=0, int *newLength=0, <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> *newMinTime=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#aa17f4acd92bbe6411e2c608a6a87a72f">popLE</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;time, int maxTimers, <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a>&lt; DATA &gt; &gt; *buffer=0, int *newLength=0, <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> *newMinTime=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#adecb2e3a6ca3d42f2fb241889d1ba9e5">remove</a> (<a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a> handle, int *newLength=0, <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> *newMinTime=0, <a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a>&lt; DATA &gt; *item=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#abe9c57579e19f603c952461c44c1c390">remove</a> (<a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a> handle, const <a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">Key</a> &amp;key, int *newLength=0, <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> *newMinTime=0, <a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a>&lt; DATA &gt; *item=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#abd6f76f1ca056ba67783d3750a2d0b77">removeAll</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a>&lt; DATA &gt; &gt; *buffer=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#a7c6b068bcfa15513daca3c53017bb584">update</a> (<a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a> handle, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;newTime, int *isNewTop=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#aef60534b815262e5e726f99cb12926da">update</a> (<a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a> handle, const <a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">Key</a> &amp;key, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;newTime, int *isNewTop=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#ac3a1fbf53a05f2e929833f8b2d85b914">length</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#a66e998e26f1728a2bb888f244d5f24e3">isRegisteredHandle</a> (<a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a> handle) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#a16e78046e6c431f75097b70ecc55aae8">isRegisteredHandle</a> (<a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a> handle, const <a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">Key</a> &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1TimeQueue.html#a930c9f79bb3da1d21bfe7ebb78f3a6c5">minTime</a> (<a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> *buffer) const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class DATA&gt;<br/>
 class bdlcc::TimeQueue&lt; DATA &gt;</h3>

<p>This parameterized class provides a public interface which is similar in structure and intent to <code><a class="el" href="classbdlcc_1_1Queue.html">Queue</a>&lt;DATA&gt;</code>, with the exception that each item stored in the <code><a class="el" href="classbdlcc_1_1TimeQueue.html">TimeQueue</a></code> has an associated time value. Items are retrieved or exchanged by proxy of a <code><a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a>&lt;DATA&gt;</code>, and are referred to by an opaque data type <code><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">TimeQueue::Handle</a></code> which serves to identify an individual element on the Time <a class="el" href="classbdlcc_1_1Queue.html">Queue</a>. Idiomatic usage of <code><a class="el" href="classbdlcc_1_1TimeQueue.html">TimeQueue</a></code> includes the member function <code>popLE</code>, which finds all items on the queue whose <code><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a></code> are less than a specified value and transfers those items to a provided vector of items, and the member function <code>update</code>, which can update the time value for a specific <code><a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a></code> without removing it from the queue. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a4d2b9397eb3a5b56576c0b8185104c9a"></a><!-- doxytag: member="bdlcc::TimeQueue::Handle" ref="a4d2b9397eb3a5b56576c0b8185104c9a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::<a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a866d05c0c28356403df7d666db29a623"></a><!-- doxytag: member="bdlcc::TimeQueue::TimeQueue" ref="a866d05c0c28356403df7d666db29a623" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::<a class="el" href="classbdlcc_1_1TimeQueue.html">TimeQueue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a59ffdfd940804a4d4239eb9055cddfbc"></a><!-- doxytag: member="bdlcc::TimeQueue::TimeQueue" ref="a59ffdfd940804a4d4239eb9055cddfbc" args="(int numIndexBits, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::<a class="el" href="classbdlcc_1_1TimeQueue.html">TimeQueue</a> </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numIndexBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty time queue. Optionally specify <code>numIndexBits</code> to configure the number of index bits used by this object. If <code>numIndexBits</code> is not specified a default value of 17 is used. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>8 &lt;= numIndexBits &lt;= 24</code>. See the component-level documentation for more information regarding <code>numIndexBits</code>. </p>

</div>
</div>
<a class="anchor" id="a40c9c57ebb48c1f3a939363d422b8c99"></a><!-- doxytag: member="bdlcc::TimeQueue::TimeQueue" ref="a40c9c57ebb48c1f3a939363d422b8c99" args="(bool poolTimerMemory, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::<a class="el" href="classbdlcc_1_1TimeQueue.html">TimeQueue</a> </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>poolTimerMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0126b44c607de3fe1aafea236fb08935"></a><!-- doxytag: member="bdlcc::TimeQueue::TimeQueue" ref="a0126b44c607de3fe1aafea236fb08935" args="(int numIndexBits, bool poolTimerMemory, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::<a class="el" href="classbdlcc_1_1TimeQueue.html">TimeQueue</a> </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numIndexBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>poolTimerMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>[!DEPRECATED!] Use the other constructor overloads instead. Note that the specified <code>poolTimerMemory</code> argument controlled whether additional memory used by an internal <code><a class="el" href="classbsl_1_1map.html">bsl::map</a></code> was pooled. When <code><a class="el" href="classbsl_1_1map.html">bsl::map</a></code> was modified to pool its own nodes, this option became irrelevant and is now ignored. </p>

</div>
</div>
<a class="anchor" id="a497ac05c2b517a0f4e5a4f3f8225ae10"></a><!-- doxytag: member="bdlcc::TimeQueue::~TimeQueue" ref="a497ac05c2b517a0f4e5a4f3f8225ae10" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::~<a class="el" href="classbdlcc_1_1TimeQueue.html">TimeQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this time queue. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a6042227d922eef1964d44f4e50f33f05"></a><!-- doxytag: member="bdlcc::TimeQueue::add" ref="a6042227d922eef1964d44f4e50f33f05" args="(const bsls::TimeInterval &amp;time, const DATA &amp;data, int *isNewTop=0, int *newLength=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a> <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>isNewTop</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>newLength</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aed34e79d0af44f1fd04d52d2000850da"></a><!-- doxytag: member="bdlcc::TimeQueue::add" ref="aed34e79d0af44f1fd04d52d2000850da" args="(const bsls::TimeInterval &amp;time, const DATA &amp;data, const Key &amp;key, int *isNewTop=0, int *newLength=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a> <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">Key</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>isNewTop</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>newLength</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a new item to this queue having the specified <code>time</code> value, and associated <code>data</code>. Optionally use the specified <code>key</code> to uniquely identify the item in subsequent calls to <code>remove</code> and <code>update</code>. Optionally load into the optionally specified <code>isNewTop</code> a non-zero value if the item is now the lowest item in this queue, and a 0 value otherwise. If specified, load into the optionally specified <code>newLength</code>, the new number of items in this queue. Return a value that may be used to identify the newly added item in future calls to time queue on success, and -1 if the maximum queue length has been reached. </p>

</div>
</div>
<a class="anchor" id="a67e7abe7b0fc30e6bc15c8c9fc24965e"></a><!-- doxytag: member="bdlcc::TimeQueue::add" ref="a67e7abe7b0fc30e6bc15c8c9fc24965e" args="(const TimeQueueItem&lt; DATA &gt; &amp;item, int *isNewTop=0, int *newLength=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a> <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a>&lt; DATA &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>isNewTop</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>newLength</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the value of the specified <code>item</code> to this queue. Optionally load into the optionally specified <code>isNewTop</code> a non-zero value if the replaces is now the lowest element in this queue, and a 0 value otherwise. If specified, load into the optionally specified <code>newLength</code>, the new number of elements in this queue. Return a value that may be used to identify the newly added element in future calls to time queue. </p>

</div>
</div>
<a class="anchor" id="aa89fe3949be4e188e308de51fe5e8eb0"></a><!-- doxytag: member="bdlcc::TimeQueue::popFront" ref="aa89fe3949be4e188e308de51fe5e8eb0" args="(TimeQueueItem&lt; DATA &gt; *buffer=0, int *newLength=0, bsls::TimeInterval *newMinTime=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::popFront </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a>&lt; DATA &gt; *&nbsp;</td>
          <td class="paramname"> <em>buffer</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>newLength</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> *&nbsp;</td>
          <td class="paramname"> <em>newMinTime</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Atomically remove the top item from this queue, and optionally load into the optionally specified <code>buffer</code> the time and associated data of the item removed. Optionally load into the optionally specified <code>newLength</code>, the number of items remaining in the queue. Optionally load into the optionally specified <code>newMinTime</code> the new lowest time in this queue. Return 0 on success, and a non-zero value if there are no items in the queue. Note that if <code>DATA</code> follows the <code>bdema</code> allocator model, the allocator of the <code>buffer</code> is used to supply memory. </p>

</div>
</div>
<a class="anchor" id="a57870c3780165e3000d9a074c235377e"></a><!-- doxytag: member="bdlcc::TimeQueue::popLE" ref="a57870c3780165e3000d9a074c235377e" args="(const bsls::TimeInterval &amp;time, bsl::vector&lt; TimeQueueItem&lt; DATA &gt; &gt; *buffer=0, int *newLength=0, bsls::TimeInterval *newMinTime=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::popLE </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a>&lt; DATA &gt; &gt; *&nbsp;</td>
          <td class="paramname"> <em>buffer</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>newLength</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> *&nbsp;</td>
          <td class="paramname"> <em>newMinTime</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this queue all the items that have a time value less than or equal to the specified <code>time</code>, and optionally append into the optionally specified <code>buffer</code> a list of the removed items, ordered by their corresponding time values (top item first). Optionally load into the optionally specified <code>newLength</code> the number of items remaining in this queue, and into the optionally specified <code>newMinTime</code> the lowest remaining time value in this queue. Note that <code>newMinTime</code> is only loaded if there are items remaining in the time queue; therefore, <code>newLength</code> should be specified and examined to determine whether items remain, and <code>newMinTime</code> used only when <code>newLength</code> &gt; 0. Also note that if <code>DATA</code> follows the <code>bdema</code> allocator model, the allocator of the <code>buffer</code> vector is used to supply memory for the items appended to the <code>buffer</code>. </p>

</div>
</div>
<a class="anchor" id="aa17f4acd92bbe6411e2c608a6a87a72f"></a><!-- doxytag: member="bdlcc::TimeQueue::popLE" ref="aa17f4acd92bbe6411e2c608a6a87a72f" args="(const bsls::TimeInterval &amp;time, int maxTimers, bsl::vector&lt; TimeQueueItem&lt; DATA &gt; &gt; *buffer=0, int *newLength=0, bsls::TimeInterval *newMinTime=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::popLE </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxTimers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a>&lt; DATA &gt; &gt; *&nbsp;</td>
          <td class="paramname"> <em>buffer</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>newLength</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> *&nbsp;</td>
          <td class="paramname"> <em>newMinTime</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this queue up to the specified <code>maxTimers</code> number of items that have a time value less than or equal to the specified <code>time</code>, and optionally append into the optionally specified <code>buffer</code> a list of the removed items, ordered by their corresponding time values (top item first). Optionally load into the optionally specified <code>newLength</code> the number of items remaining in this queue, and into the optionally specified <code>newMinTime</code> the lowest remaining time value in this queue. The behavior is undefined unless <code>maxTimers</code> &gt;= 0. Note that <code>newMinTime</code> is only loaded if there are items remaining in the time queue; therefore, <code>newLength</code> should be specified and examined to determine whether items remain, and <code>newMinTime</code> used only when <code>newLength</code> &gt; 0. Also note that if <code>DATA</code> follows the <code>bdema</code> allocator model, the allocator of the <code>buffer</code> vector is used to supply memory. Note finally that all the items appended into <code>buffer</code> have a time value less than or equal to the elements remaining in this queue. </p>

</div>
</div>
<a class="anchor" id="adecb2e3a6ca3d42f2fb241889d1ba9e5"></a><!-- doxytag: member="bdlcc::TimeQueue::remove" ref="adecb2e3a6ca3d42f2fb241889d1ba9e5" args="(Handle handle, int *newLength=0, bsls::TimeInterval *newMinTime=0, TimeQueueItem&lt; DATA &gt; *item=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>newLength</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> *&nbsp;</td>
          <td class="paramname"> <em>newMinTime</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a>&lt; DATA &gt; *&nbsp;</td>
          <td class="paramname"> <em>item</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abe9c57579e19f603c952461c44c1c390"></a><!-- doxytag: member="bdlcc::TimeQueue::remove" ref="abe9c57579e19f603c952461c44c1c390" args="(Handle handle, const Key &amp;key, int *newLength=0, bsls::TimeInterval *newMinTime=0, TimeQueueItem&lt; DATA &gt; *item=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">Key</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>newLength</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> *&nbsp;</td>
          <td class="paramname"> <em>newMinTime</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a>&lt; DATA &gt; *&nbsp;</td>
          <td class="paramname"> <em>item</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this queue the item having the specified <code>handle</code>, and optionally load into the optionally specified <code>item</code> the time and data values of the recently removed item. Optionally use the specified <code>key</code> to uniquely identify the item. If specified, load into the optionally specified <code>newMinTime</code>, the resulting lowest time value remaining in the queue. Return 0 on success, and a non-zero value if no item with the <code>handle</code> exists in the queue. Note that if <code>DATA</code> follows the <code>bdema</code> allocator model, the allocator of the <code>item</code> instance is used to supply memory. </p>

</div>
</div>
<a class="anchor" id="abd6f76f1ca056ba67783d3750a2d0b77"></a><!-- doxytag: member="bdlcc::TimeQueue::removeAll" ref="abd6f76f1ca056ba67783d3750a2d0b77" args="(bsl::vector&lt; TimeQueueItem&lt; DATA &gt; &gt; *buffer=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::removeAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbdlcc_1_1TimeQueueItem.html">TimeQueueItem</a>&lt; DATA &gt; &gt; *&nbsp;</td>
          <td class="paramname"> <em>buffer</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all the items from this queue. Optionally specify a <code>buffer</code> in which to load the removed items. The resultant items in the <code>buffer</code> are ordered by increasing time interval; items of equivalant time interval have arbitrary ordering. Note that the allocator of the <code>buffer</code> vector is used to supply memory. </p>

</div>
</div>
<a class="anchor" id="a7c6b068bcfa15513daca3c53017bb584"></a><!-- doxytag: member="bdlcc::TimeQueue::update" ref="a7c6b068bcfa15513daca3c53017bb584" args="(Handle handle, const bsls::TimeInterval &amp;newTime, int *isNewTop=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>newTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>isNewTop</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aef60534b815262e5e726f99cb12926da"></a><!-- doxytag: member="bdlcc::TimeQueue::update" ref="aef60534b815262e5e726f99cb12926da" args="(Handle handle, const Key &amp;key, const bsls::TimeInterval &amp;newTime, int *isNewTop=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">Key</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>newTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>isNewTop</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update the time value of the item having the specified <code>handle</code> to the specified <code>newTime</code> and optionally load into the optionally specified <code>isNewTop</code> a non-zero value if the modified item is now the lowest time value in the time queue or zero otherwise. Return 0 on success, and a non-zero value if there is currently no item having the <code>handle</code> registered with this time queue. </p>

</div>
</div>
<a class="anchor" id="ac3a1fbf53a05f2e929833f8b2d85b914"></a><!-- doxytag: member="bdlcc::TimeQueue::length" ref="ac3a1fbf53a05f2e929833f8b2d85b914" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "snapshot" of the current number of items in this queue. </p>

</div>
</div>
<a class="anchor" id="a66e998e26f1728a2bb888f244d5f24e3"></a><!-- doxytag: member="bdlcc::TimeQueue::isRegisteredHandle" ref="a66e998e26f1728a2bb888f244d5f24e3" args="(Handle handle) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::isRegisteredHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a16e78046e6c431f75097b70ecc55aae8"></a><!-- doxytag: member="bdlcc::TimeQueue::isRegisteredHandle" ref="a16e78046e6c431f75097b70ecc55aae8" args="(Handle handle, const Key &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::isRegisteredHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1TimeQueue.html#a4d2b9397eb3a5b56576c0b8185104c9a">Handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1TimeQueue_1_1Key.html">Key</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if an item having specified <code>handle</code> is currently registered with this time queue and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a930c9f79bb3da1d21bfe7ebb78f3a6c5"></a><!-- doxytag: member="bdlcc::TimeQueue::minTime" ref="a930c9f79bb3da1d21bfe7ebb78f3a6c5" args="(bsls::TimeInterval *buffer) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1TimeQueue.html">bdlcc::TimeQueue</a>&lt; DATA &gt;::minTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>buffer</code>, the time value of the lowest time in this queue. Return 0 on success, and a non-zero value if this queue is empty. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlcc__timequeue_8h_source.html">bdlcc_timequeue.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:21 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
