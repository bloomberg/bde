<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslstl_unorderedmultiset Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_unorderedmultiset<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL-compliant <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a> class.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KEY&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gac224ab4e150a21c2ed661131cfa487f7">bsl::unordered_multiset::key_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KEY&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga0f6d3b101c9a7c7e57422ddae8d0f36f">bsl::unordered_multiset::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef HASH&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga9440d0a963d0417b505ac78538723ff6">bsl::unordered_multiset::hasher</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef EQUAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gaa1232a18650d36bbc04857eafc86c23f">bsl::unordered_multiset::key_equal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gaae360f67451062d24aaf29b12435026d">bsl::unordered_multiset::allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef allocator_type::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga7a6d7b3ae4d8b19540906691478c6228">bsl::unordered_multiset::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
allocator_type::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga58c0759062e14e969a110993c64b152a">bsl::unordered_multiset::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorTraits::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga63942086aa758ce662757507fcaa5679">bsl::unordered_multiset::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorTraits::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga2a83c53d80141e4bfd276fad15cd2c68">bsl::unordered_multiset::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorTraits::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga6f075753682eae178706694da0f5ed1f">bsl::unordered_multiset::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorTraits::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga193c43589d77aac1fd32095369db3b8b">bsl::unordered_multiset::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
::<a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a><br class="typebreak"/>
&lt; value_type, difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gac610e64ab4cd477466638635c4439b02">bsl::unordered_multiset::iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
::<a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a><br class="typebreak"/>
&lt; const value_type, <br class="typebreak"/>
difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gaaec50219f12ed6dccf0a9d3610c99212">bsl::unordered_multiset::const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
::<a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a><br class="typebreak"/>
&lt; value_type, difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga9992d1755e1ea59f13364a4ac4801c8c">bsl::unordered_multiset::local_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
::<a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a><br class="typebreak"/>
&lt; const value_type, <br class="typebreak"/>
difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gae2506aae4cbd64e6cdb32a80e8b3dfad">bsl::unordered_multiset::const_local_iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gad22a0edcf6363e3ee9274ed048f0f928">bsl::unordered_multiset::BSLMF_NESTED_TRAIT_DECLARATION_IF</a> (unordered_multiset,::BloombergLP::bslmf::IsBitwiseMoveable,::BloombergLP::bslmf::IsBitwiseMoveable&lt; HashTable &gt;::value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gae5281db8b4524854d60fcc932a21d073">bsl::unordered_multiset::unordered_multiset</a> (size_type initialNumBuckets=0, const hasher &amp;hash=hasher(), const key_equal &amp;keyEqual=key_equal(), const allocator_type &amp;allocator=allocator_type())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gaef00b87c7e436b0f465d8a0fa6de1812">bsl::unordered_multiset::unordered_multiset</a> (const allocator_type &amp;allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga2df4d6dfb7bee8ce75457c4badc30eea">bsl::unordered_multiset::unordered_multiset</a> (const unordered_multiset &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga349f384ceb67ee28e6182c04b6da24b6">bsl::unordered_multiset::unordered_multiset</a> (const unordered_multiset &amp;original, const allocator_type &amp;allocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga3fa2df8bb116f037a4678b94cbc2dc17">bsl::unordered_multiset::unordered_multiset</a> (INPUT_ITERATOR first, INPUT_ITERATOR last, size_type initialNumBuckets=0, const hasher &amp;hash=hasher(), const key_equal &amp;keyEqual=key_equal(), const allocator_type &amp;allocator=allocator_type())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gaacfede2a3e65b5b8f7b1c9183b442894">bsl::unordered_multiset::~unordered_multiset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unordered_multiset &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga6686f51f409834c441401075ca04caa5">bsl::unordered_multiset::operator=</a> (const unordered_multiset &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gabcf3ccf453abb529eb6eb94a8298bd20">bsl::unordered_multiset::begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga20b1466c185aa184bc50f04e53b7ae2d">bsl::unordered_multiset::end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga2f6ec6ef03611c1d327368e372efff4f">bsl::unordered_multiset::begin</a> (size_type index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga422727341b9f8b6033218d7039a49cc8">bsl::unordered_multiset::end</a> (size_type index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga9bb8383caf31e8ce28e44050f48d06d2">bsl::unordered_multiset::clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pair&lt; iterator, iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga60c5b73f7a685f6d38ac4713ec348db1">bsl::unordered_multiset::equal_range</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga22ccf66a87c544193f31fedc8ee07030">bsl::unordered_multiset::erase</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga4678a57f98c8e6044bb7a6e68c3a7cf9">bsl::unordered_multiset::erase</a> (const_iterator position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga6552a8447b885db853e0c200b96b39c5">bsl::unordered_multiset::erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gaf9176db44a333499c12297f1790e2e37">bsl::unordered_multiset::find</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gada2fc1827dca0d8105df43299fffe1b0">bsl::unordered_multiset::insert</a> (const value_type &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga922e044e65efca8cf29b7af48745a570">bsl::unordered_multiset::insert</a> (const_iterator hint, const value_type &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gaad1d261c49953523eaafaec248e069b6">bsl::unordered_multiset::insert</a> (INPUT_ITERATOR first, INPUT_ITERATOR last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga21fe5c8de29ae3777a089452af5649e7">bsl::unordered_multiset::max_load_factor</a> (float newLoadFactor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga7490229d445297136270d56629443a3a">bsl::unordered_multiset::rehash</a> (size_type numBuckets)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga04a79bc05088eaae96aa76d8b2593735">bsl::unordered_multiset::reserve</a> (size_type numElements)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga13c5b72c68c73b67bcf83932ddf8f288">bsl::unordered_multiset::swap</a> (unordered_multiset &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga9da01b4e4d448a24dfdd54bdacb21f5f">bsl::unordered_multiset::begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gaad28eaba37020d055f466e0226be3859">bsl::unordered_multiset::end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga2969a1eb476105bc78c550bc36365a0c">bsl::unordered_multiset::cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gabdf1ff49beccf1dd68cfce1bf96147a8">bsl::unordered_multiset::cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gac4dc1420ef10eaf8dd6e04e7606d9a14">bsl::unordered_multiset::begin</a> (size_type index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga66425a3c3945f80dd593ec18af93ab82">bsl::unordered_multiset::end</a> (size_type index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gabdb73949d750c74a9c6ff63f0ba00cde">bsl::unordered_multiset::cbegin</a> (size_type index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_local_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga2dabab4d32a496d89286e5cf91933ffd">bsl::unordered_multiset::cend</a> (size_type index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga15b8e3739ba5c0bd7b532b81cc6e9db4">bsl::unordered_multiset::bucket</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga5cee093bfcc096b13d908b69074d96c7">bsl::unordered_multiset::bucket_count</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gac7daa1447baa7526a9b266531ddf276e">bsl::unordered_multiset::bucket_size</a> (size_type index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga041cef546e2d0dc73a4fcb821f0ce907">bsl::unordered_multiset::count</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gab84206cf24f95031d7d5579e13d0d9b9">bsl::unordered_multiset::empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pair&lt; const_iterator, <br class="typebreak"/>
const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga568005ff5479dd5f975af1c8813d4c90">bsl::unordered_multiset::equal_range</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gae6feb2f63680850962f7d96e69bab0d7">bsl::unordered_multiset::find</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga4800b08398981061d5555d024d7b6ec4">bsl::unordered_multiset::get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">key_equal&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga72f193ce1423c9a34fe7b2a5620afd0e">bsl::unordered_multiset::key_eq</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">hasher&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga5c65f0f02bba42f56eaaf6d551c5384c">bsl::unordered_multiset::hash_function</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga58c97fcd33e7fef69749dab83056ff5a">bsl::unordered_multiset::load_factor</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga3aefba0c5698b92b0d97321cd3dc5a17">bsl::unordered_multiset::max_bucket_count</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga3f22a1939b2354121a588c7a264488e5">bsl::unordered_multiset::max_load_factor</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga2050a59b28aa1cc71956c3883f24feb7">bsl::unordered_multiset::max_size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gaf9dff7a2cfd07d6703839f1999a9a55e">bsl::unordered_multiset::size</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga8e9c9a9220ff75ddc73acee85bfa7392">bsl::operator==</a> (const unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gae0f2b56046e1efc815e5637ed81ce7a8">bsl::operator!=</a> (const unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#gad7ead0881f1289594de31f274644e068">bsl::swap</a> (unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;x, unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;y)</td></tr>
<tr><td colspan="2"><h2><a name="friend-members"></a>
Friends</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY2 , class HASH2 , class EQUAL2 , class ALLOCATOR2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga8fd1815e1d9cb199648873d1c0913e46">bsl::unordered_multiset::operator==</a> (const unordered_multiset&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;, const unordered_multiset&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY2 , class HASH2 , class EQUAL2 , class ALLOCATOR2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__unorderedmultiset.html#ga8fd1815e1d9cb199648873d1c0913e46">bsl::unordered_multiset::operator==</a> (const unordered_multiset&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;, const unordered_multiset&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Requirements on <code>KEY</code></a> </li>
<li>
<a href="#3.2">Memory Allocation</a> <ul>
<li>
<a href="#3.2.1"><code>bslma</code>-Style Allocators</a> </li>
</ul>
</li>
<li>
<a href="#3.3">Operations</a> </li>
<li>
<a href="#3.4">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL-compliant <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a> class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>  </td><td>hashed-map container  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bsl+stdhdrs </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a single class template <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code>, implementing the standard container holding a collection of multiple keys with no guarantees on ordering. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An instantiation of <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> is an allocator-aware, value-semantic type whose salient attributes are its size (number of keys) and the set of keys the <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> contains, without regard to their order. If <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> is instantiated with a key type that is not itself value-semantic, then it will not retain all of its value-semantic qualities. In particular, if the key type cannot be tested for equality, then an <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> containing that type cannot be tested for equality. It is even possible to instantiate <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> with a key type that does not have an accessible copy-constructor, in which case the <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> will not be copyable. Note that the equality operator <code>operator==</code> for each element is used to determine when two <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> objects have the same value, and not the equality comparator supplied at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> meets the requirements of an unordered associative container with forward iterators in the C++11 standard [unord]. The <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> implemented here adheres to the C++11 standard, except that it does not have interfaces that take rvalue references, <code>initializer_list</code>, <code>emplace</code>, or operations taking a variadic number of template parameters. Note that excluded C++11 features are those that require (or are greatly simplified by) C++11 compiler support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_on_key"></a> <a class="anchor" id="description.requirements_on_key"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Requirements on KEY: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> instantiation is a fully <a href="group__bsldoc__glossary.html#value-semantic_type" class="glossary">Value-Semantic Type</a> (see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>) only if the supplied <code>KEY</code> template parameters is fully value-semantic. It is possible to instantiate an <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> with <code>KEY</code> parameter arguments that do not provide a full set of value-semantic operations, but then some methods of the container may not be instantiable. The following terminology, adopted from the C++11 standard, is used in the function documentation of <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> to describe a function's requirements for the <code>KEY</code> template parameter. These terms are also defined in section [utility.arg.requirements] of the C++11 standard. Note that, in the context of an <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> instantiation, the requirements apply specifically to the <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code>s entry type, <code>value_type</code>, which is an alias for <code>KEY</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="default-constructible"></a> <a class="anchor" id="requirements_on_key.default-constructible"></a> <a class="anchor" id="description.requirements_on_key.default-constructible"></a> <em>default-constructible</em>: The type provides an accessible default constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="copy-constructible"></a> <a class="anchor" id="requirements_on_key.copy-constructible"></a> <a class="anchor" id="description.requirements_on_key.copy-constructible"></a> <em>copy-constructible</em>: The type provides an accessible copy constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="equality-comparable"></a> <a class="anchor" id="requirements_on_key.equality-comparable"></a> <a class="anchor" id="description.requirements_on_key.equality-comparable"></a> <em>equality-comparable</em>: The type provides an equality-comparison operator that defines an equivalence relationship and is both reflexive and transitive.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_allocation"></a> <a class="anchor" id="description.memory_allocation"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The type supplied as a set's <code>ALLOCATOR</code> template parameter determines how that set will allocate memory. The <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> template supports allocators meeting the requirements of the C++11 standard [allocator.requirements], and in addition it supports scoped-allocators derived from the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> memory allocation protocol. Clients intending to use <code>bslma</code> style allocators should use the template's default <code>ALLOCATOR</code> type: The default type for the <code>ALLOCATOR</code> template parameter, <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, provides a C++11 standard-compatible adapter for a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma-style_allocators"></a> <a class="anchor" id="memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="description.memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>bslma-Style Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the parameterized <code>ALLOCATOR</code> type of an <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> instantiation is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, then objects of that set type will conform to the standard behavior of a <code>bslma</code>-allocator-enabled type. Such a set accepts an optional <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> argument at construction. If the address of a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object is explicitly supplied at construction, it will be used to supply memory for the <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> throughout its lifetime; otherwise, the <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> will use the default allocator installed at the time of the <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code>s construction (see <code>bslma_default</code>). In addition to directly allocating memory from the indicated <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, an <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> supplies that allocator's address to the constructors of contained objects of the parameterized <code>KEY</code> types with the <code><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a></code> trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="operations"></a> <a class="anchor" id="description.operations"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section describes the run-time complexity of operations on instances of <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Legend
  ------
  <span class="charliteral">&#39;K&#39;</span>             - parameterized <span class="stringliteral">&#39;KEY&#39;</span> type of the unordered multiset
  <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>        - two distinct objects of type <span class="stringliteral">&#39;unordered_multiset&lt;K&gt;&#39;</span>
  <span class="charliteral">&#39;n&#39;</span>, <span class="charliteral">&#39;m&#39;</span>        - number of elements in <span class="charliteral">&#39;a&#39;</span> and <span class="charliteral">&#39;b&#39;</span> respectively
  <span class="charliteral">&#39;w&#39;</span>             - number of buckets of <span class="charliteral">&#39;a&#39;</span>
  <span class="stringliteral">&#39;value_type&#39;</span>    - unoredered_multiset&lt;K&gt;::value_type
  <span class="charliteral">&#39;c&#39;</span>             - comparator providing an ordering <span class="keywordflow">for</span> objects of type <span class="charliteral">&#39;K&#39;</span>
  <span class="stringliteral">&#39;al             - an STL-style memory allocator</span>
<span class="stringliteral">  &#39;</span>i1<span class="stringliteral">&#39;, &#39;</span>i2<span class="stringliteral">&#39;      - two iterators defining a sequence of &#39;</span>value_type<span class="stringliteral">&#39; objects</span>
<span class="stringliteral">  &#39;</span>k<span class="stringliteral">&#39;             - an object of type &#39;</span>K<span class="stringliteral">&#39;</span>
<span class="stringliteral">  &#39;</span>v<span class="stringliteral">&#39;             - an object of type &#39;</span>value_type<span class="stringliteral">&#39;</span>
<span class="stringliteral">  &#39;</span>p1<span class="stringliteral">&#39;, &#39;</span>p2<span class="stringliteral">&#39;      - two iterators belonging to &#39;</span>a<span class="stringliteral">&#39;</span>
<span class="stringliteral">  distance(i1,i2) - the number of elements in the range [i1, i2)</span>
<span class="stringliteral">  distance(p1,p2) - the number of elements in the range [p1, p2)</span>
<span class="stringliteral"></span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | Operation                                          | Complexity         |</span>
<span class="stringliteral">  +====================================================+====================+</span>
<span class="stringliteral">  | unordered_multiset&lt;K&gt; a; (default construction)    | O[1]               |</span>
<span class="stringliteral">  | unordered_multiset&lt;K&gt; a(al);                       |                    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | unordered_multiset&lt;K&gt; a(b); (copy construction)    | Average: O[n]      |</span>
<span class="stringliteral">  | unordered_multiset&lt;K&gt; a(b, al);                    | Worst:   O[n^2]    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | unordered_multiset&lt;K&gt; a(w);                        | O[n]               |</span>
<span class="stringliteral">  | unordered_multiset&lt;K&gt; a(w, hf);                    |                    |</span>
<span class="stringliteral">  | unordered_multiset&lt;K&gt; a(w, hf, eq);                |                    |</span>
<span class="stringliteral">  | unordered_multiset&lt;K&gt; a(w, hf, eq, al);            |                    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | unordered_multiset&lt;K&gt; a(i1, i2);                   | Average: O[        |</span>
<span class="stringliteral">  | unordered_multiset&lt;K&gt; a(i1, i2, w)                 |   distance(i1, i2)]|</span>
<span class="stringliteral">  | unordered_multiset&lt;K&gt; a(i1, i2, w, hf);            | Worst:   O[n^2]    |</span>
<span class="stringliteral">  | unordered_multiset&lt;K&gt; a(i1, i2, w, hf, eq);        |                    |</span>
<span class="stringliteral">  | unordered_multiset&lt;K&gt; a(i1, i2, w, hf, eq, al);    |                    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.~unordered_multiset&lt;K&gt;(); (destruction)          | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a = b;          (assignment)                       | Average: O[n]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n^2]    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.begin(), a.end(), a.cbegin(), a.cend(),          | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a == b, a != b                                     | Best:  O[n]        |</span>
<span class="stringliteral">  |                                                    | Worst: O[n^2]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.swap(b), swap(a,b)                               | O[1] if &#39;</span>a<span class="stringliteral">&#39; and    |</span>
<span class="stringliteral">  |                                                    | &#39;</span>b<span class="stringliteral">&#39; use the same   |</span>
<span class="stringliteral">  |                                                    | allocator,         |</span>
<span class="stringliteral">  |                                                    | O[n + m] otherwise |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.key_eq()                                         | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.hash_function()                                  | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.size()                                           | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.max_size()                                       | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.empty()                                          | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | get_allocator()                                    | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.insert(v)                                        | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.insert(p1, v)                                    | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.insert(i1, i2)                                   | Average O[         |</span>
<span class="stringliteral">  |                                                    |   distance(i1, i2)]|</span>
<span class="stringliteral">  |                                                    | Worst:  O[ n *     |</span>
<span class="stringliteral">  |                                                    |   distance(i1, i2)]|</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(p1)                                        | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(k)                                         | Average: O[        |</span>
<span class="stringliteral">  |                                                    |         a.count(k)]|</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.erase(p1, p2)                                    | Average: O[        |</span>
<span class="stringliteral">  |                                                    |   distance(p1, p2)]|</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.clear()                                          | O[n]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.find(k)                                          | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.count(k)                                         | Average: O[1]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.equal_range(k)                                   | Average: O[        |</span>
<span class="stringliteral">  |                                                    |         a.count(k)]|</span>
<span class="stringliteral">  |                                                    | Worst:   O[n]      |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.bucket_count()                                   | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.max_bucket_count()                               | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.bucket(k)                                        | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.bucket_size(k)                                   | O[a.bucket_size(k)]|</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.load_factor()                                    | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.max_load_factor()                                | O[1]               |</span>
<span class="stringliteral">  | a.max_load_factor(z)                               | O[1]               |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.rehash(k)                                        | Average: O[n]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n^2]    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
<span class="stringliteral">  | a.resize(k)                                        | Average: O[n]      |</span>
<span class="stringliteral">  |                                                    | Worst:   O[n^2]    |</span>
<span class="stringliteral">  +----------------------------------------------------+--------------------+</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gac224ab4e150a21c2ed661131cfa487f7"></a><!-- doxytag: member="bsl::unordered_multiset::key_type" ref="gac224ab4e150a21c2ed661131cfa487f7" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KEY <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::key_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0f6d3b101c9a7c7e57422ddae8d0f36f"></a><!-- doxytag: member="bsl::unordered_multiset::value_type" ref="ga0f6d3b101c9a7c7e57422ddae8d0f36f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KEY <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9440d0a963d0417b505ac78538723ff6"></a><!-- doxytag: member="bsl::unordered_multiset::hasher" ref="ga9440d0a963d0417b505ac78538723ff6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef HASH <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::hasher<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa1232a18650d36bbc04857eafc86c23f"></a><!-- doxytag: member="bsl::unordered_multiset::key_equal" ref="gaa1232a18650d36bbc04857eafc86c23f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef EQUAL <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::key_equal<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaae360f67451062d24aaf29b12435026d"></a><!-- doxytag: member="bsl::unordered_multiset::allocator_type" ref="gaae360f67451062d24aaf29b12435026d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::allocator_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7a6d7b3ae4d8b19540906691478c6228"></a><!-- doxytag: member="bsl::unordered_multiset::reference" ref="ga7a6d7b3ae4d8b19540906691478c6228" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::reference <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga58c0759062e14e969a110993c64b152a"></a><!-- doxytag: member="bsl::unordered_multiset::const_reference" ref="ga58c0759062e14e969a110993c64b152a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef allocator_type::const_reference <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga63942086aa758ce662757507fcaa5679"></a><!-- doxytag: member="bsl::unordered_multiset::size_type" ref="ga63942086aa758ce662757507fcaa5679" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::size_type <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2a83c53d80141e4bfd276fad15cd2c68"></a><!-- doxytag: member="bsl::unordered_multiset::difference_type" ref="ga2a83c53d80141e4bfd276fad15cd2c68" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::difference_type <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6f075753682eae178706694da0f5ed1f"></a><!-- doxytag: member="bsl::unordered_multiset::pointer" ref="ga6f075753682eae178706694da0f5ed1f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::pointer <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga193c43589d77aac1fd32095369db3b8b"></a><!-- doxytag: member="bsl::unordered_multiset::const_pointer" ref="ga193c43589d77aac1fd32095369db3b8b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::const_pointer <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac610e64ab4cd477466638635c4439b02"></a><!-- doxytag: member="bsl::unordered_multiset::iterator" ref="gac610e64ab4cd477466638635c4439b02" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; value_type, difference_type&gt; <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaaec50219f12ed6dccf0a9d3610c99212"></a><!-- doxytag: member="bsl::unordered_multiset::const_iterator" ref="gaaec50219f12ed6dccf0a9d3610c99212" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">BloombergLP::bslstl::HashTableIterator</a>&lt; const value_type, difference_type&gt; <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::const_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9992d1755e1ea59f13364a4ac4801c8c"></a><!-- doxytag: member="bsl::unordered_multiset::local_iterator" ref="ga9992d1755e1ea59f13364a4ac4801c8c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; value_type, difference_type&gt; <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::local_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae2506aae4cbd64e6cdb32a80e8b3dfad"></a><!-- doxytag: member="bsl::unordered_multiset::const_local_iterator" ref="gae2506aae4cbd64e6cdb32a80e8b3dfad" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ::<a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableBucketIterator.html">BloombergLP::bslstl::HashTableBucketIterator</a>&lt; const value_type, difference_type&gt; <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::const_local_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gad22a0edcf6363e3ee9274ed048f0f928"></a><!-- doxytag: member="bsl::unordered_multiset::BSLMF_NESTED_TRAIT_DECLARATION_IF" ref="gad22a0edcf6363e3ee9274ed048f0f928" args="(unordered_multiset,::BloombergLP::bslmf::IsBitwiseMoveable,::BloombergLP::bslmf::IsBitwiseMoveable&lt; HashTable &gt;::value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::BSLMF_NESTED_TRAIT_DECLARATION_IF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::BloombergLP::bslmf::IsBitwiseMoveable&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::BloombergLP::bslmf::IsBitwiseMoveable&lt; HashTable &gt;::value&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae5281db8b4524854d60fcc932a21d073"></a><!-- doxytag: member="bsl::unordered_multiset::unordered_multiset" ref="gae5281db8b4524854d60fcc932a21d073" args="(size_type initialNumBuckets=0, const hasher &amp;hash=hasher(), const key_equal &amp;keyEqual=key_equal(), const allocator_type &amp;allocator=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::unordered_multiset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultiset.html#ga63942086aa758ce662757507fcaa5679">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>initialNumBuckets</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#ga9440d0a963d0417b505ac78538723ff6">hasher</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hash</em> = <code><a class="el" href="group__bslstl__unorderedmultiset.html#ga9440d0a963d0417b505ac78538723ff6">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#gaa1232a18650d36bbc04857eafc86c23f">key_equal</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keyEqual</em> = <code><a class="el" href="group__bslstl__unorderedmultiset.html#gaa1232a18650d36bbc04857eafc86c23f">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#gaae360f67451062d24aaf29b12435026d">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code><a class="el" href="group__bslstl__unorderedmultiset.html#gaae360f67451062d24aaf29b12435026d">allocator_type</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an empty unordered multi-set. Optionally specify an <code>initialNumBuckets</code> indicating the initial size of the array of buckets of this container. If <code>initialNumBuckets</code> is not supplied, an implementation defined value is used. Optionally specify a <code>hasher</code> used to generate the hash values associated to the keys extracted from the values contained in this object. If <code>hash</code> is not supplied, a default-constructed object of type <code>hasher</code> is used. Optionally specify a key-equality functor <code>keyEqual</code> used to verify that two key values are the same. If <code>keyEqual</code> is not supplied, a default-constructed object of type <code>key_equal</code> is used. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>allocator_type</code> is used. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>allocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>allocator</code> is not supplied, the currently installed default allocator will be used to supply memory. </p>

</div>
</div>
<a class="anchor" id="gaef00b87c7e436b0f465d8a0fa6de1812"></a><!-- doxytag: member="bsl::unordered_multiset::unordered_multiset" ref="gaef00b87c7e436b0f465d8a0fa6de1812" args="(const allocator_type &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::unordered_multiset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#gaae360f67451062d24aaf29b12435026d">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an empty unordered multi-set that uses the specified <code>allocator</code> to supply memory. Use a default-constructed object of type <code>hasher</code> to generate hash values for the key extracted from the values contained in this object. Also, use a default-constructed object of type <code>key_equal</code> to verify that two key values are the same. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>allocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. </p>

</div>
</div>
<a class="anchor" id="ga2df4d6dfb7bee8ce75457c4badc30eea"></a><!-- doxytag: member="bsl::unordered_multiset::unordered_multiset" ref="ga2df4d6dfb7bee8ce75457c4badc30eea" args="(const unordered_multiset &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::unordered_multiset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga349f384ceb67ee28e6182c04b6da24b6"></a><!-- doxytag: member="bsl::unordered_multiset::unordered_multiset" ref="ga349f384ceb67ee28e6182c04b6da24b6" args="(const unordered_multiset &amp;original, const allocator_type &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::unordered_multiset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#gaae360f67451062d24aaf29b12435026d">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an unordered set having the same value as that of the specified <code>original</code>. Use a default-constructed object of type <code>hasher</code> to generate hash values for the key extracted from the values contained in this object. Also, use a default-constructed object of type <code>key_equal</code> to verify that two key values are the same. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not supplied, a default-constructed object of type <code>allocator_type</code> is used. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>allocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. </p>

</div>
</div>
<a class="anchor" id="ga3fa2df8bb116f037a4678b94cbc2dc17"></a><!-- doxytag: member="bsl::unordered_multiset::unordered_multiset" ref="ga3fa2df8bb116f037a4678b94cbc2dc17" args="(INPUT_ITERATOR first, INPUT_ITERATOR last, size_type initialNumBuckets=0, const hasher &amp;hash=hasher(), const key_equal &amp;keyEqual=key_equal(), const allocator_type &amp;allocator=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::unordered_multiset </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultiset.html#ga63942086aa758ce662757507fcaa5679">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>initialNumBuckets</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#ga9440d0a963d0417b505ac78538723ff6">hasher</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hash</em> = <code><a class="el" href="group__bslstl__unorderedmultiset.html#ga9440d0a963d0417b505ac78538723ff6">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#gaa1232a18650d36bbc04857eafc86c23f">key_equal</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>keyEqual</em> = <code><a class="el" href="group__bslstl__unorderedmultiset.html#gaa1232a18650d36bbc04857eafc86c23f">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#gaae360f67451062d24aaf29b12435026d">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code><a class="el" href="group__bslstl__unorderedmultiset.html#gaae360f67451062d24aaf29b12435026d">allocator_type</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an empty unordered multi-set and insert each <code>value_type</code> object in the sequence starting at the specified <code>first</code> element, and ending immediately before the specified <code>last</code> element, ignoring those pairs having a key that appears earlier in the sequence. Optionally specify an <code>initialNumBuckets</code> indicating the initial size of the array of buckets of this container. If <code>initialNumBuckets</code> is not supplied, an implementation defined value is used. Optionally specify a <code>hasher</code> used to generate hash values for the keys extracted from the values contained in this object. If <code>hash</code> is not supplied, a default-constructed object of type <code>hasher</code> is used. Optionally specify a key-equality functor <code>keyEqual</code> used to verify that two key values are the same. If <code>keyEqual</code> is not supplied, a default-constructed object of type <code>key_equal</code> is used. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>allocator_type</code> is used. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>allocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the <code>allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>allocator</code> is not supplied, the currently installed default allocator will be used to supply memory. The (template parameter) type <code>INPUT_ITERATOR</code> shall meet the requirements of an input iterator defined in the C++11 standard [24.2.3] providing access to values of a type convertible to <code>value_type</code>. The behavior is undefined unless <code>first</code> and <code>last</code> refer to a sequence of valid values where <code>first</code> is at a position at or before <code>last</code>. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__unorderedmultiset.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__unorderedmultiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaacfede2a3e65b5b8f7b1c9183b442894"></a><!-- doxytag: member="bsl::unordered_multiset::~unordered_multiset" ref="gaacfede2a3e65b5b8f7b1c9183b442894" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::~unordered_multiset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga6686f51f409834c441401075ca04caa5"></a><!-- doxytag: member="bsl::unordered_multiset::operator=" ref="ga6686f51f409834c441401075ca04caa5" args="(const unordered_multiset &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unordered_multiset&amp; <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value, hasher, and key-equality functor of the specified <code>rhs</code> object, propagate to this object the allocator of <code>rhs</code> if the <code>ALLOCATOR</code> type has trait <code>propagate_on_container_copy_assignment</code>, and return a reference providing modifiable access to this object. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__unorderedmultiset.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__unorderedmultiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gabcf3ccf453abb529eb6eb94a8298bd20"></a><!-- doxytag: member="bsl::unordered_multiset::begin" ref="gabcf3ccf453abb529eb6eb94a8298bd20" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first <code>value_type</code> object (in the sequence of <code>value_type</code> objects) maintained by this multi-set, or the <code>end</code> iterator if this multi-set is empty. </p>

</div>
</div>
<a class="anchor" id="ga20b1466c185aa184bc50f04e53b7ae2d"></a><!-- doxytag: member="bsl::unordered_multiset::end" ref="ga20b1466c185aa184bc50f04e53b7ae2d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the past-the-end element in the sequence of <code>value_type</code> objects maintained by this set. </p>

</div>
</div>
<a class="anchor" id="ga2f6ec6ef03611c1d327368e372efff4f"></a><!-- doxytag: member="bsl::unordered_multiset::begin" ref="ga2f6ec6ef03611c1d327368e372efff4f" args="(size_type index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">local_iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultiset.html#ga63942086aa758ce662757507fcaa5679">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a local iterator providing modifiable access to the first <code>value_type</code> object in the sequence of <code>value_type</code> objects of the bucket having the specified <code>index</code>, in the array of buckets maintained by this multi-set, or the <code>end(index)</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga422727341b9f8b6033218d7039a49cc8"></a><!-- doxytag: member="bsl::unordered_multiset::end" ref="ga422727341b9f8b6033218d7039a49cc8" args="(size_type index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">local_iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultiset.html#ga63942086aa758ce662757507fcaa5679">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a local iterator providing modifiable access to the past-the-end element in the sequence of <code>value_type</code> objects of the bucket having the specified <code>index</code>s, in the array of buckets maintained by this multi-set. </p>

</div>
</div>
<a class="anchor" id="ga9bb8383caf31e8ce28e44050f48d06d2"></a><!-- doxytag: member="bsl::unordered_multiset::clear" ref="ga9bb8383caf31e8ce28e44050f48d06d2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all entries from this multi-set. Note that the container is empty after this call, but allocated memory may be retained for future use. </p>

</div>
</div>
<a class="anchor" id="ga60c5b73f7a685f6d38ac4713ec348db1"></a><!-- doxytag: member="bsl::unordered_multiset::equal_range" ref="ga60c5b73f7a685f6d38ac4713ec348db1" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;iterator, iterator&gt; <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#gac224ab4e150a21c2ed661131cfa487f7">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pair of iterators providing modifiable access to the sequence of <code>value_type</code> objects in this multi-set having the specified <code>key</code>, where the the first iterator is positioned at the start of the sequence, and the second is positioned one past the end of the sequence. If this multi-set contains no <code>value_type</code> objects having <code>key</code>, then the two returned iterators will have the same value. </p>

</div>
</div>
<a class="anchor" id="ga22ccf66a87c544193f31fedc8ee07030"></a><!-- doxytag: member="bsl::unordered_multiset::erase" ref="ga22ccf66a87c544193f31fedc8ee07030" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#gac224ab4e150a21c2ed661131cfa487f7">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this multi-set all <code>value_type</code> objects having the specified <code>key</code>, if they exist, and return the number of object erased; otherwise, if there is no <code>value_type</code> object having <code>key</code>, return 0 with no other effect. </p>

</div>
</div>
<a class="anchor" id="ga4678a57f98c8e6044bb7a6e68c3a7cf9"></a><!-- doxytag: member="bsl::unordered_multiset::erase" ref="ga4678a57f98c8e6044bb7a6e68c3a7cf9" args="(const_iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this multi-set the <code>value_type</code> object at the specified <code>position</code>, and return an iterator referring to the element immediately following the removed element, or to the past-the-end position if the removed element was the last element in the sequence of elements maintained by this multi-set. The behavior is undefined unless <code>position</code> refers to a <code>value_type</code> object in this multi-set. </p>

</div>
</div>
<a class="anchor" id="ga6552a8447b885db853e0c200b96b39c5"></a><!-- doxytag: member="bsl::unordered_multiset::erase" ref="ga6552a8447b885db853e0c200b96b39c5" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from multi-set the <code>value_type</code> objects starting at the specified <code>first</code> position up to, but including the specified <code>last</code> position, and return <code>last</code>. The behavior is undefined unless <code>first</code> and <code>last</code> either refer to elements in multi-set or are the <code>end</code> iterator, and the <code>first</code> position is at or before the <code>last</code> position in the ordered sequence provided by this container. </p>

</div>
</div>
<a class="anchor" id="gaf9176db44a333499c12297f1790e2e37"></a><!-- doxytag: member="bsl::unordered_multiset::find" ref="gaf9176db44a333499c12297f1790e2e37" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#gac224ab4e150a21c2ed661131cfa487f7">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first <code>value_type</code> objects in the sequence of all the value-elements of this multi-set having the specified <code>key</code>, if such value-elements exist, and the past-the-end (<code>end</code>) iterator otherwise. </p>

</div>
</div>
<a class="anchor" id="gada2fc1827dca0d8105df43299fffe1b0"></a><!-- doxytag: member="bsl::unordered_multiset::insert" ref="gada2fc1827dca0d8105df43299fffe1b0" args="(const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#ga0f6d3b101c9a7c7e57422ddae8d0f36f">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into multi-set; if a <code>value_type</code> object having the same key (according to <code>key_equal</code>) as <code>value</code> already exists in multi-set, the operation is guaranteed to insert <code>value</code> in a position contiguous to another value having the same key. Return an iterator referring to the <code>value_type</code> object inserted. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__unorderedmultiset.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__unorderedmultiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga922e044e65efca8cf29b7af48745a570"></a><!-- doxytag: member="bsl::unordered_multiset::insert" ref="ga922e044e65efca8cf29b7af48745a570" args="(const_iterator hint, const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBloombergLP_1_1bslstl_1_1HashTableIterator.html">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#ga0f6d3b101c9a7c7e57422ddae8d0f36f">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into multi-set (in constant time if the specified <code>hint</code> is a valid element in the bucket to which <code>value</code> belongs); if a <code>value_type</code> object having the same key (according to <code>key_equal</code>) as <code>value</code> already exists in this set, this method is guaranteed to insert <code>value</code> in a position contiguous to another value in the set having the same key. Return an iterator referring to the newly inserted <code>value_type</code> object. If <code>hint</code> is not a position in the bucket of the key of <code>value</code>, this operation will have worst case O[N] and average case constant time complexity, where <code>N</code> is the size of multi-set. The behavior is undefined unless <code>hint</code> is a valid iterator into this unordered multi set. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__unorderedmultiset.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__unorderedmultiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaad1d261c49953523eaafaec248e069b6"></a><!-- doxytag: member="bsl::unordered_multiset::insert" ref="gaad1d261c49953523eaafaec248e069b6" args="(INPUT_ITERATOR first, INPUT_ITERATOR last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert into multi-set the value of each <code>value_type</code> object in the range starting at the specified <code>first</code> iterator and ending immediately before the specified <code>last</code> iterator. The (template parameter) type <code>INPUT_ITERATOR</code> shall meet the requirements of an input iterator defined in the C++11 standard [24.2.3] providing access to values of a type convertible to <code>value_type</code>. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__unorderedmultiset.html#requirements_on_key.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__unorderedmultiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga21fe5c8de29ae3777a089452af5649e7"></a><!-- doxytag: member="bsl::unordered_multiset::max_load_factor" ref="ga21fe5c8de29ae3777a089452af5649e7" args="(float newLoadFactor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>newLoadFactor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the maximum load factor of this container to the specified <code>newLoadFactor</code>. </p>

</div>
</div>
<a class="anchor" id="ga7490229d445297136270d56629443a3a"></a><!-- doxytag: member="bsl::unordered_multiset::rehash" ref="ga7490229d445297136270d56629443a3a" args="(size_type numBuckets)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultiset.html#ga63942086aa758ce662757507fcaa5679">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numBuckets</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the size of the array of buckets maintained by this container to the specified <code>numBuckets</code>, and redistribute all the contained elements into the new sequence of buckets, according to their hash values. Note that this operation has no effect if rehashing the elements into <code>numBuckets</code> would cause multi-set to exceed its <code>max_load_factor</code>. </p>

</div>
</div>
<a class="anchor" id="ga04a79bc05088eaae96aa76d8b2593735"></a><!-- doxytag: member="bsl::unordered_multiset::reserve" ref="ga04a79bc05088eaae96aa76d8b2593735" args="(size_type numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultiset.html#ga63942086aa758ce662757507fcaa5679">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increase the number of buckets of multi-set to a quantity such that the ratio between the specified <code>numElements</code> and this quantity does not exceed <code>max_load_factor</code>. </p>

</div>
</div>
<a class="anchor" id="ga13c5b72c68c73b67bcf83932ddf8f288"></a><!-- doxytag: member="bsl::unordered_multiset::swap" ref="ga13c5b72c68c73b67bcf83932ddf8f288" args="(unordered_multiset &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this object as well as its hasher and key-equality functor with those of the specified <code>other</code> object. Additionally if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code> then exchange the allocator of this object with that of the <code>other</code> object, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee and guarantees O[1] complexity. The behavior is undefined is unless either this object was created with the same allocator as <code>other</code> or <code>propagate_on_container_swap</code> is <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="ga9da01b4e4d448a24dfdd54bdacb21f5f"></a><!-- doxytag: member="bsl::unordered_multiset::begin" ref="ga9da01b4e4d448a24dfdd54bdacb21f5f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> object (in the sequence of <code>value_type</code> objects) maintained by this multi-set, or the <code>end</code> iterator if this multi-set is empty. </p>

</div>
</div>
<a class="anchor" id="gaad28eaba37020d055f466e0226be3859"></a><!-- doxytag: member="bsl::unordered_multiset::end" ref="gaad28eaba37020d055f466e0226be3859" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the past-the-end element (in the sequence of <code>value_type</code> objects) maintained by this multi-set. </p>

</div>
</div>
<a class="anchor" id="ga2969a1eb476105bc78c550bc36365a0c"></a><!-- doxytag: member="bsl::unordered_multiset::cbegin" ref="ga2969a1eb476105bc78c550bc36365a0c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> object (in the sequence of <code>value_type</code> objects) maintained by this multi-set, or the <code>end</code> iterator if this multi-set is empty. </p>

</div>
</div>
<a class="anchor" id="gabdf1ff49beccf1dd68cfce1bf96147a8"></a><!-- doxytag: member="bsl::unordered_multiset::cend" ref="gabdf1ff49beccf1dd68cfce1bf96147a8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the past-the-end element (in the sequence of <code>value_type</code> objects) maintained by this multi-set. </p>

</div>
</div>
<a class="anchor" id="gac4dc1420ef10eaf8dd6e04e7606d9a14"></a><!-- doxytag: member="bsl::unordered_multiset::begin" ref="gac4dc1420ef10eaf8dd6e04e7606d9a14" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_local_iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultiset.html#ga63942086aa758ce662757507fcaa5679">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a local iterator providing non-modifiable access to the first <code>value_type</code> object (in the sequence of <code>value_type</code> objects) of the bucket having the specified <code>index</code> in the array of buckets maintained by this multi-set, or the <code>end(index)</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga66425a3c3945f80dd593ec18af93ab82"></a><!-- doxytag: member="bsl::unordered_multiset::end" ref="ga66425a3c3945f80dd593ec18af93ab82" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_local_iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultiset.html#ga63942086aa758ce662757507fcaa5679">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a local iterator providing non-modifiable access to the past-the-end element (in the sequence of <code>value_type</code> objects) of the bucket having the specified <code>index</code> in the array of buckets maintained by this multi-set. </p>

</div>
</div>
<a class="anchor" id="gabdb73949d750c74a9c6ff63f0ba00cde"></a><!-- doxytag: member="bsl::unordered_multiset::cbegin" ref="gabdb73949d750c74a9c6ff63f0ba00cde" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_local_iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultiset.html#ga63942086aa758ce662757507fcaa5679">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a local iterator providing non-modifiable access to the first <code>value_type</code> object (in the sequence of <code>value_type</code> objects) of the bucket having the specified <code>index</code> in the array of buckets maintained by multi-set, or the <code>end(index)</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga2dabab4d32a496d89286e5cf91933ffd"></a><!-- doxytag: member="bsl::unordered_multiset::cend" ref="ga2dabab4d32a496d89286e5cf91933ffd" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_local_iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultiset.html#ga63942086aa758ce662757507fcaa5679">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a local iterator providing non-modifiable access to the past-the-end element (in the sequence of <code>value_type</code> objects) of the bucket having the specified <code>index</code> in the array of buckets maintained by multi-set. </p>

</div>
</div>
<a class="anchor" id="ga15b8e3739ba5c0bd7b532b81cc6e9db4"></a><!-- doxytag: member="bsl::unordered_multiset::bucket" ref="ga15b8e3739ba5c0bd7b532b81cc6e9db4" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::bucket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#gac224ab4e150a21c2ed661131cfa487f7">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the bucket, in the array of buckets of this container, where values having the specified <code>key</code> would be inserted. </p>

</div>
</div>
<a class="anchor" id="ga5cee093bfcc096b13d908b69074d96c7"></a><!-- doxytag: member="bsl::unordered_multiset::bucket_count" ref="ga5cee093bfcc096b13d908b69074d96c7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of buckets in the array of buckets maintained by multi-set. </p>

</div>
</div>
<a class="anchor" id="gac7daa1447baa7526a9b266531ddf276e"></a><!-- doxytag: member="bsl::unordered_multiset::bucket_size" ref="gac7daa1447baa7526a9b266531ddf276e" args="(size_type index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::bucket_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__unorderedmultiset.html#ga63942086aa758ce662757507fcaa5679">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements contained in the bucket at the specified <code>index</code> in the array of buckets maintained by this container. </p>

</div>
</div>
<a class="anchor" id="ga041cef546e2d0dc73a4fcb821f0ce907"></a><!-- doxytag: member="bsl::unordered_multiset::count" ref="ga041cef546e2d0dc73a4fcb821f0ce907" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#gac224ab4e150a21c2ed661131cfa487f7">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of <code>value_type</code> objects within this map having the specified <code>key</code>. Note that since an unordered set maintains unique keys, the returned value will be either 0 or 1. </p>

</div>
</div>
<a class="anchor" id="gab84206cf24f95031d7d5579e13d0d9b9"></a><!-- doxytag: member="bsl::unordered_multiset::empty" ref="gab84206cf24f95031d7d5579e13d0d9b9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if multi-set contains no elements, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga568005ff5479dd5f975af1c8813d4c90"></a><!-- doxytag: member="bsl::unordered_multiset::equal_range" ref="ga568005ff5479dd5f975af1c8813d4c90" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;const_iterator, const_iterator&gt; <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#gac224ab4e150a21c2ed661131cfa487f7">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pair of iterators providing non-modifiable access to the sequence of <code>value_type</code> objects in this container having the specified <code>key</code>, where the the first iterator is positioned at the start of the sequence and the second iterator is positioned one past the end of the sequence. If multi-set contains no <code>value_type</code> objects having <code>key</code> then the two returned iterators will have the same value. Note that since a set maintains unique keys, the range will contain at most one element. </p>

</div>
</div>
<a class="anchor" id="gae6feb2f63680850962f7d96e69bab0d7"></a><!-- doxytag: member="bsl::unordered_multiset::find" ref="gae6feb2f63680850962f7d96e69bab0d7" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__unorderedmultiset.html#gac224ab4e150a21c2ed661131cfa487f7">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> objects in the sequence of value-elements of this multi-set having the specified <code>key</code>, if such value-elements exist, and the past-the-end (<code>end</code>) iterator otherwise. </p>

</div>
</div>
<a class="anchor" id="ga4800b08398981061d5555d024d7b6ec4"></a><!-- doxytag: member="bsl::unordered_multiset::get_allocator" ref="ga4800b08398981061d5555d024d7b6ec4" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return (a copy of) the allocator used for memory allocation by this set. </p>

</div>
</div>
<a class="anchor" id="ga72f193ce1423c9a34fe7b2a5620afd0e"></a><!-- doxytag: member="bsl::unordered_multiset::key_eq" ref="ga72f193ce1423c9a34fe7b2a5620afd0e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">key_equal <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return (a copy of) the key-equality binary functor that returns <code>true</code> if the value of two <code>key_type</code> objects is the same, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga5c65f0f02bba42f56eaaf6d551c5384c"></a><!-- doxytag: member="bsl::unordered_multiset::hash_function" ref="ga5c65f0f02bba42f56eaaf6d551c5384c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">hasher <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return (a copy of) the hash unary functor used by multi-set to generate a hash value (of type <code>size_t</code>) for a <code>key_type</code> object. </p>

</div>
</div>
<a class="anchor" id="ga58c97fcd33e7fef69749dab83056ff5a"></a><!-- doxytag: member="bsl::unordered_multiset::load_factor" ref="ga58c97fcd33e7fef69749dab83056ff5a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current ratio between the <code>size</code> of this container and the number of buckets. The <code>load_factor</code> is a measure of how full the container is, and a higher load factor leads to an increased number of collisions, thus resulting in a loss performance. </p>

</div>
</div>
<a class="anchor" id="ga3aefba0c5698b92b0d97321cd3dc5a17"></a><!-- doxytag: member="bsl::unordered_multiset::max_bucket_count" ref="ga3aefba0c5698b92b0d97321cd3dc5a17" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a theoretical upper bound on the largest number of buckets that this container could possibly manage. Note that there is no guarantee that the set can successfully grow to the returned size, or even close to that size without running out of resources. </p>

</div>
</div>
<a class="anchor" id="ga3f22a1939b2354121a588c7a264488e5"></a><!-- doxytag: member="bsl::unordered_multiset::max_load_factor" ref="ga3f22a1939b2354121a588c7a264488e5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum load factor allowed for this container. If an insert operation would cause <code>load_factor</code> to exceed the <code>max_load_factor</code>, that same insert operation will increase the number of buckets and rehash the elements of the container into those buckets the (see rehash). </p>

</div>
</div>
<a class="anchor" id="ga2050a59b28aa1cc71956c3883f24feb7"></a><!-- doxytag: member="bsl::unordered_multiset::max_size" ref="ga2050a59b28aa1cc71956c3883f24feb7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a theoretical upper bound on the largest number of elements that multi-set could possibly hold. Note that there is no guarantee that the set can successfully grow to the returned size, or even close to that size without running out of resources. </p>

</div>
</div>
<a class="anchor" id="gaf9dff7a2cfd07d6703839f1999a9a55e"></a><!-- doxytag: member="bsl::unordered_multiset::size" ref="gaf9dff7a2cfd07d6703839f1999a9a55e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset</a>&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements in multi-set. </p>

</div>
</div>
<a class="anchor" id="ga8e9c9a9220ff75ddc73acee85bfa7392"></a><!-- doxytag: member="bsl::operator==" ref="ga8e9c9a9220ff75ddc73acee85bfa7392" args="(const unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> objects have the same value if they have the same number of value-elements, and for each value-element that is contained in <code>lhs</code> there is a value-element contained in <code>rhs</code> having the same value, and vice-versa. This method requires that the (template parameter) type <code>KEY</code> be <a href="group__bslstl__unorderedmultiset.html#requirements_on_key.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__unorderedmultiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gae0f2b56046e1efc815e5637ed81ce7a8"></a><!-- doxytag: member="bsl::operator!=" ref="gae0f2b56046e1efc815e5637ed81ce7a8" args="(const unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;lhs, const unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a></code> objects do not have the same value if they do not have the same number of value-elements, or that for some value-element contained in <code>lhs</code> there is not a value-element in <code>rhs</code> having the same value, and vice-versa. This method requires that the (template parameter) type <code>KEY</code> and be <a href="group__bslstl__unorderedmultiset.html#requirements_on_key.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__unorderedmultiset.html#requirements_on_key" class="el">Requirements on <code>KEY</code></a>). </p>

</div>
</div>
<a class="anchor" id="gad7ead0881f1289594de31f274644e068"></a><!-- doxytag: member="bsl::swap" ref="gad7ead0881f1289594de31f274644e068" args="(unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;x, unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class HASH , class EQUAL , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap both the value and the comparator of the specified <code>a</code> object with the value and comparator of the specified <code>b</code> object. The behavior is undefined is unless this object was created with the same allocator as <code>other</code>. Additionally if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code> then exchange the allocator of <code>a</code> with that of <code>b</code>, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee and guarantees O[1] complexity. The behavior is undefined is unless either this object was created with the same allocator as <code>other</code> or <code>propagate_on_container_swap</code> is <code>true</code>. </p>

</div>
</div>
<hr/><h2>Friends</h2>
<a class="anchor" id="ga8fd1815e1d9cb199648873d1c0913e46"></a><!-- doxytag: member="bsl::unordered_multiset::operator==" ref="ga8fd1815e1d9cb199648873d1c0913e46" args="(const unordered_multiset&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;, const unordered_multiset&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KEY2 , class HASH2 , class EQUAL2 , class ALLOCATOR2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8fd1815e1d9cb199648873d1c0913e46"></a><!-- doxytag: member="bsl::unordered_multiset::operator==" ref="ga8fd1815e1d9cb199648873d1c0913e46" args="(const unordered_multiset&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;, const unordered_multiset&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class HASH = bsl::hash&lt;KEY&gt;, class EQUAL = bsl::equal_to&lt;KEY&gt;, class ALLOCATOR = bsl::allocator&lt;KEY&gt;&gt; </div>
<div class="memtemplate">
template&lt;class KEY2 , class HASH2 , class EQUAL2 , class ALLOCATOR2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1unordered__multiset.html">unordered_multiset</a>&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:44 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
