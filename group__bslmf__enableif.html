<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslmf_enableif Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<h1>Component bslmf_enableif<br/>
<small>
[<a class="el" href="group__bslmf.html">Package bslmf</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a utility to set up SFINAE conditions in type deduction.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if&lt; COND, TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1enable__if_3_01false_00_01TYPE_01_4.html">bsl::enable_if&lt; false, TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslmf_1_1EnableIf_3_01false_00_01BSLMA__TYPE_01_4.html">bslmf::EnableIf&lt; false, BSLMA_TYPE &gt;</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Visual Studio Workaround</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Implementing a Simple Function with <code>bsl::enable_if</code></a> </li>
<li>
<a href="#3.2.2">Example 2: Using the <code>bsl::enable_if</code> Result Type</a> </li>
<li>
<a href="#3.2.3">Example 3: Controlling Constructor Selection with <code>bsl::enable_if</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a utility to set up SFINAE conditions in type deduction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a> </td><td>standard meta-function to drop function templates from  </td></tr>
</table>
overload sets </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="el" href="structbslmf_1_1EnableIf.html">bslmf::EnableIf</a>: meta-function to drop function templates from overload sets </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines two meta-functions, <code><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a></code> and <code><a class="el" href="structbslmf_1_1EnableIf.html">bslmf::EnableIf</a></code>, both of which may be used to conditionally remove (potential) template instantiations as candidates for overload resolution by causing a deduced template instantiation to fail in a way compatible with the C++ SFINAE rules. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a></code> meets the requirements of the <code><a class="el" href="structbsl_1_1enable__if.html">enable_if</a></code> template defined in the C++11 standard [meta.trans.ptr], while <code><a class="el" href="structbslmf_1_1EnableIf.html">bslmf::EnableIf</a></code> was devised before <code><a class="el" href="structbsl_1_1enable__if.html">enable_if</a></code> was standardized. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The two meta-functions provide identical functionality. Both meta-functions provide a <code>typedef</code> <code>type</code> that is an alias to a (template parameter) type if a (template parameter) condition is <code>true</code>; otherwise, <code>type</code> is not provided. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that <code><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a></code> should be preferred over <code><a class="el" href="structbslmf_1_1EnableIf.html">bslmf::EnableIf</a></code>, and in general, should be used by new components. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="visual_studio_workaround"></a> <a class="anchor" id="description.visual_studio_workaround"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Visual Studio Workaround: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Because of a Visual Studio bug, described here: <a href="http://connect.microsoft.com/VisualStudio/feedback/details/332179/">http://connect.microsoft.com/VisualStudio/feedback/details/332179/</a> The Microsoft Visual Studio compiler may not correctly associate a function declaration that uses <code><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a></code> with that function's definition, if the definition is not inline to the declaration. This bug effects at least Visual Studio 2008 and 2010. The work-around is to implement functions using <code><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a></code> in-line with their declaration. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippets of code illustrate basic use of the <code><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a></code> meta-function. We will demonstrate how to use this utility to control overload sets with three increasingly complex examples. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Implementing a Simple Function with bsl::enable_if: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>For the first example we will implement a simple <code>Swap</code> function template to exchange two arbitrary values, as if declared as below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  <span class="keywordtype">void</span> DummySwap(T&amp; a, T&amp; b)
      <span class="comment">// Exchange the values of the specified objects, &#39;a&#39; and &#39;b&#39;.</span>
  {
      T temp(a);
      a = b;
      b = temp;
  }
</pre></div><br/>
<br/>
 However, we want to take advantage of member-swap methods supplied by user- defined types, so we define a trait that can be customized by a class implementer to indicate that their class supports an optimized member-swap method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  <span class="keyword">struct </span>HasMemberSwap : bsl::<a class="code" href="namespacebsl.html#a072205c212218b4b4cccaf66052c99a4">false_type</a> {
      <span class="comment">// This traits class indicates whether the specified template type</span>
      <span class="comment">// parameter &#39;T&#39; has a public &#39;swap&#39; method to exchange values.</span>
  };
</pre></div><br/>
<br/>
 Now we can implement a generic <code>Swap</code> function template that will invoke the member swap operation for any type that specialized our trait. The use of <code><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a></code> to declare the result type causes an attempt to deduce the type <code>T</code> to fail unless the specified condition is <code>true</code>, and this falls under the "Substitution Failure Is Not An Error" (SFINAE) clause of the C++ standard, so the compiler will look for a more suitable overload rather than fail with an error. Note that we provide two overloaded declarations that appear to differ only in their return type, which would normally raise an ambiguity error. This works, and is in fact required, in this case as the "enable-if" conditions are mutually exclusive, so that only one overload will ever be present in an overload set. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  <span class="keyword">typename</span> <a class="code" href="structbsl_1_1enable__if.html">bsl::enable_if&lt;HasMemberSwap&lt;T&gt;::value</a>&gt;<a class="code" href="classBloombergLP_1_1bslmf_1_1IsConvertible__Imp_1_1type.html">::type</a>
  Swap(T&amp; a, T&amp; b)
  {
      a.swap(b);
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  <span class="keyword">typename</span> <a class="code" href="structbsl_1_1enable__if.html">bsl::enable_if&lt; ! HasMemberSwap&lt;T&gt;::value</a>&gt;<a class="code" href="classBloombergLP_1_1bslmf_1_1IsConvertible__Imp_1_1type.html">::type</a>
  Swap(T&amp; a, T&amp; b)
  {
      T temp(a);
      a = b;
      b = temp;
  }
</pre></div><br/>
<br/>
 Next we define a simple container template, that supports an optimized <code>swap</code> operation by merely swapping the internal pointers, rather than exchanging each element: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  <span class="keyword">class </span>MyContainer {
      <span class="comment">// This is a simple container implementation for demonstration purposes</span>
      <span class="comment">// that is modeled after &#39;std::vector&#39;.</span>

      <span class="comment">// DATA</span>
      T           *d_storage;
      std::size_t  d_length;

      <span class="comment">// NOT IMPLEMENTED</span>
      MyContainer(<span class="keyword">const</span> MyContainer&amp;);
      MyContainer&amp; operator=(<span class="keyword">const</span> MyContainer&amp;);

  <span class="keyword">public</span>:
      MyContainer(<span class="keyword">const</span> T&amp; value, <span class="keywordtype">int</span> n);
          <span class="comment">// Create a &#39;MyContainer&#39; object having the specified &#39;n&#39; copies of</span>
          <span class="comment">// the specified &#39;value&#39;.</span>

      ~MyContainer();
          <span class="comment">// Destroy this container and all of its elements, reclaiming any</span>
          <span class="comment">// allocated memory.</span>

      <span class="keywordtype">void</span> <a class="code" href="group__bslstl__deque.html#ga4ffc73dd2ce1f86230d22d2284773f1d">swap</a>(MyContainer &amp;other);
          <span class="comment">// Exchange the contents of &#39;this&#39; container with those of the</span>
          <span class="comment">// specified &#39;other&#39;.  No memory will be allocated, and no</span>
          <span class="comment">// exceptions are thrown.</span>

      <span class="keyword">const</span> T&amp; front() <span class="keyword">const</span>;
          <span class="comment">// Return a reference with &#39;const&#39; access to the first element in</span>
          <span class="comment">// this container.</span>

      <span class="keywordtype">size_t</span> size() <span class="keyword">const</span>;
          <span class="comment">// Return the number of elements held by this container.</span>
  };
</pre></div><br/>
<br/>
 Then we specialize our <code>HasMemberSwap</code> trait for this new container type. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  <span class="keyword">struct </span>HasMemberSwap&lt;MyContainer&lt;T&gt; &gt; : bsl::<a class="code" href="namespacebsl.html#a124171e6663dfc2b3c10256844c8dc3b">true_type</a> {
  };
</pre></div><br/>
<br/>
 Next we implement the methods of this class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  MyContainer&lt;T&gt;::MyContainer(<span class="keyword">const</span> T&amp; value, <span class="keywordtype">int</span> n)
  : d_storage(new T[n])
  , d_length(n)
  {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i !=n; ++i) {
          d_storage[i] = value;
      }
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  MyContainer&lt;T&gt;::~MyContainer()
  {
      <span class="keyword">delete</span>[] d_storage;
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  <span class="keywordtype">void</span> <a class="code" href="namespacebslalg.html#aaa5e9eab8ebf1a94de3cf3db2c4d10c1">MyContainer&lt;T&gt;::swap</a>(MyContainer&amp; other)
  {
      Swap(d_storage, other.d_storage);
      Swap(d_length,  other.d_length);
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  <span class="keyword">const</span> T&amp; MyContainer&lt;T&gt;::front()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_storage[0];
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  <span class="keywordtype">size_t</span> MyContainer&lt;T&gt;::size()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_length;
  }
</pre></div><br/>
<br/>
 Finally we can test that the member-'swap' method is called by the generic <code>Swap</code> function. Note that the following code will not compile unless the member-function <code>swap</code> is used, as the copy constructor and assignment operator for the <code>MyContainer</code> class template are declared as private. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> TestSwap()
  {
      MyContainer&lt;int&gt; x(3, 14);
      MyContainer&lt;int&gt; y(2, 78);
      assert(14 == x.size());
      assert( 3 == x.front());
      assert(78 == y.size());
      assert( 2 == y.front());

      Swap(x, y);

      assert(78 == x.size());
      assert( 2 == x.front());
      assert(14 == y.size());
      assert( 3 == y.front());
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Using the bsl::enable_if Result Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>For the next example, we will demonstrate the use of the second template parameter in the <code><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a></code> template, which serves as the "result" type if the test condition passes. Assume we want to write a generic function to allow us to cast between pointers of different types. If the types are polymorphic, we can use <code>dynamic_cast</code> to potentially cast between two seemingly unrelated types. However, if either type is not polymorphic then the attempt to use <code>dynamic_cast</code> would be a compile-time failure, and we must use <code>static_cast</code> instead. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> TO, <span class="keyword">class</span> FROM&gt;
  <span class="keyword">typename</span> <a class="code" href="structbsl_1_1enable__if.html">bsl::enable_if&lt;bsl::is_polymorphic&lt;FROM&gt;::value</a> &amp;&amp;
                                              <a class="code" href="structbsl_1_1is__polymorphic.html">bsl::is_polymorphic&lt;TO&gt;::value</a>,
                          TO&gt;<a class="code" href="classBloombergLP_1_1bslmf_1_1IsConvertible__Imp_1_1type.html">::type</a> *
  smart_cast(FROM *from)
      <span class="comment">// Returns a pointer to the specified &#39;TO&#39; type if the specified &#39;from&#39;</span>
      <span class="comment">// pointer refers to an object whose complete class publicly derives,</span>
      <span class="comment">// directly or indirectly, from &#39;TO&#39;, and a null pointer otherwise.</span>
  {
      <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span>TO *<span class="keyword">&gt;</span>(from);
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> TO, <span class="keyword">class</span> FROM&gt;
  <span class="keyword">typename</span> <a class="code" href="structbsl_1_1enable__if.html">bsl::enable_if&lt;not(bsl::is_polymorphic&lt;FROM&gt;::value</a> &amp;&amp;
                                             bsl::is_polymorphic&lt;TO&gt;::value),
                          TO&gt;::<a class="code" href="classBloombergLP_1_1bslmf_1_1IsConvertible__Imp_1_1type.html">type</a> *
  smart_cast(FROM *from)
      <span class="comment">// Return the specified &#39;from&#39; pointer value cast as a pointer to type</span>
      <span class="comment">// &#39;TO&#39;.  Behavior is undefined unless such a conversion is valid.</span>
  {
      <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>TO *<span class="keyword">&gt;</span>(from);
  }
</pre></div><br/>
<br/>
 Next we define a small number of classes to demonstrate that this casting utility works correctly: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>A {
     <span class="comment">// Sample non-polymorphic class</span>

    <span class="keyword">public</span>:
      ~A() {}
  };

  <span class="keyword">class </span>B {
      <span class="comment">// Sample polymorphic base-class</span>

    <span class="keyword">public</span>:
      <span class="keyword">virtual</span> ~B() {}
  };

  <span class="keyword">class </span>C {
      <span class="comment">// Sample polymorphic base-class</span>

    <span class="keyword">public</span>:
      <span class="keyword">virtual</span> ~C() {}
  };

  <span class="keyword">class </span>ABC : <span class="keyword">public</span> A, <span class="keyword">public</span> B, <span class="keyword">public</span> C {
      <span class="comment">// Most-derived example class using multiple bases in order to</span>
      <span class="comment">// demonstrate cross-casting.</span>
  };
</pre></div><br/>
<br/>
 Finally we demonstrate the correct behavior of the <code>smart_cast</code> utility: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> TestSmartCast()
  {
      ABC object;
      ABC *pABC = &amp;object;
      A   *pA   = &amp;object;
      B   *pB   = &amp;object;
      C   *pC   = &amp;object;

      A *pA2 = smart_cast&lt;A&gt;(pABC);
      B *pB2 = smart_cast&lt;B&gt;(pC);
      C *pC2 = smart_cast&lt;C&gt;(pB);

      assert(&amp;<span class="keywordtype">object</span> == pA2);
      assert(&amp;<span class="keywordtype">object</span> == pB2);
      assert(&amp;<span class="keywordtype">object</span> == pC2);

      <span class="comment">// These lines would fail to compile</span>
      <span class="comment">// A *pA3 = smart_cast&lt;A&gt;(pB);</span>
      <span class="comment">// C *pC3 = smart_cast&lt;C&gt;(pA);</span>
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.2.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Controlling Constructor Selection with bsl::enable_if: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The final example demonstrates controlling the selection of a constructor template in a class with (potentially) many constructors. We define a simple container template based on <code>std::vector</code>, that illustrates a problem that may occur when trying to call the constructor the user expects. For this example, assume we are trying to create a <code>vector&lt;int&gt;</code> with <code>42</code> copies of the value <code>13</code>. When we pass the literal values <code>42</code> and <code>13</code> the compiler, the "best" candidate constructor should be the template constructor that takes two arguments of the same kind, deducing that type to be <code>int</code>. Unfortunately, that constructor expects those values to be of an iterator type, forming a valid range. We need to avoid calling this constructor unless the deduced type really is an iterator, otherwise a compile-error will occur trying to instantiate that constructor with an incompatible argument type. We use <code><a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a></code> to create a deduction context where SFINAE can kick in. Note that we cannot deduce the <code>::type</code> result of a metafunction, and there is no result type (as with a regular function) to decorate, so we add an extra dummy argument using a pointer type (produced from <code>bslma::EnableIf::type</code>) with a default null argument: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  <span class="keyword">class </span>MyVector {
      <span class="comment">// This is a simple container implementation for demonstration purposes</span>
      <span class="comment">// that is modeled after &#39;std::vector&#39;.</span>

      <span class="comment">// DATA</span>
      T           *d_storage;
      std::size_t  d_length;

      <span class="comment">// NOT IMPLEMENTED</span>
      MyVector(<span class="keyword">const</span> MyVector&amp;);
      MyVector&amp; operator=(<span class="keyword">const</span> MyVector&amp;);

  <span class="keyword">public</span>:
      MyVector(<span class="keyword">const</span> T&amp; value, <span class="keywordtype">int</span> n);
          <span class="comment">// Create a &#39;MyVector&#39; object having the specified &#39;n&#39; copies of</span>
          <span class="comment">// the specified &#39;value&#39;.</span>

      <span class="keyword">template</span>&lt;<span class="keyword">typename</span> FORWARD_ITERATOR&gt;
      MyVector(FORWARD_ITERATOR first, FORWARD_ITERATOR last,
                  <span class="keyword">typename</span> <a class="code" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt;
                      !<a class="code" href="structbsl_1_1is__fundamental.html">bsl::is_fundamental&lt;FORWARD_ITERATOR&gt;::value</a>
                                                               &gt;::<a class="code" href="classBloombergLP_1_1bslmf_1_1IsConvertible__Imp_1_1type.html">type</a> * = 0)
          <span class="comment">// Create a &#39;MyVector&#39; object having the same sequence of values as</span>
          <span class="comment">// found in range described by the iterators &#39;[first, last)&#39;.</span>
          <span class="comment">// Note that this function is currently defined inline to work</span>
          <span class="comment">// around an issue with the Microsoft Visual Studio compiler.</span>

      {
          d_length = 0;
          <span class="keywordflow">for</span> (FORWARD_ITERATOR cursor = first; cursor != last; ++cursor) {
               ++d_length;
          }

         d_storage = <span class="keyword">new</span> T[d_length];
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i != d_length; ++i) {
            d_storage[i] = *first++;
         }
      }

      ~MyVector();
          <span class="comment">// Destroy this container and all of its elements, reclaiming any</span>
          <span class="comment">// allocated memory.</span>

      <span class="keyword">const</span> T&amp; operator[](<span class="keywordtype">int</span> index) <span class="keyword">const</span>;
          <span class="comment">// Return a reference with &#39;const&#39; access to the element held by</span>
          <span class="comment">// this container at the specified &#39;index&#39;.</span>

      <span class="keywordtype">int</span> size() <span class="keyword">const</span>;
          <span class="comment">// Return the number of elements held by this container.</span>
  };
</pre></div><br/>
<br/>
 Note that there is no easy test for whether a type is an iterator, so we assume any attempt to call a constructor with two arguments that are not fundamental (such as int) must be passing iterators. Now that we have defined the class template, we implement its methods: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  MyVector&lt;T&gt;::MyVector(<span class="keyword">const</span> T&amp; value, <span class="keywordtype">int</span> n)
  : d_storage(new T[n])
  , d_length(n)
  {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i !=n; ++i) {
          d_storage[i] = value;
      }
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  MyVector&lt;T&gt;::~MyVector()
  {
      <span class="keyword">delete</span>[] d_storage;
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  <span class="keyword">const</span> T&amp; MyVector&lt;T&gt;::operator[](<span class="keywordtype">int</span> index)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_storage[index];
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
  <span class="keywordtype">int</span> MyVector&lt;T&gt;::size()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_length;
  }
</pre></div><br/>
<br/>
 Finally we demonstrate that the correct constructors are called when invoked with appropriate arguments. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> TestContainerConstructor()
  {
      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TEST_DATA[] = { 1, 2, 3, 4, 5 };

      <span class="keyword">const</span> MyVector&lt;unsigned int&gt; x(&amp;TEST_DATA[0], &amp;TEST_DATA[5]);
      <span class="keyword">const</span> MyVector&lt;unsigned int&gt; y(13, 42);

      assert(5 == x.size());
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i != 5; ++i) {
          assert(TEST_DATA[i] == x[i]);
      }

      assert(42 == y.size());
      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i != 42; ++i) {
          assert(13 == y[i]);
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:42 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
