<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// btlmt_sessionpool.h                                                -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BTLMT_SESSIONPOOL
#define INCLUDED_BTLMT_SESSIONPOOL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide thread-enabled session-based IPv4 communication
//
//@CLASSES:
//  btlmt::SessionPool: session manager
//  btlmt::SessionPoolSessionIterator: sessions iterator
//
//@SEE_ALSO: btlmt_session, btlmt_asyncchannel, btlmt_channelpool
//
//@DESCRIPTION: This component provides a thread-enabled asynchronous
// &#39;btlmt::Session&#39; manager of the IPV4-based byte stream communication
// sessions.  The sessions are allocated automatically when the appropriate
// events occur, and destroyed based on user requests.  A new session is
// allocated automatically when an incoming connection is accepted, by the
// &#39;btlmt::SessionFactory&#39; specified during the call to &#39;listen&#39;, or when a
// user explicitly requests a connection to a server, by a
// &#39;btlmt::SessionFactory&#39; specified during the call to &#39;connect&#39;.  Session
// pool has both client-side (aka connector) and server-side (aka acceptor)
// facilities.  The session pool manages efficient delivery of messages to/from
// the user based on configuration information supplied at construction.  The
// states of individual messages are not reported; rather, session pool
// notifies the user when a session changes its state.  It also notifies the
// user when the state of the pool is affected, and provides the classification
// of errors.  The notification is done via asynchronous callbacks that can be
// invoked from any (managed) thread.
//
///Message Management and Delivery
///-------------------------------
// The session pool provides an efficient mechanism for the full-duplex
// delivery of messages trying to achieve fully parallel communication on a
// socket whenever possible.  If a particular socket&#39;s system buffers are full,
// the messages are queued up to a certain (user-defined) limit, at which point
// an alert is generated and the user has the ability to explicitly clear the
// session&#39;s outgoing buffer or, by default, continue the transmission.
//
// The session pool tries to achieve optimal performance by enabling zero-copy
// semantics whenever appropriate.  On the read side, the message is either
// read into a local buffer (and subsequently copied by the user) or into a
// buffer that is subsequently handed to the user for accessing and subsequent
// deallocation.  On the write side, if caching is needed, ownership of the
// message buffer is assumed and either the message is copied into the local
// buffer of the session or the address of the buffer is retained.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Implementing an Echo Server
/// - - - - - - - - - - - - - - - - - - -
// The following example implements a simple echo server.  This server accepts
// connections, reads what it receives right away from the network stream,
// sends it back and closes the connection.
//
// To set up this server, users must create a concrete session class derived
// from &#39;btlmt::Session&#39; protocol, and a factory for creating instances of this
// concrete session type.  &#39;my_EchoSession&#39; objects are created by a factory
// that must be derived from &#39;btlmt::SessionFactory&#39;.  A
// &#39;my_EchoSessionFactory&#39; just allocates and deallocates sessions (with no
// pooling or allocation strategy).  This is the simplest form of factory.
//..
//  // my_echoserver.h
//
//                          // ====================
//                          // class my_EchoSession
//                          // ====================
//
// class my_EchoSession : public btlmt::Session {
//     // This class is a concrete implementation of the &#39;btlmt::Session&#39;
//     // protocol to use along with &#39;my_EchoServer&#39; objects.
//
//     // DATA
//     btlmt::AsyncChannel *d_channel_p;// underlying channel (held, not owned)
//
//     // PRIVATE MANIPULATORS
//     void readCb(int         result,
//                 int        *numNeeded,
//                 btlb::Blob *blob,
//                 int         channelId);
//         // Read callback for session pool.
//
//   private:
//     // NOT IMPLEMENTED
//     my_EchoSession(const my_EchoSession&amp;);
//     my_EchoSession&amp; operator=(const my_EchoSession&amp;);
//
//   public:
//     // CREATORS
//     my_EchoSession(btlmt::AsyncChannel *channel);
//         // Create a new &#39;my_EchoSession&#39; object for the specified &#39;channel&#39;.
//
//     ~my_EchoSession();
//         // Destroy this object.
//
//     // MANIPULATORS
//     virtual int start();
//         // Begin the asynchronous operation of this session.
//
//     virtual int stop();
//         // Stop the operation of this session.
//
//     // ACCESSORS
//     virtual btlmt::AsyncChannel *channel() const;
//         // Return the channel associated with this session.
//  };
//
//                      // ===========================
//                      // class my_EchoSessionFactory
//                      // ===========================
//
//  class my_EchoSessionFactory : public btlmt::SessionFactory {
//      // This class is a concrete implementation of the
//      // &#39;btlmt::SessionFactory&#39; that simply allocates &#39;my_EchoSession&#39;
//      // objects.  No specific allocation strategy (such as pooling) is
//      // implemented.
//
//      bslma::Allocator *d_allocator_p; // memory allocator (held, not owned)
//
//    public:
//      // TRAITS
//      BSLALG_DECLARE_NESTED_TRAITS(my_EchoSessionFactory,
//                                   bslalg::TypeTraitUsesBslmaAllocator);
//
//      // CREATORS
//      my_EchoSessionFactory(bslma::Allocator *basicAllocator = 0);
//          // Create a new &#39;my_EchoSessionFactory&#39; object.  Optionally specify
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//          // 0, the currently installed default allocator is used.
//
//      virtual ~my_EchoSessionFactory();
//         // Destroy this factory.
//
//      // MANIPULATORS
//      virtual void allocate(btlmt::AsyncChannel                    *channel,
//                            const btlmt::SessionFactory::Callback&amp;  cb);
//         // Asynchronously allocate a &#39;btlmt::Session&#39; object for the
//         // specified &#39;channel&#39;, and invoke the specified &#39;cb&#39; with
//         // this session.
//
//      virtual void deallocate(btlmt::Session *session);
//         // Deallocate the specified &#39;session&#39;.
//  };
//..
// The implementations of those session and factory types are rather
// straightforward.  &#39;readCb&#39; will be called when the first byte is received.
// It is in this method that the echo logic is implemented.
//..
//  // my_echoserver.cpp
//
//                          // --------------------
//                          // class my_EchoSession
//                          // --------------------
//
//  // PRIVATE MANIPULATORS
//  void my_EchoSession::readCb(int         result,
//                              int        *numNeeded,
//                              btlb::Blob *blob,
//                              int         channelId)
//  {
//      if (result) {
//          d_channel_p-&gt;close();
//          return;
//      }
//
//      ASSERT(numNeeded);
//      ASSERT(0 &lt; blob-&gt;length());
//
//      ASSERT(0 == d_channel_p-&gt;write(*blob));
//
//      *numNeeded   = 1;
//      btlb::BlobUtil::erase(blob, 0, blob-&gt;length());
//
//      d_channel_p-&gt;close(); // close connection.
//  }
//
//  // CREATORS
//  my_EchoSession::my_EchoSession(btlmt::AsyncChannel *channel)
//  : d_channel_p(channel)
//  {
//  }
//
//  my_EchoSession::~my_EchoSession()
//  {
//  }
//
//  // MANIPULATORS
//  int my_EchoSession::start()
//  {
//      return d_channel_p-&gt;read(
//                              1,
//                              bdlf::MemFnUtil::memFn(&amp;my_EchoSession::readCb,
//                              this));
//  }
//
//  int my_EchoSession::stop()
//  {
//      d_channel_p-&gt;close();
//      return 0;
//  }
//
//  // ACCESSORS
//  btlmt::AsyncChannel *my_EchoSession::channel() const
//  {
//      return d_channel_p;
//  }
//
//                      // ---------------------------
//                      // class my_EchoSessionFactory
//                      // ---------------------------
//
//  // CREATORS
//  my_EchoSessionFactory::my_EchoSessionFactory(
//                                            bslma::Allocator *basicAllocator)
//  : d_allocator_p(bslma::Default::allocator(basicAllocator))
//  {
//  }
//
//  my_EchoSessionFactory::~my_EchoSessionFactory()
//  {
//  }
//
//  // MANIPULATORS
//  void
//  my_EchoSessionFactory::allocate(
//                            btlmt::AsyncChannel                    *channel,
//                            const btlmt::SessionFactory::Callback&amp;  callback)
//  {
//      my_EchoSession *session = new (*d_allocator_p) my_EchoSession(channel);
//      callback(0, session);
//  }
//
//  void
//  my_EchoSessionFactory::deallocate(btlmt::Session *session)
//  {
//      d_allocator_p-&gt;deleteObject(session);
//  }
//..
//  We now have all the pieces needed to design and implement our echo server.
//  The server itself owns an instance of the above-defined factory.
//..
//  // my_echoserver.h (continued)
//
//                      // ===================
//                      // class my_EchoServer
//                      // ===================
//
//  class my_EchoServer {
//      // This class implements a multi-user multi-threaded echo server.
//
//      // DATA
//      btlmt::ChannelPoolConfiguration  d_config;         // pool
//                                                         // configuration
//
//      btlmt::SessionPool              *d_sessionPool_p;  // managed pool
//                                                         // (owned)
//
//      my_EchoSessionFactory            d_sessionFactory; // my_EchoSession
//                                                         // factory
//
//      int                              d_portNumber;     // port on which
//                                                         // this server is
//                                                         // listening
//
//      bslmt::Mutex                    *d_coutLock_p;     // mutex protecting
//                                                         // bsl::cout
//
//      bslma::Allocator                *d_allocator_p;    // memory allocator
//                                                         // (held)
//
//      // PRIVATE MANIPULATORS
//      void poolStateCb(int reason, int source, void *userData);
//          // Indicates the status of the whole pool.
//
//      void sessionStateCb(int             state,
//                          int             handle,
//                          btlmt::Session *session,
//                          void           *userData);
//          // Per-session state.
//
//    private:
//      // NOT IMPLEMENTED
//      my_EchoServer(const my_EchoServer&amp; original);
//      my_EchoServer&amp; operator=(const my_EchoServer&amp; rhs);
//
//    public:
//      // TRAITS
//      BSLALG_DECLARE_NESTED_TRAITS(my_EchoServer,
//                                   bslalg::TypeTraitUsesBslmaAllocator);
//
//      // CREATORS
//      my_EchoServer(bslmt::Mutex     *coutLock,
//                    int               portNumber,
//                    int               numConnections,
//                    bool              reuseAddressFlag,
//                    bslma::Allocator *basicAllocator = 0);
//          // Create an echo server that listens for incoming connections on
//          // the specified &#39;portNumber&#39; managing up to the specified
//          // &#39;numConnections&#39; simultaneous connections.  Pass the specified
//          // &#39;reuseAddressFlag&#39; to the set the &#39;REUSE_ADDRESS&#39; socket option
//          // to the listening socket.  The echo server will use the
//          // specified &#39;coutLock&#39; to synchronize access to the standard
//          // output.  Optionally specify a &#39;basicAllocator&#39; used to supply
//          // memory.  If &#39;basicAllocator&#39; is 0, the currently installed
//          // default allocator is used.  The behavior is undefined if
//          // &#39;coutLock&#39; is 0.
//
//      ~my_EchoServer();
//          // Destroy this server.
//
//      // MANIPULATORS
//      const btlmt::SessionPool&amp; pool() const;
//          // Return a non-modifiable reference to the session pool used by
//          // this echo server.
//
//      int portNumber() const;
//          // Return the port number on which this server is listening.
//  };
//..
// Note that this example server prints information depending on
// implicitly-defined static variables and therefore must use a mutex to
// synchronize access to &#39;bsl::cout&#39;.  A production application should use a
// proper logging mechanism instead such as the &#39;bael&#39; logger.
//..
//  // my_echoserver.h (continued)
//
//                          // -------------------
//                          // class my_EchoServer
//                          // -------------------
//
//  // PRIVATE MANIPULATORS
//  void my_EchoServer::poolStateCb(int reason, int source, void *userData)
//  {
//      if (veryVerbose) {
//          d_coutLock_p-&gt;lock();
//          bsl::cout &lt;&lt; &quot;Pool state changed: (&quot; &lt;&lt; reason &lt;&lt; &quot;, &quot; &lt;&lt; source
//                    &lt;&lt; &quot;) &quot; &lt;&lt; bsl::endl;
//          d_coutLock_p-&gt;unlock();
//      }
//  }
//
//  void my_EchoServer::sessionStateCb(int             state,
//                                     int             handle,
//                                     btlmt::Session *session,
//                                     void           *userData) {
//
//      switch(state) {
//        case btlmt::SessionPool::SESSION_DOWN: {
//            if (veryVerbose) {
//                d_coutLock_p-&gt;lock();
//                bsl::cout &lt;&lt; &quot;Client from &quot;
//                          &lt;&lt; session-&gt;channel()-&gt;peerAddress()
//                          &lt;&lt; &quot; has disconnected.&quot;
//                          &lt;&lt; bsl::endl;
//                d_coutLock_p-&gt;unlock();
//            }
//        } break;
//        case btlmt::SessionPool::SESSION_UP: {
//            if (veryVerbose) {
//                d_coutLock_p-&gt;lock();
//                bsl::cout &lt;&lt; &quot;Client connected from &quot;
//                          &lt;&lt; session-&gt;channel()-&gt;peerAddress()
//                          &lt;&lt; bsl::endl;
//                d_coutLock_p-&gt;unlock();
//            }
//        } break;
//      }
//  }
//
//  // CREATORS
//  my_EchoServer::my_EchoServer(bslmt::Mutex     *lock,
//                               int               portNumber,
//                               int               numConnections,
//                               bslma::Allocator *basicAllocator)
//  : d_sessionFactory(basicAllocator)
//  , d_coutLock_p(lock)
//  , d_allocator_p(bslma::Default::allocator(basicAllocator))
//  {
//      d_config.setMaxThreads(4);                  // 4 I/O threads
//      d_config.setMaxConnections(numConnections);
//      d_config.setMetricsInterval(10.0);          // seconds
//      d_config.setWriteQueueWatermarks(0, 1&lt;&lt;10); // 1Mb
//      d_config.setIncomingMessageSizes(1, 100, 1024);
//
//      typedef btlmt::SessionPool::SessionPoolStateCallback SessionStateCb;
//
//      SessionStateCb poolStateCb = bdlf::MemFnUtil::memFn(
//                                                 &amp;my_EchoServer::poolStateCb,
//                                                 this);
//
//      d_sessionPool_p = new (*d_allocator_p) btlmt::SessionPool(
//                                                             d_config,
//                                                             poolStateCb,
//                                                             basicAllocator);
//
//      btlmt::SessionPool::SessionStateCallback sessionStateCb =
//                       bdlf::MemFnUtil::memFn(&amp;my_EchoServer::sessionStateCb,
//                                              this);
//
//      ASSERT(0 == d_sessionPool_p-&gt;start());
//      int handle;
//      ASSERT(0 == d_sessionPool_p-&gt;listen(&amp;handle,
//                                          sessionStateCb,
//                                          portNumber,
//                                          numConnections,
//                                          &amp;d_sessionFactory));
//
//      d_portNumber = d_sessionPool_p-&gt;portNumber(handle);
//  }
//
//  my_EchoServer::~my_EchoServer()
//  {
//      d_sessionPool_p-&gt;stop();
//      d_allocator_p-&gt;deleteObject(d_sessionPool_p);
//  }
//
//  // ACCESSORS
//  const btlmt::SessionPool&amp; my_EchoServer::pool() const
//  {
//      return *d_sessionPool_p;
//  }
//
//  int my_EchoServer::portNumber() const
//  {
//      return d_portNumber;
//  }
//..
// We can implement a simple &quot;Hello World!&quot; example to exercise our echo
// server.
//..
//  int main() {
//
//      enum {
//          BACKLOG = 5,
//          REUSE   = 1
//      };
//
//      my_EchoServer echoServer(&amp;coutMutex, 0, BACKLOG, REUSE);
//
//      btlso::InetStreamSocketFactory&lt;btlso::IPv4Address&gt; factory;
//      btlso::StreamSocket&lt;btlso::IPv4Address&gt; *socket = factory.allocate();
//
//      const char STRING[] = &quot;Hello World!&quot;;
//
//      const btlso::IPv4Address ADDRESS(&quot;127.0.0.1&quot;, echoServer.portNumber());
//      assert(0 == socket-&gt;connect(ADDRESS));
//      assert(sizeof(STRING) == socket-&gt;write(STRING, sizeof(STRING)));
//
//      char readBuffer[sizeof(STRING)];
//      assert(sizeof(STRING) == socket-&gt;read(readBuffer, sizeof(STRING)));
//      assert(0 == bsl::strcmp(readBuffer, STRING));
//
//      factory.deallocate(socket);
//      return 0;
//  }
//..

#ifndef INCLUDED_BTLSCM_VERSION
#include &lt;btlscm_version.h&gt;
#endif

#ifndef INCLUDED_BTLMT_CHANNELPOOL
#include &lt;btlmt_channelpool.h&gt;
#endif

#ifndef INCLUDED_BTLMT_CHANNELPOOLCONFIGURATION
#include &lt;btlmt_channelpoolconfiguration.h&gt;
#endif

#ifndef INCLUDED_BTLSO_IPV4ADDRESS
#include &lt;btlso_ipv4address.h&gt;
#endif

#ifndef INCLUDED_BTLSO_STREAMSOCKET
#include &lt;btlso_streamsocket.h&gt;
#endif

#ifndef INCLUDED_BTLSO_STREAMSOCKETFACTORY
#include &lt;btlso_streamsocketfactory.h&gt;
#endif

#ifndef INCLUDED_BDLCC_OBJECTCATALOG
#include &lt;bdlcc_objectcatalog.h&gt;
#endif

#ifndef INCLUDED_BDLMA_CONCURRENTPOOLALLOCATOR
#include &lt;bdlma_concurrentpoolallocator.h&gt;
#endif

#ifndef INCLUDED_BTLB_BLOB
#include &lt;btlb_blob.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SCALARPRIMITIVES
#include &lt;bslalg_scalarprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLMA_MANAGEDPTR
#include &lt;bslma_managedptr.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMIC
#include &lt;bsls_atomic.h&gt;
#endif

#ifndef INCLUDED_BSL_FUNCTIONAL
#include &lt;bsl_functional.h&gt;
#endif

#ifndef INCLUDED_BSL_MEMORY
#include &lt;bsl_memory.h&gt;
#endif

namespace BloombergLP {

namespace btlso { class SocketOptions; }

namespace btlmt {

class ChannelPool;
class Session;
class SessionFactory;

class  ChannelPool;
class  Session;
class  SessionFactory;
struct SessionPool_Handle;
class  SessionPool;

                   // ================================
                   // class SessionPoolSessionIterator
                   // ================================

class SessionPoolSessionIterator {
    // Provide read-only sequential access to the allocated sessions in a
    // &#39;SessionPool&#39; object.

    // PRIVATE TYPES
    typedef bdlcc::ObjectCatalogIter&lt;bsl::shared_ptr&lt;SessionPool_Handle&gt; &gt;
                                                               CatalogIterator;

    // DATA
    CatalogIterator            d_iterator;  // underlying catalog iterator

    bsl::pair&lt;int, Session *&gt;  d_current;   // pair referenced by
                                            // this iterator

    bsl::pair&lt;int, Session *&gt; *d_current_p; // points to &#39;d_current&#39; if
                                            // the iterator is valid, or
                                            // 0 otherwise.

  private:
    // NOT IMPLEMENTED
    SessionPoolSessionIterator(const SessionPoolSessionIterator&amp;);
    SessionPoolSessionIterator&amp; operator=(const SessionPoolSessionIterator&amp;);

    bool operator==(const SessionPoolSessionIterator&amp;) const;
    bool operator!=(const SessionPoolSessionIterator&amp;) const;

  public:
    explicit SessionPoolSessionIterator(SessionPool *sessionPool);
        // Create an iterator for the specified &#39;sessionPool&#39; and associate it
        // If the &#39;catalog&#39; is empty than the iterator is initialized to be
        // invalid.  The &#39;catalog&#39; is read locked for the duration of
        // iterator&#39;s life.

    ~SessionPoolSessionIterator();
        // Destroy this iterator.

    // MANIPULATORS
    void operator++();
        // Advance this iterator to refer to the next object of the associated
        // session pool; if there is no next object in the associated session
        // pool, then this iterator becomes *invalid*.  The behavior is
        // undefined unless this iterator is valid.  Note that the order of the
        // iteration is implementation-defined.

    // ACCESSORS
    operator bool() const;
        // Return true if the iterator is *valid*, and false otherwise.

    const bsl::pair&lt;int, Session *&gt;&amp; operator*() const;
        // Return a pair containing the handle (&#39;first&#39; element of the pair)
        // and a pointer to the session (&#39;second&#39; element of the pair )
        // associated with this iterator.  The behavior is undefined unless the
        // iterator is *valid*.
};

                           // =================
                           // class SessionPool
                           // =================

class SessionPool {
    // This class provides a mechanism for establishing and managing network
    // connections.  A session pool can be configured at construction by
    // passing in a &#39;ChannelPoolConfiguration&#39; object and allows the
    // establishment of both server sessions via the &#39;listen&#39; method and client
    // sessions via the &#39;connect&#39; method.  The connection initiation methods
    // take a &#39;SessionFactory&#39; object that allows users to return a &#39;Session&#39;
    // object that the session pool stores as a reference for the connection.
    // During the allocation of the &#39;Session&#39; object clients are provided an
    // &#39;AsyncChannel&#39; that they can use for exchanging data with the other
    // endpoint in the connection.  An existing socket can be imported into a
    // session pool and this will create a session enabled both for read and
    // for write.  All of the callbacks invoked by session pool are run in a
    // number of threads created at start up.  Session pool ensures that
    // callback methods of a particular connection are always invoked on the
    // same thread so users dont have to synchroninze data associated with a
    // particular connection.  Session pool can be started or stopped via the
    // &#39;start&#39; and &#39;stop&#39; methods respectively.  Once started and until
    // stopped, the session pool dispatches incoming and outgoing connections,
    // messages, and other session functions to the processing threads.  Once
    // stopped, the channel pool can be started again and the channels will
    // resume their operations.

  public:
    // PUBLIC TYPES
    enum SessionState{
        // Result code passed to the session callback.

        e_SESSION_UP             = 1,  // new session has been allocated
        e_SESSION_DOWN           = 2,  // session went down
        e_SESSION_ALLOC_FAILED   = 3,  // session allocation failed
        e_SESSION_STARTUP_FAILED = 4,  // the call to &#39;start&#39; failed
        e_WRITE_QUEUE_LOWWATER   = 5,  // write queue low watermark reached
        e_WRITE_QUEUE_HIGHWATER  = 6,  // write queue high watermark reached
        e_ACCEPT_FAILED          = 7,  // accept failed
        e_CONNECT_ATTEMPT_FAILED = 8,  // a connection attempt failed
        e_CONNECT_FAILED         = 9,  // the connection initiation failed
        e_CONNECT_ABORTED        = 10  // session was shutdown before the
                                       // connection could be established


    };

    enum ConnectResolutionMode {
        // Mode indicating whether to perform name resolution at each connect
        // attempt in &#39;connect&#39;.

        e_RESOLVE_ONCE            = 0,  // perform resolution once prior to the
                                        // first connect attempt

        e_RESOLVE_AT_EACH_ATTEMPT = 1   // perform resolution prior to each
                                        // connect attempt


    };

    enum PoolState {
        // Result code passed to the pool callback.  Note that
        // &#39;e_CONNECT_ABORTED&#39;, &#39;e_CONNECT_ATTEMPT_FAILED&#39;, &#39;e_CONNECT_FAILED&#39;,
        // &#39;e_ACCEPT_FAILED&#39; are passed to both the session and the pool
        // callbacks.

        e_SESSION_LIMIT_REACHED = 1   // cannot create more sessions


    };

    typedef bsl::function&lt;void(int      state,
                               int      handle,
                               Session *session,
                               void    *userData)&gt; SessionStateCallback;
        // Session callback.

    typedef bsl::function&lt;void(int   state,
                               int   source,
                               void *userData)&gt; SessionPoolStateCallback;
        // Pool callback.

  private:
    // PRIVATE TYPES
    typedef bdlcc::ObjectCatalog&lt;bsl::shared_ptr&lt;SessionPool_Handle&gt; &gt;
                                                                 HandleCatalog;

    // DATA
    HandleCatalog                   d_handles;            // handles catalog

    ChannelPoolConfiguration        d_config;             // channel config

    ChannelPool                    *d_channelPool_p;      // underlying channel
                                                          // manager (owned)

    SessionPoolStateCallback        d_poolStateCB;        // pool state
                                                          // callback

    bdlma::ConcurrentPoolAllocator  d_spAllocator;        // smart pointers
                                                          // allocators

    bslma::ManagedPtr&lt;btlb::BlobBufferFactory&gt;
                                    d_blobBufferFactory;  // blob buffer
                                                          // factory

    bsls::AtomicInt                 d_numSessions;        // number of
                                                          // allocated
                                                          // sessions

    bslma::Allocator               *d_allocator_p;        // allocator (held)

    // PRIVATE MANIPULATORS
    void channelStateCb(int   channelId,
                        int   sourceId,
                        int   state,
                        void *userData);
        // Wrapper for channel pool&#39;s channel callback and the session
        // callback.

    void connectAbortTimerCb(
                           const bsl::shared_ptr&lt;SessionPool_Handle&gt;&amp; handle,
                           int                                        clockId);
        // Deregister the timer callback having the specified &#39;clockId&#39;
        // registered with the underlying channel pool and destroy the
        // specified &#39;handle&#39;.

    void blobBasedReadCb(int        *numNeeded,
                         btlb::Blob *msg,
                         int         channelId,
                         void       *userData);
        // Channel pool&#39;s blob based read callback.

    void terminateSession(SessionPool_Handle *handle);
        // Issue a session down event and stop the session associated with the
        // specified &#39;handle&#39;.

    void handleDeleter(SessionPool_Handle *handle);
        // Delete the specified &#39;handle&#39;.

    void poolStateCb(int state, int source, int severity);
        // Wrapper for the channel pool state callback and session pool&#39;s.

    void sessionAllocationCb(int result, Session *session, int handleId);
        // Session allocation callback passed to the factory at allocation
        // time.

    void init();
        // Initialize this session pool.

    int makeConnectHandle(
                         const SessionPool::SessionStateCallback&amp;  cb,
                         int                                       numAttempts,
                         void                                     *userData,
                         SessionFactory                           *factory);
       // Add a handle for a connection session with the specified
       // &#39;numAttempts&#39;, &#39;userData&#39;, and &#39;cb&#39; parameters to this session pool.
       // The factory will be allocated from the specified &#39;factory&#39;.  Return
       // the identifier for the new handle.

    // FRIENDS
    friend class SessionPoolSessionIterator;

  private:
    // NOT IMPLEMENTED
    SessionPool(const SessionPool&amp;);
    SessionPool&amp; operator=(const SessionPool&amp;);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(SessionPool, bslma::UsesBslmaAllocator);

    // CREATORS
    SessionPool(const ChannelPoolConfiguration&amp;  config,
                const SessionPoolStateCallback&amp;  poolStateCallback,
                bslma::Allocator                *basicAllocator = 0);
    SessionPool(btlb::BlobBufferFactory         *blobBufferFactory,
                const ChannelPoolConfiguration&amp;  config,
                const SessionPoolStateCallback&amp;  poolStateCallback,
                bslma::Allocator                *basicAllocator = 0);
        // Create a new session pool according to the specified &#39;config&#39; that
        // uses &#39;btlb::Blob&#39;s for reading data and invokes the specified
        // &#39;poolStateCallback&#39; when the pool state changes.  Use the specified
        // &#39;blobBufferFactory&#39; to supply buffers for the blobs used for reading
        // data.  Optionally specify &#39;basicAllocator&#39; used to supply memory.
        // If &#39;basicAllocator&#39; is 0, the currently installed default allocator
        // is used.  If &#39;config.readTimeout()&#39; is the default configured
        // read-timeout value, then this session pool will disable the
        // underlying channel pool&#39;s read-timeout event (i.e., this session
        // pool will set the configured read timeout to 0.0s).  Note that read
        // timeout events generated by the underlying channel pool are ignored
        // by this session pool (so there is no benefit to enabling them).

    ~SessionPool();
        // Destroy this session pool.

    // MANIPULATORS
                                  // *** pool management section ***
    int start();
        // Begin the asynchronous operation of the session pool.  Return zero
        // on success, and a non-zero value otherwise.

    int stop();
        // Stop the asynchronous operation of the session pool and gracefully
        // terminate all active connection and listeners; return 0 on success
        // and a non-zero value otherwise.  If all attempts to terminate the
        // sessions &quot;gracefully&quot; fail, a negative value is returned and the
        // sessions are destroyed anyway.

    int stopAndRemoveAllSessions();
        // Stop the asynchronous operation of this session pool, gracefully
        // terminate all active connectors and listeners, and remove all those
        // communication sessions from this session pool.  Return 0 on success,
        // and a non-zero value otherwise.  If all attempts to terminate the
        // sessions &quot;gracefully&quot; fail, a negative value is returned and the
        // sessions are destroyed anyway.  Note that shutting down a session
        // will deallocate all system resources associated with that session.

                                  // *** server-related section ***

    int listen(int                                      *handleBuffer,
               const SessionPool::SessionStateCallback&amp;  callback,
               int                                       portNumber,
               int                                       backlog,
               SessionFactory                           *factory,
               void                                     *userData = 0,
               const btlso::SocketOptions               *socketOptions = 0);
    int listen(int                                      *handleBuffer,
               const SessionPool::SessionStateCallback&amp;  callback,
               int                                       portNumber,
               int                                       backlog,
               int                                       reuseAddress,
               SessionFactory                           *factory,
               void                                     *userData = 0,
               const btlso::SocketOptions               *socketOptions = 0);
    int listen(int                                      *handleBuffer,
               const SessionPool::SessionStateCallback&amp;  callback,
               const btlso::IPv4Address&amp;                 endpoint,
               int                                       backlog,
               SessionFactory                           *factory,
               void                                     *userData = 0,
               const btlso::SocketOptions               *socketOptions = 0);
    int listen(int                                      *handleBuffer,
               const SessionPool::SessionStateCallback&amp;  callback,
               const btlso::IPv4Address&amp;                 endpoint,
               int                                       backlog,
               int                                       reuseAddress,
               SessionFactory                           *factory,
               void                                     *userData = 0,
               const btlso::SocketOptions               *socketOptions = 0);
        // Asynchronously listen for connection requests on the specified
        // &#39;portNumber&#39; on all local interfaces or the specified &#39;endpoint&#39;,
        // depending on which overload of listen is used, with up to a maximum
        // of &#39;backlog&#39; concurrent connection requests.  Once a connection is
        // successfully accepted, this session pool will allocate and start a
        // session for the connection using the specified &#39;factory&#39;.  Load a
        // handle for the listening connection into &#39;handleBuffer&#39;.  Optionally
        // specify a &#39;reuseAddress&#39; value to be used in setting &#39;REUSEADDRESS&#39;
        // socket option.  If &#39;reuseAddress&#39; is not specified, 1 (i.e.,
        // &#39;REUSEADDRESS&#39; is enabled) is used.  Optionally specify
        // &#39;socketOptions&#39; that will be used to specify what options should be
        // set on the listening socket.  Return 0 on success, and a non-zero
        // value otherwise.  Every time a connection is accepted by this pool
        // on this (newly-established) listening socket, the newly allocated
        // session is passed to the specified &#39;callback&#39; along with the
        // optionally specified &#39;userData&#39;.  The behavior is undefined unless
        // &#39;0 &lt; backlog&#39;.

                                  // *** client-related section ***
    int closeHandle(int handle);
        // Close the listener or the connection represented by the specified
        // &#39;handle&#39;.  Return 0 on success, or a non-zero value if the specified
        // &#39;handle&#39; does not match any currently allocation session handle.

    int connect(int                                      *handleBuffer,
                const SessionPool::SessionStateCallback&amp;  callback,
                const char                               *hostname,
                int                                       port,
                int                                       numAttempts,
                const bsls::TimeInterval&amp;                 interval,
                bslma::ManagedPtr&lt;btlso::StreamSocket&lt;btlso::IPv4Address&gt; &gt;
                                                         *socket,
                SessionFactory                           *factory,
                void                                     *userData = 0,
                ConnectResolutionMode                     resolutionMode
                                                             = e_RESOLVE_ONCE);
    int connect(int                                      *handleBuffer,
                const SessionPool::SessionStateCallback&amp;  callback,
                const char                               *hostname,
                int                                       port,
                int                                       numAttempts,
                const bsls::TimeInterval&amp;                 interval,
                SessionFactory                           *factory,
                void                                     *userData = 0,
                ConnectResolutionMode                     resolutionMode
                                                              = e_RESOLVE_ONCE,
                const btlso::SocketOptions               *socketOptions = 0,
                const btlso::IPv4Address                 *localAddress = 0);
        // Asynchronously attempt to connect to the specified &#39;hostname&#39; on the
        // specified &#39;port&#39; up to the specified &#39;numAttempts&#39; delaying for the
        // specified &#39;interval&#39; between each attempt.  Optionally specify a
        // &#39;resolutionMode&#39; to indicate whether the name resolution is
        // performed once (if &#39;resolutionMode&#39; is &#39;RESOLVE_ONCE&#39;), or performed
        // anew prior to each attempt (if &#39;resolutionMode&#39; is
        // &#39;RESOLVE_AT_EACH_ATTEMPT&#39;); if &#39;resolutionMode is not specified,
        // &#39;RESOLVE_ONCE&#39; is used.  Once a connection is successfully
        // established, allocate and start a session using the specified
        // &#39;factory&#39; and load a handle for the initiated connection into
        // &#39;handleBuffer&#39;.  Whenever this session state changes (i.e., is
        // established), the specified &#39;callback&#39; will be invoked along with a
        // pointer to newly created &#39;Session&#39; and the optionally specified
        // &#39;userData&#39;.  Optionally specify either &#39;socketOptions&#39; that will be
        // used to specify what options should be set on the connecting socket
        // and/or the specified &#39;localAddress&#39; to be used as the source
        // address, or specify &#39;socket&#39; to use as the connecting socket (with
        // any desired options and/or source address already set).  If &#39;socket&#39;
        // is specified, this pool will assume its ownership, if this function
        // returns successfully, and will be left unchanged if an error is
        // returned.  Return 0 on successful initiation, and a non-zero value
        // otherwise.  The behavior is undefined unless &#39;0 &lt; numAttempts&#39;, and
        // &#39;0 &lt; interval || 1 == numAttempts&#39;.

    int connect(int                                      *handleBuffer,
                const SessionPool::SessionStateCallback&amp;  callback,
                btlso::IPv4Address const&amp;                 endpoint,
                int                                       numAttempts,
                const bsls::TimeInterval&amp;                 interval,
                bslma::ManagedPtr&lt;btlso::StreamSocket&lt;btlso::IPv4Address&gt; &gt;
                                                         *socket,
                SessionFactory                           *factory,
                void                                     *userData = 0);
    int connect(int                                      *handleBuffer,
                const SessionPool::SessionStateCallback&amp;  callback,
                btlso::IPv4Address const&amp;                 endpoint,
                int                                       numAttempts,
                const bsls::TimeInterval&amp;                 interval,
                SessionFactory                           *factory,
                void                                     *userData = 0,
                const btlso::SocketOptions               *socketOptions = 0,
                const btlso::IPv4Address                 *localAddress = 0);
        // Asynchronously attempt to connect to the specified &#39;endpoint&#39; up to
        // the specified &#39;numAttempts&#39; delaying for the specified &#39;interval&#39;
        // between each attempt; once a connection is successfully established,
        // allocate and start a session using the specified &#39;factory&#39; and load
        // a handle for the initiated connection into &#39;handleBuffer&#39;.  Whenever
        // this session state changes (i.e., is established), the specified
        // &#39;callback&#39; will be invoked along with a pointer to newly created
        // &#39;Session&#39; and the optionally specified &#39;userData&#39;.  Optionally
        // specify either &#39;socketOptions&#39; that will be used to specify what
        // options should be set on the connecting socket and/or &#39;localAddress&#39;
        // to be used as the source address, or &#39;socket&#39; to use as the
        // connecting socket (with any desired options and/or source address
        // already set).  If &#39;socket&#39; is specified, ownership will be
        // transferred from it if this function returns successfully, and will
        // be left unchanged if an error is returned.  Return 0 on successful
        // initiation, and a non-zero value otherwise.  The behavior is
        // undefined unless &#39;0 &lt; numAttempts&#39;, and &#39;0 &lt; interval&#39; or
        // &#39;1 == numAttempts&#39;.

    int import(int                                            *handleBuffer,
               const SessionPool::SessionStateCallback&amp;        callback,
               btlso::StreamSocket&lt;btlso::IPv4Address&gt;        *streamSocket,
               btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt; *socketFactory,
               SessionFactory                                 *sessionFactory,
               void                                           *userData = 0);
    int import(int                                            *handleBuffer,
               const SessionPool::SessionStateCallback&amp;        callback,
               bslma::ManagedPtr&lt;btlso::StreamSocket&lt;btlso::IPv4Address&gt; &gt;
                                                              *streamSocket,
               SessionFactory                                 *sessionFactory,
               void                                           *userData = 0);
        // Asynchronously import the specified &#39;streamSocket&#39; into this session
        // pool.  Load into the specified &#39;handleBuffer&#39; the handle to the
        // corresponding internally-allocated session through the specified
        // &#39;sessionFactory&#39;.  If &#39;streamSocket&#39; is a &#39;bslma::ManagedPtr&#39;, then
        // ownership is transferred from it if this function returns
        // successfully, and will be left unchanged if an error is returned;
        // otherwise, upon destruction of this session pool, &#39;streamSocket&#39; is
        // destroyed via the specified &#39;socketFactory&#39;.  When the session state
        // changes (i.e., is established), the specified &#39;callback&#39; will be
        // invoked along with the allocated &#39;Session&#39; and the optionally
        // specified &#39;userData&#39;.  Return 0 on success, and a non-zero value
        // with no effect on the session pool otherwise.

    int setWriteQueueWatermarks(int handleId,
                                int lowWatermark,
                                int highWatermark);
        // Set the write queue low- and high-water marks for the session
        // associated with the specified &#39;handleId&#39; to the specified
        // &#39;lowWatermark&#39; and &#39;highWatermark&#39; values, respectively; return 0 on
        // success, and a non-zero value otherwise.  A &#39;e_WRITE_QUEUE_LOWWATER&#39;
        // alert is provided (via the channel state callback) if &#39;lowWatermark&#39;
        // is greater than or equal to the current size of the write queue, and
        // a &#39;e_WRITE_QUEUE_HIGHWATER&#39; alert is provided if &#39;highWatermark&#39; is
        // less than or equal to the current size of the write queue.  (See the
        // component-level documentation of &#39;btlmt_channelpool&#39; for details on
        // &#39;e_WRITE_QUEUE_HIGHWATER&#39; and &#39;e_WRITE_QUEUE_LOWWATER&#39; alerts.)  The
        // behavior is undefined unless &#39;0 &lt;= lowWatermark&#39; and
        // &#39;0 &lt;= highWatermark&#39;.  Note that this method overrides the values
        // configured (for all channels) by the &#39;ChannelPoolConfiguration&#39;
        // supplied at construction.

    // ACCESSORS
    const ChannelPoolConfiguration&amp; config() const;
        // Return a non-modifiable reference to the configuration used during
        // the construction of this session pool.

    void getChannelHandleStatistics(
                       bsl::vector&lt;ChannelPool::HandleInfo&gt; *handleInfo) const;
        // Load into the specified &#39;handleInfo&#39; array a snapshot of the
        // information per socket handle currently in use by this channel pool.

    int numSessions() const;
        // Return a *snapshot* of the current number of sessions managed by
        // this session pool.

    int portNumber(int handle) const;
        // Return the port number on which the session with the specified
        // &#39;handle&#39; is listening, or a negative value if &#39;handle&#39; does not
        // refer to an active listening session obtained from a successful call
        // to &#39;listen&#39; on this session pool.

};

// ============================================================================
//                      INLINE FUNCTION IMPLEMENTATIONS
// ============================================================================

                   // --------------------------------
                   // class SessionPoolSessionIterator
                   // --------------------------------

// CREATORS
inline
SessionPoolSessionIterator::~SessionPoolSessionIterator()
{
}

// ACCESSORS
inline
btlmt::SessionPoolSessionIterator::operator bool() const
{
    return d_current_p;
}

inline
const bsl::pair&lt;int, Session *&gt;&amp; SessionPoolSessionIterator::operator*() const
{
    return *d_current_p;
}

                           // -----------------
                           // class SessionPool
                           // -----------------

// ACCESSORS
inline
const ChannelPoolConfiguration&amp; SessionPool::config() const
{
    return d_config;
}

inline
void SessionPool::getChannelHandleStatistics(
                        bsl::vector&lt;ChannelPool::HandleInfo&gt; *handleInfo) const
{
    if (d_channelPool_p) {
        d_channelPool_p-&gt;getHandleStatistics(handleInfo);
    }
}

inline
int SessionPool::numSessions() const
{
    return d_numSessions;
}

// MANIPULATORS
inline
int SessionPool::import(
                int                                            *handleBuffer,
                const SessionPool::SessionStateCallback&amp;        callback,
                btlso::StreamSocket&lt;btlso::IPv4Address&gt;        *streamSocket,
                btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt; *socketFactory,
                SessionFactory                                 *sessionFactory,
                void                                           *userData)
{
    typedef btlso::StreamSocketFactoryDeleter Deleter;

    bslma::ManagedPtr&lt;btlso::StreamSocket&lt;btlso::IPv4Address&gt; &gt; socket(
                                   streamSocket,
                                   socketFactory,
                                   &amp;Deleter::deleteObject&lt;btlso::IPv4Address&gt;);

    const int rc = import(handleBuffer,
                          callback,
                          &amp;socket,
                          sessionFactory,
                          userData);

    if (rc) {
        socket.release();
    }
    return rc;
}


}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
