<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// balm_metrics.h                                                     -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALM_METRICS
#define INCLUDED_BALM_METRICS

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a suite of operations for recording metric values.
//
//@CLASSES:
//
//@SEE_ALSO: balm_collector, balm_integercollector, balm_defaultmetricsmanager
//
//@DESCRIPTION: This component provides a suite of macros to simplify the
// process of collecting metrics.  A metric records the number of times an
// event occurs, as well as an associated measurement value.  A metric
// maintains a count of event occurrences and the aggregated minimum, maximum,
// and total of the measured metric-event values.  Note that this component
// does *not* define what constitutes an event nor what the associated value
// represents.
//
///Thread Safety
///-------------
// All the macros defined in this component are *thread-safe*, meaning that
// they can be safely invoked simultaneously from multiple threads.  It is
// *not* safe, however, to invoke any of the macros defined in this component
// while the default metrics manager is being either created or destroyed.
//
///Macro Summary
///-------------
// This section provides a brief description of the macros defined in this
// component.  In most cases, category and metric names supplied as macro
// arguments are required to be *runtime* *constants*, meaning that their
// values must be constant for the lifetime of the process.  More complete
// documentation is provided in the &#39;Macro Reference&#39; section.
//..
//   BALM_METRICS_IF_CATEGORY_ENABLED(CATEGORY)
//       This macro behaves like an &#39;if&#39; clause, executing the subsequent
//       (compound) statement if the specified &#39;CATEGORY&#39; is enabled.
//
//   BALM_METRICS_UPDATE(CATEGORY, METRIC1, VALUE1)
//   BALM_METRICS_UPDATE2(CATEGORY, METRIC1, VALUE1, METRIC2, VALUE2)
//   BALM_METRICS_UPDATE3(CATEGORY, METRIC1, VALUE1, ..., METRIC3, VALUE3)
//   BALM_METRICS_UPDATE4(CATEGORY, METRIC1, VALUE1, ..., METRIC4, VALUE4)
//   BALM_METRICS_UPDATE5(CATEGORY, METRIC1, VALUE1, ..., METRIC5, VALUE5)
//   BALM_METRICS_UPDATE6(CATEGORY, METRIC1, VALUE1, ..., METRIC6, VALUE6)
//   BALM_METRICS_INT_UPDATE(CATEGORY, METRIC1, VALUE1)
//   BALM_METRICS_INT_UPDATE2(CATEGORY, METRIC1, VALUE1, METRIC2, VALUE2)
//   BALM_METRICS_INT_UPDATE3(CATEGORY, METRIC1, VALUE1, ..., METRIC3, VALUE3)
//   BALM_METRICS_INT_UPDATE4(CATEGORY, METRIC1, VALUE1, ..., METRIC4, VALUE4)
//   BALM_METRICS_INT_UPDATE5(CATEGORY, METRIC1, VALUE1, ..., METRIC5, VALUE5)
//   BALM_METRICS_INT_UPDATE6(CATEGORY, METRIC1, VALUE1, ..., METRIC6, VALUE6)
//       Update each of up to 6 metrics by the corresponding values.
//       The supplied category and metric names must be *runtime* *constants*.
//
//   BALM_METRICS_TYPED_UPDATE(CATEGORY, METRIC, VALUE, PREFERRED_TYPE)
//   BALM_METRICS_TYPED_INT_UPDATE(CATEGORY, METRIC, VALUE, PREFERRED_TYPE)
//       Update the identified metric by &#39;VALUE&#39; and set its preferred
//       publication type.  &#39;CATEGORY&#39; and &#39;METRIC&#39; must be *runtime*
//       *constants*.
//
//   BALM_METRICS_INCREMENT(CATEGORY, METRIC)
//       Increment (by 1) the identified metric.  &#39;CATEGORY&#39; and &#39;METRIC&#39; must
//       be *runtime* *constants*.
//
//   BALM_METRICS_TYPED_INCREMENT(CATEGORY, METRIC, PREFERRED_TYPE)
//       Increment (by 1) the identified metric and set the metric&#39;s preferred
//       publication type.  &#39;CATEGORY&#39; and &#39;METRIC&#39; must be *runtime*
//       *constants*.
//
//   BALM_METRICS_DYNAMIC_UPDATE(CATEGORY, METRIC, VALUE)
//   BALM_METRICS_DYNAMIC_INT_UPDATE(CATEGORY, METRIC, VALUE)
//       Update the identified metric by &#39;VALUE&#39;.  This operation performs a
//       lookup on &#39;CATEGORY&#39; and &#39;METRIC&#39; on each invocation, so those values
//       need *not* be runtime constants.
//
//   BALM_METRICS_DYNAMIC_INCREMENT(CATEGORY, METRIC)
//       Increment (by 1) the identified metric.  This operation performs a
//       lookup on &#39;CATEGORY&#39; and &#39;METRIC&#39; on each invocation, so those values
//       need *not* be runtime constants.
//
//   BALM_METRICS_TIME_BLOCK(CATEGORY, METRIC, TIME_UNITS)
//   BALM_METRICS_TIME_BLOCK_SECONDS(CATEGORY, METRIC)
//   BALM_METRICS_TIME_BLOCK_MILLISECONDS(CATEGORY, METRIC)
//   BALM_METRICS_TIME_BLOCK_MICROSECONDS(CATEGORY, METRIC)
//   BALM_METRICS_TIME_BLOCK_NANOSECONDS(CATEGORY, METRIC)
//       Update the identified metric by the elapsed (wall) time, in the
//       indicated units, from the instantiation point of the macro to the end
//       of the enclosing lexical scope.  &#39;CATEGORY&#39; and &#39;METRIC&#39; must
//       be *runtime* *constants*.
//
//   BALM_METRICS_DYNAMIC_TIME_BLOCK(CATEGORY, METRIC, TIME_UNITS)
//   BALM_METRICS_DYNAMIC_TIME_BLOCK_SECONDS(CATEGORY, METRIC)
//   BALM_METRICS_DYNAMIC_TIME_BLOCK_MILLISECONDS(CATEGORY, METRIC)
//   BALM_METRICS_DYNAMIC_TIME_BLOCK_MICROSECONDS(CATEGORY, METRIC)
//   BALM_METRICS_DYNAMIC_TIME_BLOCK_NANOSECONDS(CATEGORY, METRIC)
//       Update the identified metric by the elapsed (wall) time, in the
//       indicated units, from the instantiation point of the macro to the end
//       of the enclosing lexical scope.  This operation performs a lookup on
//       &#39;CATEGORY&#39; and &#39;METRIC&#39; on each invocation, so those values need *not*
//       be runtime constants.
//..
//
///Macro Reference
///---------------
// The macros defined in this component make use of the default instance of
// &#39;balm::MetricsManager&#39;.  The macros have no effect unless the metrics
// manager default instance has been initialized via a call to
// &#39;balm::DefaultMetricsManager::create&#39;.
//
// The macros defined below provide two basic operations identified by their
// suffixes: update (&#39;*_UPDATE&#39;) and increment (&#39;*_INCREMENT&#39;).  The update
// operation increments (by 1) the identified metric&#39;s count of events,
// increases the metric&#39;s total by the supplied value, if the supplied value
// is less than the metric&#39;s current minimum value then the minimum value is
// set to the supplied value, and if the supplied value is greater than the
// metric&#39;s current maximum value then the maximum value is set to the supplied
// value.  The increment operation is logically equivalent to an update of 1.
//
// The update, increment, and timing operations come in two variations:
// standard, and dynamic (*_DYNAMIC_*).  The standard variation maintains a
// (function-scope static) cache containing the identity of the metric being
// collected.  This cache is initialized the *first* time the flow of control
// passes through the instantiated macro, which in practice means that the
// identifiers for the metric(s) passed as parameters to that macro must be
// *runtime* *constants*.  The dynamic variant looks up the supplied category
// and metric(s) on each invocation of the macro, resulting in additional
// runtime overhead compared to the standard variant.
//
// The following are the standard (non-dynamic) macros provided by this
// component for updating a metric&#39;s value:
//..
//   BALM_METRICS_UPDATE(CATEGORY, METRIC, VALUE)
//       Update the indicated metric, identified by the specified &#39;CATEGORY&#39;
//       and &#39;METRIC&#39; names, with the specified &#39;VALUE&#39;.  &#39;CATEGORY&#39; and
//       &#39;METRIC&#39; must be null-terminated strings of a type convertible to
//       &#39;const char *&#39;, and &#39;VALUE&#39; is assumed to be of a type convertible to
//       &#39;double&#39;.  This macro maintains a (function-scope static) cache
//       containing the identity of the metric being updated.  This cache is
//       initialized using the &#39;CATEGORY&#39; and &#39;METRIC&#39; specified on the *first*
//       application of this macro at a particular instantiation point;
//       subsequent applications use that cached information, which in
//       practice means that &#39;CATEGORY&#39; and &#39;METRIC&#39; must be *runtime*
//       *constants*.  If the default metrics manager has not been
//       initialized, or if the indicated &#39;CATEGORY&#39; is currently disabled,
//       this macro has no effect.
//
//   BALM_METRICS_INT_UPDATE(CATEGORY, METRIC, VALUE)
//       Update the indicated metric, identified by the specified &#39;CATEGORY&#39;
//       and &#39;METRIC&#39; names, with the specified *integer* &#39;VALUE&#39;.  &#39;CATEGORY&#39;
//       and &#39;METRIC&#39; must be null-terminated strings of a type convertible to
//       &#39;const char *&#39;, and &#39;VALUE&#39; is assumed to be of a type convertible to
//       &#39;int&#39;.  This macro maintains a (function-scope static) cache
//       containing the identity of the metric being updated.  This cache is
//       initialized using the &#39;CATEGORY&#39; and &#39;METRIC&#39; specified on the *first*
//       application of this macro at a particular instantiation point;
//       subsequent applications use that cached information, which in
//       practice, means that &#39;CATEGORY&#39; and &#39;METRIC&#39; must be *runtime*
//       *constants*.  If the default metrics manager has not been initialized,
//       or if the indicated &#39;CATEGORY&#39; is currently disabled, this macro has
//       no effect.
//
//   BALM_METRICS_UPDATE2(CATEGORY, METRIC1, VALUE1, METRIC2, VALUE2)
//   BALM_METRICS_UPDATEn(CATEGORY, METRIC1, VALUE1, ..., METRICn, VALUEn)
//                                                            Where 2 &lt;= n &lt;= 6
//       Update each of the indicated metrics, identified by the specified
//       &#39;CATEGORY&#39; name and the respective metric names &#39;METRIC1&#39;, &#39;METRIC2&#39;,
//       ..., &#39;METRICn&#39; (2 &lt;= n &lt;= 6), with the corresponding specified
//       &#39;VALUE1&#39;, &#39;VALUE2&#39;, ..., &#39;VALUEn&#39;.  &#39;CATEGORY&#39; and &#39;METRIC1&#39;,
//       &#39;METRIC2&#39;, ..., &#39;METRICn&#39;, must be null-terminated strings of a type
//       convertible to &#39;const char *&#39;, and &#39;VALUE1&#39;, &#39;VALUE2&#39;, ..., &#39;VALUEn&#39;
//       are assumed to be of a type convertible to &#39;double&#39;.  These macros
//       maintain a (function-scope static) cache containing the identity of
//       the metrics being updated.  This cache is initialized using the
//       &#39;CATEGORY&#39; and metric identifiers specified on the *first*
//       application of these macros at a particular instantiation point;
//       subsequent applications use that cached information, which in
//       practice means that the &#39;CATEGORY&#39; and metric identifiers must be
//       *runtime* *constants*.  If the default metrics manager has not been
//       initialized, or if the indicated &#39;CATEGORY&#39; is currently disabled,
//       these macros have no effect.
//
//   BALM_METRICS_INT_UPDATE2(CATEGORY, METRIC1, VALUE1, METRIC2, VALUE2)
//   BALM_METRICS_INT_UPDATEn(CATEGORY, METRIC1, VALUE1, ..., METRICn, VALUEn)
//                                                            Where 2 &lt;= n &lt;= 6
//       Update each of the indicated metrics, identified by the specified
//       &#39;CATEGORY&#39; name and the respective metric names &#39;METRIC1&#39;, &#39;METRIC2&#39;,
//       ..., &#39;METRICn&#39; (2 &lt;= n &lt;= 6), with the corresponding specified
//       *integer* &#39;VALUE1&#39;, &#39;VALUE2&#39;, ..., &#39;VALUEn&#39;.  &#39;CATEGORY&#39; and
//       &#39;METRIC1&#39;, &#39;METRIC2&#39;, ..., &#39;METRICn&#39;, must be null-terminated strings
//       of a type convertible to &#39;const char *&#39;, and &#39;VALUE1&#39;, &#39;VALUE2&#39;, ...,
//       &#39;VALUEn&#39; are assumed to be of a type convertible to &#39;int&#39;.  These
//       macros maintain a (function-scope static) cache containing the
//       identity of the metrics being updated.  This cache is initialized
//       using the &#39;CATEGORY&#39; and metric identifiers specified on the *first*
//       application of these macros at a particular instantiation point;
//       subsequent applications use that cached information, which in
//       practice means that the &#39;CATEGORY&#39; and metric identifiers must be
//       *runtime* *constants*.  If the default metrics manager has not been
//       initialized, or if the indicated &#39;CATEGORY&#39; is currently disabled,
//       these macros have no effect.
//
//   BALM_METRICS_TYPED_UPDATE(CATEGORY,
//                             METRIC,
//                             VALUE,
//                             PREFERRED_PUBLICATION_TYPE)
//   BALM_METRICS_TYPED_INT_UPDATE(CATEGORY,
//                                 METRIC,
//                                 VALUE,
//                                 PREFERRED_PUBLICATION_TYPE)
//       The behavior of these macros is logically equivalent to
//       &#39;BALM_METRICS_UPDATE(CATEGORY, METRIC, VALUE)&#39; and
//       &#39;BALM_METRICS_INT_UPDATE(CATEGORY, METRIC, VALUE)&#39;, respectively,
//       except that, on the first invocation, these macros also set the
//       indicated metric&#39;s &#39;PREFERRED_PUBLICATION_TYPE&#39;.  The preferred
//       publication type of a metric indicates the preferred aggregate to
//       publish for that metric (e.g., &#39;COUNT&#39;, &#39;TOTAL&#39;, &#39;MIN&#39;, &#39;MAX&#39;, or
//       &#39;RATE&#39;).  The behavior is undefined unless
//       &#39;PREFERRED_PUBLICATION_TYPE&#39; is convertible to
//       &#39;balm::PublicationType::Value&#39;.  Note that there is no uniform
//       definition for how publishers will interpret this value; an
//       &#39;UNSPECIFIED&#39; value, however, generally indicates that all of the
//       collected aggregates (total, count, minimum, and maximum value)
//       should be published.
//
//   BALM_METRICS_INCREMENT(CATEGORY, METRIC)
//       The behavior of this macro is logically equivalent to:
//       &#39;BALM_METRICS_INT_UPDATE(CATEGORY, METRIC, 1)&#39;.
//
//   BALM_METRICS_TYPED_INCREMENT(CATEGORY, METRIC, PREFERRED_TYPE)
//       The behavior of this macro is logically equivalent to
//       &#39;BALM_METRICS_TYPED_UPDATE(CATEGORY, METRIC, 1, PREFERRED_TYPE)&#39;.
//..
//  The following are the dynamic macros provided by this component for
//  updating a metric&#39;s value; these macros do not statically cache the
//  identity of the metric and look up the supplied &#39;CATEGORY&#39; and &#39;METRIC&#39; on
//  each invocation:
//..
//   BALM_METRICS_DYNAMIC_UPDATE(CATEGORY, METRIC, VALUE)
//       Update the indicated metric, identified by the specified &#39;CATEGORY&#39;
//       and &#39;METRIC&#39; names, by the specified &#39;VALUE&#39;.  &#39;CATEGORY&#39; and
//       &#39;METRIC&#39; must be null-terminated strings of a type convertible to
//       &#39;const char *&#39;, and &#39;VALUE&#39; is assumed to be of a type convertible to
//       &#39;double&#39;.  If the default metrics manager has not been initialized,
//       or if the indicated &#39;CATEGORY&#39; is currently disabled, this macro has
//       no effect.  Note that this operation looks up the &#39;CATEGORY&#39;
//       and &#39;METRIC&#39; on *each* application, resulting in (unnecessary)
//       additional runtime overhead (if the &#39;CATEGORY&#39; and &#39;METRIC&#39; values are
//       always the same for a particular point of call).
//
//   BALM_METRICS_DYNAMIC_INT_UPDATE(CATEGORY, METRIC, VALUE)
//       Update the indicated metric, identified by the specified &#39;CATEGORY&#39;
//       and &#39;METRIC&#39; names, by the specified *integer* &#39;VALUE&#39;.  &#39;CATEGORY&#39;
//       and &#39;METRIC&#39; must be null-terminated strings of a type convertible to
//       &#39;const char *&#39;, and &#39;VALUE&#39; is assumed to be of a type convertible
//       to &#39;int&#39;.  If the default metrics manager has not been initialized,
//       or if the indicated &#39;CATEGORY&#39; is currently disabled, this macro has
//       no effect.  Note that this operation looks up the &#39;CATEGORY&#39;
//       and &#39;METRIC&#39; on *each* application, resulting in (unnecessary)
//       additional runtime overhead (if the &#39;CATEGORY&#39; and &#39;METRIC&#39; values
//       are always the same for a particular point of call).
//
//   BALM_METRICS_DYNAMIC_INCREMENT(CATEGORY, METRIC)
//       The behavior of this macro is logically equivalent to
//       &#39;BALM_METRICS_DYNAMIC_INT_UPDATE(CATEGORY, METRIC, 1)&#39;.
//..
// The following macro, &#39;BALM_METRICS_IF_CATEGORY_ENABLED&#39;, allows clients to
// (efficiently) determine if a (*runtime* *constant*) category is enabled:
//..
//   BALM_METRICS_IF_CATEGORY_ENABLED(CATEGORY)
//       This macro behaves like an &#39;if&#39; clause, executing the subsequent
//       (compound) statement if the specified &#39;CATEGORY&#39; is enabled.
//       &#39;CATEGORY&#39; must be a null-terminated string of a type convertible to
//       &#39;const char *&#39;.  If the default metrics manager has not been
//       initialized, or if the indicated &#39;CATEGORY&#39; is currently disabled,
//       the following statement is not executed (i.e., the &#39;if&#39;-condition
//       is &#39;false&#39;).  This macro maintains a (function-scope static) cache
//       containing the identity of the category.  This cache is initialized
//       using the &#39;CATEGORY&#39; specified on the *first* application of this
//       macro at a particular instantiation point; subsequent applications
//       use that cached information, which in practice means that
//       &#39;CATEGORY&#39; must be a *runtime* *constant*.  *WARNING*: although the
//       &#39;BALM_METRICS_IF_CATEGORY_ENABLED&#39; may look like a function call,
//       it actually consists of a declaration and an &#39;if&#39; statement, which
//       means that the following is syntactically *incorrect*:
//       &#39;if (BALM_METRICS_IF_CATEGORY_ENABLED(&quot;myCategory&quot;)) { stuff() }&#39;.
//       That should instead be written as:
//       &#39;BALM_METRICS_IF_CATEGORY_ENABLED(&quot;myCategory&quot;) { stuff(); }&#39;.
//..
// Finally, this component provides a set of macros to record the elapsed wall
// time of a block of code:
//..
//   BALM_METRICS_TIME_BLOCK(CATEGORY, METRIC, TIME_UNITS)
//       Update the indicated metric, identified by the specified &#39;CATEGORY&#39;
//       and &#39;METRIC&#39; names, by the elapsed (wall) time, in the specified
//       &#39;TIME_UNITS&#39;, from the point of instantiation of the macro to the end
//       of the enclosing lexical scope.  &#39;CATEGORY&#39; and &#39;METRIC&#39;  must be
//       null-terminated strings of a type convertible to &#39;const char *&#39;,
//       while &#39;TIME_UNITS&#39; is assumed to be of a type convertible to the
//       enumerated type &#39;balm::StopwatchScopedGuard::Units&#39;.  This macro
//       maintains a (function-scope static) cache containing the identity of
//       the metric being updated.  This cache is initialized using the
//       &#39;CATEGORY&#39; and &#39;METRIC&#39; specified on the *first* application of this
//       macro at a particular instantiation point; subsequent applications
//       use that cached information, which in practice means that
//       &#39;CATEGORY&#39; and &#39;METRIC&#39; must be *runtime* *constants*.  If the
//       default metrics manager has not been initialized, or the identified
//       &#39;CATEGORY&#39; is disabled, this macro has no effect.  Note that
//       &#39;TIME_UNITS&#39; indicates the scale of value to report, but does *not*
//       affect the precision of the elapsed time measurement.
//
//   BALM_METRICS_TIME_BLOCK_SECONDS(CATEGORY, METRIC)
//       The behavior of this macro is logically equivalent to
//       &#39;BALM_METRICS_TIME_BLOCK&#39; called with
//       &#39;balm::StopwatchScopedGuard::k_SECONDS&#39;.
//
//   BALM_METRICS_TIME_BLOCK_MILLISECONDS(CATEGORY, METRIC)
//       The behavior of this macro is logically equivalent to
//       &#39;BALM_METRICS_TIME_BLOCK&#39; called with
//       &#39;balm::StopwatchScopedGuard::k_MILLISECONDS&#39;.
//
//   BALM_METRICS_TIME_BLOCK_MICROSECONDS(CATEGORY, METRIC)
//       The behavior of this macro is logically equivalent to
//       &#39;BALM_METRICS_TIME_BLOCK&#39; called with
//       &#39;balm::StopwatchScopedGuard::k_MICROSECONDS&#39;.
//
//   BALM_METRICS_TIME_BLOCK_NANOSECONDS(CATEGORY, METRIC)
//       The behavior of this macro is logically equivalent to
//       &#39;BALM_METRICS_TIME_BLOCK&#39; called with
//       &#39;balm::StopwatchScopedGuard::k_NANOSECONDS&#39;.
//
//   BALM_METRICS_DYNAMIC_TIME_BLOCK(CATEGORY, METRIC, TIME_UNITS)
//       Update the indicated metric, identified by the specified &#39;CATEGORY&#39;
//       and &#39;METRIC&#39; names, by the elapsed (wall) time, in the specified
//       &#39;TIME_UNITS&#39;, from the instantiation of the macro to the end of the
//       enclosing lexical scope.  &#39;CATEGORY&#39; and &#39;METRIC&#39;  must be
//       null-terminated strings of a type convertible to &#39;const char *&#39;,
//       while &#39;TIME_UNITS&#39; is assumed to be of a type convertible to the
//       enumerated type &#39;balm::StopwatchScopedGuard::Units&#39;.  If the default
//       metrics manager has not been initialized, or the identified
//       &#39;CATEGORY&#39; is disabled, this macro has no effect.  Note that
//       this operation looks up the &#39;CATEGORY&#39; and &#39;METRIC&#39; on *each*
//       application, resulting in (unnecessary) additional runtime overhead
//       (if the &#39;CATEGORY&#39; and &#39;METRIC&#39; values are always the same for a
//       particular point of call).  Also note that &#39;TIME_UNITS&#39; indicates the
//       scale of value to report, but does *not* affect the precision of the
//       elapsed time measurement.
//
//   BALM_METRICS_DYNAMIC_TIME_BLOCK_SECONDS(CATEGORY, METRIC)
//       The behavior of this macro is logically equivalent to
//       &#39;BALM_METRICS_DYNAMIC_TIME_BLOCK&#39; called with
//       &#39;balm::StopwatchScopedGuard::k_SECONDS&#39;.
//
//   BALM_METRICS_DYNAMIC_TIME_BLOCK_MILLISECONDS(CATEGORY, METRIC)
//       The behavior of this macro is logically equivalent to
//       &#39;BALM_METRICS_DYNAMIC_TIME_BLOCK&#39; called with
//       &#39;balm::StopwatchScopedGuard::k_MILLISECONDS&#39;.
//
//   BALM_METRICS_DYNAMIC_TIME_BLOCK_MICROSECONDS(CATEGORY, METRIC)
//       The behavior of this macro is logically equivalent to
//       &#39;BALM_METRICS_DYNAMIC_TIME_BLOCK&#39; called with
//       &#39;balm::StopwatchScopedGuard::k_MICROSECONDS&#39;.
//
//   BALM_METRICS_DYNAMIC_TIME_BLOCK_NANOSECONDS(CATEGORY, METRIC)
//       The behavior of this macro is logically equivalent to
//       &#39;BALM_METRICS_DYNAMIC_TIME_BLOCK&#39; called with
//       &#39;balm::StopwatchScopedGuard::k_NANOSECONDS&#39;.
//..
//
///Usage
///-----
// The following examples demonstrate how to configure, collect, and publish
// metrics.
//
///Example 1: Create and Configure the Default &#39;balm::MetricsManager&#39; Instance
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// This example demonstrates how to create the default &#39;balm::MetricsManager&#39;
// instance and perform a trivial configuration.
//
// First we create a &#39;balm::DefaultMetricsManagerScopedGuard&#39;, which manages
// the lifetime of the default metrics manager instance.  At construction, we
// provide this guard with an output stream (&#39;stdout&#39;) to which the default
// metrics manager will publish metrics.  Note that the default metrics
// manager is intended to be created and destroyed by the *owner* of &#39;main&#39;:
// An instance of the manager should be created during the initialization of
// an application (while the task has a single thread) and destroyed just
// prior to termination (when there is similarly a single thread).
//..
//  int main(int argc, char *argv[])
//  {
//      // ...
//
//      balm::DefaultMetricsManagerScopedGuard managerGuard(bsl::cout);
//..
// Once the default manager object has been created, it can be accessed using
// the &#39;instance&#39; operation.
//..
//      balm::MetricsManager *manager =
//                                     balm::DefaultMetricsManager::instance();
//      assert(0 != manager);
//..
// Note that the default metrics manager will be released when the
// &#39;managerGuard&#39; exits this scoped and is destroyed.  Clients that choose to
// explicitly call &#39;balm::DefaultMetricsManager::create()&#39; must also explicitly
// call &#39;balm::DefaultMetricsManager::release()&#39;.
//
///Example 2: Updating a Metric
/// - - - - - - - - - - - - - -
// Once a metrics manager is initialized, we can use the various macros to
// record metric values.  In this second example, we collect metrics from a
// hypothetical event-processing function.  We use &#39;BALM_METRICS_UPDATE&#39; to
// record the size of the data being processed to a metric named &quot;msgSize&quot;,
// and the elapsed time (in milliseconds) to process the event to a metric
// named &quot;elapsedTime&quot;.  Finally, we use &#39;BALM_METRICS_INCREMENT&#39; to record a
// count of failures to a metric named &quot;failureCount&quot;.  Note that we do not use
// the &#39;*_DYNAMIC_*&#39; variants of the &#39;BALM_METRICS_UPDATE&#39; or
// &#39;BALM_METRICS_INCREMENT&#39; macros because the category and metric names are
// constant across all applications of the macro at a particular instantiation
// point (the &#39;DYNAMIC&#39; variants look up the category and metric name on each
// application, which would incur unnecessary runtime overhead).
//..
//  int processEvent(int eventId, const bsl::string&amp; eventMessage)
//      // Process the event described by the specified &#39;eventId&#39; and
//      // &#39;eventMessage&#39;.  Return 0 on success, and a non-zero
//      // value otherwise.
//  {
//      int returnCode = 0;
//
//      BALM_METRICS_UPDATE(&quot;processEvent&quot;, &quot;msgSize&quot;, eventMessage.size());
//      BALM_METRICS_TIME_BLOCK_MILLISECONDS(&quot;processingEvent&quot;, &quot;elapsedTime&quot;);
//
//      // Process &#39;data&#39;.
//
//      if (0 != returnCode) {
//          BALM_METRICS_INCREMENT(&quot;processEvent&quot;, &quot;failureCount&quot;);
//      }
//
//      return returnCode;
//  }
//..
//
///Example 3: Using &#39;BALM_METRICS_IF_CATEGORY_ENABLED&#39;
///- - - - - - - - - - - - - - - - - - - - - - - - - -
// In this next example, we use &#39;BALM_METRICS_IF_CATEGORY_ENABLED&#39; to
// conditionally disable a (relatively) expensive operation involved in
// computing a metric value.  The &#39;processEvent2&#39; function, defined below, uses
// a &#39;bsls::Stopwatch&#39; to record the elapsed system, user, and wall times,
// associated with processing the event.  The system calls used (via
// &#39;bsls::Stopwatch&#39;) to record the elapsed time may be relatively expensive,
// so we use &#39;BALM_METRICS_IF_CATEGORY_ENABLED&#39; to ensure we perform those
// operations only if metrics collection is enabled.  Finally, we use
// &#39;BALM_METRICS_UPDATE3&#39; to update the three metrics, which is (slightly) more
// efficient than updating each metric individually using &#39;BALM_METRIC_UPDATE&#39;.
//..
//  int processEvent2(int eventId, const bsl::string&amp; eventMessage)
//      // Process the event described by the specified &#39;eventId&#39; and
//      // &#39;eventMessage&#39;.  Return 0 on success, and a non-zero
//      // value otherwise.
//  {
//      int returnCode = 0;
//
//      bsls::Stopwatch stopwatch;
//      BALM_METRICS_IF_CATEGORY_ENABLED(&quot;processEvent2&quot;) {
//         stopwatch.start(true);
//      }
//
//      // Process &#39;data&#39;.
//
//      BALM_METRICS_IF_CATEGORY_ENABLED(&quot;processEvent2&quot;) {
//         double systemTime, userTime, wallTime;
//         stopwatch.accumulatedTimes(&amp;systemTime, &amp;userTime, &amp;wallTime);
//         BALM_METRICS_UPDATE3(&quot;processEvent2&quot;,
//                              &quot;systemTime&quot;, systemTime,
//                              &quot;userTime&quot;,   userTime,
//                              &quot;wallTime&quot;,   wallTime);
//      }
//
//      return returnCode;
//  }
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BALM_CATEGORY
#include &lt;balm_category.h&gt;
#endif

#ifndef INCLUDED_BALM_COLLECTOR
#include &lt;balm_collector.h&gt;
#endif

#ifndef INCLUDED_BALM_COLLECTORREPOSITORY
#include &lt;balm_collectorrepository.h&gt;
#endif

#ifndef INCLUDED_BALM_DEFAULTMETRICSMANAGER
#include &lt;balm_defaultmetricsmanager.h&gt;
#endif

#ifndef INCLUDED_BALM_INTEGERCOLLECTOR
#include &lt;balm_integercollector.h&gt;
#endif

#ifndef INCLUDED_BALM_METRICID
#include &lt;balm_metricid.h&gt;
#endif

#ifndef INCLUDED_BALM_METRICREGISTRY
#include &lt;balm_metricregistry.h&gt;
#endif

#ifndef INCLUDED_BALM_METRICSMANAGER
#include &lt;balm_metricsmanager.h&gt;
#endif

#ifndef INCLUDED_BALM_PUBLICATIONTYPE
#include &lt;balm_publicationtype.h&gt;
#endif

#ifndef INCLUDED_BALM_STOPWATCHSCOPEDGUARD
#include &lt;balm_stopwatchscopedguard.h&gt;
#endif

#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#include &lt;bsls_performancehint.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

                        // ================================
                        // BALM_METRICS_IF_CATEGORY_ENABLED
                        // ================================

#define BALM_METRICS_IF_CATEGORY_ENABLED(CATEGORY)                            \
    BALM_METRICS_IF_CATEGORY_ENABLED_IMP(                                     \
                            CATEGORY, BALM_METRICS_UNIQUE_NAME(categoryHolder))

                        // ===================
                        // BALM_METRICS_UPDATE
                        // ===================

// Note that the static collector address must be assigned *before*
// initializing category holder to ensure initialization is thread safe.
#define BALM_METRICS_UPDATE(CATEGORY, METRIC1, VALUE1) do {                   \
   using namespace BloombergLP;                                               \
   typedef balm::Metrics_Helper Helper;                                       \
   static balm::CategoryHolder holder = { false, 0, 0 };                      \
   static balm::Collector *collector1 = 0;                                    \
   if (0 == holder.category() &amp;&amp; balm::DefaultMetricsManager::instance()) {   \
     Helper::logEmptyName(CATEGORY,Helper::e_TYPE_CATEGORY,__FILE__,__LINE__);\
     Helper::logEmptyName(METRIC1, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
       collector1 = Helper::getCollector(CATEGORY, METRIC1);                  \
       Helper::initializeCategoryHolder(&amp;holder, CATEGORY);                   \
   }                                                                          \
   if (holder.enabled()) {                                                    \
       collector1-&gt;update(VALUE1);                                            \
   }                                                                          \
 } while (0)

#define BALM_METRICS_UPDATE2(CATEGORY, METRIC1, VALUE1, METRIC2, VALUE2) do { \
   using namespace BloombergLP;                                               \
   typedef balm::Metrics_Helper Helper;                                       \
   static balm::CategoryHolder holder = { false, 0, 0 };                      \
   static balm::Collector *collector1 = 0;                                    \
   static balm::Collector *collector2 = 0;                                    \
   if (0 == holder.category() &amp;&amp; balm::DefaultMetricsManager::instance()) {   \
     Helper::logEmptyName(CATEGORY,Helper::e_TYPE_CATEGORY,__FILE__,__LINE__);\
     Helper::logEmptyName(METRIC1, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC2, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
       collector1 = Helper::getCollector(CATEGORY, METRIC1);                  \
       collector2 = Helper::getCollector(CATEGORY, METRIC2);                  \
       Helper::initializeCategoryHolder(&amp;holder, CATEGORY);                   \
   }                                                                          \
   if (holder.enabled()) {                                                    \
       collector1-&gt;update(VALUE1);                                            \
       collector2-&gt;update(VALUE2);                                            \
   }                                                                          \
 } while (0)

#define BALM_METRICS_UPDATE3(CATEGORY,                                        \
                             METRIC1,                                         \
                             VALUE1,                                          \
                             METRIC2,                                         \
                             VALUE2,                                          \
                             METRIC3,                                         \
                             VALUE3) do {                                     \
   using namespace BloombergLP;                                               \
   typedef balm::Metrics_Helper Helper;                                       \
   static balm::CategoryHolder holder = { false, 0, 0 };                      \
   static balm::Collector *collector1 = 0;                                    \
   static balm::Collector *collector2 = 0;                                    \
   static balm::Collector *collector3 = 0;                                    \
   if (0 == holder.category() &amp;&amp; balm::DefaultMetricsManager::instance()) {   \
     Helper::logEmptyName(CATEGORY,Helper::e_TYPE_CATEGORY,__FILE__,__LINE__);\
     Helper::logEmptyName(METRIC1, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC2, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC3, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
       collector1 = Helper::getCollector(CATEGORY, METRIC1);                  \
       collector2 = Helper::getCollector(CATEGORY, METRIC2);                  \
       collector3 = Helper::getCollector(CATEGORY, METRIC3);                  \
       Helper::initializeCategoryHolder(&amp;holder, CATEGORY);                   \
   }                                                                          \
   if (holder.enabled()) {                                                    \
       collector1-&gt;update(VALUE1);                                            \
       collector2-&gt;update(VALUE2);                                            \
       collector3-&gt;update(VALUE3);                                            \
   }                                                                          \
 } while (0)

#define BALM_METRICS_UPDATE4(CATEGORY,                                        \
                             METRIC1,                                         \
                             VALUE1,                                          \
                             METRIC2,                                         \
                             VALUE2,                                          \
                             METRIC3,                                         \
                             VALUE3,                                          \
                             METRIC4,                                         \
                             VALUE4) do {                                     \
   using namespace BloombergLP;                                               \
   typedef balm::Metrics_Helper Helper;                                       \
   static balm::CategoryHolder holder = { false, 0, 0 };                      \
   static balm::Collector *collector1 = 0;                                    \
   static balm::Collector *collector2 = 0;                                    \
   static balm::Collector *collector3 = 0;                                    \
   static balm::Collector *collector4 = 0;                                    \
   if (0 == holder.category() &amp;&amp; balm::DefaultMetricsManager::instance()) {   \
     Helper::logEmptyName(CATEGORY,Helper::e_TYPE_CATEGORY,__FILE__,__LINE__);\
     Helper::logEmptyName(METRIC1, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC2, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC3, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC4, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
       collector1 = Helper::getCollector(CATEGORY, METRIC1);                  \
       collector2 = Helper::getCollector(CATEGORY, METRIC2);                  \
       collector3 = Helper::getCollector(CATEGORY, METRIC3);                  \
       collector4 = Helper::getCollector(CATEGORY, METRIC4);                  \
       Helper::initializeCategoryHolder(&amp;holder, CATEGORY);                   \
   }                                                                          \
   if (holder.enabled()) {                                                    \
       collector1-&gt;update(VALUE1);                                            \
       collector2-&gt;update(VALUE2);                                            \
       collector3-&gt;update(VALUE3);                                            \
       collector4-&gt;update(VALUE4);                                            \
   }                                                                          \
 } while (0)

#define BALM_METRICS_UPDATE5(CATEGORY,                                        \
                             METRIC1,                                         \
                             VALUE1,                                          \
                             METRIC2,                                         \
                             VALUE2,                                          \
                             METRIC3,                                         \
                             VALUE3,                                          \
                             METRIC4,                                         \
                             VALUE4,                                          \
                             METRIC5,                                         \
                             VALUE5) do {                                     \
   using namespace BloombergLP;                                               \
   typedef balm::Metrics_Helper Helper;                                       \
   static balm::CategoryHolder holder = { false, 0, 0 };                      \
   static balm::Collector *collector1 = 0;                                    \
   static balm::Collector *collector2 = 0;                                    \
   static balm::Collector *collector3 = 0;                                    \
   static balm::Collector *collector4 = 0;                                    \
   static balm::Collector *collector5 = 0;                                    \
   if (0 == holder.category() &amp;&amp; balm::DefaultMetricsManager::instance()) {   \
     Helper::logEmptyName(CATEGORY,Helper::e_TYPE_CATEGORY,__FILE__,__LINE__);\
     Helper::logEmptyName(METRIC1, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC2, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC3, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC4, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC5, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
       collector1 = Helper::getCollector(CATEGORY, METRIC1);                  \
       collector2 = Helper::getCollector(CATEGORY, METRIC2);                  \
       collector3 = Helper::getCollector(CATEGORY, METRIC3);                  \
       collector4 = Helper::getCollector(CATEGORY, METRIC4);                  \
       collector5 = Helper::getCollector(CATEGORY, METRIC5);                  \
       Helper::initializeCategoryHolder(&amp;holder, CATEGORY);                   \
   }                                                                          \
   if (holder.enabled()) {                                                    \
       collector1-&gt;update(VALUE1);                                            \
       collector2-&gt;update(VALUE2);                                            \
       collector3-&gt;update(VALUE3);                                            \
       collector4-&gt;update(VALUE4);                                            \
       collector5-&gt;update(VALUE5);                                            \
   }                                                                          \
 } while (0)

#define BALM_METRICS_UPDATE6(CATEGORY,                                        \
                             METRIC1,                                         \
                             VALUE1,                                          \
                             METRIC2,                                         \
                             VALUE2,                                          \
                             METRIC3,                                         \
                             VALUE3,                                          \
                             METRIC4,                                         \
                             VALUE4,                                          \
                             METRIC5,                                         \
                             VALUE5,                                          \
                             METRIC6,                                         \
                             VALUE6) do {                                     \
   using namespace BloombergLP;                                               \
   typedef balm::Metrics_Helper Helper;                                       \
   static balm::CategoryHolder holder = { false, 0, 0 };                      \
   static balm::Collector *collector1 = 0;                                    \
   static balm::Collector *collector2 = 0;                                    \
   static balm::Collector *collector3 = 0;                                    \
   static balm::Collector *collector4 = 0;                                    \
   static balm::Collector *collector5 = 0;                                    \
   static balm::Collector *collector6 = 0;                                    \
   if (0 == holder.category() &amp;&amp; balm::DefaultMetricsManager::instance()) {   \
     Helper::logEmptyName(CATEGORY, Helper::e_TYPE_CATEGORY,                  \
                            __FILE__, __LINE__);                              \
     Helper::logEmptyName(METRIC1, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC2, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC3, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC4, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC5, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC6, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
       collector1 = Helper::getCollector(CATEGORY, METRIC1);                  \
       collector2 = Helper::getCollector(CATEGORY, METRIC2);                  \
       collector3 = Helper::getCollector(CATEGORY, METRIC3);                  \
       collector4 = Helper::getCollector(CATEGORY, METRIC4);                  \
       collector5 = Helper::getCollector(CATEGORY, METRIC5);                  \
       collector6 = Helper::getCollector(CATEGORY, METRIC6);                  \
       Helper::initializeCategoryHolder(&amp;holder, CATEGORY);                   \
   }                                                                          \
   if (holder.enabled()) {                                                    \
       collector1-&gt;update(VALUE1);                                            \
       collector2-&gt;update(VALUE2);                                            \
       collector3-&gt;update(VALUE3);                                            \
       collector4-&gt;update(VALUE4);                                            \
       collector5-&gt;update(VALUE5);                                            \
       collector6-&gt;update(VALUE6);                                            \
   }                                                                          \
 } while (0)

#define BALM_METRICS_TYPED_UPDATE(CATEGORY, METRIC, VALUE, PREFERRED_TYPE)    \
 do {                                                                         \
   using namespace BloombergLP;                                               \
   typedef balm::Metrics_Helper Helper;                                       \
   static balm::CategoryHolder holder = { false, 0, 0 };                      \
   static balm::Collector *collector1 = 0;                                    \
   if (0 == holder.category() &amp;&amp; balm::DefaultMetricsManager::instance()) {   \
     Helper::logEmptyName(CATEGORY,Helper::e_TYPE_CATEGORY,__FILE__,__LINE__);\
     Helper::logEmptyName(METRIC, Helper::e_TYPE_METRIC, __FILE__, __LINE__); \
       collector1 = Helper::getCollector(CATEGORY, METRIC);                   \
       Helper::setPublicationType(collector1-&gt;metricId(), PREFERRED_TYPE);    \
       Helper::initializeCategoryHolder(&amp;holder, CATEGORY);                   \
   }                                                                          \
   if (holder.enabled()) {                                                    \
       collector1-&gt;update(VALUE);                                             \
   }                                                                          \
 } while (0)

#define BALM_METRICS_DYNAMIC_UPDATE(CATEGORY, METRIC, VALUE) do {             \
    using namespace BloombergLP;                                              \
    if (balm::DefaultMetricsManager::instance()) {                            \
        balm::CollectorRepository&amp; repository =                               \
             balm::DefaultMetricsManager::instance()-&gt;collectorRepository();  \
        balm::Collector *collector = repository.getDefaultCollector(          \
                                                        (CATEGORY), (METRIC));\
        if (collector-&gt;metricId().category()-&gt;enabled()) {                    \
            collector-&gt;update((VALUE));                                       \
        }                                                                     \
    }                                                                         \
  } while(0)

                        // =======================
                        // BALM_METRICS_INT_UPDATE
                        // =======================

#define BALM_METRICS_INT_UPDATE(CATEGORY, METRIC1, VALUE1) do {               \
   using namespace BloombergLP;                                               \
   typedef balm::Metrics_Helper Helper;                                       \
   static balm::CategoryHolder holder = { false, 0, 0 };                      \
   static balm::IntegerCollector *collector1 = 0;                             \
   if (0 == holder.category() &amp;&amp; balm::DefaultMetricsManager::instance()) {   \
     Helper::logEmptyName(CATEGORY,Helper::e_TYPE_CATEGORY,__FILE__,__LINE__);\
     Helper::logEmptyName(METRIC1, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
       collector1 = Helper::getIntegerCollector(CATEGORY, METRIC1);           \
       Helper::initializeCategoryHolder(&amp;holder, CATEGORY);                   \
   }                                                                          \
   if (holder.enabled()) {                                                    \
       collector1-&gt;update(VALUE1);                                            \
   }                                                                          \
 } while (0)

#define BALM_METRICS_INT_UPDATE2(CATEGORY,                                    \
                                 METRIC1,                                     \
                                 VALUE1,                                      \
                                 METRIC2,                                     \
                                 VALUE2) do {                                 \
   using namespace BloombergLP;                                               \
   typedef balm::Metrics_Helper Helper;                                       \
   static balm::CategoryHolder holder = { false, 0, 0 };                      \
   static balm::IntegerCollector *collector1 = 0;                             \
   static balm::IntegerCollector *collector2 = 0;                             \
   if (0 == holder.category() &amp;&amp; balm::DefaultMetricsManager::instance()) {   \
     Helper::logEmptyName(CATEGORY,Helper::e_TYPE_CATEGORY,__FILE__,__LINE__);\
     Helper::logEmptyName(METRIC1, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC2, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
       collector1 = Helper::getIntegerCollector(CATEGORY, METRIC1);           \
       collector2 = Helper::getIntegerCollector(CATEGORY, METRIC2);           \
       Helper::initializeCategoryHolder(&amp;holder, CATEGORY);                   \
   }                                                                          \
   if (holder.enabled()) {                                                    \
       collector1-&gt;update(VALUE1);                                            \
       collector2-&gt;update(VALUE2);                                            \
   }                                                                          \
 } while (0)

#define BALM_METRICS_INT_UPDATE3(CATEGORY,                                    \
                                 METRIC1,                                     \
                                 VALUE1,                                      \
                                 METRIC2,                                     \
                                 VALUE2,                                      \
                                 METRIC3,                                     \
                                 VALUE3) do {                                 \
   using namespace BloombergLP;                                               \
   typedef balm::Metrics_Helper Helper;                                       \
   static balm::CategoryHolder holder = { false, 0, 0 };                      \
   static balm::IntegerCollector *collector1 = 0;                             \
   static balm::IntegerCollector *collector2 = 0;                             \
   static balm::IntegerCollector *collector3 = 0;                             \
   if (0 == holder.category() &amp;&amp; balm::DefaultMetricsManager::instance()) {   \
     Helper::logEmptyName(CATEGORY,Helper::e_TYPE_CATEGORY,__FILE__,__LINE__);\
     Helper::logEmptyName(METRIC1, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC2, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC3, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
       collector1 = Helper::getIntegerCollector(CATEGORY, METRIC1);           \
       collector2 = Helper::getIntegerCollector(CATEGORY, METRIC2);           \
       collector3 = Helper::getIntegerCollector(CATEGORY, METRIC3);           \
       Helper::initializeCategoryHolder(&amp;holder, CATEGORY);                   \
   }                                                                          \
   if (holder.enabled()) {                                                    \
       collector1-&gt;update(VALUE1);                                            \
       collector2-&gt;update(VALUE2);                                            \
       collector3-&gt;update(VALUE3);                                            \
   }                                                                          \
 } while (0)

#define BALM_METRICS_INT_UPDATE4(CATEGORY,                                    \
                                 METRIC1,                                     \
                                 VALUE1,                                      \
                                 METRIC2,                                     \
                                 VALUE2,                                      \
                                 METRIC3,                                     \
                                 VALUE3,                                      \
                                 METRIC4,                                     \
                                 VALUE4) do {                                 \
   using namespace BloombergLP;                                               \
   typedef balm::Metrics_Helper Helper;                                       \
   static balm::CategoryHolder holder = { false, 0, 0 };                      \
   static balm::IntegerCollector *collector1 = 0;                             \
   static balm::IntegerCollector *collector2 = 0;                             \
   static balm::IntegerCollector *collector3 = 0;                             \
   static balm::IntegerCollector *collector4 = 0;                             \
   if (0 == holder.category() &amp;&amp; balm::DefaultMetricsManager::instance()) {   \
     Helper::logEmptyName(CATEGORY,Helper::e_TYPE_CATEGORY,__FILE__,__LINE__);\
     Helper::logEmptyName(METRIC1, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC2, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC3, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC4, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
       collector1 = Helper::getIntegerCollector(CATEGORY, METRIC1);           \
       collector2 = Helper::getIntegerCollector(CATEGORY, METRIC2);           \
       collector3 = Helper::getIntegerCollector(CATEGORY, METRIC3);           \
       collector4 = Helper::getIntegerCollector(CATEGORY, METRIC4);           \
       Helper::initializeCategoryHolder(&amp;holder, CATEGORY);                   \
   }                                                                          \
   if (holder.enabled()) {                                                    \
       collector1-&gt;update(VALUE1);                                            \
       collector2-&gt;update(VALUE2);                                            \
       collector3-&gt;update(VALUE3);                                            \
       collector4-&gt;update(VALUE4);                                            \
   }                                                                          \
 } while (0)

#define BALM_METRICS_INT_UPDATE5(CATEGORY,                                    \
                                 METRIC1,                                     \
                                 VALUE1,                                      \
                                 METRIC2,                                     \
                                 VALUE2,                                      \
                                 METRIC3,                                     \
                                 VALUE3,                                      \
                                 METRIC4,                                     \
                                 VALUE4,                                      \
                                 METRIC5,                                     \
                                 VALUE5) do {                                 \
   using namespace BloombergLP;                                               \
   typedef balm::Metrics_Helper Helper;                                       \
   static balm::CategoryHolder holder = { false, 0, 0 };                      \
   static balm::IntegerCollector *collector1 = 0;                             \
   static balm::IntegerCollector *collector2 = 0;                             \
   static balm::IntegerCollector *collector3 = 0;                             \
   static balm::IntegerCollector *collector4 = 0;                             \
   static balm::IntegerCollector *collector5 = 0;                             \
   if (0 == holder.category() &amp;&amp; balm::DefaultMetricsManager::instance()) {   \
     Helper::logEmptyName(CATEGORY,Helper::e_TYPE_CATEGORY,__FILE__,__LINE__);\
     Helper::logEmptyName(METRIC1, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC2, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC3, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC4, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC5, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
       collector1 = Helper::getIntegerCollector(CATEGORY, METRIC1);           \
       collector2 = Helper::getIntegerCollector(CATEGORY, METRIC2);           \
       collector3 = Helper::getIntegerCollector(CATEGORY, METRIC3);           \
       collector4 = Helper::getIntegerCollector(CATEGORY, METRIC4);           \
       collector5 = Helper::getIntegerCollector(CATEGORY, METRIC5);           \
       Helper::initializeCategoryHolder(&amp;holder, CATEGORY);                   \
   }                                                                          \
   if (holder.enabled()) {                                                    \
       collector1-&gt;update(VALUE1);                                            \
       collector2-&gt;update(VALUE2);                                            \
       collector3-&gt;update(VALUE3);                                            \
       collector4-&gt;update(VALUE4);                                            \
       collector5-&gt;update(VALUE5);                                            \
   }                                                                          \
 } while (0)

#define BALM_METRICS_INT_UPDATE6(CATEGORY,                                    \
                                 METRIC1,                                     \
                                 VALUE1,                                      \
                                 METRIC2,                                     \
                                 VALUE2,                                      \
                                 METRIC3,                                     \
                                 VALUE3,                                      \
                                 METRIC4,                                     \
                                 VALUE4,                                      \
                                 METRIC5,                                     \
                                 VALUE5,                                      \
                                 METRIC6,                                     \
                                 VALUE6) do {                                 \
   using namespace BloombergLP;                                               \
   typedef balm::Metrics_Helper Helper;                                       \
   static balm::CategoryHolder holder = { false, 0, 0 };                      \
   static balm::IntegerCollector *collector1 = 0;                             \
   static balm::IntegerCollector *collector2 = 0;                             \
   static balm::IntegerCollector *collector3 = 0;                             \
   static balm::IntegerCollector *collector4 = 0;                             \
   static balm::IntegerCollector *collector5 = 0;                             \
   static balm::IntegerCollector *collector6 = 0;                             \
   if (0 == holder.category() &amp;&amp; balm::DefaultMetricsManager::instance()) {   \
     Helper::logEmptyName(CATEGORY,Helper::e_TYPE_CATEGORY,__FILE__,__LINE__);\
     Helper::logEmptyName(METRIC1, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC2, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC3, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC4, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC5, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
     Helper::logEmptyName(METRIC6, Helper::e_TYPE_METRIC, __FILE__, __LINE__);\
       collector1 = Helper::getIntegerCollector(CATEGORY, METRIC1);           \
       collector2 = Helper::getIntegerCollector(CATEGORY, METRIC2);           \
       collector3 = Helper::getIntegerCollector(CATEGORY, METRIC3);           \
       collector4 = Helper::getIntegerCollector(CATEGORY, METRIC4);           \
       collector5 = Helper::getIntegerCollector(CATEGORY, METRIC5);           \
       collector6 = Helper::getIntegerCollector(CATEGORY, METRIC6);           \
       Helper::initializeCategoryHolder(&amp;holder, CATEGORY);                   \
   }                                                                          \
   if (holder.enabled()) {                                                    \
       collector1-&gt;update(VALUE1);                                            \
       collector2-&gt;update(VALUE2);                                            \
       collector3-&gt;update(VALUE3);                                            \
       collector4-&gt;update(VALUE4);                                            \
       collector5-&gt;update(VALUE5);                                            \
       collector6-&gt;update(VALUE6);                                            \
   }                                                                          \
 } while (0)

#define BALM_METRICS_TYPED_INT_UPDATE(CATEGORY,                               \
                                      METRIC,                                 \
                                      VALUE,                                  \
                                      PREFERRED_TYPE)                         \
do {                                                                          \
   using namespace BloombergLP;                                               \
   typedef balm::Metrics_Helper Helper;                                       \
   static balm::CategoryHolder holder = { false, 0, 0 };                      \
   static balm::IntegerCollector *collector1 = 0;                             \
   if (0 == holder.category() &amp;&amp; balm::DefaultMetricsManager::instance()) {   \
     Helper::logEmptyName(CATEGORY,Helper::e_TYPE_CATEGORY,__FILE__,__LINE__);\
     Helper::logEmptyName(METRIC, Helper::e_TYPE_METRIC, __FILE__, __LINE__); \
       collector1 = Helper::getIntegerCollector(CATEGORY, METRIC);            \
       Helper::setPublicationType(collector1-&gt;metricId(), PREFERRED_TYPE);    \
       Helper::initializeCategoryHolder(&amp;holder, CATEGORY);                   \
   }                                                                          \
   if (holder.enabled()) {                                                    \
       collector1-&gt;update(VALUE);                                             \
   }                                                                          \
 } while (0)

#define BALM_METRICS_DYNAMIC_INT_UPDATE(CATEGORY, METRIC, VALUE) do {         \
    using namespace BloombergLP;                                              \
    if (balm::DefaultMetricsManager::instance()) {                            \
        balm::CollectorRepository&amp; repository =                               \
             balm::DefaultMetricsManager::instance()-&gt;collectorRepository();  \
        balm::IntegerCollector *collector =                                   \
               repository.getDefaultIntegerCollector((CATEGORY), (METRIC));   \
        if (collector-&gt;metricId().category()-&gt;enabled()) {                    \
            collector-&gt;update((VALUE));                                       \
        }                                                                     \
    }                                                                         \
  } while (0)

#define BALM_METRICS_INCREMENT(CATEGORY, METRIC)                              \
    BALM_METRICS_INT_UPDATE(CATEGORY, METRIC, 1)

#define BALM_METRICS_TYPED_INCREMENT(CATEGORY, METRIC, PREFERRED_TYPE)        \
    BALM_METRICS_TYPED_INT_UPDATE(CATEGORY, METRIC, 1, PREFERRED_TYPE)

#define BALM_METRICS_DYNAMIC_INCREMENT(CATEGORY, METRIC)                      \
    BALM_METRICS_DYNAMIC_INT_UPDATE(CATEGORY, METRIC, 1)

                        // =======================
                        // BALM_METRICS_TIME_BLOCK
                        // =======================

#define BALM_METRICS_TIME_BLOCK(CATEGORY, METRIC, TIME_UNITS)                 \
  BALM_METRICS_TIME_BLOCK_IMP((CATEGORY),                                     \
                               (METRIC),                                      \
                               TIME_UNITS,                                    \
                               BALM_METRICS_UNIQUE_NAME(_bAlM_CoLlEcToR))

#define BALM_METRICS_DYNAMIC_TIME_BLOCK(CATEGORY, METRIC, TIME_UNITS)         \
  BALM_METRICS_DYNAMIC_TIME_BLOCK_IMP(                                        \
                                  (CATEGORY),                                 \
                                  (METRIC),                                   \
                                  TIME_UNITS,                                 \
                                  BALM_METRICS_UNIQUE_NAME(_bAlM_CoLlEcToR))

#define BALM_METRICS_TIME_BLOCK_SECONDS(CATEGORY, METRIC)                     \
  BALM_METRICS_TIME_BLOCK((CATEGORY),                                         \
                          (METRIC),                                           \
                          BloombergLP::balm::StopwatchScopedGuard::k_SECONDS);

#define BALM_METRICS_TIME_BLOCK_MILLISECONDS(CATEGORY, METRIC)                \
  BALM_METRICS_TIME_BLOCK(                                                    \
                      (CATEGORY),                                             \
                      (METRIC),                                               \
                      BloombergLP::balm::StopwatchScopedGuard::k_MILLISECONDS);

#define BALM_METRICS_TIME_BLOCK_MICROSECONDS(CATEGORY, METRIC)                \
  BALM_METRICS_TIME_BLOCK(                                                    \
                      (CATEGORY),                                             \
                      (METRIC),                                               \
                      BloombergLP::balm::StopwatchScopedGuard::k_MICROSECONDS);

#define BALM_METRICS_TIME_BLOCK_NANOSECONDS(CATEGORY, METRIC)                 \
  BALM_METRICS_TIME_BLOCK(                                                    \
                       (CATEGORY),                                            \
                       (METRIC),                                              \
                       BloombergLP::balm::StopwatchScopedGuard::k_NANOSECONDS);

#define BALM_METRICS_DYNAMIC_TIME_BLOCK_SECONDS(CATEGORY, METRIC)             \
  BALM_METRICS_DYNAMIC_TIME_BLOCK(                                            \
                           (CATEGORY),                                        \
                           (METRIC),                                          \
                           BloombergLP::balm::StopwatchScopedGuard::k_SECONDS);

#define BALM_METRICS_DYNAMIC_TIME_BLOCK_MILLISECONDS(CATEGORY, METRIC)        \
  BALM_METRICS_DYNAMIC_TIME_BLOCK(                                            \
                      (CATEGORY),                                             \
                      (METRIC),                                               \
                      BloombergLP::balm::StopwatchScopedGuard::k_MILLISECONDS);

#define BALM_METRICS_DYNAMIC_TIME_BLOCK_MICROSECONDS(CATEGORY, METRIC)        \
  BALM_METRICS_DYNAMIC_TIME_BLOCK(                                            \
                      (CATEGORY),                                             \
                      (METRIC),                                               \
                      BloombergLP::balm::StopwatchScopedGuard::k_MICROSECONDS);

#define BALM_METRICS_DYNAMIC_TIME_BLOCK_NANOSECONDS(CATEGORY, METRIC)         \
  BALM_METRICS_DYNAMIC_TIME_BLOCK(                                            \
                       (CATEGORY),                                            \
                       (METRIC),                                              \
                       BloombergLP::balm::StopwatchScopedGuard::k_NANOSECONDS);

                        // =====================
                        // Macro Implementations
                        // =====================

#define BALM_METRICS_IF_CATEGORY_ENABLED_IMP(CATEGORY, HOLDER_NAME)           \
    static BloombergLP::balm::CategoryHolder HOLDER_NAME = { false, 0, 0 };   \
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(!HOLDER_NAME.category())        \
     &amp;&amp; BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(                                \
                 BloombergLP::balm::DefaultMetricsManager::instance() != 0)) {\
        BloombergLP::balm::Metrics_Helper::initializeCategoryHolder(          \
                                                   &amp;HOLDER_NAME, CATEGORY);   \
    }                                                                         \
    if (HOLDER_NAME.enabled())

// Declare a static pointer to a &#39;balm::Collector&#39; with the specified
// &#39;VARIABLE_NAME&#39; and an initial value of 0.  If the default metrics manager
// is available and the declared pointer variable (named &#39;VARIABLE_NAME&#39;) is 0,
// assign to &#39;VARIABLE_NAME&#39; the address of a collector for the specified
// &#39;CATEGORY&#39; and &#39;METRIC&#39;.  Finally, declare a &#39;balm::StopwatchScopedGuard&#39;
// object with a unique variable name and supply its constructor the collector
// address held in &#39;VARIABLE_NAME&#39; and the specified &#39;TIME_UNITS&#39;.
#define BALM_METRICS_TIME_BLOCK_IMP(CATEGORY,                                 \
                                    METRIC,                                   \
                                    TIME_UNITS,                               \
                                    VARIABLE_NAME)                            \
    static BloombergLP::balm::Collector *VARIABLE_NAME = 0;                   \
    if (BloombergLP::balm::DefaultMetricsManager::instance()) {               \
       using namespace BloombergLP;                                           \
       if (0 == VARIABLE_NAME) {                                              \
           balm::CollectorRepository&amp; repository =                            \
              balm::DefaultMetricsManager::instance()-&gt;collectorRepository(); \
           VARIABLE_NAME = repository.getDefaultCollector((CATEGORY),         \
                                                          (METRIC));          \
       }                                                                      \
    }                                                                         \
    else {                                                                    \
       VARIABLE_NAME = 0;                                                     \
    }                                                                         \
    BloombergLP::balm::StopwatchScopedGuard                                   \
         BALM_METRICS_UNIQUE_NAME(__bAlM_gUaRd)(VARIABLE_NAME, TIME_UNITS);

// Declare a pointer to a &#39;balm::Collector&#39; with the specified &#39;VARIABLE_NAME&#39;.
// If the default metrics manager is available, assign to the declared pointer
// variable (named &#39;VARIABLE_NAME&#39;) the address of a collector for the
// specified &#39;CATEGORY&#39; and &#39;METRIC&#39;.  Finally, declare a
// &#39;balm::StopwatchScopedGuard&#39; object with a unique variable name and supply
// its constructor the collector address held in &#39;VARIABLE_NAME&#39; and the
// specified &#39;TIME_UNITS&#39;.
#define BALM_METRICS_DYNAMIC_TIME_BLOCK_IMP(CATEGORY,                         \
                                            METRIC,                           \
                                            TIME_UNITS,                       \
                                            VARIABLE_NAME)                    \
    BloombergLP::balm::Collector *VARIABLE_NAME = 0;                          \
    if (BloombergLP::balm::DefaultMetricsManager::instance()) {               \
        using namespace BloombergLP;                                          \
        balm::CollectorRepository&amp; repository =                               \
             balm::DefaultMetricsManager::instance()-&gt;collectorRepository();  \
        VARIABLE_NAME = repository.getDefaultCollector((CATEGORY),            \
                                                       (METRIC));             \
    }                                                                         \
    BloombergLP::balm::StopwatchScopedGuard                                   \
         BALM_METRICS_UNIQUE_NAME(__bAlM_gUaRd)(VARIABLE_NAME, TIME_UNITS);

                        // ------------------------
                        // Unique line number macro
                        // ------------------------

#if defined(BSLS_PLATFORM_CMP_MSVC)
// MSVC: __LINE__ macro breaks when /ZI is used (see Q199057 or KB199057)
// Fortunately the __COUNTER__ extension provided by MSVC is even better.
#   define BALM_METRICS_UNIQNUM __COUNTER__
#else
#   define BALM_METRICS_UNIQNUM __LINE__
#endif

                        // ----------------------------------
                        // Token concatenation support macros
                        // ----------------------------------

// Second layer needed to ensure that arguments are expanded before
// concatenation.
#define BALM_METRICS_CAT(X, Y) BALM_METRICS_CAT_IMP(X, Y)
#define BALM_METRICS_CAT_IMP(X, Y) X##Y

                        // ----------------------------------
                        // Unique variable name support macro
                        // ----------------------------------

// Create a unique variable name by concatenating the specified &#39;X&#39; string
// with a unique integer value.
#define BALM_METRICS_UNIQUE_NAME(X)                                           \
           BALM_METRICS_CAT(X, BALM_METRICS_UNIQNUM)

namespace BloombergLP {

namespace balm {
                           // =====================
                           // struct Metrics_Helper
                           // =====================

struct Metrics_Helper {
    // This &#39;struct&#39; provides a namespace for a suite of functions used in the
    // implementation of the macros defined in this component.
    //
    // This type is an implementation detail and *must* *not* be used
    // (directly) by clients outside of this component.

    // TYPES
    enum NameType {
        // Enumeration indicating the type of identifier supplied to
        // &#39;logEmptyName&#39;.

        e_TYPE_CATEGORY = 0,
        e_TYPE_METRIC   = 1
    };

    // CLASS METHODS
    static void initializeCategoryHolder(CategoryHolder *holder,
                                         const char     *category);
        // Load into the specified &#39;holder&#39; the address and enabled status of
        // the specified &#39;category&#39;, and add &#39;holder&#39; to the list of category
        // holders for &#39;category&#39;.  The behavior is undefined unless the balm
        // metrics manager singleton is valid.

    static Collector *getCollector(const char *category,
                                   const char *metric);
        // Return the address of the default metrics collector for the metric
        // identified by the specified &#39;category&#39; and &#39;metric&#39; names.  The
        // behavior is undefined unless the &#39;balm&#39; metrics manager singleton is
        // valid.

    static IntegerCollector *getIntegerCollector(const char *category,
                                                 const char *metric);
        // Return the address of the default integer metrics collector for the
        // metric identified by the specified &#39;category&#39; and &#39;metric&#39; names.
        // The behavior is undefined unless the &#39;balm&#39; metrics manager
        // singleton is valid.

    static void setPublicationType(const MetricId&amp;        id,
                                   PublicationType::Value type);
        // Set the publication type for the metric identified by the specified
        // &#39;id&#39; to the specified &#39;type&#39;.  The behavior is undefined unless the
        // &#39;balm&#39; metrics manager singleton is valid, and &#39;id&#39; is a valid
        // identifier supplied by the singleton metrics manager.

    static void logEmptyName(const char *name,
                             NameType    type,
                             const char *file,
                             int         line);
        // If the specified &#39;name&#39; is empty or contains only whitespace, then
        // log a warning message indicating whether &#39;name&#39; is a category or a
        // metric, depending on the specified &#39;type&#39;, and the location at which
        // this function is called, indicated by the specified &#39;file&#39; and
        // &#39;line&#39;; otherwise, do nothing.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                           // ---------------------
                           // struct Metrics_Helper
                           // ---------------------

// CLASS METHODS
inline
void Metrics_Helper::initializeCategoryHolder(CategoryHolder *holder,
                                              const char     *category)
{
    MetricsManager  *manager  = DefaultMetricsManager::instance();
    MetricRegistry&amp;  registry = manager-&gt;metricRegistry();
    registry.registerCategoryHolder(registry.getCategory(category), holder);
}

inline
Collector *Metrics_Helper::getCollector(const char *category,
                                        const char *metric)
{
    MetricsManager *manager = DefaultMetricsManager::instance();
    return manager-&gt;collectorRepository().getDefaultCollector(category,
                                                              metric);
}

inline
IntegerCollector *Metrics_Helper::getIntegerCollector(const char *category,
                                                      const char *metric)
{
    MetricsManager *manager = DefaultMetricsManager::instance();
    return manager-&gt;collectorRepository().getDefaultIntegerCollector(category,
                                                                     metric);
}

inline
void Metrics_Helper::setPublicationType(const MetricId&amp;        id,
                                        PublicationType::Value type)
{
    MetricsManager *manager = DefaultMetricsManager::instance();
    return manager-&gt;metricRegistry().setPreferredPublicationType(id, type);

}

}  // close package namespace
}  // close enterprise namespace

#if !defined(BSL_DOUBLE_UNDERSCORE_XLAT) || 1 == BSL_DOUBLE_UNDERSCORE_XLAT
#define BALM_METRICS__UNIQUE_NAME(X) BALM_METRICS_UNIQUE_NAME(X)
#endif

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
