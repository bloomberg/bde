<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdls::FdStreamBuf</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdls.html">bdls</a>      </li>
      <li><a class="el" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdls::FdStreamBuf Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdls::FdStreamBuf" -->
<p><code>#include &lt;<a class="el" href="bdls__fdstreambuf_8h_source.html">bdls_fdstreambuf.h</a>&gt;</code></p>

<p><a href="classbdls_1_1FdStreamBuf-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#a1ff91208be5aeaabb2d1484a22321931">FdStreamBuf</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FilesystemUtil::FileDescriptor</a> fileDescriptor, bool writableFlag, bool willCloseOnResetFlag=true, bool binaryModeFlag=false, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#a2eba4819687a63134525b80b98b3319c">~FdStreamBuf</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#a7af849d14caf5e808c436562d92dd432">reset</a> (<a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FilesystemUtil::FileDescriptor</a> fileDescriptor, bool writableFlag, bool willCloseOnResetFlag=true, bool binaryModeFlag=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#acc8569218d15954070a8d9206fd6baf1">release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#a4a063eeabf80fc754ef7b7ae59492c0e">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FilesystemUtil::FileDescriptor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#a37a032a66b08e45caf41218413d03f96">fileDescriptor</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#a1029b99bdeedd6b807b23143f5bc9a1d">isOpened</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#ad4d77b60cbddbc41e62f22d3880f100d">willCloseOnReset</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#ab41763f4399223ca5353d7be91de1b4b">underflow</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#a694257544df60deff0a934a334be3f50">pbackfail</a> (int_type c=traits_type::eof())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#ac4657a078d1cdd3cf297e5c7cab2a463">overflow</a> (int_type c=traits_type::eof())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbdls_1_1FdStreamBuf.html">FdStreamBuf</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#aaaa2ac92b381c73fb760a9572f4097dd">setbuf</a> (char_type *buffer, bsl::streamsize numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual pos_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#a1c39b9d749a60263c9bdc79386e2f204">seekoff</a> (off_type offset, bsl::ios_base::seekdir whence, bsl::ios_base::openmode mode=bsl::ios_base::in|bsl::ios_base::out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual pos_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#ab389b7a978fde615d5ec3b80e5f9f298">seekpos</a> (pos_type offset, bsl::ios_base::openmode mode=bsl::ios_base::in|bsl::ios_base::out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#a991b0f2a5cfc93e5efb7424de620f581">sync</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#a5eb8455eb843bd022ca75f90bf2e7d2e">imbue</a> (const bsl::locale &amp;locale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bsl::streamsize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#a9f60852b1be36d8e27489c24b69fb5b2">showmanyc</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bsl::streamsize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#ab3cdbc9f2a104c8087192229154a2f1e">xsgetn</a> (char *buffer, bsl::streamsize numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bsl::streamsize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdls_1_1FdStreamBuf.html#a65a855cbdc4aac81b7eb63aee08530ac">xsputn</a> (const char *buffer, bsl::streamsize numBytes)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class, derived from the C++ standard library class <code>bsl::streambuf</code>, is a mechanism that can be associated with an opened file descriptor, and, except for changing the locale, enables the caller to invoke all the standard <code>bsl::streambuf</code> operations on that file descriptor. Note that objects of this class are always in exactly one of the 5 modes outlined in the enum <code>FdStreamBuf::FdStreamBufMode</code>. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1ff91208be5aeaabb2d1484a22321931"></a><!-- doxytag: member="bdls::FdStreamBuf::FdStreamBuf" ref="a1ff91208be5aeaabb2d1484a22321931" args="(FilesystemUtil::FileDescriptor fileDescriptor, bool writableFlag, bool willCloseOnResetFlag=true, bool binaryModeFlag=false, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdls::FdStreamBuf::FdStreamBuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FilesystemUtil::FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>fileDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writableFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>willCloseOnResetFlag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>binaryModeFlag</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbdls_1_1FdStreamBuf.html">FdStreamBuf</a></code> associated with the specified <code>fileDescriptor</code> that refers to an already opened file or device, and specify <code>writableFlag</code> which, if <code>true</code>, indicates that <code>fileDescriptor</code> is writable, otherwise it is not. The optionally specified <code>willCloseOnResetFlag</code>, if <code>true</code>, indicates that <code>fileDescriptor</code> is to be closed the next time this object is reset, cleared or destroyed, or if <code>false</code> the file descriptor is to be left open. Optionally specify a <code>binaryModeFlag</code> which is ignored on Unix; if <code>false</code> on Windows, it indicates that <code>\n</code>s are to be translated to and from <code>\r\n</code> sequences on the device. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Note that if <code><a class="el" href="structbdls_1_1FilesystemUtil.html#af6eb8fae5d490a49997d7e4fc59ae467">FilesystemUtil::k_INVALID_FD</a></code> is passed to <code>fileDescriptor</code>, no file descriptor is to be associated with this object. Also note that the state of the <code>fileDescriptor</code> is unchanged by this call (i.e., there is no implicit seek). </p>

</div>
</div>
<a class="anchor" id="a2eba4819687a63134525b80b98b3319c"></a><!-- doxytag: member="bdls::FdStreamBuf::~FdStreamBuf" ref="a2eba4819687a63134525b80b98b3319c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdls::FdStreamBuf::~FdStreamBuf </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object and, if <code>willCloseOnReset</code> is <code>true</code>, close the file descriptor associated with this object, if any. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab41763f4399223ca5353d7be91de1b4b"></a><!-- doxytag: member="bdls::FdStreamBuf::underflow" ref="ab41763f4399223ca5353d7be91de1b4b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int_type bdls::FdStreamBuf::underflow </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replenish the input buffer with data obtained from the file descriptor, and return the next character of input (or eof if no input is available). Note that in windows text mode, <code>\r\n</code> sequences on the device will be translated to <code>\n</code>s. </p>

</div>
</div>
<a class="anchor" id="a694257544df60deff0a934a334be3f50"></a><!-- doxytag: member="bdls::FdStreamBuf::pbackfail" ref="a694257544df60deff0a934a334be3f50" args="(int_type c=traits_type::eof())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int_type bdls::FdStreamBuf::pbackfail </td>
          <td>(</td>
          <td class="paramtype">int_type&nbsp;</td>
          <td class="paramname"> <em>c</em> = <code>traits_type::eof()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the optionally specified <code>c</code> is not given, move the current input position back one character and return the character at that position. Otherwise specify a value for <code>c</code> other than <code>traits_type::eof</code>. If <code>c</code> is equal to the previous character in the read buffer, the behavior is the same as if <code>eof()</code> was passed. If <code>c</code> is not eof and is not equal to the previous character in the putback buffer push the character <code>c</code> is back into the input buffer, if possible. Return the backed up character on success and <code>traits_type::eof()</code> otherwise. If the input buffer is readonly, or <code>gptr()</code> is already at the beginning of the input buffer, this object enters <code>INPUT_PUTBACK_MODE</code> and <code>c</code> is stuffed back into the putback buffer. Note that only <code>PBACK_BUF_SIZE</code> characters can be backed up into the putback buffer, if this limit is exceeded, <code>traits_type::eof()</code> will be returned. Also note that this method is called by public methods <code>sputbackc</code> or <code>sungetc</code> in the base class, and only when simply decrementing the current position in the input buffer won't satisfy the request, either because <code>c</code> doesn't match the previously input character, or because the input position is already at the beginning of the input buffer. </p>

</div>
</div>
<a class="anchor" id="ac4657a078d1cdd3cf297e5c7cab2a463"></a><!-- doxytag: member="bdls::FdStreamBuf::overflow" ref="ac4657a078d1cdd3cf297e5c7cab2a463" args="(int_type c=traits_type::eof())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int_type bdls::FdStreamBuf::overflow </td>
          <td>(</td>
          <td class="paramtype">int_type&nbsp;</td>
          <td class="paramname"> <em>c</em> = <code>traits_type::eof()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If in output mode, write the contents of the buffer to output. Return <code>traits_type::eof()</code> on failure, and any other value on success. Optionally specify a character <code>c</code> to be appended to the buffer prior to the flush. If no character is specified, no character is appended to the buffer. If not in output mode, switch to output mode. Note that the write will translate <code>\n</code>s to <code>\r\n</code>s. </p>

</div>
</div>
<a class="anchor" id="aaaa2ac92b381c73fb760a9572f4097dd"></a><!-- doxytag: member="bdls::FdStreamBuf::setbuf" ref="aaaa2ac92b381c73fb760a9572f4097dd" args="(char_type *buffer, bsl::streamsize numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbdls_1_1FdStreamBuf.html">FdStreamBuf</a>* bdls::FdStreamBuf::setbuf </td>
          <td>(</td>
          <td class="paramtype">char_type *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::streamsize&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use the specified <code>buffer</code> of the specified <code>numBytes</code> capacity as the input/output buffer for this <code>streambuf</code>. If <code>buffer == 0</code>, the buffer is dynamically allocated with a default size. If both <code>buffer</code> and <code>numBytes</code> are zero a 1-byte buffer is dynamically allocated. The behavior is undefined if any I/O has preceded this call, and unless the buffer is uninitialized before this call. </p>

</div>
</div>
<a class="anchor" id="a1c39b9d749a60263c9bdc79386e2f204"></a><!-- doxytag: member="bdls::FdStreamBuf::seekoff" ref="a1c39b9d749a60263c9bdc79386e2f204" args="(off_type offset, bsl::ios_base::seekdir whence, bsl::ios_base::openmode mode=bsl::ios_base::in|bsl::ios_base::out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual pos_type bdls::FdStreamBuf::seekoff </td>
          <td>(</td>
          <td class="paramtype">off_type&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::ios_base::seekdir&nbsp;</td>
          <td class="paramname"> <em>whence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::ios_base::openmode&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>bsl::ios_base::in|bsl::ios_base::out</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the file pointer associated with the file descriptor according to the specified <code>offset</code> and <code>whence</code>: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment"> If <span class="stringliteral">&#39;whence&#39;</span> is <span class="stringliteral">&#39;bsl::ios_base::beg&#39;</span>, <span class="keyword">set</span> the pointer to <span class="stringliteral">&#39;offset&#39;</span>
           bytes from the beginning of the file.
 If <span class="stringliteral">&#39;whence&#39;</span> is <span class="stringliteral">&#39;bsl::ios_base::cur&#39;</span>, advance the pointer by
           <span class="stringliteral">&#39;offset&#39;</span> bytes
 If <span class="stringliteral">&#39;whence&#39;</span> is <span class="stringliteral">&#39;bsl::ios_base::end&#39;</span>, <span class="keyword">set</span> the pointer to <span class="stringliteral">&#39;offset&#39;</span>
           bytes beyond the end of the file.
</pre></div><p><br/>
<br/>
 Optionally specify <code>mode</code>, which is ignored. Return the new location of the file position, in bytes from the beginning of the file, on success, and -1 otherwise. The behavior is undefined unless the file descriptor is on a device capable of seeking. Note that seeking does not change the size of the file if the pointer advances beyond the end of the file; instead, the next write at the pointer will increase the file size. Also note that seeks are always in terms of bytes on the device, meaning that in Windows text mode, seeking past a <code>\n</code> perceived by the caller will count as 2 bytes since it has to seek over a <code>\r\n</code> sequence on the device. </p>

</div>
</div>
<a class="anchor" id="ab389b7a978fde615d5ec3b80e5f9f298"></a><!-- doxytag: member="bdls::FdStreamBuf::seekpos" ref="ab389b7a978fde615d5ec3b80e5f9f298" args="(pos_type offset, bsl::ios_base::openmode mode=bsl::ios_base::in|bsl::ios_base::out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual pos_type bdls::FdStreamBuf::seekpos </td>
          <td>(</td>
          <td class="paramtype">pos_type&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::ios_base::openmode&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>bsl::ios_base::in|bsl::ios_base::out</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Seek to the specified <code>offset</code> relative to the beginning of the file. Return the resulting absolute position in the file relative to the beginning. Optionally specify <code>mode</code> which is ignored. Also note that seeks are always in terms of bytes on the device, meaning that on a Windows text file, seeking past a <code>\r\n</code> sequence on the disk will count as two bytes, though if it is read in it will be a single <code>\n</code> byte. </p>

</div>
</div>
<a class="anchor" id="a991b0f2a5cfc93e5efb7424de620f581"></a><!-- doxytag: member="bdls::FdStreamBuf::sync" ref="a991b0f2a5cfc93e5efb7424de620f581" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int bdls::FdStreamBuf::sync </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If in output mode, flush the buffer to the associated file descriptor; otherwise do nothing. Return 0 on success, -1 otherwise. </p>

</div>
</div>
<a class="anchor" id="a5eb8455eb843bd022ca75f90bf2e7d2e"></a><!-- doxytag: member="bdls::FdStreamBuf::imbue" ref="a5eb8455eb843bd022ca75f90bf2e7d2e" args="(const bsl::locale &amp;locale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bdls::FdStreamBuf::imbue </td>
          <td>(</td>
          <td class="paramtype">const bsl::locale &amp;&nbsp;</td>
          <td class="paramname"> <em>locale</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the locale for this object. This method has no effect. The behavior is undefined unless the specified <code>locale</code> is the same as <code>bsl::locale()</code>. </p>

</div>
</div>
<a class="anchor" id="a9f60852b1be36d8e27489c24b69fb5b2"></a><!-- doxytag: member="bdls::FdStreamBuf::showmanyc" ref="a9f60852b1be36d8e27489c24b69fb5b2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bsl::streamsize bdls::FdStreamBuf::showmanyc </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this object is in putback mode, return the number of characters remaining to be read in the putback buffer, and otherwise the number of characters remaining in the file to be read. Return a non-negative number of characters on success and a negative value otherwise. The behavior is undefined unless this object is in input mode and the file descriptor is associated with a regular file. </p>

</div>
</div>
<a class="anchor" id="ab3cdbc9f2a104c8087192229154a2f1e"></a><!-- doxytag: member="bdls::FdStreamBuf::xsgetn" ref="ab3cdbc9f2a104c8087192229154a2f1e" args="(char *buffer, bsl::streamsize numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bsl::streamsize bdls::FdStreamBuf::xsgetn </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::streamsize&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read up to the specified <code>numBytes</code> characters from the file descriptor into the specified <code>buffer</code> and return the number of characters successfully read. The behavior is undefined unless <code>buffer</code> is at least <code>numBytes</code> bytes long. Note that on a Windows text file, a <code>\r\n</code> in the file will be read as <code>\n</code> (counting as a single character). </p>

</div>
</div>
<a class="anchor" id="a65a855cbdc4aac81b7eb63aee08530ac"></a><!-- doxytag: member="bdls::FdStreamBuf::xsputn" ref="a65a855cbdc4aac81b7eb63aee08530ac" args="(const char *buffer, bsl::streamsize numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bsl::streamsize bdls::FdStreamBuf::xsputn </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::streamsize&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write up to the specified <code>numBytes</code> characters from the specified <code>buffer</code> and return the number of characters successfully written. Note that this method does not necessarily modify the <a href="file:">file:</a> this method may simply write the characters to a buffer to be flushed to the file at a later time. Also note that on a Windows text file, a <code>\n</code> will be written to the file as <code>\r\n</code> (counted as a single character). </p>

</div>
</div>
<a class="anchor" id="a7af849d14caf5e808c436562d92dd432"></a><!-- doxytag: member="bdls::FdStreamBuf::reset" ref="a7af849d14caf5e808c436562d92dd432" args="(FilesystemUtil::FileDescriptor fileDescriptor, bool writableFlag, bool willCloseOnResetFlag=true, bool binaryModeFlag=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdls::FdStreamBuf::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FilesystemUtil::FileDescriptor</a>&nbsp;</td>
          <td class="paramname"> <em>fileDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writableFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>willCloseOnResetFlag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>binaryModeFlag</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Associate this object with the specified <code>fileDescriptor</code>, and record the state of the specified <code>writableFlag</code> which, if <code>true</code>, indicates that <code>fileDescriptor</code> is writable, otherwise it is not. Before making this association, if, prior to this call, <code>willCloseOnReset</code> is true, close any file descriptor previously associated with this object, otherwise leave it open but disassociate this object from it. The Optionally specified <code>willCloseOnResetFlag</code> which will set <code>willCloseOnReset</code>, which, if <code>true</code>, indicates that the specified file descriptor is to be closed when this object is cleared, reset, or destroyed, otherwise no action will be taken on <code>fileDescriptor</code> at that time. Optionally specify a <code>binaryModeFlag</code>, which is ignored on Unix; if <code>false</code> on Windows, it indicates that <code>\n</code>s internally are to be translated to and from <code>\r\n</code> sequences on the device; on Unix or if <code>binaryModeFlag</code> is <code>true</code> no such translation is to occur. Return 0 on success, and a non-zero value otherwise. Note that if <code><a class="el" href="structbdls_1_1FilesystemUtil.html#af6eb8fae5d490a49997d7e4fc59ae467">FilesystemUtil::k_INVALID_FD</a></code> is passed as <code>fileDescriptor</code>, no file descriptor is to be associated with this object. Also note that the state of the <code>fileDescriptor</code> is unchanged by this call, there is no implicit seek. </p>

</div>
</div>
<a class="anchor" id="acc8569218d15954070a8d9206fd6baf1"></a><!-- doxytag: member="bdls::FdStreamBuf::release" ref="acc8569218d15954070a8d9206fd6baf1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdls::FdStreamBuf::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disassociate this file handler from any file descriptor with which it may be associated without closing that file descriptor. This method succeeds with no effect is <code>isOpened</code> was false. Note that <code>fileDescriptor</code> is <code><a class="el" href="structbdls_1_1FilesystemUtil.html#af6eb8fae5d490a49997d7e4fc59ae467">FilesystemUtil::k_INVALID_FD</a></code> after this call. </p>

</div>
</div>
<a class="anchor" id="a4a063eeabf80fc754ef7b7ae59492c0e"></a><!-- doxytag: member="bdls::FdStreamBuf::clear" ref="a4a063eeabf80fc754ef7b7ae59492c0e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdls::FdStreamBuf::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release any file descriptor that may be associated with this file handler. If <code>isOpened</code> and <code>willCloseOnReset</code> are both <code>true</code>, the file descriptor will be closed, otherwise it will not. Return 0 on success, and a non-zero value if the close fails. This method succeeds with no effect if <code>isOpened</code> was false. Note that <code>fileDescriptor</code> is <code><a class="el" href="structbdls_1_1FilesystemUtil.html#af6eb8fae5d490a49997d7e4fc59ae467">FilesystemUtil::k_INVALID_FD</a></code> after this call. </p>

</div>
</div>
<a class="anchor" id="a37a032a66b08e45caf41218413d03f96"></a><!-- doxytag: member="bdls::FdStreamBuf::fileDescriptor" ref="a37a032a66b08e45caf41218413d03f96" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">FilesystemUtil::FileDescriptor</a> bdls::FdStreamBuf::fileDescriptor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the file descriptor associated with this object, or <code><a class="el" href="structbdls_1_1FilesystemUtil.html#af6eb8fae5d490a49997d7e4fc59ae467">FilesystemUtil::k_INVALID_FD</a></code> if this object is not currently associated with a file descriptor. </p>

</div>
</div>
<a class="anchor" id="a1029b99bdeedd6b807b23143f5bc9a1d"></a><!-- doxytag: member="bdls::FdStreamBuf::isOpened" ref="a1029b99bdeedd6b807b23143f5bc9a1d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdls::FdStreamBuf::isOpened </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this object is currently associated with a file descriptor, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ad4d77b60cbddbc41e62f22d3880f100d"></a><!-- doxytag: member="bdls::FdStreamBuf::willCloseOnReset" ref="ad4d77b60cbddbc41e62f22d3880f100d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdls::FdStreamBuf::willCloseOnReset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this object will close the associated file descriptor the next time it is reset, cleared, or destroyed, and <code>false</code> otherwise. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdls__fdstreambuf_8h_source.html">bdls_fdstreambuf.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:33 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
