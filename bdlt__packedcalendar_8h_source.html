<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlt_packedcalendar.h                                              -*-C++-*-
#ifndef INCLUDED_BDLT_PACKEDCALENDAR
#define INCLUDED_BDLT_PACKEDCALENDAR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a compact repository for weekend/holiday information.
//
//@CLASSES:
//  bdlt::PackedCalendar: compact repository of weekend/holiday information
//
//@SEE_ALSO: bdlt_calendar
//
//@DESCRIPTION: This component provides a value-semantic class,
// &#39;bdlt::PackedCalendar&#39;, that represents weekend and holiday information over
// a *valid* *range* of dates.  A &#39;bdlt::PackedCalendar&#39; is an approximation to
// the same *mathematical* type, and is capable of representing the same subset
// of *mathematical* values, as a &#39;bdlt::Calendar&#39;.
//
// But unlike &#39;bdlt::Calendar&#39;, which is optimized for runtime efficiency,
// &#39;bdlt::PackedCalendar&#39; is designed to minimize the amount of in-process
// memory required to represent that information.  For example, a packed
// calendar storing 250 holidays and holiday codes can consume as little as
// approximately 0.75K bytes (e.g., 2 bytes per holiday plus 1 byte per
// holiday code) to as much as approximately 3K bytes (e.g., 8 bytes per
// holiday plus 4 bytes per holiday code) depending upon the data of the
// calendar.  For typical calendars having a range of 40 years and 10 holidays
// per year, the expected size of the packed calendar is about half that of a
// similar implementation using a non-packed structure.
//
// Default-constructed calendars are empty, and have an empty valid range.
// Calendars can also be constructed with an initial (non-empty) valid range,
// implying that all dates within that range are business days.  The
// &#39;setValidRange&#39; and &#39;addDay&#39; methods modify the valid range of a calendar,
// and a suite of &quot;add&quot; methods can be used to populate a calendar with
// weekend days and holidays.
//
// The &#39;addHolidayCode&#39; method associates an integer &quot;holiday code&quot; with a
// specific date, and can be called repeatedly with different integers and the
// same date to build up a set of holiday codes for that date.  Note that
// holiday codes are unique integers that, from the perspective of the
// calendar, have no particular meaning.  Typically, the user will choose
// holiday code values that are indices into an auxiliary collection (such as a
// &#39;bsl::vector&lt;bsl::string&gt;&#39;) to identify holiday names for end-user display.
//
// Once a calendar is populated, a rich set of accessor methods can be used to
// determine, e.g., if a given date is a business day, or the number of
// non-business days within some subrange of the calendar.  The holidays
// within a calendar can be obtained in increasing (chronological) order using
// an iterator identified by the nested &#39;HolidayConstIterator&#39; &#39;typedef&#39;.  The
// set of holiday codes associated with an arbitrary date in a
// &#39;bdlt::PackedCalendar&#39; (or the current holiday referred to by a
// &#39;HolidayConstIterator&#39;) can be obtained in increasing (numerical) order
// using an iterator identified by the nested &#39;HolidayCodeConstIterator&#39;
// &#39;typedef&#39; (see below).
//
// Calendars are value-semantic objects, and, as such, necessarily support all
// of the standard value-semantic operations, such as default construction,
// copy construction and copy assignment, equality comparison, and
// externalization (BDEX streaming, in particular).  Calendars also support
// the notions of both union and intersection merging operations, whereby a
// calendar can change its value to contain the union or intersection of its
// own contained weekend days, holidays, and holiday codes with those of
// another calendar object.  Such merging operations will, in general, also
// alter the valid range of the resulting calendar.  Note that merged
// calendars can be significantly more efficient for certain repeated
// &quot;is-common-business-day&quot; determinations among two or more calendars.
//
///Weekend Days and Weekend-Days Transitions
///-----------------------------------------
// A calendar maintains a set of dates considered to be weekend days.
// Typically, a calendar&#39;s weekend days fall on the same days of the week for
// the entire range of a calendar.  For example, the weekend for United States
// has consisted of Saturday and Sunday since the year 1940.  The
// &#39;addWeekendDay&#39; and &#39;addWeekendDays&#39; methods can be used to specify the
// weekend days for these calendars.
//
// However, sometimes a calendar&#39;s weekend days changes over time.  For
// example, Bangladesh&#39;s weekend consisted of Friday until June 1, 1997 when
// Bangladesh changed its weekends to contain both Friday and Saturday.  Later,
// on October 1, 2001, Bangladesh reverted to a weekend of only Friday, until
// on September 9, 2009, Bangladesh again changed its weekends to include both
// Friday and Saturday.
//
// To optimize for space allocation while supporting both consistent and
// changing weekend days, a calendar represents weekend information using a
// sequence of &quot;weekend-days transitions&quot;, each of which comprises a date and a
// set of days of the week considered to be the weekend on and after that
// date.  To represent the weekend days of Bangladesh, a calendar can use a
// sequence of four weekend-days transitions: (1) a transition on January 1,
// 0001 having a weekend day set containing only Friday, (2) a transition at
// June 1, 1997 having a weekend day set containing Friday and Saturday, (3) a
// transition at October 1, 2001 having a weekend day set containing only
// Friday, and (4) a transition at September 9, 2009 having a weekend day set
// containing Friday and Saturday.  To represent the weekend days of the United
// States, a calendar having a range after 1940 can use a single weekend-days
// transition on January 1, 0001 containing Saturday and Sunday.
//
// On construction, a calendar does not contain any weekend-days transitions.
// The &#39;addWeekendDaysTransition&#39; method adds a new weekend-days transition or
// replaces an existing weekend-days transition.  The &#39;addWeekendDay&#39; and
// &#39;addWeekendDays&#39; methods create a weekend-days transition at January 1,
// 0001, if one doesn&#39;t already exist, and update the set of weekend days for
// that transition.  &#39;addWeekendDay&#39; and &#39;addWeekendDays&#39; should only be used
// for calendars having a consistent set of weekend days throughout their
// entire range.  The use of &#39;addWeekendDay&#39; and &#39;addWeekendDays&#39; is intended
// to be *mutually* *exclusive* to the use of &#39;addWeekendDaysTransition&#39;.  As
// such, the behavior of using these two methods together with
// &#39;addWeekendDaysTransition&#39; is undefined.
//
///Nested Iterators
///----------------
// Also provided are several STL-style &#39;const&#39; bidirectional iterators
// accessible as nested &#39;typedef&#39;s.  &#39;HolidayConstIterator&#39;,
// &#39;HolidayCodeConstIterator&#39;, &#39;WeekendDaysTransitionConstIterator&#39;, and
// &#39;BusinessDayConstIterator&#39;, respectively, iterate over a chronologically
// ordered sequence of holidays, a numerically ordered sequence of holiday
// codes, a sequence of chronologically ordered weekend-days transitions, and a
// sequence of chronologically ordered business days.  Reverse iterators are
// also provided for each of these (forward) iterators.  As a general rule,
// calling a &#39;const&#39; method will not invalidate any iterators, and calling a
// non-&#39;const&#39; method might invalidate all of them; it is, however, guaranteed
// that attempting to add *duplicate* holidays or holiday codes will have no
// effect, and therefore will not invalidate any iterators.  It is also
// guaranteed that adding a new code for an existing holiday will not
// invalidate any &#39;HolidayConstIterator&#39; objects.
//
// Note that these iterators do *not* meet the requirements for a
// &#39;bsl::forward_iterator&#39; and should not be used in standard algorithms (e.g.,
// &#39;bsl::lower_bound&#39;).
//
///Iterator Invalidation
///---------------------
// The modification of a &#39;bdlt::PackedCalendar&#39; will invalidate iterators
// referring to the calendar.  The following table shows the relationship
// between a calendar manipulator and the types of iterators it will
// invalidate if the invocation of the manipulator modified the calendar (e.g.,
// using &#39;addHoliday&#39; with a date that is not currently a holiday in the
// calendar):
//..
//          Manipulator                         Invalidates
//    --------------------------            --------------------
//    &#39;operator=&#39;                           H    HC    WDT    BD
//    &#39;addHoliday&#39;                          H    HC           BD
//    &#39;addHolidayCode&#39;                           HC
//    &#39;addHolidayCodeIfInRange&#39;                  HC
//    &#39;addHolidayIfInRange&#39;                 H    HC           BD
//    &#39;addWeekendDay&#39;                                  WDT    BD
//    &#39;addWeekendDays&#39;                                 WDT    BD
//    &#39;addWeekendDaysTransition&#39;                       WDT    BD
//    &#39;intersectBusinessDays&#39;               H    HC    WDT    BD
//    &#39;intersectNonBusinessDays&#39;            H    HC    WDT    BD
//    &#39;removeAll&#39;                           H    HC    WDT    BD
//    &#39;removeHoliday&#39;                       H    HC           BD
//    &#39;removeHolidayCode&#39;                        HC
//    &#39;setValidRange&#39;                       H    HC           BD
//    &#39;unionBusinessDays&#39;                   H    HC    WDT    BD
//    &#39;unionNonBusinessDays&#39;                H    HC    WDT    BD
//
// where &quot;H&quot; represents the holiday iterators (&#39;HolidayConstIterator&#39; and
// &#39;HolidayConstReverseIterator&#39;), &quot;HC&quot; represents the holiday code iterators
// (&#39;HolidayCodeConstIterator&#39; and &#39;HolidayCodeConstReverseIterator&#39;), &quot;WDT&quot;
// represents the weekend-days transition iterators
// (&#39;WeekendDaysTransitionConstIterator&#39; and
// &#39;WeekendDaysTransitionConstReverseIterator&#39;), and &quot;BD&quot; represents the
// business day iterators (&#39;BusinessDayConstIterator&#39; and
// &#39;BusinessDayConstReverseIterator&#39;).
//..
//
///Performance and Exception-Safety Guarantees
///-------------------------------------------
// The asymptotic worst-case performance of representative operations is
// characterized using big-O notation, &#39;O[f(N,M,W,V)]&#39;.  &#39;N&#39; and &#39;M&#39; each refer
// to the combined number (&#39;H + C&#39;) of holidays &#39;H&#39; (i.e., method
// &#39;numHolidays&#39;) and holiday codes &#39;C&#39; (i.e., &#39;numHolidayCodesTotal&#39;) in the
// respective packed calendars.  &#39;W&#39; and &#39;V&#39; each refer to the (likely small)
// number of weekend-days transitions in the respective packed calendars.  For
// clarity, the methods have abbreviated arguments: &#39;b&#39;, &#39;e&#39;, and &#39;d&#39; are
// dates, &#39;c&#39; is a holiday code, &#39;u&#39; is a weekday, and &#39;w&#39; is a set of
// weekdays.  Here, *Best* *Case* complexity, denoted by &#39;B[f(N)]&#39;, is loosely
// defined (for manipulators) as the worst-case cost, provided that (1) no
// additional internal capacity is required, (2) the start of the valid range
// does not change, and (3) that if a holiday (or holiday code) is being added,
// it is being appended *to* *the* *end* of the current sequence (of the latest
// holiday).
//..
//                                    Worst       Best    Exception-Safety
//  Operation                          Case       Case      Guarantee
//  ---------                         -----       ----    ----------------
//  DEFAULT CTOR                      O[1]                No-Throw
//  COPY CTOR(N)                      O[N]                Exception-Safe
//  N.DTOR()                          O[1]                No-Throw
//
//  N.OP=(M)                          O[M]                Basic &lt;*&gt;
//
//  N.reserveCapacity(H, C)           O[N]                Strong &lt;*&gt;
//
//  N.setValidRange(b, e)             O[N]        O[1]    Basic &lt;*&gt;
//  N.addDay(d)                       O[N]        O[1]    Basic &lt;*&gt;
//  N.addHoliday(d)                   O[N]        O[1]    Basic &lt;*&gt;
//  N.addHolidayCode(d,c)             O[N]        O[1]    Basic &lt;*&gt;
//
//  N.addWeekendDay(u)                O[1]                No-Throw
//  N.addWeekendDaysTransition(d,w)   O[W]                Basic &lt;*&gt;
//
//  N.intersectBusinessDays(M)        O[N+M+W+V]          Basic &lt;*&gt;
//  N.intersectNonBusinessDays(M)     O[N+M+W+V]          Basic &lt;*&gt;
//  N.unionBusinessDays(M)            O[N+M+W+V]          Basic &lt;*&gt;
//  N.unionNonBusinessDays(M)         O[N+M+W+V]          Basic &lt;*&gt;
//
//  N.removeHoliday(d)                O[N]                No-Throw
//  N.removeHolidayCode(d, c)         O[N]                No-Throw
//  N.removeAll();                    O[1]                No-Throw
//
//  N.swap(M)                         O[1]                No-Throw
//
//  N.firstDate()                     O[1]                No-Throw
//  N.lastDate()                      O[1]                No-Throw
//  N.length()                        O[1]                No-Throw
//
//  N.numHolidays()                   O[1]                No-Throw
//
//  N.numHolidayCodesTotal()          O[1]                No-Throw
//  N.numWeekendDaysInRange()         O[1]                No-Throw
//
//  N.isInRange(d);                   O[1]                No-Throw
//  N.isWeekendDay(w);                O[1]                No-Throw
//  N.isWeekendDay(d)                 O[log(W)]           No-Throw
//
//  N.isHoliday(d);                   O[log(N)]           No_Throw
//  N.isBusinessDay(d);               O[log(N)]           No_Throw
//  N.isNonBusinessDay(d);            O[log(N)]           No_Throw
//
//  N.numHolidayCodes(d)              O[log(N)]           No-Throw
//
//  N.numBusinessDays()               O[N]                No-Throw
//  N.numNonBusinessDays()            O[N]                No-Throw
//
//  other &#39;const&#39; methods             O[1] .. O[N]        No-Throw
//
//
//  OP==(N,M)                         O[min(N,M)+min(W+V) No-Throw
//  OP!=(N,M)                         O[min(N,M)+min(W+V) No-Throw
//
//                          &lt;*&gt; No-Throw guarantee when capacity is sufficient.
//..
// Note that *all* of the non-creator methods of &#39;bdlt::PackedCalendar&#39; provide
// the *No-Throw* guarantee whenever sufficient capacity is already available.
// Also note that these are largely the same as &#39;bdlt::Calendar&#39; *except* that
// the accessors &#39;isBusinessDay&#39; and &#39;isNonBusinessDay&#39; are logarithmic in the
// number of holidays in &#39;bdlt::PackedCalendar&#39;.
//
///Usage
///-----
// The two subsections below illustrate various aspects of populating and using
// packed calendars.
//
///Example 1: Populating Packed Calendars
/// - - - - - - - - - - - - - - - - - - -
// Packed calendars will typically be populated from a database or flat file.
// The user should employ an appropriate population mechanism that provides
// the desired holiday dates and associated holiday codes within some desired
// range.  For example, suppose we have created the following flat-file format
// that encodes calendar information, including holidays and holiday codes (we
// assume, for the simplicity of this example, that &quot;Weekend Days&quot; (i.e.,
// recurring non-business days) are always just Saturdays and Sundays):
//..
//  // HOLIDAY DATE   HOLIDAY CODES
//  // ------------   -------------
//  // Year Mon Day    #    Codes     Comments, separated by Semicolons (;)
//  // ---- --- ---   --- ---------   -------------------------------------
//     2010  1  18     1   57         ;Martin Luther King, Jr. Day
//     2010  2  15     1   51         ;Presidents Day
//     2010  4   2     2   9 105      ;Easter Sunday (Observed); Good Friday
//     2010  5  31     1   16         ;Memorial Day
//     2010  7   5     1   28         ;Independence Day (Observed)
//     2010  9   6     1   44         ;Labor Day
//     2010 10  11     1   19         ;Columbus Day
//     2010 11   2     0              ;Election Day
//     2010 11  25     1   14         ;Thanksgiving Day
//     2010 12  25     1    4         ;Christmas Day (Observed)
//     2010 12  31     1   22         ;New Year&#39;s Day (Observed)
//..
// Let&#39;s now create a couple of primitive helper functions to extract holiday
// and holiday-code counts from a given input stream.
//
// First, we&#39;ll create a helper function to get a holiday record:
//..
//  int getNextHoliday(bsl::istream&amp; input, bdlt::Date *holiday, int *numCodes)
//      // Load into the specified &#39;holiday&#39; the date of the next holiday, and
//      // into the specified &#39;numCodes&#39; the associated number of holiday codes
//      // for the holiday read from the specified &#39;input&#39; stream.  Return 0 on
//      // success, and a non-zero value (with no effect on &#39;*holiday&#39; and
//      // &#39;*numCodes&#39;) otherwise.
//  {
//      enum { SUCCESS = 0, FAILURE = 1 };
//
//      int year, month, day, codes;
//
//      if (input.good()) {
//          input &gt;&gt; year;
//      }
//      if (input.good()) {
//          input &gt;&gt; month;
//      }
//      if (input.good()) {
//          input &gt;&gt; day;
//      }
//      if (input.good()) {
//          input &gt;&gt; codes;
//      }
//
//      if (input.good()
//       &amp;&amp; bdlt::Date::isValidYearMonthDay(year, month, day)) {
//          *holiday  = bdlt::Date(year, month, day);
//          *numCodes = codes;
//          return SUCCESS;                                           // RETURN
//      }
//
//      return FAILURE;                                               // RETURN
//  }
//..
// Then, we&#39;ll write a function that gets us an integer holiday code, or
// invalidates the stream if it cannot (note that negative holiday codes are
// not supported by this function, but negative holiday codes *are* supported
// by &#39;bdlt::PackedCalendar&#39;):
//..
//  void getNextHolidayCode(bsl::istream&amp; input, int *result)
//      // Load, into the specified &#39;result&#39;, the value read from the specified
//      // &#39;input&#39; stream.  If the next token is not an integer, invalidate the
//      // stream with no effect on &#39;result&#39;.
//  {
//      int holidayCode;
//
//      if (input.good()) {
//          input &gt;&gt; holidayCode;
//      }
//
//      if (input.good()) {
//          *result = holidayCode;
//      }
//  }
//..
// Now, with these helper functions, it is a simple matter to write a calendar
// loader function, &#39;load&#39;, that populates a given calendar with data in this
// &quot;proprietary&quot; format:
//..
//  void load(bsl::istream&amp; input, bdlt::PackedCalendar *calendar)
//      // Populate the specified &#39;calendar&#39; with holidays and corresponding
//      // codes read from the specified &#39;input&#39; stream in our &quot;proprietary&quot;
//      // format (see above).  On success, &#39;input&#39; will be empty, but valid;
//      // otherwise &#39;input&#39; will be invalid.
//  {
//      bdlt::Date holiday;
//      int        numCodes;
//
//      while (0 == getNextHoliday(input, &amp;holiday, &amp;numCodes)) {
//          calendar-&gt;addHoliday(holiday);                       // add date
//          for (int i = 0; i &lt; numCodes; ++i) {
//              int holidayCode;
//              getNextHolidayCode(input, &amp;holidayCode);
//              if (input.good()) {
//                  // add codes
//
//                  calendar-&gt;addHolidayCode(holiday, holidayCode);
//              }
//          }
//          input.ignore(256, &#39;\n&#39;);  // skip comments
//      }
//  }
//..
// Finally, we load a &#39;bdlt::PackedCalendar&#39; and verify some values from the
// calendar.
//..
//  bsl::stringstream stream;
//  {
//      stream &lt;&lt; &quot;2010  9   6     1   44         ;Labor Day\n&quot;
//             &lt;&lt; &quot;2010 10  11     1   19         ;Columbus Day\n&quot;
//             &lt;&lt; &quot;2010 11   2     0              ;Election Day\n&quot;
//             &lt;&lt; &quot;2010 11  25     1   14         ;Thanksgiving Day\n&quot;;
//  }
//
//  bdlt::PackedCalendar calendar;
//  load(stream, &amp;calendar);
//
//  assert(bdlt::Date(2010,  9,  6) == calendar.firstDate());
//  assert(bdlt::Date(2010, 11, 25) == calendar.lastDate());
//  assert(true  == calendar.isBusinessDay(bdlt::Date(2010, 10, 12)));
//  assert(false == calendar.isBusinessDay(bdlt::Date(2010, 11,  2)));
//..
// Note that different formats can easily be accommodated, while still using
// the same basic population strategy.  Also note that it may be substantially
// more efficient to populate calendars in increasing date order, compared to
// either reverse or random order.
//
///Example 2: Using Packed Calendars
///- - - - - - - - - - - - - - - - -
// Higher-level clients (e.g., a GUI) may need to extract the holiday codes
// for a particular date, use them to look up their corresponding string names
// in a separate repository (e.g., a vector of strings), and to display these
// names to end users.
//
// First, let&#39;s create a function that prints the names of holidays for a
// given date:
//..
//  void
//  printHolidayNamesForGivenDate(bsl::ostream&amp;                   output,
//                                const bdlt::PackedCalendar&amp;     calendar,
//                                const bdlt::Date&amp;               date,
//                                const bsl::vector&lt;bsl::string&gt;&amp; holidayNames)
//      // Write, to the specified &#39;output&#39; stream, the elements in the
//      // specified &#39;holidayNames&#39; associated, via holiday codes in the
//      // specified &#39;calendar&#39;, to the specified &#39;date&#39;.  Each holiday name
//      // emitted is followed by a newline (&#39;\n&#39;).  The behavior is undefined
//      // unless &#39;date&#39; is within the valid range of &#39;calendar&#39;.
//  {
//      for (bdlt::PackedCalendar::HolidayCodeConstIterator
//                                       it = calendar.beginHolidayCodes(date);
//                                       it != calendar.endHolidayCodes(date);
//                                     ++it) {
//          output &lt;&lt; holidayNames[*it] &lt;&lt; bsl::endl;
//      }
//  }
//..
// Then, since we can write the names of holidays for a given date, let&#39;s
// write a function that can write out all of the names associated with each
// holiday in the calendar:
//..
//  void
//  printHolidayDatesAndNames(bsl::ostream&amp;                   output,
//                            const bdlt::PackedCalendar&amp;     calendar,
//                            const bsl::vector&lt;bsl::string&gt;&amp; holidayNames)
//      // Write, to the specified &#39;output&#39; stream, each date associated with
//      // a holiday in the specified &#39;calendar&#39; followed by any elements in
//      // the specified &#39;holidayNames&#39; (associated via holiday codes in
//      // &#39;calendar&#39;) corresponding to that date.  Each date emitted is
//      // preceded and followed by a newline (&#39;\n&#39;).  Each holiday name
//      // emitted is followed by a newline (&#39;\n&#39;).
//  {
//      for (bdlt::PackedCalendar::HolidayConstIterator
//                        it = calendar.beginHolidays();
//                                      it != calendar.endHolidays(); ++it) {
//          output &lt;&lt; &#39;\n&#39; &lt;&lt; *it &lt;&lt; &#39;\n&#39;;
//          printHolidayNamesForGivenDate(output,
//                                        calendar,
//                                        *it,
//                                        holidayNames);
//      }
//  }
//..
// Next, we populate the &#39;holidayNames&#39; vector:
//..
//  bsl::vector&lt;bsl::string&gt; holidayNames;
//  {
//      holidayNames.resize(45);
//
//      holidayNames[44] = &quot;Labor Day&quot;;         // holiday code 44 is for
//                                              // Labor Day
//
//      holidayNames[14] = &quot;Thanksgiving Day&quot;;  // holiday code 14 is for
//                                              // Thanksgiving Day
//  }
//..
// Now, using the &#39;calendar&#39; populated in the previous example, we print the
// holiday information to a new &#39;bsl::stringstream&#39;:
//..
//  bsl::stringstream printStream;
//
//  printHolidayDatesAndNames(printStream, calendar, holidayNames);
//..
// Finally, we verify the output:
//..
//  assert(printStream.str() == &quot;\n06SEP2010\nLabor Day\n\n11OCT2010\n\n\n&quot;
//                               &quot;02NOV2010\n\n25NOV2010\nThanksgiving Day\n&quot;);
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLT_CALENDARREVERSEITERATORADAPTER
#include &lt;bdlt_calendarreverseiteratoradapter.h&gt;
#endif

#ifndef INCLUDED_BDLT_DATE
#include &lt;bdlt_date.h&gt;
#endif

#ifndef INCLUDED_BDLT_DAYOFWEEK
#include &lt;bdlt_dayofweek.h&gt;
#endif

#ifndef INCLUDED_BDLT_DAYOFWEEKSET
#include &lt;bdlt_dayofweekset.h&gt;
#endif

#ifndef INCLUDED_BDLC_PACKEDINTARRAY
#include &lt;bdlc_packedintarray.h&gt;
#endif

#ifndef INCLUDED_BDLC_PACKEDINTARRAYUTIL
#include &lt;bdlc_packedintarrayutil.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SWAPUTIL
#include &lt;bslalg_swaputil.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include &lt;bslalg_typetraits.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITUSESBSLMAALLOCATOR
#include &lt;bslalg_typetraitusesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_INTEGRALCONSTANT
#include &lt;bslmf_integralconstant.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSL_ALGORITHM
#include &lt;bsl_algorithm.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDDEF
#include &lt;bsl_cstddef.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSL_ITERATOR
#include &lt;bsl_iterator.h&gt;
#endif

#ifndef INCLUDED_BSL_UTILITY
#include &lt;bsl_utility.h&gt;      // &#39;bsl::pair&#39;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {
namespace bdlt {

class PackedCalendar_BusinessDayConstIterator;
class PackedCalendar_HolidayCodeConstIterator;
class PackedCalendar_HolidayConstIterator;

                          // ====================
                          // class PackedCalendar
                          // ====================

class PackedCalendar {
    // This class implements a space-efficient, value-semantic repository of
    // weekend and holiday information over a *valid* *range* of dates.  This
    // valid range, &#39;[firstDate() .. lastDate()]&#39;, spans the first and last
    // dates of a calendar&#39;s accessible contents.  A calendar can be
    // &quot;populated&quot; with weekend and holiday information via a suite of &quot;add&quot;
    // methods.  Any subset of days of the week may be specified as weekend
    // (i.e., recurring non-business) days starting from a specified date by
    // adding a weekend-days transition; holidays within the valid range are
    // specified individually.  When adding a holiday, an arbitrary integer
    // &quot;holiday code&quot; may be associated with that date.  Additional holiday
    // codes for that date may subsequently be added.  Both the holidays and
    // the set of unique holiday codes associated with each holiday date are
    // maintained (internally) in order of increasing value.  Note that the
    // behavior of requesting *any* calendar information for a supplied date
    // whose value is outside the current *valid* *range* for that calendar
    // (unless otherwise noted, e.g., &#39;isWeekendDay&#39;) is undefined.

  private:
    // PRIVATE TYPES
    typedef bsl::pair&lt;Date, DayOfWeekSet&gt; WeekendDaysTransitionPrivate;

    typedef bdlc::PackedIntArray&lt;int&gt;::const_iterator OffsetsConstIterator;
    typedef bdlc::PackedIntArray&lt;int&gt;::const_iterator CodesIndexConstIterator;
    typedef bdlc::PackedIntArray&lt;int&gt;::const_iterator CodesConstIterator;

    typedef bsl::vector&lt;WeekendDaysTransitionPrivate&gt;
                                                 WeekendDaysTransitionSequence;

    struct WeekendDaysTransitionLess {
        // This &#39;struct&#39; provides a comparator predicate for the type
        // &#39;WeekendDaysTransition&#39; to enable the use of standard algorithms
        // (such as &#39;bsl::lower_bound&#39;) on ranges of objects of that type.

        // ACCESSORS
        bool operator()(const WeekendDaysTransitionPrivate&amp; lhs,
                        const WeekendDaysTransitionPrivate&amp; rhs) const
            // Return &#39;true&#39; if the value of the specified &#39;lhs&#39; is less than
            // (ordered before) the value of the specified &#39;rhs&#39;, and &#39;false&#39;
            // otherwise.  The value of &#39;lhs&#39; is less than the value of &#39;rhs&#39;
            // if the date represented by the data member &#39;first&#39; of &#39;lhs&#39; is
            // earlier than the date represented by the data member &#39;first&#39; of
            // &#39;rhs&#39;.
        {
            return lhs.first &lt; rhs.first;
        }
    };

  public:
    // TYPES
    typedef WeekendDaysTransitionPrivate WeekendDaysTransition;

    typedef PackedCalendar_BusinessDayConstIterator   BusinessDayConstIterator;

    typedef PackedCalendar_HolidayConstIterator       HolidayConstIterator;

    typedef PackedCalendar_HolidayCodeConstIterator   HolidayCodeConstIterator;

    typedef bdlt::CalendarReverseIteratorAdapter&lt;BusinessDayConstIterator&gt;
                                               BusinessDayConstReverseIterator;

    typedef bdlt::CalendarReverseIteratorAdapter&lt;HolidayConstIterator&gt;
                                                   HolidayConstReverseIterator;

    typedef bdlt::CalendarReverseIteratorAdapter&lt;HolidayCodeConstIterator&gt;
                                               HolidayCodeConstReverseIterator;

    typedef WeekendDaysTransitionSequence::const_iterator
                                            WeekendDaysTransitionConstIterator;

    typedef
    bsl::reverse_iterator&lt;WeekendDaysTransitionSequence::const_iterator&gt;
                                     WeekendDaysTransitionConstReverseIterator;

  private:
    // DATA
    Date                       d_firstDate;  // first valid date of calendar or
                                             // 9999/12/31 if this calendar is
                                             // empty

    Date                       d_lastDate;   // last valid date of calendar or
                                             // 0001/01/01 if this calendar is
                                             // empty

    bsl::vector&lt;WeekendDaysTransition&gt;
                               d_weekendDaysTransitions;
                                             // chronological list of weekend-
                                             // days transitions

    bdlc::PackedIntArray&lt;int&gt;  d_holidayOffsets;
                                             // ordered list of all holidays in
                                             // this calendar stored as offsets
                                             // from &#39;d_firstDate&#39;

    bdlc::PackedIntArray&lt;int&gt;  d_holidayCodesIndex;
                                             // parallel to &#39;d_holidayOffsets&#39;,
                                             // this is a list of indices into
                                             // &#39;d_holidayCodes&#39;; note that the
                                             // end of each sequence can be
                                             // determined using the value of
                                             // the next entry in this array if
                                             // it exists, or else the length
                                             // of &#39;d_holidayCodes&#39; itself

    bdlc::PackedIntArray&lt;int&gt;  d_holidayCodes;
                                             // sequences of holiday codes,
                                             // each partitioned into an
                                             // ordered &quot;chunk&quot; of codes per
                                             // holiday in &#39;d_holidayOffsets&#39;;
                                             // chunks are stored in the same
                                             // order as in &#39;d_holidayOffsets&#39;

    bslma::Allocator          *d_allocator_p;
                                             // memory allocator (held, not
                                             // owned)

    // FRIENDS
    friend class PackedCalendar_BusinessDayConstIterator;

    friend bool operator==(const PackedCalendar&amp;, const PackedCalendar&amp;);
    friend bool operator!=(const PackedCalendar&amp;, const PackedCalendar&amp;);

  private:
    // PRIVATE CLASS METHODS
    static void intersectHolidays(
                               bdlc::PackedIntArray&lt;int&gt; *resHolidayOffsets,
                               bdlc::PackedIntArray&lt;int&gt; *resHolidayCodesIndex,
                               bdlc::PackedIntArray&lt;int&gt; *resHolidayCodes,
                               const PackedCalendar&amp;      lhs,
                               const PackedCalendar&amp;      rhs,
                               const bdlt::Date           firstDate,
                               const bdlt::Date           lastDate);
        // Append, onto the specified &#39;resHolidayOffsets&#39;,
        // &#39;resHolidayCodesIndex&#39;, and &#39;resHolidayCodes&#39;, the intersection of
        // the holidays from the specified &#39;lhs&#39; and &#39;rhs&#39; calendars
        // restricted to the date range of the specified &#39;firstDate&#39; and
        // &#39;lastDate&#39;.  The behavior is undefined unless
        // &#39;firstDate &lt;= lastDate&#39;.

    static void unionHolidays(bdlc::PackedIntArray&lt;int&gt; *resHolidayOffsets,
                              bdlc::PackedIntArray&lt;int&gt; *resHolidayCodesIndex,
                              bdlc::PackedIntArray&lt;int&gt; *resHolidayCodes,
                              const PackedCalendar&amp;      lhs,
                              const PackedCalendar&amp;      rhs,
                              const bdlt::Date           firstDate,
                              const bdlt::Date           lastDate);
        // Append, onto the specified &#39;resHolidayOffsets&#39;,
        // &#39;resHolidayCodesIndex&#39;, and &#39;resHolidayCodes&#39;, the union of the
        // holidays from the specified &#39;lhs&#39; and &#39;rhs&#39; calendars restricted to
        // the date range of the specified &#39;firstDate&#39; and &#39;lastDate&#39;.  The
        // behavior is undefined unless &#39;firstDate &lt;= lastDate&#39;.

    // PRIVATE MANIPULATORS
    int addHolidayImp(int offset);
        // Add the specified &#39;offset&#39; as a holiday offset in this calendar.  If
        // the date represented by &#39;offset&#39; is already a holiday, this method
        // has no effect.  Return the index of &#39;d_holidayOffsets&#39; where
        // &#39;offset&#39; is stored.  The behavior is undefined unless &#39;0 &lt;= offset&#39;
        // and the &#39;offset&#39; represents a date within the valid range of the
        // calendar.

    // PRIVATE ACCESSORS
    CodesConstIterator beginHolidayCodes(
                                       const OffsetsConstIterator&amp; iter) const;
        // Return an iterator that refers to the first non-modifiable holiday
        // code for the holiday referenced by the specified &#39;iter&#39;.  If there
        // are no holiday codes associated with the date referenced by &#39;iter&#39;,
        // the returned iterator has the same value as that returned by
        // &#39;endHolidayCodes(iter)&#39;.  The behavior is undefined unless &#39;iter&#39;
        // refers to a valid holiday of this calendar.

    CodesConstIterator endHolidayCodes(const OffsetsConstIterator&amp; iter) const;
        // Return an iterator that indicates the element one past the last
        // holiday code associated with the date referenced by the specified
        // &#39;iter&#39;.  The behavior is undefined unless &#39;iter&#39; references a valid
        // holiday in this calendar.

  public:
    // CLASS METHODS

                                  // Aspects

    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that it is highly recommended that &#39;versionSelector&#39;
        // be formatted as &quot;YYYYMMDD&quot;, a date representation.  Also note that
        // &#39;versionSelector&#39; should be a *compile*-time-chosen value that
        // selects a format version supported by both externalizer and
        // unexternalizer.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    // CREATORS
    explicit PackedCalendar(bslma::Allocator *basicAllocator = 0);
        // Create an empty calendar, i.e., a calendar having an empty valid
        // range.  Optionally specify a &#39;basicAllocator&#39; used to supply memory.
        // If &#39;basicAllocator&#39; is 0, the currently installed default allocator
        // is used.

    PackedCalendar(const Date&amp;       firstDate,
                   const Date&amp;       lastDate,
                   bslma::Allocator *basicAllocator = 0);
        // Create a calendar having a valid range from the specified
        // &#39;firstDate&#39; through the specified &#39;lastDate&#39;.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.  The behavior is
        // undefined unless &#39;firstDate &lt;= lastDate&#39;.

    PackedCalendar(const PackedCalendar&amp;  original,
                   bslma::Allocator      *basicAllocator = 0);
        // Create a calendar having the value of the specified &#39;original&#39;
        // calendar.  Optionally specify a &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.

    ~PackedCalendar();
        // Destroy this object.

    // MANIPULATORS
    PackedCalendar&amp; operator=(const PackedCalendar&amp; rhs);
        // Assign to this calendar the value of the specified &#39;rhs&#39; calendar,
        // and return a reference providing modifiable access to this calendar.
        // See {Iterator Invalidation} for information regarding which
        // iterators are affected by the use of this method.

    void addDay(const Date&amp; date);
        // Extend the valid range (if necessary) of this calendar to include
        // the specified &#39;date&#39; value.

    void addHoliday(const Date&amp; date);
        // Mark the specified &#39;date&#39; as a holiday (i.e., a non-business day)
        // in this calendar.  Extend the valid range of this calendar if
        // necessary.  If &#39;date&#39; is already marked as a holiday, this method
        // has no effect.  See {Iterator Invalidation} for information
        // regarding which iterators are affected by the use of this method.

    void addHolidayCode(const Date&amp; date, int holidayCode);
        // Mark the specified &#39;date&#39; as a holiday (i.e., a non-business day) in
        // this calendar and add the specified &#39;holidayCode&#39; (if not already
        // present) to the ordered set of codes associated with &#39;date&#39;.
        // Extend the valid range of this calendar if necessary.  If
        // &#39;holidayCode&#39; is already a code for &#39;date&#39;, this method has no
        // effect.  See {Iterator Invalidation} for information regarding
        // which iterators are affected by the use of this method.

    int addHolidayCodeIfInRange(const Date&amp; date, int holidayCode);
        // Mark the specified &#39;date&#39; as a holiday (i.e., a non-business day)
        // in this calendar and add the specified &#39;holidayCode&#39; (if not
        // already present) to the set of codes associated with &#39;date&#39;, if
        // &#39;date&#39; is within the valid range of this calendar.  Return 0 if
        // &#39;date&#39; is in range, and a non-zero value otherwise.  If
        // &#39;holidayCode&#39; is already a code for &#39;date&#39;, or if &#39;date&#39; is not in
        // the valid range, this method has no effect.  See
        // {Iterator Invalidation} for information regarding which iterators
        // are affected by the use of this method.  Note that this method may
        // be called repeatedly with the same value for &#39;date&#39; to build up a
        // set of holiday codes for that date.

    int addHolidayIfInRange(const Date&amp; date);
        // Mark the specified &#39;date&#39; as a holiday (i.e., a non-business day) in
        // this calendar if &#39;date&#39; is within the valid range.  Return 0 if
        // &#39;date&#39; is in range, and a non-zero value otherwise.  This method has
        // no effect if &#39;date&#39; is already marked as a holiday or is not in the
        // valid range.  See {Iterator Invalidation} for information regarding
        // which iterators are affected by the use of this method.

    void addWeekendDay(DayOfWeek::Enum weekendDay);
        // Add the specified &#39;weekendDay&#39; to the set of weekend days associated
        // with the weekend-days transition at January 1, 0001 maintained by
        // this calendar.  Create a transition at January 1, 0001 if one does
        // not exist.  See {Iterator Invalidation} for information regarding
        // which iterators are affected by the use of this method.  The
        // behavior is undefined unless no weekend-days transitions were added
        // to this calendar via the &#39;addWeekendDaysTransition&#39; method.

    void addWeekendDays(const DayOfWeekSet&amp; weekendDays);
        // Add the specified &#39;weekendDays&#39; to the set of weekend days
        // associated with the weekend-days transition at January 1, 0001
        // maintained by this calendar.  Create a transition at January 1, 0001
        // if one does not exist.  See {Iterator Invalidation} for information
        // regarding which iterators are affected by the use of this method.
        // The behavior is undefined unless no weekend-days transitions were
        // added to this calendar via the &#39;addWeekendDaysTransition&#39; method.

    void addWeekendDaysTransition(const Date&amp;         startDate,
                                  const DayOfWeekSet&amp; weekendDays);
        // Add to this calendar a weekend-days transition on the specified
        // &#39;startDate&#39; having the specified &#39;weekendDays&#39; set.  If a
        // weekend-days transition already exists on &#39;startDate&#39;, replace the
        // set of weekend days of that transition with &#39;weekendDays&#39;.  See
        // {Iterator Invalidation} for information regarding which iterators
        // are affected by the use of this method.  Note that this method does
        // not extend the valid range of the calendar.

    void intersectBusinessDays(const PackedCalendar&amp; other);
        // Merge the specified &#39;other&#39; calendar into this calendar such that
        // the valid range of this calendar becomes the *intersection* of the
        // two calendars&#39; ranges, and the weekend days and holidays for this
        // calendar become the union of those (non-business) days from the two
        // calendars -- i.e., the valid business days of this calendar become
        // the intersection of those of the two original calendar values, over
        // the *intersection* of their ranges.  For each holiday that remains,
        // the resulting holiday codes in this calendar will be the union of
        // the corresponding original holiday codes.  See
        // {Iterator Invalidation} for information regarding which iterators
        // are affected by the use of this method.

    void intersectNonBusinessDays(const PackedCalendar&amp; other);
        // Merge the specified &#39;other&#39; calendar into this calendar such that
        // the valid range of this calendar becomes the *intersection* of the
        // two calendars&#39; ranges, and the weekend days and holidays for this
        // calendar become the intersection of those (non-business) days from
        // the two calendars -- i.e., the valid business days of this calendar
        // become the union of those of the two original calendars, over the
        // *intersection* of their ranges.  For each holiday that remains, the
        // resulting holiday codes in this calendar will be the union of the
        // corresponding original holiday codes.  See {Iterator Invalidation}
        // for information regarding which iterators are affected by the use of
        // this method.

    void removeAll();
        // Remove all information from this calendar, leaving it with its
        // default constructed &quot;empty&quot; value.  See {Iterator Invalidation} for
        // information regarding which iterators are affected by the use of
        // this method.

    void removeHoliday(const Date&amp; date);
        // Remove from this calendar the holiday having the specified &#39;date&#39; if
        // such a holiday exists.  This operation has no effect if &#39;date&#39; is
        // not a holiday in this calendar.  See {Iterator Invalidation} for
        // information regarding which iterators are affected by the use of
        // this method.  Note that this method is defined for all &#39;date&#39;
        // values, not just those that fall within the valid range, and may be
        // invoked even on an empty calendar (i.e., having &#39;0 == length()&#39;).

    void removeHolidayCode(const Date&amp; date, int holidayCode);
        // Remove from this calendar the specified &#39;holidayCode&#39; for the
        // holiday having the specified &#39;date&#39; if such a holiday having
        // &#39;holidayCode&#39; exists.  This operation has no effect if &#39;date&#39; is not
        // a holiday in this calendar, or if the holiday at &#39;date&#39; does not
        // have &#39;holidayCode&#39; associated with it.  See {Iterator Invalidation}
        // for information regarding which iterators are affected by the use of
        // this method.  Note that this method is defined for all &#39;date&#39;
        // values, not just those that fall within the valid range, and may be
        // invoked even on an empty calendar (i.e., having &#39;0 == length()&#39;).

    void reserveHolidayCapacity(int numHolidays);
        // Reserve enough space to store at least the specified &#39;numHolidays&#39;
        // within this calendar.  This method has no effect if
        // &#39;numHolidays &lt;= numHolidays()&#39;.

    void reserveHolidayCodeCapacity(int numHolidayCodes);
        // Reserve enough space to store at least the specified
        // &#39;numHolidayCodes&#39; within this calendar assuming no additional
        // holidays are added to this calendar.  This method has no effect if
        // &#39;numHolidayCodes &lt;= numHolidayCodesTotal()&#39;.

    void setValidRange(const Date&amp; firstDate, const Date&amp; lastDate);
        // Set the range of this calendar using the specified &#39;firstDate&#39; and
        // &#39;lastDate&#39; as, respectively, the first date and the last date of the
        // calendar.  Any holiday that is outside the new range and its holiday
        // codes are removed.  See {Iterator Invalidation} for information
        // regarding which iterators are affected by the use of this method.
        // The behavior is undefined unless &#39;firstDate &lt;= lastDate&#39;.

    void unionBusinessDays(const PackedCalendar&amp; other);
        // Merge the specified &#39;other&#39; calendar into this calendar such that
        // the valid range of this calendar becomes the *union* of the two
        // calendars&#39; ranges (or the minimal continuous range spanning the two
        // ranges, if the ranges are non-overlapping), and the weekend days
        // and holidays for this calendar become the intersection of those
        // (non-business) days from the two calendars -- i.e., the valid
        // business days of this calendar become the union of those of the two
        // original calendar values.  For each holiday that remains, the
        // resulting holiday codes in this calendar will be the union of the
        // corresponding original holiday codes.  See {Iterator Invalidation}
        // for information regarding which iterators are affected by the use of
        // this method.

    void unionNonBusinessDays(const PackedCalendar&amp; other);
        // Merge the specified &#39;other&#39; calendar into this calendar such that
        // the valid range of this calendar becomes the *union* of the two
        // calendars&#39; ranges (or the minimal continuous range spanning the two
        // ranges, if the ranges are non-overlapping), and the weekend days
        // and holidays for this calendar become the union of those
        // (non-business) days from the two calendars -- i.e., the valid
        // business days of this calendar become the intersection of those of
        // the two calendars after each range is extended to cover the
        // resulting one.  For each holiday in either calendar, the resulting
        // holiday codes in this calendar will be the union of the
        // corresponding original holiday codes.  See {Iterator Invalidation}
        // for information regarding which iterators are affected by the use of
        // this method.

                                  // Aspects

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format and return a reference
        // to the modifiable &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;stream&#39; becomes invalid during this
        // operation or if &#39;version&#39; is not supported, this object is
        // unaltered.  Note that no version is read from &#39;stream&#39;.  See the
        // &#39;bdex&#39; package-level documentation for more information on &#39;bdex&#39;
        // streaming of value-semantic types and containers.

    void swap(PackedCalendar&amp; other);
        // Efficiently exchange the value of this object with the value of the
        // specified &#39;other&#39; object.  This method provides the no-throw
        // exception-safety guarantee.  The behavior is undefined unless this
        // object was created with the same allocator as &#39;other&#39;.

    // ACCESSORS
    BusinessDayConstIterator beginBusinessDays() const;
        // Return an iterator providing non-modifiable access to the first
        // business day in this calendar.  If this calendar has no valid
        // business days, the returned iterator has the same value as that
        // returned by &#39;endBusinessDays()&#39;.

    BusinessDayConstIterator beginBusinessDays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // business day that occurs on or after the specified &#39;date&#39; in this
        // calendar.  If this calendar has no such business day, the returned
        // iterator has the same value as that returned by
        // &#39;endBusinessDays(date)&#39;.  The behavior is undefined unless &#39;date&#39; is
        // within the valid range of this calendar.

    HolidayCodeConstIterator beginHolidayCodes(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // holiday code for the specified &#39;date&#39; in this calendar.  If there is
        // no holiday code associated with &#39;date&#39;, the returned iterator has
        // the same value as that returned by &#39;endHolidayCodes(date)&#39;.  The
        // behavior is undefined unless &#39;date&#39; is marked as a holiday in this
        // calendar.

    HolidayCodeConstIterator beginHolidayCodes(
                                       const HolidayConstIterator&amp; iter) const;
        // Return an iterator providing non-modifiable access to the first
        // holiday code for the holiday referenced by the specified &#39;iter&#39;.  If
        // there is no holiday code associated with the date referenced by
        // &#39;iter&#39;, the returned iterator has the same value as that returned by
        // &#39;endHolidayCodes(iter)&#39;.  The behavior is undefined unless &#39;iter&#39;
        // refers to a valid holiday of this calendar.

    HolidayConstIterator beginHolidays() const;
        // Return an iterator providing non-modifiable access to the first
        // holiday in this calendar.  If this calendar has no holidays, the
        // returned iterator has the same value as that returned by
        // &#39;endHolidays()&#39;.

    HolidayConstIterator beginHolidays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // holiday that occurs on or after the specified &#39;date&#39; in this
        // calendar.  If this calendar has no such holiday, the returned
        // iterator has the same value as that returned by &#39;endHolidays(date)&#39;.
        // The behavior is undefined unless &#39;date&#39; is within the valid range
        // of this calendar.

    WeekendDaysTransitionConstIterator beginWeekendDaysTransitions() const;
        // Return an iterator providing non-modifiable access to the first
        // weekend-days transition in the chronological sequence of
        // weekend-days transitions maintained by this calendar.  If this
        // calendar has no weekend-days transitions, the returned iterator has
        // the same value as that returned by &#39;endWeekendDaysTransitions()&#39;.

    BusinessDayConstIterator endBusinessDays() const;
        // Return an iterator providing non-modifiable access to the
        // past-the-end business day in this calendar.

    BusinessDayConstIterator endBusinessDays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // business day that occurs after the specified &#39;date&#39; in this
        // calendar.  If this calendar has no such business day, the returned
        // iterator has the same value as that returned by
        // &#39;endBusinessDays()&#39;.  The behavior is undefined unless &#39;date&#39; is
        // within the valid range of this calendar.

    HolidayCodeConstIterator endHolidayCodes(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the
        // past-the-end holiday code associated with the specified &#39;date&#39;.  The
        // behavior is undefined unless &#39;date&#39; is marked as a holiday in this
        // calendar.

    HolidayCodeConstIterator
                       endHolidayCodes(const HolidayConstIterator&amp; iter) const;
        // Return an iterator providing non-modifiable access to the
        // past-the-end holiday code associated with the date referenced by
        // the specified &#39;iter&#39;.  The behavior is undefined unless &#39;iter&#39;
        // references a valid holiday in this calendar.

    HolidayConstIterator endHolidays() const;
        // Return an iterator providing non-modifiable access to the
        // past-the-end holiday in the chronological sequence of holidays
        // maintained by this calendar.

    HolidayConstIterator endHolidays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // holiday that occurs after the specified &#39;date&#39; in this calendar.
        // If this calendar has no such holiday, the returned iterator has the
        // same value as that returned by &#39;endHolidays()&#39;.  The behavior is
        // undefined unless &#39;date&#39; is within the valid range of this calendar.

    WeekendDaysTransitionConstIterator endWeekendDaysTransitions() const;
        // Return an iterator providing non-modifiable access to the
        // past-the-end weekend-days transition in the chronological sequence
        // of weekend-days transitions maintained by this calendar.

    const Date&amp; firstDate() const;
        // Return a reference providing non-modifiable access to the earliest
        // date in the valid range of this calendar.  The behavior is
        // undefined unless this calendar is non-empty -- i.e., unless
        // &#39;1 &lt;= length()&#39;.

    int getNextBusinessDay(Date *nextBusinessDay, const Date&amp; date) const;
        // Load, into the specified &#39;nextBusinessDay&#39;, the date of the first
        // business day in this calendar following the specified &#39;date&#39;.
        // Return 0 on success -- i.e., if such a business day exists, and a
        // non-zero value (with no effect on &#39;nextBusinessDay&#39;) otherwise.  The
        // behavior is undefined unless &#39;date + 1&#39; is both a valid &#39;bdlt::Date&#39;
        // and within the valid range of this calendar.

    int getNextBusinessDay(Date        *nextBusinessDay,
                           const Date&amp;  date,
                           int          nth) const;
        // Load, into the specified &#39;nextBusinessDay&#39;, the date of the
        // specified &#39;nth&#39; business day in this calendar following the
        // specified &#39;date&#39;.  Return 0 on success -- i.e., if such a business
        // day exists, and a non-zero value (with no effect on
        // &#39;nextBusinessDay&#39;) otherwise.  The behavior is undefined unless
        // &#39;date + 1&#39; is both a valid &#39;bdlt::Date&#39; and within the valid range
        // of this calendar, and &#39;0 &lt; nth&#39;.

    bdlt::Date holiday(int index) const;
        // Return the holiday at the specified &#39;index&#39; in this calendar.  For
        // all &#39;index&#39; values from 0 to &#39;numHolidays() - 1&#39; (inclusive), a
        // unique holiday is returned.  The mapping of &#39;index&#39; to holiday is
        // invalidated when the set of holidays is modified by an invocation of
        // &#39;addHoliday&#39;, &#39;addHolidayIfInRange&#39;, &#39;intersectBusinessDays&#39;,
        // &#39;intersectNonBusinessDays&#39;, &#39;removeAll&#39;, &#39;removeHoliday&#39;,
        // &#39;setValidRange&#39;, &#39;unionBusinessDays&#39;, or &#39;unionNonBusinessDays&#39;.
        // The behavior is undefined unless &#39;0 &lt;= index &lt; numHolidays()&#39;.

    int holidayCode(const Date&amp; date, int index) const;
        // Return, for the holiday at the specified &#39;date&#39; in this calendar,
        // the holiday code at the specified &#39;index&#39;.  For all &#39;index&#39; values
        // from 0 to &#39;numHolidayCodes(date) - 1&#39; (inclusive), a unique holiday
        // code is returned.  The mapping of &#39;index&#39; to holiday code is
        // invalidated when the set of holidays or holiday codes is modified by
        // an invocation of &#39;addHoliday&#39;, &#39;addHolidayCode&#39;,
        // &#39;addHolidayCodeIfInRange&#39;, &#39;addHolidayIfInRange&#39;,
        // &#39;intersectBusinessDays&#39;, &#39;intersectNonBusinessDays&#39;, &#39;removeAll&#39;,
        // &#39;removeHoliday&#39;, &#39;removeHolidayCode&#39;, &#39;setValidRange&#39;,
        // &#39;unionBusinessDays&#39;, or &#39;unionNonBusinessDays&#39;.  The behavior is
        // undefined unless &#39;date&#39; is a holiday in this calendar and
        // &#39;0 &lt;= index &lt; numHolidayCodes(date)&#39;.  Note that this method
        // facilitates testing and generally should not be used by clients; in
        // particular, using this method to iterate over the holiday codes for
        // &#39;date&#39; is less efficient than using a &#39;HolidayCodeConstIterator&#39;.

    bool isBusinessDay(const Date&amp; date) const;
        // Return &#39;true&#39; if the specified &#39;date&#39; is a business day (i.e., not
        // a holiday or weekend day) in this calendar, and &#39;false&#39; otherwise.
        // The behavior is undefined unless &#39;date&#39; is within the valid range of
        // this calendar.

    bool isHoliday(const Date&amp; date) const;
        // Return &#39;true&#39; if the specified &#39;date&#39; is a holiday in this calendar,
        // and &#39;false&#39; otherwise.  The behavior is undefined unless &#39;date&#39; is
        // within the valid range of this calendar.

    bool isInRange(const Date&amp; date) const;
        // Return &#39;true&#39; if the specified &#39;date&#39; is within the valid range of
        // this calendar (i.e., &#39;firstDate() &lt;= date &lt;= lastDate()&#39;), and
        // &#39;false&#39; otherwise.  Note that the valid range for a
        // &#39;PackedCalendar&#39; is empty if its length is 0.

    bool isNonBusinessDay(const Date&amp; date) const;
        // Return &#39;true&#39; if the specified &#39;date&#39; is not a business day (i.e.,
        // is either a holiday or weekend day) in this calendar, and &#39;false&#39;
        // otherwise.  The behavior is undefined unless &#39;date&#39; is within the
        // valid range of this calendar.  Note that:
        //..
        //  !isBusinessDay(date)
        //..
        // returns the same result.

    bool isWeekendDay(const Date&amp; date) const;
        // Return &#39;true&#39; if the specified &#39;date&#39; falls on a day of the week
        // that is considered a weekend day in this calendar, and &#39;false&#39;
        // otherwise.  Note that this method is defined for all &#39;date&#39; values,
        // not just those that fall within the valid range, and may be invoked
        // even on an empty calendar (i.e., having &#39;0 == length()&#39;).

    bool isWeekendDay(DayOfWeek::Enum dayOfWeek) const;
        // Return &#39;true&#39; if the specified &#39;dayOfWeek&#39; is a weekend day in this
        // calendar, and &#39;false&#39; otherwise.  The behavior is undefined unless
        // no weekend-days transitions were added to this calendar via the
        // &#39;addWeekendDaysTransition&#39; method.

    const Date&amp; lastDate() const;
        // Return a reference providing non-modifiable access to the latest
        // date in the valid range of this calendar.  The behavior is
        // undefined unless this calendar is non-empty -- i.e., unless
        // &#39;1 &lt;= length()&#39;.

    int length() const;
        // Return the number of days in the valid range of this calendar,
        // which is defined to be 0 if this calendar is empty, and
        // &#39;lastDate() - firstDate() + 1&#39; otherwise.

    int numBusinessDays() const;
        // Return the number of days in the valid range of this calendar that
        // are considered business days -- i.e., are neither holidays nor
        // weekend days.  Note that
        // &#39;numBusinessDays() == length() - numNonBusinessDays()&#39;.

    int numBusinessDays(const Date&amp; beginDate, const Date&amp; endDate) const;
        // Return the number of days in the specified range
        // &#39;[beginDate .. endDate]&#39; of this calendar that are considered
        // business days -- i.e., are neither holidays nor weekend days.  The
        // behavior is undefined unless &#39;beginDate&#39; and &#39;endDate&#39; are within
        // the valid range of this calendar, and &#39;beginDate &lt;= endDate&#39;.

    int numHolidayCodes(const Date&amp; date) const;
        // Return the number of (unique) holiday codes associated with the
        // specified &#39;date&#39; in this calendar if &#39;date&#39; is a holiday in this
        // calender, and 0 otherwise.  The behavior is undefined unless &#39;date&#39;
        // is within the valid range of this calendar.

    int numHolidayCodesTotal() const;
        // Return the total number of holiday codes for all holidays in this
        // calendar.  Note that this function is used primarily in conjunction
        // with &#39;reserveHolidayCodeCapacity&#39;.

    int numHolidays() const;
        // Return the number of days in the valid range of this calendar that
        // are individually marked as holidays, irrespective of whether or not
        // the date is also considered a weekend day.

    int numNonBusinessDays() const;
        // Return the number of days in the valid range of this calendar that
        // are *not* considered business days -- i.e., are either holidays,
        // weekend days, or both.  Note that
        // &#39;numNonBusinessDays() == length() - numBusinessDays()&#39;.

    int numWeekendDaysInRange() const;
        // Return the number of days in the valid range of this calendar that
        // are considered weekend days, irrespective of any designated
        // holidays.

    int numWeekendDaysTransitions() const;
        // Return the number of weekend-days transitions maintained by this
        // calendar.

    BusinessDayConstReverseIterator rbeginBusinessDays() const;
        // Return an iterator providing non-modifiable access to the last
        // business day in this calendar.  If this calendar has no valid
        // business days, the returned iterator has the same value as that
        // returned by &#39;rendBusinessDays()&#39;.

    BusinessDayConstReverseIterator rbeginBusinessDays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // business day that occurs on or before the specified &#39;date&#39; in this
        // calendar.  If this calendar has no such business day, the returned
        // iterator has the same value as that returned by
        // &#39;rendBusinessDays(date)&#39;.  The behavior is undefined unless &#39;date&#39;
        // is within the valid range of this calendar.

    HolidayCodeConstReverseIterator rbeginHolidayCodes(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the last
        // holiday code associated with the specified &#39;date&#39; in this calendar.
        // If there are no holiday codes associated with &#39;date&#39;, the returned
        // iterator has the same value as that returned by
        // &#39;rendHolidayCodes(date)&#39;.  The behavior is undefined unless &#39;date&#39;
        // is marked as a holiday in this calendar.

    HolidayCodeConstReverseIterator
                    rbeginHolidayCodes(const HolidayConstIterator&amp; iter) const;
        // Return an iterator providing non-modifiable access to the last
        // holiday code associated with the holiday referenced by the specified
        // &#39;iter&#39;.  If there are no holiday codes associated with the date
        // referenced by &#39;iter&#39;, the returned iterator has the same value as
        // that returned by &#39;rendHolidayCodes(iter)&#39;.  The behavior is
        // undefined unless &#39;iter&#39; refers to a valid holiday of this calendar.

    HolidayConstReverseIterator rbeginHolidays() const;
        // Return an iterator providing non-modifiable access to the last
        // holiday in this calendar.  If this calendar has no holidays, the
        // returned iterator has the same value as that returned by
        // &#39;rendHolidays()&#39;.

    HolidayConstReverseIterator rbeginHolidays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // holiday that occurs on or before the specified &#39;date&#39; in this
        // calendar.  If this calendar has no such holiday, the returned
        // iterator has the same value as that returned by
        // &#39;rendHolidays(date)&#39;.  The behavior is undefined unless &#39;date&#39; is
        // within the valid range of this calendar.

    WeekendDaysTransitionConstReverseIterator
                                          rbeginWeekendDaysTransitions() const;
        // Return an iterator providing non-modifiable access to the last
        // weekend-days transition in the chronological sequence of
        // weekend-days transitions maintained by this calendar.  If this
        // calendar has no weekend-days transitions, the returned iterator has
        // the same value as that returned by &#39;rendWeekendDaysTransitions()&#39;.

    BusinessDayConstReverseIterator rendBusinessDays() const;
        // Return an iterator providing non-modifiable access to the element
        // one before the first business day in this calendar.

    BusinessDayConstReverseIterator rendBusinessDays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // business day that occurs before the specified &#39;date&#39; in this
        // calendar.  If this calendar has no such business day, the returned
        // iterator has the same value as that returned by
        // &#39;rendBusinessDays()&#39;.  The behavior is undefined unless &#39;date&#39; is
        // within the valid range of this calendar.

    HolidayCodeConstReverseIterator rendHolidayCodes(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the element
        // one before the first holiday code associated with the specified
        // &#39;date&#39;.  The behavior is undefined unless &#39;date&#39; is marked as a
        // holiday in this calendar.

    HolidayCodeConstReverseIterator
                      rendHolidayCodes(const HolidayConstIterator&amp; iter) const;
        // Return an iterator providing non-modifiable access to the element
        // one before the first holiday code associated with the holiday
        // referenced by the specified &#39;iter&#39;.  The behavior is undefined
        // unless &#39;iter&#39; references a valid holiday in this calendar.

    HolidayConstReverseIterator rendHolidays() const;
        // Return an iterator providing non-modifiable access to the element
        // one before the first holiday in this calendar.

    HolidayConstReverseIterator rendHolidays(const Date&amp; date) const;
        // Return an iterator providing non-modifiable access to the first
        // holiday that occurs before the specified &#39;date&#39; in this calendar.
        // If this calendar has no such holiday, the returned iterator has the
        // same value as that returned by &#39;rendHolidays()&#39;.  The behavior is
        // undefined unless &#39;date&#39; is within the valid range of this calendar.

    WeekendDaysTransitionConstReverseIterator
                                            rendWeekendDaysTransitions() const;
        // Return an iterator providing non-modifiable access to the element
        // one before the first weekend-days transition in the chronological
        // sequence of weekend-days transitions maintained by this calendar.

    WeekendDaysTransition weekendDaysTransition(int index) const;
        // Return the weekend-days transition at the specified &#39;index&#39; in this
        // calendar.  For all &#39;index&#39; values from 0 to
        // &#39;numWeekendDaysTransitions() - 1&#39; (inclusive), a unique weekend-days
        // transition is returned.  The mapping of &#39;index&#39; to weekend-days
        // transition is invalidated when the set of weekend-days transitions
        // is modified by an invocation of &#39;addWeekendDay&#39;, &#39;addWeekendDays&#39;,
        // &#39;addWeekendDaysTransition&#39;, &#39;intersectBusinessDays&#39;,
        // &#39;intersectNonBusinessDays&#39;, &#39;removeAll&#39;, &#39;unionBusinessDays&#39;, or
        // &#39;unionNonBusinessDays&#39;.  The behavior is undefined unless
        // &#39;0 &lt;= index &lt; numWeekendDaysTransitions()&#39;.

                                  // Aspects

    bslma::Allocator *allocator() const;
        // Return the allocator used by this object to supply memory.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write this value to the specified output &#39;stream&#39; using the
        // specified &#39;version&#39; format and return a reference to the modifiable
        // &#39;stream&#39;.  If &#39;version&#39; is not supported, &#39;stream&#39; is unmodified.
        // Note that &#39;version&#39; is not written to &#39;stream&#39;.  See the &#39;bdex&#39;
        // package-level documentation for more information on &#39;bdex&#39; streaming
        // of value-semantic types and containers.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the (absolute
        // value of) the optionally specified indentation &#39;level&#39; and return a
        // reference to the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified,
        // optionally specify &#39;spacesPerLevel&#39;, the number of spaces per
        // indentation level for this and all of its nested objects.  If
        // &#39;level&#39; is negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, format the entire output on one line,
        // suppressing all but the initial indentation (as governed by
        // &#39;level&#39;).  If &#39;stream&#39; is not valid on entry, this operation has no
        // effect.

};

// FREE OPERATORS
bool operator==(const PackedCalendar&amp; lhs, const PackedCalendar&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; calendars have the same
    // value, and &#39;false&#39; otherwise.  Two calendars have the same value if they
    // have the same valid range (or are both empty), the same weekend days,
    // the same holidays, and each corresponding pair of holidays has the same
    // (ordered) set of associated holiday codes.

bool operator!=(const PackedCalendar&amp; lhs, const PackedCalendar&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; calendars do not have the
    // same value, and &#39;false&#39; otherwise.  Two calendars do not have the same
    // value if they do not have the same valid range (and are not both empty),
    // do not have the same weekend days, do not have the same holidays, or,
    // for at least one corresponding pair of holidays, do not have the same
    // (ordered) set of associated holiday codes.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;         stream,
                         const PackedCalendar&amp; calendar);
    // Write the value of the specified &#39;calendar&#39; to the specified output
    // &#39;stream&#39;, and return a reference to the modifiable &#39;stream&#39;.

// FREE FUNCTIONS
void swap(PackedCalendar&amp; a, PackedCalendar&amp; b);
    // Efficiently exchange the values of the specified &#39;a&#39; and &#39;b&#39; objects.
    // This function provides the no-throw exception-safety guarantee.  The
    // behavior is undefined unless the two objects were created with the same
    // allocator.

                       // ==============================
                       // class PackedCalendar_DateProxy
                       // ==============================

class PackedCalendar_DateProxy {
    // This class serves as a proxy for &#39;Date&#39; for use by the arrow operator of
    // calendar iterators (e.g., &#39;PackedCalendar_HolidayConstIterator&#39;).  An
    // object of this class behaves as the &#39;Date&#39; object with which it was
    // constructed.

    // DATA
    Date d_date;  // proxied date

  private:
    // NOT IMPLEMENTED
    PackedCalendar_DateProxy&amp; operator=(const PackedCalendar_DateProxy&amp;);

  public:
    // CREATORS
    PackedCalendar_DateProxy(const Date&amp; date);                     // IMPLICIT
        // Create a proxy object for the specified &#39;date&#39;.

    ~PackedCalendar_DateProxy();
        // Destroy this object.

    PackedCalendar_DateProxy(const PackedCalendar_DateProxy&amp; original);
        // Create a proxy object referencing the same &#39;Date&#39; value as the
        // specified &#39;original&#39; proxy.

    // ACCESSORS
    const Date *operator-&gt;() const;
        // Return the address providing non-modifiable access to the proxied
        // date object.
};

                      // ============================
                      // class PackedCalendar_DateRef
                      // ============================

class PackedCalendar_DateRef : public Date {
    // This private class is used by the arrow operator of the holiday
    // iterator and business day iterator classes.  The objects instantiated
    // from this class serve as references to &#39;Date&#39; objects.

  private:
    // NOT IMPLEMENTED
    PackedCalendar_DateRef&amp; operator=(const PackedCalendar_DateRef&amp;);

  public:
    // CREATORS
    explicit PackedCalendar_DateRef(const Date&amp; date);
        // Create a date reference object using the specified &#39;date&#39;.

    PackedCalendar_DateRef(const PackedCalendar_DateRef&amp; original);
        // Create a date reference object having the value of the specified
        // &#39;original&#39; object.

    ~PackedCalendar_DateRef();
        // Destroy this object.

    // ACCESSORS
    PackedCalendar_DateProxy operator&amp;() const;
        // Return a proxy object to this object&#39;s referenced date.
};

                  // =========================================
                  // class PackedCalendar_HolidayConstIterator
                  // =========================================

class PackedCalendar_HolidayConstIterator {
    // Provide read-only, sequential access in increasing (chronological) order
    // to the holidays in a &#39;PackedCalendar&#39; object.  This class owns an
    // iterator into the &#39;bdlc::PackedIntArray&#39; storing the holiday offsets of
    // the referenced &#39;bdlt::PackedCalendar&#39; and a date, &#39;d_firstDate&#39;, to
    // convert the offsets into dates corresponding to holidays.

    // DATA
    bdlc::PackedIntArray&lt;int&gt;::const_iterator d_iterator;   // array&#39;s iterator

    Date                                      d_firstDate;  // offset date

    // FRIENDS
    friend class PackedCalendar;
    friend bool operator==(const PackedCalendar_HolidayConstIterator&amp;,
                           const PackedCalendar_HolidayConstIterator&amp;);
    friend bool operator!=(const PackedCalendar_HolidayConstIterator&amp;,
                           const PackedCalendar_HolidayConstIterator&amp;);

  private:
    // PRIVATE TYPES
    typedef bdlc::PackedIntArray&lt;int&gt;::const_iterator OffsetsConstIterator;

    // PRIVATE CREATORS
    PackedCalendar_HolidayConstIterator(const OffsetsConstIterator&amp; iter,
                                        const Date                  firstDate);
        // Create a holiday iterator using the specified &#39;iter&#39; and
        // &#39;firstDate&#39;.

  public:
    // TYPES
    typedef Date                     value_type;
    typedef int                      difference_type;
    typedef PackedCalendar_DateProxy pointer;
    typedef PackedCalendar_DateRef   reference;
        // The star operator returns a &#39;PackedCalendar_DateRef&#39; *by* *value*.



    // CREATORS
    PackedCalendar_HolidayConstIterator(
                          const PackedCalendar_HolidayConstIterator&amp; original);
        // Create an iterator having the value of the specified &#39;original&#39;
        // iterator.

    ~PackedCalendar_HolidayConstIterator();
        // Destroy this object.

    // MANIPULATORS
    PackedCalendar_HolidayConstIterator&amp; operator=(
                               const PackedCalendar_HolidayConstIterator&amp; rhs);
        // Assign to this iterator the value of the specified &#39;rhs&#39; iterator,
        // and return a reference providing modifiable access to this object.

    PackedCalendar_HolidayConstIterator&amp; operator++();
        // Advance this iterator to refer to the next holiday in the calendar,
        // and return a reference providing modifiable access to this object.
        // The behavior is undefined unless, on entry, this iterator
        // references a valid holiday.

    PackedCalendar_HolidayConstIterator&amp; operator--();
        // Regress this iterator to refer to the previous holiday in the
        // calendar, and return a reference providing modifiable access to this
        // object.  The behavior is undefined unless, on entry, this iterator
        // references a valid holiday that is not the first holiday in the
        // associated calendar.

    // ACCESSORS
    PackedCalendar_DateRef operator*() const;
        // Return a &#39;PackedCalendar_DateRef&#39; object that contains the date
        // value of the holiday referenced by this iterator.

    PackedCalendar_DateProxy operator-&gt;() const;
        // Return a date proxy for the holiday referenced by this iterator.
};

// FREE OPERATORS
bool operator==(const PackedCalendar_HolidayConstIterator&amp; lhs,
                const PackedCalendar_HolidayConstIterator&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; iterators refer to the
    // same element in the same calendar, and &#39;false&#39; otherwise.  The behavior
    // is undefined unless &#39;lhs&#39; and &#39;rhs&#39; both iterate over the same calendar.

bool operator!=(const PackedCalendar_HolidayConstIterator&amp; lhs,
                const PackedCalendar_HolidayConstIterator&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; iterators do not refer to
    // the same element in the same calendar, and &#39;false&#39; otherwise.  The
    // behavior is undefined unless &#39;lhs&#39; and &#39;rhs&#39; both iterate over the same
    // calendar.

PackedCalendar_HolidayConstIterator
                operator++(PackedCalendar_HolidayConstIterator&amp; iterator, int);
    // Advance the specified &#39;iterator&#39; to refer to the next holiday in the
    // associated calendar, and return the previous value of &#39;iterator&#39;.  The
    // behavior is undefined unless, on entry, &#39;iterator&#39; references a valid
    // holiday.

PackedCalendar_HolidayConstIterator
                operator--(PackedCalendar_HolidayConstIterator&amp; iterator, int);
    // Regress the specified &#39;iterator&#39; to refer to the previous holiday in the
    // associated calendar, and return the previous value of &#39;iterator&#39;.  The
    // behavior is undefined unless, on entry, &#39;iterator&#39; references a valid
    // holiday that is not the first holiday in the associated calendar.

               // =============================================
               // class PackedCalendar_HolidayCodeConstIterator
               // =============================================

class PackedCalendar_HolidayCodeConstIterator {
    // Provide read-only, sequential access in increasing (numerical) order to
    // the holiday codes in a &#39;PackedCalendar&#39; object.

    // DATA
    bdlc::PackedIntArray&lt;int&gt;::const_iterator d_iterator;  // array&#39;s iterator

    // FRIENDS
    friend class PackedCalendar;
    friend bool operator==(const PackedCalendar_HolidayCodeConstIterator&amp;,
                           const PackedCalendar_HolidayCodeConstIterator&amp;);
    friend bool operator!=(const PackedCalendar_HolidayCodeConstIterator&amp;,
                           const PackedCalendar_HolidayCodeConstIterator&amp;);
    friend bsl::ptrdiff_t operator-(
                               const PackedCalendar_HolidayCodeConstIterator&amp;,
                               const PackedCalendar_HolidayCodeConstIterator&amp;);

  private:
    // PRIVATE TYPES
    typedef bdlc::PackedIntArray&lt;int&gt;::const_iterator CodesConstIterator;

    // PRIVATE CREATORS
    PackedCalendar_HolidayCodeConstIterator(const CodesConstIterator&amp; iter);
                                                                    // IMPLICIT
        // Create a holiday-code iterator referencing the holiday code
        // referred to by the specified &#39;iter&#39;.

  public:
    // TYPES
    typedef int  value_type;
    typedef int  difference_type;
    typedef int *pointer;
    typedef int  reference;
        // The star operator returns an &#39;int&#39; *by* *value*.


    // CREATORS
    PackedCalendar_HolidayCodeConstIterator(
                      const PackedCalendar_HolidayCodeConstIterator&amp; original);
        // Create an object having the value of the specified &#39;original&#39;
        // iterator.

    ~PackedCalendar_HolidayCodeConstIterator();
        // Destroy this object.

    // MANIPULATORS
    PackedCalendar_HolidayCodeConstIterator&amp; operator=(
                           const PackedCalendar_HolidayCodeConstIterator&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; iterator, and
        // return a reference providing modifiable access to this object.

    PackedCalendar_HolidayCodeConstIterator&amp; operator++();
        // Advance this iterator to refer to the next holiday code for the
        // associated date in the associated calendar, and return a reference
        // providing modifiable access to this object.  The behavior is
        // undefined unless, on entry, this iterator references a valid
        // holiday code.

    PackedCalendar_HolidayCodeConstIterator&amp; operator--();
        // Regress this iterator to refer to the previous holiday code for the
        // associated date in the associated calendar, and return a reference
        // providing modifiable access to this object.  The behavior is
        // undefined unless, on entry, this iterator references a valid
        // holiday code that is not the first holiday code for the associated
        // date in the calendar.

    // ACCESSORS
    int operator*() const;
        // Return the holiday code referenced by this iterator.
};

// FREE OPERATORS
bool operator==(const PackedCalendar_HolidayCodeConstIterator&amp; lhs,
                const PackedCalendar_HolidayCodeConstIterator&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; iterators refers to the
    // same element, and &#39;false&#39; otherwise.  The behavior is undefined unless
    // &#39;lhs&#39; and &#39;rhs&#39; both reference the same holiday in the same calendar.

bool operator!=(const PackedCalendar_HolidayCodeConstIterator&amp; lhs,
                const PackedCalendar_HolidayCodeConstIterator&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; iterators do not refer to
    // the same element, and &#39;false&#39; otherwise.  The behavior is undefined
    // unless &#39;lhs&#39; and &#39;rhs&#39; both reference the same holiday in the same
    // calendar.

PackedCalendar_HolidayCodeConstIterator
            operator++(PackedCalendar_HolidayCodeConstIterator&amp; iterator, int);
    // Advance the specified &#39;iterator&#39; to refer to the next holiday code for
    // the associated date in the associated calendar, and return the previous
    // value of &#39;iterator&#39;.  The behavior is undefined unless, on entry,
    // &#39;iterator&#39; references a valid holiday code.

PackedCalendar_HolidayCodeConstIterator
            operator--(PackedCalendar_HolidayCodeConstIterator&amp; iterator, int);
    // Regress the specified &#39;iterator&#39; to refer to the previous holiday code
    // for the associated date in the associated calendar, and return the
    // previous value of &#39;iterator&#39;.  The behavior is undefined unless, on
    // entry, &#39;iterator&#39; references a valid holiday code that is not the first
    // holiday code for the associated date in the calendar.

bsl::ptrdiff_t operator-(const PackedCalendar_HolidayCodeConstIterator&amp; lhs,
                         const PackedCalendar_HolidayCodeConstIterator&amp; rhs);
    // Return the number of elements between specified &#39;lhs&#39; and &#39;rhs&#39;.  The
    // behavior is undefined unless &#39;lhs&#39; and &#39;rhs&#39; refer to codes associated
    // with the same holiday in the same calendar.

              // =============================================
              // class PackedCalendar_BusinessDayConstIterator
              // =============================================

class PackedCalendar_BusinessDayConstIterator {
    // Provide read-only, sequential access in increasing (chronological) order
    // to the business days in a &#39;PackedCalendar&#39; object.

    // DATA
    bdlc::PackedIntArray&lt;int&gt;::const_iterator  d_offsetIter;
                     // iterator for the holiday offsets

    const PackedCalendar                      *d_calendar_p;
                     // pointer to the calendar

    int                                        d_currentOffset;
                     // offset of the date referenced by this iterator from
                     // &#39;d_calendar_p-&gt;firstDate()&#39;; if
                     // &#39;d_endFlag &amp;&amp; 0 &lt; d_calendar_p-&gt;length()&#39;, must equal
                     // &#39;d_calendar_p-&gt;lastDate() - d_calendar_p-&gt;firstDate()&#39;;
                     // if &#39;d_endFlag &amp;&amp; 0 == d_calendar_p-&gt;length()&#39;, must
                     // equal 0

    bool                                       d_endFlag;
                     // indicates an &#39;end&#39; iterator if set to &#39;true&#39;

    // FRIENDS
    friend class PackedCalendar;
    friend bool operator==(const PackedCalendar_BusinessDayConstIterator&amp;,
                           const PackedCalendar_BusinessDayConstIterator&amp;);
    friend bool operator!=(const PackedCalendar_BusinessDayConstIterator&amp;,
                           const PackedCalendar_BusinessDayConstIterator&amp;);

  private:
    // PRIVATE TYPES
    typedef bdlc::PackedIntArray&lt;int&gt;::const_iterator OffsetsConstIterator;

    // PRIVATE CREATORS
    PackedCalendar_BusinessDayConstIterator(const PackedCalendar&amp; calendar,
                                            const Date&amp;           startDate,
                                            bool                  endIterFlag);
        // Create a business day iterator for the specified &#39;calendar&#39;.  If the
        // specified &#39;endIterFlag&#39; is &#39;false&#39;, then this iterator references
        // the first business day on or after the specified &#39;startDate&#39;;
        // otherwise, this iterator references one business day *past* the
        // first business day on or after &#39;startDate&#39;.  If no business day
        // matching the above specification exists, then this iterator will
        // reference one day past the end of its range.

    // PRIVATE MANIPULATORS
    void nextBusinessDay();
        // Advance this iterator to the next business day.  The behavior is
        // undefined unless &#39;false == d_endFlag&#39;.

    void previousBusinessDay();
        // Regress this iterator to the previous business day.  The behavior is
        // undefined unless &#39;*this != d_calendar_p-&gt;beginBusinessDays()&#39;.

  public:
    // TYPES
    typedef Date                     value_type;
    typedef int                      difference_type;
    typedef PackedCalendar_DateProxy pointer;
    typedef PackedCalendar_DateRef   reference;
        // The star operator returns a &#39;PackedCalendar_DateRef&#39; *by* *value*.


    // CREATORS
    PackedCalendar_BusinessDayConstIterator(
                      const PackedCalendar_BusinessDayConstIterator&amp; original);
        // Create an iterator having the value of the specified &#39;original&#39;
        // iterator.

    ~PackedCalendar_BusinessDayConstIterator();
        // Destroy this object.

    // MANIPULATORS
    PackedCalendar_BusinessDayConstIterator&amp; operator=(
                           const PackedCalendar_BusinessDayConstIterator&amp; rhs);
        // Assign to this iterator the value of the specified &#39;rhs&#39; iterator,
        // and return a reference providing modifiable access to this object.

    PackedCalendar_BusinessDayConstIterator&amp; operator++();
        // Advance this iterator to refer to the next business day in the
        // associated calendar, and return a reference providing modifiable
        // access to this object.  The behavior is undefined unless, on entry,
        // this iterator references a valid business day.

    PackedCalendar_BusinessDayConstIterator&amp; operator--();
        // Regress this iterator to refer to the previous business day in the
        // associated calendar, and return a reference providing modifiable
        // access to this object.  The behavior is undefined unless, on entry,
        // this iterator references a valid business day that is not the first
        // business day for the associated calendar.

    // ACCESSORS
    PackedCalendar_DateRef operator*() const;
        // Return a &#39;PackedCalendar_DateRef&#39; object that contains the date
        // value of the business day referenced by this iterator.

    PackedCalendar_DateProxy operator-&gt;() const;
        // Return a date proxy for the business day referenced by this
        // iterator.
};

// FREE OPERATORS
bool operator==(const PackedCalendar_BusinessDayConstIterator&amp; lhs,
                const PackedCalendar_BusinessDayConstIterator&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; iterators refer to the
    // same element in the same calendar, and &#39;false&#39; otherwise.  The behavior
    // is undefined unless &#39;lhs&#39; and &#39;rhs&#39; both iterate over the same calendar.

bool operator!=(const PackedCalendar_BusinessDayConstIterator&amp; lhs,
                const PackedCalendar_BusinessDayConstIterator&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; iterators do not refer to
    // the same element in the same calendar, and &#39;false&#39; otherwise.  The
    // behavior is undefined unless &#39;lhs&#39; and &#39;rhs&#39; both iterate over the same
    // calendar.

PackedCalendar_BusinessDayConstIterator operator++(
                       PackedCalendar_BusinessDayConstIterator&amp; iterator, int);
    // Advance the specified &#39;iterator&#39; to refer to the next business day in
    // the associated calendar, and return the previous value of &#39;iterator&#39;.
    // The behavior is undefined unless, on entry, &#39;iterator&#39; references a
    // valid business day.

PackedCalendar_BusinessDayConstIterator operator--(
                       PackedCalendar_BusinessDayConstIterator&amp; iterator, int);
    // Regress the specified &#39;iterator&#39; to refer to the previous business day
    // in the associated calendar, and return the previous value of &#39;iterator&#39;.
    // The behavior is undefined unless, on entry, &#39;iterator&#39; references a
    // valid business day that is not the first business day for the associated
    // calendar.

// ============================================================================
//                          INLINE DEFINITIONS
// ============================================================================

                     // ------------------------------
                     // class PackedCalendar_DateProxy
                     // ------------------------------

// CREATORS
inline
PackedCalendar_DateProxy::PackedCalendar_DateProxy(const Date&amp; date)
: d_date(date)
{
}

inline
PackedCalendar_DateProxy::~PackedCalendar_DateProxy()
{
}

inline
PackedCalendar_DateProxy::PackedCalendar_DateProxy(
                                      const PackedCalendar_DateProxy&amp; original)
: d_date(original.d_date)
{
}

// ACCESSORS
inline
const Date *PackedCalendar_DateProxy::operator-&gt;() const
{
    return &amp;d_date;
}

                        // ----------------------------
                        // class PackedCalendar_DateRef
                        // ----------------------------

// CREATORS
inline
PackedCalendar_DateRef::PackedCalendar_DateRef(const Date&amp; date)
: Date(date)
{
}

inline
PackedCalendar_DateRef::PackedCalendar_DateRef(
                                        const PackedCalendar_DateRef&amp; original)
: Date(original)
{
}

inline
PackedCalendar_DateRef::~PackedCalendar_DateRef()
{
}

// ACCESSORS
inline
PackedCalendar_DateProxy PackedCalendar_DateRef::operator&amp;() const
{
    return *this;
}

                    // -----------------------------------------
                    // class PackedCalendar_HolidayConstIterator
                    // -----------------------------------------

// PRIVATE CREATORS
inline
PackedCalendar_HolidayConstIterator::
     PackedCalendar_HolidayConstIterator(const OffsetsConstIterator&amp; iter,
                                         const Date                  firstDate)
: d_iterator(iter)
, d_firstDate(firstDate)
{
}

// CREATORS
inline
PackedCalendar_HolidayConstIterator::PackedCalendar_HolidayConstIterator(
                           const PackedCalendar_HolidayConstIterator&amp; original)
: d_iterator(original.d_iterator)
, d_firstDate(original.d_firstDate)
{
}

inline
PackedCalendar_HolidayConstIterator::~PackedCalendar_HolidayConstIterator()
{
}

// MANIPULATORS
inline
PackedCalendar_HolidayConstIterator&amp; PackedCalendar_HolidayConstIterator::
                      operator=(const PackedCalendar_HolidayConstIterator&amp; rhs)
{
    d_iterator  = rhs.d_iterator;
    d_firstDate = rhs.d_firstDate;
    return *this;
}

inline
PackedCalendar_HolidayConstIterator&amp;
                              PackedCalendar_HolidayConstIterator::operator++()
{
    ++d_iterator;
    return *this;
}

inline
PackedCalendar_HolidayConstIterator&amp;
                              PackedCalendar_HolidayConstIterator::operator--()
{
    --d_iterator;
    return *this;
}

// ACCESSORS
inline
PackedCalendar_DateRef PackedCalendar_HolidayConstIterator::operator*() const
{
    return PackedCalendar_DateRef(d_firstDate + *d_iterator);
}

inline
PackedCalendar_DateProxy
                        PackedCalendar_HolidayConstIterator::operator-&gt;() const
{
    return PackedCalendar_DateProxy(this-&gt;operator*());
}

}  // close package namespace

// FREE OPERATORS
inline
bool bdlt::operator==(const PackedCalendar_HolidayConstIterator&amp; lhs,
                      const PackedCalendar_HolidayConstIterator&amp; rhs)
{
    return lhs.d_iterator == rhs.d_iterator;
}

inline
bool bdlt::operator!=(const PackedCalendar_HolidayConstIterator&amp; lhs,
                      const PackedCalendar_HolidayConstIterator&amp; rhs)
{
    return lhs.d_iterator != rhs.d_iterator;
}

inline
bdlt::PackedCalendar_HolidayConstIterator
           bdlt::operator++(PackedCalendar_HolidayConstIterator&amp; iterator, int)
{
    PackedCalendar_HolidayConstIterator tmp(iterator);
    ++iterator;
    return tmp;
}

inline
bdlt::PackedCalendar_HolidayConstIterator
           bdlt::operator--(PackedCalendar_HolidayConstIterator&amp; iterator, int)
{
    PackedCalendar_HolidayConstIterator tmp(iterator);
    --iterator;
    return tmp;
}

namespace bdlt {

                // ---------------------------------------------
                // class PackedCalendar_HolidayCodeConstIterator
                // ---------------------------------------------

// PRIVATE CREATORS
inline
PackedCalendar_HolidayCodeConstIterator::
        PackedCalendar_HolidayCodeConstIterator(const CodesConstIterator&amp; iter)
: d_iterator(iter)
{
}

// CREATORS
inline
PackedCalendar_HolidayCodeConstIterator::
PackedCalendar_HolidayCodeConstIterator(
                       const PackedCalendar_HolidayCodeConstIterator&amp; original)
: d_iterator(original.d_iterator)
{
}

inline
PackedCalendar_HolidayCodeConstIterator::
                                     ~PackedCalendar_HolidayCodeConstIterator()
{
}

// MANIPULATORS
inline
PackedCalendar_HolidayCodeConstIterator&amp;
PackedCalendar_HolidayCodeConstIterator::
                  operator=(const PackedCalendar_HolidayCodeConstIterator&amp; rhs)
{
    d_iterator = rhs.d_iterator;
    return *this;
}

inline
PackedCalendar_HolidayCodeConstIterator&amp;
                          PackedCalendar_HolidayCodeConstIterator::operator++()
{
    ++d_iterator;
    return *this;
}

inline
PackedCalendar_HolidayCodeConstIterator&amp;
                          PackedCalendar_HolidayCodeConstIterator::operator--()
{
    --d_iterator;
    return *this;
}

// ACCESSORS
inline
int PackedCalendar_HolidayCodeConstIterator::operator*() const
{
    return *d_iterator;
}

}  // close package namespace

// FREE OPERATORS
inline
bool bdlt::operator==(const PackedCalendar_HolidayCodeConstIterator&amp; lhs,
                      const PackedCalendar_HolidayCodeConstIterator&amp; rhs)
{
    return lhs.d_iterator == rhs.d_iterator;
}

inline
bool bdlt::operator!=(const PackedCalendar_HolidayCodeConstIterator&amp; lhs,
                      const PackedCalendar_HolidayCodeConstIterator&amp; rhs)
{
    return lhs.d_iterator != rhs.d_iterator;
}

inline
bdlt::PackedCalendar_HolidayCodeConstIterator
       bdlt::operator++(PackedCalendar_HolidayCodeConstIterator&amp; iterator, int)
{
    bdlt::PackedCalendar_HolidayCodeConstIterator tmp(iterator);
    ++iterator;
    return tmp;
}

inline
bdlt::PackedCalendar_HolidayCodeConstIterator
       bdlt::operator--(PackedCalendar_HolidayCodeConstIterator&amp; iterator, int)
{
    PackedCalendar_HolidayCodeConstIterator tmp(iterator);
    --iterator;
    return tmp;
}

inline
bsl::ptrdiff_t
            bdlt::operator-(const PackedCalendar_HolidayCodeConstIterator&amp; lhs,
                            const PackedCalendar_HolidayCodeConstIterator&amp; rhs)
{
    return lhs.d_iterator - rhs.d_iterator;
}

namespace bdlt {

               // ---------------------------------------------
               // class PackedCalendar_BusinessDayConstIterator
               // ---------------------------------------------

// CREATORS
inline
PackedCalendar_BusinessDayConstIterator::
PackedCalendar_BusinessDayConstIterator(
                       const PackedCalendar_BusinessDayConstIterator&amp; original)
: d_offsetIter(original.d_offsetIter)
, d_calendar_p(original.d_calendar_p)
, d_currentOffset(original.d_currentOffset)
, d_endFlag(original.d_endFlag)
{
}

inline
PackedCalendar_BusinessDayConstIterator::
                                     ~PackedCalendar_BusinessDayConstIterator()
{
}

// MANIPULATORS
inline
PackedCalendar_BusinessDayConstIterator&amp;
                          PackedCalendar_BusinessDayConstIterator::operator++()
{
    BSLS_ASSERT_SAFE(false == d_endFlag);

    nextBusinessDay();
    return *this;
}

inline
PackedCalendar_BusinessDayConstIterator&amp;
                          PackedCalendar_BusinessDayConstIterator::operator--()
{
    BSLS_ASSERT_SAFE(*this != d_calendar_p-&gt;beginBusinessDays());

    previousBusinessDay();
    return *this;
}

// ACCESSORS
inline
PackedCalendar_DateRef
                     PackedCalendar_BusinessDayConstIterator::operator*() const
{
    return PackedCalendar_DateRef(d_calendar_p-&gt;firstDate() + d_currentOffset);
}

inline
PackedCalendar_DateProxy
                    PackedCalendar_BusinessDayConstIterator::operator-&gt;() const
{
    return PackedCalendar_DateProxy(this-&gt;operator*());
}

}  // close package namespace

// FREE OPERATORS
inline
bool bdlt::operator==(const PackedCalendar_BusinessDayConstIterator&amp; lhs,
                      const PackedCalendar_BusinessDayConstIterator&amp; rhs)
{
    BSLS_ASSERT_SAFE(lhs.d_calendar_p == rhs.d_calendar_p);

    return lhs.d_endFlag       == rhs.d_endFlag
        &amp;&amp; lhs.d_currentOffset == rhs.d_currentOffset;
}

inline
bool bdlt::operator!=(const PackedCalendar_BusinessDayConstIterator&amp; lhs,
                      const PackedCalendar_BusinessDayConstIterator&amp; rhs)
{
    BSLS_ASSERT_SAFE(lhs.d_calendar_p == rhs.d_calendar_p);

    return lhs.d_endFlag       != rhs.d_endFlag
        || lhs.d_currentOffset != rhs.d_currentOffset;
}

inline
bdlt::PackedCalendar_BusinessDayConstIterator bdlt::operator++(
                        PackedCalendar_BusinessDayConstIterator&amp; iterator, int)
{
    PackedCalendar_BusinessDayConstIterator tmp(iterator);
    ++iterator;
    return tmp;
}

inline
bdlt::PackedCalendar_BusinessDayConstIterator bdlt::operator--(
                        PackedCalendar_BusinessDayConstIterator&amp; iterator, int)
{
    PackedCalendar_BusinessDayConstIterator tmp(iterator);
    --iterator;
    return tmp;
}

namespace bdlt {

                         // --------------------
                         // class PackedCalendar
                         // --------------------

// PRIVATE ACCESSORS
inline
PackedCalendar::CodesConstIterator
      PackedCalendar::beginHolidayCodes(const OffsetsConstIterator&amp; iter) const
{
    BSLS_ASSERT_SAFE(isHoliday(d_firstDate + *iter));

    const int indexOffset = static_cast&lt;int&gt;(iter - d_holidayOffsets.begin());

    const bsl::size_t codeOffset = d_holidayCodesIndex[indexOffset];

    return d_holidayCodes.begin() + codeOffset;
}

inline
PackedCalendar::CodesConstIterator
        PackedCalendar::endHolidayCodes(const OffsetsConstIterator&amp; iter) const
{
    BSLS_ASSERT_SAFE(isHoliday(d_firstDate + *iter));

    const bsl::size_t endIndexOffset = iter - d_holidayOffsets.begin() + 1;

    const bsl::size_t iterIndex = endIndexOffset ==
                                                   d_holidayCodesIndex.length()
                                  ? d_holidayCodes.length()
                                  : d_holidayCodesIndex[endIndexOffset];
    return d_holidayCodes.begin() + iterIndex;
}

// CLASS METHODS

                                  // Aspects

inline
int PackedCalendar::maxSupportedBdexVersion(int versionSelector)
{
    if (versionSelector &gt;= 20150612) {
        return 3;                                                     // RETURN
    }
    return 2;
}

// MANIPULATORS
inline
int PackedCalendar::addHolidayCodeIfInRange(const Date&amp; date, int holidayCode)
{
    if (isInRange(date)) {
        addHolidayCode(date, holidayCode);
        return 0;                                                     // RETURN
    }
    return -1;
}

inline
int PackedCalendar::addHolidayIfInRange(const Date&amp; date)
{
    if (isInRange(date)) {
        addHoliday(date);
        return 0;                                                     // RETURN
    }
    return -1;
}

inline
void PackedCalendar::reserveHolidayCapacity(int numHolidays)
{
    BSLS_ASSERT_SAFE(0 &lt;= numHolidays);

    d_holidayOffsets.reserveCapacity(numHolidays);
    d_holidayCodesIndex.reserveCapacity(numHolidays);
}

inline
void PackedCalendar::reserveHolidayCodeCapacity(int numHolidayCodes)
{
    BSLS_ASSERT_SAFE(0 &lt;= numHolidayCodes);

    d_holidayCodes.reserveCapacity(numHolidayCodes);
}

                                  // Aspects

template &lt;class STREAM&gt;
STREAM&amp; PackedCalendar::bdexStreamIn(STREAM&amp; stream, int version)
{
    if (stream) {
        switch (version) {  // Switch on the schema version (starting with 1).
          case 3: {
            bdlt::Date firstDate;
            firstDate.bdexStreamIn(stream, 1);

            if (!stream) {
                return stream;                                        // RETURN
            }

            bdlt::Date lastDate;
            lastDate.bdexStreamIn(stream, 1);

            if (!stream
             || (firstDate &gt; lastDate
              &amp;&amp; (firstDate != Date(9999,12,31)
                  || lastDate  != Date(1,1,1)))) {
                stream.invalidate();
                return stream;                                        // RETURN
            }

            int length = lastDate - firstDate + 1;

            int transitionsLength;
            stream.getLength(transitionsLength);

            if (!stream || transitionsLength &lt; 0) {
                stream.invalidate();
                return stream;                                        // RETURN
            }

            bsl::vector&lt;WeekendDaysTransition&gt;
                      weekendDaysTransitions(transitionsLength, d_allocator_p);
            for (int i = 0; i &lt; transitionsLength; ++i) {
                WeekendDaysTransition&amp; wdt = weekendDaysTransitions[i];

                wdt.first.bdexStreamIn(stream, 1);

                if (!stream) {
                    return stream;                                    // RETURN
                }

                // The data must be monotonically increasing.

                if (i &amp;&amp; wdt.first &lt;= weekendDaysTransitions[i - 1].first) {
                    stream.invalidate();
                    return stream;                                    // RETURN
                }

                wdt.second.bdexStreamIn(stream, 1);

                if (!stream) {
                    return stream;                                    // RETURN
                }
            }

            bdlc::PackedIntArray&lt;int&gt; holidayOffsets(d_allocator_p);
            holidayOffsets.bdexStreamIn(stream, 1);

            if (!stream
             || (firstDate &gt;  lastDate &amp;&amp; !holidayOffsets.isEmpty())
             || (firstDate &lt;= lastDate
              &amp;&amp; (static_cast&lt;int&gt;(holidayOffsets.length()) &gt; length
               || (!holidayOffsets.isEmpty()
                &amp;&amp; (holidayOffsets[0] &lt; 0
                 || holidayOffsets[0] &gt; length))))) {
                stream.invalidate();
                return stream;                                        // RETURN
            }

            // The values in &#39;holidayOffsets&#39; must be monotonically increasing
            // and represent dates within the valid range.

            for (bsl::size_t i = 1; i &lt; holidayOffsets.length(); ++i) {
                if (holidayOffsets[i - 1] &gt;= holidayOffsets[i]
                 || holidayOffsets[i] &gt; length) {
                    stream.invalidate();
                    return stream;                                    // RETURN
                }
            }

            bdlc::PackedIntArray&lt;int&gt; holidayCodesIndex(d_allocator_p);
            holidayCodesIndex.bdexStreamIn(stream, 1);

            if (!stream
             || holidayCodesIndex.length() != holidayOffsets.length()
             || (!holidayCodesIndex.isEmpty() &amp;&amp; holidayCodesIndex[0] != 0)) {
                stream.invalidate();
                return stream;                                        // RETURN
            }

            // The values in &#39;holidayCodesIndex&#39; must be monotonically
            // non-decreasing.

            for (bsl::size_t i = 1; i &lt; holidayCodesIndex.length(); ++i) {
                if (holidayCodesIndex[i - 1] &gt; holidayCodesIndex[i]) {
                    stream.invalidate();
                    return stream;                                    // RETURN
                }
            }

            bdlc::PackedIntArray&lt;int&gt; holidayCodes(d_allocator_p);
            holidayCodes.bdexStreamIn(stream, 1);

            if (!stream
             || (holidayOffsets.isEmpty() &amp;&amp; !holidayCodes.isEmpty())) {
                stream.invalidate();
                return stream;                                        // RETURN
            }

            // The values in the segments of &#39;holidayOffsets&#39; must be
            // monotonically increasing.

            bsl::size_t index = 0;
            for (int i = 0; i &lt; static_cast&lt;int&gt;(holidayCodes.length()); ++i) {
                if (index &lt; holidayCodesIndex.length()
                 &amp;&amp; i == holidayCodesIndex[index]) {
                    ++index;
                    while (index &lt; holidayCodesIndex.length()
                        &amp;&amp; i == holidayCodesIndex[index]) {
                        ++index;
                    }
                }
                else if (holidayCodes[i - 1] &gt;= holidayCodes[i]) {
                    stream.invalidate();
                    return stream;                                    // RETURN
                }
            }

            bslalg::SwapUtil::swap(&amp;d_firstDate,         &amp;firstDate);
            bslalg::SwapUtil::swap(&amp;d_lastDate,          &amp;lastDate);
            bslalg::SwapUtil::swap(&amp;d_weekendDaysTransitions,
                                   &amp;weekendDaysTransitions);
            bslalg::SwapUtil::swap(&amp;d_holidayOffsets,    &amp;holidayOffsets);
            bslalg::SwapUtil::swap(&amp;d_holidayCodesIndex, &amp;holidayCodesIndex);
            bslalg::SwapUtil::swap(&amp;d_holidayCodes,      &amp;holidayCodes);
          } break;
          case 2: {
            PackedCalendar inCal(d_allocator_p);
            inCal.d_firstDate.bdexStreamIn(stream, 1);
            if (!stream) {
                return stream;                                        // RETURN
            }

            inCal.d_lastDate.bdexStreamIn(stream, 1);
            if (!stream
             || (inCal.d_firstDate &gt; inCal.d_lastDate
              &amp;&amp; (inCal.d_firstDate != Date(9999,12,31)
               || inCal.d_lastDate  != Date(1,1,1)))) {
                stream.invalidate();
                return stream;                                        // RETURN
            }
            int length = inCal.d_lastDate - inCal.d_firstDate + 1;

            int transitionsLength;
            stream.getLength(transitionsLength);
            if (!stream || transitionsLength &lt; 0)
            {
                stream.invalidate();
                return stream;                                        // RETURN
            }

            int offsetsLength;
            stream.getLength(offsetsLength);
            if (!stream
             || (inCal.d_firstDate &gt;  inCal.d_lastDate
              &amp;&amp; offsetsLength != 0)
             || (inCal.d_firstDate &lt;= inCal.d_lastDate
              &amp;&amp; (offsetsLength &lt; 0 || offsetsLength &gt; length))) {
                stream.invalidate();
                return stream;                                        // RETURN
            }
            BSLS_ASSERT_SAFE(offsetsLength &gt;= 0);

            int codesLength;
            stream.getLength(codesLength);
            if (!stream || (0 == offsetsLength &amp;&amp; codesLength != 0)) {
                stream.invalidate();
                return stream;                                        // RETURN
            }

            inCal.d_weekendDaysTransitions.resize(transitionsLength);

            // To ensure &#39;inCal&#39; cannot be in an invalid state, we must first
            // reserve capacity for the three &#39;PackedIntArray&#39; and then resize
            // them to guarantee the operations can complete without
            // re-allocation *and* the object invariants (see the destructor
            // implementation) are maintained.

            inCal.d_holidayOffsets.reserveCapacity(offsetsLength);
            inCal.d_holidayCodesIndex.reserveCapacity(offsetsLength);
            inCal.d_holidayCodes.reserveCapacity(codesLength);

            inCal.d_holidayOffsets.resize(offsetsLength);
            inCal.d_holidayCodesIndex.resize(offsetsLength);
            inCal.d_holidayCodes.resize(codesLength);

            for (WeekendDaysTransitionSequence::iterator it =
                     inCal.d_weekendDaysTransitions.begin();
                 it != inCal.d_weekendDaysTransitions.end();
                 ++it) {
                it-&gt;first.bdexStreamIn(stream, 1);
                if (!stream) {
                    return stream;                                    // RETURN
                }

                if (it        != inCal.d_weekendDaysTransitions.begin()
                 &amp;&amp; it-&gt;first &lt;= (it - 1)-&gt;first) {
                    stream.invalidate();
                    return stream;                                    // RETURN
                }

                it-&gt;second.bdexStreamIn(stream, 1);
                if (!stream) {
                    return stream;                                    // RETURN
                }
            }

            int previousValue = -1;
            for (int i = 0; i &lt; offsetsLength; ++i) {
                int tmp;
                stream.getInt32(tmp);
                if (!stream
                 || tmp &lt; 0
                 || tmp &gt;= length
                 || tmp &lt;= previousValue) {
                    stream.invalidate();
                    return stream;                                    // RETURN
                }
                inCal.d_holidayOffsets.replace(i, tmp);
                previousValue = tmp;
            }

            previousValue = -1;
            for (int i = 0; i &lt; offsetsLength; ++i) {
                int tmp;
                stream.getInt32(tmp);

                // This vector is ordered but duplicates are allowed.  The
                // first element must be 0.

                if (!stream
                 || tmp &lt; 0
                 || tmp &lt; previousValue
                 || tmp &gt; codesLength
                 || (0 == i &amp;&amp; 0 != tmp)) {

                    // If we get here, some of the code indices could
                    // potentially be greater than &#39;codesLength&#39;.  That would
                    // trigger an assertion in the destructor.  So call
                    // &#39;removeAll&#39; to clean up.

                    inCal.removeAll();
                    stream.invalidate();
                    return stream;                                    // RETURN
                }
                inCal.d_holidayCodesIndex.replace(i, tmp);
                previousValue = tmp;
            }

            CodesIndexConstIterator it = inCal.d_holidayCodesIndex.begin();
            CodesIndexConstIterator end = inCal.d_holidayCodesIndex.end();

            // Skip the holidays that have no codes.

            while (it != end &amp;&amp; 0 == *it) {
                ++it;
            }

            // &#39;it&#39; is now positioned at the first holiday with one or more
            // codes or at the end.

            bool previousValueFlag = false;  // This flag is used to determine
                                             // if we are inside an ordered
                                             // sequence of codes (i.e.,
                                             // &#39;previousValue&#39; refers to a
                                             // code for the same holiday as
                                             // &#39;value&#39;).

            for (int i = 0; i &lt; codesLength; ++i) {
                int tmp;
                stream.getInt32(tmp);
                if (!stream
                 || (previousValueFlag &amp;&amp; tmp &lt;= previousValue)) {
                    stream.invalidate();
                    return stream;                                    // RETURN
                }
                inCal.d_holidayCodes.replace(i, tmp);

                // Regardless of whether or not there is more data, advance the
                // index iterator as needed and update &#39;previousValueFlag&#39; if
                // &#39;it&#39; moves.

                if (it != end &amp;&amp; i == (*it - 1)) {
                    previousValueFlag = false;

                    while (it != end &amp;&amp; i == (*it - 1)) {
                        ++it;  // Skip the holidays that have no codes.
                    }
                }
                else {
                    previousValueFlag = true;
                }
                previousValue = tmp;
            }
            BSLS_ASSERT_SAFE(it == end);

            swap(inCal);  // This cannot throw.
          } break;
          case 1: {
            PackedCalendar inCal(d_allocator_p);
            inCal.d_firstDate.bdexStreamIn(stream, 1);
            if (!stream) {
                return stream;                                        // RETURN
            }

            inCal.d_lastDate.bdexStreamIn(stream, 1);
            if (!stream
             || (inCal.d_firstDate &gt; inCal.d_lastDate
              &amp;&amp; (inCal.d_firstDate != Date(9999, 12, 31)
               || inCal.d_lastDate  != Date(1, 1, 1)))) {
                stream.invalidate();
                return stream;                                        // RETURN
            }
            int length = inCal.d_lastDate - inCal.d_firstDate + 1;

            DayOfWeekSet weekendDays;
            weekendDays.bdexStreamIn(stream, 1);
            if (!stream) {
                return stream;                                        // RETURN
            }

            if (weekendDays.length() &gt; 0) {
                inCal.addWeekendDays(weekendDays);
            }

            int offsetsLength;
            stream.getLength(offsetsLength);
            if (!stream
             || (inCal.d_firstDate &gt;  inCal.d_lastDate
              &amp;&amp; offsetsLength != 0)
             || (inCal.d_firstDate &lt;= inCal.d_lastDate
              &amp;&amp; (offsetsLength &lt; 0 || offsetsLength &gt; length))) {
                stream.invalidate();
                return stream;                                        // RETURN
            }
            BSLS_ASSERT_SAFE(offsetsLength &gt;= 0);

            int codesLength;
            stream.getLength(codesLength);
            if (!stream || (0 == offsetsLength &amp;&amp; codesLength != 0)) {
                stream.invalidate();
                return stream;                                        // RETURN
            }

            // To ensure &#39;inCal&#39; cannot be in an invalid state, we must first
            // reserve capacity for the three &#39;PackedIntArray&#39; and then resize
            // them to guarantee the operations can complete without
            // re-allocation *and* the object invariants (see the destructor
            // implementation) are maintained.

            inCal.d_holidayOffsets.reserveCapacity(offsetsLength);
            inCal.d_holidayCodesIndex.reserveCapacity(offsetsLength);
            inCal.d_holidayCodes.reserveCapacity(codesLength);

            inCal.d_holidayOffsets.resize(offsetsLength);
            inCal.d_holidayCodesIndex.resize(offsetsLength);
            inCal.d_holidayCodes.resize(codesLength);

            int previousValue = -1;
            for (int i = 0; i &lt; offsetsLength; ++i) {
                int tmp;
                stream.getInt32(tmp);
                if (!stream
                 || tmp &lt; 0
                 || tmp &gt;= length
                 || tmp &lt;= previousValue) {
                    stream.invalidate();
                    return stream;                                    // RETURN
                }
                inCal.d_holidayOffsets.replace(i, tmp);
                previousValue = tmp;
            }

            previousValue = -1;
            for (int i = 0; i &lt; offsetsLength; ++i) {
                int tmp;
                stream.getInt32(tmp);

                // This vector is ordered but duplicates are allowed.  The
                // first element must be 0.

                if (!stream
                 || tmp &lt; 0
                 || tmp &lt; previousValue
                 || tmp &gt; codesLength
                 || (0 == i &amp;&amp; 0 != tmp)) {

                    // If we get here, some of the code indices could
                    // potentially be greater than &#39;codesLength&#39;.  That would
                    // trigger an assertion in the destructor.  So call
                    // &#39;removeAll&#39; to clean up.

                    inCal.removeAll();
                    stream.invalidate();
                    return stream;                                    // RETURN
                }
                inCal.d_holidayCodesIndex.replace(i, tmp);
                previousValue = tmp;
            }

            CodesIndexConstIterator it = inCal.d_holidayCodesIndex.begin();
            CodesIndexConstIterator end = inCal.d_holidayCodesIndex.end();

            // Skip the holidays that have no codes.

            while (it != end &amp;&amp; 0 == *it) {
                ++it;
            }

            // &#39;it&#39; is now positioned at the first holiday with one or more
            // codes or at the end.

            bool previousValueFlag = false;  // This flag is used to determine
                                             // if we are inside an ordered
                                             // sequence of codes (i.e.,
                                             // &#39;previousValue&#39; refers to a
                                             // code for the same holiday as
                                             // &#39;value&#39;).

            for (int i = 0; i &lt; codesLength; ++i) {
                int tmp;
                stream.getInt32(tmp);
                if (!stream
                 || (previousValueFlag &amp;&amp; tmp &lt;= previousValue)) {
                    stream.invalidate();
                    return stream;                                    // RETURN
                }
                inCal.d_holidayCodes.replace(i, tmp);

                // Regardless of whether or not there is more data, advance the
                // index iterator as needed and update &#39;previousValueFlag&#39; if
                // &#39;it&#39; moves.

                if (it != end &amp;&amp; i == (*it - 1)) {
                    previousValueFlag = false;

                    while (it != end &amp;&amp; i == (*it - 1)) {
                        ++it;  // Skip the holidays that have no codes.
                    }
                }
                else {
                    previousValueFlag = true;
                }
                previousValue = tmp;
            }
            BSLS_ASSERT_SAFE(it == end);

            swap(inCal);  // This cannot throw.
          } break;
          default: {
            stream.invalidate();
          }
        }
    }
    return stream;
}

// ACCESSORS
inline
PackedCalendar::BusinessDayConstIterator
                                      PackedCalendar::beginBusinessDays() const
{
    return BusinessDayConstIterator(*this, d_firstDate, false);
}

inline
PackedCalendar::BusinessDayConstIterator
                      PackedCalendar::beginBusinessDays(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    return BusinessDayConstIterator(*this, date, false);
}

inline
PackedCalendar::HolidayCodeConstIterator
      PackedCalendar::beginHolidayCodes(const HolidayConstIterator&amp; iter) const
{
    BSLS_ASSERT_SAFE(isHoliday(*iter));

    return HolidayCodeConstIterator(beginHolidayCodes(iter.d_iterator));
}

inline
PackedCalendar::HolidayConstIterator PackedCalendar::beginHolidays() const
{
    return HolidayConstIterator(d_holidayOffsets.begin(), d_firstDate);
}

inline
PackedCalendar::HolidayConstIterator
                          PackedCalendar::beginHolidays(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    OffsetsConstIterator i = bdlc::PackedIntArrayUtil::lowerBound(
                                                      d_holidayOffsets.begin(),
                                                      d_holidayOffsets.end(),
                                                      date - d_firstDate);
    return HolidayConstIterator(i, d_firstDate);
}

inline
PackedCalendar::WeekendDaysTransitionConstIterator
                            PackedCalendar::beginWeekendDaysTransitions() const
{
    return d_weekendDaysTransitions.begin();
}

inline
PackedCalendar::BusinessDayConstIterator
                                        PackedCalendar::endBusinessDays() const
{
    return BusinessDayConstIterator(*this, d_lastDate, true);
}

inline
PackedCalendar::BusinessDayConstIterator
                        PackedCalendar::endBusinessDays(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    return BusinessDayConstIterator(*this, date, true);
}

inline
PackedCalendar::HolidayCodeConstIterator
        PackedCalendar::endHolidayCodes(const HolidayConstIterator&amp; iter) const
{
    BSLS_ASSERT_SAFE(isHoliday(*iter));

    return endHolidayCodes(iter.d_iterator);
}

inline
PackedCalendar::HolidayConstIterator PackedCalendar::endHolidays() const
{
    return HolidayConstIterator(d_holidayOffsets.end(), d_firstDate);
}

inline
PackedCalendar::HolidayConstIterator
                            PackedCalendar::endHolidays(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    OffsetsConstIterator i = bdlc::PackedIntArrayUtil::upperBound(
                                                      d_holidayOffsets.begin(),
                                                      d_holidayOffsets.end(),
                                                      date - d_firstDate);
    return HolidayConstIterator(i, d_firstDate);
}

inline
PackedCalendar::WeekendDaysTransitionConstIterator
                              PackedCalendar::endWeekendDaysTransitions() const
{
    return d_weekendDaysTransitions.end();
}

inline
const Date&amp; PackedCalendar::firstDate() const
{
    BSLS_ASSERT_SAFE(d_firstDate &lt;= d_lastDate);

    return d_firstDate;
}

inline
int PackedCalendar::getNextBusinessDay(Date        *nextBusinessDay,
                                       const Date&amp;  date) const
{
    BSLS_ASSERT_SAFE(nextBusinessDay);
    BSLS_ASSERT_SAFE(Date(9999, 12, 31) &gt; date);
    BSLS_ASSERT_SAFE(isInRange(date + 1));

    enum { e_SUCCESS = 0, e_FAILURE = 1 };

    BusinessDayConstIterator iter = beginBusinessDays(date + 1);
    if (iter == endBusinessDays()) {
        return e_FAILURE;                                             // RETURN
    }
    *nextBusinessDay = *iter;
    return e_SUCCESS;
}

inline
bdlt::Date PackedCalendar::holiday(int index) const
{
    BSLS_ASSERT_SAFE(0 &lt;= index);
    BSLS_ASSERT_SAFE(     index &lt; numHolidays());

    return d_firstDate + d_holidayOffsets[index];
}

inline
int PackedCalendar::holidayCode(const Date&amp; date, int index) const
{
    BSLS_ASSERT_SAFE(isInRange(date));
    BSLS_ASSERT_SAFE(isHoliday(date));
    BSLS_ASSERT_SAFE(0 &lt;= index);
    BSLS_ASSERT_SAFE(     index &lt; numHolidayCodes(date));

    const int                  offset = date - d_firstDate;
    const OffsetsConstIterator offsetBegin = d_holidayOffsets.begin();
    const OffsetsConstIterator offsetEnd   = d_holidayOffsets.end();
    const OffsetsConstIterator i = bdlc::PackedIntArrayUtil::lowerBound(
                                                                   offsetBegin,
                                                                   offsetEnd,
                                                                   offset);
    return d_holidayCodes[d_holidayCodesIndex[i - offsetBegin] + index];
}

inline
bool PackedCalendar::isBusinessDay(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    return !isNonBusinessDay(date);
}

inline
bool PackedCalendar::isHoliday(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    const int                  offset = date - d_firstDate;
    const OffsetsConstIterator offsetEnd = d_holidayOffsets.end();
    const OffsetsConstIterator i = bdlc::PackedIntArrayUtil::lowerBound(
                                                      d_holidayOffsets.begin(),
                                                      offsetEnd,
                                                      offset);

    return i != offsetEnd &amp;&amp; *i == offset;
}

inline
bool PackedCalendar::isInRange(const Date&amp; date) const
{
    return d_firstDate &lt;= date &amp;&amp; date &lt;= d_lastDate;
}

inline
bool PackedCalendar::isNonBusinessDay(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    return isWeekendDay(date) || isHoliday(date);
}

inline
bool PackedCalendar::isWeekendDay(DayOfWeek::Enum dayOfWeek) const
{
    BSLS_ASSERT_SAFE(d_weekendDaysTransitions.size() &lt;= 1);

    if (d_weekendDaysTransitions.empty()) {
        return false;                                                 // RETURN
    }

    BSLS_ASSERT_SAFE(d_weekendDaysTransitions[0].first == Date(1,1,1));

    return d_weekendDaysTransitions[0].second.isMember(dayOfWeek);
}

inline
const Date&amp; PackedCalendar::lastDate() const
{
    BSLS_ASSERT_SAFE(d_firstDate &lt;= d_lastDate);

    return d_lastDate;
}

inline
int PackedCalendar::length() const
{
    return d_firstDate &lt;= d_lastDate ? d_lastDate - d_firstDate + 1 : 0;
}

inline
int PackedCalendar::numBusinessDays() const
{
    return length() - numNonBusinessDays();
}

inline
int PackedCalendar::numHolidayCodesTotal() const
{
    return static_cast&lt;int&gt;(d_holidayCodes.length());
}

inline
int PackedCalendar::numHolidays() const
{
    return static_cast&lt;int&gt;(d_holidayOffsets.length());
}

inline
int PackedCalendar::numWeekendDaysTransitions() const
{
    return static_cast&lt;int&gt;(d_weekendDaysTransitions.size());
}

inline
PackedCalendar::BusinessDayConstReverseIterator
                                     PackedCalendar::rbeginBusinessDays() const
{
    return BusinessDayConstReverseIterator(endBusinessDays());
}

inline
PackedCalendar::BusinessDayConstReverseIterator
                     PackedCalendar::rbeginBusinessDays(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    return BusinessDayConstReverseIterator(endBusinessDays(date));
}

inline
PackedCalendar::HolidayCodeConstReverseIterator
                     PackedCalendar::rbeginHolidayCodes(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isHoliday(date));

    return HolidayCodeConstReverseIterator(endHolidayCodes(date));
}

inline
PackedCalendar::HolidayCodeConstReverseIterator
     PackedCalendar::rbeginHolidayCodes(const HolidayConstIterator&amp; iter) const
{
    BSLS_ASSERT_SAFE(isHoliday(*iter));

    return HolidayCodeConstReverseIterator(endHolidayCodes(iter));
}

inline
PackedCalendar::HolidayConstReverseIterator
                                         PackedCalendar::rbeginHolidays() const
{
    return HolidayConstReverseIterator(endHolidays());
}

inline
PackedCalendar::HolidayConstReverseIterator
                         PackedCalendar::rbeginHolidays(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    return HolidayConstReverseIterator(endHolidays(date));
}

inline
PackedCalendar::WeekendDaysTransitionConstReverseIterator
                           PackedCalendar::rbeginWeekendDaysTransitions() const
{
    return WeekendDaysTransitionConstReverseIterator(
                                               d_weekendDaysTransitions.end());
}

inline
PackedCalendar::BusinessDayConstReverseIterator
                                       PackedCalendar::rendBusinessDays() const
{
    return BusinessDayConstReverseIterator(beginBusinessDays());
}

inline
PackedCalendar::BusinessDayConstReverseIterator
                       PackedCalendar::rendBusinessDays(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    return BusinessDayConstReverseIterator(beginBusinessDays(date));
}

inline
PackedCalendar::HolidayCodeConstReverseIterator
                       PackedCalendar::rendHolidayCodes(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isHoliday(date));

    return HolidayCodeConstReverseIterator(beginHolidayCodes(date));
}

inline
PackedCalendar::HolidayCodeConstReverseIterator
       PackedCalendar::rendHolidayCodes(const HolidayConstIterator&amp; iter) const
{
    BSLS_ASSERT_SAFE(isHoliday(*iter));

    return HolidayCodeConstReverseIterator(beginHolidayCodes(iter));
}

inline
PackedCalendar::HolidayConstReverseIterator
                                           PackedCalendar::rendHolidays() const
{
    return HolidayConstReverseIterator(beginHolidays());
}

inline
PackedCalendar::HolidayConstReverseIterator
                           PackedCalendar::rendHolidays(const Date&amp; date) const
{
    BSLS_ASSERT_SAFE(isInRange(date));

    return HolidayConstReverseIterator(beginHolidays(date));
}

inline
PackedCalendar::WeekendDaysTransitionConstReverseIterator
                             PackedCalendar::rendWeekendDaysTransitions() const
{
    return WeekendDaysTransitionConstReverseIterator(
                                             d_weekendDaysTransitions.begin());
}

inline
PackedCalendar::WeekendDaysTransition
                         PackedCalendar::weekendDaysTransition(int index) const
{
    BSLS_ASSERT_SAFE(0 &lt;= index);
    BSLS_ASSERT_SAFE(     index &lt; numWeekendDaysTransitions());

    return d_weekendDaysTransitions[index];
}

                                  // Aspects

inline
bslma::Allocator *PackedCalendar::allocator() const
{
    return d_allocator_p;
}

template &lt;class STREAM&gt;
STREAM&amp; PackedCalendar::bdexStreamOut(STREAM&amp; stream, int version) const
{
    switch (version) {  // Switch on the schema version (starting with 1).
      case 3: {
        d_firstDate.bdexStreamOut(stream, 1);
        d_lastDate.bdexStreamOut(stream, 1);

        stream.putLength(static_cast&lt;int&gt;(d_weekendDaysTransitions.size()));
        for (WeekendDaysTransitionSequence::size_type i = 0;
             i &lt; d_weekendDaysTransitions.size();
             ++i) {
            d_weekendDaysTransitions[i].first.bdexStreamOut(stream, 1);
            d_weekendDaysTransitions[i].second.bdexStreamOut(stream, 1);
        }

        d_holidayOffsets.bdexStreamOut(stream, 1);
        d_holidayCodesIndex.bdexStreamOut(stream, 1);
        d_holidayCodes.bdexStreamOut(stream, 1);
      } break;
      case 2: {
        d_firstDate.bdexStreamOut(stream, 1);
        d_lastDate.bdexStreamOut(stream, 1);

        stream.putLength(static_cast&lt;int&gt;(d_weekendDaysTransitions.size()));
        stream.putLength(static_cast&lt;int&gt;(d_holidayOffsets.length()));
        stream.putLength(static_cast&lt;int&gt;(d_holidayCodes.length()));

        for (WeekendDaysTransitionSequence::size_type i = 0;
             i &lt; d_weekendDaysTransitions.size();
             ++i) {
            d_weekendDaysTransitions[i].first.bdexStreamOut(stream, 1);
            d_weekendDaysTransitions[i].second.bdexStreamOut(stream, 1);
        }

        for (bsl::size_t i = 0; i &lt; d_holidayOffsets.length(); ++i) {
            stream.putInt32(d_holidayOffsets[i]);
        }
        for (bsl::size_t i = 0; i &lt; d_holidayCodesIndex.length(); ++i) {
            stream.putInt32(d_holidayCodesIndex[i]);
        }
        for (bsl::size_t i = 0; i &lt; d_holidayCodes.length(); ++i) {
            stream.putInt32(d_holidayCodes[i]);
        }
      } break;
      case 1: {
        d_firstDate.bdexStreamOut(stream, 1);
        d_lastDate.bdexStreamOut(stream, 1);

        if (!d_weekendDaysTransitions.empty() &amp;&amp;
            d_weekendDaysTransitions[0].first == Date(1, 1, 1)) {
            d_weekendDaysTransitions[0].second.bdexStreamOut(stream, 1);
        }
        else {
            DayOfWeekSet tempSet;
            tempSet.bdexStreamOut(stream, 1);
        }

        stream.putLength(static_cast&lt;int&gt;(d_holidayOffsets.length()));
        stream.putLength(static_cast&lt;int&gt;(d_holidayCodes.length()));

        for (bsl::size_t i = 0; i &lt; d_holidayOffsets.length(); ++i) {
            stream.putInt32(d_holidayOffsets[i]);
        }
        for (bsl::size_t i = 0; i &lt; d_holidayCodesIndex.length(); ++i) {
            stream.putInt32(d_holidayCodesIndex[i]);
        }
        for (bsl::size_t i = 0; i &lt; d_holidayCodes.length(); ++i) {
            stream.putInt32(d_holidayCodes[i]);
        }
      } break;
      default: {
        stream.invalidate();
      }

    }
    return stream;
}


}  // close package namespace

// FREE OPERATORS
inline
bool bdlt::operator!=(const PackedCalendar&amp; lhs, const PackedCalendar&amp; rhs)
{
    return !(lhs == rhs);
}

// FREE FUNCTIONS
inline
void bdlt::swap(PackedCalendar&amp; a, PackedCalendar&amp; b)
{
    a.swap(b);
}

}  // close enterprise namespace

// TRAITS
namespace BloombergLP {
namespace bslma {

template &lt;&gt;
struct UsesBslmaAllocator&lt;bdlt::PackedCalendar&gt; : bsl::true_type {};

}  // close namespace bslma
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
