<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdls_fdstreambuf Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdls_fdstreambuf<br/>
<small>
[<a class="el" href="group__bdls.html">Package bdls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a stream buffer initialized with a file descriptor.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdls.html">bdls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Stream Initializaton</a> </li>
<li>
<a href="#3.1.2">Example 2: Streambuf</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a stream buffer initialized with a file descriptor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a> </td><td>stream buffer constructed with file descriptor  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>&lt;bsl::streambuf&gt; </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements a class, <code><a class="el" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a></code>, derived from the C++ standard library's <code>bsl::streambuf</code> that can be associated with a file descriptor. Except for the <code>pubimbue</code> function, all of the actions that can be performed on an <code>bsl::streambuf</code> can be performed on a <code><a class="el" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a></code>. An <code>bsl::streambuf</code> provides public methods for reading from and writing to a stream of data, which are implemented in terms of protected virtual functions. A <code><a class="el" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a></code> provides an implementation of these protected virtual members such that they operate on a given file descriptor. The file descriptor can represent a file, a pipe, or other device, and it can be associated with the <code><a class="el" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a></code> at construction, or by calling the <code>reset</code> method. Note that a <code>bsl::stream</code> can be initialized with a <code><a class="el" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a></code>, making it possible to associate the stream with a file descriptor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the <code>pubimbue</code> function may be called, but not with any value other than <code>bsl::locale()</code>. Furthermore, when called with this value, it has no effect. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The file descriptor type <code><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">bdls::FilesystemUtil::FileDescriptor</a></code> used in this component is, on Unix, an <code>int</code> type returned by <code>open</code>, and on Windows, a <code>HANDLE</code> type returned by <code>CreateFile</code>. Ideally, a user would open the file and obtain the platform-independent <code><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">bdls::FilesystemUtil::FileDescriptor</a></code> by calling <code><a class="el" href="structbdls_1_1FilesystemUtil.html#ac68835c410c78ead136a647058738062">bdls::FilesystemUtil::open</a></code>, which will call the appropriate routine for the platform and return a <code><a class="el" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">bdls::FilesystemUtil::FileDescriptor</a></code>. A value of <code><a class="el" href="structbdls_1_1FilesystemUtil.html#af6eb8fae5d490a49997d7e4fc59ae467">bdls::FilesystemUtil::k_INVALID_FD</a></code> is used to represent an invalid file handle on both platforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>On Windows for a file in text mode, the byte <code>0x1a</code> (ctrl-Z) is recognized as an end of file marker. If it is encountered, it is not returned in the buffer and subsequent reads will indicate that no more input is available. The behavior is undefined if it is not the last byte in the file. Other types of files are not required to end with <code>0x1a</code>. For files on Unix and files opened in binary mode on Windows, <code>0x1a</code> is treated like any other byte. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the public methods of the <code>bsl::streambuf</code> class used in the usage example are not described here. See documentation in "The C++ Programming Language, Third Edition", by Bjarne Stroustrup, Section 21.6.4, and on the web at: <br/>
<br/>
<div class="fragment"><pre class="fragment"> http:<span class="comment">//www.cplusplus.com/reference/iostream/streambuf</span>
</pre></div><br/>
<br/>
 Note that the <code><a class="el" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a></code> and <code><a class="el" href="classbdls_1_1FdStreamBuf__FileHandler.html">bdls::FdStreamBuf_FileHandler</a></code> classes here are based on STLPort's implementation of <code>filebuf</code> and <code>_Filebuf_Base</code> respectively, with copyright notice as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment"> ----------------------------------------------------------------------------
 Copyright (c) 1999
 Silicon Graphics Computer Systems, Inc.

 Copyright (c) 1999
 Boris Fomitchev

 This material is provided <span class="stringliteral">&quot;as is&quot;</span>, with absolutely no warranty expressed
 or implied.  Any use is at your own risk.

 Permission to use or copy <span class="keyword">this</span> software <span class="keywordflow">for</span> any purpose is hereby granted
 without fee, provided the above notices are retained on all copies.
 Permission to modify the code and to distribute modified code is granted,
 provided the above notices are retained, and a notice that the code was
 modified is included with the above copyright notice.
 ----------------------------------------------------------------------------
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_stream_initializaton"></a> <a class="anchor" id="usage.example_1~3A_stream_initializaton"></a> <a class="anchor" id="description.usage.example_1~3A_stream_initializaton"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Stream Initializaton: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The most common usage of this component is to initialize a stream. In this case, the <code><a class="el" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a></code> will be used for either input or output, but not both. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First we create a suitable file name, and make sure that no file of that name already exists: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">char</span> fileNameBuffer[100];
  bsl::sprintf(fileNameBuffer,
#ifdef BSLS_PLATFORM_OS_UNIX
               <span class="stringliteral">&quot;/tmp/bdls_FdStreamBuf.usage.1.%d.txt&quot;</span>,
#<span class="keywordflow">else</span> <span class="comment">// windows</span>
               <span class="stringliteral">&quot;C:\\TEMP\\bdls_FdStreamBuf.usage.1.%d.txt&quot;</span>;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>               <a class="code" href="structbdls_1_1ProcessUtil.html#a91e2ec5ff9b9496e25d8ad2fdea1c43b">bdls::ProcessUtil::getProcessId</a>());

  <a class="code" href="structbdls_1_1FilesystemUtil.html#aec68946bf27cba1c0aadf32b9e47fd4f">bdls::FilesystemUtil::remove</a>(fileNameBuffer);
  assert(0 == <a class="code" href="structbdls_1_1FilesystemUtil.html#a6a5769072861d4afd4d279377cfbeaf9">bdls::FilesystemUtil::exists</a>(fileNameBuffer));
</pre></div><br/>
<br/>
 Then we create the file and open a file descriptor to it; the boolean flags indicate that the file is to be writable, and not previously existing (and therefore must be created): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">bdls::FilesystemUtil::FileDescriptor</a> FdType;

  FdType fd = <a class="code" href="structbdls_1_1FilesystemUtil.html#ac68835c410c78ead136a647058738062">bdls::FilesystemUtil::open</a>(fileNameBuffer,
                                         <a class="code" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3ba5f3858914719d2049f7b07b7bd2933fb">bdls::FilesystemUtil::e_CREATE</a>,
                                         <a class="code" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908a2ffe2d27677b466194b884c43690fa56" title="Allow both reading and writing.">bdls::FilesystemUtil::e_READ_WRITE</a>);
  assert(<a class="code" href="structbdls_1_1FilesystemUtil.html#af6eb8fae5d490a49997d7e4fc59ae467">bdls::FilesystemUtil::k_INVALID_FD</a> != fd);
</pre></div><br/>
<br/>
 Next we create a <code><a class="el" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a></code> associated with file descriptor <code>fd</code>; the <code>false</code> argument indicates that <code>streamBuffer</code> will not assume ownership of <code>fd</code>, meaning that when <code>streamBuffer</code> is destroyed <code>fd</code> will remain open: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note also that the stream buffer defaults to being in text mode on Windows, and binary mode on Unix. <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      <a class="code" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a> streamBuffer(fd,
                                     <span class="keyword">true</span>,    <span class="comment">// writable</span>
                                     <span class="keyword">false</span>);  <span class="comment">// &#39;fd&#39; won&#39;t be closed</span>
                                              <span class="comment">// when &#39;streamBuffer&#39; is</span>
                                              <span class="comment">// destroyed</span>

      bsl::ostream os(&amp;streamBuffer);

      os &lt;&lt; <span class="stringliteral">&quot;Five times nine point five = &quot;</span> &lt;&lt; 5 * 9.5 &lt;&lt; bsl::endl;
  }
</pre></div><br/>
<br/>
 Note also that the stream buffer defaults to being in text mode on Windows, and binary mode on Unix. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Now create a new stream buffer to read the file back, in this case using binary mode so we can see exactly what was written. The new stream buf is used to initialize an input stream. <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      <span class="comment">// read it in binary mode</span>

      <a class="code" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a> streamBuffer(fd,
                                     <span class="keyword">false</span>,  <span class="comment">// not writable</span>
                                     <span class="keyword">false</span>,  <span class="comment">// &#39;streamBuffer&#39; does not</span>
                                             <span class="comment">// own &#39;fd&#39;</span>
                                     <span class="keyword">true</span>);  <span class="comment">// binary mode</span>

      streamBuffer.pubseekpos(0);

      <span class="keywordtype">char</span> buf[100];
      bsl::memset(buf, 0, <span class="keyword">sizeof</span>(buf));

      bsl::istream is(&amp;streamBuffer);
      <span class="keywordtype">char</span> *pc = buf;
      <span class="keywordflow">do</span> {
          is &gt;&gt; bsl::noskipws &gt;&gt; *pc++;
      } <span class="keywordflow">while</span> (<span class="charliteral">&#39;\n&#39;</span> != pc[-1]);

<span class="preprocessor">#ifdef BSLS_PLATFORM_OS_UNIX</span>
<span class="preprocessor"></span>      assert(!bsl::strcmp(<span class="stringliteral">&quot;Five times nine point five = 47.5\n&quot;</span>, buf));
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>      <span class="comment">//On Windows we see a CRLF (&#39;\r\n&#39;) instead of a simple LF &#39;\n&#39;</span>
      assert(!bsl::strcmp(<span class="stringliteral">&quot;Five times nine point five = 47.5\r\n&quot;</span>, buf));
<span class="preprocessor">#endif</span>
<span class="preprocessor">  }</span>
</pre></div><br/>
<br/>
 Finally, read the file back a second time, this time in text mode. Note how, on Windows, the <code>\r\n</code> is translated back to <code>\n</code> <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      <span class="comment">// read it back in text mode</span>

      <a class="code" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a> streamBuffer(fd,
                                     <span class="keyword">false</span>);  <span class="comment">// not writable</span>
                                              <span class="comment">// &#39;fd&#39; will be closed when</span>
                                              <span class="comment">// streamBuffer is destroyed.</span>
                                              <span class="comment">// Mode will be binary on</span>
                                              <span class="comment">// Unix, text on Dos.</span>
      streamBuffer.pubseekpos(0);

      <span class="keywordtype">char</span> buf[100];
      bsl::memset(buf, 0, <span class="keyword">sizeof</span>(buf));

      bsl::istream is(&amp;streamBuffer);
      <span class="keywordtype">char</span> *pc = buf;
      <span class="keywordflow">do</span> {
          is &gt;&gt; bsl::noskipws &gt;&gt; *pc++;
      } <span class="keywordflow">while</span> (<span class="charliteral">&#39;\n&#39;</span> != pc[-1]);

      assert(!bsl::strcmp(<span class="stringliteral">&quot;Five times nine point five = 47.5\n&quot;</span>, buf));
  }
</pre></div><br/>
<br/>
 And finally, we clean up: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbdls_1_1FilesystemUtil.html#aec68946bf27cba1c0aadf32b9e47fd4f">bdls::FilesystemUtil::remove</a>(fileNameBuffer);
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_streambuf"></a> <a class="anchor" id="usage.example_2~3A_streambuf"></a> <a class="anchor" id="description.usage.example_2~3A_streambuf"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Streambuf: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>For our second example we will create a <code><a class="el" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a></code> associated with a temporary file, and then use the public methods of the base class interface, including <code>sputn</code>, <code>sgetn</code> and <code>pubseekpos</code>, to do some I/O and seeking on it. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">char</span> line1[] = <span class="stringliteral">&quot;To be or not to be, that is the question.\n&quot;</span>;
  <span class="keyword">const</span> <span class="keywordtype">char</span> line2[] =
                     <span class="stringliteral">&quot;There are more things in heaven and earth,\n&quot;</span>
                     <span class="stringliteral">&quot;Horatio, than are dreamt of in your philosophy.\n&quot;</span>;
  <span class="keyword">const</span> <span class="keywordtype">char</span> line3[] = <span class="stringliteral">&quot;Wherever you go, there you are.  B Banzai\n&quot;</span>;

  <span class="keyword">const</span> <span class="keywordtype">int</span> lengthLine1 = <span class="keyword">sizeof</span>(line1) - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> lengthLine2 = <span class="keyword">sizeof</span>(line2) - 1;
  <span class="keyword">const</span> <span class="keywordtype">int</span> lengthLine3 = <span class="keyword">sizeof</span>(line3) - 1;
</pre></div><br/>
<br/>
 We start by selecting a file name for our (temporary) file. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">char</span> fileNameBuffer[100];
  bsl::sprintf(fileNameBuffer,
#ifdef BSLS_PLATFORM_OS_UNIX
               <span class="stringliteral">&quot;/tmp/bdls_FdStreamBuf.usage.2.%d.txt&quot;</span>,
#<span class="keywordflow">else</span> <span class="comment">// windows</span>
               <span class="stringliteral">&quot;C:\\TEMP\\bdls_FdStreamBuf.usage.2.%d.txt&quot;</span>,
#endif
               <a class="code" href="structbdls_1_1ProcessUtil.html#a91e2ec5ff9b9496e25d8ad2fdea1c43b">bdls::ProcessUtil::getProcessId</a>());
</pre></div><br/>
<br/>
 Then, make sure the file does not already exist: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbdls_1_1FilesystemUtil.html#aec68946bf27cba1c0aadf32b9e47fd4f">bdls::FilesystemUtil::remove</a>(fileNameBuffer);
  assert(<span class="keyword">false</span> == <a class="code" href="structbdls_1_1FilesystemUtil.html#a6a5769072861d4afd4d279377cfbeaf9">bdls::FilesystemUtil::exists</a>(fileNameBuffer));
</pre></div><br/>
<br/>
 Next, Create the file and open a file descriptor to it. The boolean flags indicate that the file is writable, and not previously existing (and therefore must be created): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="structbdls_1_1FilesystemUtil.html#af177603b027970757c45b67984235d36">bdls::FilesystemUtil::FileDescriptor</a> FdType;

  FdType fd = <a class="code" href="structbdls_1_1FilesystemUtil.html#ac68835c410c78ead136a647058738062">bdls::FilesystemUtil::open</a>(fileNameBuffer,
                                         <a class="code" href="structbdls_1_1FilesystemUtil.html#aaf288297e2a9b65fdcdd18c2aec66c3ba5f3858914719d2049f7b07b7bd2933fb">bdls::FilesystemUtil::e_CREATE</a>,
                                         <a class="code" href="structbdls_1_1FilesystemUtil.html#ab79b11034df3e25311be375da986b908a2ffe2d27677b466194b884c43690fa56" title="Allow both reading and writing.">bdls::FilesystemUtil::e_READ_WRITE</a>);
  assert(<a class="code" href="structbdls_1_1FilesystemUtil.html#af6eb8fae5d490a49997d7e4fc59ae467">bdls::FilesystemUtil::k_INVALID_FD</a> != fd);
</pre></div><br/>
<br/>
 Now, we create a <code><a class="el" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a></code> object named <code>streamBuffer</code> associated with the file descriptor <code>fd</code>. Note that <code>streamBuffer</code> defaults to assuming ownership of <code>fd</code>, meaning that when <code>streamBuffer</code> is cleared, reset, or destroyed, <code>fd</code> will be closed. Note that <code>FdStreamBuf</code> implements <code>streambuf</code>, which provides the public methods used in this example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdls_1_1FdStreamBuf.html">bdls::FdStreamBuf</a> streamBuffer(fd, <span class="keyword">true</span>);

  assert(streamBuffer.fileDescriptor() == fd);
  assert(streamBuffer.isOpened());
</pre></div><br/>
<br/>
 Next we use the <code>sputn</code> method to write two lines to the <a href="file:">file:</a> <br/>
<br/>
<div class="fragment"><pre class="fragment">  streamBuffer.sputn(line1, lengthLine1);
  streamBuffer.sputn(line2, lengthLine2);
</pre></div><br/>
<br/>
 Then we seek back to the start of the file. <br/>
<br/>
<div class="fragment"><pre class="fragment">  bsl::streamoff status = streamBuffer.pubseekpos(0);
  assert(0 == status);
</pre></div><br/>
<br/>
 Next, we read the first <code>lengthLine1</code> characters of the file into <code>buf</code>, with the method <code>sgetn</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">char</span> buf[1000];
  bsl::memset(buf, 0, <span class="keyword">sizeof</span>(buf));
  status = streamBuffer.sgetn(buf, lengthLine1);
  assert(lengthLine1 == status);
  assert(!bsl::strcmp(line1, buf));
</pre></div><br/>
<br/>
 Next we try to read <code>2 * lengthLine2</code> characters when only <code>lengthLine2</code> characters are available in the file to read, so the <code>sgetn</code> method will stop after reading <code>lengthLine2</code> characters. The <code>sgetn</code> method will return the number of chars successfully read: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bsl::memset(buf, 0, <span class="keyword">sizeof</span>(buf));
  status =  streamBuffer.sgetn(buf, 2 * lengthLine2);
  assert(lengthLine2 == status);
  assert(!bsl::strcmp(line2, buf));
</pre></div><br/>
<br/>
 Trying to read past the end of the file invalidated the current cursor position in the file, so we must seek from the end or the beginning of the file in order to establish a new cursor position. Note the <code>pubseekpos</code> method always seeks relative to the beginning. We seek back to the start of the <a href="file:">file:</a> <br/>
<br/>
<div class="fragment"><pre class="fragment">  status = streamBuffer.pubseekpos(0);
  assert(0 == status);
</pre></div><br/>
<br/>
 Note that line1 and line3 are the same length: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(lengthLine1 == lengthLine3);
</pre></div><br/>
<br/>
 Then we write, replacing <code>line1</code> in the file with <code>line3</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  status = streamBuffer.sputn(line3, lengthLine3);
  assert(lengthLine3 == status);
</pre></div><br/>
<br/>
 Now we seek back to the beginning of the <a href="file:">file:</a> <br/>
<br/>
<div class="fragment"><pre class="fragment">  status = streamBuffer.pubseekpos(0);
</pre></div><br/>
<br/>
 Next we verify we were returned to the start of the <a href="file:">file:</a> <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == status);
</pre></div><br/>
<br/>
 Then we read and verify the first line, which now contains the text of <code>line3</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bsl::memset(buf, 0, <span class="keyword">sizeof</span>(buf));
  status = streamBuffer.sgetn(buf, lengthLine3);
  assert(lengthLine3 == status);
  assert(!bsl::strcmp(line3, buf));
</pre></div><br/>
<br/>
 Now we read and verify the second line, still <code>line2</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bsl::memset(buf, 0, <span class="keyword">sizeof</span>(buf));
  status = streamBuffer.sgetn(buf, lengthLine2);
  assert(lengthLine2 == status);
  assert(!bsl::strcmp(line2, buf));
</pre></div><br/>
<br/>
 Next we close <code>fd</code> and disconnect <code>streamBuffer</code> from <code>fd</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  status = streamBuffer.clear();
  assert(0 == status);
</pre></div><br/>
<br/>
 Note that <code>streamBuffer</code> is now no longer open, and is not associated with a file descriptor: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(!streamBuffer.isOpened());
  assert(<a class="code" href="structbdls_1_1FilesystemUtil.html#af6eb8fae5d490a49997d7e4fc59ae467">bdls::FilesystemUtil::k_INVALID_FD</a> ==
         streamBuffer.fileDescriptor());
</pre></div><br/>
<br/>
 Finally, we clean up the <a href="file:">file:</a> <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbdls_1_1FilesystemUtil.html#aec68946bf27cba1c0aadf32b9e47fd4f">bdls::FilesystemUtil::remove</a>(fileNameBuffer);
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:47 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
