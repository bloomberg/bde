<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bdlt_localtimeoffset.h                                             -*-C++-*-
#ifndef INCLUDED_BDLT_LOCALTIMEOFFSET
#define INCLUDED_BDLT_LOCALTIMEOFFSET

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide utilities to retrieve the local time offset.
//
//@CLASSES:
//   bdlt::LocalTimeOffset: namespace for local time offset functions
//
//@SEE_ALSO: bsls_timeinterval, bsls_systemtime, bsls_currenttime
//
//@DESCRIPTION: This component provides a &#39;struct&#39;, &#39;bdlt::LocalTimeOffset&#39;, in
// which are defined a series of static methods for using a callback function
// to retrieve the local time offset (the difference between the currently
// executing task&#39;s local time and UTC time) at a specified UTC date and time.
// &#39;LocalTimeoffset&#39; provides a function &#39;localTimeOffset&#39; that delegates to
// the currently installed local time offset callback.  By default,
// &#39;localTimeOffsetDefault&#39; is installed as the local time offset callback.
// Clients can configure the default callback function by calling the
// &#39;setLocalTimeOffsetCallback&#39; function.
//
///Thread Safety
///-------------
// The functions provided by &#39;bdlt::LocalTimeOffset&#39; are *thread-safe* (meaning
// they may be called concurrently from multiple threads), including those that
// set and retrieve the callback function.  In addition, user-supplied callback
// functions must be *thread-safe*.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Basic &#39;bdlt::LocalTimeOffset&#39; Usage
///- - - - - - - - - - - - - - - - - - - - - - -
// This example demonstrates how to use &#39;bdlt::LocalTimeOffset&#39;.
//
// First, obtain the current UTC time - ignoring milliseconds - using
// &#39;bsls::SystemTime&#39; and &#39;bdlt::EpochUtil&#39; (note that clients may prefer
// &#39;bdlt_currenttime&#39;, which is not shown here for dependency reasons):
//..
//  bsls::TimeInterval now = bsls::SystemTime::nowRealtimeClock();
//
//  bdlt::Datetime utc = bdlt::EpochUtil::epoch() +
//                              bdlt::DatetimeInterval(0, 0, 0, now.seconds());
//..
// Then, obtain the local time offset:
//..
//  bsls::TimeInterval localOffset =
//                                 bdlt::LocalTimeOffset::localTimeOffset(utc);
//..
// Next, add the offset to the UTC time to obtain the local time:
//..
//  bsls::TimeInterval local = utc;
//  local.addSeconds(localOffset.seconds());
//..
// Finally, stream the two time values to &#39;stdout&#39;:
//..
//  bsl::cout &lt;&lt; &quot;utc   = &quot; &lt;&lt; utc &lt;&lt; bsl::endl;
//  bsl::cout &lt;&lt; &quot;local = &quot; &lt;&lt; local &lt;&lt; bsl::endl;
//..
// The streaming operator produces output in the following format on &#39;stdout&#39;:
//..
//  utc   = ddMONyyyy_hh:mm::ss.000
//  local = ddMONyyyy_hh:mm::ss.000
//..
//
///Example 2: Using the Local Time Offset Callback
///- - - - - - - - - - - - - - - - - - - - - - - -
// Suppose one has to provide time stamp values that always reflect local time
// for a given location, even when local time transitions into and out of
// daylight saving time.  Further suppose that one must do this quite often
// (e.g., for every record in a high frequency log), so the performance of the
// default method for calculating local time offset is not adequate.  Creation
// and installation of a specialized user-defined callback for local time
// offset allows one to solve this problem.
//
// First, create a utility class that provides a method of type
// &#39;bdlt::LocalTimeOffset::LocalTimeOffsetCallback&#39; that is valid for the
// location of interest (New York) for the period of interest (the year 2013).
//..
//  struct MyLocalTimeOffsetUtilNewYork2013 {
//
//    private:
//      // DATA
//      static int            s_useCount;
//      static bdlt::Datetime s_startOfDaylightSavingTime;  // UTC Datetime
//      static bdlt::Datetime s_resumptionOfStandardTime;   // UTC Datetime
//
//    public:
//      // CLASS METHODS
//      static bsls::TimeInterval localTimeOffset(
//                                          const bdlt::Datetime&amp; utcDatetime);
//          // Return a &#39;bsls::TimeInterval&#39; value representing the difference
//          // between the local time for the &quot;America/New_York&quot; timezone and
//          // UTC time at the specified &#39;utcDatetime&#39;.  The behavior is
//          // undefined unless &#39;2013 == utcDatetime.date().year()&#39;.
//
//      static int useCount();
//          // Return the number of invocations of the &#39;localTimeOffset&#39; since
//          // the start of the process.
//  };
//
//  // DATA
//  int MyLocalTimeOffsetUtilNewYork2013::s_useCount = 0;
//
//  bdlt::Datetime
//  MyLocalTimeOffsetUtilNewYork2013::s_startOfDaylightSavingTime(2013,
//                                                                   3,
//                                                                  10,
//                                                                   7);
//  bdlt::Datetime
//  MyLocalTimeOffsetUtilNewYork2013::s_resumptionOfStandardTime(2013,
//                                                                 11,
//                                                                  3,
//                                                                  6);
//
//  // CLASS METHODS
//  bsls::TimeInterval MyLocalTimeOffsetUtilNewYork2013::localTimeOffset(
//                                           const bdlt::Datetime&amp; utcDatetime)
//  {
//      assert(2013 == utcDatetime.date().year());
//
//      ++s_useCount;
//      int seconds = utcDatetime &lt; s_startOfDaylightSavingTime ? -18000 :
//                    utcDatetime &lt; s_resumptionOfStandardTime  ? -14400 :
//                                                                -18000;
//      return bsls::TimeInterval(seconds, 0);
//  }
//
//  int MyLocalTimeOffsetUtilNewYork2013::useCount()
//  {
//      return s_useCount;
//  }
//..
// Note that the transition times into and out of daylight saving for New York
// are given in UTC.  Also notice that we do not attempt to make the
// &#39;localTimeOffset&#39; method &#39;inline&#39;, since we must take its address to install
// it as the callback.
//
// Then, we install this &#39;localTimeOffset&#39; as the local time offset callback.
//..
//  bdlt::LocalTimeOffset::LocalTimeOffsetCallback defaultCallback =
//                           bdlt::LocalTimeOffset::setLocalTimeOffsetCallback(
//                                          &amp;MyLocalTimeOffsetUtilNewYork2013::
//                                                            localTimeOffset);
//
//  assert(bdlt::LocalTimeOffset::localTimeOffsetDefault == defaultCallback);
//  assert(&amp;MyLocalTimeOffsetUtilNewYork2013::localTimeOffset
//                        == bdlt::LocalTimeOffset::localTimeOffsetCallback());
//..
// Now, we can use the &#39;bdlt::LocalTimeOffset::localTimeOffset&#39; method to
// obtain the local time offsets in New York on several dates of interest.  The
// increasing values from our &#39;useCount&#39; method assures us that the callback we
// defined is indeed being used.
//..
//  assert(0 == MyLocalTimeOffsetUtilNewYork2013::useCount());
//
//  bsls::Types::Int64 offset;
//  bdlt::Datetime     newYearsDay(2013,  1,  1);
//  bdlt::Datetime     independenceDay(2013,  7,  4);
//  bdlt::Datetime     newYearsEve(2013, 12, 31);
//
//  offset = bdlt::LocalTimeOffset::localTimeOffset(newYearsDay).seconds();
//  assert(-5 * 3600 == offset);
//  assert(        1 == MyLocalTimeOffsetUtilNewYork2013::useCount());
//
//  offset = bdlt::LocalTimeOffset::localTimeOffset(independenceDay).seconds();
//  assert(-4 * 3600 == offset);
//  assert(        2 == MyLocalTimeOffsetUtilNewYork2013::useCount());
//
//  offset = bdlt::LocalTimeOffset::localTimeOffset(newYearsEve).seconds();
//  assert(-5 * 3600 == offset);
//  assert(        3 == MyLocalTimeOffsetUtilNewYork2013::useCount());
//..
// Finally, to be neat, we restore the local time offset callback to the
// default callback:
//..
//  bdlt::LocalTimeOffset::setLocalTimeOffsetCallback(defaultCallback);
//  assert(&amp;bdlt::LocalTimeOffset::localTimeOffsetDefault
//                        == bdlt::LocalTimeOffset::localTimeOffsetCallback());
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLT_DATETIME
#include &lt;bdlt_datetime.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMICOPERATIONS
#include &lt;bsls_atomicoperations.h&gt;
#endif

#ifndef INCLUDED_BSLS_TIMEINTERVAL
#include &lt;bsls_timeinterval.h&gt;
#endif

namespace BloombergLP {
namespace bdlt {

                            // =====================
                            // class LocalTimeOffset
                            // =====================

struct LocalTimeOffset {
    // This &#39;struct&#39; provides a namespace for local-time-offset procedures
    // including a configurable global callback mechanism.  The use of these
    // procedures is thread-safe (see &#39;Thread Safety&#39;).

    // TYPES
    typedef bsls::TimeInterval (*LocalTimeOffsetCallback)(
                                                  const Datetime&amp; utcDatetime);
        // &#39;LocalTimeOffsetCallback&#39; is an alias for the type of a function
        // that returns a &#39;bsls::TimeInterval&#39; value representing the
        // difference between local time and UTC time at the specified
        // &#39;utcDatetime&#39;.  This function must be thread-safe in multi-threaded
        // builds.  Note that the installed callback function must have
        // geographic information specifying the local timezone.

  private:
    static bsls::AtomicOperations::AtomicTypes::Pointer
                                  s_localTimeOffsetCallback_p;
                                       // address of local-time-offset callback

  public:
    // CLASS METHODS

                        // ** computation method **

    static bsls::TimeInterval localTimeOffset(const Datetime&amp; utcDatetime);
        // Return a &#39;bsls::TimeInterval&#39; value representing the difference
        // between local time and UTC time at the specified &#39;utcDatetime&#39;.
        // This method uses the currently installed local-time-offset callback
        // mechanism.

                        // ** default callback **

    static bsls::TimeInterval localTimeOffsetDefault(
                                                  const Datetime&amp; utcDatetime);
        // Return a &#39;bsls::TimeInterval&#39; value representing the difference
        // between local time and UTC time at the specified &#39;utcDatetime&#39;.
        // Note that the local time zone is determined by the &#39;TZ&#39; environment
        // variable in the same manner as the &#39;localtime&#39; POSIX function.

                        // ** set callback **

    static LocalTimeOffsetCallback setLocalTimeOffsetCallback(
                                             LocalTimeOffsetCallback callback);
        // Set the specified &#39;callback&#39; as the function to be used to return a
        // &#39;bsls::TimeInterval&#39; value representing the difference between
        // local time and UTC time at a specified UTC date and time.  Return
        // the previously installed &#39;LocalTimeOffsetCallback&#39; function.  The
        // behavior is undefined unless &#39;0 != callback&#39;.

                        // ** get current callback **

    static LocalTimeOffsetCallback localTimeOffsetCallback();
        // Return the currently installed &#39;LocalTimeOffsetCallback&#39; function.
};

// ============================================================================
//                           INLINE DEFINITIONS
// ============================================================================

                        // ** computation method **

inline
bsls::TimeInterval LocalTimeOffset::
                                   localTimeOffset(const Datetime&amp; utcDatetime)
{
    return localTimeOffsetCallback()(utcDatetime);
}

                        // ** set callback **

inline
LocalTimeOffset::LocalTimeOffsetCallback
  LocalTimeOffset::setLocalTimeOffsetCallback(LocalTimeOffsetCallback callback)
{
    BSLS_ASSERT_SAFE(callback);

    LocalTimeOffsetCallback previousCallback = localTimeOffsetCallback();
    bsls::AtomicOperations::setPtrRelease(&amp;s_localTimeOffsetCallback_p,
                                          reinterpret_cast&lt;void *&gt;(callback));
    return previousCallback;
}

                        // ** get current callback **

inline
LocalTimeOffset::LocalTimeOffsetCallback
                                     LocalTimeOffset::localTimeOffsetCallback()
{
    return reinterpret_cast&lt;LocalTimeOffsetCallback&gt;(
          bsls::AtomicOperations::getPtrAcquire(&amp;s_localTimeOffsetCallback_p));
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
