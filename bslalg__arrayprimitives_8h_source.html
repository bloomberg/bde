<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslalg_arrayprimitives.h                                           -*-C++-*-
#ifndef INCLUDED_BSLALG_ARRAYPRIMITIVES
#define INCLUDED_BSLALG_ARRAYPRIMITIVES

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$ $CSID$&quot;)

//@PURPOSE: Provide primitive algorithms that operate on arrays.
//
//@CLASSES:
//  bslalg::ArrayPrimitives: namespace for array algorithms
//
//@SEE_ALSO: bslalg_scalarprimitives, bslalg_typetraits
//
//@DESCRIPTION: This component provides utilities to initialize, move, and
// otherwise perform various primitive manipulations on arrays with a uniform
// interface, but selecting a different implementation according to the various
// traits possessed by the underlying type.  Such primitives are exceptionally
// useful for implementing generic components such as containers.
//
// Several algorithms are provided, with the following short synopsis
// describing the observable behavior and mentioning the relevant traits.  See
// the full function-level contract for detailed description, including
// exception-safety guarantees.  In the description below, &#39;Sc&#39; stands for
// &#39;bslalg::ScalarPrimitives&#39; and &#39;ADP&#39; stands for
// &#39;bslalg::ArrayDestructionPrimitives&#39; (for brevity).  Note that some
// algorithms (e.g., &#39;insert&#39;) are explained in terms of previous algorithms
// (e.g., &#39;destructiveMove&#39;).
//..
//  Algorithm                     Short description of observable behavior
//  ----------------------------  ---------------------------------------------
//  defaultConstruct              &#39;Sc::defaultConstruct&#39; from value for each
//                                element in the target range, or &#39;std::memset&#39;
//                                if type has a trivial default constructor
//
//  uninitializedFillN            &#39;Sc::copyConstruct&#39; from value for each
//                                element in the target range, or &#39;std::memset&#39;
//                                if value is all 0s or 1s bits, and type is
//                                bit-wise copyable
//
//  copyConstruct                 &#39;Sc::copyConstruct&#39; from each element in the
//                                original range to the corresponding element
//                                in the target range, or &#39;std::memcpy&#39; if
//                                value is null and type is bit-wise copyable
//
//  destructiveMove               &#39;Sc::destructiveMove&#39; from each element in
//                                the original range to the corresponding
//                                element in the target range, or &#39;std::memcpy&#39;
//                                if type is bit-wise moveable
//
//  destructiveMoveAndInsert      &#39;Sc::destructiveMove&#39; from each element in
//                                the original range to the corresponding
//                                element in the target range, leaving a hole
//                                in the middle, followed by
//                                &#39;uninitializedFillN&#39; or &#39;copyConstruct&#39; to
//                                fill hole with the appropriate values
//
//  destructiveMoveAndMoveInsert  &#39;destructiveMove&#39; from the original range to
//                                the target range, leaving a hole in the
//                                middle, followed by &#39;destructiveMove&#39;
//                                from second range to fill hole
//
//  insert                        &#39;std::memmove&#39; or &#39;copyConstruct&#39; by some
//                                positive offset to create a hole, followed by
//                                &#39;uninitializedFillN&#39;, &#39;copyConstruct&#39;, or
//                                copy assignment to fill hole with the
//                                appropriate values
//
//  emplace                       &#39;std::memmove&#39; or &#39;copyConstruct&#39; by some
//                                positive offset to create a hole, followed by
//                                in-place construction, &#39;copyConstruct&#39;, or
//                                copy assignment to fill hole with the
//                                appropriate values
//
//  moveInsert                    &#39;destructiveMove&#39; by some positive offset to
//                                create a hole, followed by &#39;destructiveMove&#39;
//                                to fill hole with the appropriate values
//
//  erase                         &#39;ADP::destroy&#39; elements in target range until
//                                specified position, followed by
//                                &#39;destructiveMove&#39; by some negative offset
//                                from the end of the range to fill hole with
//                                the remaining values
//
//  rotate                        &#39;Sc::destructiveMove&#39; to move elements into a
//                                shifting hole along parallel cyclic
//                                permutations, or &#39;std::memmove&#39; for small
//                                rotations if type is bit-wise moveable
//..
// The traits under consideration by this component are:
//..
//  Trait                                         English description
//  --------------------------------------------  -----------------------------
//  bsl::is_trivially_default_constructible       &quot;TYPE has the trivial default
//                                                constructor trait&quot;, or
//                                                &quot;TYPE has a trivial default
//                                                constructor&quot;
//
//  bsl::is_trivially_copyable                    &quot;TYPE has the bit-wise
//                                                copyable trait&quot;, or
//                                                &quot;TYPE is bit-wise copyable&quot;
//
//  bslmf::IsBitwiseMoveable                      &quot;TYPE has the bit-wise
//                                                moveable trait&quot;, or
//                                                &quot;TYPE is bit-wise moveable&quot;
//..
//
///Aliasing
///--------
// There are some aliasing concerns in this component, due to the presence of
// the reference &#39;const TARGET_TYPE&amp; value&#39; argument, which may belong to a
// range that will be modified during the course of the operation.  All such
// aliasing concerns are taken care of properly.  Other aliasing concerns due
// to the copying or a range &#39;[first, last)&#39; are *not* taken care of, since
// their intended use is for range assignments and insertions in standard
// containers, for which the standard explicitly says that &#39;first&#39; and &#39;last&#39;
// shall not be iterators into the container.
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Defining a Vector-Like Type
/// - - - - - - - - - - - - - - - - - - -
// Suppose we want to define a STL-vector-like type.  One requirement is that
// an object of this vector should forward its allocator to its contained
// elements when appropriate.  Another requirement is that the vector should
// take advantage of the optimizations available for certain traits of the
// contained element type.  For example, if the contained element type has the
// &#39;bslalg::TypeTraitBitwiseMoveable&#39; trait, moving an element in a vector can
// be done using &#39;memcpy&#39; instead of copy construction.
//
// We can utilize the class methods provided by &#39;bslalg::ArrayPrimitives&#39; to
// satisfy the above requirements.  Unlike &#39;bslalg::ScalarPrimitives&#39;, which
// operates on a single element, &#39;bslalg::ArrayPrimitives&#39; operates on arrays,
// which will further help simplify our implementation.
//
// First, we create an elided definition of the class template &#39;MyVector&#39;:
//..
//  template &lt;class TYPE&gt;
//  class MyVector {
//      // This class implements a vector of elements of the (template
//      // parameter) &#39;TYPE&#39;, which must be copy constructable.  Note that for
//      // the brevity of the usage example, this class does not provide any
//      // Exception-Safety guarantee.
//
//      // DATA
//      TYPE             *d_array_p;     // pointer to the allocated array
//      int               d_capacity;    // capacity of the allocated array
//      int               d_size;        // number of objects
//      bslma::Allocator *d_allocator_p; // allocator pointer (held, not owned)
//
//    public:
//      // TYPE TRAITS
//      BSLMF_NESTED_TRAIT_DECLARATION(
//          MyVector,
//          BloombergLP::bslmf::IsBitwiseMoveable);
//
//      // CREATORS
//      explicit MyVector(bslma::Allocator *basicAllocator = 0)
//          // Construct a &#39;MyVector&#39; object having a size of 0 and and a
//          // capacity of 0.  Optionally specify a &#39;basicAllocator&#39; used to
//          // supply memory.  If &#39;basicAllocator&#39; is 0, the currently
//          // installed default allocator is used.
//      : d_array_p(0)
//      , d_capacity(0)
//      , d_size(0)
//      , d_allocator_p(bslma::Default::allocator(basicAllocator))
//      {
//      }
//
//      MyVector(const MyVector&amp;   original,
//               bslma::Allocator *basicAllocator = 0);
//          // Create a &#39;MyVector&#39; object having the same value as the
//          // specified &#39;original&#39; object.  Optionally specify a
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//          // 0, the currently installed default allocator is used.
//
//      // ...
//
//      // MANIPULATORS
//      void reserve(int minCapacity);
//          // Change the capacity of this vector to at least the specified
//          // &#39;minCapacity&#39; if it is greater than the vector&#39;s current
//          // capacity.
//
//      void insert(int dstIndex, int numElements, const TYPE&amp; value);
//          // Insert, into this vector, the specified &#39;numElements&#39; of the
//          // specified &#39;value&#39; at the specified &#39;dstIndex&#39;.  The behavior is
//          // undefined unless &#39;0 &lt;= dstIndex &lt;= size()&#39;.
//
//      // ACCESSORS
//      const TYPE&amp; operator[](int position) const
//          // Return a reference providing non-modifiable access to the
//          // element at the specified &#39;position&#39; in this vector.
//      {
//          return d_array_p[position];
//      }
//
//      int size() const
//          // Return the size of this vector.
//      {
//          return d_size;
//      }
//  };
//..
// Then, we implement the copy constructor of &#39;MyVector&#39;:
//..
//  template &lt;class TYPE&gt;
//  MyVector&lt;TYPE&gt;::MyVector(const MyVector&lt;TYPE&gt;&amp;  original,
//                           bslma::Allocator      *basicAllocator)
//  : d_array_p(0)
//  , d_capacity(0)
//  , d_size(0)
//  , d_allocator_p(bslma::Default::allocator(basicAllocator))
//  {
//      reserve(original.d_size);
//..
// Here, we call the &#39;bslalg::ArrayPrimitives::copyConstruct&#39; class method to
// copy each element from &#39;original.d_array_p&#39; to &#39;d_array_p&#39; (When
// appropriate, this class method passes this vector&#39;s allocator to the copy
// constructor of &#39;TYPE&#39; or uses bit-wise copy.):
//..
//      bslalg::ArrayPrimitives::copyConstruct(
//                                        d_array_p,
//                                        original.d_array_p,
//                                        original.d_array_p + original.d_size,
//                                        d_allocator_p);
//
//      d_size = original.d_size;
//  }
//..
// Now, we implement the &#39;reserve&#39; method of &#39;MyVector&#39;:
//..
//  template &lt;class TYPE&gt;
//  void MyVector&lt;TYPE&gt;::reserve(int minCapacity)
//  {
//      if (d_capacity &gt;= minCapacity) return;                        // RETURN
//
//      TYPE *newArrayPtr = static_cast&lt;TYPE*&gt;(d_allocator_p-&gt;allocate(
//      BloombergLP::bslma::Allocator::size_type(minCapacity * sizeof(TYPE))));
//
//      if (d_array_p) {
//..
// Here, we call the &#39;bslalg::ArrayPrimitives::destructiveMove&#39; class method to
// copy each original element from &#39;d_array_p&#39; to &#39;newArrayPtr&#39; and then
// destroy all the original elements (When appropriate, this class method
// passes this vector&#39;s allocator to the copy constructor of &#39;TYPE&#39; or uses
// bit-wise copy.):
//..
//          bslalg::ArrayPrimitives::destructiveMove(newArrayPtr,
//                                                   d_array_p,
//                                                   d_array_p + d_size,
//                                                   d_allocator_p);
//          d_allocator_p-&gt;deallocate(d_array_p);
//      }
//
//      d_array_p = newArrayPtr;
//      d_capacity = minCapacity;
//  }
//..
// Finally, we implement the &#39;insert&#39; method of &#39;MyVector&#39;:
//..
//  template &lt;class TYPE&gt;
//  void
//  MyVector&lt;TYPE&gt;::insert(int dstIndex, int numElements, const TYPE&amp; value)
//  {
//      int newSize = d_size + numElements;
//
//      if (newSize &gt; d_capacity) {
//          int newCapacity = d_capacity == 0 ? 2 : d_capacity * 2;
//          reserve(newCapacity);
//      }
//..
// Here, we call the &#39;bslalg::ArrayPrimitives::insert&#39; class method to first
// move each element after &#39;dstIndex&#39; by &#39;numElements&#39; and then copy construct
// &#39;numElements&#39; of &#39;value&#39; at &#39;dstIndex&#39;.  (When appropriate, this class
// method passes this vector&#39;s allocator to the copy constructor of &#39;TYPE&#39; or
// uses bit-wise copy.):
//..
//      bslalg::ArrayPrimitives::insert(d_array_p + dstIndex,
//                                      d_array_p + d_size,
//                                      value,
//                                      numElements,
//                                      d_allocator_p);
//
//      d_size = newSize;
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLALG_ARRAYDESTRUCTIONPRIMITIVES
#include &lt;bslalg_arraydestructionprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLALG_AUTOARRAYDESTRUCTOR
#include &lt;bslalg_autoarraydestructor.h&gt;
#endif

#ifndef INCLUDED_BSLALG_AUTOARRAYMOVEDESTRUCTOR
#include &lt;bslalg_autoarraymovedestructor.h&gt;
#endif

#ifndef INCLUDED_BSLALG_CONSTRUCTORPROXY
#include &lt;bslalg_constructorproxy.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SCALARDESTRUCTIONPRIMITIVES
#include &lt;bslalg_scalardestructionprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SCALARPRIMITIVES
#include &lt;bslalg_scalarprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLMF_FUNCTIONPOINTERTRAITS
#include &lt;bslmf_functionpointertraits.h&gt;
#endif

#ifndef INCLUDED_BSLMF_INTEGRALCONSTANT
#include &lt;bslmf_integralconstant.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISCONVERTIBLE
#include &lt;bslmf_isconvertible.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISFUNDAMENTAL
#include &lt;bslmf_isfundamental.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISPOINTER
#include &lt;bslmf_ispointer.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISSAME
#include &lt;bslmf_issame.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYCOPYABLE
#include &lt;bslmf_istriviallycopyable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYDEFAULTCONSTRUCTIBLE
#include &lt;bslmf_istriviallydefaultconstructible.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISVOID
#include &lt;bslmf_isvoid.h&gt;
#endif

#ifndef INCLUDED_BSLMF_MATCHANYTYPE
#include &lt;bslmf_matchanytype.h&gt;
#endif

#ifndef INCLUDED_BSLMF_METAINT
#include &lt;bslmf_metaint.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVECONST
#include &lt;bslmf_removeconst.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVECVQ
#include &lt;bslmf_removecvq.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVEPOINTER
#include &lt;bslmf_removepointer.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENTUTIL
#include &lt;bsls_alignmentutil.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_OBJECTBUFFER
#include &lt;bsls_objectbuffer.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSLS_UTIL
#include &lt;bsls_util.h&gt;
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;  // &#39;std::size_t&#39;
#define INCLUDED_CSTDDEF
#endif

#ifndef INCLUDED_CSTRING
#include &lt;cstring&gt;  // &#39;memset&#39;, &#39;memcpy&#39;, &#39;memmove&#39;
#define INCLUDED_CSTRING
#endif

#ifndef INCLUDED_CWCHAR
#include &lt;cwchar&gt;   // &#39;wmemset&#39;
#define INCLUDED_CWCHAR
#endif

#ifndef BDE_DONT_ALLOW_TRANSITIVE_INCLUDES

#ifndef INCLUDED_UTILITY
#include &lt;utility&gt;  // &#39;std::forward&#39;
#define INCLUDED_UTILITY
#endif

#endif // BDE_DONT_ALLOW_TRANSITIVE_INCLUDES

#if defined(BSLS_PLATFORM_CMP_IBM)
# define BSLALG_ARRAYPRIMITIVES_CANNOT_REMOVE_POINTER_FROM_FUNCTION_POINTER
    // xlC has problem removing pointer from function pointer types.
#endif

namespace BloombergLP {

namespace bslalg {

struct ArrayPrimitives_Imp;

                        // ======================
                        // struct ArrayPrimitives
                        // ======================

struct ArrayPrimitives {
    // This &#39;struct&#39; provides a namespace for a suite of independent utility
    // functions that operate on arrays of elements of parameterized type
    // &#39;TARGET_TYPE&#39;.  Depending on the traits of &#39;TARGET_TYPE&#39;, the default
    // and copy constructors, destructor, assignment operators, etc. may not be
    // invoked, optimized away by no-op or bit-wise move or copy.

    // TYPES
    typedef ArrayPrimitives_Imp         Imp;
    typedef std::size_t                 size_type;
    typedef std::ptrdiff_t              difference_type;

    // CLASS METHODS
    template &lt;class TARGET_TYPE, class ALLOCATOR, class FWD_ITER&gt;
    static void copyConstruct(TARGET_TYPE *toBegin,
                              FWD_ITER     fromBegin,
                              FWD_ITER     fromEnd,
                              ALLOCATOR   *allocator);
    template &lt;class TARGET_TYPE, class SOURCE_TYPE, class ALLOCATOR&gt;
    static void copyConstruct(TARGET_TYPE *toBegin,
                              SOURCE_TYPE *fromBegin,
                              SOURCE_TYPE *fromEnd,
                              ALLOCATOR   *allocator);
        // Copy into an uninitialized array of (the template parameter)
        // &#39;TARGET_TYPE&#39; beginning at the specified &#39;toBegin&#39; address, the
        // elements in the array of &#39;TARGET_TYPE&#39; starting at the specified
        // &#39;fromBegin&#39; address and ending immediately before the specified
        // &#39;fromEnd&#39; address.  If the (template parameter) &#39;ALLOCATOR&#39; type is
        // derived from &#39;bslma::Allocator&#39; and &#39;TARGET_TYPE&#39; supports &#39;bslma&#39;
        // allocators, then the specified &#39;allocator&#39; is passed to each
        // invocation of the &#39;TARGET_TYPE&#39; copy constructor.  If a
        // &#39;TARGET_TYPE&#39; constructor throws an exception during the operation,
        // then the destructor is called on any newly-constructed elements,
        // leaving the output array in an uninitialized state.

    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void defaultConstruct(TARGET_TYPE *begin,
                                 size_type    numElements,
                                 ALLOCATOR   *allocator);
        // Call the default constructor on each of the elements of an array of
        // the specified &#39;numElements&#39; of the parameterized &#39;TARGET_TYPE&#39;
        // starting at the specified &#39;begin&#39; address.  If the (template
        // parameter) &#39;ALLOCATOR&#39; type is derived from &#39;bslma::Allocator&#39; and
        // &#39;TARGET_TYPE&#39; supports &#39;bslma&#39; allocators, then the specified
        // &#39;allocator&#39; is passed to each &#39;TARGET_TYPE&#39; default constructor
        // call.  The behavior is undefined unless the output array contains at
        // least &#39;numElements&#39; uninitialized elements after &#39;begin&#39;.  If a
        // &#39;TARGET_TYPE&#39; constructor throws an exception during this operation,
        // then the destructor is called on any newly-constructed elements,
        // leaving the output array in an uninitialized state.

    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void destructiveMove(TARGET_TYPE *toBegin,
                                TARGET_TYPE *fromBegin,
                                TARGET_TYPE *fromEnd,
                                ALLOCATOR   *allocator);
        // Move the elements of the parameterized &#39;TARGET_TYPE&#39; in the array
        // starting at the specified &#39;fromBegin&#39; address and ending immediately
        // before the specified &#39;fromEnd&#39; address into an uninitialized array
        // of &#39;TARGET_TYPE&#39; beginning at the specified &#39;toBegin&#39; address.  On
        // return, the elements in the input range are invalid, i.e., their
        // destructors must not be called after this operation returns.  If the
        // parameterized &#39;ALLOCATOR&#39; type is derived from &#39;bslma::Allocator&#39;
        // and &#39;TARGET_TYPE&#39; supports &#39;bslma&#39; allocators, then the specified
        // &#39;allocator&#39; is used by the objects in their new location.  If an
        // exception is thrown by a &#39;TARGET_TYPE&#39; constructor during the
        // operation, then the output array is left in an uninitialized state
        // and the input elements remain in their original state.

    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void destructiveMoveAndInsert(TARGET_TYPE         *toBegin,
                                         TARGET_TYPE        **fromEndPtr,
                                         TARGET_TYPE         *fromBegin,
                                         TARGET_TYPE         *position,
                                         TARGET_TYPE         *fromEnd,
                                         const TARGET_TYPE&amp;   value,
                                         size_type            numElements,
                                         ALLOCATOR           *allocator);
        // Move the elements of the parameterized &#39;TARGET_TYPE&#39; in the array
        // starting at the specified &#39;fromBegin&#39; address and ending immediately
        // before the specified &#39;fromEnd&#39; address into an uninitialized array
        // of &#39;TARGET_TYPE&#39; at the specified &#39;toBegin&#39; address, inserting at
        // the specified &#39;position&#39; (after translating from &#39;fromBegin&#39; to
        // &#39;toBegin&#39;) the specified &#39;numElements&#39; copies of the specified
        // &#39;value&#39;.  Keep the pointer at the specified &#39;fromEndPtr&#39; address
        // pointing to the first uninitialized element in &#39;[ fromBegin,
        // fromEnd)&#39; as the elements are moved from source to destination.  The
        // behavior is undefined unless &#39;fromBegin &lt;= position &lt;= fromEnd&#39; and
        // the destination array contains at least
        // &#39;(fromEnd - fromBegin) + numElements&#39; uninitialized elements.  If a
        // copy constructor or assignment operator for &#39;TARGET_TYPE&#39; throws an
        // exception, then any elements created in the output array are
        // destroyed and the elements in the range &#39;[ fromBegin, *fromEndPtr )&#39;
        // will have unspecified but valid values.

    template &lt;class TARGET_TYPE, class FWD_ITER, class ALLOCATOR&gt;
    static void destructiveMoveAndInsert(TARGET_TYPE  *toBegin,
                                         TARGET_TYPE **fromEndPtr,
                                         TARGET_TYPE  *fromBegin,
                                         TARGET_TYPE  *position,
                                         TARGET_TYPE  *fromEnd,
                                         FWD_ITER      first,
                                         FWD_ITER      last,
                                         size_type     numElements,
                                         ALLOCATOR    *allocator);
        // Move the elements of the parameterized &#39;TARGET_TYPE&#39; in the array
        // starting at the specified &#39;fromBegin&#39; address and ending immediately
        // before the specified &#39;fromEnd&#39; address into an uninitialized array
        // of &#39;TARGET_TYPE&#39; at the specified &#39;toBegin&#39; address, inserting at
        // the specified &#39;position&#39; (after translating from &#39;fromBegin&#39; to
        // &#39;toBegin&#39;) the specified &#39;numElements&#39; copies of the non-modifiable
        // elements from the range starting at the specified &#39;first&#39; iterator
        // of the parameterized &#39;FWD_ITER&#39; type and ending immediately before
        // the specified &#39;last&#39; iterator.  Keep the pointer at the specified
        // &#39;fromEndPtr&#39; to point to the first uninitialized element in
        // &#39;[fromBegin, fromEnd)&#39; as the elements are moved from source to
        // destination.  The behavior is undefined unless
        // &#39;fromBegin &lt;= position &lt;= fromEnd&#39;, the destination array contains
        // at least &#39;(fromEnd - fromBegin) + numElements&#39; uninitialized
        // elements after &#39;toBegin&#39;, and &#39;numElements&#39; is the distance from
        // &#39;first&#39; to &#39;last&#39;.  If a copy constructor or assignment operator for
        // &#39;TARGET_TYPE&#39; throws an exception, then any elements created in the
        // output array are destroyed and the elements in the range
        // &#39;[ fromBegin, *fromEndPtr )&#39; will have unspecified but valid values.

    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void destructiveMoveAndMoveInsert(TARGET_TYPE  *toBegin,
                                             TARGET_TYPE **fromEndPtr,
                                             TARGET_TYPE **lastPtr,
                                             TARGET_TYPE  *fromBegin,
                                             TARGET_TYPE  *position,
                                             TARGET_TYPE  *fromEnd,
                                             TARGET_TYPE  *first,
                                             TARGET_TYPE  *last,
                                             size_type     numElements,
                                             ALLOCATOR    *allocator);
        // Move the elements of (template parameter) &#39;TARGET_TYPE&#39; in the array
        // starting at the specified &#39;fromBegin&#39; address and ending immediately
        // before the specified &#39;fromEnd&#39; address into an uninitialized array
        // of &#39;TARGET_TYPE&#39; at the specified &#39;toBegin&#39; address, moving into the
        // specified &#39;position&#39; (after translating from &#39;fromBegin&#39; to
        // &#39;toBegin&#39;) the specified &#39;numElements&#39; of the &#39;TARGET_TYPE&#39; from the
        // array starting at the specified &#39;first&#39; address and ending
        // immediately before the specified &#39;last&#39; address.  Keep the pointer
        // at the specified &#39;fromEndPtr&#39; address pointing to the first
        // uninitialized element in &#39;[fromBegin, fromEnd)&#39;, and the pointer at
        // the specified &#39;lastPtr&#39; address pointing to the end of the moved
        // range as the elements from the range &#39;[ first, last)&#39; are moved from
        // source to destination.  The behavior is undefined unless
        // &#39;fromBegin &lt;= position &lt;= fromEnd&#39;, the destination array contains
        // at least &#39;(fromEnd - fromBegin) + numElements&#39; uninitialized
        // elements after &#39;toBegin&#39;, and &#39;numElements&#39; is the distance from
        // &#39;first&#39; to &#39;last&#39;.  If a copy constructor or assignment operator for
        // &#39;TARGET_TYPE&#39; throws an exception, then any elements in
        // &#39;[ *lastPtr, last )&#39; as well as in &#39;[ toBegin, ... )&#39; are destroyed,
        // and the elements in the ranges &#39;[ first, *lastPtr )&#39; and
        // &#39;[ fromBegin, *fromEndPtr )&#39; will have unspecified but valid values.

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES // $var-args=5
    template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
    static void emplace(TARGET_TYPE               *toBegin,
                        TARGET_TYPE               *toEnd,
                        size_type                  numElements,
                        ALLOCATOR                 *allocator,
                        Args&amp;&amp;...                  args);
        // Construct &#39;numElements&#39; elements in-place using the specified &#39;args&#39;
        // as the parameter passed to the constructor of the (template
        // parameter) &#39;TARGET_TYPE&#39; into the array, starting at the &#39;toBegin&#39;
        // address and ending immediately before the specified &#39;toEnd&#39; address,
        // shifting the elements in the array by &#39;numElements&#39; positions
        // towards larger addresses.  The behavior is undefined unless the
        // destination array contains at least &#39;numElements&#39; uninitialized
        // elements after &#39;toEnd&#39;.  If a copy constructor or assignment
        // operator for &#39;TARGET_TYPE&#39; throws an exception, then any elements
        // created after &#39;toEnd&#39; are destroyed and the elements in the range &#39;[
        // toBegin, toEnd )&#39; will have unspecified, but valid, values.
#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Generator command line: sim_cpp11_features.pl bslalg_arrayprimitives.h
    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void emplace(TARGET_TYPE               *toBegin,
                        TARGET_TYPE               *toEnd,
                        size_type                  numElements,
                        ALLOCATOR                 *allocator);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1&gt;
    static void emplace(TARGET_TYPE               *toBegin,
                        TARGET_TYPE               *toEnd,
                        size_type                  numElements,
                        ALLOCATOR                 *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2&gt;
    static void emplace(TARGET_TYPE               *toBegin,
                        TARGET_TYPE               *toEnd,
                        size_type                  numElements,
                        ALLOCATOR                 *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2,
                                                  class Args_3&gt;
    static void emplace(TARGET_TYPE               *toBegin,
                        TARGET_TYPE               *toEnd,
                        size_type                  numElements,
                        ALLOCATOR                 *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2,
                                                  class Args_3,
                                                  class Args_4&gt;
    static void emplace(TARGET_TYPE               *toBegin,
                        TARGET_TYPE               *toEnd,
                        size_type                  numElements,
                        ALLOCATOR                 *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2,
                                                  class Args_3,
                                                  class Args_4,
                                                  class Args_5&gt;
    static void emplace(TARGET_TYPE               *toBegin,
                        TARGET_TYPE               *toEnd,
                        size_type                  numElements,
                        ALLOCATOR                 *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_5) args_5);

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
    static void emplace(TARGET_TYPE               *toBegin,
                        TARGET_TYPE               *toEnd,
                        size_type                  numElements,
                        ALLOCATOR                 *allocator,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args);
// }}} END GENERATED CODE
#endif

    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void erase(TARGET_TYPE *first,
                      TARGET_TYPE *middle,
                      TARGET_TYPE *last,
                      ALLOCATOR   *allocator);
        // Destroy the elements of the parameterized &#39;TARGET_TYPE&#39; in the array
        // starting at the specified &#39;first&#39; address and ending immediately
        // before the specified &#39;middle&#39; address, and move the elements in the
        // array starting at &#39;middle&#39; and ending at the specified &#39;last&#39;
        // address down to the &#39;first&#39; address.  If an assignment throws an
        // exception during this process, all of the elements in the range
        // &#39;[ first, last )&#39; will have unspecified but valid values, and no
        // elements are destroyed.  The behavior is undefined unless
        // &#39;first &lt;= middle &lt;= last&#39;.

    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void insert(TARGET_TYPE        *toBegin,
                       TARGET_TYPE        *toEnd,
                       const TARGET_TYPE&amp;  value,
                       size_type           numElements,
                       ALLOCATOR          *allocator);
        // Insert the specified &#39;numElements&#39; copies of the specified &#39;value&#39;
        // into the array of (template parameter) &#39;TARGET_TYPE&#39; starting at the
        // specified &#39;toBegin&#39; address and ending immediately before the
        // specified &#39;toEnd&#39; address, shifting the elements in the array by
        // &#39;numElements&#39; positions towards larger addresses.  The behavior is
        // undefined unless the destination array contains at least
        // &#39;numElements&#39; uninitialized elements after &#39;toEnd&#39;.  If a copy
        // constructor or assignment operator for &#39;TARGET_TYPE&#39; throws an
        // exception, then any elements created after &#39;toEnd&#39; are destroyed and
        // the elements in the range &#39;[ toBegin, toEnd )&#39; will have
        // unspecified, but valid, values.

    template &lt;class TARGET_TYPE, class FWD_ITER, class ALLOCATOR&gt;
    static void insert(TARGET_TYPE *toBegin,
                       TARGET_TYPE *toEnd,
                       FWD_ITER     fromBegin,
                       FWD_ITER     fromEnd,
                       size_type    numElements,
                       ALLOCATOR   *allocator);
    template &lt;class TARGET_TYPE, class SOURCE_TYPE, class ALLOCATOR&gt;
    static void insert(TARGET_TYPE *toBegin,
                       TARGET_TYPE *toEnd,
                       SOURCE_TYPE *fromBegin,
                       SOURCE_TYPE *fromEnd,
                       size_type    numElements,
                       ALLOCATOR   *allocator);
        // Insert the specified &#39;numElements&#39; from the range starting at the
        // specified &#39;fromBegin&#39; and ending immediately before the specified
        // &#39;fromEnd&#39; iterators of the (template parameter) &#39;FWD_ITER&#39; type (or
        // the (template parameter) &#39;SOURCE_TYPE *&#39;), into the array of
        // elements of the parameterized &#39;TARGET_TYPE&#39; starting at the
        // specified &#39;toBegin&#39; address and ending immediately before the
        // specified &#39;toEnd&#39; address, shifting the elements in the array by
        // &#39;numElements&#39; positions towards larger addresses.  The behavior is
        // undefined unless the destination array contains &#39;numElements&#39;
        // uninitialized elements after &#39;toEnd&#39;, &#39;numElements&#39; is the distance
        // between &#39;fromBegin&#39; and &#39;fromEnd&#39;, and the input array and the
        // destination array do not overlap.  If a copy constructor or
        // assignment operator for &#39;TARGET_TYPE&#39; throws an exception, then any
        // elements created after &#39;toEnd&#39; are destroyed and the elements in the
        // range &#39;[ toBegin, toEnd )&#39; will have unspecified, but valid, values.

    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void moveInsert(TARGET_TYPE  *toBegin,
                           TARGET_TYPE  *toEnd,
                           TARGET_TYPE **fromEndPtr,
                           TARGET_TYPE  *fromBegin,
                           TARGET_TYPE  *fromEnd,
                           size_type     numElements,
                           ALLOCATOR    *allocator);
        // Move the elements of the (template paramaeter) &#39;TARGET_TYPE&#39; in the
        // array starting at the specified &#39;toBegin&#39; address and ending
        // immediately before the specified &#39;toEnd&#39; address by the specified
        // &#39;numElements&#39; positions towards larger addresses, and fill the
        // &#39;numElements&#39; at the &#39;toBegin&#39; address by moving the elements from
        // the array starting at the specified &#39;fromBegin&#39; and ending
        // immediately before the specified &#39;fromEnd&#39; address.  Keep the
        // iterator at the specified &#39;fromEndPtr&#39; address pointing to the end
        // of the range as the elements from &#39;[ fromBegin, fromEnd )&#39; are moved
        // from source to destination.  The behavior is undefined unless the
        // destination array contains &#39;numElements&#39; uninitialized elements
        // after &#39;toEnd&#39;, &#39;numElements&#39; is the distance from &#39;fromBegin&#39; to
        // &#39;fromEnd&#39;, and the input and destination arrays do not overlap.  If
        // a copy constructor or assignment operator for &#39;TARGET_TYPE&#39; throws
        // an exception, then any elements created after &#39;toEnd&#39; are destroyed,
        // the elements in the ranges &#39;[ toBegin, toEnd)&#39; and
        // &#39;[ fromBegin, *fromEndPtr )&#39; will have unspecified, but valid,
        // values, and the elements in &#39;[ *fromEndPtr, fromEnd )&#39; will be
        // destroyed.

    template &lt;class TARGET_TYPE&gt;
    static void rotate(TARGET_TYPE *first,
                       TARGET_TYPE *middle,
                       TARGET_TYPE *last);
        // Move the elements of the parameterized &#39;TARGET_TYPE&#39; in the array
        // starting at the specified &#39;first&#39; address and ending immediately
        // before the specified &#39;middle&#39; address to the array of the same
        // length ending at the specified &#39;last&#39; address (and thus starting at
        // the &#39;last - (middle - first)&#39; address), and move the elements
        // previously in the array starting at &#39;middle&#39; and ending at &#39;last&#39;
        // down to the &#39;first&#39; address.  If the assignment operator throws an
        // exception during this process, all of the elements in
        // &#39;[ first, last )&#39; will have unspecified, but valid, values.  The
        // behavior is undefined unless &#39;first &lt;= middle &lt;= last&#39;.

    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void uninitializedFillN(TARGET_TYPE        *begin,
                                   size_type           numElements,
                                   const TARGET_TYPE&amp;  value,
                                   ALLOCATOR          *allocator);
        // Construct copies of the specified &#39;value&#39; of the parameterized type
        // &#39;TARGET_TYPE&#39; into the uninitialized array containing the specified
        // &#39;numElements&#39; starting at the specified &#39;begin&#39; address.  If the
        // (template parameter) &#39;ALLOCATOR&#39; type is derived from
        // &#39;bslma::Allocator&#39; and &#39;TARGET_TYPE&#39; supports &#39;bslma&#39; allocators,
        // then the specified &#39;allocator&#39; is passed to each invocation of the
        // &#39;TARGET_TYPE&#39; copy constructor.  The behavior is undefined unless
        // the output array contains at least &#39;numElements&#39; uninitialized
        // elements after &#39;begin&#39;.  If a &#39;TARGET_TYPE&#39; constructor throws an
        // exception during the operation, then the destructor is called on any
        // newly-constructed elements, leaving the output array in an
        // uninitialized state.  Note that the argument order was chosen to
        // maintain compatibility with the existing &#39;bslalg&#39;.
};

                     // ==========================
                     // struct ArrayPrimitives_Imp
                     // ==========================

struct ArrayPrimitives_Imp {
    // This &#39;struct&#39; provides a namespace for a suite of independent utility
    // functions that operate on arrays of elements of a parameterized
    // &#39;TARGET_TYPE&#39;.  These utility functions are only for the purpose of
    // implementing those in the &#39;ArrayPrimitives&#39; utility.  For brevity, we do
    // not repeat the main contracts here, but instead refer to the
    // corresponding contract in the &#39;ArrayPrimitive&#39; utility.

  private:
    // PRIVATE METHODS
    template &lt;class TARGET_TYPE&gt;
    static void assign(TARGET_TYPE *srcStart,
                       TARGET_TYPE *srcEnd,
                       TARGET_TYPE&amp; value);
        // Copy-assign the specified &#39;value&#39; to the range starting at the
        // specified &#39;srcStart&#39; and ending immediately before the specified
        // &#39;srcEnd&#39;.  Note that the (template parameter) &#39;TARGET_TYPE&#39; must be
        // copy-assignable.  Also note that &#39;value&#39; should not be an element in
        // the range &#39;[srcStart, srcEnd)&#39;.

    template &lt;class TARGET_TYPE&gt;
    static void reverseAssign(TARGET_TYPE *dest,
                              TARGET_TYPE *srcStart,
                              TARGET_TYPE *srcEnd);
        // Copy-assign the elements in reverse order from the range starting at
        // the specified &#39;srcStart&#39; and ending immediately before the specified
        // &#39;srcEnd&#39; to the range starting at the specified &#39;dest&#39; and ending
        // immediately before &#39;dest + (srcEnd - srcStart)&#39;.  The behavior is
        // undefined unless each element is both range &#39;[srcStart, srcEnd)&#39; and
        // range &#39;[dest, dest + (srcEnd - srcStart))&#39; is valid.  Note that the
        // (template parameter) &#39;TARGET_TYPE&#39; must be copy-assignable.  Also
        // note that this method is intended to support range assignment when
        // the two ranges may be overlapped, and &#39;srcStart &lt;= dest&#39;.

  public:
    // TYPES
    typedef ArrayPrimitives::size_type       size_type;
    typedef ArrayPrimitives::difference_type difference_type;

    enum {
        // These constants are used in the overloads below, when the last
        // argument is of type &#39;bslmf::MetaInt&lt;N&gt; *&#39;, indicating that
        // &#39;TARGET_TYPE&#39; has the traits for which the enumerator equal to &#39;N&#39;
        // is named.

        e_IS_ITERATOR_TO_FUNCTION_POINTER  = 6,
        e_IS_POINTER_TO_POINTER            = 5,
        e_IS_FUNDAMENTAL_OR_POINTER        = 4,
        e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS  = 3,
        e_BITWISE_COPYABLE_TRAITS          = 2,
        e_BITWISE_MOVEABLE_TRAITS          = 1,
        e_NIL_TRAITS                       = 0
    };

    enum {
        // Number of bytes for which a stack-allocated buffer can be
        // comfortably obtained to optimize bitwise moves.

        k_INPLACE_BUFFER_SIZE = 16 * bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT
    };

    // CLASS METHODS
    static void bitwiseFillN(char      *begin,
                             size_type  numBytesInitialized,
                             size_type  numBytes);
        // Fill the specified &#39;numBytes&#39; in the array starting at the specified
        // &#39;begin&#39; address, as if by bit-wise copying the specified
        // &#39;numBytesInitialized&#39; at every offset that is a multiple of
        // &#39;numBytesInitialized&#39; within the output array.  The behavior is
        // undefined unless &#39;numBytesInitialized &lt;= numBytes&#39;.  Note that
        // &#39;numBytes&#39; usually is, but does not have to be, a multiple of
        // &#39;numBytesInitialized&#39;.

    static void uninitializedFillN(
                      bool                                        *begin,
                      bool                                         value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                      char                                        *begin,
                      char                                         value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                      unsigned char                               *begin,
                      unsigned char                                value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                      signed char                                 *begin,
                      signed char                                  value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                      wchar_t                                     *begin,
                      wchar_t                                      value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                      short                                       *begin,
                      short                                        value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                      unsigned short                              *begin,
                      unsigned short                               value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                      int                                         *begin,
                      int                                          value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                      unsigned int                                *begin,
                      unsigned int                                 value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                      long                                        *begin,
                      long                                         value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                      unsigned long                               *begin,
                      unsigned long                                value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                      bsls::Types::Int64                          *begin,
                      bsls::Types::Int64                           value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                      bsls::Types::Uint64                         *begin,
                      bsls::Types::Uint64                          value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                      float                                       *begin,
                      float                                        value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                      double                                      *begin,
                      double                                       value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                      long double                                 *begin,
                      long double                                  value,
                      size_type                                    numElements,
                      void                                        * = 0,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; * = 0);
    static void uninitializedFillN(
                     void                                        **begin,
                     void                                         *value,
                     size_type                                     numElements,
                     void                                         * = 0,
                     bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt;  * = 0);
    static void uninitializedFillN(
                     const void                                  **begin,
                     const void                                   *value,
                     size_type                                     numElements,
                     void                                         * = 0,
                     bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt;  * = 0);
    template &lt;class TARGET_TYPE&gt;
    static void uninitializedFillN(
                     TARGET_TYPE                                 **begin,
                     TARGET_TYPE                                  *value,
                     size_type                                     numElements,
                     void                                         * = 0,
                     bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt;  * = 0);
    template &lt;class TARGET_TYPE&gt;
    static void uninitializedFillN(
                     const TARGET_TYPE                           **begin,
                     const TARGET_TYPE                            *value,
                     size_type                                     numElements,
                     void                                         * = 0,
                     bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt;  * = 0);
    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void uninitializedFillN(
                        TARGET_TYPE                               *begin,
                        const TARGET_TYPE&amp;                         value,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *);
    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void uninitializedFillN(TARGET_TYPE                  *begin,
                                   const TARGET_TYPE&amp;            value,
                                   size_type                     numElements,
                                   ALLOCATOR                    *allocator,
                                   bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *);
        // Copy the specified &#39;value&#39; of the parameterized &#39;TARGET_TYPE&#39; into
        // every of the specified &#39;numElements&#39; in the array starting at the
        // specified &#39;begin&#39; address.  Pass the specified &#39;allocator&#39; to the
        // copy constructor if appropriate.  Note that if &#39;TARGET_TYPE&#39; is
        // bit-wise copyable or is not based on &#39;bslma::Allocator&#39;, &#39;allocator&#39;
        // is ignored.  The last argument is for removing overload ambiguities
        // and is not used.

    template &lt;class TARGET_TYPE, class FWD_ITER, class ALLOCATOR&gt;
    static void copyConstruct(TARGET_TYPE                *toBegin,
                              FWD_ITER                    fromBegin,
                              FWD_ITER                    fromEnd,
                              ALLOCATOR                  *allocator,
                              bslmf::MetaInt&lt;e_IS_POINTER_TO_POINTER&gt; *);
    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void copyConstruct(
                          TARGET_TYPE                               *toBegin,
                          const TARGET_TYPE                         *fromBegin,
                          const TARGET_TYPE                         *fromEnd,
                          ALLOCATOR                                 *allocator,
                          bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *);
    template &lt;class TARGET_TYPE, class FWD_ITER, class ALLOCATOR&gt;
    static void copyConstruct(TARGET_TYPE                           *toBegin,
                              FWD_ITER                               fromBegin,
                              FWD_ITER                               fromEnd,
                              ALLOCATOR                             *allocator,
                          bslmf::MetaInt&lt;e_IS_ITERATOR_TO_FUNCTION_POINTER&gt; *);
    template &lt;class FWD_ITER, class ALLOCATOR&gt;
    static void copyConstruct(void                                 **toBegin,
                              FWD_ITER                               fromBegin,
                              FWD_ITER                               fromEnd,
                              ALLOCATOR                             *allocator,
                          bslmf::MetaInt&lt;e_IS_ITERATOR_TO_FUNCTION_POINTER&gt; *);
    template &lt;class TARGET_TYPE, class FWD_ITER, class ALLOCATOR&gt;
    static void copyConstruct(TARGET_TYPE                  *toBegin,
                              FWD_ITER                      fromBegin,
                              FWD_ITER                      fromEnd,
                              ALLOCATOR                    *allocator,
                              bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *);
        // These functions follow the &#39;copyConstruct&#39; contract.  If the
        // (template parameter) &#39;ALLOCATOR&#39; type is based on &#39;bslma::Allocator&#39;
        // and the &#39;TARGET_TYPE&#39; constructors take an allocator argument, then
        // pass the specified &#39;allocator&#39; to the copy constructor.  The
        // behavior is undefined unless the output array has length at least
        // the distance from the specified &#39;fromBegin&#39; to the specified
        // &#39;fromEnd&#39;.  Note that if &#39;FWD_ITER&#39; is the &#39;TARGET_TYPE *&#39; pointer
        // type and &#39;TARGET_TYPE&#39; is bit-wise copyable, then this operation is
        // simply &#39;memcpy&#39;.  The last argument is for removing overload
        // ambiguities and is not used.

    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void defaultConstruct(
                TARGET_TYPE                                       *begin,
                size_type                                          numElements,
                ALLOCATOR                                         *allocator,
                bslmf::MetaInt&lt;e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS&gt; *);
    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void defaultConstruct(
                        TARGET_TYPE                               *begin,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *);
    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void defaultConstruct(TARGET_TYPE                  *begin,
                                 size_type                     numElements,
                                 ALLOCATOR                    *allocator,
                                 bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *);
        // Use the default constructor of the (template parameter)
        // &#39;TARGET_TYPE&#39; (or &#39;memset&#39; to 0 if &#39;TARGET_TYPE&#39; has a trivial
        // default constructor) on each element of the array starting at the
        // specified &#39;begin&#39; address and ending immediately before the &#39;end&#39;
        // address.  Pass the specified &#39;allocator&#39; to the default constructor
        // if appropriate.  The last argument is for traits overloading
        // resolution only and its value is ignored.

    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void destructiveMove(
                          TARGET_TYPE                               *toBegin,
                          TARGET_TYPE                               *fromBegin,
                          TARGET_TYPE                               *fromEnd,
                          ALLOCATOR                                 *allocator,
                          bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *);
    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void destructiveMove(TARGET_TYPE                  *toBegin,
                                TARGET_TYPE                  *fromBegin,
                                TARGET_TYPE                  *fromEnd,
                                ALLOCATOR                    *allocator,
                                bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *);
        // These functions follow the &#39;destructiveMove&#39; contract.  Note that
        // both arrays cannot overlap (one contains only initialized elements
        // and the other only uninitialized elements), and that if
        // &#39;TARGET_TYPE&#39; is bit-wise moveable, then this operation is simply
        // &#39;memcpy&#39;.  The last argument is for removing overload ambiguities
        // and is not used.

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
    template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *,
                        Args&amp;&amp;...                                args);
    template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *,
                        Args&amp;&amp;...                                args);
    template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
    static void emplace(TARGET_TYPE                  *toBegin,
                        TARGET_TYPE                  *toEnd,
                        size_type                     numElements,
                        ALLOCATOR                    *allocator,
                        bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *,
                        Args&amp;&amp;...                     args);
        // Construct &#39;numElements&#39; elements in-place using the specified &#39;args&#39;
        // as the parameter passed to the constructor of the (template
        // parameter) &#39;TARGET_TYPE&#39; into the array, starting at the &#39;toBegin&#39;
        // address and ending immediately before the specified &#39;toEnd&#39; address,
        // shifting the elements in the array by &#39;numElements&#39; positions
        // towards larger addresses.  Optionally specifiy an integral type to
        // distinguish among various traits that the &#39;TARGET_TYPE&#39; has.  The
        // behavior is undefined unless the destination array contains at least
        // &#39;numElements&#39; uninitialized elements after &#39;toEnd&#39;.  If a copy
        // constructor or assignment operator for &#39;TARGET_TYPE&#39; throws an
        // exception, then any elements created after &#39;toEnd&#39; are destroyed and
        // the elements in the range &#39;[ toBegin, toEnd )&#39; will have
        // unspecified, but valid, values.
#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Generator command line: sim_cpp11_features.pl bslalg_arrayprimitives.h
    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2,
                                                  class Args_3&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2,
                                                  class Args_3,
                                                  class Args_4&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2,
                                                  class Args_3,
                                                  class Args_4,
                                                  class Args_5&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_5) args_5);

    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2,
                                                  class Args_3&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2,
                                                  class Args_3,
                                                  class Args_4&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2,
                                                  class Args_3,
                                                  class Args_4,
                                                  class Args_5&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_5) args_5);

    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void emplace(TARGET_TYPE                  *toBegin,
                        TARGET_TYPE                  *toEnd,
                        size_type                     numElements,
                        ALLOCATOR                    *allocator,
                        bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1&gt;
    static void emplace(TARGET_TYPE                  *toBegin,
                        TARGET_TYPE                  *toEnd,
                        size_type                     numElements,
                        ALLOCATOR                    *allocator,
                        bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2&gt;
    static void emplace(TARGET_TYPE                  *toBegin,
                        TARGET_TYPE                  *toEnd,
                        size_type                     numElements,
                        ALLOCATOR                    *allocator,
                        bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2,
                                                  class Args_3&gt;
    static void emplace(TARGET_TYPE                  *toBegin,
                        TARGET_TYPE                  *toEnd,
                        size_type                     numElements,
                        ALLOCATOR                    *allocator,
                        bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2,
                                                  class Args_3,
                                                  class Args_4&gt;
    static void emplace(TARGET_TYPE                  *toBegin,
                        TARGET_TYPE                  *toEnd,
                        size_type                     numElements,
                        ALLOCATOR                    *allocator,
                        bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4);

    template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                                  class Args_2,
                                                  class Args_3,
                                                  class Args_4,
                                                  class Args_5&gt;
    static void emplace(TARGET_TYPE                  *toBegin,
                        TARGET_TYPE                  *toEnd,
                        size_type                     numElements,
                        ALLOCATOR                    *allocator,
                        bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_5) args_5);

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args);
    template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
    static void emplace(TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args);
    template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
    static void emplace(TARGET_TYPE                  *toBegin,
                        TARGET_TYPE                  *toEnd,
                        size_type                     numElements,
                        ALLOCATOR                    *allocator,
                        bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args);
// }}} END GENERATED CODE
#endif

    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void erase(TARGET_TYPE                               *first,
                      TARGET_TYPE                               *middle,
                      TARGET_TYPE                               *last,
                      ALLOCATOR                                 *allocator,
                      bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *);
    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void erase(TARGET_TYPE                *first,
                      TARGET_TYPE                *middle,
                      TARGET_TYPE                *last,
                      ALLOCATOR                  *allocator,
                      bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *);
        // These functions follow the &#39;erase&#39; contract.  Note that if (template
        // parameter) &#39;TARGET_TYPE&#39; is bit-wise moveable, then this operation
        // can be implemented by first bit-wise moving the elements in
        // &#39;[middle, last)&#39; towards first, and destroying
        // &#39;[ last - (middle - first), last)&#39;; note that this cannot throw
        // exceptions.

    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void insert(TARGET_TYPE                               *toBegin,
                       TARGET_TYPE                               *toEnd,
                       const TARGET_TYPE&amp;                         value,
                       size_type                                  numElements,
                       ALLOCATOR                                 *allocator,
                       bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *);
    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void insert(TARGET_TYPE                               *toBegin,
                       TARGET_TYPE                               *toEnd,
                       const TARGET_TYPE&amp;                         value,
                       size_type                                  numElements,
                       ALLOCATOR                                 *allocator,
                       bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *);
    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void insert(TARGET_TYPE                  *toBegin,
                       TARGET_TYPE                  *toEnd,
                       const TARGET_TYPE&amp;            value,
                       size_type                     numElements,
                       ALLOCATOR                    *allocator,
                       bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *);
        // These functions follow the &#39;insert&#39; contract.  Note that if
        // &#39;TARGET_TYPE&#39; is bit-wise copyable, then this operation is simply
        // &#39;memmove&#39; followed by &#39;bitwiseFillN&#39;.  If &#39;TARGET_TYPE&#39; is bit-wise
        // moveable, then this operation can still be optimized using &#39;memmove&#39;
        // followed by repeated assignments, but a guard needs to be set up.
        // The last argument is for removing overload ambiguities and is not
        // used.

    template &lt;class TARGET_TYPE, class FWD_ITER, class ALLOCATOR&gt;
    static void insert(TARGET_TYPE                             *toBegin,
                       TARGET_TYPE                             *toEnd,
                       FWD_ITER                                 fromBegin,
                       FWD_ITER                                 fromEnd,
                       size_type                                numElements,
                       ALLOCATOR                               *allocator,
                       bslmf::MetaInt&lt;e_IS_POINTER_TO_POINTER&gt; *);
    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void insert(TARGET_TYPE                               *toBegin,
                       TARGET_TYPE                               *toEnd,
                       const TARGET_TYPE                         *fromBegin,
                       const TARGET_TYPE                         *fromEnd,
                       size_type                                  numElements,
                       ALLOCATOR                                 *allocator,
                       bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *);
    template &lt;class TARGET_TYPE, class FWD_ITER, class ALLOCATOR&gt;
    static void insert(TARGET_TYPE                               *toBegin,
                       TARGET_TYPE                               *toEnd,
                       FWD_ITER                                   fromBegin,
                       FWD_ITER                                   fromEnd,
                       size_type                                  numElements,
                       ALLOCATOR                                 *allocator,
                       bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *);
    template &lt;class FWD_ITER, class ALLOCATOR&gt;
    static void insert(void                                   **toBegin,
                       void                                   **toEnd,
                       FWD_ITER                                 fromBegin,
                       FWD_ITER                                 fromEnd,
                       size_type                                numElements,
                       ALLOCATOR                               *allocator,
                       bslmf::MetaInt&lt;e_IS_ITERATOR_TO_FUNCTION_POINTER&gt; *);
    template &lt;class TARGET_TYPE, class FWD_ITER, class ALLOCATOR&gt;
    static void insert(TARGET_TYPE                  *toBegin,
                       TARGET_TYPE                  *toEnd,
                       FWD_ITER                      fromBegin,
                       FWD_ITER                      fromEnd,
                       size_type                     numElements,
                       ALLOCATOR                    *allocator,
                       bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *);
        // These functions follow the &#39;insert&#39; contract.  Note that if
        // &#39;TARGET_TYPE&#39; is bit-wise copyable and &#39;FWD_ITER&#39; is convertible to
        // &#39;const TARGET_TYPE *&#39;, then this operation is simply &#39;memmove&#39;
        // followed by &#39;memcopy&#39;.  If &#39;TARGET_TYPE&#39; is bit-wise moveable and
        // &#39;FWD_ITER&#39; is convertible to &#39;const TARGET_TYPE *&#39;, then this
        // operation can still be optimized using &#39;memmove&#39; followed by
        // repeated copies.  The last argument is for removing overload
        // ambiguities and is not used.

    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void moveInsert(
                       TARGET_TYPE                                *toBegin,
                       TARGET_TYPE                                *toEnd,
                       TARGET_TYPE                               **lastPtr,
                       TARGET_TYPE                                *first,
                       TARGET_TYPE                                *last,
                       size_type                                   numElements,
                       ALLOCATOR                                  *allocator,
                       bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt;  *);
    template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
    static void moveInsert(TARGET_TYPE                   *toBegin,
                           TARGET_TYPE                   *toEnd,
                           TARGET_TYPE                  **lastPtr,
                           TARGET_TYPE                   *first,
                           TARGET_TYPE                   *last,
                           size_type                      numElements,
                           ALLOCATOR                     *allocator,
                           bslmf::MetaInt&lt;e_NIL_TRAITS&gt;  *);
        // These functions follow the &#39;moveInsert&#39; contract.  Note that if
        // &#39;TARGET_TYPE&#39; is at least bit-wise moveable, then this operation is
        // simply &#39;memmove&#39; followed by &#39;memcpy&#39;.

    template &lt;class TARGET_TYPE&gt;
    static void rotate(TARGET_TYPE                               *begin,
                       TARGET_TYPE                               *middle,
                       TARGET_TYPE                               *end,
                       bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *);
    template &lt;class TARGET_TYPE&gt;
    static void rotate(TARGET_TYPE                  *begin,
                       TARGET_TYPE                  *middle,
                       TARGET_TYPE                  *end,
                       bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *);
        // These functions follow the &#39;rotate&#39; contract, but the first overload
        // is optimized when the parameterized &#39;TARGET_TYPE&#39; is bit-wise
        // moveable.  The last argument is for removing overload ambiguities
        // and is not used.  Note that if &#39;TARGET_TYPE&#39; is bit-wise moveable,
        // the &#39;rotate(char*, char*, char*)&#39; can be used, enabling to take the
        // whole implementation out-of-line.

    // &#39;bitwise&#39; METHODS
    static void bitwiseRotate(char *begin, char *middle, char *end);
        // This function follows the &#39;rotate&#39; contract, but by using bit-wise
        // moves on the underlying &#39;char&#39; array.

    static void bitwiseRotateBackward(char *begin, char *middle, char *end);
        // Move the characters in the array starting at the specified &#39;first&#39;
        // address and ending immediately before the specified &#39;middle&#39; address
        // to the array of the same length ending at the specified &#39;last&#39;
        // address (and thus starting at the &#39;last - (middle - first)&#39;
        // address), and move the elements previously in the array starting at
        // &#39;middle&#39; and ending at &#39;last&#39; down to the &#39;first&#39; address.  The
        // behavior is undefined unless
        // &#39;middle - begin &lt;= k_INPLACE_BUFFER_SIZE&#39;.

    static void bitwiseRotateForward(char *begin, char *middle, char *end);
        // Move the characters in the array starting at the specified &#39;first&#39;
        // address and ending immediately before the specified &#39;middle&#39; address
        // to the array of the same length ending at the specified &#39;last&#39;
        // address (and thus starting at the &#39;last - (middle - first)&#39;
        // address), and move the elements previously in the array starting at
        // &#39;middle&#39; and ending at &#39;last&#39; down to the &#39;first&#39; address.  The
        // behavior is undefined unless
        // &#39;end - middle &lt;= k_INPLACE_BUFFER_SIZE&#39;.

    static void bitwiseSwapRanges(char *begin, char *middle, char *end);
        // Swap the characters in the array starting at the specified &#39;first&#39;
        // address and ending immediately before the specified &#39;middle&#39; address
        // with the array of the same length starting at the &#39;middle&#39; address
        // and ending at the specified &#39;last&#39; address.  The behavior is
        // undefined unless &#39;middle - begin == end - middle&#39;.

    template &lt;class FORWARD_ITERATOR&gt;
    static bool isInvalidRange(FORWARD_ITERATOR begin, FORWARD_ITERATOR end);
    template &lt;class TARGET_TYPE&gt;
    static bool isInvalidRange(TARGET_TYPE *begin, TARGET_TYPE *end);
        // Return &#39;true&#39; if the specified &#39;begin&#39; and the specified &#39;end&#39;
        // provably do not form a valid semi-open range, &#39;[begin, end)&#39;, and
        // &#39;false&#39; otherwise.  Note that &#39;begin == null == end&#39; produces a
        // valid range, and any other use of the null pointer value will return
        // &#39;true&#39;.  Also note that this function is intended to support
        // testing, primarily through assertions, so will return &#39;true&#39; unless
        // it can *prove* that the passed range is invalid.  Currently, this
        // function can prove invalid ranges only for pointers, although should
        // also encompass generic random access iterators in a future update,
        // where iterator tag types are levelized below &#39;bslalg&#39;.
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================
// IMPLEMENTATION NOTES: Specializations of &#39;uninitializedFillN&#39; for most
// fundamental types are not templates nor inline, and thus can be found in the
// &#39;.cpp&#39; file.

                   // =====================================
                   // struct ArrayPrimitives_CanBitwiseCopy
                   // =====================================

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct ArrayPrimitives_CanBitwiseCopy {

    typedef typename bsl::remove_const&lt;FROM_TYPE&gt;::type FromType;
    typedef typename bsl::remove_const&lt;TO_TYPE  &gt;::type ToType;
        // We do not worry about volatile qualifiers as volatile types should
        // not be bitwise copyable.  We do allow &#39;TO_TYPE&#39; to be &#39;const&#39; to
        // support cases like range construction.

    enum {
        k_VALUE = bsl::is_same&lt;FromType, ToType&gt;::value &amp;&amp;
                  bsl::is_trivially_copyable&lt;TO_TYPE&gt;::value
    };

    static const bool value = k_VALUE;
    typedef bsl::integral_constant&lt;bool, k_VALUE&gt; type;
};

                       // ----------------------
                       // struct ArrayPrimitives
                       // ----------------------

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives::uninitializedFillN(TARGET_TYPE        *begin,
                                         size_type           numElements,
                                         const TARGET_TYPE&amp;  value,
                                         ALLOCATOR          *allocator)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    enum {
        // We provide specialized overloads of &#39;uninitializedFillN&#39; for
        // fundamental and pointer types.  However, function pointers can have
        // extern &quot;C&quot; linkage and SunPro doesn&#39;t match them properly with the
        // pointer template function overload in &#39;Imp&#39;, so we resort to the
        // general case for those.

        k_IS_FUNCTION_POINTER = bslmf::IsFunctionPointer&lt;TARGET_TYPE&gt;::value,
        k_IS_FUNDAMENTAL      = bslmf::IsFundamental&lt;TARGET_TYPE&gt;::value,
        k_IS_POINTER          = bslmf::IsPointer&lt;TARGET_TYPE&gt;::value,

        k_IS_FUNDAMENTAL_OR_POINTER = k_IS_FUNDAMENTAL ||
                                     (k_IS_POINTER &amp;&amp; !k_IS_FUNCTION_POINTER),

        k_IS_BITWISECOPYABLE  = bsl::is_trivially_copyable&lt;TARGET_TYPE&gt;::value,

        k_VALUE =
                 k_IS_FUNDAMENTAL_OR_POINTER ? Imp::e_IS_FUNDAMENTAL_OR_POINTER
               : k_IS_BITWISECOPYABLE        ? Imp::e_BITWISE_COPYABLE_TRAITS
               :                               Imp::e_NIL_TRAITS
    };
    ArrayPrimitives_Imp::uninitializedFillN(begin,
                                            value,
                                            numElements,
                                            allocator,
                                            (bslmf::MetaInt&lt;k_VALUE&gt;*)0);
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class FWD_ITER&gt;
inline
void ArrayPrimitives::copyConstruct(TARGET_TYPE *toBegin,
                                    FWD_ITER     fromBegin,
                                    FWD_ITER     fromEnd,
                                    ALLOCATOR   *allocator)
{
    BSLS_ASSERT_SAFE(toBegin || fromBegin == fromEnd);

    BSLMF_ASSERT(!bsl::is_pointer&lt;FWD_ITER&gt;::value);
    typedef typename FWD_ITER::value_type FwdTarget;
        // Overload resolution will handle the case where &#39;FWD_ITER&#39; is a raw
        // pointer, so we need handle only user-defined iterators.  As &#39;bslalg&#39;
        // is levelized below &#39;bslstl&#39; we cannot use &#39;iterator_traits&#39;, but
        // rely on the same property as &#39;iterator_traits&#39; that this typedef
        // must be defined for any standard-conforming iterator, unless the
        // iterator explicitly specialized the &#39;std::iterator_traits&#39; template.
        // In practice, iterators always prefer to provide the member typedef
        // than specialize the traits as it is a much simpler implementation,
        // so this assumption is good enough.
        //
        // Also note that as we know that &#39;FWD_ITER&#39; is not a pointer, then we
        // cannot take advantage of bitwise copying as we do not have pointers
        // to pass to the &#39;memcpy&#39; describing the whole range.  It is not worth
        // the effort to try to bitwise copy one element at a time.

    typedef typename bsl::remove_pointer&lt;TARGET_TYPE&gt;::type RemovePtrTarget;
        // We want to detect the special case of copying function pointers to
        // &#39;void *&#39; or &#39;const void *&#39; pointers.

    enum {
        k_ITER_TO_FUNC_PTRS   = bslmf::IsFunctionPointer&lt;FwdTarget&gt;::value,
        k_TARGET_IS_VOID_PTR  = bsl::is_pointer&lt;TARGET_TYPE&gt;::value &amp;&amp;
                                bsl::is_void&lt;RemovePtrTarget&gt;::value,

        k_VALUE = k_ITER_TO_FUNC_PTRS &amp;&amp; k_TARGET_IS_VOID_PTR
                ? Imp::e_IS_ITERATOR_TO_FUNCTION_POINTER
                : Imp::e_NIL_TRAITS
    };

    ArrayPrimitives_Imp::copyConstruct(toBegin,
                                       fromBegin,
                                       fromEnd,
                                       allocator,
                                       (bslmf::MetaInt&lt;k_VALUE&gt;*)0);
}

template &lt;class TARGET_TYPE, class SOURCE_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives::copyConstruct(TARGET_TYPE *toBegin,
                                    SOURCE_TYPE *fromBegin,
                                    SOURCE_TYPE *fromEnd,
                                    ALLOCATOR   *allocator)
{
    BSLS_ASSERT_SAFE(toBegin || fromBegin == fromEnd);

    enum {
        k_ARE_PTRS_TO_PTRS = bslmf::IsPointer&lt;TARGET_TYPE&gt;::value &amp;&amp;
                             bslmf::IsPointer&lt;SOURCE_TYPE&gt;::value,
        k_IS_BITWISECOPYABLE  =
               ArrayPrimitives_CanBitwiseCopy&lt;SOURCE_TYPE, TARGET_TYPE&gt;::value,
        k_VALUE = k_ARE_PTRS_TO_PTRS   ? Imp::e_IS_POINTER_TO_POINTER
                : k_IS_BITWISECOPYABLE ? Imp::e_BITWISE_COPYABLE_TRAITS
                :                        Imp::e_NIL_TRAITS
    };

    ArrayPrimitives_Imp::copyConstruct(toBegin,
                                       fromBegin,
                                       fromEnd,
                                       allocator,
                                       (bslmf::MetaInt&lt;k_VALUE&gt;*)0);
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives::defaultConstruct(TARGET_TYPE *begin,
                                       size_type    numElements,
                                       ALLOCATOR   *allocator)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    enum {
        k_VALUE = bsl::is_trivially_default_constructible&lt;TARGET_TYPE&gt;::value
              ? Imp::e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS
              : bsl::is_trivially_copyable&lt;TARGET_TYPE&gt;::value
                  ? Imp::e_BITWISE_COPYABLE_TRAITS
                  : Imp::e_NIL_TRAITS
    };
    ArrayPrimitives_Imp::defaultConstruct(begin,
                                          numElements,
                                          allocator,
                                          (bslmf::MetaInt&lt;k_VALUE&gt;*)0);
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives::destructiveMove(TARGET_TYPE *toBegin,
                                      TARGET_TYPE *fromBegin,
                                      TARGET_TYPE *fromEnd,
                                      ALLOCATOR   *allocator)
{
    BSLS_ASSERT_SAFE(toBegin || fromBegin == fromEnd);
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(fromBegin,
                                                          fromEnd));

    enum {
        k_VALUE = bslmf::IsBitwiseMoveable&lt;TARGET_TYPE&gt;::value
              ? Imp::e_BITWISE_MOVEABLE_TRAITS
              : Imp::e_NIL_TRAITS
    };
    ArrayPrimitives_Imp::destructiveMove(toBegin,
                                         fromBegin,
                                         fromEnd,
                                         allocator,
                                         (bslmf::MetaInt&lt;k_VALUE&gt;*)0);
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
void ArrayPrimitives::destructiveMoveAndInsert(
                                              TARGET_TYPE         *toBegin,
                                              TARGET_TYPE        **fromEndPtr,
                                              TARGET_TYPE         *fromBegin,
                                              TARGET_TYPE         *position,
                                              TARGET_TYPE         *fromEnd,
                                              const TARGET_TYPE&amp;   value,
                                              size_type            numElements,
                                              ALLOCATOR           *allocator)
{
    // Key to the transformation diagrams:
    //..
    //  A...H   original contents of &#39;[fromBegin, fromEnd)&#39;  (&quot;source&quot;)
    //  v...v   copies of &#39;value&#39;                            (&quot;input&quot;)
    //  ; ...   contents of &#39;[toBegin, toEnd)&#39;               (&quot;destination&quot;)
    //  ..:..   position of &#39;fromEndPtr&#39; in the input
    //  _____   uninitialized array elements
    //  [...]   part of array protected by an exception guard object
    //..

    *fromEndPtr = fromEnd;

    // Note: Construct copies of &#39;value&#39; first in case &#39;value&#39; is a reference
    // in the input range, which would be invalidated by any of the following
    // moves.
    //
    //..
    //  Transformation: ABCDEFGH: ; _____________[]
    //               =&gt; ABCDEFGH: ; ____[vvvvv]____
    //..

    TARGET_TYPE *toPositionBegin = toBegin + (position - fromBegin);
    uninitializedFillN(toPositionBegin, numElements, value, allocator);

    TARGET_TYPE *toPositionEnd   = toPositionBegin + numElements;
    AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toPositionBegin,
                                           toPositionEnd);

    //..
    //  Transformation: ABCDEFGH: ; ____[vvvvv]____
    //               =&gt; ABCD:____ ; ____[vvvvvEFGH]
    //..

    destructiveMove(toPositionEnd,
                    position,
                    fromEnd,
                    allocator);

    *fromEndPtr = position;  // shorten input range after partial destruction
    guard.moveEnd(fromEnd - position);  // toEnd

    //..
    //  Transformation: ABCD:____ ; ____[vvvvvEFGH]
    //               =&gt; :________ ; ABCDvvvvvEFGH[]
    //..

    destructiveMove(toBegin,
                    fromBegin,
                    position,
                    allocator);

    *fromEndPtr = fromBegin;  // empty input range after final destruction
    guard.release();
}

template &lt;class TARGET_TYPE, class FWD_ITER, class ALLOCATOR&gt;
void ArrayPrimitives::destructiveMoveAndInsert(TARGET_TYPE  *toBegin,
                                               TARGET_TYPE **fromEndPtr,
                                               TARGET_TYPE  *fromBegin,
                                               TARGET_TYPE  *position,
                                               TARGET_TYPE  *fromEnd,
                                               FWD_ITER      first,
                                               FWD_ITER      last,
                                               size_type     numElements,
                                               ALLOCATOR    *allocator)
{
    // Key to the transformation diagrams:
    //..
    //  A...H   original contents of &#39;[fromBegin, fromEnd)&#39;  (&quot;source&quot;)
    //  t...z   original contents of &#39;[first, last)&#39;         (&quot;input&quot;)
    //  ; ...   contents of &#39;[toBegin, toEnd)&#39;               (&quot;destination&quot;)
    //  ..:..   position of &#39;fromEndPtr&#39; in the input
    //  _____   uninitialized array elements
    //  [...]   part of array protected by an exception guard object
    //..

    *fromEndPtr = fromEnd;

    // Note: Construct copies of &#39;value&#39; first in case &#39;value&#39; is a reference
    // in the input range, which would be invalidated by any of the following
    // moves:
    //..
    //  Transformation: ABCDEFGH: ; _________[]____
    //               =&gt; ABCDEFGH: ; ____[tuvxy]____
    //..

    TARGET_TYPE *toPositionBegin = toBegin + (position - fromBegin);
    copyConstruct(toPositionBegin, first, last, allocator);

    TARGET_TYPE *toPositionEnd   = toPositionBegin + numElements;
    AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toPositionBegin,
                                           toPositionEnd);

    //..
    //  Transformation: ABCDEFGH: ; ____[tuvxy]____
    //               =&gt; ABCD:____ ; ____[tuvxyEFGH]
    //..

    destructiveMove(toPositionEnd,
                    position,
                    fromEnd,
                    allocator);

    *fromEndPtr = position;  // shorten input range after partial destruction
    guard.moveEnd(fromEnd - position);  // toEnd

    //..
    //  Transformation: ABCD:____ ; ____[tuvxyEFGH]
    //               =&gt; :________ ; ABCDtuvxyEFGH[]
    //..

    destructiveMove(toBegin,
                    fromBegin,
                    position,
                    allocator);

    *fromEndPtr = fromBegin;  // empty input range after final destruction
    guard.release();
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
void ArrayPrimitives::destructiveMoveAndMoveInsert(TARGET_TYPE  *toBegin,
                                                   TARGET_TYPE **fromEndPtr,
                                                   TARGET_TYPE **lastPtr,
                                                   TARGET_TYPE  *fromBegin,
                                                   TARGET_TYPE  *position,
                                                   TARGET_TYPE  *fromEnd,
                                                   TARGET_TYPE  *first,
                                                   TARGET_TYPE  *last,
                                                   size_type     numElements,
                                                   ALLOCATOR    *allocator)
{
    // Key to the transformation diagrams:
    //..
    //  A...H   original contents of &#39;[fromBegin, fromEnd)&#39;  (&quot;source&quot;)
    //  t...z   original contents of &#39;[first, last)&#39;         (&quot;input&quot;)
    //  ; ...   contents of &#39;[toBegin, toEnd)&#39;               (&quot;destination&quot;)
    //  ..:..   position of &#39;fromEndPtr&#39; in the input
    //  _____   uninitialized array elements
    //  [...]   part of array protected by an exception guard object
    //..

    *lastPtr = last;
    *fromEndPtr = fromEnd;

    //..
    //  Transformation: ABCDEFGH: ; _____________[]
    //               =&gt; ABCD:____ ; _________[EFGH]
    //..

    TARGET_TYPE *toPositionBegin = toBegin + (position - fromBegin);
    TARGET_TYPE *toPositionEnd   = toPositionBegin + numElements;
    destructiveMove(toPositionEnd,
                    position,
                    fromEnd,
                    allocator);

    *fromEndPtr = position;  // shorten input range after partial destruction

    AutoArrayDestructor&lt;TARGET_TYPE&gt;
                                   guard(toPositionEnd,
                                         toPositionEnd + (fromEnd - position));

    //..
    //  Transformation: ABCD:____ ; _________[EFGH]
    //               =&gt; ABCD:____ ; _____[tuvwEFGH]
    //..

    destructiveMove(toPositionBegin, first, last, allocator);

    *lastPtr = first;
    guard.moveBegin(-static_cast&lt;difference_type&gt;(numElements));

    //..
    //  Transformation: ABCD:____ ; ____[tuvwEFGH]
    //               =&gt; :________ ; ABCDtuvwEFGH[]
    //..

    destructiveMove(toBegin,
                    fromBegin,
                    position,
                    allocator);

    *fromEndPtr = fromBegin;  // empty input range after final destruction
    guard.release();
}

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
inline
void ArrayPrimitives::emplace(TARGET_TYPE               *toBegin,
                              TARGET_TYPE               *toEnd,
                              size_type                  numElements,
                              ALLOCATOR                 *allocator,
                              Args&amp;&amp;...                  args)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));

    if (0 == numElements) {
        return;                                                       // RETURN
    }

    enum {
        k_VALUE = bsl::is_trivially_copyable&lt;TARGET_TYPE&gt;::value
              ? Imp::e_BITWISE_COPYABLE_TRAITS
              : bslmf::IsBitwiseMoveable&lt;TARGET_TYPE&gt;::value
                  ? Imp::e_BITWISE_MOVEABLE_TRAITS
                  : Imp::e_NIL_TRAITS
    };

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;k_VALUE&gt;*)0,
                                 BSLS_COMPILERFEATURES_FORWARD(Args,args)...);
}
#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Generator command line: sim_cpp11_features.pl bslalg_arrayprimitives.h
template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives::emplace(TARGET_TYPE               *toBegin,
                              TARGET_TYPE               *toEnd,
                              size_type                  numElements,
                              ALLOCATOR                 *allocator)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));

    if (0 == numElements) {
        return;
    }

    enum {
        k_VALUE = bsl::is_trivially_copyable&lt;TARGET_TYPE&gt;::value
              ? Imp::e_BITWISE_COPYABLE_TRAITS
              : bslmf::IsBitwiseMoveable&lt;TARGET_TYPE&gt;::value
                  ? Imp::e_BITWISE_MOVEABLE_TRAITS
                  : Imp::e_NIL_TRAITS
    };

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;k_VALUE&gt;*)0);
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1&gt;
inline
void ArrayPrimitives::emplace(TARGET_TYPE               *toBegin,
                              TARGET_TYPE               *toEnd,
                              size_type                  numElements,
                              ALLOCATOR                 *allocator,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));

    if (0 == numElements) {
        return;
    }

    enum {
        k_VALUE = bsl::is_trivially_copyable&lt;TARGET_TYPE&gt;::value
              ? Imp::e_BITWISE_COPYABLE_TRAITS
              : bslmf::IsBitwiseMoveable&lt;TARGET_TYPE&gt;::value
                  ? Imp::e_BITWISE_MOVEABLE_TRAITS
                  : Imp::e_NIL_TRAITS
    };

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;k_VALUE&gt;*)0,
                                 BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1));
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2&gt;
inline
void ArrayPrimitives::emplace(TARGET_TYPE               *toBegin,
                              TARGET_TYPE               *toEnd,
                              size_type                  numElements,
                              ALLOCATOR                 *allocator,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));

    if (0 == numElements) {
        return;
    }

    enum {
        k_VALUE = bsl::is_trivially_copyable&lt;TARGET_TYPE&gt;::value
              ? Imp::e_BITWISE_COPYABLE_TRAITS
              : bslmf::IsBitwiseMoveable&lt;TARGET_TYPE&gt;::value
                  ? Imp::e_BITWISE_MOVEABLE_TRAITS
                  : Imp::e_NIL_TRAITS
    };

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;k_VALUE&gt;*)0,
                                 BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2));
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2,
                                              class Args_3&gt;
inline
void ArrayPrimitives::emplace(TARGET_TYPE               *toBegin,
                              TARGET_TYPE               *toEnd,
                              size_type                  numElements,
                              ALLOCATOR                 *allocator,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));

    if (0 == numElements) {
        return;
    }

    enum {
        k_VALUE = bsl::is_trivially_copyable&lt;TARGET_TYPE&gt;::value
              ? Imp::e_BITWISE_COPYABLE_TRAITS
              : bslmf::IsBitwiseMoveable&lt;TARGET_TYPE&gt;::value
                  ? Imp::e_BITWISE_MOVEABLE_TRAITS
                  : Imp::e_NIL_TRAITS
    };

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;k_VALUE&gt;*)0,
                                 BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3));
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2,
                                              class Args_3,
                                              class Args_4&gt;
inline
void ArrayPrimitives::emplace(TARGET_TYPE               *toBegin,
                              TARGET_TYPE               *toEnd,
                              size_type                  numElements,
                              ALLOCATOR                 *allocator,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));

    if (0 == numElements) {
        return;
    }

    enum {
        k_VALUE = bsl::is_trivially_copyable&lt;TARGET_TYPE&gt;::value
              ? Imp::e_BITWISE_COPYABLE_TRAITS
              : bslmf::IsBitwiseMoveable&lt;TARGET_TYPE&gt;::value
                  ? Imp::e_BITWISE_MOVEABLE_TRAITS
                  : Imp::e_NIL_TRAITS
    };

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;k_VALUE&gt;*)0,
                                 BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_4,args_4));
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2,
                                              class Args_3,
                                              class Args_4,
                                              class Args_5&gt;
inline
void ArrayPrimitives::emplace(TARGET_TYPE               *toBegin,
                              TARGET_TYPE               *toEnd,
                              size_type                  numElements,
                              ALLOCATOR                 *allocator,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_5) args_5)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));

    if (0 == numElements) {
        return;
    }

    enum {
        k_VALUE = bsl::is_trivially_copyable&lt;TARGET_TYPE&gt;::value
              ? Imp::e_BITWISE_COPYABLE_TRAITS
              : bslmf::IsBitwiseMoveable&lt;TARGET_TYPE&gt;::value
                  ? Imp::e_BITWISE_MOVEABLE_TRAITS
                  : Imp::e_NIL_TRAITS
    };

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;k_VALUE&gt;*)0,
                                 BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_4,args_4),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_5,args_5));
}

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
inline
void ArrayPrimitives::emplace(TARGET_TYPE               *toBegin,
                              TARGET_TYPE               *toEnd,
                              size_type                  numElements,
                              ALLOCATOR                 *allocator,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));

    if (0 == numElements) {
        return;
    }

    enum {
        k_VALUE = bsl::is_trivially_copyable&lt;TARGET_TYPE&gt;::value
              ? Imp::e_BITWISE_COPYABLE_TRAITS
              : bslmf::IsBitwiseMoveable&lt;TARGET_TYPE&gt;::value
                  ? Imp::e_BITWISE_MOVEABLE_TRAITS
                  : Imp::e_NIL_TRAITS
    };

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;k_VALUE&gt;*)0,
                                 BSLS_COMPILERFEATURES_FORWARD(Args,args)...);
}
// }}} END GENERATED CODE
#endif

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives::erase(TARGET_TYPE *first,
                            TARGET_TYPE *middle,
                            TARGET_TYPE *last,
                            ALLOCATOR   *allocator)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(first,
                                                          middle));
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(middle,
                                                          last));

    if (first == middle) { // erasing empty range O(1) versus O(N): Do not
                           // remove!
        return;                                                       // RETURN
    }

    enum {
        k_VALUE = bslmf::IsBitwiseMoveable&lt;TARGET_TYPE&gt;::value
              ? Imp::e_BITWISE_MOVEABLE_TRAITS
              : Imp::e_NIL_TRAITS
    };
    ArrayPrimitives_Imp::erase(first,
                               middle,
                               last,
                               allocator,
                               (bslmf::MetaInt&lt;k_VALUE&gt;*)0);
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives::insert(TARGET_TYPE        *toBegin,
                             TARGET_TYPE        *toEnd,
                             const TARGET_TYPE&amp;  value,
                             size_type           numElements,
                             ALLOCATOR          *allocator)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin, toEnd));
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    if (0 == numElements) {
        return;                                                       // RETURN
    }

    enum {
        k_VALUE = bsl::is_trivially_copyable&lt;TARGET_TYPE&gt;::value
              ? Imp::e_BITWISE_COPYABLE_TRAITS
              : bslmf::IsBitwiseMoveable&lt;TARGET_TYPE&gt;::value
                  ? Imp::e_BITWISE_MOVEABLE_TRAITS
                  : Imp::e_NIL_TRAITS
    };
    ArrayPrimitives_Imp::insert(toBegin,
                                toEnd,
                                value,
                                numElements,
                                allocator,
                                (bslmf::MetaInt&lt;k_VALUE&gt;*)0);
}

template &lt;class TARGET_TYPE, class FWD_ITER, class ALLOCATOR&gt;
inline
void ArrayPrimitives::insert(TARGET_TYPE *toBegin,
                             TARGET_TYPE *toEnd,
                             FWD_ITER     fromBegin,
                             FWD_ITER     fromEnd,
                             size_type    numElements,
                             ALLOCATOR   *allocator)
{
    if (0 == numElements) {
        return;                                                       // RETURN
    }

    BSLMF_ASSERT(!bsl::is_pointer&lt;FWD_ITER&gt;::value);
    typedef typename FWD_ITER::value_type FwdTarget;
        // Overload resolution will handle the case where &#39;FWD_ITER&#39; is a raw
        // pointer, so we need handle only user-defined iterators.  As &#39;bslalg&#39;
        // is levelized below &#39;bslstl&#39; we cannot use &#39;iterator_traits&#39;, but
        // rely on the same property as &#39;iterator_traits&#39; that this typedef
        // must be defined for any standard-conforming iterator, unless the
        // iterator explicitly specialized the &#39;std::iterator_traits&#39; template.
        // In practice, iterators always prefer to provide the member typedef
        // than specialize the traits as it is a much simpler implementation,
        // so this assumption is good enough.
        //
        // Also note that as we know that &#39;FWD_ITER&#39; is not a pointer, then we
        // cannot take advantage of bitwise copying as we do not have pointers
        // to pass to the &#39;memcpy&#39; describing the whole range.  It is not worth
        // the effort to try to bitwise copy one element at a time.

    typedef typename bsl::remove_pointer&lt;TARGET_TYPE&gt;::type RemovePtrTarget;
        // We want to detect the special case of copying function pointers to
        // &#39;void *&#39; or &#39;const void *&#39; pointers.

    enum {
        k_ITER_TO_FUNC_PTRS  = bslmf::IsFunctionPointer&lt;FwdTarget&gt;::value,
        k_TARGET_IS_VOID_PTR = bsl::is_pointer&lt;TARGET_TYPE&gt;::value &amp;&amp;
                               bsl::is_void&lt;RemovePtrTarget&gt;::value,

        k_VALUE = k_ITER_TO_FUNC_PTRS &amp;&amp; k_TARGET_IS_VOID_PTR
                ? Imp::e_IS_ITERATOR_TO_FUNCTION_POINTER
                : Imp::e_NIL_TRAITS
    };
    ArrayPrimitives_Imp::insert(toBegin,
                                toEnd,
                                fromBegin,
                                fromEnd,
                                numElements,
                                allocator,
                                (bslmf::MetaInt&lt;k_VALUE&gt;*)0);
}

template &lt;class TARGET_TYPE, class SOURCE_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives::insert(TARGET_TYPE *toBegin,
                             TARGET_TYPE *toEnd,
                             SOURCE_TYPE *fromBegin,
                             SOURCE_TYPE *fromEnd,
                             size_type    numElements,
                             ALLOCATOR   *allocator)
{
    if (0 == numElements) {
        return;                                                       // RETURN
    }

    enum {
        k_ARE_PTRS_TO_PTRS   = bslmf::IsPointer&lt;TARGET_TYPE&gt;::value &amp;&amp;
                               bslmf::IsPointer&lt;SOURCE_TYPE&gt;::value,
        k_IS_BITWISEMOVEABLE = bslmf::IsBitwiseMoveable&lt;TARGET_TYPE&gt;::value,
        k_IS_BITWISECOPYABLE =
               ArrayPrimitives_CanBitwiseCopy&lt;SOURCE_TYPE, TARGET_TYPE&gt;::value,
        k_VALUE = k_ARE_PTRS_TO_PTRS   ? Imp::e_IS_POINTER_TO_POINTER
                : k_IS_BITWISECOPYABLE ? Imp::e_BITWISE_COPYABLE_TRAITS
                : k_IS_BITWISEMOVEABLE ? Imp::e_BITWISE_MOVEABLE_TRAITS
                : Imp::e_NIL_TRAITS
    };
    ArrayPrimitives_Imp::insert(toBegin,
                                toEnd,
                                fromBegin,
                                fromEnd,
                                numElements,
                                allocator,
                                (bslmf::MetaInt&lt;k_VALUE&gt;*)0);
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives::moveInsert(TARGET_TYPE  *toBegin,
                                 TARGET_TYPE  *toEnd,
                                 TARGET_TYPE **fromEndPtr,
                                 TARGET_TYPE  *fromBegin,
                                 TARGET_TYPE  *fromEnd,
                                 size_type     numElements,
                                 ALLOCATOR    *allocator)
{
    enum {
        k_VALUE = bslmf::IsBitwiseMoveable&lt;TARGET_TYPE&gt;::value
              ? Imp::e_BITWISE_MOVEABLE_TRAITS
              : Imp::e_NIL_TRAITS
    };
    ArrayPrimitives_Imp::moveInsert(toBegin,
                                    toEnd,
                                    fromEndPtr,
                                    fromBegin,
                                    fromEnd,
                                    numElements,
                                    allocator,
                                    (bslmf::MetaInt&lt;k_VALUE&gt;*)0);
}

template &lt;class TARGET_TYPE&gt;
inline
void ArrayPrimitives::rotate(TARGET_TYPE *first,
                             TARGET_TYPE *middle,
                             TARGET_TYPE *last)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(first,
                                                          middle));
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(middle,
                                                          last));

    enum {
        k_VALUE = bslmf::IsBitwiseMoveable&lt;TARGET_TYPE&gt;::value
              ? Imp::e_BITWISE_MOVEABLE_TRAITS
              : Imp::e_NIL_TRAITS
    };
    ArrayPrimitives_Imp::rotate(first,
                                middle,
                                last,
                                (bslmf::MetaInt&lt;k_VALUE&gt;*)0);
}

                     // --------------------------
                     // struct ArrayPrimitives_Imp
                     // --------------------------

// CLASS METHODS
template &lt;class TARGET_TYPE&gt;
inline
void ArrayPrimitives_Imp::assign(TARGET_TYPE *srcStart,
                                 TARGET_TYPE *srcEnd,
                                 TARGET_TYPE&amp; value)
{
    for ( ; srcStart != srcEnd; ++srcStart) {
        *srcStart = value;
    }
}

template &lt;class FORWARD_ITERATOR&gt;
inline
bool ArrayPrimitives_Imp::isInvalidRange(FORWARD_ITERATOR,
                                         FORWARD_ITERATOR)
{
    // Ideally would dispatch on random_access_iterator_tag to support
    // generalized random access iterators, but we are constrained by &#39;bsl&#39;
    // levelization to not depend on &#39;bsl_iterator.h&#39;.  As the intent is to
    // detect invalid ranges in assertions, the conservative choice is to
    // return &#39;false&#39; always.

    return false;
}

template &lt;class TARGET_TYPE&gt;
inline
bool ArrayPrimitives_Imp::isInvalidRange(TARGET_TYPE *begin,
                                         TARGET_TYPE *end)
{
    return !begin != !end || begin &gt; end;
}

template &lt;class TARGET_TYPE&gt;
inline
void ArrayPrimitives_Imp::reverseAssign(TARGET_TYPE *dest,
                                        TARGET_TYPE *srcStart,
                                        TARGET_TYPE *srcEnd)
{
    TARGET_TYPE *destEnd = srcEnd - srcStart + dest;
    while (srcStart != srcEnd) {
        *--destEnd = *--srcEnd;
    }
}


                   // *** &#39;uninitializedFillN&#39; overloads: ***

inline
void ArrayPrimitives_Imp::uninitializedFillN(
                      bool                                        *begin,
                      bool                                         value,
                      size_type                                    numElements,
                      void                                        *,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    std::memset(reinterpret_cast&lt;char *&gt;(begin),      // odd, why not &#39;void *&#39;?
                static_cast&lt;char&gt;(value),
                numElements);
}

inline
void ArrayPrimitives_Imp::uninitializedFillN(
                      char                                        *begin,
                      char                                         value,
                      size_type                                    numElements,
                      void                                        *,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    std::memset(begin, value, numElements);
}

inline
void ArrayPrimitives_Imp::uninitializedFillN(
                      unsigned char                               *begin,
                      unsigned char                                value,
                      size_type                                    numElements,
                      void                                        *,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    std::memset(begin, value, numElements);
}

inline
void ArrayPrimitives_Imp::uninitializedFillN(
                      signed char                                 *begin,
                      signed char                                  value,
                      size_type                                    numElements,
                      void                                        *,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    std::memset(begin, value, numElements);
}

inline
void ArrayPrimitives_Imp::uninitializedFillN(
                      wchar_t                                     *begin,
                      wchar_t                                      value,
                      size_type                                    numElements,
                      void                                        *,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    std::wmemset(begin, value, numElements);
}

inline
void ArrayPrimitives_Imp::uninitializedFillN(
                      unsigned short                              *begin,
                      unsigned short                               value,
                      size_type                                    numElements,
                      void                                        *,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    uninitializedFillN(reinterpret_cast&lt;short *&gt;(begin),
                       static_cast&lt;short&gt;(value),
                       numElements,
                       (void *)0,
                       (bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)0);
}

inline
void ArrayPrimitives_Imp::uninitializedFillN(
                      unsigned int                                *begin,
                      unsigned int                                 value,
                      size_type                                    numElements,
                      void                                        *,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    uninitializedFillN(reinterpret_cast&lt;int *&gt;(begin),
                       static_cast&lt;int&gt;(value),
                       numElements,
                       (void *)0,
                       (bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)0);
}

inline
void ArrayPrimitives_Imp::uninitializedFillN(
                      long                                        *begin,
                      long                                         value,
                      size_type                                    numElements,
                      void                                        *,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

#if defined(BSLS_PLATFORM_CPU_64_BIT) &amp;&amp; !defined(BSLS_PLATFORM_OS_WINDOWS)
    uninitializedFillN(reinterpret_cast&lt;bsls::Types::Int64 *&gt;(begin),
                       static_cast&lt;bsls::Types::Int64&gt;(value),
                       numElements);
#else
    uninitializedFillN(reinterpret_cast&lt;int *&gt;(begin),
                       static_cast&lt;int&gt;(value),
                       numElements,
                       (void *)0,
                       (bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)0);
#endif
}

inline
void ArrayPrimitives_Imp::uninitializedFillN(
                      unsigned long                               *begin,
                      unsigned long                                value,
                      size_type                                    numElements,
                      void                                        *,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

#if defined(BSLS_PLATFORM_CPU_64_BIT) &amp;&amp; !defined(BSLS_PLATFORM_OS_WINDOWS)
    uninitializedFillN(reinterpret_cast&lt;bsls::Types::Int64 *&gt;(begin),
                       static_cast&lt;bsls::Types::Int64&gt;(value),
                       numElements,
                       (void *)0,
                       (bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt;*)0);
#else
    uninitializedFillN(reinterpret_cast&lt;int *&gt;(begin),
                       static_cast&lt;int&gt;(value),
                       numElements,
                       (void *)0,
                       (bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)0);
#endif
}

inline
void ArrayPrimitives_Imp::uninitializedFillN(
                      bsls::Types::Uint64                         *begin,
                      bsls::Types::Uint64                          value,
                      size_type                                    numElements,
                      void                                        *,
                      bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    uninitializedFillN(reinterpret_cast&lt;bsls::Types::Int64 *&gt;(begin),
                       value,
                       numElements,
                       (void *)0,
                       (bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)0);
}

template &lt;class TARGET_TYPE&gt;
inline
void ArrayPrimitives_Imp::uninitializedFillN(
                     TARGET_TYPE                                 **begin,
                     TARGET_TYPE                                  *value,
                     size_type                                     numElements,
                     void                                         *,
                     bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt;  *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    // Note: &#39;const&#39;-correctness is respected because the next overload picks
    // up the &#39;const TARGET_TYPE&#39; and will be a better match.  Note that we
    // cannot cast to &#39;const void **&#39; (one would have to add &#39;const&#39; at every
    // level, not just the innermost; i.e., &#39;const void *const *&#39; would be
    // correct, &#39;const void **&#39; is not [C++ Standard, 4.4 Qualification
    // conversions]).

    uninitializedFillN(reinterpret_cast&lt;void **&gt;(begin),
                       static_cast&lt;void *&gt;(value),
                       numElements,
                       (void *)0,
                       (bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)0);
}

template &lt;class TARGET_TYPE&gt;
inline
void ArrayPrimitives_Imp::uninitializedFillN(
                     const TARGET_TYPE                           **begin,
                     const TARGET_TYPE                            *value,
                     size_type                                     numElements,
                     void                                         *,
                     bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt;  *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    // While it seems that this overload is subsumed by the previous template,
    // SunPro does not detect it.

    uninitializedFillN(reinterpret_cast&lt;const void **&gt;(begin),
                       static_cast&lt;const void *&gt;(value),
                       numElements,
                       (void *)0,
                       (bslmf::MetaInt&lt;e_IS_FUNDAMENTAL_OR_POINTER&gt; *)0);
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
void ArrayPrimitives_Imp::uninitializedFillN(
                        TARGET_TYPE                               *begin,
                        const TARGET_TYPE&amp;                         value,
                        size_type                                  numElements,
                        ALLOCATOR                                 *,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    if (0 == numElements) {
        return;                                                       // RETURN
    }

    // Important sub-case: When value is identically (bit-wise) 0, such as
    // happens for default-constructed values of a type that has a trivial
    // default constructor, or even the same byte pattern repeated over
    // &#39;sizeof value&#39; times, we can use &#39;memset.

    size_type index = 0;
    const char *valueBuffer =
                    reinterpret_cast&lt;const char *&gt;(BSLS_UTIL_ADDRESSOF(value));
    while (++index &lt; sizeof(TARGET_TYPE)) {
        if (valueBuffer[index] != valueBuffer[0]) {
            break;
        }
    }

    if (index == sizeof value) {
        std::memset(begin, valueBuffer[0], sizeof(TARGET_TYPE) * numElements);
    } else {
        std::memcpy(begin, valueBuffer, sizeof(TARGET_TYPE));
        bitwiseFillN(reinterpret_cast&lt;char *&gt;(begin),
                     sizeof(TARGET_TYPE),
                     sizeof(TARGET_TYPE) * numElements);
    }
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
void ArrayPrimitives_Imp::uninitializedFillN(
                                     TARGET_TYPE                  *begin,
                                     const TARGET_TYPE&amp;            value,
                                     size_type                     numElements,
                                     ALLOCATOR                    *allocator,
                                     bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    if (0 == numElements) {
        return;                                                       // RETURN
    }
    AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(begin, begin);

    TARGET_TYPE *end = begin + numElements;
    do {
        ScalarPrimitives::copyConstruct(begin, value, allocator);
        begin = guard.moveEnd(1);
    } while (begin != end);
    guard.release();
}

                    // *** &#39;copyConstruct&#39; overloads: ***

template &lt;class TARGET_TYPE, class FWD_ITER, class ALLOCATOR&gt;
inline
void ArrayPrimitives_Imp::copyConstruct(
                            TARGET_TYPE                             *toBegin,
                            FWD_ITER                                 fromBegin,
                            FWD_ITER                                 fromEnd,
                            ALLOCATOR                               *allocator,
                            bslmf::MetaInt&lt;e_IS_POINTER_TO_POINTER&gt; *)
{
    // We may be casting a function pointer to a &#39;void *&#39; here, so this won&#39;t
    // work if we port to an architecture where the two are of different sizes.

    BSLMF_ASSERT(sizeof(void *) == sizeof(void (*)()));

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_pointer&lt;TARGET_TYPE&gt;::type&gt;::type NcPtrType;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_pointer&lt;
            typename bsl::remove_pointer&lt;FWD_ITER&gt;::type&gt;::type&gt;::type NcIter;

#if defined(BSLALG_ARRAYPRIMITIVES_CANNOT_REMOVE_POINTER_FROM_FUNCTION_POINTER)
    // fall back on traditional C-style casts.
    copyConstruct((void *       *)toBegin,
                  (void * const *)fromBegin,
                  (void * const *)fromEnd,
                  allocator,
                  (bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *) 0);
#else
    copyConstruct(
     reinterpret_cast&lt;void *       *&gt;(const_cast&lt;NcPtrType **&gt;(toBegin)),
     reinterpret_cast&lt;void * const *&gt;(const_cast&lt;NcIter * const *&gt;(fromBegin)),
     reinterpret_cast&lt;void * const *&gt;(const_cast&lt;NcIter * const *&gt;(fromEnd)),
     allocator,
     (bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *)0);
#endif
}

template &lt;class FWD_ITER, class ALLOCATOR&gt;
void ArrayPrimitives_Imp::copyConstruct(
                           void                                    **toBegin,
                           FWD_ITER                                  fromBegin,
                           FWD_ITER                                  fromEnd,
                           ALLOCATOR                                *,
                           bslmf::MetaInt&lt;e_IS_ITERATOR_TO_FUNCTION_POINTER&gt; *)
{
    BSLMF_ASSERT(sizeof(void *) == sizeof(void (*)()));
        // We will be casting a function pointer to a &#39;void *&#39;, so this won&#39;t
        // work if we port to an architecture where the two are of different
        // sizes.

    BSLS_ASSERT_SAFE(toBegin || fromBegin == fromEnd);
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(fromBegin, fromEnd));

    while (fromBegin != fromEnd) {
        // &#39;fromBegin&#39; iterates over pointers to functions, which must be
        // &#39;reinterpret_cast&#39; to &#39;void *&#39;.

        *toBegin = reinterpret_cast&lt;void *&gt;(*fromBegin);
        ++fromBegin;
        ++toBegin;
    }
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives_Imp::copyConstruct(
                          TARGET_TYPE                               *toBegin,
                          const TARGET_TYPE                         *fromBegin,
                          const TARGET_TYPE                         *fromEnd,
                          ALLOCATOR                                 *,
                          bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(toBegin);
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(fromBegin,
                                                          fromEnd));

    const size_type numBytes = reinterpret_cast&lt;const char*&gt;(fromEnd)
                             - reinterpret_cast&lt;const char*&gt;(fromBegin);
    std::memcpy(toBegin, fromBegin, numBytes);
}

template &lt;class TARGET_TYPE, class FWD_ITER, class ALLOCATOR&gt;
void ArrayPrimitives_Imp::copyConstruct(
                                       TARGET_TYPE                  *toBegin,
                                       FWD_ITER                      fromBegin,
                                       FWD_ITER                      fromEnd,
                                       ALLOCATOR                    *allocator,
                                       bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(toBegin || fromBegin == fromEnd);
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(fromBegin,
                                                          fromEnd));

    AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toBegin, toBegin);

    while (fromBegin != fromEnd) {
        // Note: We are not sure the value type of &#39;FWD_ITER&#39; is convertible to
        // &#39;TARGET_TYPE&#39;.  Use &#39;construct&#39; instead.

        ScalarPrimitives::construct(toBegin, *fromBegin, allocator);
        ++fromBegin;
        toBegin = guard.moveEnd(1);
    }
    guard.release();
}

              // *** &#39;defaultConstruct&#39; overloads: ***

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives_Imp::defaultConstruct(
                TARGET_TYPE                                       *begin,
                size_type                                          numElements,
                ALLOCATOR                                         *,
                bslmf::MetaInt&lt;e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    std::memset(static_cast&lt;void *&gt;(begin),
                0,
                sizeof(TARGET_TYPE) * numElements);
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives_Imp::defaultConstruct(
                        TARGET_TYPE                               *begin,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    ScalarPrimitives::defaultConstruct(begin, allocator);
    bitwiseFillN(reinterpret_cast&lt;char *&gt;(begin),
                 sizeof(TARGET_TYPE),
                 numElements * sizeof(TARGET_TYPE));
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
void ArrayPrimitives_Imp::defaultConstruct(
                                     TARGET_TYPE                  *begin,
                                     size_type                     numElements,
                                     ALLOCATOR                    *allocator,
                                     bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(begin || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(begin, begin);

    const TARGET_TYPE *end = begin + numElements;
    while (begin != end) {
        ScalarPrimitives::defaultConstruct(begin, allocator);
        begin = guard.moveEnd(1);
    }
    guard.release();
}

                     // *** &#39;destructiveMove&#39; overloads: ***

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives_Imp::destructiveMove(
                          TARGET_TYPE                               *toBegin,
                          TARGET_TYPE                               *fromBegin,
                          TARGET_TYPE                               *fromEnd,
                          ALLOCATOR                                 *,
                          bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(toBegin || fromBegin == fromEnd);
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(fromBegin,
                                                          fromEnd));

    const size_type numBytes = reinterpret_cast&lt;const char*&gt;(fromEnd)
                             - reinterpret_cast&lt;const char*&gt;(fromBegin);
    std::memcpy(toBegin, fromBegin, numBytes);
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives_Imp::destructiveMove(
                                       TARGET_TYPE                  *toBegin,
                                       TARGET_TYPE                  *fromBegin,
                                       TARGET_TYPE                  *fromEnd,
                                       ALLOCATOR                    *allocator,
                                       bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(toBegin || fromBegin == fromEnd);
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(fromBegin,
                                                          fromEnd));

    // &#39;TARGET_TYPE&#39; certainly cannot be bit-wise copyable, so we can save the
    // compiler some work.

    copyConstruct(toBegin, fromBegin, fromEnd, allocator,
                  (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);
    ArrayDestructionPrimitives::destroy(fromBegin, fromEnd);
}

                  // *** &#39;emplace&#39; with &#39;args&#39; overloads: ***

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
inline
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *,
                        Args&amp;&amp;...                                  args)
{
    // TBD: The implementation is exactly the same as &#39;BITWISE_MOVEABLE_TRAITS&#39;
    // unless &#39;AutoArrayMoveDestructor&#39; has a &#39;release&#39; method so the guard can
    // be called off after one in-place construction.  Then an optimization
    // using &#39;bitwiseFillN&#39; is possible.

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt;*)0,
                                 BSLS_COMPILERFEATURES_FORWARD(Args,args)...);
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *,
                        Args&amp;&amp;...                                  args)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));

    // Key to the transformation diagrams:
    //..
    //  A...G   original contents of &#39;[toBegin, toEnd)&#39;  (&quot;tail&quot;)
    //  v...v   contents of &#39;[fromBegin, fromEnd)&#39;       (&quot;input&quot;)
    //  _____   uninitialized array element
    //  [...]   part of an array guarded by an exception guard object
    //  |.(.,.) part of array guarded by move guard
    //          (middle indicated by &#39;,&#39; and dest by &#39;|&#39;)
    //..

    size_type tailLen    = toEnd - toBegin;
    size_type numGuarded = tailLen &lt; numElements ? tailLen : numElements;

    //..
    //  Transformation: ABCDE_______ =&gt; _______ABCDE (might overlap)
    //..

    TARGET_TYPE *destBegin = toBegin + numElements;
    std::memmove(destBegin, toBegin, tailLen * sizeof(TARGET_TYPE));

    //..
    //  Transformation: |_______(,ABCDE) =&gt; vvvvv|__(ABCDE,)
    //..

    TARGET_TYPE *destEnd = toEnd + numElements;
    AutoArrayMoveDestructor&lt;TARGET_TYPE&gt; guard(toBegin,
                                               destEnd - numGuarded,
                                               destEnd - numGuarded,
                                               destEnd);

    while (guard.middle() != guard.end()) {
        ScalarPrimitives::construct(
                                   guard.destination(),
                                   BSLS_COMPILERFEATURES_FORWARD(Args,args)...,
                                   allocator);
        guard.advance();
    }

    // The bitwise &#39;guard&#39; is now inactive, since &#39;middle() == end()&#39; and
    // &#39;guard.destination()&#39; is the smaller of &#39;destBegin&#39; or &#39;toEnd&#39;.

    if (tailLen &lt; numElements) {
        // There still is a gap of &#39;numElements - tailLen&#39; to fill in between
        // &#39;toEnd&#39; and &#39;destBegin&#39;.  The elements that have been &#39;memmove&#39;-ed
        // need to be guarded, we fill the gap backward from there to keep
        // guarded portion in one piece.

        AutoArrayDestructor&lt;TARGET_TYPE&gt; endGuard(destBegin, destEnd);

        //..
        //  Transformation: vvvvv__[ABCDE] =&gt; vvvvv[vvABCDE]
        //..

        while (toEnd != destBegin) {
            ScalarPrimitives::construct(
                                   --destBegin,
                                   BSLS_COMPILERFEATURES_FORWARD(Args,args)...,
                                   allocator);
            endGuard.moveBegin(-1);
        }
        endGuard.release();
    }
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
void ArrayPrimitives_Imp::emplace(TARGET_TYPE                  *toBegin,
                                  TARGET_TYPE                  *toEnd,
                                  size_type                     numElements,
                                  ALLOCATOR                    *allocator,
                                  bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *,
                                  Args&amp;&amp;...                     args)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));

    // Key to the transformation diagrams:
    //..
    //  A...G   original contents of &#39;[toBegin, toEnd)&#39;  (&quot;tail&quot;)
    //  v...v   copies of &#39;value&#39;                        (&quot;input&quot;)
    //  _____   uninitialized array elements
    //  [...]   part of array protected by an exception guard object
    //..

    const size_type tailLen = toEnd - toBegin;
    if (tailLen &gt;= numElements) {
        // Tail is not shorter than input.

        //..
        //  Transformation: ABCDEFG___[] =&gt; ABCDEFG[EFG].
        //..

        copyConstruct(toEnd,                // destination
                      toEnd - numElements,  // source
                      toEnd,                // end source
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd,
                                               toEnd + numElements);

        // Aliasing: Make a temp copy of &#39;value&#39; (always).  The reason is that
        // &#39;value&#39; could be a reference inside the input range, or even outside
        // but with lifetime controlled by one of these values, and so the next
        // transformation could invalidate &#39;value&#39;.  Note: One cannot rely on
        // &#39;TARGET_TYPE&#39; to have a single-argument copy ctor (i.e., default
        // allocator argument to 0) if it takes an allocator; hence the
        // constructor proxy.

        ConstructorProxy&lt;TARGET_TYPE&gt; tempValue(
                                   BSLS_COMPILERFEATURES_FORWARD(Args,args)...,
                                   bslma::Default::allocator());

        //..
        //  Transformation: ABCDEFG[EFG] =&gt; ABCABCD[EFG].
        //..

        reverseAssign(toBegin + numElements, toBegin, toEnd - numElements);

        //..
        //  Transformation: ABCABCD[EFG] =&gt; vvvABCD[EFG].
        //..

        assign(toBegin, toBegin + numElements, tempValue.object());

        guard.release();
    }
    else {
        // Tail is shorter than input.  We can avoid the temp copy of value
        // since there will be space to make a first copy after the tail, and
        // use that to make the subsequent copies.

        difference_type remElements = numElements - tailLen;

        //..
        //  Transformation: ABC_______[] =&gt; ABC____[ABC].
        //..

        copyConstruct(toBegin + numElements,  // destination
                      toBegin,                // source
                      toEnd,                  // end source
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd + remElements,
                                               toEnd + numElements);

        //..
        //  Transformation: ABC____[ABC] =&gt; ABC[vvvvABC].
        //..

        TARGET_TYPE *addr = toEnd + remElements - 1;
        for (; addr != toEnd - 1; --addr) {
            ScalarPrimitives::construct(
                                   addr,
                                   BSLS_COMPILERFEATURES_FORWARD(Args,args)...,
                                   allocator);
            guard.moveBegin(-1);
        }

        //..
        //  Transformation: ABC[vvvvABC] =&gt; vvv[vvvvABC].
        //..

        assign(toBegin, toEnd, *toEnd);

        guard.release();
    }
}
#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Generator command line: sim_cpp11_features.pl bslalg_arrayprimitives.h
template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *)
{

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt;*)0);
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1&gt;
inline
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1)
{

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt;*)0,
                                 BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1));
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2&gt;
inline
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2)
{

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt;*)0,
                                 BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2));
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2,
                                              class Args_3&gt;
inline
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3)
{

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt;*)0,
                                 BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3));
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2,
                                              class Args_3,
                                              class Args_4&gt;
inline
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4)
{

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt;*)0,
                                 BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_4,args_4));
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2,
                                              class Args_3,
                                              class Args_4,
                                              class Args_5&gt;
inline
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_5) args_5)
{

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt;*)0,
                                 BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_4,args_4),
                                 BSLS_COMPILERFEATURES_FORWARD(Args_5,args_5));
}


template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));


    size_type tailLen    = toEnd - toBegin;
    size_type numGuarded = tailLen &lt; numElements ? tailLen : numElements;


    TARGET_TYPE *destBegin = toBegin + numElements;
    std::memmove(destBegin, toBegin, tailLen * sizeof(TARGET_TYPE));


    TARGET_TYPE *destEnd = toEnd + numElements;
    AutoArrayMoveDestructor&lt;TARGET_TYPE&gt; guard(toBegin,
                                               destEnd - numGuarded,
                                               destEnd - numGuarded,
                                               destEnd);

    while (guard.middle() != guard.end()) {
        ScalarPrimitives::construct(
                                   guard.destination(),
                                   allocator);
        guard.advance();
    }


    if (tailLen &lt; numElements) {

        AutoArrayDestructor&lt;TARGET_TYPE&gt; endGuard(destBegin, destEnd);


        while (toEnd != destBegin) {
            ScalarPrimitives::construct(
                                   --destBegin,
                                   allocator);
            endGuard.moveBegin(-1);
        }
        endGuard.release();
    }
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1&gt;
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));


    size_type tailLen    = toEnd - toBegin;
    size_type numGuarded = tailLen &lt; numElements ? tailLen : numElements;


    TARGET_TYPE *destBegin = toBegin + numElements;
    std::memmove(destBegin, toBegin, tailLen * sizeof(TARGET_TYPE));


    TARGET_TYPE *destEnd = toEnd + numElements;
    AutoArrayMoveDestructor&lt;TARGET_TYPE&gt; guard(toBegin,
                                               destEnd - numGuarded,
                                               destEnd - numGuarded,
                                               destEnd);

    while (guard.middle() != guard.end()) {
        ScalarPrimitives::construct(
                                   guard.destination(),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                   allocator);
        guard.advance();
    }


    if (tailLen &lt; numElements) {

        AutoArrayDestructor&lt;TARGET_TYPE&gt; endGuard(destBegin, destEnd);


        while (toEnd != destBegin) {
            ScalarPrimitives::construct(
                                   --destBegin,
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                   allocator);
            endGuard.moveBegin(-1);
        }
        endGuard.release();
    }
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2&gt;
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));


    size_type tailLen    = toEnd - toBegin;
    size_type numGuarded = tailLen &lt; numElements ? tailLen : numElements;


    TARGET_TYPE *destBegin = toBegin + numElements;
    std::memmove(destBegin, toBegin, tailLen * sizeof(TARGET_TYPE));


    TARGET_TYPE *destEnd = toEnd + numElements;
    AutoArrayMoveDestructor&lt;TARGET_TYPE&gt; guard(toBegin,
                                               destEnd - numGuarded,
                                               destEnd - numGuarded,
                                               destEnd);

    while (guard.middle() != guard.end()) {
        ScalarPrimitives::construct(
                                   guard.destination(),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                   allocator);
        guard.advance();
    }


    if (tailLen &lt; numElements) {

        AutoArrayDestructor&lt;TARGET_TYPE&gt; endGuard(destBegin, destEnd);


        while (toEnd != destBegin) {
            ScalarPrimitives::construct(
                                   --destBegin,
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                   allocator);
            endGuard.moveBegin(-1);
        }
        endGuard.release();
    }
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2,
                                              class Args_3&gt;
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));


    size_type tailLen    = toEnd - toBegin;
    size_type numGuarded = tailLen &lt; numElements ? tailLen : numElements;


    TARGET_TYPE *destBegin = toBegin + numElements;
    std::memmove(destBegin, toBegin, tailLen * sizeof(TARGET_TYPE));


    TARGET_TYPE *destEnd = toEnd + numElements;
    AutoArrayMoveDestructor&lt;TARGET_TYPE&gt; guard(toBegin,
                                               destEnd - numGuarded,
                                               destEnd - numGuarded,
                                               destEnd);

    while (guard.middle() != guard.end()) {
        ScalarPrimitives::construct(
                                   guard.destination(),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                   allocator);
        guard.advance();
    }


    if (tailLen &lt; numElements) {

        AutoArrayDestructor&lt;TARGET_TYPE&gt; endGuard(destBegin, destEnd);


        while (toEnd != destBegin) {
            ScalarPrimitives::construct(
                                   --destBegin,
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                   allocator);
            endGuard.moveBegin(-1);
        }
        endGuard.release();
    }
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2,
                                              class Args_3,
                                              class Args_4&gt;
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));


    size_type tailLen    = toEnd - toBegin;
    size_type numGuarded = tailLen &lt; numElements ? tailLen : numElements;


    TARGET_TYPE *destBegin = toBegin + numElements;
    std::memmove(destBegin, toBegin, tailLen * sizeof(TARGET_TYPE));


    TARGET_TYPE *destEnd = toEnd + numElements;
    AutoArrayMoveDestructor&lt;TARGET_TYPE&gt; guard(toBegin,
                                               destEnd - numGuarded,
                                               destEnd - numGuarded,
                                               destEnd);

    while (guard.middle() != guard.end()) {
        ScalarPrimitives::construct(
                                   guard.destination(),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_4,args_4),
                                   allocator);
        guard.advance();
    }


    if (tailLen &lt; numElements) {

        AutoArrayDestructor&lt;TARGET_TYPE&gt; endGuard(destBegin, destEnd);


        while (toEnd != destBegin) {
            ScalarPrimitives::construct(
                                   --destBegin,
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_4,args_4),
                                   allocator);
            endGuard.moveBegin(-1);
        }
        endGuard.release();
    }
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2,
                                              class Args_3,
                                              class Args_4,
                                              class Args_5&gt;
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args_5) args_5)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));


    size_type tailLen    = toEnd - toBegin;
    size_type numGuarded = tailLen &lt; numElements ? tailLen : numElements;


    TARGET_TYPE *destBegin = toBegin + numElements;
    std::memmove(destBegin, toBegin, tailLen * sizeof(TARGET_TYPE));


    TARGET_TYPE *destEnd = toEnd + numElements;
    AutoArrayMoveDestructor&lt;TARGET_TYPE&gt; guard(toBegin,
                                               destEnd - numGuarded,
                                               destEnd - numGuarded,
                                               destEnd);

    while (guard.middle() != guard.end()) {
        ScalarPrimitives::construct(
                                   guard.destination(),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_4,args_4),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_5,args_5),
                                   allocator);
        guard.advance();
    }


    if (tailLen &lt; numElements) {

        AutoArrayDestructor&lt;TARGET_TYPE&gt; endGuard(destBegin, destEnd);


        while (toEnd != destBegin) {
            ScalarPrimitives::construct(
                                   --destBegin,
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_4,args_4),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_5,args_5),
                                   allocator);
            endGuard.moveBegin(-1);
        }
        endGuard.release();
    }
}


template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
void ArrayPrimitives_Imp::emplace(TARGET_TYPE                  *toBegin,
                                  TARGET_TYPE                  *toEnd,
                                  size_type                     numElements,
                                  ALLOCATOR                    *allocator,
                                  bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));


    const size_type tailLen = toEnd - toBegin;
    if (tailLen &gt;= numElements) {


        copyConstruct(toEnd,
                      toEnd - numElements,
                      toEnd,
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd,
                                               toEnd + numElements);


        ConstructorProxy&lt;TARGET_TYPE&gt; tempValue(
                                   bslma::Default::allocator());


        reverseAssign(toBegin + numElements, toBegin, toEnd - numElements);


        assign(toBegin, toBegin + numElements, tempValue.object());

        guard.release();
    }
    else {

        difference_type remElements = numElements - tailLen;


        copyConstruct(toBegin + numElements,
                      toBegin,
                      toEnd,
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd + remElements,
                                               toEnd + numElements);


        TARGET_TYPE *addr = toEnd + remElements - 1;
        for (; addr != toEnd - 1; --addr) {
            ScalarPrimitives::construct(
                                   addr,
                                   allocator);
            guard.moveBegin(-1);
        }


        assign(toBegin, toEnd, *toEnd);

        guard.release();
    }
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1&gt;
void ArrayPrimitives_Imp::emplace(TARGET_TYPE                  *toBegin,
                                  TARGET_TYPE                  *toEnd,
                                  size_type                     numElements,
                                  ALLOCATOR                    *allocator,
                                  bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));


    const size_type tailLen = toEnd - toBegin;
    if (tailLen &gt;= numElements) {


        copyConstruct(toEnd,
                      toEnd - numElements,
                      toEnd,
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd,
                                               toEnd + numElements);


        ConstructorProxy&lt;TARGET_TYPE&gt; tempValue(
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                   bslma::Default::allocator());


        reverseAssign(toBegin + numElements, toBegin, toEnd - numElements);


        assign(toBegin, toBegin + numElements, tempValue.object());

        guard.release();
    }
    else {

        difference_type remElements = numElements - tailLen;


        copyConstruct(toBegin + numElements,
                      toBegin,
                      toEnd,
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd + remElements,
                                               toEnd + numElements);


        TARGET_TYPE *addr = toEnd + remElements - 1;
        for (; addr != toEnd - 1; --addr) {
            ScalarPrimitives::construct(
                                   addr,
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                   allocator);
            guard.moveBegin(-1);
        }


        assign(toBegin, toEnd, *toEnd);

        guard.release();
    }
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2&gt;
void ArrayPrimitives_Imp::emplace(TARGET_TYPE                  *toBegin,
                                  TARGET_TYPE                  *toEnd,
                                  size_type                     numElements,
                                  ALLOCATOR                    *allocator,
                                  bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));


    const size_type tailLen = toEnd - toBegin;
    if (tailLen &gt;= numElements) {


        copyConstruct(toEnd,
                      toEnd - numElements,
                      toEnd,
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd,
                                               toEnd + numElements);


        ConstructorProxy&lt;TARGET_TYPE&gt; tempValue(
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                   bslma::Default::allocator());


        reverseAssign(toBegin + numElements, toBegin, toEnd - numElements);


        assign(toBegin, toBegin + numElements, tempValue.object());

        guard.release();
    }
    else {

        difference_type remElements = numElements - tailLen;


        copyConstruct(toBegin + numElements,
                      toBegin,
                      toEnd,
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd + remElements,
                                               toEnd + numElements);


        TARGET_TYPE *addr = toEnd + remElements - 1;
        for (; addr != toEnd - 1; --addr) {
            ScalarPrimitives::construct(
                                   addr,
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                   allocator);
            guard.moveBegin(-1);
        }


        assign(toBegin, toEnd, *toEnd);

        guard.release();
    }
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2,
                                              class Args_3&gt;
void ArrayPrimitives_Imp::emplace(TARGET_TYPE                  *toBegin,
                                  TARGET_TYPE                  *toEnd,
                                  size_type                     numElements,
                                  ALLOCATOR                    *allocator,
                                  bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));


    const size_type tailLen = toEnd - toBegin;
    if (tailLen &gt;= numElements) {


        copyConstruct(toEnd,
                      toEnd - numElements,
                      toEnd,
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd,
                                               toEnd + numElements);


        ConstructorProxy&lt;TARGET_TYPE&gt; tempValue(
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                   bslma::Default::allocator());


        reverseAssign(toBegin + numElements, toBegin, toEnd - numElements);


        assign(toBegin, toBegin + numElements, tempValue.object());

        guard.release();
    }
    else {

        difference_type remElements = numElements - tailLen;


        copyConstruct(toBegin + numElements,
                      toBegin,
                      toEnd,
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd + remElements,
                                               toEnd + numElements);


        TARGET_TYPE *addr = toEnd + remElements - 1;
        for (; addr != toEnd - 1; --addr) {
            ScalarPrimitives::construct(
                                   addr,
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                   allocator);
            guard.moveBegin(-1);
        }


        assign(toBegin, toEnd, *toEnd);

        guard.release();
    }
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2,
                                              class Args_3,
                                              class Args_4&gt;
void ArrayPrimitives_Imp::emplace(TARGET_TYPE                  *toBegin,
                                  TARGET_TYPE                  *toEnd,
                                  size_type                     numElements,
                                  ALLOCATOR                    *allocator,
                                  bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));


    const size_type tailLen = toEnd - toBegin;
    if (tailLen &gt;= numElements) {


        copyConstruct(toEnd,
                      toEnd - numElements,
                      toEnd,
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd,
                                               toEnd + numElements);


        ConstructorProxy&lt;TARGET_TYPE&gt; tempValue(
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_4,args_4),
                                   bslma::Default::allocator());


        reverseAssign(toBegin + numElements, toBegin, toEnd - numElements);


        assign(toBegin, toBegin + numElements, tempValue.object());

        guard.release();
    }
    else {

        difference_type remElements = numElements - tailLen;


        copyConstruct(toBegin + numElements,
                      toBegin,
                      toEnd,
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd + remElements,
                                               toEnd + numElements);


        TARGET_TYPE *addr = toEnd + remElements - 1;
        for (; addr != toEnd - 1; --addr) {
            ScalarPrimitives::construct(
                                   addr,
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_4,args_4),
                                   allocator);
            guard.moveBegin(-1);
        }


        assign(toBegin, toEnd, *toEnd);

        guard.release();
    }
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class Args_1,
                                              class Args_2,
                                              class Args_3,
                                              class Args_4,
                                              class Args_5&gt;
void ArrayPrimitives_Imp::emplace(TARGET_TYPE                  *toBegin,
                                  TARGET_TYPE                  *toEnd,
                                  size_type                     numElements,
                                  ALLOCATOR                    *allocator,
                                  bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_2) args_2,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_3) args_3,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_4) args_4,
                              BSLS_COMPILERFEATURES_FORWARD_REF(Args_5) args_5)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));


    const size_type tailLen = toEnd - toBegin;
    if (tailLen &gt;= numElements) {


        copyConstruct(toEnd,
                      toEnd - numElements,
                      toEnd,
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd,
                                               toEnd + numElements);


        ConstructorProxy&lt;TARGET_TYPE&gt; tempValue(
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_4,args_4),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_5,args_5),
                                   bslma::Default::allocator());


        reverseAssign(toBegin + numElements, toBegin, toEnd - numElements);


        assign(toBegin, toBegin + numElements, tempValue.object());

        guard.release();
    }
    else {

        difference_type remElements = numElements - tailLen;


        copyConstruct(toBegin + numElements,
                      toBegin,
                      toEnd,
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd + remElements,
                                               toEnd + numElements);


        TARGET_TYPE *addr = toEnd + remElements - 1;
        for (; addr != toEnd - 1; --addr) {
            ScalarPrimitives::construct(
                                   addr,
                                  BSLS_COMPILERFEATURES_FORWARD(Args_1,args_1),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_2,args_2),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_3,args_3),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_4,args_4),
                                  BSLS_COMPILERFEATURES_FORWARD(Args_5,args_5),
                                   allocator);
            guard.moveBegin(-1);
        }


        assign(toBegin, toEnd, *toEnd);

        guard.release();
    }
}

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
inline
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args)
{

    ArrayPrimitives_Imp::emplace(toBegin,
                                 toEnd,
                                 numElements,
                                 allocator,
                                 (bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt;*)0,
                                 BSLS_COMPILERFEATURES_FORWARD(Args,args)...);
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
void ArrayPrimitives_Imp::emplace(
                        TARGET_TYPE                               *toBegin,
                        TARGET_TYPE                               *toEnd,
                        size_type                                  numElements,
                        ALLOCATOR                                 *allocator,
                        bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *,
                        BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));


    size_type tailLen    = toEnd - toBegin;
    size_type numGuarded = tailLen &lt; numElements ? tailLen : numElements;


    TARGET_TYPE *destBegin = toBegin + numElements;
    std::memmove(destBegin, toBegin, tailLen * sizeof(TARGET_TYPE));


    TARGET_TYPE *destEnd = toEnd + numElements;
    AutoArrayMoveDestructor&lt;TARGET_TYPE&gt; guard(toBegin,
                                               destEnd - numGuarded,
                                               destEnd - numGuarded,
                                               destEnd);

    while (guard.middle() != guard.end()) {
        ScalarPrimitives::construct(
                                   guard.destination(),
                                   BSLS_COMPILERFEATURES_FORWARD(Args,args)...,
                                   allocator);
        guard.advance();
    }


    if (tailLen &lt; numElements) {

        AutoArrayDestructor&lt;TARGET_TYPE&gt; endGuard(destBegin, destEnd);


        while (toEnd != destBegin) {
            ScalarPrimitives::construct(
                                   --destBegin,
                                   BSLS_COMPILERFEATURES_FORWARD(Args,args)...,
                                   allocator);
            endGuard.moveBegin(-1);
        }
        endGuard.release();
    }
}

template &lt;class TARGET_TYPE, class ALLOCATOR, class... Args&gt;
void ArrayPrimitives_Imp::emplace(TARGET_TYPE                  *toBegin,
                                  TARGET_TYPE                  *toEnd,
                                  size_type                     numElements,
                                  ALLOCATOR                    *allocator,
                                  bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *,
                               BSLS_COMPILERFEATURES_FORWARD_REF(Args)... args)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin,
                                                          toEnd));
    BSLMF_ASSERT((bslmf::IsSame&lt;size_type, std::size_t&gt;::VALUE));


    const size_type tailLen = toEnd - toBegin;
    if (tailLen &gt;= numElements) {


        copyConstruct(toEnd,
                      toEnd - numElements,
                      toEnd,
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd,
                                               toEnd + numElements);


        ConstructorProxy&lt;TARGET_TYPE&gt; tempValue(
                                   BSLS_COMPILERFEATURES_FORWARD(Args,args)...,
                                   bslma::Default::allocator());


        reverseAssign(toBegin + numElements, toBegin, toEnd - numElements);


        assign(toBegin, toBegin + numElements, tempValue.object());

        guard.release();
    }
    else {

        difference_type remElements = numElements - tailLen;


        copyConstruct(toBegin + numElements,
                      toBegin,
                      toEnd,
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd + remElements,
                                               toEnd + numElements);


        TARGET_TYPE *addr = toEnd + remElements - 1;
        for (; addr != toEnd - 1; --addr) {
            ScalarPrimitives::construct(
                                   addr,
                                   BSLS_COMPILERFEATURES_FORWARD(Args,args)...,
                                   allocator);
            guard.moveBegin(-1);
        }


        assign(toBegin, toEnd, *toEnd);

        guard.release();
    }
}
// }}} END GENERATED CODE
#endif

                          // *** &#39;erase&#39; overloads: ***

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
void ArrayPrimitives_Imp::erase(
                               TARGET_TYPE                             *first,
                               TARGET_TYPE                             *middle,
                               TARGET_TYPE                             *last,
                               ALLOCATOR                               *,
                               bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(first, middle));
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(middle, last));

    // Key to the transformation diagrams:
    //..
    //  t...z   Original contents of &#39;[first, middle)&#39;
    //  A...G   Original contents of &#39;[middle, last)&#39;
    //  _       Destroyed array element
    //..

    //..
    //  Transformation: tuvABCDEFG =&gt; ___ABCDEFG (no throw)
    //..
    ArrayDestructionPrimitives::destroy(first, middle);

    //..
    //  Transformation: ___ABCDEFG =&gt; ABCDEFG___  (might overlap, but no throw)
    //..
    size_type numBytes = reinterpret_cast&lt;const char *&gt;(last)
                       - reinterpret_cast&lt;const char *&gt;(middle);
    std::memmove(first, middle, numBytes);
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
void ArrayPrimitives_Imp::erase(TARGET_TYPE                *first,
                                TARGET_TYPE                *middle,
                                TARGET_TYPE                *last,
                                ALLOCATOR                  *,
                                bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(first, middle));
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(middle, last));

    // Key to the transformation diagrams:
    //..
    //  t...z   Original contents of &#39;[first, middle)&#39;
    //  A...G   Original contents of &#39;[middle, last)&#39;
    //  _       Destructed array element
    //..

    //..
    //  Transformation: tuvABCDEFG =&gt; ABCDEFGEFG.
    //..

    while (middle != last) {
        *first++ = *middle++;
    }

    //..
    //  Transformation: ABCDEFGEFG =&gt; ABCDEFG___.
    //..

    ArrayDestructionPrimitives::destroy(first, middle);
}

                   // *** &#39;insert&#39; with &#39;value&#39; overloads: ***

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives_Imp::insert(
                          TARGET_TYPE                             *toBegin,
                          TARGET_TYPE                             *toEnd,
                          const TARGET_TYPE&amp;                       value,
                          size_type                                numElements,
                          ALLOCATOR                               *allocator,
                          bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin, toEnd));
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    // Key to the transformation diagrams:
    //..
    //  A...G   original contents of &#39;[toBegin, toEnd)&#39;  (&quot;tail&quot;)
    //  v...v   contents of &#39;[fromBegin, fromEnd)&#39;       (&quot;input&quot;)
    //  _____   uninitialized array element
    //..

    // ALIASING: If &#39;value&#39; is a reference into the array &#39;toBegin..toEnd&#39;,
    // then moving the array first might introduce a change in &#39;value&#39;.  Since
    // type is bitwise copyable, then no memory changes outside the array, so
    // the test below is sufficient to discover all the possible aliasing.
    // Note that we never make a copy.

    const TARGET_TYPE *tempValuePtr = BSLS_UTIL_ADDRESSOF(value);
    if (toBegin &lt;= tempValuePtr &amp;&amp; tempValuePtr &lt; toEnd ) {
        // Adjust pointer for shifting after the move.

        tempValuePtr += numElements;
    }

    //..
    //  Transformation: ABCDE___ =&gt; ___ABCDE  (might overlap).
    //..

    const size_type numBytes = reinterpret_cast&lt;const char*&gt;(toEnd)
                             - reinterpret_cast&lt;const char*&gt;(toBegin);
    std::memmove(toBegin + numElements, toBegin, numBytes);

    //..
    //  Transformation: ___ABCDE =&gt; v__ABCDE (no overlap).
    //..

    // Use &#39;copyConstruct&#39; instead of &#39;memcpy&#39; because the former optimizes for
    // fundamental types using &#39;operator=&#39; instead, which avoid the &#39;memcpy&#39;
    // function call.

    ScalarPrimitives::copyConstruct(toBegin,
                                    *tempValuePtr,
                                    allocator);

    //..
    //  Transformation: v__ABCDE =&gt; vvvABCDE.
    //..

    bitwiseFillN(reinterpret_cast&lt;char *&gt;(toBegin),
                 sizeof value,
                 numElements * sizeof value);
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
void ArrayPrimitives_Imp::insert(
                          TARGET_TYPE                             *toBegin,
                          TARGET_TYPE                             *toEnd,
                          const TARGET_TYPE&amp;                       value,
                          size_type                                numElements,
                          ALLOCATOR                               *allocator,
                          bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin, toEnd));
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    // Key to the transformation diagrams:
    //..
    //  A...G   original contents of &#39;[toBegin, toEnd)&#39;  (&quot;tail&quot;)
    //  v...v   contents of &#39;[fromBegin, fromEnd)&#39;       (&quot;input&quot;)
    //  _____   uninitialized array element
    //  [...]   part of an array guarded by an exception guard object
    //  |.(.,.) part of array guarded by move guard
    //          (middle indicated by &#39;,&#39; and dest by &#39;|&#39;)
    //..

    const TARGET_TYPE *tempValuePtr = BSLS_UTIL_ADDRESSOF(value);
    if (toBegin &lt;= tempValuePtr &amp;&amp; tempValuePtr &lt; toEnd + numElements) {
        // Adjust pointer for shifting after the move.

        tempValuePtr += numElements;
    }

    size_type tailLen    = toEnd - toBegin;
    size_type numGuarded = tailLen &lt; numElements ? tailLen : numElements;

    //..
    //  Transformation: ABCDE_______ =&gt; _______ABCDE (might overlap)
    //..

    TARGET_TYPE *destBegin = toBegin + numElements;
    std::memmove(destBegin, toBegin, tailLen * sizeof(TARGET_TYPE));

    //..
    //  Transformation: |_______(,ABCDE) =&gt; vvvvv|__(ABCDE,)
    //..

    TARGET_TYPE *destEnd = toEnd + numElements;
    AutoArrayMoveDestructor&lt;TARGET_TYPE&gt; guard(toBegin,
                                               destEnd - numGuarded,
                                               destEnd - numGuarded,
                                               destEnd);

    while (guard.middle() != guard.end()) {
        ScalarPrimitives::copyConstruct(guard.destination(),
                                        *tempValuePtr,
                                        allocator);
        guard.advance();
    }

    // The bitwise &#39;guard&#39; is now inactive, since &#39;middle() == end()&#39; and
    // &#39;guard.destination()&#39; is the smaller of &#39;destBegin&#39; or &#39;toEnd&#39;.

    if (tailLen &lt; numElements) {
        // There still is a gap of &#39;numElements - tailLen&#39; to fill in between
        // &#39;toEnd&#39; and &#39;destBegin&#39;.  The elements that have been &#39;memmove&#39;-ed
        // need to be guarded, we fill the gap backward from there to keep
        // guarded portion in one piece.

        AutoArrayDestructor&lt;TARGET_TYPE&gt; endGuard(destBegin, destEnd);

        //..
        //  Transformation: vvvvv__[ABCDE] =&gt; vvvvv[vvABCDE]
        //..

        while (toEnd != destBegin) {
            ScalarPrimitives::copyConstruct(--destBegin,
                                            *tempValuePtr,
                                            allocator);
            endGuard.moveBegin(-1);
        }
        endGuard.release();
    }
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
void ArrayPrimitives_Imp::insert(TARGET_TYPE                *toBegin,
                                 TARGET_TYPE                *toEnd,
                                 const TARGET_TYPE&amp;          value,
                                 size_type                   numElements,
                                 ALLOCATOR                  *allocator,
                                 bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin, toEnd));
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    // Key to the transformation diagrams:
    //..
    //  A...G   original contents of &#39;[toBegin, toEnd)&#39;  (&quot;tail&quot;)
    //  v...v   copies of &#39;value&#39;                        (&quot;input&quot;)
    //  _____   uninitialized array elements
    //  [...]   part of array protected by an exception guard object
    //..

    const size_type tailLen = toEnd - toBegin;
    if (tailLen &gt;= numElements) {
        // Tail is not shorter than input.

        //..
        //  Transformation: ABCDEFG___[] =&gt; ABCDEFG[EFG].
        //..

        copyConstruct(                                           // destination
                      toEnd,
                      toEnd - numElements,  // source
                      toEnd,                // end source
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd,
                                               toEnd + numElements);

        // Aliasing: Make a temp copy of &#39;value&#39; (always).  The reason is that
        // &#39;value&#39; could be a reference inside the input range, or even outside
        // but with lifetime controlled by one of these values, and so the next
        // transformation could invalidate &#39;value&#39;.  Note: One cannot rely on
        // &#39;TARGET_TYPE&#39; to have a single-argument copy ctor (i.e., default
        // allocator argument to 0) if it takes an allocator; hence the
        // constructor proxy.

        ConstructorProxy&lt;TARGET_TYPE&gt;
                                 tempValue(value, bslma::Default::allocator());

        //..
        //  Transformation: ABCDEFG[EFG] =&gt; ABCABCD[EFG].
        //..

        TARGET_TYPE *src  = toEnd - numElements;
        TARGET_TYPE *dest = toEnd;
        while (toBegin != src) {
            *--dest = *--src;
        }

        //..
        //  Transformation: ABCABCD[EFG] =&gt; vvvABCD[EFG].
        //..

        for ( ; toBegin != dest; ++toBegin) {
            *toBegin = tempValue.object();
        }

        guard.release();
    }
    else {
        // Tail is shorter than input.  We can avoid the temp copy of value
        // since there will be space to make a first copy after the tail, and
        // use that to make the subsequent copies.

        difference_type remElements = numElements - tailLen;

        //..
        //  Transformation: ABC_______[] =&gt; ABC____[ABC].
        //..

        copyConstruct(                                           // destination
                      toBegin + numElements,
                      toBegin,                // source
                      toEnd,                  // end source
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd + remElements,
                                               toEnd + numElements);

        //..
        //  Transformation: ABC____[ABC] =&gt; ABC[vvvvABC].
        //..

        uninitializedFillN(toEnd,
                           value,
                           remElements,
                           allocator,
                           (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);
        guard.moveBegin(-remElements);

        //..
        //  Transformation: ABC[vvvvABC] =&gt; vvv[vvvvABC].
        //..

        for ( ; toBegin != toEnd; ++toBegin) {
            *toBegin = *toEnd;
        }

        guard.release();
    }
}

                  // *** &#39;insert&#39; with &#39;FWD_ITER&#39; overloads: ***


template &lt;class TARGET_TYPE, class FWD_ITER, class ALLOCATOR&gt;
inline
void ArrayPrimitives_Imp::insert(
                          TARGET_TYPE                             *toBegin,
                          TARGET_TYPE                             *toEnd,
                          FWD_ITER                                 fromBegin,
                          FWD_ITER                                 fromEnd,
                          size_type                                numElements,
                          ALLOCATOR                               *allocator,
                          bslmf::MetaInt&lt;e_IS_POINTER_TO_POINTER&gt;   *)
{
    // We may be casting a function pointer to a &#39;void *&#39; here, so this won&#39;t
    // work if we port to an architecture where the two are of different sizes.

    BSLMF_ASSERT(sizeof(void *) == sizeof(void (*)()));

#if defined(BSLALG_ARRAYPRIMITIVES_CANNOT_REMOVE_POINTER_FROM_FUNCTION_POINTER)
    // fall back on traditional C-style casts.
    insert((void *       *)toBegin,
           (void *       *)toEnd,
           (void * const *)fromBegin,
           (void * const *)fromEnd,
           numElements,
           allocator,
           (bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *) 0);
#else
    typedef typename bsl::remove_const&lt;
            typename bsl::remove_pointer&lt;TARGET_TYPE&gt;::type&gt;::type NcPtrType;

    typedef typename bsl::remove_const&lt;
            typename bsl::remove_pointer&lt;
            typename bsl::remove_pointer&lt;FWD_ITER&gt;::type&gt;::type&gt;::type NcIter;

    insert(
     reinterpret_cast&lt;void *       *&gt;(const_cast&lt;NcPtrType **&gt;(toBegin)),
     reinterpret_cast&lt;void *       *&gt;(const_cast&lt;NcPtrType **&gt;(toEnd)),
     reinterpret_cast&lt;void * const *&gt;(const_cast&lt;NcIter * const *&gt;(fromBegin)),
     reinterpret_cast&lt;void * const *&gt;(const_cast&lt;NcIter * const *&gt;(fromEnd)),
     numElements,
     allocator,
     (bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *) 0);
#endif
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives_Imp::insert(
                          TARGET_TYPE                             *toBegin,
                          TARGET_TYPE                             *toEnd,
                          const TARGET_TYPE                       *fromBegin,
                          const TARGET_TYPE                       *fromEnd,
                          size_type                                numElements,
                          ALLOCATOR                               *,
                          bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt; *)
{
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    // &#39;FWD_ITER&#39; has been converted to a &#39;const TARGET_TYPE *&#39; and
    // &#39;TARGET_TYPE&#39; is bit-wise copyable.
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin, toEnd));
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(fromBegin, fromEnd));
    BSLS_ASSERT_SAFE(fromBegin || 0 == numElements);

    BSLS_ASSERT_SAFE(fromBegin + numElements == fromEnd);
    BSLS_ASSERT_SAFE(fromEnd &lt;= toBegin || toEnd + numElements &lt;= fromBegin);

    (void) fromEnd;  // quell warning when &#39;BSLS_ASSERT_SAFE&#39; is compiled out

    // Key to the transformation diagrams:
    //..
    //  A...G   original contents of &#39;[toBegin, toEnd)&#39;  (&quot;tail&quot;)
    //  t...z   contents of &#39;[fromBegin, fromEnd)&#39;       (&quot;input&quot;)
    //  _____   uninitialized array element
    //..

    //..
    //  Transformation: ABCDE_______ =&gt; _______ABCDE (might overlap).
    //..

    const size_type numBytes = reinterpret_cast&lt;const char*&gt;(toEnd)
                             - reinterpret_cast&lt;const char*&gt;(toBegin);
    std::memmove(toBegin + numElements, toBegin, numBytes);

    //..
    //  Transformation: _______ABCDE =&gt; tuvwxyzABCDE (no overlap).
    //..

    std::memcpy(toBegin, fromBegin, numElements * sizeof(TARGET_TYPE));
}

template &lt;class TARGET_TYPE, class FWD_ITER, class ALLOCATOR&gt;
void ArrayPrimitives_Imp::insert(
                          TARGET_TYPE                             *toBegin,
                          TARGET_TYPE                             *toEnd,
                          FWD_ITER                                 fromBegin,
                          FWD_ITER,
                          size_type                                numElements,
                          ALLOCATOR                               *allocator,
                          bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *)
{
    // &#39;TARGET_TYPE&#39; is bit-wise moveable.
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin, toEnd));
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    if (0 == numElements) {
        return;                                                       // RETURN
    }

    // The following assertions make sense only if &#39;FWD_ITER&#39; is a pointer to a
    // possibly cv-qualified &#39;TARGET_TYPE&#39;, and are tested in that overload
    // (see above).
    //..
    //  BSLS_ASSERT(fromBegin + numElements == fromEnd);
    //  BSLS_ASSERT(fromEnd &lt;= toBegin || toEnd + numElements &lt;= fromBegin);
    //..

    // Key to the transformation diagrams:
    //..
    //  A...G   original contents of &#39;[toBegin, toEnd)&#39;  (&quot;tail&quot;)
    //  t...z   contents of &#39;[fromBegin, fromEnd)&#39;       (&quot;input&quot;)
    //  _____   uninitialized array element
    //  [...]   part of array guarded by exception guard
    //  |.(.,.) part of array guarded by move guard
    //          (middle indicated by &#39;,&#39; and dest by &#39;|&#39;)
    //..

    const size_type tailLen  = toEnd - toBegin;
    const size_type numGuarded = tailLen &lt; numElements ? tailLen : numElements;

    //..
    //  Transformation: ABCDE____ =&gt; ____ABCDE (might overlap).
    //..

    TARGET_TYPE *destBegin = toBegin + numElements;
    std::memmove(destBegin, toBegin, tailLen * sizeof(TARGET_TYPE));

    //..
    //  Transformation: |_______(,ABCDE) =&gt; tuvwx|__(ABCDE,).
    //..

    TARGET_TYPE *destEnd = toEnd + numElements;
    AutoArrayMoveDestructor&lt;TARGET_TYPE&gt; guard(toBegin,
                                               destEnd - numGuarded,
                                               destEnd - numGuarded,
                                               destEnd);

    for (; guard.middle() != guard.end(); ++fromBegin) {
        ScalarPrimitives::construct(guard.destination(),
                                    *fromBegin,
                                    allocator);
        guard.advance();
    }

    // The bitwise &#39;guard&#39; is now inactive, since &#39;middle() == end()&#39;, and
    // &#39;guard.destination()&#39; is the smaller of &#39;destBegin&#39; or &#39;toEnd&#39;.

    if (tailLen &lt; numElements) {
        // There still is a gap of &#39;numElements - tailLen&#39; to fill in between
        // &#39;toEnd&#39; and &#39;destBegin&#39;.  The elements that have been &#39;memmove&#39;-ed
        // need to be guarded, and we need to continue to fill the hole at the
        // same guarding the copied elements as well.

        AutoArrayDestructor&lt;TARGET_TYPE&gt; endGuard1(toEnd, toEnd);
        AutoArrayDestructor&lt;TARGET_TYPE&gt; endGuard2(destBegin, destEnd);

        //..
        //  Transformation: tuvwx[]__[ABCDE] =&gt; tuvwx[yz][ABCDE].
        //..

        for (; toEnd != destBegin; ++fromBegin) {
            ScalarPrimitives::construct(toEnd,
                                        *fromBegin,
                                        allocator);
            toEnd = endGuard1.moveEnd(1);
        }
        endGuard1.release();
        endGuard2.release();
    }
}

template &lt;class TARGET_TYPE, class FWD_ITER, class ALLOCATOR&gt;
void ArrayPrimitives_Imp::insert(TARGET_TYPE                *toBegin,
                                 TARGET_TYPE                *toEnd,
                                 FWD_ITER                    fromBegin,
                                 FWD_ITER                    fromEnd,
                                 size_type                   numElements,
                                 ALLOCATOR                  *allocator,
                                 bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin, toEnd));
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    if (0 == numElements) {
        return;                                                       // RETURN
    }

    // Key to the transformation diagrams:
    //..
    //  A...G   original contents of &#39;[toBegin, toEnd)&#39;  (&quot;tail&quot;)
    //  t...z   contents of &#39;[fromBegin, fromEnd)&#39;       (&quot;input&quot;)
    //  _____   uninitialized array elements
    //  [...]   part of array protected by a guard object
    //..

    const size_type tailLen = toEnd - toBegin;
    if (tailLen &gt; numElements) {
        // Tail is longer than input.

        //..
        //  Transformation: ABCDEFG___[] =&gt; ABCDEFG[EFG].
        //..

        copyConstruct(                                           // destination
                      toEnd,
                      toEnd - numElements,  // source
                      toEnd,                // end source
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd,
                                               toEnd + numElements);

        //..
        //  Transformation: ABCDEFG[EFG] =&gt; ABCABCD[EFG].
        //..

        TARGET_TYPE *src  = toEnd - numElements;
        TARGET_TYPE *dest = toEnd;
        while (toBegin != src) {
            *--dest = *--src;
        }

        //..
        //  Transformation: ABCABCD[EFG] =&gt; tuvABCD[EFG].
        //..

        for (; toBegin != dest; ++toBegin, ++fromBegin) {
            *toBegin = *fromBegin;
        }

        guard.release();
    }
    else {
        // Tail is not longer than input (numElements).

        difference_type remElements = numElements - tailLen;

        //..
        //  Transformation: ABC_______[] =&gt; ABC____[ABC]
        //..

        copyConstruct(                                           // destination
                      toBegin + numElements,
                      toBegin,                // source
                      toEnd,                  // end source
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        AutoArrayDestructor&lt;TARGET_TYPE&gt; guard(toEnd + remElements,
                                               toEnd + numElements);

        //..
        //  Transformation: ABC____[ABC] =&gt; tuv____[ABC].
        //..

        for (; toBegin != toEnd; ++fromBegin, ++toBegin) {
            *toBegin = *fromBegin;
        }

        //..
        //  Transformation: tuv____[ABC] =&gt; tuvwxyzABC[].
        //..
        copyConstruct(toBegin,
                      fromBegin,
                      fromEnd,
                      allocator,
                      (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);

        guard.release();
    }
}

template &lt;class FWD_ITER, class ALLOCATOR&gt;
void ArrayPrimitives_Imp::insert(
                           void                                  **toBegin,
                           void                                  **toEnd,
                           FWD_ITER                                fromBegin,
                           FWD_ITER,
                           size_type                               numElements,
                           ALLOCATOR                              *,
                           bslmf::MetaInt&lt;e_IS_ITERATOR_TO_FUNCTION_POINTER&gt; *)
{
    // This very specific overload is required for the case that &#39;FWD_ITER&#39; is
    // an iterator that is not a pointer, iterating over a sequence of function
    // pointers.  The implementation relies on the conditionally-supported
    // behavior that any function pointer can be &#39;reinterpret_cast&#39; to
    // &#39;void *&#39;.

    // &#39;TARGET_TYPE&#39; is bit-wise moveable.
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin, toEnd));
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));

    if (0 == numElements) {
        return;                                                       // RETURN
    }

    // The following assertions make sense only if &#39;FWD_ITER&#39; is a pointer to a
    // possibly cv-qualified &#39;TARGET_TYPE&#39;, and are tested in that overload
    // (see above).
    //..
    //  BSLS_ASSERT(fromBegin + numElements == fromEnd);
    //  BSLS_ASSERT(fromEnd &lt;= toBegin || toEnd + numElements &lt;= fromBegin);
    //..

    // Key to the transformation diagrams:
    //..
    //  A...G   original contents of &#39;[toBegin, toEnd)&#39;  (&quot;tail&quot;)
    //  t...z   contents of &#39;[fromBegin, fromEnd)&#39;       (&quot;input&quot;)
    //  _____   uninitialized array element
    //  [...]   part of array guarded by exception guard
    //  |.(.,.) part of array guarded by move guard
    //          (middle indicated by &#39;,&#39; and dest by &#39;|&#39;)
    //..

    const size_type tailLen  = toEnd - toBegin;

    //..
    //  Transformation: ABCDE____ =&gt; ____ABCDE (might overlap).
    //..

    void **destBegin = toBegin + numElements;

    std::memmove(destBegin, toBegin, tailLen * sizeof(void **));

    for (size_type i = 0; i &lt; numElements; ++i) {
        *toBegin = reinterpret_cast&lt;void *&gt;(*fromBegin);

        ++fromBegin;
        ++toBegin;
    }
}

                       // *** &#39;moveInsert&#39; overloads: ***

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives_Imp::moveInsert(
                         TARGET_TYPE                              *toBegin,
                         TARGET_TYPE                              *toEnd,
                         TARGET_TYPE                             **lastPtr,
                         TARGET_TYPE                              *first,
                         TARGET_TYPE                              *last,
                         size_type                                 numElements,
                         ALLOCATOR                                *allocator,
                         bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt;  *)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin, toEnd));
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(first, last));
    BSLS_ASSERT_SAFE(first || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));
    BSLS_ASSERT_SAFE(lastPtr);

    // Functionally indistinguishable from this:

    *lastPtr = last;
    insert(toBegin, toEnd, first, last, numElements, allocator,
           (bslmf::MetaInt&lt;e_BITWISE_COPYABLE_TRAITS&gt;*)0);
    *lastPtr = first;
}

template &lt;class TARGET_TYPE, class ALLOCATOR&gt;
inline
void ArrayPrimitives_Imp::moveInsert(TARGET_TYPE                 *toBegin,
                                     TARGET_TYPE                 *toEnd,
                                     TARGET_TYPE                **lastPtr,
                                     TARGET_TYPE                 *first,
                                     TARGET_TYPE                 *last,
                                     size_type                    numElements,
                                     ALLOCATOR                   *allocator,
                                     bslmf::MetaInt&lt;e_NIL_TRAITS&gt;  *)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(toBegin, toEnd));
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(first, last));
    BSLS_ASSERT_SAFE(first || 0 == numElements);
    BSLMF_ASSERT((bsl::is_same&lt;size_type, std::size_t&gt;::value));
    BSLS_ASSERT_SAFE(lastPtr);

    // There isn&#39;t any advantage at destroying [first,last) one by one as we&#39;re
    // moving it, except perhaps for slightly better memory usage.

    *lastPtr = last;
    insert(toBegin, toEnd, first, last, numElements, allocator,
           (bslmf::MetaInt&lt;e_NIL_TRAITS&gt;*)0);
    ArrayDestructionPrimitives::destroy(first, last);
    *lastPtr = first;
}

                         // *** &#39;rotate&#39; overloads: ***

template &lt;class TARGET_TYPE&gt;
inline
void ArrayPrimitives_Imp::rotate(
                               TARGET_TYPE                             *begin,
                               TARGET_TYPE                             *middle,
                               TARGET_TYPE                             *end,
                               bslmf::MetaInt&lt;e_BITWISE_MOVEABLE_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(begin, middle));
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(middle, end));

    bitwiseRotate(reinterpret_cast&lt;char *&gt;(begin),
                  reinterpret_cast&lt;char *&gt;(middle),
                  reinterpret_cast&lt;char *&gt;(end));
}

template &lt;class TARGET_TYPE&gt;
void ArrayPrimitives_Imp::rotate(TARGET_TYPE                *begin,
                                 TARGET_TYPE                *middle,
                                 TARGET_TYPE                *end,
                                 bslmf::MetaInt&lt;e_NIL_TRAITS&gt; *)
{
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(begin, middle));
    BSLS_ASSERT_SAFE(!ArrayPrimitives_Imp::isInvalidRange(middle, end));

    if (begin == middle || middle == end) {
        // This test changes into O(1) what would otherwise be O(N): Do not
        // remove!

        return;                                                       // RETURN
    }

    // This case is simple enough, it should be taken care of on its own.

    const std::size_t numElements = middle - begin;
    const std::size_t remElements = end - middle;

    if (numElements == remElements) {
        for (; middle != end; ++begin, ++middle) {
            TARGET_TYPE tmp(*middle);
            *middle = *begin;
            *begin = tmp;
        }
        return;                                                       // RETURN
    }

    // This algorithm proceeds by decomposing the rotation into cycles, which
    // can then be rotated using a single element buffer.  First we compute the
    // &#39;gcd(end - begin, numElements)&#39; which is the number of cycles in the
    // rotation.

    std::size_t numCycles = end - begin;
    std::size_t remainder = numElements;
    while (remainder != 0) {
        std::size_t t = numCycles % remainder;
        numCycles = remainder;
        remainder = t;
    }

    // Key to the transformation diagrams:
    //..
    //  A...D   Contents of the current cycle
    //  W...Z   Contents of another cycle
    //  _       Elements not in the current cycle
    //..

    for (std::size_t i = 0; i &lt; numCycles; ++i) {
        // Let the current cycle be initially &#39;A__B__C__D__&#39;, (note that its
        // stride is &#39;length / numCycles&#39;) and let (*) denote the current
        // position of &#39;ptr&#39;.

        TARGET_TYPE *ptr = begin; // seed for current cycle:  A(*)__B__C__D__
        TARGET_TYPE  tmp = *ptr;  // value held at the seed:  tmp == A

        if (numElements &lt; remElements) {
            // Rotate the cycle forward by numElements positions (or backward
            // by -(length-numElements)=-remElements positions if crossing the
            // boundary forward).  The transformation is:
            //..
            //  A(*)__B__C__D__ =&gt; B__B(*)__C__D__
            //                  =&gt; B__C__C(*)__D__
            //                  =&gt; B__C__D__D(*)__
            //..
            // The length of the cycle is always &#39;length / numCycles&#39;, but it
            // crosses the range boundaries &#39;numElements / numCycles&#39; times,
            // each triggering an extra assignment in the &#39;if&#39; clause below, so
            // the loop must only be executed:
            //..
            //  (length - numElements) / numCycles = remELements / numCycles
            //..
            // times.

            std::size_t cycleSize = remElements / numCycles;

            for (std::size_t j = 0; j &lt; cycleSize; ++j) {
                if (ptr &gt; begin + remElements) {
                    // Wrap around the range boundaries.  (Note that
                    // &#39;-remElements == numElements - (end - begin)&#39;.)

                    *ptr = *(ptr - remElements);
                    ptr -= remElements;
                }

                *ptr = *(ptr + numElements);
                ptr += numElements;
            }
        }
        else {
            // Rotate the cycle backward by &#39;-remElements&#39; positions (or
            // forward by &#39;numElements&#39; positions if crossing the boundary
            // backward).  The transformation is:
            //..
            //  A(*)__B__C__D__ =&gt; D__B__C__D(*)__
            //                  =&gt; D__B__C(*)__C__
            //                  =&gt; D__B(*)__B__C__
            //..
            // The length of the cycle is always &#39;length/numCycles&#39;, but going
            // backward (which adds an initial extra crossing) crosses the
            // range boundaries &#39;remElements/numCycles+1&#39; times each of which
            // trigger an extra assignment in the &#39;if&#39; clause below, so the
            // loop must only be executed:
            //..
            //  (length - remElements) / numCycles - 1 =
            //                                      numELements / numCycles - 1
            //..
            // times.

            std::size_t cycleSize = numElements / numCycles - 1;

            for (std::size_t j = 0; j &lt; cycleSize; ++j) {
                if (ptr &lt; end - numElements) {
                    *ptr = *(ptr + numElements);
                    ptr += numElements;
                }

                *ptr = *(ptr - remElements);
                ptr -= remElements;
            }
        }

        *ptr = tmp; // Close the cycle, e.g.:
                    //..
                    //  (first case):  B__C__D__D(*)__ =&gt; B__C__D__A__
                    //  (second case): D__D(*)__B__C__ =&gt; D__A__B__C__
                    //..
        ++begin;    // and move on to the next cycle:
                    //..
                    //                                 =&gt; _W__X__Y__Z_
                    //..
    }
}

}  // close package namespace


}  // close enterprise namespace

#if defined(BSLALG_ARRAYPRIMITIVES_CANNOT_REMOVE_POINTER_FROM_FUNCTION_POINTER)
# undef BSLALG_ARRAYPRIMITIVES_CANNOT_REMOVE_POINTER_FROM_FUNCTION_POINTER
#endif

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
