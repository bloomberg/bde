<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlcc_queue.h                                                      -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLCC_QUEUE
#define INCLUDED_BDLCC_QUEUE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a thread-enabled queue of items of parameterized &#39;TYPE&#39;.
//
//@CLASSES:
//   bdlcc::Queue: thread-enabled &#39;bdlc::Queue&#39; wrapper
//
//@SEE_ALSO: bdlc_queue
//
//@DESCRIPTION: This component provides a thread-enabled implementation of an
// efficient, in-place, indexable, double-ended queue of parameterized &#39;TYPE&#39;
// values, namely the &#39;bdlcc::Queue&lt;TYPE&gt;&#39; container.  &#39;bdlcc::Queue&#39; is
// effectively a thread-enabled handle for &#39;bdlc::Queue&#39;, whose interface is
// also made available through &#39;bdlcc::Queue&#39;.
//
///Thread-Enabled Idioms in the &#39;bdlcc::Queue&#39; Interface
///-----------------------------------------------------
// The thread-enabled &#39;bdlcc::Queue&#39; is similar to &#39;bdlc::Queue&#39; in many
// regards, but there are several differences in method behavior and signature
// that arise due to the thread-enabled nature of the queue and its anticipated
// usage pattern.  Most notably, the &#39;popFront&#39; and &#39;popBack&#39; methods return a
// &#39;TYPE&#39; object *by* *value*, rather than returning &#39;void&#39;, as &#39;bdlc::Queue&#39;
// does.  Moreover, if a queue object is empty, &#39;popFront&#39; and &#39;popBack&#39; will
// block indefinitely until an item is added to the queue.
//
// As a corollary to this behavior choice, &#39;bdlcc::Queue&#39; also provides
// &#39;timedPopFront&#39; and &#39;timedPopBack&#39; methods.  These methods wait until a
// specified timeout expires if the queue is empty, returning an item if one
// becomes available before the specified timeout; otherwise, they return a
// non-zero value to indicate that the specified timeout expired before an item
// was available.  Note that *all* timeouts are expressed as values of type
// &#39;bsls::TimeInterval&#39; that represent !ABSOLUTE! times from 00:00:00 UTC,
// January 1, 1970.
//
// The behavior of the &#39;push&#39; methods differs in a similar manner.
// &#39;bdlcc::Queue&#39; supports the notion of a suggested maximum queue size, called
// the &quot;high-water mark&quot;, a value supplied at construction.  The &#39;pushFront&#39;
// and &#39;pushBack&#39; methods will block indefinitely if the queue contains (at
// least) the high-water mark number of items, until the number of items falls
// below the high-water mark.  The &#39;timedPushFront&#39; and &#39;timedPushBack&#39; are
// provided to limit the duration of blocking; note, however, that these
// methods can fail to add an item to the queue.  For this reason,
// &#39;bdlcc::Queue&#39; also provides a &#39;forcePushFront&#39; method that will override
// the high-water mark, if needed, in order to succeed without blocking.  Note
// that this design decision makes the high-water mark concept a suggestion and
// not an invariant.
//
///Use of the &#39;bdlc::Queue&#39; Interface
///----------------------------------
// Class &#39;bdlcc::Queue&#39; provides access to an underlying &#39;bdlc::Queue&#39;, so
// clients of &#39;bdlcc::Queue&#39; have full access to the interface behavior of
// &#39;bdlc::Queue&#39; to inspect and modify the &#39;bdlcc::Queue&#39;.
//
// Member function &#39;bdlcc::Queue::queue()&#39; provides *direct* modifiable access
// to the &#39;bdlc::Queue&#39; object used in the implementation.  Member functions
// &#39;bdlcc::Queue::mutex()&#39;, &#39;bdlcc::Queue::notEmptyCondition()&#39;, and
// &#39;bdlcc::Queue::notFullCondition()&#39; correspondingly provide *direct*
// modifiable access to the underlying &#39;bslmt::Mutex&#39; and &#39;bslmt::Condition&#39;
// objects respectively.  These underlying objects are used within
// &#39;bdlcc::Queue&#39; to manage concurrent access to the queue.  Clients may use
// these member variables together if needed.
//
// Whenever accessing the &#39;bdec&#39; queue directly, clients must be sure to lock
// and unlock the mutex or to signal or broadcast on the condition variable as
// appropriate.  For example, a client might use the underlying queue and mutex
// as follows:
//..
//     bdlcc::Queue&lt;myData&gt;  myWorkQueue;
//     bdlc::Queue&lt;myData&gt;&amp; rawQueue = myWorkQueue.queue();
//     bslmt::Mutex&amp;        queueMutex = myWorkQueue.mutex();
//         // other code omitted...
//
//     myData  data1;
//     myData  data2;
//     bool pairFoundFlag = 0;
//     // Take two items from the queue atomically, if available.
//
//     queueMutex.lock();
//     if (rawQueue.length() &gt;= 2) {
//         data1 = rawQueue.front();
//         rawQueue.popFront();
//         data2 = rawQueue.front();
//         rawQueue.popFront();
//         pairFound = 1;
//     }
//     queueMutex.unlock();
//
//     if (pairFoundFlag) {
//         // Process the pair
//     }
//..
// Note that a future version of this component will provide access to a
// thread-safe &quot;smart pointer&quot; that will manage the &#39;bdlc::Queue&#39; with respect
// to locking and signaling.  At that time, direct access to the &#39;bdlc::Queue&#39;
// will be deprecated.  In the meanwhile, the user should be careful to use the
// &#39;bdlc::Queue&#39; and the synchronization objects properly.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Simple Thread Pool
///- - - - - - - - - - - - - - -
// The following example demonstrates a typical usage of a &#39;bdlcc::Queue&#39;.
//
// This &#39;bdlcc::Queue&#39; is used to communicate between a single &quot;producer&quot;
// thread and multiple &quot;consumer&quot; threads.  The &quot;producer&quot; will push work
// requests onto the queue, and each &quot;consumer&quot; will iteratively take a work
// request from the queue and service the request.  This example shows a
// partial, simplified implementation of the &#39;bdlmt::ThreadPool&#39; class.  See
// component &#39;bdlmt_threadpool&#39; for more information.
//
// We begin our example with some utility classes that define a simple &quot;work
// item&quot;:
//..
//  enum {
//      k_MAX_CONSUMER_THREADS = 10
//  };
//
//  struct my_WorkData {
//      // Work data...
//  };
//
//  struct my_WorkRequest {
//      enum RequestType {
//          e_WORK = 1,
//          e_STOP = 2
//      };
//
//      RequestType d_type;
//      my_WorkData d_data;
//      // Work data...
//  };
//..
// Next, we provide a simple function to service an individual work item.  The
// details are unimportant for this example.
//..
//  void myDoWork(my_WorkData&amp; data)
//  {
//      // do some stuff...
//      (void)data;
//  }
//..
// The &#39;myConsumer&#39; function will pop items off the queue and process them.  As
// discussed above, note that the call to &#39;queue-&gt;popFront()&#39; will block until
// there is an item available on the queue.  This function will be executed in
// multiple threads, so that each thread waits in &#39;queue-&gt;popFront()&#39;, and
// &#39;bdlcc::Queue&#39; guarantees that each thread gets a unique item from the
// queue.
//..
//  void myConsumer(bdlcc::Queue&lt;my_WorkRequest&gt; *queue)
//  {
//      while (1) {
//          // &#39;popFront()&#39; will wait for a &#39;my_WorkRequest&#39; until available.
//
//          my_WorkRequest item = queue-&gt;popFront();
//          if (item.d_type == my_WorkRequest::e_STOP) break;
//          myDoWork(item.d_data);
//      }
//  }
//..
// The function below is a callback for &#39;bslmt::ThreadUtil&#39;, which requires a
// &quot;C&quot; signature.  &#39;bslmt::ThreadUtil::create()&#39; expects a pointer to this
// function, and provides that function pointer to the newly created thread.
// The new thread then executes this function.
//
// Since &#39;bslmt::ThreadUtil::create()&#39; uses the familiar &quot;C&quot; convention of
// passing a &#39;void&#39; pointer, our function simply casts that pointer to our
// required type (&#39;bdlcc::Queue&lt;my_WorkRequest*&gt; *&#39;), and then delegates to the
// queue-specific function &#39;myConsumer&#39;, above.
//..
//  extern &quot;C&quot; void *myConsumerThread(void *queuePtr)
//  {
//      myConsumer ((bdlcc::Queue&lt;my_WorkRequest&gt; *)queuePtr);
//      return queuePtr;
//  }
//..
// In this simple example, the &#39;myProducer&#39; function serves multiple roles: it
// creates the &#39;bdlcc::Queue&#39;, starts out the consumer threads, and then
// produces and queues work items.  When work requests are exhausted, this
// function queues one &#39;STOP&#39; item for each consumer queue.
//
// When each Consumer thread reads a &#39;STOP&#39;, it terminates its thread-handling
// function.  Note that, although the producer cannot control which thread
// &#39;pop&#39;s a particular work item, it can rely on the knowledge that each
// Consumer thread will read a single &#39;STOP&#39; item and then terminate.
//
// Finally, the &#39;myProducer&#39; function &quot;joins&quot; each Consumer thread, which
// ensures that the thread itself will terminate correctly; see the
// &#39;bslmt_threadutil&#39; component for details.
//..
//  void myProducer(int numThreads)
//  {
//      my_WorkRequest item;
//      my_WorkData    workData;
//
//      bdlcc::Queue&lt;my_WorkRequest&gt; queue;
//
//      assert(0 &lt; numThreads &amp;&amp; numThreads &lt;= k_MAX_CONSUMER_THREADS);
//      bslmt::ThreadUtil::Handle consumerHandles[k_MAX_CONSUMER_THREADS];
//
//      for (int i = 0; i &lt; numThreads; ++i) {
//          bslmt::ThreadUtil::create(&amp;consumerHandles[i],
//                                    myConsumerThread,
//                                    &amp;queue);
//      }
//
//      while (!getWorkData(&amp;workData)) {
//          item.d_type = my_WorkRequest::e_WORK;
//          item.d_data = workData;
//          queue.pushBack(item);
//      }
//
//      for (int i = 0; i &lt; numThreads; ++i) {
//          item.d_type = my_WorkRequest::e_STOP;
//          queue.pushBack(item);
//      }
//
//      for (int i = 0; i &lt; numThreads; ++i) {
//          bslmt::ThreadUtil::join(consumerHandles[i]);
//      }
//  }
//..
//
///Example 2: Multi-Threaded Observer
/// - - - - - - - - - - - - - - - - -
// The previous example shows a simple mechanism for distributing work requests
// over multiple threads.  This approach works well for large tasks that can be
// decomposed into discrete, independent tasks that can benefit from parallel
// execution.  Note also that the various threads are synchronized only at the
// end of execution, when the Producer &quot;joins&quot; the various consumer threads.
//
// The simple strategy used in the first example works well for tasks that
// share no state, and are completely independent of one another.  For
// instance, a web server might use a similar strategy to distribute http
// requests across multiple worker threads.
//
// In more complicated examples, it is often necessary or desirable to
// synchronize the separate tasks during execution.  The second example below
// shows a single &quot;Observer&quot; mechanism that receives event notification from
// the various worker threads.
//
// We first create a simple &#39;my_Event&#39; data type.  Worker threads will use this
// data type to report information about their work.  In our example, we will
// report the &quot;worker Id&quot;, the event number, and some arbitrary text.
//
// As with the previous example, class &#39;my_Event&#39; also contains an &#39;EventType&#39;,
// which is an enumeration which that indicates whether the worker has
// completed all work.  The &quot;Observer&quot; will use this enumerated value to note
// when a Worker thread has completed its work.
//..
//  enum {
//      k_MAX_CONSUMER_THREADS = 10,
//      k_MAX_EVENT_TEXT       = 80
//  };
//
//  struct my_Event {
//      enum EventType {
//          e_IN_PROGRESS   = 1,
//          e_TASK_COMPLETE = 2
//      };
//
//      EventType d_type;
//      int       d_workerId;
//      int       d_eventNumber;
//      char      d_eventText[k_MAX_EVENT_TEXT];
//  };
//..
// As noted in the previous example, &#39;bslmt::ThreadUtil::create()&#39; spawns a new
// thread, which invokes a simple &quot;C&quot; function taking a &#39;void&#39; pointer.  In the
// previous example, we simply converted that &#39;void&#39; pointer into a pointer to
// the parameterized &#39;bdlcc::Queue&lt;TYPE&gt;&#39; object.
//
// In this example, we want to pass an additional data item.  Each worker
// thread is initialized with a unique integer value (&quot;worker Id&quot;) that
// identifies that thread.  We create a simple data structure that contains
// both of these values:
//..
//  struct my_WorkerData {
//      int                     d_workerId;
//      bdlcc::Queue&lt;my_Event&gt; *d_queue_p;
//  };
//..
// Function &#39;myWorker&#39; simulates a working thread by enqueuing multiple
// &#39;my_Event&#39; events during execution.  In a normal application, each
// &#39;my_Event&#39; structure would likely contain different textual information; for
// the sake of simplicity, our loop uses a constant value for the text field.
//..
//  void myWorker(int workerId, bdlcc::Queue&lt;my_Event&gt; *queue)
//  {
//      const int NEVENTS = 5;
//      int evnum;
//
//      for (evnum = 0; evnum &lt; NEVENTS; ++evnum) {
//          my_Event ev = {
//              my_Event::e_IN_PROGRESS,
//              workerId,
//              evnum,
//              &quot;In-Progress Event&quot;
//          };
//          queue-&gt;pushBack(ev);
//      }
//
//      my_Event ev = {
//          my_Event::e_TASK_COMPLETE,
//          workerId,
//          evnum,
//          &quot;Task Complete&quot;
//      };
//      queue-&gt;pushBack(ev);
//  }
//..
// The callback function invoked by &#39;bslmt::ThreadUtil::create()&#39; takes the
// traditional &#39;void&#39; pointer.  The expected data is the composite structure
// &#39;my_WorkerData&#39;.  The callback function casts the &#39;void&#39; pointer to the
// application-specific data type and then uses the referenced object to
// construct a call to the &#39;myWorker&#39; function.
//..
//  extern &quot;C&quot; void *myWorkerThread(void *v_worker_p)
//  {
//      my_WorkerData *worker_p = (my_WorkerData *) v_worker_p;
//      myWorker(worker_p-&gt;d_workerId, worker_p-&gt;d_queue_p);
//      return v_worker_p;
//  }
//..
// For the sake of simplicity, we will implement the Observer behavior in the
// main thread.  The &#39;void&#39; function &#39;myObserver&#39; starts out multiple threads
// running the &#39;myWorker&#39; function, reads &#39;my_Event&#39;s from the queue, and logs
// all messages in the order of arrival.
//
// As each &#39;myWorker&#39; thread terminates, it sends a &#39;e_TASK_COMPLETE&#39; event.
// Upon receiving this event, the &#39;myObserver&#39; function uses the &#39;d_workerId&#39;
// to find the relevant thread, and then &quot;joins&quot; that thread.
//
// The &#39;myObserver&#39; function determines when all tasks have completed simply by
// counting the number of &#39;e_TASK_COMPLETE&#39; messages received.
//..
//  void myObserver()
//  {
//      const int NTHREADS = 10;
//      bdlcc::Queue&lt;my_Event&gt; queue;
//
//      assert(NTHREADS &gt; 0 &amp;&amp; NTHREADS &lt;= k_MAX_CONSUMER_THREADS);
//      bslmt::ThreadUtil::Handle workerHandles[k_MAX_CONSUMER_THREADS];
//
//      my_WorkerData workerData;
//      workerData.d_queue_p = &amp;queue;
//      for (int i = 0; i &lt; NTHREADS; ++i) {
//          workerData.d_workerId = i;
//          bslmt::ThreadUtil::create(&amp;workerHandles[i],
//                                    myWorkerThread,
//                                    &amp;workerData);
//      }
//      int nStop = 0;
//      while (nStop &lt; NTHREADS) {
//          my_Event ev = queue.popFront();
//          bsl::cout &lt;&lt; &quot;[&quot; &lt;&lt; ev.d_workerId    &lt;&lt; &quot;] &quot;
//                           &lt;&lt; ev.d_eventNumber &lt;&lt; &quot;. &quot;
//                           &lt;&lt; ev.d_eventText   &lt;&lt; bsl::endl;
//          if (my_Event::e_TASK_COMPLETE == ev.d_type) {
//              ++nStop;
//              bslmt::ThreadUtil::join(workerHandles[ev.d_workerId]);
//          }
//      }
//  }
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMT_LOCKGUARD
#include &lt;bslmt_lockguard.h&gt;
#endif

#ifndef INCLUDED_BSLMT_CONDITION
#include &lt;bslmt_condition.h&gt;
#endif

#ifndef INCLUDED_BSLMT_MUTEX
#include &lt;bslmt_mutex.h&gt;
#endif

#ifndef INCLUDED_BSLMT_THREADUTIL
#include &lt;bslmt_threadutil.h&gt;
#endif

#ifndef INCLUDED_BDLC_QUEUE
#include &lt;bdlc_queue.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include &lt;bslalg_typetraits.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLS_TIMEINTERVAL
#include &lt;bsls_timeinterval.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {
namespace bdlcc {

                                // ===========
                                // class Queue
                                // ===========

template &lt;class TYPE&gt;
class Queue {
    // This class provides a thread-enabled implementation of an efficient,
    // in-place, indexable, double-ended queue of parameterized &#39;TYPE&#39; values.
    // Very efficient access to the underlying &#39;bdlc::Queue&#39; object is
    // provided, as well as to a &#39;bslmt::Mutex&#39; and a &#39;bslmt::Condition&#39;
    // variable, to facilitate thread-safe use of the &#39;bdlc::Queue&#39;.  Note that
    // &#39;Queue&#39; is not a value-semantic type, but the underlying &#39;bdlc::Queue&#39;
    // is.  In this regard, &#39;Queue&#39; is a thread-enabled handle for a
    // &#39;bdlc::Queue&#39;.

    // PRIVATE TYPES
    typedef typename bdlc::Queue&lt;TYPE&gt;::InitialCapacity QueueCapacity;
                                          // We need this typedef to work
                                          // around a bug in Sun WorkShop 6
                                          // update 1: if the typedef is
                                          // replaced by its actual definition
                                          // in the two constructors
                                          // initialization list, the compiler
                                          // erroneously reports a syntax error
                                          // (&quot;Expected an expression&quot;).

    // DATA
    mutable
    bslmt::Mutex      d_mutex;             // mutex object used to synchronize
                                          // access to this queue

    bslmt::Condition  d_notEmptyCondition; // condition variable used to signal
                                          // that new data is available in the
                                          // queue

    bslmt::Condition  d_notFullCondition;  // condition variable used to signal
                                          // when there is room available to
                                          // add new data to the queue

    bdlc::Queue&lt;TYPE&gt; d_queue;             // the queue, with allocator as last
                                          // data member

    int              d_highWaterMark;     // positive maximum number of items
                                          // that can be queued before
                                          // insertions will be blocked, or
                                          // -1 if unlimited

  private:
    // NOT IMPLEMENTED
    Queue(const Queue&lt;TYPE&gt;&amp;);
    Queue&lt;TYPE&gt;&amp; operator=(const Queue&lt;TYPE&gt;&amp;);

  public:
    // TRAITS
    BSLALG_DECLARE_NESTED_TRAITS(Queue, bslalg::TypeTraitUsesBslmaAllocator);

    // TYPES
    struct InitialCapacity {
        // Enable uniform use of an optional integral constructor argument to
        // specify the initial internal capacity (in items).  For example,
        //..
        //   const Queue&lt;int&gt;::InitialCapacity NUM_ITEMS(8));
        //   Queue&lt;int&gt; x(NUM_ITEMS);
        //..
        // defines an instance &#39;x&#39; with an initial capacity of 8 items, but
        // with a logical length of 0 items.

        // DATA
        unsigned int d_i;

        // CREATORS
        explicit InitialCapacity(int i)
        : d_i(i)
            // Create an object with the specified value &#39;i&#39;.
        {}
    };

    // CREATORS
    explicit
    Queue(bslma::Allocator *basicAllocator = 0);
        // Create a queue of objects of parameterized &#39;TYPE&#39;.  Optionally
        // specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    explicit
    Queue(int highWaterMark, bslma::Allocator *basicAllocator = 0);
        // Create a queue of objects of parameterized &#39;TYPE&#39; having either the
        // specified &#39;highWaterMark&#39; suggested maximum length if
        // &#39;highWaterMark&#39; is positive, or no maximum length if &#39;highWaterMark&#39;
        // is negative.  Optionally specify a &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.  The behavior is undefined unless
        // &#39;highWaterMark != 0&#39;.

    explicit
    Queue(const InitialCapacity&amp;  numItems,
          bslma::Allocator       *basicAllocator = 0);
        // Create a queue of objects of parameterized &#39;TYPE&#39; with sufficient
        // initial capacity to accommodate up to the specified &#39;numItems&#39;
        // values without subsequent reallocation.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    Queue(const InitialCapacity&amp;  numItems,
          int                     highWaterMark,
          bslma::Allocator       *basicAllocator = 0);
        // Create a queue of objects of parameterized &#39;TYPE&#39; with sufficient
        // initial capacity to accommodate up to the specified &#39;numItems&#39;
        // values without subsequent reallocation and having either the
        // specified &#39;highWaterMark&#39; suggested maximum length if
        // &#39;highWaterMark&#39; is positive, or no maximum length if &#39;highWaterMark&#39;
        // is negative.  Optionally specify a &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.  The behavior is undefined unless
        // &#39;highWaterMark != 0&#39;.

    Queue(const bdlc::Queue&lt;TYPE&gt;&amp;  srcQueue,
          bslma::Allocator         *basicAllocator = 0);        // IMPLICIT
        // Create a queue of objects of parameterized &#39;TYPE&#39; containing the
        // sequence of &#39;TYPE&#39; values from the specified &#39;srcQueue&#39;.  Optionally
        // specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    Queue(const bdlc::Queue&lt;TYPE&gt;&amp;  srcQueue,
          int                       highWaterMark,
          bslma::Allocator         *basicAllocator = 0);
        // Create a queue of objects of parameterized &#39;TYPE&#39; containing the
        // sequence of &#39;TYPE&#39; values from the specified &#39;srcQueue&#39; and having
        // either the specified &#39;highWaterMark&#39; suggested maximum length if
        // &#39;highWaterMark&#39; is positive, or no maximum length if &#39;highWaterMark&#39;
        // is negative.  Optionally specify a &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.  The behavior is undefined unless
        // &#39;highWaterMark != 0&#39;.

    ~Queue();
        // Destroy this queue.

    // MANIPULATORS
    void popBack(TYPE *buffer);
        // Remove the last item in this queue and load that item into the
        // specified &#39;buffer&#39;.  If this queue is empty, block until an item is
        // available.

    TYPE popBack();
        // Remove the last item in this queue and return that item value.  If
        // this queue is empty, block until an item is available.

    int timedPopBack(TYPE *buffer, const bsls::TimeInterval&amp; timeout);
        // Remove the last item in this queue and load that item value into the
        // specified &#39;buffer&#39;.  If this queue is empty, block until an item is
        // available or until the specified &#39;timeout&#39; (expressed as the
        // !ABSOLUTE! time from 00:00:00 UTC, January 1, 1970) expires.  Return
        // 0 on success, and a non-zero value if the call timed out before an
        // item was available.

    void popFront(TYPE *buffer);
        // Remove the first item in this queue and load that item into the
        // specified &#39;buffer&#39;.  If the queue is empty, block until an item is
        // available.

    TYPE popFront();
        // Remove the first item in this queue and return that item value.  If
        // the queue is empty, block until an item is available.

    int timedPopFront(TYPE *buffer, const bsls::TimeInterval&amp; timeout);
        // Remove the first item in this queue and load that item value into
        // the specified &#39;buffer&#39;.  If this queue is empty, block until an item
        // is available or until the specified &#39;timeout&#39; (expressed as the
        // !ABSOLUTE! time from 00:00:00 UTC, January 1, 1970) expires.  Return
        // 0 on success, and a non-zero value if the call timed out before an
        // item was available.

    void removeAll(bsl::vector&lt;TYPE&gt; *buffer = 0);
        // Remove all the items in this queue.  If the optionally specified
        // &#39;buffer&#39; is not 0, load into &#39;buffer&#39; a copy of the items removed in
        // front to back order of the queue prior to &#39;removeAll&#39;.

    void pushBack(const TYPE&amp; item);
        // Append the specified &#39;item&#39; to the back of this queue.  If the
        // high-water mark is non-negative and the number of items in this
        // queue is greater than or equal to the high-water mark, then block
        // until the number of items in this queue is less than the high-water
        // mark.

    void pushFront(const TYPE&amp; item);
        // Append the specified &#39;item&#39; to the front of this queue.  If the
        // high-water mark is non-negative and the number of items in this
        // queue is greater than or equal to the high-water mark, then block
        // until the number of items in this queue is less than the high-water
        // mark.

    int timedPushBack(const TYPE&amp; item, const bsls::TimeInterval&amp; timeout);
        // Append the specified &#39;item&#39; to the back of this queue.  If the
        // high-water mark is non-negative and the number of items in this
        // queue is greater than or equal to the high-water mark, then block
        // until the number of items in this queue is less than the high-water
        // mark or until the specified &#39;timeout&#39; (expressed as the !ABSOLUTE!
        // time from 00:00:00 UTC, January 1, 1970) expires.  Return 0 on
        // success, and a non-zero value if the call timed out before the
        // number of items in this queue fell below the high-water mark.

    int timedPushFront(const TYPE&amp; item, const bsls::TimeInterval&amp; timeout);
        // Append the specified &#39;item&#39; to the front of this queue.  If the high
        // water mark is non-negative and the number of items in this queue is
        // greater than or equal to the high-water mark, then block until the
        // number of items in this queue is less than the high-water mark or
        // until the specified &#39;timeout&#39; (expressed as the !ABSOLUTE! time from
        // 00:00:00 UTC, January 1, 1970) expires.  Return 0 on success, and a
        // non-zero value if the call timed out before the number of items in
        // this queue fell below the high-water mark.

    void forcePushFront(const TYPE&amp; item);
        // Append the specified &#39;item&#39; to the front of this queue without
        // regard for the high-water mark.  Note that this method is provided
        // to allow high priority items to be inserted when the queue is full
        // (i.e., has a number of items greater than or equal to its high-water
        // mark); &#39;pushFront&#39; and &#39;pushBack&#39; should be used for general use.

    int tryPopFront(TYPE *buffer);
        // If this queue is non-empty, remove the first item, load that item
        // into the specified &#39;buffer&#39;, and return 0 indicating success.  If
        // this queue is empty, return a non-zero value with no effect on
        // &#39;buffer&#39; or the state of this queue.  This method never blocks.

    void tryPopFront(int maxNumItems, bsl::vector&lt;TYPE&gt; *buffer = 0);
        // Remove up to the specified &#39;maxNumItems&#39; from the front of this
        // queue.  Optionally specify a &#39;buffer&#39; into which the items removed
        // from the queue are loaded.  If &#39;buffer&#39; is non-null, the removed
        // items are appended to it as if by repeated application of
        // &#39;buffer-&gt;push_back(popFront())&#39; while the queue is not empty and
        // &#39;maxNumItems&#39; have not yet been removed.  The behavior is undefined
        // unless &#39;maxNumItems &gt;= 0&#39;.  This method never blocks.

    int tryPopBack(TYPE *buffer);
        // If this queue is non-empty, remove the last item, load that item
        // into the specified &#39;buffer&#39;, and return 0 indicating success.  If
        // this queue is empty, return a non-zero value with no effect on
        // &#39;buffer&#39; or the state of this queue.  This method never blocks.

    void tryPopBack(int maxNumItems, bsl::vector&lt;TYPE&gt; *buffer = 0);
        // Remove up to the specified &#39;maxNumItems&#39; from the back of this
        // queue.  Optionally specify a &#39;buffer&#39; into which the items removed
        // from the queue are loaded.  If &#39;buffer&#39; is non-null, the removed
        // items are appended to it as if by repeated application of
        // &#39;buffer-&gt;push_back(popBack())&#39; while the queue is not empty and
        // &#39;maxNumItems&#39; have not yet been removed.  This method never blocks.
        // The behavior is undefined unless &#39;maxNumItems &gt;= 0&#39;.  Note that the
        // ordering of the items in &#39;*buffer&#39; after the call is the reverse of
        // the ordering they had in the queue.

    // *** Modifiable access to the mutex, condition variable, and queue ***

    bslmt::Condition&amp; condition();
        // Return a reference to the modifiable condition variable used by this
        // queue to signal that the queue is not empty.
        //
        // *DEPRECATED* Use &#39;notEmptyCondition&#39; instead.

    bslmt::Condition&amp; insertCondition();
        // Return a reference to the modifiable condition variable used by this
        // queue to signal that the queue is not full (i.e., has fewer items
        // than its high-water mark).
        //
        // *DEPRECATED* Use &#39;notFullCondition&#39; instead.

    bslmt::Mutex&amp; mutex();
        // Return a reference to the modifiable mutex used by this queue to
        // synchronize access to its underlying &#39;bdlc::Queue&#39; object.

    bslmt::Condition&amp; notEmptyCondition();
        // Return the condition variable used by this queue to signal that the
        // queue is not empty.

    bslmt::Condition&amp; notFullCondition();
        // Return the condition variable used by this queue to signal that the
        // queue is not full (i.e., has fewer items than its high-water mark).

    bdlc::Queue&lt;TYPE&gt;&amp; queue();
        // Return a reference to the modifiable underlying &#39;bdlc::Queue&#39; object
        // used by this queue.  Any access to the returned queue MUST first
        // lock the associated mutex object (see the &#39;mutex&#39; method) in a
        // multi-threaded environment.  And when items are directly added to
        // the queue returned by this method, the associated condition variable
        // (see the &#39;condition&#39; method) should be signaled to notify any
        // waiting threads of the availability of the new data.
        //
        // The (error-prone) usage of this method will be replaced by an
        // appropriate smart-pointer-like proctor object in the future.
        // Meanwhile, use this method with caution.

    // ACCESSORS
    int highWaterMark() const;
        // Return the high-water mark value for this queue.  Note that a
        // negative value indicates no suggested-maximum capacity, and is not
        // necessarily the same negative value that was passed to the
        // constructor.

    int length() const;
        // Return the number of elements in this queue.  Note that if other
        // threads are manipulating the queue, this information may be obsolete
        // by the time it is returned.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

// CREATORS
template &lt;class TYPE&gt;
inline
Queue&lt;TYPE&gt;::Queue(bslma::Allocator *basicAllocator)
: d_queue(basicAllocator)
, d_highWaterMark(-1)
{
}

template &lt;class TYPE&gt;
inline
Queue&lt;TYPE&gt;:: Queue(const InitialCapacity&amp;  numItems,
                    bslma::Allocator       *basicAllocator)
: d_queue(QueueCapacity(numItems.d_i), basicAllocator)
, d_highWaterMark(-1)
{
}

template &lt;class TYPE&gt;
inline
Queue&lt;TYPE&gt;::Queue(int highWaterMark, bslma::Allocator *basicAllocator)
: d_queue(basicAllocator)
, d_highWaterMark(highWaterMark &lt; 0 ? -1 : highWaterMark)
{
}

template &lt;class TYPE&gt;
inline
Queue&lt;TYPE&gt;::Queue(const InitialCapacity&amp;  numItems,
                   int                     highWaterMark,
                   bslma::Allocator       *basicAllocator)
: d_queue(QueueCapacity(numItems.d_i), basicAllocator)
, d_highWaterMark(highWaterMark &lt; 0 ? -1 : highWaterMark)
{
}

template &lt;class TYPE&gt;
inline
Queue&lt;TYPE&gt;::Queue(const bdlc::Queue&lt;TYPE&gt;&amp;  srcQueue,
                   bslma::Allocator         *basicAllocator)
: d_queue(srcQueue, basicAllocator)
, d_highWaterMark(-1)
{
}

template &lt;class TYPE&gt;
inline
Queue&lt;TYPE&gt;::Queue(const bdlc::Queue&lt;TYPE&gt;&amp;  srcQueue,
                   int                       highWaterMark,
                   bslma::Allocator         *basicAllocator)
: d_queue(srcQueue, basicAllocator)
, d_highWaterMark(highWaterMark &lt; 0 ? -1 : highWaterMark)
{
}

template &lt;class TYPE&gt;
inline
Queue&lt;TYPE&gt;::~Queue()
{
}

// MANIPULATORS
template &lt;class TYPE&gt;
void Queue&lt;TYPE&gt;::popBack(TYPE *buffer)
{
    unsigned int length;

    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);

    while (0 == (length = d_queue.length())) {
        d_notEmptyCondition.wait(&amp;d_mutex);
    }
    *buffer = d_queue.back();
    d_queue.popBack();
    --length;

    if (length &lt; (unsigned) d_highWaterMark) {
        d_notFullCondition.signal();
    }
}

template &lt;class TYPE&gt;
TYPE Queue&lt;TYPE&gt;::popBack()
{
    // Note that this method is not implemented in terms of &#39;popBack(TYPE*)&#39;
    // because that would require TYPE to have a default constructor.

    unsigned int length;

    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);

    while (0 == (length = d_queue.length())) {
        d_notEmptyCondition.wait(&amp;d_mutex);
    }
    TYPE back = d_queue.back();
    d_queue.popBack();
    --length;

    if (length &lt; (unsigned) d_highWaterMark) {
        d_notFullCondition.signal();
    }
    return back;
}

template &lt;class TYPE&gt;
int Queue&lt;TYPE&gt;::timedPopBack(TYPE *buffer, const bsls::TimeInterval&amp; timeout)
{
    unsigned int length;

    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);

    while (0 == (length = d_queue.length())) {
        if (d_notEmptyCondition.timedWait(&amp;d_mutex, timeout)) {
            return 1;                                                 // RETURN
        }
    }
    *buffer = d_queue.back();
    d_queue.popBack();
    --length;

    if (length &lt; (unsigned) d_highWaterMark) {
        d_notFullCondition.signal();
    }
    return 0;
}

template &lt;class TYPE&gt;
void Queue&lt;TYPE&gt;::popFront(TYPE *buffer)
{
    unsigned int length;

    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);

    while (0 == (length = d_queue.length())) {
        d_notEmptyCondition.wait(&amp;d_mutex);
    }
    *buffer = d_queue.front();
    d_queue.popFront();
    --length;

    if (length &lt; (unsigned) d_highWaterMark) {
        d_notFullCondition.signal();
    }
}

template &lt;class TYPE&gt;
TYPE Queue&lt;TYPE&gt;::popFront()
{
    // Note that this method is not implemented in terms of &#39;popFront(TYPE*)&#39;
    // because that would require TYPE to have a default constructor.

    unsigned int length;

    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);

    while (0 == (length = d_queue.length())) {
        d_notEmptyCondition.wait(&amp;d_mutex);
    }
    TYPE front = d_queue.front();
    d_queue.popFront();
    --length;

    if (length &lt; (unsigned) d_highWaterMark) {
        d_notFullCondition.signal();
    }
    return front;
}

template &lt;class TYPE&gt;
int Queue&lt;TYPE&gt;::timedPopFront(TYPE *buffer, const bsls::TimeInterval&amp; timeout)
{
    unsigned int length;

    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);

    while (0 == (length = d_queue.length())) {
        if (d_notEmptyCondition.timedWait(&amp;d_mutex, timeout)) {
            return 1;                                                 // RETURN
        }
    }
    *buffer = d_queue.front();
    d_queue.popFront();
    --length;

    if (length &lt; (unsigned) d_highWaterMark) {
        d_notFullCondition.signal();
    }
    return 0;
}

template &lt;class TYPE&gt;
int Queue&lt;TYPE&gt;::tryPopFront(TYPE *buffer)
{
    unsigned int length;

    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);

    if (0 == (length = d_queue.length())) {
        return 1;                                                     // RETURN
    }
    *buffer = d_queue.front();
    d_queue.popFront();
    --length;

    if (length &lt; (unsigned) d_highWaterMark) {
        d_notFullCondition.signal();
    }
    return 0;
}

template &lt;class TYPE&gt;
void Queue&lt;TYPE&gt;::tryPopFront(int maxNumItems, bsl::vector&lt;TYPE&gt; *buffer)
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);

    int        length  = d_queue.length();
    const bool wasFull = d_highWaterMark &gt; 0 &amp;&amp; length &gt;= d_highWaterMark;

    for (; d_queue.length() &gt; 0 &amp;&amp; maxNumItems &gt; 0; --maxNumItems) {
        if (buffer) {
            buffer-&gt;push_back(d_queue.front());
        }
        d_queue.popFront();
        --length;
        if (wasFull &amp;&amp; length &lt; d_highWaterMark) {
            d_notFullCondition.signal();
        }
    }
}

template &lt;class TYPE&gt;
int Queue&lt;TYPE&gt;::tryPopBack(TYPE *buffer)
{
    unsigned int length;

    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);

    if (0 == (length = d_queue.length())) {
        return 1;                                                     // RETURN
    }
    *buffer = d_queue.back();
    d_queue.popBack();
    --length;

    if (length &lt; (unsigned) d_highWaterMark) {
        d_notFullCondition.signal();
    }
    return 0;
}

template &lt;class TYPE&gt;
void Queue&lt;TYPE&gt;::tryPopBack(int maxNumItems, bsl::vector&lt;TYPE&gt; *buffer)
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);

    int        length  = d_queue.length();
    const bool wasFull = d_highWaterMark &gt; 0 &amp;&amp; length &gt;= d_highWaterMark;

    for (; d_queue.length() &gt; 0 &amp;&amp; maxNumItems &gt; 0; --maxNumItems) {
        if (buffer) {
            buffer-&gt;push_back(d_queue.back());
        }
        d_queue.popBack();
        --length;
        if (wasFull &amp;&amp; length &lt; d_highWaterMark) {
            d_notFullCondition.signal();
        }
    }
}

template &lt;class TYPE&gt;
void Queue&lt;TYPE&gt;::removeAll(bsl::vector&lt;TYPE&gt; *buffer)
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);
    bool wasFull = d_highWaterMark &gt; 0 &amp;&amp; d_queue.length() &gt;= d_highWaterMark;
    d_queue.removeAll(buffer);
    if (wasFull) {
        for (int i = 0; d_highWaterMark &gt; i; ++i) {
            d_notFullCondition.signal();
        }
    }
}

template &lt;class TYPE&gt;
void Queue&lt;TYPE&gt;::pushBack(const TYPE&amp; item)
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);
    if (d_highWaterMark &gt;= 0) {
        while (d_queue.length() &gt;= d_highWaterMark) {
            d_notFullCondition.wait(&amp;d_mutex);
        }
    }
    d_queue.pushBack(item);
    d_notEmptyCondition.signal();
}

template &lt;class TYPE&gt;
void Queue&lt;TYPE&gt;::pushFront(const TYPE&amp; item)
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);
    if (d_highWaterMark &gt;= 0) {
        while (d_queue.length() &gt;= d_highWaterMark) {
            d_notFullCondition.wait(&amp;d_mutex);
        }
    }
    d_queue.pushFront(item);
    d_notEmptyCondition.signal();
}

template &lt;class TYPE&gt;
int Queue&lt;TYPE&gt;::timedPushBack(const TYPE&amp;               item,
                               const bsls::TimeInterval&amp; timeout)
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);
    if (d_highWaterMark &gt;= 0) {
        while (d_queue.length() &gt;= d_highWaterMark) {
            if (d_notFullCondition.timedWait(&amp;d_mutex, timeout)) {
                return 1;                                             // RETURN
            }
        }
    }
    d_queue.pushBack(item);
    d_notEmptyCondition.signal();
    return 0;
}

template &lt;class TYPE&gt;
int Queue&lt;TYPE&gt;::timedPushFront(const TYPE&amp;               item,
                                const bsls::TimeInterval&amp; timeout)
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);
    if (d_highWaterMark &gt;= 0) {
        while (d_queue.length() &gt;= d_highWaterMark) {
            if (d_notFullCondition.timedWait(&amp;d_mutex, timeout)) {
                return 1;                                             // RETURN
            }
        }
    }
    d_queue.pushFront(item);
    d_notEmptyCondition.signal();
    return 0;
}

template &lt;class TYPE&gt;
inline
void Queue&lt;TYPE&gt;::forcePushFront(const TYPE&amp; item)
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);
    d_queue.pushFront(item);
    d_notEmptyCondition.signal();
}

// *** Modifiable access to the mutex, condition variable, and queue ***

template &lt;class TYPE&gt;
inline
bslmt::Condition&amp; Queue&lt;TYPE&gt;::condition()
{
    return d_notEmptyCondition;
}

template &lt;class TYPE&gt;
inline
bslmt::Condition&amp; Queue&lt;TYPE&gt;::insertCondition()
{
    return d_notFullCondition;
}

template &lt;class TYPE&gt;
inline
bslmt::Mutex&amp; Queue&lt;TYPE&gt;::mutex()
{
    return d_mutex;
}

template &lt;class TYPE&gt;
inline
bslmt::Condition&amp; Queue&lt;TYPE&gt;::notEmptyCondition()
{
    return d_notEmptyCondition;
}

template &lt;class TYPE&gt;
inline
bslmt::Condition&amp; Queue&lt;TYPE&gt;::notFullCondition()
{
    return d_notFullCondition;
}

template &lt;class TYPE&gt;
inline
bdlc::Queue&lt;TYPE&gt;&amp; Queue&lt;TYPE&gt;::queue()
{
    return d_queue;
}

// ACCESSORS
template &lt;class TYPE&gt;
inline
int Queue&lt;TYPE&gt;::highWaterMark() const
{
    return d_highWaterMark;
}

template &lt;class TYPE&gt;
inline
int Queue&lt;TYPE&gt;::length() const
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);

    return d_queue.length();
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
