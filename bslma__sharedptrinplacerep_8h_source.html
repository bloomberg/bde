<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslma_sharedptrinplacerep.h                                        -*-C++-*-
#ifndef INCLUDED_BSLMA_SHAREDPTRINPLACEREP
#define INCLUDED_BSLMA_SHAREDPTRINPLACEREP

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$ $CSID$&quot;)

//@PURPOSE: Provide an in-place implementation of &#39;bslma::SharedPtrRep&#39;.
//
//@CLASSES:
//  bslma::SharedPtrInplaceRep: in-place &#39;bslma::SharedPtrRep&#39; implementation
//
//@SEE_ALSO: bslma_sharedptr, bslma_sharedptr_rep, bslma_sharedptroutofplacerep
//
//@DESCRIPTION: This component provides a concrete implementation of
// &#39;bslma::SharedPtrRep&#39; for managing objects of the parameterized &#39;TYPE&#39; that
// are stored in-place in the representation .  Thus, only one memory
// allocation is required to create both the representation and the managed
// object.  When all references to the in-place object are released (using
// &#39;releaseRef&#39;), the destructor of &#39;TYPE&#39; is invoked.
//
///Thread Safety
///-------------
// &#39;bslma::SharedPtrInplaceRep&#39; is thread-safe provided that &#39;disposeObject&#39;
// and &#39;disposeRep&#39; are not called explicitly, meaning that all non-creator
// operations other than &#39;disposeObject&#39; and &#39;disposeRep&#39; on a given instance
// can be safely invoked simultaneously from multiple threads (&#39;disposeObject&#39;
// and &#39;disposeRep&#39; are meant to be invoked only by &#39;releaseRef&#39; and
// &#39;releaseWeakRef&#39;).  Note that there is no thread safety guarantees for
// operations on the managed object contained in &#39;bslma::SharedPtrInplaceRep&#39;.
//
///Usage
///-----
// The following example demonstrates how to implement a shared &#39;bdet_Datetime&#39;
// using &#39;bslma::SharedPtrInplaceRep&#39;:
//..
//  class MySharedDatetimePtr {
//      // This class provide a reference counted smart pointer to support
//      // shared ownership of a &#39;bdet_Datetime&#39; object.
//
//      bdet_Datetime       *d_ptr_p;  // pointer to the managed object
//      bslma::SharedPtrRep *d_rep_p;  // pointer to the representation object
//
//    private:
//      // NOT IMPLEMENTED
//      MySharedDatetimePtr&amp; operator=(const MySharedDatetimePtr&amp;);
//
//    public:
//      // CREATORS
//      MySharedDatetimePtr();
//          // Create an empty shared datetime.
//
//      MySharedDatetimePtr(bdet_Datetime* ptr, bslma::SharedPtrRep* rep);
//          // Create a shared datetime that adopts ownership of the specified
//          // &#39;ptr&#39; and the specified &#39;rep.
//
//      MySharedDatetimePtr(const MySharedDatetimePtr&amp; original);
//          // Create a shared datetime that refers to the same object managed
//          // by the specified &#39;original&#39;
//
//      ~MySharedDatetimePtr();
//          // Destroy this shared datetime and release the reference to the
//          // &#39;bdet_Datetime&#39; object to which it might be referring.  If this
//          // is the last shared reference, deleted the managed object.
//
//      // MANIPULATORS
//      void createInplace(bslma::Allocator *basicAllocator,
//                         int               year,
//                         int               month,
//                         int               day);
//          // Create a new &#39;bslma::SharedPtrInplaceRep&#39;, using the specified
//          // &#39;basicAllocator&#39; to supply memory, using the specified &#39;year&#39;,
//          // &#39;month&#39; and &#39;day&#39; to initialize the &#39;bdet_Datetime&#39; within the
//          // newly created &#39;bslma::SharedPtrInplaceRep&#39;, and make this
//          // object refer to the newly created &#39;bdet_Datetime&#39; object.
//
//      bdet_Datetime&amp; operator*() const;
//          // Return a modifiable reference to the shared &#39;bdet_Datetime&#39;
//          // object.
//
//      bdet_Datetime *operator-&gt;() const;
//          // Return the address of the modifiable &#39;bdet_Datetime&#39; to which
//          // this object refers.
//
//      bdet_Datetime *ptr() const;
//          // Return the address of the modifiable &#39;bdet_Datetime&#39; to which
//          // this object refers.
//  };
//..
// Finally, we define the implementation.
//..
//  MySharedDatetimePtr::MySharedDatetimePtr()
//  : d_ptr_p(0)
//  , d_rep_p(0)
//  {
//  }
//
//  MySharedDatetimePtr::MySharedDatetimePtr(bdet_Datetime       *ptr,
//                                           bslma::SharedPtrRep *rep)
//  : d_ptr_p(ptr)
//  , d_rep_p(rep)
//  {
//  }
//
//  MySharedDatetimePtr::MySharedDatetimePtr(
//                                         const MySharedDatetimePtr&amp; original)
//  : d_ptr_p(original.d_ptr_p)
//  , d_rep_p(original.d_rep_p)
//  {
//      if (d_ptr_p) {
//          d_rep_p-&gt;acquireRef();
//      } else {
//          d_rep_p = 0;
//      }
//  }
//
//  MySharedDatetimePtr::~MySharedDatetimePtr()
//  {
//      if (d_rep_p) {
//          d_rep_p-&gt;releaseRef();
//      }
//  }
//
//  void MySharedDatetimePtr::createInplace(bslma::Allocator *basicAllocator,
//                                          int               year,
//                                          int               month,
//                                          int               day)
//  {
//      basicAllocator = bslma::Default::allocator(basicAllocator);
//      bslma::SharedPtrInplaceRep&lt;bdet_Datetime&gt; *rep = new (*basicAllocator)
//                    bslma::SharedPtrInplaceRep&lt;bdet_Datetime&gt;(basicAllocator,
//                                                              year,
//                                                              month,
//                                                              day);
//      MySharedDatetimePtr temp(rep-&gt;ptr(), rep);
//      bsl::swap(d_ptr_p, temp.d_ptr_p);
//      bsl::swap(d_rep_p, temp.d_rep_p);
//  }
//
//  bdet_Datetime&amp; MySharedDatetimePtr::operator*() const {
//      return *d_ptr_p;
//  }
//
//  bdet_Datetime *MySharedDatetimePtr::operator-&gt;() const {
//      return d_ptr_p;
//  }
//
//  bdet_Datetime *MySharedDatetimePtr::ptr() const {
//      return d_ptr_p;
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_SHAREDPTRREP
#include &lt;bslma_sharedptrrep.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_MOVABLEREF
#include &lt;bslmf_movableref.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_COMPILERFEATURES
#include &lt;bsls_compilerfeatures.h&gt;
#endif

#ifndef INCLUDED_BSLS_UTIL
#include &lt;bsls_util.h&gt;
#endif

#ifndef INCLUDED_TYPEINFO
#include &lt;typeinfo&gt;
#define INCLUDED_TYPEINFO
#endif

namespace BloombergLP {
namespace bslma {

                      // =========================
                      // class SharedPtrInplaceRep
                      // =========================

template &lt;class TYPE&gt;
class SharedPtrInplaceRep : public SharedPtrRep {
    // This class provides a concrete implementation of the &#39;SharedPtrRep&#39;
    // protocol for &quot;in-place&quot; instances of the parameterized &#39;TYPE&#39;.  Upon
    // destruction of this object, the destructor of &#39;TYPE&#39; is invoked.

    // DATA
    Allocator *d_allocator_p; // memory allocator (held, not owned)

    TYPE       d_instance;    // Beginning of the in-place buffer.  Note that
                              // this must be last in this layout to allow for
                              // the possibility of creating in-place
                              // uninitialized buffer, where it is possible to
                              // access memory beyond the &#39;d_instance&#39;
                              // footprint (refer to &#39;bsl::share_ptr::
                              // createInplaceUninitializedBuffer&#39; for sample
                              // usage)

  private:
    // NOT IMPLEMENTED
    SharedPtrInplaceRep(const SharedPtrInplaceRep&amp;);
    SharedPtrInplaceRep&amp; operator=(const SharedPtrInplaceRep&amp;);

    // PRIVATE CREATORS
    ~SharedPtrInplaceRep();
        // Destroy this representation object and the embedded instance of
        // parameterized &#39;TYPE&#39;.  Note that this destructor is never called.
        // Instead, &#39;disposeObject&#39; destroys the in-place object and
        // &#39;disposeRep&#39; deallocates this representation object (including the
        // shared object&#39;s footprint).

  public:
    // CREATORS
#if defined(BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES)
# if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES)
    template &lt;class... ARGS&gt;
    explicit SharedPtrInplaceRep(Allocator *basicAllocator,
                                 ARGS&amp;&amp;...  args);
        // Create a &#39;SharedPtrInplaceRep&#39; object having an &quot;in-place&quot; instance
        // of the parameterized &#39;TYPE&#39; using the &#39;TYPE&#39; constructor that takes
        // the specified arguments, &#39;args...&#39;.  Use the specified
        // &#39;basicAllocator&#39; to supply memory and, upon a call to &#39;disposeRep&#39;,
        // to destroy this representation (and the &quot;in-place&quot; shared object).
# else
    template &lt;class... ARGS&gt;
    explicit SharedPtrInplaceRep(Allocator      *basicAllocator,
                                 const ARGS&amp;...  args);
        // Create a &#39;SharedPtrInplaceRep&#39; object having an &quot;in-place&quot; instance
        // of the parameterized &#39;TYPE&#39; using the &#39;TYPE&#39; constructor that takes
        // the specified arguments, &#39;args...&#39;.  Use the specified
        // &#39;basicAllocator&#39; to supply memory and, upon a call to &#39;disposeRep&#39;,
        // to destroy this representation (and the &quot;in-place&quot; shared object).

# endif  // BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#else
    explicit SharedPtrInplaceRep(Allocator *basicAllocator);
        // Create a &#39;SharedPtrInplaceRep&#39; object having an &quot;in-place&quot;
        // default-constructed instance of the parameterized &#39;TYPE&#39;.  Use the
        // specified &#39;basicAllocator&#39; to supply memory and, upon a call to
        // &#39;disposeRep&#39;, to destroy this representation (and the &quot;in-place&quot;
        // shared object) .

    template &lt;class A1&gt;
    SharedPtrInplaceRep(Allocator *basicAllocator, const A1&amp; a1);
    template &lt;class A1, class A2&gt;
    SharedPtrInplaceRep(Allocator *basicAllocator,
                        const A1&amp;  a1,
                        const A2&amp;  a2);
    template &lt;class A1, class A2, class A3&gt;
    SharedPtrInplaceRep(Allocator *basicAllocator,
                        const A1&amp;  a1,
                        const A2&amp;  a2,
                        const A3&amp;  a3);
    template &lt;class A1, class A2, class A3, class A4&gt;
    SharedPtrInplaceRep(Allocator *basicAllocator,
                        const A1&amp;  a1,
                        const A2&amp;  a2,
                        const A3&amp;  a3,
                        const A4&amp;  a4);
    template &lt;class A1, class A2, class A3, class A4, class A5&gt;
    SharedPtrInplaceRep(Allocator *basicAllocator,
                        const A1&amp;  a1,
                        const A2&amp;  a2,
                        const A3&amp;  a3,
                        const A4&amp;  a4,
                        const A5&amp;  a5);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6&gt;
    SharedPtrInplaceRep(Allocator *basicAllocator,
                        const A1&amp;  a1,
                        const A2&amp;  a2,
                        const A3&amp;  a3,
                        const A4&amp;  a4,
                        const A5&amp;  a5,
                        const A6&amp;  a6);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7&gt;
    SharedPtrInplaceRep(Allocator *basicAllocator,
                        const A1&amp;  a1,
                        const A2&amp;  a2,
                        const A3&amp;  a3,
                        const A4&amp;  a4,
                        const A5&amp;  a5,
                        const A6&amp;  a6,
                        const A7&amp;  a7);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7, class A8&gt;
    SharedPtrInplaceRep(Allocator *basicAllocator,
                        const A1&amp;  a1,
                        const A2&amp;  a2,
                        const A3&amp;  a3,
                        const A4&amp;  a4,
                        const A5&amp;  a5,
                        const A6&amp;  a6,
                        const A7&amp;  a7,
                        const A8&amp;  a8);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7, class A8, class A9&gt;
    SharedPtrInplaceRep(Allocator *basicAllocator,
                        const A1&amp;  a1,
                        const A2&amp;  a2,
                        const A3&amp;  a3,
                        const A4&amp;  a4,
                        const A5&amp;  a5,
                        const A6&amp;  a6,
                        const A7&amp;  a7,
                        const A8&amp;  a8,
                        const A9&amp;  a9);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7, class A8, class A9, class A10&gt;
    SharedPtrInplaceRep(Allocator  *basicAllocator,
                        const A1&amp;   a1,
                        const A2&amp;   a2,
                        const A3&amp;   a3,
                        const A4&amp;   a4,
                        const A5&amp;   a5,
                        const A6&amp;   a6,
                        const A7&amp;   a7,
                        const A8&amp;   a8,
                        const A9&amp;   a9,
                        const A10&amp;  a10);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7, class A8, class A9, class A10, class A11&gt;
    SharedPtrInplaceRep(Allocator  *basicAllocator,
                        const A1&amp;   a1,
                        const A2&amp;   a2,
                        const A3&amp;   a3,
                        const A4&amp;   a4,
                        const A5&amp;   a5,
                        const A6&amp;   a6,
                        const A7&amp;   a7,
                        const A8&amp;   a8,
                        const A9&amp;   a9,
                        const A10&amp;  a10,
                        const A11&amp;  a11);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7, class A8, class A9, class A10, class A11, class A12&gt;
    SharedPtrInplaceRep(Allocator  *basicAllocator,
                        const A1&amp;   a1,
                        const A2&amp;   a2,
                        const A3&amp;   a3,
                        const A4&amp;   a4,
                        const A5&amp;   a5,
                        const A6&amp;   a6,
                        const A7&amp;   a7,
                        const A8&amp;   a8,
                        const A9&amp;   a9,
                        const A10&amp;  a10,
                        const A11&amp;  a11,
                        const A12&amp;  a12);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7, class A8, class A9, class A10, class A11, class A12,
              class A13&gt;
    SharedPtrInplaceRep(Allocator  *basicAllocator,
                        const A1&amp;   a1,
                        const A2&amp;   a2,
                        const A3&amp;   a3,
                        const A4&amp;   a4,
                        const A5&amp;   a5,
                        const A6&amp;   a6,
                        const A7&amp;   a7,
                        const A8&amp;   a8,
                        const A9&amp;   a9,
                        const A10&amp;  a10,
                        const A11&amp;  a11,
                        const A12&amp;  a12,
                        const A13&amp;  a13);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7, class A8, class A9, class A10, class A11, class A12,
              class A13, class A14&gt;
    SharedPtrInplaceRep(Allocator  *basicAllocator,
                        const A1&amp;   a1,
                        const A2&amp;   a2,
                        const A3&amp;   a3,
                        const A4&amp;   a4,
                        const A5&amp;   a5,
                        const A6&amp;   a6,
                        const A7&amp;   a7,
                        const A8&amp;   a8,
                        const A9&amp;   a9,
                        const A10&amp;  a10,
                        const A11&amp;  a11,
                        const A12&amp;  a12,
                        const A13&amp;  a13,
                        const A14&amp;  a14);
        // Create a &#39;SharedPtrInplaceRep&#39; object having an &quot;in-place&quot; instance
        // of the parameterized &#39;TYPE&#39; using the &#39;TYPE&#39; constructor that takes
        // the specified arguments, &#39;a1&#39; up to &#39;aN&#39;, where &#39;N&#39; (at most 14) is
        // the number of arguments passed to this method.  Use the specified
        // &#39;basicAllocator&#39; to supply memory and, upon a call to &#39;disposeRep&#39;,
        // to destroy this representation (and the &quot;in-place&quot; shared object).
#endif

    // MANIPULATORS
    virtual void disposeObject();
        // Destroy the object being referred to by this representation.  This
        // method is automatically invoked by &#39;releaseRef&#39; when the number of
        // shared references reaches zero and should not be explicitly invoked
        // otherwise.  Note that this function calls the destructor for the
        // shared object, but does not deallocate its footprint.

    virtual void disposeRep();
        // Deallocate the memory associated with this representation object
        // (including the shared object&#39;s footprint).  This method is
        // automatically invoked by &#39;releaseRef&#39; and &#39;releaseWeakRef&#39; when the
        // number of weak references and the number of shared references both
        // reach zero and should not be explicitly invoked otherwise.  The
        // behavior is undefined unless &#39;disposeObject&#39; has already been called
        // for this representation.  Note that this &#39;disposeRep&#39; method
        // effectively serves as the representation object&#39;s destructor.

    void *getDeleter(const std::type_info&amp; type);
        // Return a null pointer.  Note that the specified &#39;type&#39; is not used
        // as an in-place representation for a shared pointer can never store a
        // user-supplied deleter (there is no function that might try to create
        // one).

    TYPE *ptr();
        // Return the address of the modifiable (in-place) object referred to
        // by this representation object.

    // ACCESSORS
    virtual void *originalPtr() const;
        // Return the (untyped) address of the modifiable (in-place) object
        // referred to by this representation object.
};

                        //============================
                        // SharedPtrInplaceRep_ImpUtil
                        //============================

struct SharedPtrInplaceRep_ImpUtil {
    // This struct provides a namespace for several static methods that ease
    // the implementation of many methods of the &#39;SharedPtrInplaceRep&#39; class.

    // CLASS METHODS
    template &lt;class TYPE&gt;
    static const TYPE&amp; forward(const TYPE&amp; reference);
    template &lt;class TYPE&gt;
    static BloombergLP::bslmf::MovableRef&lt;TYPE&gt; forward(
                        const BloombergLP::bslmf::MovableRef&lt;TYPE&gt;&amp; reference);
        // Return the specified &#39;reference&#39;.  Note that this pair of overloaded
        // functions is necessary to correctly forward movable references when
        // providing explicit move-semantics for C++03; otherwise the
        // &#39;MovableRef&#39; is likely to be wrapped in multiple layers of reference
        // wrappers, and not be recognized as the movable vocabulary type.

    template &lt;class TYPE&gt;
    static void *voidify(TYPE *address);
        // Return the specified &#39;address&#39; cast as a pointer to &#39;void&#39;, even if
        // (the template parameter) &#39;TYPE&#39; is cv-qualified.
};

// ============================================================================
//              INLINE FUNCTION AND FUNCTION TEMPLATE DEFINITIONS
// ============================================================================


                        // ---------------------------
                        // SharedPtrInplaceRep_ImpUtil
                        // ---------------------------

template &lt;class TYPE&gt;
inline
const TYPE&amp; SharedPtrInplaceRep_ImpUtil::forward(const TYPE&amp; reference)
{
    return reference;
}

template &lt;class TYPE&gt;
inline
BloombergLP::bslmf::MovableRef&lt;TYPE&gt; SharedPtrInplaceRep_ImpUtil::forward(
                         const BloombergLP::bslmf::MovableRef&lt;TYPE&gt;&amp; reference)
{
    return reference;
}

template &lt;class TYPE&gt;
inline
void *SharedPtrInplaceRep_ImpUtil::voidify(TYPE *address) {
    return static_cast&lt;void *&gt;(
            const_cast&lt;typename bsl::remove_cv&lt;TYPE&gt;::type *&gt;(address));
}

                        // -------------------------
                        // class SharedPtrInplaceRep
                        // -------------------------

// CREATORS
#if defined(BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES)
# if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES)
template &lt;class TYPE&gt;
template &lt;class... ARGS&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator,
                                               ARGS&amp;&amp;...  args)
: d_allocator_p(basicAllocator)
, d_instance(BSLS_COMPILERFEATURES_FORWARD(ARGS,args)...)
{
}
# else
template &lt;class TYPE&gt;
template &lt;class... ARGS&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator      *basicAllocator,
                                               const ARGS&amp;...  args)
: d_allocator_p(basicAllocator)
, d_instance(SharedPtrInplaceRep_ImpUtil::forward(args)...)
{
}
# endif
#else
template &lt;class TYPE&gt;
inline
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator)
: d_allocator_p(basicAllocator)
, d_instance()
{
}

template &lt;class TYPE&gt;
template &lt;class A1&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator,
                                               const A1&amp;  a1)
: d_allocator_p(basicAllocator)
, d_instance(SharedPtrInplaceRep_ImpUtil::forward(a1))
{
}

template &lt;class TYPE&gt;
template &lt;class A1, class A2&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator,
                                               const A1&amp;  a1,
                                               const A2&amp;  a2)
: d_allocator_p(basicAllocator)
, d_instance(SharedPtrInplaceRep_ImpUtil::forward(a1),
             SharedPtrInplaceRep_ImpUtil::forward(a2))
{
}

template &lt;class TYPE&gt;
template &lt;class A1, class A2, class A3&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator,
                                               const A1&amp;  a1,
                                               const A2&amp;  a2,
                                               const A3&amp;  a3)
: d_allocator_p(basicAllocator)
, d_instance(SharedPtrInplaceRep_ImpUtil::forward(a1),
             SharedPtrInplaceRep_ImpUtil::forward(a2),
             SharedPtrInplaceRep_ImpUtil::forward(a3))
{
}

template &lt;class TYPE&gt;
template &lt;class A1, class A2, class A3, class A4&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator,
                                               const A1&amp;  a1,
                                               const A2&amp;  a2,
                                               const A3&amp;  a3,
                                               const A4&amp;  a4)
: d_allocator_p(basicAllocator)
, d_instance(SharedPtrInplaceRep_ImpUtil::forward(a1),
             SharedPtrInplaceRep_ImpUtil::forward(a2),
             SharedPtrInplaceRep_ImpUtil::forward(a3),
             SharedPtrInplaceRep_ImpUtil::forward(a4))
{
}

template &lt;class TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator,
                                               const A1&amp;  a1,
                                               const A2&amp;  a2,
                                               const A3&amp;  a3,
                                               const A4&amp;  a4,
                                               const A5&amp;  a5)
: d_allocator_p(basicAllocator)
, d_instance(SharedPtrInplaceRep_ImpUtil::forward(a1),
             SharedPtrInplaceRep_ImpUtil::forward(a2),
             SharedPtrInplaceRep_ImpUtil::forward(a3),
             SharedPtrInplaceRep_ImpUtil::forward(a4),
             SharedPtrInplaceRep_ImpUtil::forward(a5))
{
}

template &lt;class TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator,
                                               const A1&amp;  a1,
                                               const A2&amp;  a2,
                                               const A3&amp;  a3,
                                               const A4&amp;  a4,
                                               const A5&amp;  a5,
                                               const A6&amp;  a6)
: d_allocator_p(basicAllocator)
, d_instance(SharedPtrInplaceRep_ImpUtil::forward(a1),
             SharedPtrInplaceRep_ImpUtil::forward(a2),
             SharedPtrInplaceRep_ImpUtil::forward(a3),
             SharedPtrInplaceRep_ImpUtil::forward(a4),
             SharedPtrInplaceRep_ImpUtil::forward(a5),
             SharedPtrInplaceRep_ImpUtil::forward(a6))
{
}

template &lt;class TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator,
                                               const A1&amp;  a1,
                                               const A2&amp;  a2,
                                               const A3&amp;  a3,
                                               const A4&amp;  a4,
                                               const A5&amp;  a5,
                                               const A6&amp;  a6,
                                               const A7&amp;  a7)
: d_allocator_p(basicAllocator)
, d_instance(SharedPtrInplaceRep_ImpUtil::forward(a1),
             SharedPtrInplaceRep_ImpUtil::forward(a2),
             SharedPtrInplaceRep_ImpUtil::forward(a3),
             SharedPtrInplaceRep_ImpUtil::forward(a4),
             SharedPtrInplaceRep_ImpUtil::forward(a5),
             SharedPtrInplaceRep_ImpUtil::forward(a6),
             SharedPtrInplaceRep_ImpUtil::forward(a7))
{
}

template &lt;class TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7, class A8&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator,
                                               const A1&amp;  a1,
                                               const A2&amp;  a2,
                                               const A3&amp;  a3,
                                               const A4&amp;  a4,
                                               const A5&amp;  a5,
                                               const A6&amp;  a6,
                                               const A7&amp;  a7,
                                               const A8&amp;  a8)
: d_allocator_p(basicAllocator)
, d_instance(SharedPtrInplaceRep_ImpUtil::forward(a1),
             SharedPtrInplaceRep_ImpUtil::forward(a2),
             SharedPtrInplaceRep_ImpUtil::forward(a3),
             SharedPtrInplaceRep_ImpUtil::forward(a4),
             SharedPtrInplaceRep_ImpUtil::forward(a5),
             SharedPtrInplaceRep_ImpUtil::forward(a6),
             SharedPtrInplaceRep_ImpUtil::forward(a7),
             SharedPtrInplaceRep_ImpUtil::forward(a8))
{
}

template &lt;class TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7, class A8, class A9&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator,
                                               const A1&amp;  a1,
                                               const A2&amp;  a2,
                                               const A3&amp;  a3,
                                               const A4&amp;  a4,
                                               const A5&amp;  a5,
                                               const A6&amp;  a6,
                                               const A7&amp;  a7,
                                               const A8&amp;  a8,
                                               const A9&amp;  a9)
: d_allocator_p(basicAllocator)
, d_instance(SharedPtrInplaceRep_ImpUtil::forward(a1),
             SharedPtrInplaceRep_ImpUtil::forward(a2),
             SharedPtrInplaceRep_ImpUtil::forward(a3),
             SharedPtrInplaceRep_ImpUtil::forward(a4),
             SharedPtrInplaceRep_ImpUtil::forward(a5),
             SharedPtrInplaceRep_ImpUtil::forward(a6),
             SharedPtrInplaceRep_ImpUtil::forward(a7),
             SharedPtrInplaceRep_ImpUtil::forward(a8),
             SharedPtrInplaceRep_ImpUtil::forward(a9))
{
}

template &lt;class TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7, class A8, class A9, class A10&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator,
                                               const A1&amp;  a1,
                                               const A2&amp;  a2,
                                               const A3&amp;  a3,
                                               const A4&amp;  a4,
                                               const A5&amp;  a5,
                                               const A6&amp;  a6,
                                               const A7&amp;  a7,
                                               const A8&amp;  a8,
                                               const A9&amp;  a9,
                                               const A10&amp; a10)
: d_allocator_p(basicAllocator)
, d_instance(SharedPtrInplaceRep_ImpUtil::forward(a1),
             SharedPtrInplaceRep_ImpUtil::forward(a2),
             SharedPtrInplaceRep_ImpUtil::forward(a3),
             SharedPtrInplaceRep_ImpUtil::forward(a4),
             SharedPtrInplaceRep_ImpUtil::forward(a5),
             SharedPtrInplaceRep_ImpUtil::forward(a6),
             SharedPtrInplaceRep_ImpUtil::forward(a7),
             SharedPtrInplaceRep_ImpUtil::forward(a8),
             SharedPtrInplaceRep_ImpUtil::forward(a9),
             SharedPtrInplaceRep_ImpUtil::forward(a10))
{
}

template &lt;class TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7, class A8, class A9, class A10, class A11&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator,
                                               const A1&amp;  a1,
                                               const A2&amp;  a2,
                                               const A3&amp;  a3,
                                               const A4&amp;  a4,
                                               const A5&amp;  a5,
                                               const A6&amp;  a6,
                                               const A7&amp;  a7,
                                               const A8&amp;  a8,
                                               const A9&amp;  a9,
                                               const A10&amp; a10,
                                               const A11&amp; a11)
: d_allocator_p(basicAllocator)
, d_instance(SharedPtrInplaceRep_ImpUtil::forward(a1),
             SharedPtrInplaceRep_ImpUtil::forward(a2),
             SharedPtrInplaceRep_ImpUtil::forward(a3),
             SharedPtrInplaceRep_ImpUtil::forward(a4),
             SharedPtrInplaceRep_ImpUtil::forward(a5),
             SharedPtrInplaceRep_ImpUtil::forward(a6),
             SharedPtrInplaceRep_ImpUtil::forward(a7),
             SharedPtrInplaceRep_ImpUtil::forward(a8),
             SharedPtrInplaceRep_ImpUtil::forward(a9),
             SharedPtrInplaceRep_ImpUtil::forward(a10),
             SharedPtrInplaceRep_ImpUtil::forward(a11))
{
}

template &lt;class TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7, class A8, class A9, class A10, class A11, class A12&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator,
                                               const A1&amp;  a1,
                                               const A2&amp;  a2,
                                               const A3&amp;  a3,
                                               const A4&amp;  a4,
                                               const A5&amp;  a5,
                                               const A6&amp;  a6,
                                               const A7&amp;  a7,
                                               const A8&amp;  a8,
                                               const A9&amp;  a9,
                                               const A10&amp; a10,
                                               const A11&amp; a11,
                                               const A12&amp; a12)
: d_allocator_p(basicAllocator)
, d_instance(SharedPtrInplaceRep_ImpUtil::forward(a1),
             SharedPtrInplaceRep_ImpUtil::forward(a2),
             SharedPtrInplaceRep_ImpUtil::forward(a3),
             SharedPtrInplaceRep_ImpUtil::forward(a4),
             SharedPtrInplaceRep_ImpUtil::forward(a5),
             SharedPtrInplaceRep_ImpUtil::forward(a6),
             SharedPtrInplaceRep_ImpUtil::forward(a7),
             SharedPtrInplaceRep_ImpUtil::forward(a8),
             SharedPtrInplaceRep_ImpUtil::forward(a9),
             SharedPtrInplaceRep_ImpUtil::forward(a10),
             SharedPtrInplaceRep_ImpUtil::forward(a11),
             SharedPtrInplaceRep_ImpUtil::forward(a12))
{
}

template &lt;class TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7, class A8, class A9, class A10, class A11, class A12,
          class A13&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator,
                                               const A1&amp;  a1,
                                               const A2&amp;  a2,
                                               const A3&amp;  a3,
                                               const A4&amp;  a4,
                                               const A5&amp;  a5,
                                               const A6&amp;  a6,
                                               const A7&amp;  a7,
                                               const A8&amp;  a8,
                                               const A9&amp;  a9,
                                               const A10&amp; a10,
                                               const A11&amp; a11,
                                               const A12&amp; a12,
                                               const A13&amp; a13)
: d_allocator_p(basicAllocator)
, d_instance(SharedPtrInplaceRep_ImpUtil::forward(a1),
             SharedPtrInplaceRep_ImpUtil::forward(a2),
             SharedPtrInplaceRep_ImpUtil::forward(a3),
             SharedPtrInplaceRep_ImpUtil::forward(a4),
             SharedPtrInplaceRep_ImpUtil::forward(a5),
             SharedPtrInplaceRep_ImpUtil::forward(a6),
             SharedPtrInplaceRep_ImpUtil::forward(a7),
             SharedPtrInplaceRep_ImpUtil::forward(a8),
             SharedPtrInplaceRep_ImpUtil::forward(a9),
             SharedPtrInplaceRep_ImpUtil::forward(a10),
             SharedPtrInplaceRep_ImpUtil::forward(a11),
             SharedPtrInplaceRep_ImpUtil::forward(a12),
             SharedPtrInplaceRep_ImpUtil::forward(a13))
{
}

template &lt;class TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7, class A8, class A9, class A10, class A11, class A12,
          class A13, class A14&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::SharedPtrInplaceRep(Allocator *basicAllocator,
                                               const A1&amp;  a1,
                                               const A2&amp;  a2,
                                               const A3&amp;  a3,
                                               const A4&amp;  a4,
                                               const A5&amp;  a5,
                                               const A6&amp;  a6,
                                               const A7&amp;  a7,
                                               const A8&amp;  a8,
                                               const A9&amp;  a9,
                                               const A10&amp; a10,
                                               const A11&amp; a11,
                                               const A12&amp; a12,
                                               const A13&amp; a13,
                                               const A14&amp; a14)
: d_allocator_p(basicAllocator)
, d_instance(SharedPtrInplaceRep_ImpUtil::forward(a1),
             SharedPtrInplaceRep_ImpUtil::forward(a2),
             SharedPtrInplaceRep_ImpUtil::forward(a3),
             SharedPtrInplaceRep_ImpUtil::forward(a4),
             SharedPtrInplaceRep_ImpUtil::forward(a5),
             SharedPtrInplaceRep_ImpUtil::forward(a6),
             SharedPtrInplaceRep_ImpUtil::forward(a7),
             SharedPtrInplaceRep_ImpUtil::forward(a8),
             SharedPtrInplaceRep_ImpUtil::forward(a9),
             SharedPtrInplaceRep_ImpUtil::forward(a10),
             SharedPtrInplaceRep_ImpUtil::forward(a11),
             SharedPtrInplaceRep_ImpUtil::forward(a12),
             SharedPtrInplaceRep_ImpUtil::forward(a13),
             SharedPtrInplaceRep_ImpUtil::forward(a14))
{
}
#endif

template &lt;class TYPE&gt;
SharedPtrInplaceRep&lt;TYPE&gt;::~SharedPtrInplaceRep()
{
    BSLS_ASSERT(0);
}

// MANIPULATORS
template &lt;class TYPE&gt;
inline
void SharedPtrInplaceRep&lt;TYPE&gt;::disposeObject()
{
    d_instance.~TYPE();
}

template &lt;class TYPE&gt;
inline
void SharedPtrInplaceRep&lt;TYPE&gt;::disposeRep()
{
    d_allocator_p-&gt;deallocate(this);
}

template &lt;class TYPE&gt;
inline
void *SharedPtrInplaceRep&lt;TYPE&gt;::getDeleter(const std::type_info&amp;)
{
    return 0;
}

template &lt;class TYPE&gt;
inline
TYPE *SharedPtrInplaceRep&lt;TYPE&gt;::ptr()
{
    return bsls::Util::addressOf(d_instance);
}

// ACCESSORS
template &lt;class TYPE&gt;
inline
void *SharedPtrInplaceRep&lt;TYPE&gt;::originalPtr() const
{
    return const_cast&lt;void *&gt;(static_cast&lt;const void *&gt;(
                                           bsls::Util::addressOf(d_instance)));
}

// ============================================================================
//                              TYPE TRAITS
// ============================================================================

template &lt;class ELEMENT_TYPE&gt;
struct UsesBslmaAllocator&lt;SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; &gt;
    : bsl::false_type {
    // The class template &#39;SharedPtrInplaceRep&#39; appears to use allocators, but
    // passes its allocator argument in the first position, rather than in the
    // last position, so is not compatible with BDE APIs that use this trait.
};

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
