<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslstl_allocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_allocator<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL-compatible proxy for <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> objects.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1allocator_1_1rebind.html">bsl::allocator&lt; T &gt;::rebind&lt; U &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1allocator_3_01void_01_4.html">bsl::allocator&lt; void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1allocator_3_01void_01_4_1_1rebind.html">bsl::allocator&lt; void &gt;::rebind&lt; U &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga805a9265040329e62bb03c5e599f7a65">bsl::allocator::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga11592900f659edf1527778145f94382d">bsl::allocator::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gab040ead7cb9559795d86ad6fd780fca9">bsl::allocator::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga265cdbf7be2cde5407223541f8089e2c">bsl::allocator::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga0cc70630a7705e6d1f2f9cc2b3ea0294">bsl::allocator::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga3d75f8882aa4270f8c09513276146a6b">bsl::allocator::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga2f5a301855ebda2806d7644dc635ac56">bsl::allocator::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga96e756efd4a9f33778f874ecc4d03eb1">bsl::allocator&lt; void &gt;::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga2fa0d9a832532b3fae1e875e5b7824ea">bsl::allocator&lt; void &gt;::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gaadc5ca24fcd421a097b1ccfd9c10f32a">bsl::allocator&lt; void &gt;::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga53d6f82c890bf4ff86e1ded57675b283">bsl::allocator&lt; void &gt;::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gacd165d8920a3aadfd96b8fd552e38018">bsl::allocator&lt; void &gt;::value_type</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga23c7d73de0e0fc022177c8ba481b5a34">bsl::allocator::BSLMF_NESTED_TRAIT_DECLARATION</a> (allocator, <a class="el" href="structbsl_1_1is__trivially__copyable.html">bsl::is_trivially_copyable</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga94c03ff5d40ef571743b585c36caa772">bsl::allocator::BSLMF_NESTED_TRAIT_DECLARATION</a> (allocator, BloombergLP::bslmf::IsBitwiseMoveable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gad4f94f94652cc64597cbf9e5b5c0353e">bsl::allocator::BSLMF_NESTED_TRAIT_DECLARATION</a> (allocator, BloombergLP::bslmf::IsBitwiseEqualityComparable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga406e9e1772e150de7e36aebfa3682612">bsl::allocator::allocator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga11b43657c23f967d54fda0a14342f6bb">bsl::allocator::allocator</a> (BloombergLP::bslma::Allocator *mechanism)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga749b33d3550416991bc6b88d4e0326f0">bsl::allocator::allocator</a> (const allocator &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga109d73e81427f7e1605c1934f110c325">bsl::allocator::allocator</a> (const allocator&lt; U &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gafd5ba6c32251e07c35d2443a62db70a3">bsl::allocator::~allocator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gac7499740c1db9d233bd07f41ef5acf34">bsl::allocator::operator=</a> (const allocator &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga45e9feb5003f4c9622c56b1f3f31bf87">bsl::allocator::allocate</a> (size_type n, const void *hint=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gaece540c244e6beee6a5b8ccbaac82c05">bsl::allocator::deallocate</a> (pointer p, size_type n=1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga70c058a8054ad704de18a7aca93aa683">bsl::allocator::construct</a> (pointer p, const T &amp;val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gab95d1740230a070b3e40a3b2712985f1">bsl::allocator::destroy</a> (pointer p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BloombergLP::bslma::Allocator *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga0325472ed841f5189359b2a0d7920f23">bsl::allocator::mechanism</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gad5267207812c4278aef372adcca370ac">bsl::allocator::address</a> (reference x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga9fb743d06ff51b08e62d3223dc59446b">bsl::allocator::address</a> (const_reference x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga4531b068b672b1c2f09bc316d884d031">bsl::allocator::max_size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gad1ee2be9d1e85efa55bfa1ae01da5e32">bsl::allocator&lt; void &gt;::BSLMF_NESTED_TRAIT_DECLARATION</a> (allocator, <a class="el" href="structbsl_1_1is__trivially__copyable.html">bsl::is_trivially_copyable</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gad4c8f45387afb9ee8774f8af1ac56bc9">bsl::allocator&lt; void &gt;::BSLMF_NESTED_TRAIT_DECLARATION</a> (allocator, BloombergLP::bslmf::IsBitwiseMoveable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga8fe9051795cbe8110becebb12152cebb">bsl::allocator&lt; void &gt;::BSLMF_NESTED_TRAIT_DECLARATION</a> (allocator, BloombergLP::bslmf::IsBitwiseEqualityComparable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gab8b77c2e92a6c1b37cb9c21d0b0783c9">bsl::allocator&lt; void &gt;::allocator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gac139021032aaa9ee9267696a94dbbc35">bsl::allocator&lt; void &gt;::allocator</a> (BloombergLP::bslma::Allocator *mechanism)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga8394ec6606c6455c75ba36b10a50b237">bsl::allocator&lt; void &gt;::allocator</a> (const allocator &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga8ea1dfcd3c9bc298b6a3731830738b02">bsl::allocator&lt; void &gt;::allocator</a> (const allocator&lt; U &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gaf98317ed19012db5bd9f1702f59bdaa1">bsl::allocator&lt; void &gt;::~allocator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gabce216dd9a18b336e8a35f83ce56bdf5">bsl::allocator&lt; void &gt;::operator=</a> (const allocator &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BloombergLP::bslma::Allocator *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga8b506fae8c08d3178bb02893a117d0d1">bsl::allocator&lt; void &gt;::mechanism</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">bsl::operator==</a> (const allocator&lt; T1 &gt; &amp;lhs, const allocator&lt; T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">bsl::operator!=</a> (const allocator&lt; T1 &gt; &amp;lhs, const allocator&lt; T2 &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gac670def83951dc213e173ca26625f3d0">bsl::operator==</a> (const allocator&lt; T &gt; &amp;lhs, const BloombergLP::bslma::Allocator *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#gabdcd355a6885da0eb7d47aa7410aee04">bsl::operator!=</a> (const allocator&lt; T &gt; &amp;lhs, const BloombergLP::bslma::Allocator *rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga61cb1e180a4ddd04c182bb7bc91384e8">bsl::operator==</a> (const BloombergLP::bslma::Allocator *lhs, const allocator&lt; T &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__allocator.html#ga0a4465ac5dff39c1acd5cb17efb89dab">bsl::operator!=</a> (const BloombergLP::bslma::Allocator *lhs, const allocator&lt; T &gt; &amp;rhs)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Restrictions on Allocator Usage</a> </li>
<li>
<a href="#3.2">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL-compatible proxy for <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> objects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a> </td><td>STL-compatible allocator template  </td></tr>
<tr>
<td>bsl::Allocator_BslalgTypeTraits </td><td>type traits for <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__allocator.html" title="Provide a pure abstract interface for memory-allocation mechanisms.">Component bslma_allocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component is for internal use only. Please include <code>&lt;bsl_memory.h&gt;</code> instead and use <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> directly. This component provides an STL-compatible proxy for any allocator class derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>. The proxy class, <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> is a template that adheres to the allocator requirements defined in section 20.1.5 [lib.allocator.requirements] of the C++ standard. <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> may be used to instantiate any class template that is parameterized by a standard allocator. The container is expected to allocate memory for its own use through the allocator. Different types of allocator use different allocation mechanisms, so this mechanism gives the programmer control over how the container obtains memory. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> template is intended to solve a problem created by the C++ standard allocator protocol. Since, in STL, the allocator type is specified as a container template parameter, the allocation mechanism becomes an explicit part of the resulting container type. Two containers cannot be of the same type unless they are instantiated with the same allocator type, and therefore the same allocation mechanism. <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> breaks the connection between allocator type and allocation mechanism. The allocation mechanism is chosen at <em>run-time</em> by <em>initializing</em> (contrast with <em>instantiating</em>) the <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> with a pointer to a <em>mechanism</em> <em>object</em> derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>. Each class derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> implements a specific allocation mechanism and is thus called a <em>mechanism</em> <em>class</em> within this component. The <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> object forwards calls made through the standard allocator interface to the mechanism object with which it was initialized. In this way, two containers instantiated with <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> can utilize different allocation mechanisms even though they have the same compile-time type. The default mechanism object, if none is supplied to the <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> constructor, is <code><a class="el" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator()</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Instantiations of <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> have full value semantics (well-behaved copy construction, assignment, and tests for equality). Note, however, that a <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> object does not "own" the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> with which it is initialized. In practice , this means that copying a <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> object does not copy its mechanism object and destroying a <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> does not destroy its mechanism object. Two <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> objects compare equal if and only if they share the same mechanism object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="restrictions_on_allocator_usage"></a> <a class="anchor" id="description.restrictions_on_allocator_usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Restrictions on Allocator Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The allocator requirements section of the C++ standard (section 20.1.5 [lib.allocator.requirements]) permits containers to assume that two allocators of the same type always compare equal. This assumption is incorrect for instantiations of <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>. Therefore, any container (or other facility) that can use <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> must operate correctly in the presence of non-equal <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> objects. In practice, this means that a container cannot transfer ownership of allocated memory to another container unless the two containers use equal allocators. Two <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> objects will compare equal if and only if they were initialized with the same mechanism object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>We first show how to define a container type parameterized with an STL-style allocator template parameter. For simplicity, we choose a fixed-size array to avoid issues concerning reallocation, dynamic growth, etc. Furthermore, we do not assume the <code>bslma</code> allocation protocol, which would dictate that we pass-through the allocator to the parameterized <code>T</code> contained type (see the <code>bslma_allocator</code> component and <code>bslalg</code> package). The interface would be as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_fixedsizearray.h</span>
  <span class="comment">// ...</span>

                             <span class="comment">// =======================</span>
                             <span class="comment">// class my_FixedSizeArray</span>
                             <span class="comment">// =======================</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> ALLOC&gt;
  <span class="keyword">class </span>my_FixedSizeArray {
      <span class="comment">// This class provides an array of the parameterized &#39;T&#39; type passed of</span>
      <span class="comment">// fixed length at construction, using an object of the parameterized</span>
      <span class="comment">// &#39;ALLOC&#39; type to supply memory.</span>

      <span class="comment">// DATA</span>
      ALLOC  d_allocator;
      <span class="keywordtype">int</span>    d_length;
      T     *d_array;

    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> ALLOC  allocator_type;
      <span class="keyword">typedef</span> T      value_type;

      <span class="comment">// CREATORS</span>
      my_FixedSizeArray(<span class="keywordtype">int</span> length, <span class="keyword">const</span> ALLOC&amp; allocator = ALLOC());
          <span class="comment">// Create a fixed-size array of the specified &#39;length&#39;, using the</span>
          <span class="comment">// optionally specified &#39;allocator&#39; to supply memory.  If</span>
          <span class="comment">// &#39;allocator&#39; is not specified, a default-constructed object of</span>
          <span class="comment">// the parameterized &#39;ALLOC&#39; type is used.  Note that all the</span>
          <span class="comment">// elements in that array are default-constructed.</span>

      my_FixedSizeArray(<span class="keyword">const</span> my_FixedSizeArray&amp; original,
                        <span class="keyword">const</span> ALLOC&amp;             allocator = ALLOC());
          <span class="comment">// Create a copy of the specified &#39;original&#39; fixed-size array,</span>
          <span class="comment">// using the optionally specified &#39;allocator&#39; to supply memory.  If</span>
          <span class="comment">// &#39;allocator&#39; is not specified, a default-constructed object of</span>
          <span class="comment">// the parameterized &#39;ALLOC&#39; type is used.</span>

      ~my_FixedSizeArray();
          <span class="comment">// Destroy this fixed size array.</span>

      <span class="comment">// MANIPULATORS</span>
      T&amp; operator[](<span class="keywordtype">int</span> index);
          <span class="comment">// Return a reference to the modifiable element at the specified</span>
          <span class="comment">// &#39;index&#39; position in this fixed size array.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> T&amp; operator[](<span class="keywordtype">int</span> index) <span class="keyword">const</span>;
          <span class="comment">// Return a reference to the modifiable element at the specified</span>
          <span class="comment">// &#39;index&#39; position in this fixed size array.</span>

      <span class="keywordtype">int</span> length() <span class="keyword">const</span>;
          <span class="comment">// Return the length specified at construction of this fixed size</span>
          <span class="comment">// array.</span>

      <span class="keyword">const</span> ALLOC&amp; allocator() <span class="keyword">const</span>;
          <span class="comment">// Return a reference to the non-modifiable allocator used by this</span>
          <span class="comment">// fixed size array to supply memory.  This is here for</span>
          <span class="comment">// illustrative purposes.  We should not generally have an accessor</span>
          <span class="comment">// to return the allocator.</span>
  };

  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> ALLOC&gt;
  <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> my_FixedSizeArray&lt;T,ALLOC&gt;&amp; lhs,
                  <span class="keyword">const</span> my_FixedSizeArray&lt;T,ALLOC&gt;&amp; rhs)
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; fixed-size array has the same</span>
      <span class="comment">// value as the specified &#39;rhs&#39; fixed-size array, and &#39;false&#39;</span>
      <span class="comment">// otherwise.  Two fixed-size arrays have the same value if they have</span>
      <span class="comment">// the same length and if the element at any index in &#39;lhs&#39; has the</span>
      <span class="comment">// same value as the corresponding element at the same index in &#39;rhs&#39;.</span>
</pre></div><br/>
<br/>
 The implementation is straightforward <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_fixedsizearray.cpp</span>
  <span class="comment">// ...</span>
                         <span class="comment">// -----------------------</span>
                         <span class="comment">// class my_FixedSizeArray</span>
                         <span class="comment">// -----------------------</span>

  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> ALLOC&gt;
  my_FixedSizeArray&lt;T,ALLOC&gt;::my_FixedSizeArray(<span class="keywordtype">int</span>          length,
                                                <span class="keyword">const</span> ALLOC&amp; alloc)
  : d_allocator(alloc), d_length(length)
  {
      d_array = d_allocator.allocate(d_length);  <span class="comment">// sizeof(T)*d_length bytes</span>

      <span class="comment">// Default construct each element of the array:</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d_length; ++i) {
          d_allocator.construct(&amp;d_array[i], T());
      }
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> ALLOC&gt;
  my_FixedSizeArray&lt;T,ALLOC&gt;::my_FixedSizeArray(
                                              <span class="keyword">const</span> my_FixedSizeArray&amp; rhs,
                                              <span class="keyword">const</span> ALLOC&amp;             alloc)
  : d_allocator(alloc), d_length(rhs.d_length)
  {
      d_array = d_allocator.allocate(d_length);  <span class="comment">// sizeof(T)*d_length bytes</span>

      <span class="comment">// copy construct each element of the array:</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d_length; ++i) {
          d_allocator.construct(&amp;d_array[i], rhs.d_array[i]);
      }
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> ALLOC&gt;
  my_FixedSizeArray&lt;T,ALLOC&gt;::~my_FixedSizeArray()
  {
      <span class="comment">// Call destructor for each element</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d_length; ++i) {
          d_allocator.destroy(&amp;d_array[i]);
      }

      <span class="comment">// Return memory to allocator.</span>
      d_allocator.deallocate(d_array, d_length);
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> ALLOC&gt;
  <span class="keyword">inline</span> T&amp; my_FixedSizeArray&lt;T,ALLOC&gt;::operator[](<span class="keywordtype">int</span> i)
  {
      <span class="keywordflow">return</span> d_array[i];
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> ALLOC&gt;
  <span class="keyword">inline</span>
  <span class="keyword">const</span> T&amp; my_FixedSizeArray&lt;T,ALLOC&gt;::operator[](<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_array[i];
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> ALLOC&gt;
  <span class="keyword">inline</span> <span class="keywordtype">int</span> my_FixedSizeArray&lt;T,ALLOC&gt;::length()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_length;
  }

  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> ALLOC&gt;
  <span class="keyword">inline</span>
  <span class="keyword">const</span> ALLOC&amp; my_FixedSizeArray&lt;T,ALLOC&gt;::allocator()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_allocator;
  }

  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> ALLOC&gt;
  <span class="keywordtype">bool</span> <a class="code" href="namespacebsltf.html#ae361aa40f9f34fccfcbea9bcd670d50f">operator==</a>(<span class="keyword">const</span> my_FixedSizeArray&lt;T,ALLOC&gt;&amp; lhs,
                  <span class="keyword">const</span> my_FixedSizeArray&lt;T,ALLOC&gt;&amp; rhs)
  {
      <span class="keywordflow">if</span> (lhs.length() != rhs.length()) {
          <span class="keywordflow">return</span> <span class="keyword">false</span>;
      }
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; lhs.length(); ++i) {
          <span class="keywordflow">if</span> (lhs[i] != rhs[i]) {
              <span class="keywordflow">return</span> <span class="keyword">false</span>;
          }
      }
      <span class="keywordflow">return</span> <span class="keyword">true</span>;
  }
</pre></div><br/>
<br/>
 Now we declare an allocator mechanism. Our mechanism will be to simply call global <code>operator new</code> and <code>operator delete</code> functions, and count the number of blocks outstanding (allocated but not deallocated). Note that a more reusable implementation would take an underlying mechanism at construction. We keep things simple only for the sake of this example. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_countingallocator.h</span>

                           <span class="comment">// ==========================</span>
                           <span class="comment">// class my_CountingAllocator</span>
                           <span class="comment">// ==========================</span>

  <span class="keyword">class </span>my_CountingAllocator : <span class="keyword">public</span> bslma::Allocator {
      <span class="comment">// This concrete implementation of the &#39;bslma::Allocator&#39; protocol</span>
      <span class="comment">// maintains some statistics of the number of blocks outstanding (i.e.,</span>
      <span class="comment">// allocated but not yet deallocated).</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span> d_blocksOutstanding;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_CountingAllocator();
      <span class="comment">// Create a counting allocator that uses the operators &#39;new&#39; and</span>
      <span class="comment">// &#39;delete&#39; to supply and free memory.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> *allocate(size_type size);
          <span class="comment">// Return a pointer to an uninitialized memory of the specified</span>
          <span class="comment">// &#39;size (in bytes).</span>

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *address);
          <span class="comment">// Return the memory at the specified &#39;address&#39; to this allocator.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> blocksOutstanding() <span class="keyword">const</span>;
          <span class="comment">// Return the number of blocks outstanding (i.e., allocated but not</span>
          <span class="comment">// yet deallocated by this counting allocator).</span>
  };
</pre></div><br/>
<br/>
 The implementation is really straightforward: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_countingallocator.cpp</span>

                           <span class="comment">// --------------------------</span>
                           <span class="comment">// class my_CountingAllocator</span>
                           <span class="comment">// --------------------------</span>

  <span class="comment">// CREATORS</span>
  my_CountingAllocator::my_CountingAllocator()
  : d_blocksOutstanding(0)
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">void</span> *my_CountingAllocator::allocate(size_type size)
  {
      ++d_blocksOutstanding;
      <span class="keywordflow">return</span> <a class="code" href="group__bslma__allocator.html#gac5363158ac0ed1690a6a09e3300c19e5">operator new</a>(size);
  }

  <span class="keywordtype">void</span> my_CountingAllocator::deallocate(<span class="keywordtype">void</span> *address)
  {
      --d_blocksOutstanding;
      <a class="code" href="group__bslma__allocator.html#ga6cf9e81d957defe9c22a005d59e9624d">operator delete</a>(address);
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keywordtype">int</span> my_CountingAllocator::blocksOutstanding()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_blocksOutstanding;
  }
</pre></div><br/>
<br/>
 Now we can create array objects with different allocator mechanisms. First we create an array, <code>a1</code>, using the default allocator and fill it with the values <code>[ 1 .. 5 ]</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main() {

      my_FixedSizeArray&lt;int, bsl::allocator&lt;int&gt; &gt; a1(5);
      assert(5 == a1.length());
      assert(<a class="code" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator</a>() == a1.allocator());

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; a1.length(); ++i) {
          a1[i] = i + 1;
      }
</pre></div><br/>
<br/>
 Then we create a copy of <code>a1</code> using the counting allocator. The values of <code>a1</code> and <code>a2</code> are equal, even though they have different allocation mechanisms. <br/>
<br/>
<div class="fragment"><pre class="fragment">      my_CountingAllocator countingAlloc;
      my_FixedSizeArray&lt;int, bsl::allocator&lt;int&gt; &gt; a2(a1,&amp;countingAlloc);
      assert(a1 == a2);
      assert(a1.allocator() != a2.allocator());
      assert(&amp;countingAlloc == a2.allocator());
      assert(1 == countingAlloc.blocksOutstanding())
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga805a9265040329e62bb03c5e599f7a65"></a><!-- doxytag: member="bsl::allocator::size_type" ref="ga805a9265040329e62bb03c5e599f7a65" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga11592900f659edf1527778145f94382d"></a><!-- doxytag: member="bsl::allocator::difference_type" ref="ga11592900f659edf1527778145f94382d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab040ead7cb9559795d86ad6fd780fca9"></a><!-- doxytag: member="bsl::allocator::pointer" ref="gab040ead7cb9559795d86ad6fd780fca9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga265cdbf7be2cde5407223541f8089e2c"></a><!-- doxytag: member="bsl::allocator::const_pointer" ref="ga265cdbf7be2cde5407223541f8089e2c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0cc70630a7705e6d1f2f9cc2b3ea0294"></a><!-- doxytag: member="bsl::allocator::reference" ref="ga0cc70630a7705e6d1f2f9cc2b3ea0294" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T&amp; <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3d75f8882aa4270f8c09513276146a6b"></a><!-- doxytag: member="bsl::allocator::const_reference" ref="ga3d75f8882aa4270f8c09513276146a6b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2f5a301855ebda2806d7644dc635ac56"></a><!-- doxytag: member="bsl::allocator::value_type" ref="ga2f5a301855ebda2806d7644dc635ac56" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga96e756efd4a9f33778f874ecc4d03eb1"></a><!-- doxytag: member="bsl::allocator&lt; void &gt;::size_type" ref="ga96e756efd4a9f33778f874ecc4d03eb1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; void &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2fa0d9a832532b3fae1e875e5b7824ea"></a><!-- doxytag: member="bsl::allocator&lt; void &gt;::difference_type" ref="ga2fa0d9a832532b3fae1e875e5b7824ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; void &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaadc5ca24fcd421a097b1ccfd9c10f32a"></a><!-- doxytag: member="bsl::allocator&lt; void &gt;::pointer" ref="gaadc5ca24fcd421a097b1ccfd9c10f32a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; void &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga53d6f82c890bf4ff86e1ded57675b283"></a><!-- doxytag: member="bsl::allocator&lt; void &gt;::const_pointer" ref="ga53d6f82c890bf4ff86e1ded57675b283" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const void* <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; void &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gacd165d8920a3aadfd96b8fd552e38018"></a><!-- doxytag: member="bsl::allocator&lt; void &gt;::value_type" ref="gacd165d8920a3aadfd96b8fd552e38018" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; void &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga23c7d73de0e0fc022177c8ba481b5a34"></a><!-- doxytag: member="bsl::allocator::BSLMF_NESTED_TRAIT_DECLARATION" ref="ga23c7d73de0e0fc022177c8ba481b5a34" args="(allocator, bsl::is_trivially_copyable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsl_1_1is__trivially__copyable.html">bsl::is_trivially_copyable</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga94c03ff5d40ef571743b585c36caa772"></a><!-- doxytag: member="bsl::allocator::BSLMF_NESTED_TRAIT_DECLARATION" ref="ga94c03ff5d40ef571743b585c36caa772" args="(allocator, BloombergLP::bslmf::IsBitwiseMoveable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslmf::IsBitwiseMoveable&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad4f94f94652cc64597cbf9e5b5c0353e"></a><!-- doxytag: member="bsl::allocator::BSLMF_NESTED_TRAIT_DECLARATION" ref="gad4f94f94652cc64597cbf9e5b5c0353e" args="(allocator, BloombergLP::bslmf::IsBitwiseEqualityComparable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslmf::IsBitwiseEqualityComparable&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Declare nested type traits for this class. </p>

</div>
</div>
<a class="anchor" id="ga406e9e1772e150de7e36aebfa3682612"></a><!-- doxytag: member="bsl::allocator::allocator" ref="ga406e9e1772e150de7e36aebfa3682612" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a proxy object which will forward allocation calls to the object pointed to by <code><a class="el" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator()</a></code>. Postcondition: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          this-&gt;<a class="code" href="group__bslstl__allocator.html#ga0325472ed841f5189359b2a0d7920f23">mechanism</a>() == <a class="code" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator</a>();
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ga11b43657c23f967d54fda0a14342f6bb"></a><!-- doxytag: member="bsl::allocator::allocator" ref="ga11b43657c23f967d54fda0a14342f6bb" args="(BloombergLP::bslma::Allocator *mechanism)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::allocator </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>mechanism</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> pointer to a <code>allocator</code> object which forwards allocation calls to the object pointed to by the specified <code>mechanism</code>. If <code>mechanism</code> is 0, then the currently installed default allocator is used instead. Postcondition: <code>0 == mechanism || this-&gt;mechanism() == mechanism</code>. </p>

</div>
</div>
<a class="anchor" id="ga749b33d3550416991bc6b88d4e0326f0"></a><!-- doxytag: member="bsl::allocator::allocator" ref="ga749b33d3550416991bc6b88d4e0326f0" args="(const allocator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::allocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy construct a proxy object using the same mechanism as rhs. Postcondition: <code>this-&gt;mechanism() == rhs.mechanism()</code>. </p>

</div>
</div>
<a class="anchor" id="ga109d73e81427f7e1605c1934f110c325"></a><!-- doxytag: member="bsl::allocator::allocator" ref="ga109d73e81427f7e1605c1934f110c325" args="(const allocator&lt; U &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::allocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a proxy object sharing the same mechanism object as <code>rhs</code>. The newly constructed allocator will compare equal to rhs, even though they are instantiated on different types. Postcondition: <code>this-&gt;mechanism() == rhs.mechanism()</code>. </p>

</div>
</div>
<a class="anchor" id="gafd5ba6c32251e07c35d2443a62db70a3"></a><!-- doxytag: member="bsl::allocator::~allocator" ref="gafd5ba6c32251e07c35d2443a62db70a3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::~allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. Note that this does not delete the object pointed to by <code>mechanism()</code>. Also note that this method's definition is compiler generated. </p>

</div>
</div>
<a class="anchor" id="gac7499740c1db9d233bd07f41ef5acf34"></a><!-- doxytag: member="bsl::allocator::operator=" ref="gac7499740c1db9d233bd07f41ef5acf34" args="(const allocator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">allocator&amp; <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign this object the value of the specified <code>rhs</code>. Postcondition: <code>this-&gt;mechanism() == rhs-&gt;mechanism()</code>. Note that this does not delete the object pointed to by the previous value of <code>mechanism()</code>. Also note that this method's definition is compiler generated. </p>

</div>
</div>
<a class="anchor" id="ga45e9feb5003f4c9622c56b1f3f31bf87"></a><!-- doxytag: member="bsl::allocator::allocate" ref="ga45e9feb5003f4c9622c56b1f3f31bf87" args="(size_type n, const void *hint=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pointer <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__allocator.html#ga805a9265040329e62bb03c5e599f7a65">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>hint</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate enough (properly aligned) space for <code>n</code> objects of type <code>T</code> by calling <code>allocate</code> on the mechanism object. The <code>hint</code> argument is ignored by this allocator type. The behavior is undefined unless <code>n &lt;= max_size()</code>. </p>

</div>
</div>
<a class="anchor" id="gaece540c244e6beee6a5b8ccbaac82c05"></a><!-- doxytag: member="bsl::allocator::deallocate" ref="gaece540c244e6beee6a5b8ccbaac82c05" args="(pointer p, size_type n=1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__allocator.html#gab040ead7cb9559795d86ad6fd780fca9">pointer</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__allocator.html#ga805a9265040329e62bb03c5e599f7a65">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return memory previously allocated with <code>allocate</code> to the underlying mechanism object by calling <code>deallocate</code> on the the mechanism object. The <code>n</code> argument is ignored by this allocator type. </p>

</div>
</div>
<a class="anchor" id="ga70c058a8054ad704de18a7aca93aa683"></a><!-- doxytag: member="bsl::allocator::construct" ref="ga70c058a8054ad704de18a7aca93aa683" args="(pointer p, const T &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__allocator.html#gab040ead7cb9559795d86ad6fd780fca9">pointer</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy-construct a <code>T</code> object at the memory address specified by <code>p</code>. Do not directly allocate memory. Undefined if <code>p</code> is not properly aligned for <code>T</code>. </p>

</div>
</div>
<a class="anchor" id="gab95d1740230a070b3e40a3b2712985f1"></a><!-- doxytag: member="bsl::allocator::destroy" ref="gab95d1740230a070b3e40a3b2712985f1" args="(pointer p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__allocator.html#gab040ead7cb9559795d86ad6fd780fca9">pointer</a>&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call the <code>T</code> destructor for the object pointed to by <code>p</code>. Do not directly deallocate any memory. </p>

</div>
</div>
<a class="anchor" id="ga0325472ed841f5189359b2a0d7920f23"></a><!-- doxytag: member="bsl::allocator::mechanism" ref="ga0325472ed841f5189359b2a0d7920f23" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">BloombergLP::bslma::Allocator* <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::mechanism </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pointer to the mechanism object to which this proxy forwards allocation and deallocation calls. </p>

</div>
</div>
<a class="anchor" id="gad5267207812c4278aef372adcca370ac"></a><!-- doxytag: member="bsl::allocator::address" ref="gad5267207812c4278aef372adcca370ac" args="(reference x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pointer <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__allocator.html#ga0cc70630a7705e6d1f2f9cc2b3ea0294">reference</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="ga9fb743d06ff51b08e62d3223dc59446b"></a><!-- doxytag: member="bsl::allocator::address" ref="ga9fb743d06ff51b08e62d3223dc59446b" args="(const_reference x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_pointer <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__allocator.html#ga3d75f8882aa4270f8c09513276146a6b">const_reference</a>&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="ga4531b068b672b1c2f09bc316d884d031"></a><!-- doxytag: member="bsl::allocator::max_size" ref="ga4531b068b672b1c2f09bc316d884d031" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; T &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum number of elements of type <code>T</code> that can be allocated using this allocator. Note that there is no guarantee that attempts at allocating less elements than the value returned by <code>max_size</code> will not throw. </p>

</div>
</div>
<a class="anchor" id="gad1ee2be9d1e85efa55bfa1ae01da5e32"></a><!-- doxytag: member="bsl::allocator&lt; void &gt;::BSLMF_NESTED_TRAIT_DECLARATION" ref="gad1ee2be9d1e85efa55bfa1ae01da5e32" args="(allocator, bsl::is_trivially_copyable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; void &gt;::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; void &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsl_1_1is__trivially__copyable.html">bsl::is_trivially_copyable</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad4c8f45387afb9ee8774f8af1ac56bc9"></a><!-- doxytag: member="bsl::allocator&lt; void &gt;::BSLMF_NESTED_TRAIT_DECLARATION" ref="gad4c8f45387afb9ee8774f8af1ac56bc9" args="(allocator, BloombergLP::bslmf::IsBitwiseMoveable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; void &gt;::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; void &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslmf::IsBitwiseMoveable&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8fe9051795cbe8110becebb12152cebb"></a><!-- doxytag: member="bsl::allocator&lt; void &gt;::BSLMF_NESTED_TRAIT_DECLARATION" ref="ga8fe9051795cbe8110becebb12152cebb" args="(allocator, BloombergLP::bslmf::IsBitwiseEqualityComparable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; void &gt;::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; void &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslmf::IsBitwiseEqualityComparable&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Declare nested type traits for this class. PUBLIC TYPES </p>

</div>
</div>
<a class="anchor" id="gab8b77c2e92a6c1b37cb9c21d0b0783c9"></a><!-- doxytag: member="bsl::allocator&lt; void &gt;::allocator" ref="gab8b77c2e92a6c1b37cb9c21d0b0783c9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; void &gt;::allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a proxy object which will forward allocation calls to the object pointed to by <code><a class="el" href="structbslma_1_1Default.html#aef37c008128ff52f8fec313f6df5581d">bslma::Default::defaultAllocator()</a></code>. </p>

</div>
</div>
<a class="anchor" id="gac139021032aaa9ee9267696a94dbbc35"></a><!-- doxytag: member="bsl::allocator&lt; void &gt;::allocator" ref="gac139021032aaa9ee9267696a94dbbc35" args="(BloombergLP::bslma::Allocator *mechanism)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; void &gt;::allocator </td>
          <td>(</td>
          <td class="paramtype">BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>mechanism</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> pointer to a <code>allocator</code> object which forwards allocation calls to the object pointed to by the specified <code>mechanism</code>. If <code>mechanism</code> is 0, then the current default allocator is used instead. Postcondition: <code>0 == mechanism || this-&gt;mechanism() == mechanism</code>. </p>

</div>
</div>
<a class="anchor" id="ga8394ec6606c6455c75ba36b10a50b237"></a><!-- doxytag: member="bsl::allocator&lt; void &gt;::allocator" ref="ga8394ec6606c6455c75ba36b10a50b237" args="(const allocator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; void &gt;::allocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; void &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy construct a proxy object using the same mechanism as rhs. Postcondition: <code>this-&gt;mechanism() == rhs.mechanism()</code>. </p>

</div>
</div>
<a class="anchor" id="ga8ea1dfcd3c9bc298b6a3731830738b02"></a><!-- doxytag: member="bsl::allocator&lt; void &gt;::allocator" ref="ga8ea1dfcd3c9bc298b6a3731830738b02" args="(const allocator&lt; U &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; void &gt;::allocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; U &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a proxy object sharing the same mechanism object as <code>rhs</code>. The newly constructed allocator will compare equal to rhs, even though they are instantiated on different types. Postcondition: <code>this-&gt;mechanism() == rhs.mechanism()</code>. </p>

</div>
</div>
<a class="anchor" id="gaf98317ed19012db5bd9f1702f59bdaa1"></a><!-- doxytag: member="bsl::allocator&lt; void &gt;::~allocator" ref="gaf98317ed19012db5bd9f1702f59bdaa1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; void &gt;::~allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. Note that this does not delete the object pointed to by <code>mechanism()</code>. Also note that this method's definition is compiler generated. </p>

</div>
</div>
<a class="anchor" id="gabce216dd9a18b336e8a35f83ce56bdf5"></a><!-- doxytag: member="bsl::allocator&lt; void &gt;::operator=" ref="gabce216dd9a18b336e8a35f83ce56bdf5" args="(const allocator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">allocator&amp; <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; void &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1allocator.html">allocator</a>&lt; void &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign this object the value of the specified <code>rhs</code>. Postcondition: <code>this-&gt;mechanism() == rhs-&gt;mechanism()</code>. Note that this does not delete the object pointed to by the previous value of <code>mechanism()</code>. Also note that this method's definition is compiler generated. </p>

</div>
</div>
<a class="anchor" id="ga8b506fae8c08d3178bb02893a117d0d1"></a><!-- doxytag: member="bsl::allocator&lt; void &gt;::mechanism" ref="ga8b506fae8c08d3178bb02893a117d0d1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BloombergLP::bslma::Allocator* <a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a>&lt; void &gt;::mechanism </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pointer to the mechanism object to which this proxy forwards allocation and deallocation calls. </p>

</div>
</div>
<a class="anchor" id="gad6d3f796409781b394c2140195a5b7d2"></a><!-- doxytag: member="bsl::operator==" ref="gad6d3f796409781b394c2140195a5b7d2" args="(const allocator&lt; T1 &gt; &amp;lhs, const allocator&lt; T2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const allocator&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator&lt; T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true <code>lhs</code> and <code>rhs</code> are proxies for the same <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object. This is a practical implementation of the STL requirement that two allocators compare equal if and only if memory allocated from one can be deallocated from the other. Note that the two allocators need not be instantiated on the same type in order to compare equal. </p>

</div>
</div>
<a class="anchor" id="gaf374c3c1f79238d64b145df26aa1845c"></a><!-- doxytag: member="bsl::operator!=" ref="gaf374c3c1f79238d64b145df26aa1845c" args="(const allocator&lt; T1 &gt; &amp;lhs, const allocator&lt; T2 &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const allocator&lt; T1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator&lt; T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>!(lhs == rhs)</code>. </p>

</div>
</div>
<a class="anchor" id="gac670def83951dc213e173ca26625f3d0"></a><!-- doxytag: member="bsl::operator==" ref="gac670def83951dc213e173ca26625f3d0" args="(const allocator&lt; T &gt; &amp;lhs, const BloombergLP::bslma::Allocator *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const allocator&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if <code>lhs.mechanism() == rhs</code>. </p>

</div>
</div>
<a class="anchor" id="gabdcd355a6885da0eb7d47aa7410aee04"></a><!-- doxytag: member="bsl::operator!=" ref="gabdcd355a6885da0eb7d47aa7410aee04" args="(const allocator&lt; T &gt; &amp;lhs, const BloombergLP::bslma::Allocator *rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const allocator&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>!(lhs == rhs)</code>. </p>

</div>
</div>
<a class="anchor" id="ga61cb1e180a4ddd04c182bb7bc91384e8"></a><!-- doxytag: member="bsl::operator==" ref="ga61cb1e180a4ddd04c182bb7bc91384e8" args="(const BloombergLP::bslma::Allocator *lhs, const allocator&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if <code>lhs == rhs.mechanism()</code>. </p>

</div>
</div>
<a class="anchor" id="ga0a4465ac5dff39c1acd5cb17efb89dab"></a><!-- doxytag: member="bsl::operator!=" ref="ga0a4465ac5dff39c1acd5cb17efb89dab" args="(const BloombergLP::bslma::Allocator *lhs, const allocator&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const BloombergLP::bslma::Allocator *&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const allocator&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>!(lhs == rhs)</code>. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:43 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
