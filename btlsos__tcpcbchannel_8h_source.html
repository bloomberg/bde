<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// btlsos_tcpcbchannel.h                                              -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BTLSOS_TCPCBCHANNEL
#define INCLUDED_BTLSOS_TCPCBCHANNEL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide stream-based communication channel over TCP sockets.
//
//@CLASSES:
//  btlsos::TcpCbChannel: non-blocking non-timed channel over TCP/IPv4 sockets
//
//@SEE_ALSO:  btlsos_tcptimedcbacceptor btlsos_tcptimedcbconnector
//
//@SEE_ALSO:  btlsos_tcptimedcbchannel btlso_streamsocket
//
//@SEE_ALSO:  btlsc_timedcbchannel btlsc_timedchannel
//
//@DESCRIPTION: This component provides a non-blocking communication channel
// over TCP/IPv4 sockets, &#39;btlsos::TcpCbChannel&#39;, that adheres to
// &#39;btlsc::TimedCbChannel&#39; protocol.  Following the protocol, only operations
// without timeout are supported.  The channel uses user-installed event
// manager(s) to monitor an underlying socket for incoming events; two event
// managers can be installed in order to monitor for read and write events in
// different event managers.
//
// This channel uses a user-provided stream socket for IPv4 address family.
// Any concrete implementation that provides socket-like primitives is allowed.
// Common paradigms of acceptor and connector that produce channels directly is
// implemented (in other components) for both user convenience and completeness
// of the framework (see &#39;btlsos_tcptimedcbacceptor&#39; and
// &#39;btlsos_tcptimedcbconnector&#39; components).
//
///Thread Safety
///-------------
// Generally speaking, this channel is *not* *thread-safe*, meaning that any
// operation can not be called on *distinct instances* from different threads
// without any side-effects.  Thread-safety of this channel depends on whether
// or not given event manager(s), stream socket implementation, and memory
// allocator is *thread enabled (meaning that any operation can be invoked on
// the same instance from different threads).  If two channels share the same
// event manager, memory manager, and stream socket, then this two instances
// are thread safe if and only if the user-installed components are thread
// enabled.
//
///Performance
///-----------
// This channel is optimized for homogeneous operations, where homogeneity is
// consider within read or write domains in three different categories:
// buffered, non-buffered, and vectored.  Thus, it is advised that, for optimal
// performance, only one category within domain is used.
//
///Usage
///-----
//..
// See the {&#39;btlsos_tcptimedcbacceptor&#39;} component.
//..

#ifndef INCLUDED_BTLSCM_VERSION
#include &lt;btlscm_version.h&gt;
#endif

#ifndef INCLUDED_BTLSC_CBCHANNEL
#include &lt;btlsc_cbchannel.h&gt;
#endif

#ifndef INCLUDED_BDLMA_POOL
#include &lt;bdlma_pool.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSL_DEQUE
#include &lt;bsl_deque.h&gt;
#endif

#ifndef INCLUDED_BSL_FUNCTIONAL
#include &lt;bsl_functional.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {
namespace btlso { class IPv4Address; }
namespace btlso { template&lt;class ADDRESS&gt; class StreamSocket; }
namespace btlso { class TimerEventManager; }
namespace btlsos {class TcpCbChannel_RReg;  // Component local class

                                            // declaration

class TcpCbChannel_WReg;  // Component local class declaration

                            // ==================
                            // class TcpCbChannel
                            // ==================

class TcpCbChannel : public btlsc::CbChannel {
    // This class implements a &#39;btesc&#39;-style (non-timed) callback-based channel
    // for a single TCP/IPv4 socket.  The I/O requests are enqueued along with
    // their callbacks.  The callbacks are invoked as appropriate.  In general,
    // the status supplied to the callback is less than -1 for failure, -1 when
    // channel detects that connection is closed, 0 for an interrupted
    // operation due to either restartable interruption of an underlying system
    // call (secondary status of 1), or dequeueing/cancellation (secondary
    // status of -1).  A registration method returns 0 if registration is
    // successful, and a non-zero value otherwise, in which case the channel is
    // invalid and no other registration attempts will succeed.

    btlso::StreamSocket&lt;btlso::IPv4Address&gt;   *d_socket_p;
    btlso::TimerEventManager     *d_rManager_p;
    btlso::TimerEventManager     *d_wManager_p;

    bsl::vector&lt;char&gt;            d_readBuffer;
    int                          d_readBufferOffset;
    int                          d_readBufferSP;      // stack pointer

    bsl::vector&lt;char&gt;            d_writeBuffer;
    int                          d_writeBufferOffset;

    bsl::deque&lt;TcpCbChannel_RReg *&gt;
                                 d_readRequests;

    bsl::deque&lt;TcpCbChannel_WReg *&gt;
                                 d_writeRequests;

    bsl::function&lt;void()&gt;        d_bufferedReadFunctor;
    bsl::function&lt;void()&gt;        d_readFunctor;

    bsl::function&lt;void()&gt;        d_bufferedWriteFunctor;
    bsl::function&lt;void()&gt;        d_writeFunctor;

    bdlma::Pool                  d_rrequestPool; // read requests&#39; pool
    bdlma::Pool                  d_wrequestPool; // write requests&#39; pool
    bslma::Allocator            *d_allocator_p;

    int                          d_isInvalidReadFlag;
    int                          d_isInvalidWriteFlag;

    TcpCbChannel_RReg
                                *d_currentReadRequest_p;
    TcpCbChannel_WReg
                                *d_currentWriteRequest_p;
  private:
    // PRIVATE MANIPULATORS
    void initializeReadBuffer(int size = -1);
        // Initialize internal read buffer with the optionally specified
        // &#39;size&#39;.  If &#39;size&#39; is not specified, the default that is obtained by
        // querying the underlying socket is used.

    void initializeWriteBuffer(int size = -1);
        // Initialize internal write buffer with the optionally specified
        // &#39;size&#39;.  If &#39;size&#39; is not specified, the default that is obtained by
        // querying the underlying socket is used.

    // Callback methods.

    void bufferedReadCb();
        // Process the request on top of the read requests queue, invoke the
        // callback associated with the request as needed, and register
        // callbacks, as needed for the next request, if any.  The behavior is
        // undefined if read requests queue is empty or the request on top of
        // this queue is not a buffered read request.

    void readCb();
        // Process the request on top of the read requests queue, invoke the
        // callback associated with the request as needed, and register
        // callbacks, as needed for the next request, if any.  The behavior is
        // undefined if read requests queue is empty or the request on top of
        // this queue is a buffered read request.

    void bufferedWriteCb();
        // Process the request on top of the write requests queue, invoke the
        // callback associated with the request as needed, and register
        // callbacks, as needed for the next request, if any.  The behavior is
        // undefined if write requests queue is empty or the request on top of
        // this queue is not a buffered write request.

    void writeCb();
        // Process the request on top of the write requests queue, invoke the
        // callback associated with the request as needed, and register
        // callbacks, as needed for the next request, if any.  The behavior is
        // undefined if write requests queue is empty or the request on top of
        // this queue is a buffered write request.

  private:
    // Not implemented:
    TcpCbChannel(const TcpCbChannel&amp;);
    TcpCbChannel&amp; operator=(const TcpCbChannel);

  public:
    // CREATORS
    TcpCbChannel(btlso::StreamSocket&lt;btlso::IPv4Address&gt; *sSocket,
                 btlso::TimerEventManager                *manager,
                 bslma::Allocator                        *basicAllocator = 0);
        // Create a callback channel for the TCP/IPv4 that uses the specified
        // &#39;sSocket&#39; for socket-level communications, the specified &#39;manager&#39;
        // to monitor for incoming data and for availability of space in the
        // system&#39;s buffer for outgoing data.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.  The behavior is
        // undefined unless both &#39;sSocket&#39; and &#39;manager&#39; are not 0.  Note that
        // the I/O mode of &#39;sSocket&#39; will be changed to non-blocking.  Usage of
        // &#39;sSocket&#39; directly simultaneously with this channel may result in an
        // undefined behavior of the channel.

    TcpCbChannel(btlso::StreamSocket&lt;btlso::IPv4Address&gt; *sSocket,
                 btlso::TimerEventManager                *rManager,
                 btlso::TimerEventManager                *wManager,
                 bslma::Allocator                        *basicAllocator = 0);
        // Create a callback channel for the TCP/IPv4 that uses the specified
        // &#39;sSocket&#39; for socket-level communications, the specified &#39;rManager&#39;
        // to monitor for incoming data and the specified &#39;wManager&#39; for
        // availability of space in the system&#39;s buffer for outgoing data.
        // Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.  The behavior is undefined unless &#39;sSocket&#39;, &#39;rManager&#39; and
        // &#39;wManager&#39; are not 0.  Note that the I/O mode of &#39;sSocket&#39; will be
        // changed to non-blocking.  Usage of &#39;sSocket&#39; directly simultaneously
        // with this channel may result in an undefined behavior of the
        // channel.

    ~TcpCbChannel();
        // Invalidate this channel, cancel all read and write pending requests
        // (and invoke the associated callbacks), deregister from event
        // manager(s) as required, and destroy this channel.

    // MANIPULATORS
    int read(char                *buffer,
             int                  numBytes,
             const ReadCallback&amp;  readCallback,
             int                  flags = 0);
        // Initiate a non-blocking operation to read the specified &#39;numBytes&#39;
        // from this channel into the specified &#39;buffer&#39;; execute the specified
        // &#39;readCallback&#39; functor after this read operation terminates.  If the
        // optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Return 0 on successful initiation, and a non-zero value
        // otherwise (in which case &#39;readCallback&#39; will not be invoked).
        //
        // When invoked, the &#39;readCallback&#39; is passed an integer &quot;status&quot; and a
        // second integer &quot;augStatus&quot; (which is meaningful only upon an
        // incomplete transmission).  If &quot;status&quot; is equal to &#39;numBytes&#39;, the
        // operation was successful and &#39;buffer&#39; is loaded with &#39;numBytes&#39; of
        // newly read data.  Otherwise, if &quot;status&quot; is non-negative (incomplete
        // read), it indicates the number of bytes read into &#39;buffer&#39; in which
        // case &quot;augStatus&quot; will be positive if the operation was interrupted
        // due to an asynchronous event, and negative (&quot;status&quot; identically 0)
        // if this operation was cancelled.  If the transmission is incomplete,
        // the channel itself potentially remains valid; hence, this (or
        // another) operation may be retried (with arguments suitably adjusted)
        // with some reasonable hope of success.  A negative &quot;status&quot;, however,
        // indicates a permanent error (leaving the contents of &#39;buffer&#39;
        // undefined); -1 implies that the connection was closed by the peer
        // (but the converse is not guaranteed).  The behavior is undefined
        // unless &#39;buffer&#39; has sufficient capacity to hold the requested data
        // and remains valid until the (non-null) &#39;readCallback&#39; completes, and
        // &#39;0 &lt; numBytes&#39;.

    int readv(const btls::Iovec   *buffers,
              int                  numBuffers,
              const ReadCallback&amp;  readCallback,
              int                  flags = 0);
        // Initiate a non-blocking operation to read from this channel into the
        // specified sequence of &#39;buffers&#39; of specified sequence length
        // &#39;numBuffers&#39; the respective numbers of bytes as defined by the
        // &#39;d_length&#39; fields of each &#39;Iovec&#39; structure; execute the specified
        // &#39;readCallback&#39; functor after this read operation terminates.  If the
        // optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Return 0 on successful initiation, and a non-zero value
        // otherwise (in which case &#39;readCallback&#39; will not be invoked).
        //
        // When invoked, &#39;readCallback&#39; is passed an integer &quot;status&quot; and a
        // second integer &quot;augStatus&quot; (which is meaningful only upon an
        // incomplete transmission).  If &quot;status&quot; is equal to the total number
        // of requested bytes (i.e., the sum of the &#39;numBuffers&#39; &#39;d_length&#39;
        // fields in &#39;buffers&#39;) the operation was successful and each
        // respective &#39;d_buffer_p&#39; is loaded with its corresponding &#39;d_length&#39;
        // bytes of newly read data.  Otherwise, if &quot;status&quot; is non-negative
        // (incomplete read), it indicates the number of bytes read into these
        // respective buffers in sequence in which case &quot;augStatus&quot; will be
        // positive if the operation was interrupted due to an asynchronous
        // event, and negative (&quot;status&quot; identically 0) if this operation was
        // cancelled.  A negative &quot;status&quot;, however, indicates a permanent
        // error (leaving the contents of &#39;buffer&#39; undefined); -1 implies that
        // the connection was closed by the peer (but the converse is not
        // guaranteed).  The behavior is undefined unless &#39;buffer&#39; has
        // sufficient capacity to hold the requested data and remains valid
        // until the (non-null) &#39;readCallback&#39; completes, and 0 &lt; numBytes.

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    int readRaw(char                *buffer,
                int                  numBytes,
                const ReadCallback&amp;  readCallback,
                int                  flags = 0);
        // Initiate a non-blocking operation to *atomically* read *up *to* the
        // specified &#39;numBytes&#39; from this channel into the specified &#39;buffer&#39;;
        // execute the specified &#39;readCallback&#39; functor after this read
        // operation terminates.  If the optionally specified &#39;flags&#39;
        // incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot;
        // are permitted to interrupt this operation; by default, such events
        // are ignored.  Return 0 on successful initiation, and a non-zero
        // value otherwise (in which case &#39;readCallback&#39; will not be invoked).
        //
        // When invoked, &#39;readCallback&#39; is passed an integer &quot;status&quot; and a
        // second integer &quot;augStatus&quot; (which is meaningful only upon an
        // incomplete transmission).  If &quot;status&quot; is equal to &#39;numBytes&#39;, the
        // operation was successful and &#39;buffer&#39; is loaded with &#39;numBytes&#39; of
        // newly read data.  Otherwise, if &quot;status&quot; is non-negative (incomplete
        // read), it indicates the number of bytes read into &#39;buffer&#39; in which
        // case &quot;augStatus&quot; will be positive if the operation was interrupted
        // due to an asynchronous event, and negative (status &gt; 0) if the
        // atomic OS-level write operation wrote at least one but less than
        // &#39;numBytes&#39; or (&quot;status&quot; identically 0) if this operation was
        // cancelled.  If the transmission is incomplete, the channel itself
        // potentially remains valid; hence, this (or another) operation may be
        // retried (with arguments suitably adjusted) with some reasonable hope
        // of success.  A negative &quot;status&quot;, however, indicates a permanent
        // error: -1 implies that the connection was closed by the peer (but
        // the converse is not guaranteed).  The behavior is undefined unless
        // &#39;buffer&#39; has sufficient capacity to hold the requested data and
        // remains valid until the (non-null) &#39;readCallback&#39; completes, and
        // &#39;0 &lt; numBytes&#39;.

    int readvRaw(const btls::Iovec   *buffers,
                 int                  numBuffers,
                 const ReadCallback&amp;  readCallback,
                 int                  flags = 0);
        // Initiate a non-blocking operation to *atomically* read from this
        // channel into the specified sequence of &#39;buffers&#39; of specified
        // sequence length &#39;numBuffers&#39; *up* *to* the respective numbers of
        // bytes as defined by the &#39;d_length&#39; fields of each &#39;Iovec&#39; structure;
        // execute the specified &#39;readCallback&#39; functor after this read
        // operation terminates.  If the optionally specified &#39;flags&#39;
        // incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot;
        // are permitted to interrupt this operation; by default, such events
        // are ignored.  Return 0 on successful initiation, and a non-zero
        // value otherwise (in which case &#39;readCallback&#39; will not be invoked).
        //
        // When invoked, &#39;readCallback&#39; is passed an integer &quot;status&quot; and a
        // second integer &quot;augStatus&quot; (which is meaningful only upon an
        // incomplete transmission).  If &quot;status&quot; is equal to the total number
        // of requested bytes (i.e., the sum of the &#39;numBuffers&#39; &#39;d_length&#39;
        // fields in &#39;buffers&#39;) the operation was successful and each
        // respective &#39;d_buffer_p&#39; is loaded with its corresponding &#39;d_length&#39;
        // bytes of newly read data.  Otherwise, if &quot;status&quot; is non-negative
        // (incomplete read), it indicates the number of bytes read into these
        // respective buffers in sequence in which case &quot;augStatus&quot; will be
        // positive if the operation was interrupted due to an asynchronous
        // event, and negative (status &gt; 0) if the atomic OS-level operation
        // transmitted at least one but less than the total requested number of
        // bytes or (&quot;status&quot; identically 0) if this operation was cancelled.
        // A negative &quot;status&quot;, however, indicates a permanent error (leaving
        // the contents of &#39;buffer&#39; undefined); -1 implies that the connection
        // was closed by the peer (but the converse is not guaranteed).  The
        // behavior is undefined unless &#39;buffer&#39; has sufficient capacity to
        // hold the requested data and remains valid until the (non-null)
        // &#39;readCallback&#39; completes, and 0 &lt; numBytes.

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    int bufferedRead(int                         numBytes,
                     const BufferedReadCallback&amp; bufferedReadCallback,
                     int                         flags = 0);
        // Initiate a non-blocking operation to read the specified &#39;numBytes&#39;
        // from this channel into a channel-supplied buffer; execute the
        // specified &#39;bufferedReadCallback&#39; functor after this read operation
        // terminates.  If the optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Return 0 on successful initiation, and a non-zero value
        // otherwise (in which case &#39;bufferedReadCallback&#39; will not be
        // invoked).
        //
        // When invoked, &#39;bufferedReadCallback&#39; is passed the address of a
        // non-modifiable character &quot;buffer&quot;, an integer &quot;status&quot;, and a second
        // integer &quot;augStatus&quot; (which is meaningful only upon an incomplete
        // transmission).  If &quot;status&quot; is equal to &#39;numBytes&#39;, the operation
        // was successful and &quot;buffer&quot; contains &#39;numBytes&#39; of newly read data
        // (which will remain valid only until the callback completes).
        // Otherwise, if &quot;status&quot; is non-negative (incomplete read), it
        // indicates the number of (accessible) bytes in &quot;buffer&quot;, in which
        // case &quot;augStatus&quot; will be positive if the operation was interrupted
        // due to an asynchronous event, and negative (&quot;status&quot; identically 0)
        // if this operation was cancelled.  If the transmission is partial,
        // the data is retained in the channel&#39;s buffer and the channel itself
        // potentially remains valid; hence, this (or another) operation may be
        // retried (with arguments suitably adjusted) with some reasonable hope
        // of success.  A negative &quot;status&quot;, however, indicates a permanent
        // error (leaving the contents of &#39;buffer&#39; undefined); -1 implies that
        // the connection was closed by the peer (but the converse is not
        // guaranteed).  The behavior is undefined unless &#39;0 &lt; numBytes&#39; and
        // &#39;bufferedReadCallback&#39; is non-null.

    int bufferedReadRaw(int                         numBytes,
                        const BufferedReadCallback&amp; bufferedReadCallback,
                        int                         flags = 0);
        // Initiate a non-blocking operation to *atomically* read *up *to* the
        // specified &#39;numBytes&#39; from this channel into a channel-supplied
        // buffer; execute the specified &#39;bufferedReadCallback&#39; functor after
        // this read operation terminates.  If the optionally specified &#39;flags&#39;
        // incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot;
        // are permitted to interrupt this operation; by default, such events
        // are ignored.  Return 0 on successful initiation, and a non-zero
        // value otherwise (in which case &#39;bufferedReadCallback&#39; will not be
        // invoked).
        //
        // When invoked, &#39;bufferedReadCallback&#39; is passed the address of a
        // non-modifiable character &quot;buffer&quot;, an integer &quot;status&quot;, and a second
        // integer &quot;augStatus&quot; (which is meaningful only upon an incomplete
        // transmission).  If &quot;status&quot; is equal to &#39;numBytes&#39;, the operation
        // was successful and &quot;buffer&quot; contains &#39;numBytes&#39; of newly read data
        // (which will remain valid only until the callback completes).
        // Otherwise, if &quot;status&quot; is non-negative (incomplete read), it
        // indicates the number of (accessible) bytes in &quot;buffer&quot;, in which
        // case &quot;augStatus&quot; will be positive if the operation was interrupted
        // due to an asynchronous event and negative (status &gt; 0) if the atomic
        // OS-level operation transmitted at least one but less than &#39;numBytes&#39;
        // or (&quot;status&quot; identically 0) if this operation was cancelled.  If the
        // transmission is incomplete, the data is retained in the channel&#39;s
        // buffer and the channel itself potentially remains valid; hence, this
        // (or another) operation may be retried (with arguments suitably
        // adjusted) with some reasonable hope of success.  A negative
        // &quot;status&quot;, however, indicates a permanent error (leaving the contents
        // of &#39;buffer&#39; undefined); -1 implies that the connection was closed by
        // the peer (but the converse is not guaranteed).  The behavior is
        // undefined unless &#39;0 &lt; numBytes&#39; and &#39;bufferedReadCallback&#39; is
        // non-null.

    // = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

    int write(const char           *buffer,
              int                   numBytes,
              const WriteCallback&amp;  writeCallback,
              int                   flags = 0);
        // Initiate a non-blocking operation to write the specified &#39;numBytes&#39;
        // from the specified &#39;buffer&#39; to this channel; execute the specified
        // &#39;writeCallback&#39; functor after this write operation terminates.  If
        // the optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Return 0 on successful initiation, and a non-zero value
        // otherwise (in which case &#39;writeCallback&#39; will not be invoked).
        //
        // When invoked, &#39;writeCallback&#39; is passed an integer &quot;status&quot; and a
        // second integer &quot;augStatus&quot; (which is meaningful only upon an
        // incomplete transmission).  If &quot;status&quot; is equal to &#39;numBytes&#39;, the
        // operation was successful and all &#39;numBytes&#39; of data were transmitted
        // to the channel.  Otherwise, if &quot;status&quot; is non-negative (incomplete
        // write), it indicates the number of bytes written from &#39;buffer&#39;, in
        // which case &quot;augStatus&quot; will be positive if the operation was
        // interrupted due to an asynchronous event, and negative (&quot;status&quot;
        // identically 0) if this operation was cancelled.  If the transmission
        // is incomplete, the channel itself potentially remains valid; hence,
        // this (or another) operation may be retried (with arguments suitably
        // adjusted) with some reasonable hope of success.  A negative
        // &quot;status&quot;, however, indicates a permanent error; -1 implies that the
        // connection was closed by the peer (but the converse is not
        // guaranteed).  The behavior is undefined unless &#39;buffer&#39; remains
        // valid until the (non-null) &#39;writeCallback&#39; completes, and
        // &#39;0 &lt; numBytes&#39;.

    int writeRaw(const char           *buffer,
                 int                   numBytes,
                 const WriteCallback&amp;  writeCallback,
                 int                   flags = 0);
        // Initiate a non-blocking operation to *atomically* write *up *to* the
        // specified &#39;numBytes&#39; from the specified &#39;buffer&#39; to this channel;
        // execute the specified &#39;writeCallback&#39; functor after this write
        // operation terminates.  If the optionally specified &#39;flags&#39;
        // incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot;
        // are permitted to interrupt this operation; by default, such events
        // are ignored.  Return 0 on successful initiation, and a non-zero
        // value otherwise (in which case &#39;writeCallback&#39; will not be invoked).
        //
        // When invoked, &#39;writeCallback&#39; is passed an integer &quot;status&quot; and a
        // second integer &quot;augStatus&quot; (which is meaningful only upon an
        // incomplete transmission).  If &quot;status&quot; is equal to &#39;numBytes&#39;, the
        // operation was successful and all &#39;numBytes&#39; of data were transmitted
        // to the channel.  Otherwise, if &quot;status&quot; is non-negative (incomplete
        // write), it indicates the number of bytes written from &#39;buffer&#39;, in
        // which case &quot;augStatus&quot; will be positive if the operation was
        // interrupted due to an asynchronous event, and negative (status &gt; 0)
        // if the atomic OS-level operation transmitted at least one but less
        // than &#39;numBytes&#39; or (&quot;status&quot; identically 0) if this operation was
        // cancelled.  If the transmission is incomplete, the channel itself
        // potentially remains valid; hence, this (or another) operation may be
        // retried (with arguments suitably adjusted) with some reasonable hope
        // of success.  A negative &quot;status&quot;, however, indicates a permanent
        // error; -1 implies that the connection was closed by the peer (but
        // the converse is not guaranteed).  The behavior is undefined unless
        // &#39;buffer&#39; remains valid until the (non-null) &#39;writeCallback&#39;
        // completes, and &#39;0 &lt; numBytes&#39;.

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    int writev(const btls::Ovec     *buffers,
               int                   numBuffers,
               const WriteCallback&amp;  writeCallback,
               int                   flags = 0);
    int writev(const btls::Iovec    *buffers,
               int                   numBuffers,
               const WriteCallback&amp;  writeCallback,
               int                   flags = 0);
        // Initiate a non-blocking operation to write to this channel from the
        // specified sequence of &#39;buffers&#39; of specified sequence length
        // &#39;numBuffers&#39; the respective numbers of bytes as defined by the
        // &#39;d_length&#39; fields of each &#39;Ovec&#39; (or &#39;Iovec&#39;) structure; execute the
        // specified &#39;writeCallback&#39; functor after this write operation
        // terminates.  If the optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Return 0 on successful initiation, and a non-zero value
        // otherwise (in which case &#39;writeCallback&#39; will not be invoked).
        //
        // When invoked, &#39;writeCallback&#39; is passed an integer &quot;status&quot; and a
        // second integer &quot;augStatus&quot; (which is meaningful only upon an
        // incomplete transmission).  If &quot;status&quot; is equal to the total number
        // bytes to be written (i.e., the sum of the &#39;numBuffers&#39; &#39;d_length&#39;
        // fields in &#39;buffers&#39;), all indicated data was transmitted to the
        // channel.  Otherwise, if &quot;status&quot; is non-negative (incomplete write),
        // it indicates the number of bytes written in sequence from the
        // indicated buffers, in which case &quot;augStatus&quot; will be positive if the
        // operation was interrupted due to an asynchronous event, and negative
        // (&quot;status&quot; identically 0) if this operation was cancelled.  If the
        // transmission is incomplete, the channel itself potentially remains
        // valid; hence, this (or another) operation may be retried (with
        // arguments suitably adjusted) with some reasonable hope of success.
        // A negative &quot;status&quot;, however, indicates a permanent error; -1
        // implies that the connection was closed by the peer (but the converse
        // is not guaranteed).  The behavior is undefined unless the total
        // number of bytes to be written is *positive* and &#39;buffers&#39; (and the
        // data to which it refers) remains valid until the (non-null)
        // &#39;writeCallback&#39; completes.

    int writevRaw(const btls::Ovec     *buffers,
                  int                   numBuffers,
                  const WriteCallback&amp;  writeCallback,
                  int                   flags = 0);
    int writevRaw(const btls::Iovec    *buffers,
                  int                   numBuffers,
                  const WriteCallback&amp;  writeCallback,
                  int                   flags = 0);
        // Initiate a non-blocking operation to *atomically* write *up *to* the
        // total number of bytes indicated by the specified sequence of
        // &#39;buffers&#39; of specified sequence length &#39;numBuffers&#39; the respective
        // numbers of bytes as defined by the &#39;d_length&#39; fields of each &#39;Ovec&#39;
        // (or &#39;Iovec&#39;) structure; execute the specified &#39;writeCallback&#39;
        // functor after this write operation terminates.  If the optionally
        // specified &#39;flags&#39; incorporates &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;,
        // &quot;asynchronous events&quot; are permitted to interrupt this operation; by
        // default, such events are ignored.  Return 0 on successful
        // initiation, and a non-zero value otherwise (in which case
        // &#39;writeCallback&#39; will not be invoked).
        //
        // When invoked, &#39;writeCallback&#39; is passed an integer &quot;status&quot; and a
        // second integer &quot;augStatus&quot; (which is meaningful only upon an
        // incomplete transmission).  If &quot;status&quot; is equal to the total number
        // bytes to be written (i.e., the sum of the &#39;numBuffers&#39; &#39;d_length&#39;
        // fields in &#39;buffers&#39;), all indicated data was transmitted to the
        // channel.  Otherwise, if &quot;status&quot; is non-negative (incomplete write),
        // it indicates the number of bytes written in sequence from the
        // indicated buffers, in which case &quot;augStatus&quot; will be positive if the
        // operation was interrupted due to an asynchronous event, and negative
        // (status &gt; 0) if the atomic OS-level operation transmitted at least
        // one but less than &#39;numBytes&#39; or (&quot;status&quot; identically 0) if this
        // operation was cancelled.  If the transmission is incomplete, the
        // channel itself potentially remains valid; hence, this (or another)
        // operation may be retried (with arguments suitably adjusted) with
        // some reasonable hope of success.  A negative &quot;status&quot;, however,
        // indicates a permanent error; -1 implies that the connection was
        // closed by the peer (but the converse is not guaranteed).  The
        // behavior is undefined unless the total number of bytes to be written
        // is *positive* and &#39;buffers&#39; (and the data to which it refers)
        // remains valid until the (non-null) &#39;writeCallback&#39; completes.

    int bufferedWrite(const char           *buffer,
                      int                   numBytes,
                      const WriteCallback&amp;  writeCallback,
                      int                   flags = 0);
        // Initiate a non-blocking operation to write the specified &#39;numBytes&#39;
        // from the specified &#39;buffer&#39; to this channel; execute the specified
        // &#39;writeCallback&#39; functor after this write operation terminates.  If
        // the optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Return 0 on successful initiation, and a non-zero value
        // otherwise (in which case &#39;writeCallback&#39; will not be invoked).  Note
        // that the contents of &#39;buffer&#39; need not be preserved after this
        // method returns (except for the purpose of initiating a retry in the
        // event that this operation results in a partial write.
        //
        // When invoked, &#39;writeCallback&#39; is passed an integer &quot;status&quot; and a
        // second integer &quot;augStatus&quot; (which is meaningful only upon an
        // incomplete transmission).  If &quot;status&quot; is equal to &#39;numBytes&#39;, the
        // operation was successful and all &#39;numBytes&#39; of data were transmitted
        // to the channel.  Otherwise, if &quot;status&quot; is non-negative (incomplete
        // write), it indicates the number of bytes written from &#39;buffer&#39;, in
        // which case &quot;augStatus&quot; will be positive if the operation was
        // interrupted due to an asynchronous event and negative (with &quot;status&quot;
        // identically 0) if this operation was cancelled.  If the transmission
        // is incomplete, the remaining buffered data is discarded, but the
        // channel itself potentially remains valid; hence, this (or another)
        // operation may be retried (with arguments suitably adjusted) with
        // some reasonable hope of success.  A negative &quot;status&quot;, however,
        // indicates a permanent error; -1 implies that the connection was
        // closed by the peer (but the converse is not guaranteed).  The
        // behavior is undefined unless &#39;buffer&#39; remains valid until the
        // (non-null) &#39;writeCallback&#39; completes, and &#39;0 &lt; numBytes&#39;.

    int bufferedWritev(const btls::Ovec     *buffers,
                       int                   numBuffers,
                       const WriteCallback&amp;  writeCallback,
                       int                   flags = 0);
    int bufferedWritev(const btls::Iovec    *buffers,
                       int                   numBuffers,
                       const WriteCallback&amp;  writeCallback,
                       int                   flags = 0);
        // Initiate a non-blocking operation to write to this channel from the
        // specified sequence of &#39;buffers&#39; of specified sequence length
        // &#39;numBuffers&#39; the respective numbers of bytes as defined by the
        // &#39;d_length&#39; fields of each &#39;Ovec&#39; (or &#39;Iovec&#39;) structure; execute the
        // specified &#39;writeCallback&#39; functor after this write operation
        // terminates.  If the optionally specified &#39;flags&#39; incorporates
        // &#39;btlsc::Flag::k_ASYNC_INTERRUPT&#39;, &quot;asynchronous events&quot; are
        // permitted to interrupt this operation; by default, such events are
        // ignored.  Return 0 on successful initiation, and a non-zero value
        // otherwise (in which case &#39;writeCallback&#39; will not be invoked).  Note
        // that neither &#39;buffers&#39; nor the data to which it refers need be
        // preserved after this method returns (except for the purpose of
        // initiating a retry in the event that this operation results in a
        // partial write.
        //
        // When invoked, &#39;writeCallback&#39; is passed an integer &quot;status&quot; and a
        // second integer &quot;augStatus&quot; (which is meaningful only upon an
        // incomplete transmission).  If &quot;status&quot; is equal to the total number
        // bytes to be written (i.e., the sum of the &#39;numBuffers&#39; &#39;d_length&#39;
        // fields in &#39;buffers&#39;), all indicated data was transmitted to the
        // channel.  Otherwise, if &quot;status&quot; is non-negative (incomplete write),
        // it indicates the number of bytes written in sequence from the
        // indicated buffers, in which case &quot;augStatus&quot; will be positive if the
        // operation was interrupted due to an asynchronous event, and negative
        // (&quot;status&quot; identically 0) if this operation was cancelled.  If the
        // transmission is incomplete, the remaining buffered data is
        // discarded, but the channel itself potentially remains valid; hence,
        // this (or another) operation may be retried (with arguments suitably
        // adjusted) with some reasonable hope of success.  A negative
        // &quot;status&quot;, however, indicates a permanent error; -1 implies that the
        // connection was closed by the peer (but the converse is not
        // guaranteed).  The behavior is undefined unless the total number of
        // bytes to be written is *positive* and &#39;buffers&#39; (and the data to
        // which it refers) remains valid until the (non-null) &#39;writeCallback&#39;

    // = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

    void cancelAll();
        // Remove all enqueued operations from both the read queue and the
        // write queue of this channel, and, in turn, invoke each callback with
        // a 0 &quot;status&quot; and a negative &quot;augStatus&quot;.  Note that the validity of
        // this channel is not altered by this operation.

    void cancelRead();
        // Remove all enqueued operations from the read queue of this channel,
        // and, in turn, invoke each callback with a 0 &quot;status&quot; and a negative
        // &quot;augStatus&quot;.  Note that the validity of this channel is not altered
        // by this operation.

    void cancelWrite();
        // Remove all enqueued operations from the write queue of this channel,
        // and, in turn, invoke each callback with a 0 &quot;status&quot; and a negative
        // &quot;augStatus&quot;.  Note that the validity of this channel is not altered
        // by this operation.

    void invalidate();
        // Make this channel invalid; no new operations can be initiated
        // successfully.  Pending operations are not affected.

    void invalidateRead();
        // Invalidate the read portion of this channel; no new read operations
        // can be initiated successfully.  Pending operations are not affected.

    void invalidateWrite();
        // Invalidate the write portion of this channel; no new write
        // operations can be initiated successfully.  Pending operations are
        // not affected.

    void setReadEventManager(btlso::TimerEventManager *manager);
        // Set the event manager used for read operations on this channel to
        // the specified &#39;manager&#39;.  The behavior is undefined if manager is 0
        // or unless numPendingReadOperations() is 0.

    void setWriteEventManager(btlso::TimerEventManager *manager);
        // Set the event manager used for write operations on this channel to
        // the specified &#39;manager&#39;.  The behavior is undefined if manager is 0
        // or unless numPendingWriteOperations() is 0.

    // ACCESSORS
    int isInvalidRead() const;
        // Return 1 if the read portion of this (full-duplex) channel is
        // invalid (e.g., due to a read error or an explicit call to
        // &#39;invalidateRead&#39;), and 0 otherwise.  Once the read portion of a
        // channel is invalid, no new read operations can be initiated
        // successfully.  Note that a 0 return value cannot be relied upon to
        // indicate that the read portion of this channel *is* valid.

    int isInvalidWrite() const;
        // Return 1 if the write portion of this (full-duplex) channel is
        // invalid (e.g., due to a write error or an explicit call to
        // &#39;invalidateWrite&#39;), and 0 otherwise.  Once the write portion of a
        // channel is invalid, no new write operations can be initiated
        // successfully.  Note that a 0 return value cannot be relied upon to
        // indicate that the write portion of this channel *is* valid.

    int isInvalid() const; // TBD - remove it.
        // Return 1 if *any* transmission error has occurred or if the channel
        // has been explicitly invalidated (via &#39;invalidate&#39;), and 0 otherwise.
        // Once a channel is invalid, no new operations can be initiated
        // successfully.  Note that the significance of a 0 return cannot be
        // relied upon beyond the return of this method.

    int numPendingReadOperations() const;
        // Return the total number of pending (buffered and unbuffered) read
        // operations for this channel.

    int numPendingWriteOperations() const;
        // Return the total number of pending write operations for this
        // channel.

    btlso::StreamSocket&lt;btlso::IPv4Address&gt; *socket() const;
        // Return the address of the stream-socket used by this channel.

    btlso::TimerEventManager *readEventManager() const;
        // Return the address of an event manager used for monitoring for
        // incoming data on this channel.

    btlso::TimerEventManager *writeEventManager() const;
        // Return the address of an event manager used for monitoring for
        // availability of space in the outgoing buffer on this channel.
};

// ----------------------------------------------------------------------------
//                             INLINE DEFINITIONS
// ----------------------------------------------------------------------------

inline
btlso::StreamSocket&lt;btlso::IPv4Address&gt; *TcpCbChannel::socket() const
{
    return d_socket_p;
}

inline
btlso::TimerEventManager *TcpCbChannel::readEventManager() const {
    return d_rManager_p;
}

inline
btlso::TimerEventManager *TcpCbChannel::writeEventManager() const {
    return d_wManager_p;
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
