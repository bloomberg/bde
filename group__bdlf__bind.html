<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlf_bind Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Defines</a>  </div>
  <div class="headertitle">
<h1>Component bdlf_bind<br/>
<small>
[<a class="el" href="group__bdlf.html">Package bdlf</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a signature-specific function object (functor).  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlf.html">bdlf</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind.html#ga62bffd8ba8e708e2402c1435295f252f">BDLF_BIND_PARAMINDEX</a>(N)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind.html#ga5c048f6042cde47741056e706c1492c3">BDLF_BIND_EVAL</a>(N)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Supported Functionality</a> </li>
<li>
<a href="#3.2">Elementary Construction and Usage of <code>bdlf::Bind</code> Objects</a> </li>
<li>
<a href="#3.3">Binding Data</a> <ul>
<li>
<a href="#3.3.1">Ignoring Parameters</a> </li>
<li>
<a href="#3.3.2">Duplicating Parameters</a> </li>
</ul>
</li>
<li>
<a href="#3.4">Bound Functors</a> <ul>
<li>
<a href="#3.4.1">Binding to Member Functions</a> </li>
<li>
<a href="#3.4.2">Binding to Functions with an Ellipsis</a> </li>
<li>
<a href="#3.4.3">Binding to Function Objects by Value or by Address</a> </li>
<li>
<a href="#3.4.4">Inferring the Signature of the Bound Functor</a> </li>
<li>
<a href="#3.4.5">Binding with Constants and Temporaries</a> </li>
</ul>
</li>
<li>
<a href="#3.5">Binding with Allocators</a> </li>
<li>
<a href="#3.6">Usage</a> <ul>
<li>
<a href="#3.6.1">Example 1: Implementing a Callback</a> </li>
<li>
<a href="#3.6.2">Binding to Free Functions</a> </li>
<li>
<a href="#3.6.3">Binding to Function Objects</a> </li>
<li>
<a href="#3.6.4">Binding to Function Objects by Reference</a> </li>
<li>
<a href="#3.6.5">Binding to Member Functions</a> </li>
<li>
<a href="#3.6.6">Nesting Bindings</a> </li>
<li>
<a href="#3.6.7">Binding to a Function Object with Explicit Return Type</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a signature-specific function object (functor). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a> </td><td>select the proper implementation for the binder  </td></tr>
<tr>
<td><a class="el" href="classbdlf_1_1BindWrapper.html">bdlf::BindWrapper</a> </td><td>reference counted function binder  </td></tr>
<tr>
<td><a class="el" href="structbdlf_1_1BindUtil.html">bdlf::BindUtil</a> </td><td>factory methods for creating the binder  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlf__memfn.html" title="Provide member function pointer wrapper classes and utility.">Component bdlf_memfn</a>, <a class="el" href="group__bdlf__placeholder.html" title="Provide a parameterized placeholder and specialized placeholders.">Component bdlf_placeholder</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a parameterized binder mechanism, <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code>, that is a functor object that binds an invocable object or function to a list of arguments. This component also defines factory methods in the <code><a class="el" href="structbdlf_1_1BindUtil.html">bdlf::BindUtil</a></code> namespace for creating <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> objects (e.g., <code>bind</code> and <code>bindR</code>) and <code><a class="el" href="classbdlf_1_1BindWrapper.html">bdlf::BindWrapper</a></code> objects (e.g., <code>bindS</code> and <code>bindSR</code>). The <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> functor (called henceforth a "binder") is an object that can hold any invocable object (the "bound functor") and a number of parameters (the "bound arguments", some of which can be place-holders of type <code><a class="el" href="structbdlf_1_1PlaceHolder.html">bdlf::PlaceHolder</a></code>). When the binder is later invoked (with optional additional arguments called the "invocation
 arguments" used to compute the value of bound arguments that use place-holders), it returns the result of calling the bound functor with the bound arguments and invocation arguments. The <code><a class="el" href="classbdlf_1_1BindWrapper.html">bdlf::BindWrapper</a></code> functor provides a binder with shared pointer semantics to a non-modifiable binder (both <code>operator*</code> and <code>operator-&gt;</code> accessors) and forwards its construction arguments to the underlying binder. The section "Supported functionality
 and limitations" details which kind of bound functors and bound arguments can be used in conjunction with this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The main use of <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> is to invoke bound functors with additional data that is not available prior to the point the functor is invoked (as is often the case with callback functions). The binding is accomplished by passing place-holders instead of literal values as the bound arguments. When the binder is invoked, these place-holders are replaced by their respective invocation arguments. The section "Elementary construction and
 usage of &lt;code&gt;bdlf::Bind&lt;/code&gt; objects" shows an elementary (but not realistic) usage of the <code><a class="el" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a></code> factory methods with free functions, that should be enough for most users to grasp the basic usage of this component. The section "Binding data" offers more details and should enable a user to make a more advanced usage of this component. The usage example presents many uses of <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> and <code><a class="el" href="structbdlf_1_1BindUtil.html">bdlf::BindUtil</a></code> in a somewhat realistic (but a bit more involved) situation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> functors are typically used with standard algorithms, or with <code>bsl::function</code>. This mechanism is similar to, but much more powerful than, <code>bsl::bind1st</code> or <code>bsl::bind2nd</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The difference between a binder created using one of <code>bindS</code> and <code>bindSR</code> and a binder created using <code>bind</code>, and <code>bindR</code> is that in the former case the binder is returned by reference rather than by value, with shared ownership semantics. Hence its main use is for creating binders that hold a non-trivial amount of storage (i.e., the bound arguments) and will be copied, possibly several times, such as jobs enqueued in a threadpool. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="supported_functionality"></a> <a class="anchor" id="description.supported_functionality"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Supported Functionality: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An invocable object is any object that can be invoked in syntactically the same manner as a function. Invocable objects include function pointers, and objects that provide an <code>operator()</code> method. This component supports bound objects that can be function pointers, member function pointers (the first bound argument must evaluate to an instance of the class of which the function is a member), or function objects passed by address or by value. In addition, there is a limitation on the number of parameters that such an object can take (currently no more than 14). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> functor can be constructed, usually by one of the <code><a class="el" href="structbdlf_1_1BindUtil.html">bdlf::BindUtil</a></code> factory methods, from a bound functor and from 0 up to 14 bound arguments that can be either literal values, place-holders of type <code><a class="el" href="structbdlf_1_1PlaceHolder.html">bdlf::PlaceHolder</a></code>, or further <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> functors. The type of a binder object is a complicated expression, which is why a binder is typically a short-lived object that is returned or passed as parameter to a function template. That is also why the <code><a class="el" href="structbdlf_1_1BindUtil.html">bdlf::BindUtil</a></code> factory methods are the preferred way to create a binder. When a binder is later invoked with some arguments, literal values are passed to the bound functor and place-holders are substituted by their respective invocation arguments. In addition, any argument that is a binder itself is invoked recursively with the same invocation arguments and the result of that invocation is passed to the parent binder. The section "Elementary construction and usage of
 &lt;code&gt;bdlf::Bind&lt;/code&gt; objects" below details the whole mechanism and offers some examples. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> functors support <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code> arguments. When binders are constructed by the <code><a class="el" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a></code> (and <code>bindR</code>) factory methods, the currently installed default allocator is used. When binders are constructed by the <code><a class="el" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a></code> (and <code>bindSR</code>) factory methods, the non-optional, user-supplied allocator is used both for the creation of the bound functor arguments and for the reference counting mechanism that manages those arguments. See the section "Binding with
 allocators" below for a more detailed discussion. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="elementary_construction_and_usage_of_bdlf~3A~3Abind_objects"></a> <a class="anchor" id="description.elementary_construction_and_usage_of_bdlf~3A~3Abind_objects"></a> <a class="anchor" id="elementary_construction_and_usage_of_bdlf"></a> <a class="anchor" id="description.elementary_construction_and_usage_of_bdlf"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Elementary Construction and Usage of bdlf::Bind Objects: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Bound functors are generally constructed by invoking the <code><a class="el" href="structbdlf_1_1BindUtil.html">bdlf::BindUtil</a></code> with an "invocation template". An invocation template is a series of one or more arguments that describe how to invoke the bound functor. Each argument can be either a place-holder or a literal value. Literal values are stored by value in the binder and directly forwarded to the bound functor when invoked. Place-holders are substituted with the respective argument provided at invocation of the binder. For example, given the following <code>invocable</code> (here a free function for simplicity): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> invocable(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j, <span class="keyword">const</span> <span class="keywordtype">char</span> *str)
  {
 Do something with <span class="charliteral">&#39;i&#39;</span>, <span class="charliteral">&#39;j&#39;</span> and <span class="stringliteral">&#39;str&#39;</span>.
      printf(<span class="stringliteral">&quot;Invoked with: %d %d %s\n&quot;</span>, i, j, str);
  }
</pre></div><br/>
<br/>
 and the following (global) string: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">char</span> *someString = <span class="stringliteral">&quot;p3&quot;</span>; <span class="comment">// for third parameter to &#39;invocable&#39;</span>
</pre></div><br/>
<br/>
 we can bind the parameters of <code>invocable</code> to the following arguments: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> bindTest(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0) {
      <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;invocable,         <span class="comment">// bound functor and</span>
                          10, 14, someString) <span class="comment">// bound arguments</span>
</pre></div><br/>
<br/>
 and the binder declared above can be passed invocation arguments directly, as follows (here we specify zero invocation arguments since all the bound arguments are fully specified): <br/>
<br/>
<div class="fragment"><pre class="fragment">                                          (); <span class="comment">// invocation</span>
</pre></div><br/>
<br/>
 Similarly, we can also create a reference-counted shared binder using the <code>bindS</code> method: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator,                    <span class="comment">// allocator,</span>
                            &amp;invocable,                   <span class="comment">// bound object and</span>
                            10, 14, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)<span class="stringliteral">&quot;p3&quot;</span>)(); <span class="comment">// bound arguments</span>
  }
</pre></div><br/>
<br/>
 In the function call above, the <code>invocable</code> will be bound with the arguments <code>10</code>, <code>14</code>, and <code>"p3"</code> respectively, then invoked with those bound arguments. In the next example, place-holders are used to forward user-provided arguments to the bound functor. We separate the invocation of the binder into a function template to avoid having to declare the type of the binder: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> BINDER&gt;
  <span class="keywordtype">void</span> callBinder(BINDER <span class="keyword">const</span>&amp; b)
  {
      b(10, 14);
  }
</pre></div><br/>
<br/>
 The creation of the binder is as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> bindTest1(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0) {
      callBinder(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;invocable,
                                     <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>, someString));

      callBinder(<a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator,
                                       &amp;invocable,
                                       <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>, someString));
  }
</pre></div><br/>
<br/>
 In this code snippet, the <code>callBinder</code> template function is invoked with a binder bound to the specified <code>invocable</code> and having the invocation template <code>_1</code>, <code>_2</code>, and <code>"p3"</code> respectively. The two special parameters <code>_1</code> and <code>_2</code> are place-holders for arguments one and two, respectively, which will be specified to the binder at invocation time. Each place-holder will be substituted with the corresponding positional argument when invoked. When called within the <code>callBinder</code> function, <code>invocable</code> will be invoked as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  invocable(10, 14, <span class="stringliteral">&quot;p3&quot;</span>);
</pre></div><br/>
<br/>
 Place-holders can appear anywhere in the invocation template, and in any order. The same place-holder can appear multiple times. Each instance will be substituted with the same value. For example, in the following snippet of code, the <code>callBinder</code> function, is invoked with a binder such that argument one (10) of the binder is passed as parameter two and argument two (14) is passed as (i.e., bound to) parameter one: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> bindTest2(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0) {
      callBinder(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;invocable, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, someString));

      callBinder(<a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator,
                                       &amp;invocable,
                                       <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, someString));
  }
</pre></div><br/>
<br/>
 When called within the <code>callBinder</code> function, <code>invocable</code> will be invoked as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  invocable(14, 10, <span class="stringliteral">&quot;p3&quot;</span>);
</pre></div><br/>
<br/>
 The following snippet of code illustrates a number of ways to call <code><a class="el" href="structbdlf_1_1BindUtil.html">bdlf::BindUtil</a></code> and their respective output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> test1(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j)
  {
      <span class="keywordflow">return</span> i + j;
  }

  <span class="keywordtype">int</span> abs(<span class="keywordtype">int</span> x)
  {
      <span class="keywordflow">return</span> (x &gt; 0) ? x : -x;
  }

  <span class="keywordtype">void</span> bindTest3(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      <span class="keyword">using namespace </span>bdlf::PlaceHolders;
      assert(24 == <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;test1, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>)(10, 14));
      assert(24 == <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;test1, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, 14)(10));
      assert(24 == <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;test1, 10, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>)(14));
      assert(24 == <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;test1, 10, 14)());
      assert(24 == <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;test1,
                                    <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;abs,<a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>), 14)(-10));

      assert(24 == <a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator, &amp;test1, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>)(10, 14));
      assert(24 == <a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator, &amp;test1, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, 14)(10));
      assert(24 == <a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator, &amp;test1, 10, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a> )(14));
      assert(24 == <a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator, &amp;test1, 10, 14)());
      assert(24 == <a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator, &amp;test1,
                       <a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator, &amp;abs, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>), 14)(-10));
  }
</pre></div><br/>
<br/>
 The usage example below provides a more comprehensive series of calling sequences. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="binding_data"></a> <a class="anchor" id="description.binding_data"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Binding Data: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The main use of <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> is to invoke bound functors with additional data that is not available prior to the point the functor is invoked (as is often the case with callback functions). For that purpose, place-holders are key. There are a couple of issues to understand in order to properly use this component. The bound arguments must be of a value-semantic type (unless they are place-holders or <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> objects). They are evaluated at binding time once and only once and their value copied into the binder (using the default allocator to supply memory unless an allocator is specified). A <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> object always invokes its bound functor with only the arguments listed as bound arguments, regardless of how many arguments are specified to the binder at invocation time. Invocation arguments that are not referenced through a place-holder are simply discarded. Invocation arguments that are duplicated (by using the same place-holder several times) are simply copied several times. The following examples should make things perfectly clear. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="ignoring_parameters"></a> <a class="anchor" id="binding_data.ignoring_parameters"></a> <a class="anchor" id="description.binding_data.ignoring_parameters"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Ignoring Parameters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is possible to pass more invocation arguments to a binder than were specified in the signature by the number of bound arguments. Invocation arguments not referenced by any placeholder, as well as extra invocation arguments, will be ignored. Note that they will nevertheless be evaluated even though their value will be unused. Consider, for example, the following snippet of code: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> marker = 0;
  <span class="keywordtype">int</span> singleArgumentFunction(<span class="keywordtype">int</span> x) {
      <span class="keywordflow">return</span> x;
  }

  <span class="keywordtype">int</span> identityFunctionWithSideEffects(<span class="keywordtype">int</span> x)
  {
      printf(<span class="stringliteral">&quot;Calling &#39;identityFunctionWithSideEffects&#39; with %d\n&quot;</span>, x);
      marker += x;
      <span class="keywordflow">return</span> x;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> BINDER&gt;
  <span class="keywordtype">void</span> callBinderWithSideEffects1(BINDER <span class="keyword">const</span>&amp; binder)
  {
      ASSERT(14 == binder(identityFunctionWithSideEffects(10), 14));
  }

  <span class="keywordtype">void</span> bindTest4(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0) {
      marker = 0;
      callBinderWithSideEffects1(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
                                               &amp;singleArgumentFunction, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
</pre></div><br/>
<br/>
 In the above snippets of code, <code>singleArgumentFunction</code> will be called with only the second argument (14) specified to the binder at invocation time in the <code>callBinderWithSideEffects1</code> function. Thus the return value of the invocation must be 14. The <code>identityFunctionWithSideEffects(10)</code> will be evaluated, even though its return value (10) will be discarded. We can check this as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">      assert(10 == marker);
</pre></div><br/>
<br/>
 We repeat the same call using <code>bindS</code> below: <br/>
<br/>
<div class="fragment"><pre class="fragment">      marker = 0;
      callBinderWithSideEffects1(<a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(
                                                     allocator,
                                                     &amp;singleArgumentFunction,
                                                     <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
      assert(10 == marker);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="duplicating_parameters"></a> <a class="anchor" id="binding_data.duplicating_parameters"></a> <a class="anchor" id="description.binding_data.duplicating_parameters"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>Duplicating Parameters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A place-holder can be specified multiple times, effectively passing the same value to different arguments of the function. The value will be evaluated only once. To illustrate this, consider another example that reuses the <code>singleArgumentFunction</code> of the previous example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> doubleArgumentFunction(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) {
      <span class="keywordflow">return</span> x+y;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> BINDER&gt;
  <span class="keywordtype">void</span> callBinderWithSideEffects2(BINDER <span class="keyword">const</span>&amp; binder)
  {
      <span class="keyword">const</span> <span class="keywordtype">int</span> RET1 = binder(10);
      ASSERT(20 == RET1);
      <span class="keyword">const</span> <span class="keywordtype">int</span> RET2 = binder(identityFunctionWithSideEffects(10));
      ASSERT(20 == RET2);
  }

  <span class="keywordtype">void</span> bindTest5(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0) {
      marker = 0;
      callBinderWithSideEffects2(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
                                           &amp;doubleArgumentFunction, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>));
</pre></div><br/>
<br/>
 In the above snippet of code, <code>doubleArgumentFunction</code> will be called with the first argument (<code>identityFunctionWithSideEffects(10)</code>) specified to the binder, computed only once at invocation time. We can check this as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">      assert(10 == marker);
</pre></div><br/>
<br/>
 We repeat the same call using <code>bindS</code> below: <br/>
<br/>
<div class="fragment"><pre class="fragment">      marker = 0;
      callBinderWithSideEffects2(<a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(
                                                     allocator,
                                                     &amp;doubleArgumentFunction,
                                                     <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>));
      assert(marker, 10 == marker);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bound_functors"></a> <a class="anchor" id="description.bound_functors"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Bound Functors: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are a few issues to be aware of concerning the kind of bound functors that can successfully be used with this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="binding_to_member_functions"></a> <a class="anchor" id="bound_functors.binding_to_member_functions"></a> <a class="anchor" id="description.bound_functors.binding_to_member_functions"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Binding to Member Functions: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Although member function pointers are not invoked in syntactically the same manner as free functions, they can still be used directly in conjunction with <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code>. When the binder detects that a member function pointer was specified, it automatically wraps it in a <code><a class="el" href="classbdlf_1_1MemFn.html">bdlf::MemFn</a></code> object. In this case a pointer to the object must be passed as the first argument to bind, followed by the remaining arguments. See the usage example "Binding to
 Member Functions" below. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that special care should be exercised when passing <code>this</code> to bind. If <code>this</code> is passed as the first argument to bind, then all other arguments must be passed by value or by const reference. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="binding_to_functions_with_an_ellipsis"></a> <a class="anchor" id="bound_functors.binding_to_functions_with_an_ellipsis"></a> <a class="anchor" id="description.bound_functors.binding_to_functions_with_an_ellipsis"></a> <a class="anchor" id="3.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Binding to Functions with an Ellipsis: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is possible to create a binder with a <em>free</em> function (pointer or reference) that takes an ellipsis (e.g., <code>int printf(const char*, ...</code>). This component does <em>not</em> support ellipsis in <em>member</em> function pointers, however. See the <code>bindTest7</code> example function at the end of the usage example below. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="binding_to_function_objects_by_value_or_by_address"></a> <a class="anchor" id="bound_functors.binding_to_function_objects_by_value_or_by_address"></a> <a class="anchor" id="description.bound_functors.binding_to_function_objects_by_value_or_by_address"></a> <a class="anchor" id="3.4.3"></a> </dd></dl>
<dl class="user"><dt><b>Binding to Function Objects by Value or by Address: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Although function objects are invoked in syntactically the same manner as free functions, they can be used by value or by address in conjunction with <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code>. When the binder detects that a pointer to a function object was specified, it automatically dereferences that pointer prior to invoking the function object. The difference between the two usages is that the binder object holds a copy of the whole object or of its address only. In particular, when passing by value an object that takes an allocator, the copy held by the binder uses the default allocator if constructed by <code><a class="el" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a></code> or <code><a class="el" href="structbdlf_1_1BindUtil.html#a9fcde06a8f9646f60f38a46d671cee4f">bdlf::BindUtil::bindR</a></code>, <em>not</em> the allocator of the original object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For keeping the same allocator, pass the object by address to the binder, or call <code>bindS</code> or <code>bindSR</code> instead. See the section "Binding with allocators" and the usage example sections "Binding to Function Objects" and "Binding to
 Function Objects by Reference" below. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>CAVEAT: When passing a function object by value, only the (non-modifiable) copy held by the binder will be invoked. Prior to this version, it was possible to modifiably invoke this copy (hence a non-const <code>operator()</code>) with the intent to modify the state of the function object. However, only the copy held by the binder was modified and the original function object passed to the binder was not, but this usage error went undetected. In this version, a binder cannot modifiably invoke functors held by value, and attempting to do so will trigger a compilation error. If it is desired that an invocation modifies the state of the function object, then this function object must be passed to the binder <em>by</em> <em>address</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="inferring_the_signature_of_the_bound_functor"></a> <a class="anchor" id="bound_functors.inferring_the_signature_of_the_bound_functor"></a> <a class="anchor" id="description.bound_functors.inferring_the_signature_of_the_bound_functor"></a> <a class="anchor" id="3.4.4"></a> </dd></dl>
<dl class="user"><dt><b>Inferring the Signature of the Bound Functor: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> object will strive to properly and automatically resolve the signature of its bound functor between different overloads of that invocable. The signature of the bound functor is inferred from that of the bound functor and the type of the arguments either at binding or invocation time. The signature of invocables that are not function objects (i.e., free functions with C++ linkage and member functions) must be determined at binding time (in particular, overloads must be disambiguated when obtaining the address of the function). In those cases, the bound arguments will be of the corresponding type and any values passed as bound arguments (except placeholders) will be cast to the corresponding type at binding time and stored by value unless the argument type is a reference type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Invocation arguments will be cast in place of their corresponding place-holder(s) to the corresponding type only at invocation time. If the signature of the bound functor is known, the invocation argument will be forwarded using the most efficient type (in particular, unnecessary copies will be avoided for non fundamental types). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Some invocable objects, however, may not allow the binder to detect their signature until invocation. This is the case for function objects, for free functions with C linkage (e.g., <code>printf</code>), if a bound argument is a nested binder, or if a placeholder is used in two positions in the bound arguments. In that case, the bound arguments are stored in their own types, and cast to the corresponding argument type of the signature only when the signature is determined at invocation time. Place-holders, likewise, are not typed and will acquire the type of their corresponding invocation argument when invoked, which will be cast to the corresponding argument type of the signature. In particular, the same binder constructed with a functor and place-holders in place of the bound arguments can invoke several overloads of the <code>operator()</code> of the functor, depending on the type of the invocation arguments. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Although function objects are invoked in syntactically the same manner as free functions, their return type cannot always be inferred. The same limitation applies to free functions with <code>extern "C"</code> linkage. In that case, the return type has to be given explicitly to the binder. This can be done by using the <code><a class="el" href="structbdlf_1_1BindUtil.html#a9fcde06a8f9646f60f38a46d671cee4f">bdlf::BindUtil::bindR</a></code> function. Note that all <code>bsl::function</code> objects have a standard public type <code>result_type</code> to assist the deduction of return type and can be used with <code><a class="el" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a></code>. See the usage example "Binding to a Function Object with Explicit Return
 Type" below. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="binding_with_constants_and_temporaries"></a> <a class="anchor" id="bound_functors.binding_with_constants_and_temporaries"></a> <a class="anchor" id="description.bound_functors.binding_with_constants_and_temporaries"></a> <a class="anchor" id="3.4.5"></a> </dd></dl>
<dl class="user"><dt><b>Binding with Constants and Temporaries: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Due to a technical restriction of the C++ language known as the "forwarding
 problem", it is not possible to match the signature of a function object exactly when passing a mix of non-'const' lvalues and rvalues as invocation arguments. Nevertheless, this component supports passing literal values and temporaries as invocation arguments to a <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> object. There is however one limitation: if <em>any</em> of the arguments in the signature of the bound functor should be of a modifiable reference type, then <em>all</em> the invocation arguments need to be modifiable references. That is, it is not possible to pass a literal (<code>const</code>) value to some argument of a bound functor when another argument expects a modifiable reference. Note that a direct call to the bound functor (without the binder) would accept such an argument. This is not a severe limitation, and the workaround is to pass instead a local modifiable variable initialized to the literal value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="binding_with_allocators"></a> <a class="anchor" id="description.binding_with_allocators"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Binding with Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The bound functor and bound arguments are created as members of the <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> object, so no memory is allocated for storing them. However, if the bound functor or bound argument's copy constructor requires memory allocation, that memory is supplied by the currently installed default allocator unless <code><a class="el" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a></code> (or <code>bindSR</code>) method is used. In the latter cases, the non-optional, user-supplied allocator is passed to the copy constructors of the bound functor and arguments. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When invoking a bound functor object, the (unbound) arguments are passed "as
 is" to the bound functor. Those arguments are not copied if the bound functor takes them by modifiable or non-modifiable reference. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In order to make clear where the allocation occurs, we will wrap "p3" into a type that takes an allocator, e.g., a class <code>MyString</code> (kept minimal here for the purpose of exposition): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyString {
 PRIVATE INSTANCE DATA
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;
      <span class="keywordtype">char</span>             *d_string_p;

    <span class="keyword">public</span>:
 TRAITS
      <a class="code" href="bslmf__nestedtraitdeclaration_8h.html#a6d33ff2982d65052e0c33136bf4d74e7">BSLMF_NESTED_TRAIT_DECLARATION</a>(MyString, <a class="code" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>);

CREATORS
      MyString(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
      : d_allocator_p(bslma::Default::allocator(allocator))
      , d_string_p((char*)d_allocator_p-&gt;allocate(1 + strlen(str)))
      {
          strcpy(d_string_p, str);
      }

      MyString(MyString <span class="keyword">const</span>&amp; rhs, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
      : d_allocator_p(bslma::Default::allocator(allocator))
      , d_string_p((char*)d_allocator_p-&gt;allocate(1 + strlen(rhs)))
      {
          strcpy(d_string_p, rhs);
      }

      ~MyString() {
          d_allocator_p-&gt;deallocate(d_string_p);
      }

 ACCESSORS
      operator const char*()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_string_p; }
  };
</pre></div><br/>
<br/>
 We will also use a <code><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a></code> to keep track of the memory allocated: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> bindTest6() {
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> allocator;
      MyString myString((<span class="keyword">const</span> <span class="keywordtype">char</span>*)<span class="stringliteral">&quot;p3&quot;</span>, &amp;allocator);
      <span class="keyword">const</span> Int64 NUM_ALLOCS = allocator.<a class="code" href="classbslma_1_1TestAllocator.html#a464a6bc3f5125e8b0d303efbd339afec">numAllocations</a>();
</pre></div><br/>
<br/>
 To expose that the default allocator is not used, we will use a default allocator guard, which will re-route any default allocation to the local <code>defaultAllocator</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> defaultAllocator(<span class="stringliteral">&quot;Default&quot;</span>, globalVerbose);
      <a class="code" href="classbslma_1_1DefaultAllocatorGuard.html">bslma::DefaultAllocatorGuard</a> defaultAllocatorGuard(&amp;defaultAllocator);
      <span class="keyword">const</span> Int64 NUM_DEFAULT_ALLOCS = defaultAllocator.numAllocations();
</pre></div><br/>
<br/>
 We now create a shared binder object with <code>allocator</code> using <code>bindS</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      callBinder(
            <a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(&amp;allocator, &amp;invocable, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>, myString));
</pre></div><br/>
<br/>
 When the bound object is an instance of a class taking an allocator, then <code>allocator</code> is be passed to its copy constructor as occurs in this example. Here <code>allocator</code> is used to make the copy of <code>myString</code> held by the binder. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We now check that memory was allocated from the test allocator, and none from the default allocator: <br/>
<br/>
<div class="fragment"><pre class="fragment">      assert(NUM_ALLOCS         != allocator.<a class="code" href="classbslma_1_1TestAllocator.html#a464a6bc3f5125e8b0d303efbd339afec">numAllocations</a>());
      assert(NUM_DEFAULT_ALLOCS == defaultAllocator.numAllocations());
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_implementing_a_callback"></a> <a class="anchor" id="usage.example_1~3A_implementing_a_callback"></a> <a class="anchor" id="description.usage.example_1~3A_implementing_a_callback"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.6.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Implementing a Callback: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>What follows is a series of code snippets illustrating detailed aspects of typical usage of <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> and <code><a class="el" href="structbdlf_1_1BindUtil.html">bdlf::BindUtil</a></code>. For these examples, we will use a typical pair of event and event dispatcher classes, where the event is defined as: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>MyEvent {
 Event data, <span class="keywordflow">for</span> illustration purpose here:
      <span class="keywordtype">int</span> d_value;
  };
</pre></div><br/>
<br/>
 and the event dispatcher is defined as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyEventDispatcher {
 This <span class="keyword">class </span>owns a callback function object that takes an &#39;int&#39; and
 an instance of &#39;MyEvent&#39;.  When the &#39;dispatch&#39; method is called, it
 invokes the callback with a series of events that it obtains using
 its own stream of events.

 PRIVATE INSTANCE DATA
      bsl::function&lt;void(int, MyEvent)&gt;  d_callback;

 PRIVATE MANIPULATORS
      int getNextEvent(MyEvent *eventBuffer) {
 Create a copy of the next <span class="keyword">event</span> in the specified <span class="stringliteral">&#39;eventBuffer&#39;</span>
 Return 0 on success, and non-zero <span class="keywordflow">if</span> no <span class="keyword">event</span> is available.

 Implementation elided
 ...
      }
</pre></div><br/>
<br/>
 A dispatcher is created with a callback function object as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keyword">public</span>:
 CREATORS
      MyEventDispatcher(bsl::function&lt;<span class="keywordtype">void</span>(<span class="keywordtype">int</span>, MyEvent)&gt; <span class="keyword">const</span>&amp; cb)
      : d_callback(cb)
      {
      }
</pre></div><br/>
<br/>
 and its main function is to invoke the callback on the series of events as obtained by <code>getNextEvent</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment"> MANIPULATORS
      <span class="keywordtype">void</span> dispatch(<span class="keywordtype">int</span> <span class="keywordtype">id</span>)
      {
          MyEvent e;
          <span class="keywordflow">while</span> (!getNextEvent(&amp;e)) {
              d_callback(<span class="keywordtype">id</span>, e);
          }
      }
  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="binding_to_free_functions"></a> <a class="anchor" id="usage.binding_to_free_functions"></a> <a class="anchor" id="description.usage.binding_to_free_functions"></a> <a class="anchor" id="3.6.2"></a> </dd></dl>
<dl class="user"><dt><b>Binding to Free Functions: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>We illustrate how to use the dispatcher with free callback functions that have various signatures by passing a binder as the callback function of the dispatcher, and how to use the binder to match the signature of the callback function. Note that at the point of invocation in <code>dispatch</code> the binder will be invoked with two invocation arguments, thus we may use only place-holders <code>_1</code> and <code>_2</code>. In the following snippet of code, the binder passes its invocation arguments straight through to the callback: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myCallback(<span class="keywordtype">int</span> <span class="keywordtype">id</span>, MyEvent <span class="keyword">const</span>&amp; event)
  {
 Do something ...
  }

  <span class="keywordtype">void</span> myMainLoop(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      MyEventDispatcher schedA(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;myCallback, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
      schedA.dispatch(10);

      MyEventScheduler schedB(<a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator,
                                                    &amp;myCallback, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
      schedB.run(10);
  }
</pre></div><br/>
<br/>
 Next we show how to bind some of the callback arguments at binding time, while letting the invocation arguments straight through to the callback as the first two arguments: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myCallbackWithUserArgs(<span class="keywordtype">int</span>            <span class="keywordtype">id</span>,
                              MyEvent <span class="keyword">const</span>&amp; event,
                              <span class="keywordtype">int</span>            userArg1,
                              <span class="keywordtype">double</span>         userArg2)
  {
 Do something ...
  }

  <span class="keywordtype">void</span> myMainLoop2(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      MyEventDispatcher schedA(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;myCallbackWithUserArgs,
                                                    <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>, 360, 3.14));
      schedA.dispatch(10);

      MyEventScheduler schedB(<a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator,
                                                    &amp;myCallbackWithUserArgs,
                                                    <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>, 360, 3.14));
      schedB.run(10);
  }
</pre></div><br/>
<br/>
 In the next snippet of code, we show how to reorder the invocation arguments before they are passed to the callback: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myCallbackWithUserArgsReordered(<span class="keywordtype">int</span>            <span class="keywordtype">id</span>,
                                       <span class="keywordtype">int</span>            userArg1,
                                       <span class="keywordtype">double</span>         userArg2,
                                       MyEvent <span class="keyword">const</span>&amp; event)
  {
 Do something ...
  }

  <span class="keywordtype">void</span> myMainLoop3(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      MyEventDispatcher schedA(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
                      &amp;myCallbackWithUserArgsReordered, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, 360, 3.14, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
      schedA.dispatch(10);

      MyEventScheduler schedB(<a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator,
                       &amp;myCallbackWithUserArgsReordered, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, 360, 3.14, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
      schedB.run(10);
  }
</pre></div><br/>
<br/>
 And finally, we illustrate that the signature of the callback can be <em>smaller</em> than expected by the dispatcher by letting the binder ignore its first argument: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myCallbackThatDiscardsResult(MyEvent <span class="keyword">const</span>&amp; event)
  {
 Do something ...
  }

  <span class="keywordtype">void</span> myMainLoop4(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      MyEventDispatcher schedA(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
                                        &amp;myCallbackThatDiscardsResult, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
      schedA.dispatch(10);

      MyEventScheduler schedB(<a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator,
                                         &amp;myCallbackThatDiscardsResult, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
      schedB.run(10);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="binding_to_function_objects"></a> <a class="anchor" id="usage.binding_to_function_objects"></a> <a class="anchor" id="description.usage.binding_to_function_objects"></a> <a class="anchor" id="3.6.3"></a> </dd></dl>
<dl class="user"><dt><b>Binding to Function Objects: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the next example, we wrap the callback function into a function object which is bound by value. For brevity, we only present the basic example of passing the arguments straight through to the actual callback <code>operator()</code>, but all the variations of the previous example could be given as well. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>MyCallbackObject {
      <span class="keyword">typedef</span> <span class="keywordtype">void</span> ResultType;
      <span class="keywordtype">void</span> operator() (<span class="keywordtype">int</span> <span class="keywordtype">id</span>, MyEvent <span class="keyword">const</span>&amp; event)
      {
          myCallback(<span class="keywordtype">id</span>, event);
      }
  };

  <span class="keywordtype">void</span> myMainLoop5(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      MyCallbackObject objA;
      MyEventDispatcher schedA(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(objA, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
      schedA.dispatch(10);

      MyCallbackObject objB;
      MyEventScheduler schedB(<a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator,
                                                    objB, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
      schedB.run(10);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="binding_to_function_objects_by_reference"></a> <a class="anchor" id="usage.binding_to_function_objects_by_reference"></a> <a class="anchor" id="description.usage.binding_to_function_objects_by_reference"></a> <a class="anchor" id="3.6.4"></a> </dd></dl>
<dl class="user"><dt><b>Binding to Function Objects by Reference: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example reuses the <code>MyCallbackObject</code> of the previous example, but illustrates that it can be passed by reference as well as by value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myMainLoop6(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      MyCallbackObject objA;
      MyEventScheduler schedA(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;objA, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
      schedA.run(10);

      MyCallbackObject objB;
      MyEventScheduler schedB(<a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator,
                                                    &amp;objB, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
      schedB.run(10);
  }
</pre></div><br/>
<br/>
 When passed by reference, only the address of the function object is copied. Hence the function object must remain valid throughout the lifetime of the binder. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage.binding_to_member_functions"></a> <a class="anchor" id="description.usage.binding_to_member_functions"></a> <a class="anchor" id="3.6.5"></a> </dd></dl>
<dl class="user"><dt><b>Binding to Member Functions: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the next example, we show that the callback function can be a member function, in which case there are three, not two, bound arguments. The first bound argument must be a pointer to an instance of the class owning the member function. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>MyStatefulObject {

 DATA
 ...

    <span class="keyword">public</span>:
      <span class="keywordtype">void</span> callback(<span class="keywordtype">int</span>, MyEvent <span class="keyword">const</span>&amp; event)
      {
 Do something that may modify the state info...
      }
  };

  <span class="keywordtype">void</span> myMainLoop7(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      MyStatefulObject objA;
      MyEventScheduler schedA(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
                                &amp;MyStatefulObject::callback, &amp;objA, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
      schedA.run(10);

      MyStatefulObject objB;
      MyEventScheduler schedB(<a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator,
                                &amp;MyStatefulObject::callback, &amp;objB, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
      schedB.run(10);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="nesting_bindings"></a> <a class="anchor" id="usage.nesting_bindings"></a> <a class="anchor" id="description.usage.nesting_bindings"></a> <a class="anchor" id="3.6.6"></a> </dd></dl>
<dl class="user"><dt><b>Nesting Bindings: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>We now show that it is possible to provide a binder as an argument to <code><a class="el" href="structbdlf_1_1BindUtil.html">bdlf::BindUtil</a></code>. Upon invocation, the invocation arguments are forwarded to the nested binder. <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyEvent annotateEvent(<span class="keywordtype">int</span>, MyEvent <span class="keyword">const</span>&amp; event) {
 Do something to <span class="stringliteral">&#39;event&#39;</span> ...
      <span class="keywordflow">return</span> event;
  }

  <span class="keywordtype">void</span> myMainLoop8(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      MyCallbackObject objA;
      MyEventScheduler schedA(
              <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;objA, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>,
                              <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;annotateEvent, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>)));
      schedA.run(10);

      MyCallbackObject objB;
      MyEventScheduler schedB(
              <a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator, &amp;objB, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>,
                  <a class="code" href="structbdlf_1_1BindUtil.html#acb10b9c931d6715c67d588722ded3423">bdlf::BindUtil::bindS</a>(allocator, &amp;annotateEvent, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>)));
      schedB.run(10);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="binding_to_a_function_object_with_explicit_return_type"></a> <a class="anchor" id="usage.binding_to_a_function_object_with_explicit_return_type"></a> <a class="anchor" id="description.usage.binding_to_a_function_object_with_explicit_return_type"></a> <a class="anchor" id="3.6.7"></a> </dd></dl>
<dl class="user"><dt><b>Binding to a Function Object with Explicit Return Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>When the return type cannot be inferred from the bound functor (using <code>typename FUNC::ResultType</code>), the binder needs an explicit specification. This is done by using the <code><a class="el" href="structbdlf_1_1BindUtil.html#a9fcde06a8f9646f60f38a46d671cee4f">bdlf::BindUtil::bindR</a></code> function template as exemplified below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <span class="keywordtype">void</span> GlobalResultType;
  <span class="keyword">struct </span>MyCallbackObjectWithoutResultType {
      GlobalResultType operator() (<span class="keywordtype">int</span> <span class="keywordtype">id</span>, MyEvent <span class="keyword">const</span>&amp; event)
      {
          myCallback(<span class="keywordtype">id</span>, event);
      }
  };

  <span class="keywordtype">void</span> myMainLoop9(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      MyCallbackObjectWithoutResultType objA;
      MyEventScheduler schedA(<a class="code" href="structbdlf_1_1BindUtil.html">bdlf::BindUtil</a>::
                                      bindR&lt;GlobalResultType&gt;(objA, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
      schedA.run(10);

      MyCallbackObjectWithoutResultType objB;
      MyEventScheduler schedB(<a class="code" href="structbdlf_1_1BindUtil.html">bdlf::BindUtil</a>::
                          bindSR&lt;GlobalResultType&gt;(allocator, objB, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
      schedB.run(10);
  }
</pre></div><br/>
<br/>
 Another situation where the return type (in fact, the whole signature) cannot be inferred from the bound functor is the use of the free function with C linkage and variable number of arguments <code>printf(const char*, ...)</code>. In the following code snippet, we show how the argument to the <code>callBinder</code> function (redefined below for the reader's convenience) of section "Elementary construction and usage of &lt;code&gt;bdlf::Bind&lt;/code&gt; objects" above can be bound to <code>printf</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> BINDER&gt;
  <span class="keywordtype">void</span> callBinder(BINDER <span class="keyword">const</span>&amp; b)
  {
      b(10, 14);
  }

  <span class="keywordtype">void</span> bindTest7(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = 0)
  {
      <span class="keyword">const</span> <span class="keywordtype">char</span> *formatString = <span class="stringliteral">&quot;Here it is: %d %d\n&quot;</span>;
      callBinder(bdlf::BindUtil::bindR&lt;int&gt;(&amp;printf, formatString, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">_2</a>));
  }
</pre></div><br/>
<br/>
 When called, <code>bindTest7</code> will create a binder, pass it to <code>callBinder</code> which will invoke it with arguments <code>10</code> and <code>14</code>, and the output will be: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Here it is: 10 14
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga62bffd8ba8e708e2402c1435295f252f"></a><!-- doxytag: member="bdlf_bind.h::BDLF_BIND_PARAMINDEX" ref="ga62bffd8ba8e708e2402c1435295f252f" args="(N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BDLF_BIND_PARAMINDEX</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">N</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">( \
(k_PARAM1  == N ? 1  : 0) + \
(k_PARAM2  == N ? 2  : 0) + \
(k_PARAM3  == N ? 3  : 0) + \
(k_PARAM4  == N ? 4  : 0) + \
(k_PARAM5  == N ? 5  : 0) + \
(k_PARAM6  == N ? 6  : 0) + \
(k_PARAM7  == N ? 7  : 0) + \
(k_PARAM8  == N ? 8  : 0) + \
(k_PARAM9  == N ? 9  : 0) + \
(k_PARAM10 == N ? 10 : 0) + \
(k_PARAM11 == N ? 11 : 0) + \
(k_PARAM12 == N ? 12 : 0) + \
(k_PARAM13 == N ? 13 : 0) + \
(k_PARAM14 == N ? 14 : 0))
</pre></div>
</div>
</div>
<a class="anchor" id="ga5c048f6042cde47741056e706c1492c3"></a><!-- doxytag: member="bdlf_bind.h::BDLF_BIND_EVAL" ref="ga5c048f6042cde47741056e706c1492c3" args="(N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BDLF_BIND_EVAL</td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname">N</td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="structbdlf_1_1Bind__Evaluator.html">bdlf::Bind_Evaluator&lt;typename bslmf::TypeListTypeOf&lt;N,LIST&gt;::Type</a>, ARGS&gt;\
           ::eval(args, (list-&gt;d_a##N).value())
</pre></div>
<p>Referenced by <a class="el" href="structbdlf_1_1Bind__Invoker_3_01void_00_0114_01_4.html#a21a9172c140f0b28ce8a7d098d1b782a">bdlf::Bind_Invoker&lt; void, 14 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01RET_00_0114_01_4.html#a33429405d2a3a8eb71916867643a930c">bdlf::Bind_Invoker&lt; RET, 14 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01void_00_0113_01_4.html#a50e8c92c19ea70e4ac28c8becfd01bc5">bdlf::Bind_Invoker&lt; void, 13 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01RET_00_0113_01_4.html#a4e8e292867f44435711b90d3faaee24b">bdlf::Bind_Invoker&lt; RET, 13 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01void_00_0112_01_4.html#a75c666cd463c6572143ffdc77b53bf98">bdlf::Bind_Invoker&lt; void, 12 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01RET_00_0112_01_4.html#a49b8f135377054497560721bdd57d643">bdlf::Bind_Invoker&lt; RET, 12 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01void_00_0111_01_4.html#aa2b5b260eeb1aa02c43bca76fae40ea5">bdlf::Bind_Invoker&lt; void, 11 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01RET_00_0111_01_4.html#ad905e1791aaaea56848b400f392d2999">bdlf::Bind_Invoker&lt; RET, 11 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01void_00_0110_01_4.html#a9ebc9845988670aacdf673dad76f078c">bdlf::Bind_Invoker&lt; void, 10 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01RET_00_0110_01_4.html#a352d3682b231357e18882fceba880b16">bdlf::Bind_Invoker&lt; RET, 10 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01void_00_019_01_4.html#a66775773cd01c20187d438c86447b445">bdlf::Bind_Invoker&lt; void, 9 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01RET_00_019_01_4.html#a1638e7ebb67cf005d74d118636d2eeb0">bdlf::Bind_Invoker&lt; RET, 9 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01void_00_018_01_4.html#af7e7709ddc4cccef865edf29a0ffd63b">bdlf::Bind_Invoker&lt; void, 8 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01RET_00_018_01_4.html#ad6a68f6d4fb5c463a985bd4240318af5">bdlf::Bind_Invoker&lt; RET, 8 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01void_00_017_01_4.html#a06d67a48f36a8626ef10db2985d625b5">bdlf::Bind_Invoker&lt; void, 7 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01RET_00_017_01_4.html#a773f55513c63fe0de87cd6e8343d200a">bdlf::Bind_Invoker&lt; RET, 7 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01void_00_016_01_4.html#a1885175ab6405b9a0b569398da52413f">bdlf::Bind_Invoker&lt; void, 6 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01RET_00_016_01_4.html#ae0175d5a605b2a337f1848aa4dfaf7f1">bdlf::Bind_Invoker&lt; RET, 6 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01void_00_015_01_4.html#a2950729c74dfdca0da1256a40f5653d6">bdlf::Bind_Invoker&lt; void, 5 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01RET_00_015_01_4.html#af67f3e5fdad1fed556784d58206ba4d5">bdlf::Bind_Invoker&lt; RET, 5 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01void_00_014_01_4.html#a69709eedaf7e1da1f4887e5cdf89c867">bdlf::Bind_Invoker&lt; void, 4 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01RET_00_014_01_4.html#aa54763e1fb1309f4d683c12441c46d55">bdlf::Bind_Invoker&lt; RET, 4 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01void_00_013_01_4.html#a7bfca0a762c0e5d0d7380ec72f4632c7">bdlf::Bind_Invoker&lt; void, 3 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01RET_00_013_01_4.html#ac876fe1db633091fdfbcb3c1742b554d">bdlf::Bind_Invoker&lt; RET, 3 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01void_00_012_01_4.html#a6920e764b444a7195d8e359450868d5c">bdlf::Bind_Invoker&lt; void, 2 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01RET_00_012_01_4.html#ac71f9a6fc3cf1ec00c5141a792f612f1">bdlf::Bind_Invoker&lt; RET, 2 &gt;::invoke()</a>, <a class="el" href="structbdlf_1_1Bind__Invoker_3_01void_00_011_01_4.html#af87f631e46d0548bf8ef5b3e3caedf9c">bdlf::Bind_Invoker&lt; void, 1 &gt;::invoke()</a>, and <a class="el" href="structbdlf_1_1Bind__Invoker_3_01RET_00_011_01_4.html#a8a8a64a40fc8930e46d505c795b676dc">bdlf::Bind_Invoker&lt; RET, 1 &gt;::invoke()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:43 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
