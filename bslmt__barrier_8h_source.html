<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslmt_barrier.h                                                    -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BSLMT_BARRIER
#define INCLUDED_BSLMT_BARRIER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a thread barrier component.
//
//@CLASSES:
//   bslmt::Barrier: thread barrier class
//
//@SEE_ALSO: bslmt_mutex, bslmt_condition
//
//@DESCRIPTION: This component defines a thread barrier named &#39;bslmt::Barrier&#39;.
// Barriers provide a simple mechanism for synchronizing a series of threads at
// a given point in a program.  A barrier is constructed with a number
// &#39;numThreads&#39; which is the number of threads required to reach the
// synchronization point for the barrier to be unblocked.  As each thread
// reaches the synchronization point, it calls the &#39;wait&#39; method and blocks.
// An invariant is that the number of threads blocking on a barrier is always
// less than &#39;numThreads&#39;.  Once the required &#39;numThreads&#39; threads have called
// &#39;wait&#39;, the invariant is restored by unblocking all the threads and
// resetting the barrier to its initial state.  In particular, the barrier can
// be reused several times in succession.
//
// Note that the number of threads sharing the use of the barrier should be
// exactly &#39;numThreads&#39;, as only exactly &#39;numThreads&#39; threads calling &#39;wait&#39;
// will be unblocked.  In particular, extra threads calling &#39;wait&#39; will block,
// perhaps unwittingly participating in the next round of reuse of the barrier
// together with the unblocked &#39;numThreads&#39; threads (leading to potential race
// conditions).
//
// Note also that the behavior is undefined if a barrier is destroyed while one
// or more threads are waiting on it.
//
///Supported Clock-Types
///---------------------
// The component &#39;bsls::SystemClockType&#39; supplies the enumeration indicating
// the system clock on which timeouts supplied to other methods should be
// based.  If the clock type indicated at construction is
// &#39;bsls::SystemClockType::e_REALTIME&#39;, the timeout should be expressed as an
// absolute offset since 00:00:00 UTC, January 1, 1970 (which matches the epoch
// used in &#39;bsls::SystemTime::now(bsls::SystemClockType::e_REALTIME)&#39;.  If the
// clock type indicated at construction is
// &#39;bsls::SystemClockType::e_MONOTONIC&#39;, the timeout should be expressed as an
// absolute offset since the epoch of this clock (which matches the epoch used
// in &#39;bsls::SystemTime::now(bsls::SystemClockType::e_MONOTONIC)&#39;.
//
///Usage
///-----
// The following example demonstrates the use of a &#39;bslmt::Barrier&#39; to create
// &quot;checkpoints&quot; in a threaded &quot;basket trade&quot; processing logic.  In this
// example, a &quot;basket&quot; is a series of trades submitted as one logical trade.
// If any given trade fails to process for any reason, then all the trades must
// be cancelled.
//
// The example is driven through function &#39;processBasketTrade&#39;, which takes as
// its argument a reference to a &#39;BasketTrade&#39; structure.  The &#39;BasketTrade&#39;
// structure contains a collection of &#39;Trade&#39; objects; the &#39;processBasketTrade&#39;
// function creates a separate thread to manage each &#39;Trade&#39; object.
//
// The &#39;Trade&#39; threads proceed independently, except that they synchronize with
// one another at various stages of the trade processing: each thread waits for
// all trades to complete a given step before any individual trade thread
// proceeds to the next step.
//
// The &#39;bslmt::Barrier&#39; is used repeatedly at each processing stage to wait for
// all trades to complete the given stage before continuing to the next stage.
//
// To begin, we define the fundamental structures &#39;Trade&#39; and &#39;BasketTrade&#39;.
//..
//  enum {
//      k_MAX_BASKET_TRADES = 10
//  };
//
//  struct Trade {
//      // Trade stuff...
//  };
//
//  struct BasketTrade {
//      bsl::vector&lt;Trade&gt; d_trades;  // array of trade that comprise the
//                                    // basket
//  };
//..
// Functions &#39;validateTrade&#39;, &#39;insertToDatabase&#39;, and &#39;submitToExchange&#39; define
// functionality for the three stages of trade processing.  Again, the
// &#39;bslmt::Barrier&#39; will be used so that no individual trade moves forward to
// the next stage before all trades have completed the given stage.  So, for
// instance, no individual trade can call the &#39;insertToDatabase&#39; function until
// all trades have successfully completed the &#39;validateTrade&#39; function.
//
// Functions &#39;deleteFromDatabase&#39; and &#39;cancelAtExchange&#39; are used for rolling
// back all trades in the event that any one trade fails to move forward.
//
// The implementation of these functions is left incomplete for our example.
//..
//  int validateTrade(Trade &amp;trade)
//  {
//      (void)trade;
//      int result = 0;
//      // Do some checking here...
//
//      return result;
//  }
//
//  int insertToDatabase(Trade &amp;trade)
//  {
//      (void)trade;
//      int result = 0;
//      // Insert the record here...
//
//      return result;
//  }
//
//  int submitToExchange(Trade &amp;trade)
//  {
//      (void)trade;
//      int result = 0;
//      // Do submission here...
//
//      return result;
//  }
//
//  int deleteFromDatabase(Trade &amp;trade)
//  {
//      (void)trade;
//      int result = 0;
//      // Delete record here...
//
//      return result;
//  }
//
//  int cancelAtExchange(Trade &amp;trade)
//  {
//      (void)trade;
//      int result = 0;
//      // Cancel trade here...
//
//      return result;
//  }
//..
// The &#39;processTrade&#39; function handles a single trade within a Trade Basket.
// Because this function is called within a &#39;bslmt::Thread&#39; callback (see the
// &#39;tradeProcessingThread&#39; function, below), its arguments are passed in a
// single structure.  The &#39;processTrade&#39; function validates a trade, stores the
// trade into a database, and registers that trade with an exchange.  At each
// step, the &#39;processTrade&#39; function synchronizes with other trades in the
// Trade Basket.
//..
//  struct TradeThreadArgument {
//      bsl::vector&lt;Trade&gt; *d_trades_p;
//      bslmt::Barrier     *d_barrier_p;
//      volatile bool      *d_errorFlag_p;
//      int                 d_tradeNum;
//  };
//
//  TradeThreadArgument *processTrade(TradeThreadArgument *arguments)
//  {
//      int retval;
//      Trade &amp;trade = (*arguments-&gt;d_trades_p)[arguments-&gt;d_tradeNum];
//
//      retval = validateTrade(trade);
//..
// If this trade failed validation, then indicate that an error has occurred.
// Note that, even when an error occurs, we must still block on the barrier
// object; otherwise, other threads which did not fail would remain blocked
// indefinitely.
//..
//      if (retval) *arguments-&gt;d_errorFlag_p = true;
//      arguments-&gt;d_barrier_p-&gt;wait();
//..
// Once all threads have completed the validation phase, check to see if any
// errors occurred; if so, exit.  Otherwise continue to the next step.
//..
//      if (*arguments-&gt;d_errorFlag_p) return arguments;              // RETURN
//
//      retval = insertToDatabase(trade);
//      if (retval) *arguments-&gt;d_errorFlag_p = true;
//      arguments-&gt;d_barrier_p-&gt;wait();
//..
// As before, if an error occurs on this thread, we must still block on the
// barrier object.  This time, if an error has occurred, we need to check to
// see whether this trade had an error.  If not, then the trade has been
// inserted into the database, so we need to remove it before we exit.
//..
//      if (*arguments-&gt;d_errorFlag_p) {
//          if (!retval) deleteFromDatabase(trade);
//          return arguments;                                         // RETURN
//      }
//..
// The final synchronization point is at the exchange.  As before, if there is
// an error in the basket, we may need to cancel the individual trade.
//..
//      retval = submitToExchange(trade);
//      if (retval) *arguments-&gt;d_errorFlag_p = true;
//      arguments-&gt;d_barrier_p-&gt;wait();
//      if (*arguments-&gt;d_errorFlag_p) {
//          if (!retval) cancelAtExchange(trade);
//          deleteFromDatabase(trade);
//          return arguments;                                         // RETURN
//      }
//..
// All synchronized steps have completed for all trades in this basket.  The
// basket trade is placed.
//..
//      return arguments;
//  }
//..
// Function &#39;tradeProcessingThread&#39; is a callback for &#39;bslmt::ThreadUtil&#39;,
// which requires &#39;void&#39; pointers for argument and return type and &#39;extern &quot;C&quot;&#39;
// linkage.  &#39;bslmt::ThreadUtil::create()&#39; expects a pointer to this function,
// and provides that function pointer to the newly created thread.  The new
// thread then executes this function.
//
// The &#39;tradeProcessingThread&#39; function receives the &#39;void&#39; pointer, casts it
// to our required type (&#39;TradeThreadArgument *&#39;), and then calls the
// type-specific function, &#39;processTrade&#39;.  On return, the specific type is
// cast back to &#39;void*&#39;.
//..
//  extern &quot;C&quot; void *tradeProcessingThread(void *argumentsIn)
//  {
//      return (void *) processTrade ((TradeThreadArgument *)argumentsIn);
//  }
//..
// Function &#39;processBasketTrade&#39; drives the example.  Given a &#39;BasketTrade&#39;,
// the function spawns a separate thread for each individual trade in the
// basket, supplying the function &#39;tradeProcessingThread&#39; to be executed on
// each thread.
//..
//  bool processBasketTrade(BasketTrade&amp; trade)
//      // Return &#39;true&#39; if the specified basket &#39;trade&#39; was processed
//      // successfully, and &#39;false&#39; otherwise.  The &#39;trade&#39; is processed
//      // atomically, i.e., all the trades succeed, or none of the trades are
//      // executed.
//  {
//      TradeThreadArgument arguments[k_MAX_BASKET_TRADES];
//      bslmt::ThreadAttributes attributes;
//      bslmt::ThreadUtil::Handle threadHandles[k_MAX_BASKET_TRADES];
//
//      int numTrades = trade.d_trades.size();
//      assert(0 &lt; numTrades &amp;&amp; k_MAX_BASKET_TRADES &gt;= numTrades);
//..
// Construct the barrier that will be used by the processing threads.  Since a
// thread will be created for each trade in the basket, use the number of
// trades as the barrier count.  When &#39;bslmt::Barrier::wait()&#39; is called, the
// barrier will require &#39;numTrades&#39; objects to wait before all are released.
//..
//      bslmt::Barrier barrier(numTrades);
//      bool errorFlag = false;
//..
// Create a thread to process each trade.
//..
//      for (int i = 0; i &lt; numTrades; ++i) {
//          arguments[i].d_trades_p    = &amp;trade.d_trades;
//          arguments[i].d_barrier_p   = &amp;barrier;
//          arguments[i].d_errorFlag_p = &amp;errorFlag;
//          arguments[i].d_tradeNum    = i;
//          bslmt::ThreadUtil::create(&amp;threadHandles[i],
//                                    attributes,
//                                    tradeProcessingThread,
//                                    &amp;arguments[i]);
//      }
//..
// Wait for all threads to complete.
//..
//      for (int i = 0; i &lt; numTrades; ++i) {
//          bslmt::ThreadUtil::join(threadHandles[i]);
//      }
//..
// Check if any error occurred.
//..
//      return false == errorFlag;
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMT_CONDITION
#include &lt;bslmt_condition.h&gt;
#endif

#ifndef INCLUDED_BSLMT_MUTEX
#include &lt;bslmt_mutex.h&gt;
#endif

#ifndef INCLUDED_BSLS_TIMEINTERVAL
#include &lt;bsls_timeinterval.h&gt;
#endif

#ifndef INCLUDED_BSLS_SYSTEMCLOCKTYPE
#include &lt;bsls_systemclocktype.h&gt;
#endif

namespace BloombergLP {
namespace bslmt {

                              // =============
                              // class Barrier
                              // =============

class Barrier {
    // This class defines a thread barrier.

    Mutex           d_mutex;      // mutex used to control access to this
                                  // barrier.
    Condition       d_cond;       // condition variable used for signaling
                                  // blocked threads.
    const int       d_numThreads; // number of threads required to be waiting
                                  // before this barrier can be signaled.
    int             d_numWaiting; // number of threads currently waiting for
                                  // this barrier to be signaled.
    int             d_sigCount;   // counted of number of times this barrier
                                  // has been signaled.
    int             d_numPending; // Number of threads that have been signaled
                                  // but have not yet awakened.

    // NOT IMPLEMENTED
    Barrier(const Barrier&amp;);
    Barrier&amp; operator=(const Barrier&amp;);

  public:
    // CREATORS
    explicit Barrier(
    int                         numThreads,
    bsls::SystemClockType::Enum clockType = bsls::SystemClockType::e_REALTIME);
        // Create a barrier that requires the specified &#39;numThreads&#39; to
        // unblock.  Optionally specify a &#39;clockType&#39; indicating the type of
        // the system clock against which the &#39;bsls::TimeInterval&#39; timeouts
        // passed to the &#39;timedWait&#39; method are to be interpreted.  If
        // &#39;clockType&#39; is not specified then the realtime system clock is used.
        // The behavior is undefined unless &#39;0 &lt; numThreads&#39;.

    ~Barrier();
        // Wait for all *signaled* threads to unblock and destroy this barrier.
        // (See &#39;wait&#39; and &#39;timedWait&#39; below for the meaning of *signaled*.)
        // Note that the behavior is undefined if a barrier is destroyed while
        // one or more threads are waiting on it.

    // MANIPULATORS
    int timedWait(const bsls::TimeInterval &amp;timeout);
        // Block until the required number of threads have called &#39;wait&#39; or
        // &#39;timedWait&#39; on this barrier, or until the specified &#39;timeout&#39;
        // expires.  In the former case, *signal* all the threads that are
        // currently waiting on this barrier to unblock, reset the state of
        // this barrier to its initial state, and return 0.  If this method
        // times out before the required number of threads are waiting, the
        // thread is released to proceed and ceases to contribute to the number
        // of threads waiting.  Return a non-zero value if a timeout or error
        // occurs.  The &#39;timeout&#39; is an absolute time represented as an
        // interval from some epoch, which is determined by the clock indicated
        // at construction (see {&#39;Supported Clock-Types&#39;} in the component
        // documentation).  Note that &#39;timedWait&#39; and &#39;wait&#39; should not
        // generally be used together; if one or more threads called &#39;wait&#39;
        // while others called &#39;timedWait&#39;, then if the thread(s) that called
        // &#39;timedWait&#39; were to time out and not retry, the threads that called
        // &#39;wait&#39; would never unblock.

    void wait();
        // Block until the required number of threads have called either &#39;wait&#39;
        // or &#39;timedWait&#39; on this barrier.  Then *signal* all the threads that
        // are currently waiting on this barrier to unblock and reset the state
        // of this barrier to its initial state.  Note that generally &#39;wait&#39;
        // and &#39;timedWait&#39; should not be used together, for reasons explained
        // in the documentation of &#39;timedWait&#39;.

    // ACCESSORS
    int numThreads() const;
        // Return the number of threads that are required to call &#39;wait&#39; before
        // all waiting threads will unblock.
};
}  // close package namespace

// ============================================================================
//                             INLINE DEFINITIONS
// ============================================================================

// CREATORS
inline bslmt::Barrier::Barrier(int                         numThreads,
                               bsls::SystemClockType::Enum clockType)
: d_mutex()
, d_cond(clockType)
, d_numThreads(numThreads)
, d_numWaiting(0)
, d_sigCount(0)
, d_numPending(0)
{
}

// ACCESSORS
inline
int bslmt::Barrier::numThreads() const
{
    return d_numThreads;
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
