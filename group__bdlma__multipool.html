<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlma_multipool Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_multipool<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a memory manager to manage pools of varying block sizes.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Configuration at Construction</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Using a <code>bdlma::Multipool</code> Directly</a> </li>
<li>
<a href="#3.2.2">Example 2: Implementing an Allocator Using <code>bdlma::Multipool</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a memory manager to manage pools of varying block sizes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a> </td><td>memory manager that manages pools of varying block sizes  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlma__pool.html" title="Provide efficient allocation of memory blocks of uniform size.">Component bdlma_pool</a>, <a class="el" href="group__bdlma__multipoolallocator.html" title="Provide a memory-pooling allocator of heterogeneous block sizes.">Component bdlma_multipoolallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements a memory manager, <code><a class="el" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a></code>, that maintains a configurable number of <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code> objects, each dispensing maximally-aligned memory blocks of a unique size. The <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code> objects are placed in an array, starting at index 0, with each successive pool managing memory blocks of a size twice that of the previous pool. Each multipool allocation (deallocation) request allocates memory from (returns memory to) the internal pool managing memory blocks of the smallest size not less than the requested size, or else from a separately managed list of memory blocks, if no internal pool managing memory blocks of sufficient size exists. Both the <code>release</code> method and the destructor of a <code><a class="el" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a></code> release all memory currently allocated via the object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a></code> can be depicted visually: <br/>
<br/>
<div class="fragment"><pre class="fragment">                    +-----+--- memory blocks of 8 bytes
                    |     |
   ========       ----- ----- ------------
  |8 bytes |----&gt;|     |     |     ...    |
  &gt;========&lt;      =====^=====^============
  |16 bytes|
  &gt;========&lt;      \___________ __________/
  |32 bytes|                  V
  &gt;========&lt;              a <span class="stringliteral">&quot;chunk&quot;</span>
  |        |
  |  ...   |
  |        |
   ========
      |
      +------- array of <span class="stringliteral">&#39;bdlma::Pool&#39;</span>
</pre></div><br/>
<br/>
 Note that a "chunk" is a large, contiguous block of memory, internal to a <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code> maintained by the multipool, from which memory blocks of uniform size are dispensed to users. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="configuration_at_construction"></a> <a class="anchor" id="description.configuration_at_construction"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Configuration at Construction: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>When creating a <code><a class="el" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a></code>, clients can optionally configure: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
NUMBER OF POOLS -- the number of internal pools (the block size managed by the first pool is eight bytes, with each successive pool managing blocks of a size twice that of the previous pool).  </li>
<li>
<p class="startli">GROWTH STRATEGY -- geometrically growing chunk size starting from 1 (in terms of the number of memory blocks per chunk), or fixed chunk size, specified as either:</p>
<ul>
<li>
the unique growth strategy for all pools, or  </li>
<li>
(if the number of pools is specified) an array of growth strategies corresponding to each individual pool.  </li>
</ul>
<div class="hanging"> </div></li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> If the growth strategy is not specified, geometric growth is used for all</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> pools. </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<p>MAX BLOCKS PER CHUNK -- the maximum number of memory blocks within a chunk, specified as either:</p>
<ul>
<li>
the unique maximum-blocks-per-chunk value for all of the pools, or  </li>
<li>
an array of maximum-blocks-per-chunk values corresponding to each individual pool. </li>
</ul>
<div class="hanging"> <dl class="user"><dt><b></b></dt><dd>If the maximum blocks per chunk is not specified, an</dd></dl>
<dl class="user"><dt><b></b></dt><dd>implementation-defined default value is used. Note that the maximum</dd></dl>
<dl class="user"><dt><b></b></dt><dd>blocks per chunk can be configured only if the number of pools is also</dd></dl>
<dl class="user"><dt><b></b></dt><dd>configured. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p>BASIC ALLOCATOR -- the allocator used to supply memory (to replenish an internal pool, or directly if the maximum block size is exceeded). If not specified, the currently installed default allocator is used (see <code>bslma_default</code>).   </p>
<dl class="user"><dt><b></b></dt><dd>A default-constructed multipool has a relatively small, implementation-defined number of pools, <code>N</code>, with respective block sizes ranging from <code>2^3 = 8</code> to <code>2^(N+2)</code>. By default, the initial chunk size, (i.e., the number of blocks of a given size allocated at once to replenish a pool's memory) is 1, and each pool's chunk size grows geometrically until it reaches an implementation-defined maximum, at which it is capped. Finally, unless otherwise specified, all memory comes from the allocator that was the currently installed default allocator at the time the <code><a class="el" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a></code> was created. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Using the various pooling options described above, we can configure the number of pools maintained, whether replenishment should be adaptive (i.e., geometric starting with 1) or fixed at a maximum chunk size, what that maximum chunk size should be (which need not be an integral power of 2), and the underlying allocator used to supply memory. Note that both GROWTH STRATEGY and MAX BLOCKS PER CHUNK can be specified separately either as a single value applying to all of the maintained pools, or as an array of values, with the elements applying to each individually maintained pool. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_a_bdlma~3A~3Amultipool_directly"></a> <a class="anchor" id="usage.example_1~3A_using_a_bdlma~3A~3Amultipool_directly"></a> <a class="anchor" id="description.usage.example_1~3A_using_a_bdlma~3A~3Amultipool_directly"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using a bdlma::Multipool Directly: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a></code> can be used by containers that hold different types of elements, each of uniform size, for efficient memory allocation of new elements. Suppose we have a factory class, <code>my_MessageFactory</code>, that creates messages based on user requests. Each message is created with the most efficient memory storage possible, using predefined 8-byte, 16-byte, and 32-byte buffers. If the message size exceeds the three predefined values, a generic message is used. For efficient memory allocation of messages, we use a <code><a class="el" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define our message types as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_MessageFactory;

  <span class="keyword">class </span>my_Message {
      <span class="comment">// This class represents a general message interface that provides a</span>
      <span class="comment">// &#39;getMessage&#39; method for clients to retrieve the underlying message.</span>

    <span class="keyword">public</span>:
      <span class="comment">// ACCESSORS</span>
      <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *getMessage() = 0;
          <span class="comment">// Return the null-terminated message string.</span>
  };

  <span class="keyword">class </span>my_SmallMessage : <span class="keyword">public</span> my_Message {
      <span class="comment">// This class represents an 8-byte message (including null terminator).</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> d_buffer[8];

      <span class="comment">// FRIEND</span>
      <span class="keyword">friend</span> <span class="keyword">class </span>my_MessageFactory;

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      my_SmallMessage(<span class="keyword">const</span> my_SmallMessage&amp;);
      my_SmallMessage&amp; operator=(<span class="keyword">const</span> my_SmallMessage&amp;);

      <span class="comment">// PRIVATE CREATORS</span>
      my_SmallMessage(<span class="keyword">const</span> <span class="keywordtype">char</span> *msg, <span class="keywordtype">int</span> length)
      {
          assert(length &lt;= 7);

          bsl::memcpy(d_buffer, msg, length);
          d_buffer[length] = <span class="charliteral">&#39;\0&#39;</span>;
      }

      <span class="comment">// PRIVATE ACCESSORS</span>
      <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *getMessage()
      {
          <span class="keywordflow">return</span> d_buffer;
      }
  };

  <span class="keyword">class </span>my_MediumMessage : <span class="keyword">public</span> my_Message {
      <span class="comment">// This class represents a 16-byte message (including null</span>
      <span class="comment">// terminator).</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> d_buffer[16];

      <span class="comment">// FRIEND</span>
      <span class="keyword">friend</span> <span class="keyword">class </span>my_MessageFactory;

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      my_MediumMessage(<span class="keyword">const</span> my_MediumMessage&amp;);
      my_MediumMessage&amp; operator=(<span class="keyword">const</span> my_MediumMessage&amp;);

      <span class="comment">// PRIVATE CREATORS</span>
      my_MediumMessage(<span class="keyword">const</span> <span class="keywordtype">char</span> *msg, <span class="keywordtype">int</span> length)
      {
          assert(length &lt;= 15);

          bsl::memcpy(d_buffer, msg, length);
          d_buffer[length] = <span class="charliteral">&#39;\0&#39;</span>;
      }

      <span class="comment">// PRIVATE ACCESSORS</span>
      <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *getMessage()
      {
          <span class="keywordflow">return</span> d_buffer;
      }
  };

  <span class="keyword">class </span>my_LargeMessage : <span class="keyword">public</span> my_Message {
      <span class="comment">// This class represents a 32-byte message (including null</span>
      <span class="comment">// terminator).</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> d_buffer[32];

      <span class="comment">// FRIEND</span>
      <span class="keyword">friend</span> <span class="keyword">class </span>my_MessageFactory;

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      my_LargeMessage(<span class="keyword">const</span> my_LargeMessage&amp;);
      my_LargeMessage&amp; operator=(<span class="keyword">const</span> my_LargeMessage&amp;);

      <span class="comment">// PRIVATE CREATORS</span>
      my_LargeMessage(<span class="keyword">const</span> <span class="keywordtype">char</span> *msg, <span class="keywordtype">int</span> length)
      {
          assert(length &lt;= 31);

          bsl::memcpy(d_buffer, msg, length);
          d_buffer[length] = <span class="charliteral">&#39;\0&#39;</span>;
      }

      <span class="comment">// PRIVATE ACCESSORS</span>
      <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *getMessage()
      {
          <span class="keywordflow">return</span> d_buffer;
      }
  };

  <span class="keyword">class </span>my_GenericMessage : <span class="keyword">public</span> my_Message {
      <span class="comment">// This class represents a generic message.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> *d_buffer;

      <span class="comment">// FRIEND</span>
      <span class="keyword">friend</span> <span class="keyword">class </span>my_MessageFactory;

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      my_GenericMessage(<span class="keyword">const</span> my_GenericMessage&amp;);
      my_GenericMessage&amp; operator=(<span class="keyword">const</span> my_GenericMessage&amp;);

      <span class="comment">// PRIVATE CREATORS</span>
      my_GenericMessage(<span class="keywordtype">char</span> *msg) : d_buffer(msg)
      {
      }

      <span class="comment">// PRIVATE ACCESSORS</span>
      <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *getMessage()
      {
          <span class="keywordflow">return</span> d_buffer;
      }
  };
</pre></div><br/>
<br/>
 Then, we define our factory class, <code>my_MessageFactory</code>, as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_MessageFactory {
      <span class="comment">// This class implements an efficient message factory that builds and</span>
      <span class="comment">// returns messages.  The life-time of the messages created by this</span>
      <span class="comment">// factory is the same as this factory.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a> d_multipool;  <span class="comment">// multipool used to supply memory</span>

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      my_MessageFactory(<span class="keyword">const</span> my_MessageFactory&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_MessageFactory(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a message factory.  Optionally specify a &#39;basicAllocator&#39;</span>
          <span class="comment">// used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently</span>
          <span class="comment">// installed default allocator is used.</span>

      ~my_MessageFactory();
          <span class="comment">// Destroy this factory and reclaim all messages created by it.</span>

      <span class="comment">// MANIPULATORS</span>
      my_Message *createMessage(<span class="keyword">const</span> <span class="keywordtype">char</span> *data);
          <span class="comment">// Create a message storing the specified &#39;data&#39;.  The behavior is</span>
          <span class="comment">// undefined unless &#39;data&#39; is null-terminated.</span>

      <span class="keywordtype">void</span> disposeAllMessages();
          <span class="comment">// Dispose of all created messages.</span>

      <span class="keywordtype">void</span> disposeMessage(my_Message *message);
          <span class="comment">// Dispose of the specified &#39;message&#39;.  The behavior is undefined</span>
          <span class="comment">// unless &#39;message&#39; was created by this factory, and has not</span>
          <span class="comment">// already been disposed.</span>
  };
</pre></div><br/>
<br/>
 Next, we define the <code>inline</code> methods of <code>my_MessageFactory</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In calling the multipool's <code>release</code> method, <code>disposeAllMessages</code> quickly deallocates all memory blocks that were used to create messages currently outstanding from the factory. Following the call to <code>release</code>, <em>all</em> memory that had been allocated from the multipool is available for reuse: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_MessageFactory::disposeAllMessages()
  {
      d_multipool.release();
  }
</pre></div><br/>
<br/>
 Similarly, the call to the multipool's <code>deleteObject</code> method in <code>disposeMessage</code> first destroys the message, then releases the memory that had been allocated for it back to the multipool for use in creating another message having the same size: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_MessageFactory::disposeMessage(my_Message *message)
  {
      d_multipool.deleteObject(message);
  }
</pre></div><br/>
<br/>
 A multipool optimizes the allocation of memory by using dynamically-allocated buffers (also known as chunks) to supply memory. As each chunk can satisfy multiple memory block requests before requiring additional dynamic memory allocation, the number of dynamic allocation requests needed is greatly reduced. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For the number of pools managed by the multipool, we chose to use the implementation-defined default value instead of calculating and specifying a value. If users instead want to specify the number of pools, the value can be calculated as the smallest value, <code>N</code>, such that the following relationship holds: <br/>
<br/>
<div class="fragment"><pre class="fragment">  N &gt; log2(<span class="keyword">sizeof</span>(Object <a class="code" href="classBind__ImplSelector_1_1Type.html">Type</a>)) - 2
</pre></div><br/>
<br/>
 Next, we define the creators of <code>my_MessageFactory</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  my_MessageFactory::my_MessageFactory(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_multipool(basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 Note that in the destructor, all outstanding messages are reclaimed automatically when <code>d_multipool</code> is destroyed: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_MessageFactory::~my_MessageFactory()
  {
  }
</pre></div><br/>
<br/>
 Finally, we define the <code>createMessage</code> factory method that actually creates the messages using memory provided by the multipool. A <code><a class="el" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a></code> is ideal for allocating the different sized messages since repeated deallocations might be necessary, which renders a <code><a class="el" href="classbdlma_1_1SequentialPool.html">bdlma::SequentialPool</a></code> unsuitable: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  my_Message *my_MessageFactory::createMessage(<span class="keyword">const</span> <span class="keywordtype">char</span> *data)
  {
      <span class="keyword">enum</span> { k_SMALL = 8, k_MEDIUM = 16, k_LARGE = 32 };

      <span class="keyword">const</span> <span class="keywordtype">int</span> length = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(bsl::strlen(data));

      <span class="keywordflow">if</span> (length &lt; k_SMALL) {
          <span class="keywordflow">return</span> <span class="keyword">new</span>(d_multipool.allocate(<span class="keyword">sizeof</span>(my_SmallMessage)))
                                    my_SmallMessage(data, length);  <span class="comment">// RETURN</span>
      }

      <span class="keywordflow">if</span> (length &lt; k_MEDIUM) {
          <span class="keywordflow">return</span> <span class="keyword">new</span>(d_multipool.allocate(<span class="keyword">sizeof</span>(my_MediumMessage)))
                                   my_MediumMessage(data, length);  <span class="comment">// RETURN</span>
      }

      <span class="keywordflow">if</span> (length &lt; k_LARGE) {
          <span class="keywordflow">return</span> <span class="keyword">new</span>(d_multipool.allocate(<span class="keyword">sizeof</span>(my_LargeMessage)))
                                    my_LargeMessage(data, length);  <span class="comment">// RETURN</span>
      }

      <span class="keywordtype">char</span> *buffer = (<span class="keywordtype">char</span> *)d_multipool.allocate(length + 1);
      bsl::memcpy(buffer, data, length + 1);

      <span class="keywordflow">return</span> <span class="keyword">new</span>(d_multipool.allocate(<span class="keyword">sizeof</span>(my_GenericMessage)))
                                                   my_GenericMessage(buffer);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_implementing_an_allocator_using_bdlma~3A~3Amultipool"></a> <a class="anchor" id="usage.example_2~3A_implementing_an_allocator_using_bdlma~3A~3Amultipool"></a> <a class="anchor" id="description.usage.example_2~3A_implementing_an_allocator_using_bdlma~3A~3Amultipool"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Implementing an Allocator Using bdlma::Multipool: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose that we want to create a multipool allocator (i.e., that implements the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> interface) that allocates memory from multiple <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code> objects in a similar fashion to <code><a class="el" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a></code>. In this example, we create just such a multipool allocator, <code>my_MultipoolAllocator</code>, that uses a <code><a class="el" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a></code> to manage the multiple pools. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define the interface of <code>my_MultipoolAllocator</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_MultipoolAllocator : <span class="keyword">public</span> bslma::Allocator {
      <span class="comment">// This class implements the &#39;bslma::Allocator&#39; protocol to provide an</span>
      <span class="comment">// allocator that manages a set of memory pools, each dispensing memory</span>
      <span class="comment">// blocks of a unique size, with each successive pool&#39;s block size</span>
      <span class="comment">// being twice that of the previous one.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a> d_multiPool;  <span class="comment">// memory manager for allocated memory</span>
                                     <span class="comment">// blocks</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_MultipoolAllocator(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a multipool allocator.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      <span class="comment">// ...</span>

      <span class="keyword">virtual</span> ~my_MultipoolAllocator();
          <span class="comment">// Destroy this multipool allocator.  All memory allocated from</span>
          <span class="comment">// this memory pool is released.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> *allocate(size_type size);
          <span class="comment">// Return the address of a contiguous block of maximally-aligned</span>
          <span class="comment">// memory of (at least) the specified &#39;size&#39; (in bytes).  If &#39;size&#39;</span>
          <span class="comment">// is 0, no memory is allocated and 0 is returned.</span>

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *address);
          <span class="comment">// Relinquish the memory block at the specified &#39;address&#39; back to</span>
          <span class="comment">// this multipool allocator for reuse.  The behavior is undefined</span>
          <span class="comment">// unless &#39;address&#39; is non-zero, was allocated by this multipool</span>
          <span class="comment">// allocator, and has not already been deallocated.</span>
  };
</pre></div><br/>
<br/>
 Note that the interface and documentation for this class is simplified for this usage example. Please see <code>bdlma_multipoolallocator</code> for a similar class meant for production use. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, we provide the trivial implementation of <code>my_MultipoolAllocator</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  my_MultipoolAllocator::my_MultipoolAllocator(
                                            <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_multiPool(basicAllocator)
  {
  }

  my_MultipoolAllocator::~my_MultipoolAllocator()
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> *my_MultipoolAllocator::allocate(size_type size)
  {
      <span class="keywordflow">if</span> (0 == size) {
          <span class="keywordflow">return</span> 0;                                                 <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">else</span> {
          <span class="keywordflow">return</span> d_multiPool.allocate(static_cast&lt;int&gt;(size));      <span class="comment">// RETURN</span>
      }
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_MultipoolAllocator::deallocate(<span class="keywordtype">void</span> *address)
  {
      d_multiPool.deallocate(address);
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:46 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
