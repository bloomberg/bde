<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslma_deallocatorproctor.h                                         -*-C++-*-
#ifndef INCLUDED_BSLMA_DEALLOCATORPROCTOR
#define INCLUDED_BSLMA_DEALLOCATORPROCTOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a proctor to conditionally manage a block memory.
//
//@CLASSES:
//  bslma::DeallocatorProctor: proctor to conditionally manage a memory
//
//@SEE_ALSO: bslma_deallocatorguard, bslma_autodeallocator
//
//@DESCRIPTION: This component provides a proctor class template to
// conditionally manage a block of (otherwise-unmanaged) memory.  If not
// explicitly released, the managed memory is deallocated automatically when
// the proctor object goes out of scope by freeing the memory using the
// parameterized &#39;ALLOCATOR&#39; (allocator or pool) supplied at construction.
// Note that after a proctor object releases its managed memory, the same
// proctor can be reused to conditionally manage another block of memory
// (allocated from the same allocator or pool that was supplied at
// construction) by invoking the &#39;reset&#39; method.
//
///Requirement
///-----------
// The parameterized &#39;ALLOCATOR&#39; type of the &#39;bslma::DeallocatorProctor&#39; class
// must provide a (possibly &#39;virtual&#39;) method:
//..
//  void deallocate(void *address);
//..
// to deallocate memory at the specified &#39;address&#39; (originally supplied by the
// &#39;ALLOCATOR&#39; object).
//
///Usage
///-----
// The &#39;bslma::DeallocatorProctor&#39; is normally used to achieve *exception*
// *safety* in an *exception* *neutral* way by managing memory in a sequence of
// continuous memory allocations.  Since each memory allocation may
// potentially throw an exception, an object of this proctor class can be used
// to (temporarily) manage newly allocated memory while attempting to allocate
// additional memory.  Should an exception occur in subsequent memory
// allocation, the proctor&#39;s destructor deallocates its managed memory,
// preventing a memory leak.
//
// This example illustrate a typical use of &#39;bslma::DeallocatorProctor&#39;.
// Suppose we have an array class that stores an &quot;in-place&quot; representation of
// objects of parameterized &#39;TYPE&#39;:
//..
//  // my_array.h
//  // ...
//
//  template &lt;class TYPE&gt;
//  class my_Array {
//      // This class implements an &quot;in-place&quot; array of objects of
//      // parameterized &#39;TYPE&#39; stored contiguously in memory.
//
//      // DATA
//      TYPE             *d_array_p;      // dynamically allocated array
//      int               d_length;       // logical length of this array
//      int               d_size;         // physical capacity of this array
//      bslma::Allocator *d_allocator_p;  // allocator (held, not owned)
//
//    public:
//      // CREATORS
//      my_Array(bslma::Allocator *basicAllocator = 0);
//          // Create a &#39;my_Array&#39; object.  Optionally specify a
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//          // 0, the currently installed default allocator is used.
//
//      // ...
//
//      ~my_Array();
//          // Destroy this &#39;my_Array&#39; object and all elements currently
//          // stored.
//
//      // MANIPULATORS
//      // ...
//
//      void append(const TYPE&amp; object);
//          // Append (a copy of) the specified &#39;object&#39; of parameterized
//          // &#39;TYPE&#39; to (the end of) this array.
//
//      // ...
//  };
//..
// Note that the rest of the &#39;my_Array&#39; interface (above) and implementation
// (below) is elided as the portion shown is sufficient to demonstrate the use
// of &#39;bslma::DeallocatorProctor&#39;.
//..
//  // CREATORS
//  template &lt;class TYPE&gt;
//  inline
//  my_Array&lt;TYPE&gt;::my_Array(bslma::Allocator *basicAllocator)
//  : d_length(0)
//  , d_size(1)
//  , d_allocator_p(bslma::Default::allocator(basicAllocator))
//  {
//      d_array_p = (TYPE *)d_allocator_p-&gt;allocate(sizeof(TYPE));
//  }
//
//  template &lt;class TYPE&gt;
//  my_Array&lt;TYPE&gt;::~my_Array()
//  {
//      for (int i = 0; i &lt; d_length; ++i) {
//          d_array_p[i].~TYPE();
//      }
//      d_allocator_p-&gt;deallocate(d_array_p);
//  }
//..
// In order to implement the &#39;append&#39; function, we first have to introduce an
// &#39;my_AutoDestructor&#39; &#39;class&#39;, which automatically destroy a sequence of
// managed objects upon destruction.  See &#39;bslma::AutoDestructor&#39; for a similar
// component with full documentation:
//..
//  // my_autodestructor.h
//  // ...
//
//  template &lt;class TYPE&gt;
//  class my_AutoDestructor {
//      // This class implements a range proctor that, unless its &#39;release&#39;
//      // method has previously been invoked, automatically invokes the
//      // destructor of each of sequence of objects it manages.
//
//      // DATA
//      TYPE * d_origin_p;
//      int    d_length;
//
//    public:
//      // CREATORS
//      my_AutoDestructor(TYPE *origin, int length)
//          // Create an &#39;my_AutoDestructor&#39; to manage a contiguous sequence of
//          // objects.
//      : d_origin_p(origin)
//      , d_length(length)
//      {
//      }
//
//      ~my_AutoDestructor()
//          // Destroy this &#39;my_AutoDestructor&#39; and, unless its &#39;release&#39;
//          // method has previously been invoked, destroy the sequence of
//          // objects it manages by invoking the destructor of each of the
//          // (managed) objects.
//      {
//          if (d_length) {
//              for (; d_length &gt; 0; --d_length, ++d_origin_p) {
//                  d_origin_p-&gt;~TYPE();
//              }
//          }
//      }
//
//      // MANIPULATORS
//      my_AutoDestructor&lt;TYPE&gt;&amp; operator++()
//          // Increase by one the length of the sequence of objects managed by
//          // this range proctor.
//      {
//          ++d_length;
//          return *this;
//      }
//
//      void release()
//          // Release from management the sequence of objects currently
//          // managed by this range proctor.
//      {
//          d_length = 0;
//      }
//  };
//..
// We can now continue with our implementation of the &#39;my_Array&#39; class:
//..
//  // my_array.h
//  // ...
//
//  // MANIPULATORS
//  template &lt;class TYPE&gt;
//  void my_Array&lt;TYPE&gt;::append(const TYPE &amp;object)
//  {
//      if (d_length == d_size) {
//          TYPE *newArray = (TYPE *)d_allocator_p-&gt;allocate(
//                               d_size * 2 * sizeof(TYPE));  // possibly throw
//
//          //*****************************************************************
//          // Note the use of the deallocator proctor on &#39;newArray&#39; (below). *
//          //*****************************************************************
//
//          bslma::DeallocatorProctor&lt;bslma::Allocator&gt; proctor(newArray,
//                                                              d_allocator_p);
//
//          // Note use of &#39;my_AutoDestructor&#39; here to protect the copy
//          // construction of &#39;TYPE&#39; objects.
//          my_AutoDestructor&lt;TYPE&gt; destructor(newArray, 0);
//
//          for (int i = 0; i &lt; d_length; ++i) {
//              new(&amp;newArray[i]) TYPE(d_array_p[i], d_allocator_p);
//                                                           // possibly throw
//              d_array_p[i].~TYPE();
//              ++destructor;
//          }
//
//          destructor.release();
//
//          //*********************************************************
//          // Note that the deallocator proctor is released (below). *
//          //*********************************************************
//
//          proctor.release();
//
//          d_allocator_p-&gt;deallocate(d_array_p);
//          d_array_p = newArray;
//          d_size   *= 2;
//      }
//
//      new(&amp;d_array_p[d_length]) TYPE(object, d_allocator_p);
//      ++d_length;
//  }
//..
// Both the use of &#39;bslma::DeallocatorProctor&#39; and &#39;my_AutoDestructor&#39; are
// necessary to implement exception safety.
//
// The &#39;append&#39; method defined above potentially throws in two places.  If the
// memory allocator held in &#39;d_allocator_p&#39; where to throw while attempting to
// allocate the new array of parameterized &#39;TYPE&#39;, no memory would be leaked.
// But without subsequent use of the &#39;bslma::DeallocatorProctor&#39;, if the
// allocator subsequently throws while copy constructing the objects from the
// old array to the new array, the newly allocated memory block would be
// leaked.  Using the &#39;bslma::DeallocatorProctor&#39; prevents the leak by
// deallocating the proctored memory automatically should the proctor go out
// of scope before the &#39;release&#39; method of the proctor is called (such as when
// the function exits prematurely due to an exception).
//
// Similarly, any resources acquired as a result of copy constructing the
// objects from the old array to the new array would be leaked if the
// constructor of &#39;TYPE&#39; throws.  Using the &#39;my_AutoDestructor&#39; prevents the
// leak by invoking the destructor of the proctored (and newly created) objects
// in the new array should the &#39;my_AutoDestructor&#39; goes out of scope before the
// &#39;release&#39; method of the proctor is called.
//
// Note that the &#39;append&#39; method assumes the copy constructor of &#39;TYPE&#39; takes
// an allocator as a second argument.  In production code, a constructor proxy
// that checks the traits of &#39;TYPE&#39; (to see whether &#39;TYPE&#39; uses
// &#39;bslma::Allocator&#39;) should be used (see &#39;bslalg::ConstructorProxy&#39;).

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#include &lt;bsls_performancehint.h&gt;
#endif

namespace BloombergLP {

namespace bslma {

                        // ========================
                        // class DeallocatorProctor
                        // ========================

template &lt;class ALLOCATOR&gt;
class DeallocatorProctor {
    // This class implements a proctor that, unless its &#39;release&#39; method has
    // previously been invoked, automatically deallocates a block of managed
    // memory upon destruction by invoking the &#39;deallocate&#39; method of an
    // allocator (or pool) of parameterized &#39;ALLOCATOR&#39; type supplied to it at
    // construction.  The managed memory must have been provided by this
    // allocator (or pool), which must remain valid throughout the lifetime of
    // the proctor object.

    // DATA
    void      *d_memory_p;     // address of managed memory
    ALLOCATOR *d_allocator_p;  // allocator or pool (held, not owned)

    // NOT IMPLEMENTED
    DeallocatorProctor(const DeallocatorProctor&amp;);
    DeallocatorProctor&amp; operator=(const DeallocatorProctor&amp;);

  public:
    // CREATORS
    DeallocatorProctor(void *memory, ALLOCATOR *allocator);
        // Create a deallocator proctor that conditionally manages the
        // specified &#39;memory&#39; (if non-zero), and that uses the specified
        // &#39;allocator&#39; to deallocate the block of memory managed by this
        // proctor (if not released -- see &#39;release&#39;) upon destruction.  The
        // behavior is undefined unless &#39;allocator&#39; is non-zero and supplied
        // &#39;memory&#39;.  Note that &#39;allocator&#39; must remain valid throughout the
        // lifetime of this proctor.

    ~DeallocatorProctor();
        // Destroy this deallocator proctor, and deallocate the block of memory
        // it manages (if any) by invoking the &#39;deallocate&#39; method of the
        // allocator (or pool) that was supplied at construction of this
        // proctor.  If no memory is currently being managed, this method has
        // no effect.

    // MANIPULATORS
    void release();
        // Release from management the block of memory currently managed by
        // this proctor.  If no memory is currently being managed, this method
        // has no effect.

    void reset(void *memory);
        // Set the specified &#39;memory&#39; as the block of memory to be managed by
        // this proctor.  The behavior is undefined unless &#39;memory&#39; is non-zero
        // and was allocated by the allocator (or pool) supplied at
        // construction.  Note that this method releases any previously-managed
        // memory from management (without deallocating it), and so may be
        // invoked with or without having called &#39;release&#39; when reusing this
        // object.
};

// ============================================================================
//                      TEMPLATE FUNCTION DEFINITIONS
// ============================================================================

                        // ------------------------
                        // class DeallocatorProctor
                        // ------------------------

// CREATORS
template &lt;class ALLOCATOR&gt;
inline
DeallocatorProctor&lt;ALLOCATOR&gt;::
DeallocatorProctor(void *memory, ALLOCATOR *allocator)
: d_memory_p(memory)
, d_allocator_p(allocator)
{
    BSLS_ASSERT_SAFE(allocator);
}

template &lt;class ALLOCATOR&gt;
inline
DeallocatorProctor&lt;ALLOCATOR&gt;::~DeallocatorProctor()
{
    BSLS_ASSERT_SAFE(d_allocator_p);

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(0 != d_memory_p)) {
        d_allocator_p-&gt;deallocate(d_memory_p);
    }
}

// MANIPULATORS
template &lt;class ALLOCATOR&gt;
inline
void DeallocatorProctor&lt;ALLOCATOR&gt;::release()
{
    d_memory_p = 0;
}

template &lt;class ALLOCATOR&gt;
inline
void DeallocatorProctor&lt;ALLOCATOR&gt;::reset(void *memory)
{
    BSLS_ASSERT_SAFE(memory);

    d_memory_p = memory;
}

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
