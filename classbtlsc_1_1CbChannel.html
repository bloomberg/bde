<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlsc::CbChannel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlsc.html">btlsc</a>      </li>
      <li><a class="el" href="classbtlsc_1_1CbChannel.html">btlsc::CbChannel</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlsc::CbChannel Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlsc::CbChannel" -->
<p><code>#include &lt;<a class="el" href="btlsc__cbchannel_8h_source.html">btlsc_cbchannel.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlsc::CbChannel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlsc_1_1CbChannel.png" usemap="#btlsc::CbChannel_map" alt=""/>
  <map id="btlsc::CbChannel_map" name="btlsc::CbChannel_map">
<area href="classbtlsc_1_1TimedCbChannel.html" alt="btlsc::TimedCbChannel" shape="rect" coords="0,56,167,80"/>
<area href="classbtlsos_1_1TcpCbChannel.html" alt="btlsos::TcpCbChannel" shape="rect" coords="177,56,344,80"/>
<area href="classbtlsos_1_1TcpTimedCbChannel.html" alt="btlsos::TcpTimedCbChannel" shape="rect" coords="0,112,167,136"/>
</map>
</div>

<p><a href="classbtlsc_1_1CbChannel-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(int, <br class="typebreak"/>
int)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(const <br class="typebreak"/>
char *, int, int)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a808401f2ddc7b467842899e3bf5dbd9d">BufferedReadCallback</a> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(int, <br class="typebreak"/>
int)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a26ce2ef9fa5cb39f26d928f424af69fe">~CbChannel</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a71fcb3cb575021a5bff1e1d996ae3dc9">read</a> (char *buffer, int numBytes, const <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a> &amp;readCallback, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#adb7ade594003c33472a35749462f76e0">readRaw</a> (char *buffer, int numBytes, const <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a> &amp;readCallback, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a9fcff7d3b744f8dbb05a094b203523e5">readvRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a> &amp;readCallback, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a8cc6b0bd0b4cf6070d6b164a1726a7e1">bufferedRead</a> (int numBytes, const <a class="el" href="classbtlsc_1_1CbChannel.html#a808401f2ddc7b467842899e3bf5dbd9d">BufferedReadCallback</a> &amp;bufferedReadCallback, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a6ac1deccdd7bdcf1a949638e532c2ed9">bufferedReadRaw</a> (int numBytes, const <a class="el" href="classbtlsc_1_1CbChannel.html#a808401f2ddc7b467842899e3bf5dbd9d">BufferedReadCallback</a> &amp;bufferedReadCallback, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#ac58ed54ff869f449e6672a6bd470ff2d">write</a> (const char *buffer, int numBytes, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#ab07c45b0997c2e66e3b28943be4e1948">writeRaw</a> (const char *buffer, int numBytes, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#ace33a3f5d0ae273230d79898827dd21f">writevRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#ae3d0fe91594c169bc3b0123d7124e758">writevRaw</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a2e12ce40b22aabba8689d4325efea1b4">bufferedWrite</a> (const char *buffer, int numBytes, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a2e102b37af56ff4502dde940d7ac46fd">bufferedWritev</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a7c153666e294299a83bff84ffcc6dc08">bufferedWritev</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a92c1e71d3d0378dcbe198018ab14a2ea">cancelAll</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a98b8fbce01bfbf03f1d1b5b9c67c3eb9">cancelRead</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a1a6e0c4c40a1401ad43003c38f997a00">cancelWrite</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#ad1d652169b74a4a7c8609547e242898a">invalidate</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a5e223877ed9b0eea354960757769b9eb">invalidateRead</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a88e8f4b0da32d77b35de2c22e4720448">invalidateWrite</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a8d33bdf80527d19a95559d9834c63814">isInvalidRead</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#aa69b72f04f1d01ccad96923c61bb7a14">isInvalidWrite</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#ac13128f3bb11696dd22ad286efe9bd64">numPendingReadOperations</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#ac653cbfea8a41ce9eaf71bd85f87acb7">numPendingWriteOperations</a> () const =0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class represents a protocol (pure abstract interface) for a communications channel that supports (non-blocking) buffered read and write operations on a byte stream. In general, a non-negative status indicates the number of bytes read or written, while a negative status implies an unspecified error. Note that an error status of -1 indicates that the connection is <em>known</em> to have been closed by the peer. The converse -- that -1 will be returned if/when a peer drops a connection -- cannot be guaranteed by implementations of this interface and must not be relied upon by users. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a9a33340398e368155dd8d6df7a2433fe"></a><!-- doxytag: member="btlsc::CbChannel::ReadCallback" ref="a9a33340398e368155dd8d6df7a2433fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(int, int)&gt; <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">btlsc::CbChannel::ReadCallback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a result of any non-buffered read method, <code>ReadCallback</code> is an alias for a callback function object (functor) that returns <code>void</code> and takes as arguments an integer "status" indicating <em>success</em>, an <em>incomplete</em> <em>read</em>, or an <em>error</em>, and a second integer "augStatus". Together, the two status values indicate three possible reasons for any incomplete result: (1) a (caller-authorized) interruption by an asynchronous event, (2) a (caller-authorized) implementation-dependent, data-driven optimization, or (3) an operation dequeued (canceled) by the implementation or the user. </p>

<p>Reimplemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#af2269d5a75219ce003c35c70e1a8c245">btlsc::TimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a808401f2ddc7b467842899e3bf5dbd9d"></a><!-- doxytag: member="btlsc::CbChannel::BufferedReadCallback" ref="a808401f2ddc7b467842899e3bf5dbd9d" args=")" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(const char *, int, int) <a class="el" href="classbtlsc_1_1CbChannel.html#a808401f2ddc7b467842899e3bf5dbd9d">btlsc::CbChannel::BufferedReadCallback</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a result of any buffered read method, <code>BufferedReadCallback</code> is an alias for a callback function object (functor) that returns <code>void</code> and takes as arguments the (potential) address of a non-modifiable character "buffer", an integer "status" indicating <em>success</em>, an <em>incomplete</em> <em>read</em>, or an <em>error</em>, and a second integer "augStatus". Together, the two status values indicate three possible reasons for any incomplete result: (1) a (caller-authorized) interruption by an asynchronous event, (2) a (caller-authorized) implementation-dependent, data-driven optimization, or (3) an operation dequeued (canceled) by the implementation or the user. </p>

<p>Reimplemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a59d8adcfe643e0468504b0b0342dd2f8">btlsc::TimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a0a7a36015788139496abcf47ec1ba712"></a><!-- doxytag: member="btlsc::CbChannel::WriteCallback" ref="a0a7a36015788139496abcf47ec1ba712" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(int, int)&gt; <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">btlsc::CbChannel::WriteCallback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a result of any write method, <code>WriteCallback</code> is an alias for a callback function object (functor) that returns <code>void</code> and takes as arguments an integer "status" indicating <em>success</em>, an <em>incomplete</em> <em>write</em>, or an <em>error</em>, and a second integer "augStatus". Together, the two status values indicate three possible reasons for any incomplete result: (1) a (caller-authorized) interruption by an asynchronous event, (2) a (caller-authorized) implementation-dependent, data-driven optimization, or (3) an operation dequeued (canceled) by the implementation or the user. </p>

<p>Reimplemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#aae5dd7f12c6b1d98eab280fd8f64060b">btlsc::TimedCbChannel</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a26ce2ef9fa5cb39f26d928f424af69fe"></a><!-- doxytag: member="btlsc::CbChannel::~CbChannel" ref="a26ce2ef9fa5cb39f26d928f424af69fe" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual btlsc::CbChannel::~CbChannel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a71fcb3cb575021a5bff1e1d996ae3dc9"></a><!-- doxytag: member="btlsc::CbChannel::read" ref="a71fcb3cb575021a5bff1e1d996ae3dc9" args="(char *buffer, int numBytes, const ReadCallback &amp;readCallback, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::read </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>readCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to read the specified <code>numBytes</code> from this channel into the specified <code>buffer</code>; execute the specified <code>readCallback</code> functor after this read operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>readCallback</code> will not be invoked).</p>
<p>When invoked, the <code>readCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to <code>numBytes</code>, the operation was successful and <code>buffer</code> is loaded with <code>numBytes</code> of incoming data. Otherwise, if "status" is non-negative (incomplete read), it indicates the number of bytes read into <code>buffer</code> in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event, and negative ("status" identically 0) if this operation was canceled. If the transmission is incomplete, the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and remains valid until the (non-null) <code>readCallback</code> completes, and <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a3e1d58f78923b83041988a57024e2159">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#a2385288c221a27881079c63fdc5961dd">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#aae431c242b1409e2b6fcd26dd03e2fd8">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="adb7ade594003c33472a35749462f76e0"></a><!-- doxytag: member="btlsc::CbChannel::readRaw" ref="adb7ade594003c33472a35749462f76e0" args="(char *buffer, int numBytes, const ReadCallback &amp;readCallback, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::readRaw </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>readCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to <em>atomically</em> read <em>up</em> <em>to</em> the specified <code>numBytes</code> from this channel into the specified <code>buffer</code>; execute the specified <code>readCallback</code> functor after this read operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous
         events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>readCallback</code> will not be invoked).</p>
<p>When invoked, <code>readCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful for this method only when "status" is zero). A non-negative "status" indicates the number of bytes read into <code>buffer</code>. If "status" is positive, the atomic OS-level ("raw") read operation completed; "status" equals <code>numBytes</code> upon success. In either case, "augStatus" has no meaning. If "status" is zero, the atomic read operation did not complete, in which case "augStatus" is positive if an "asynchronous
         event" interrupted the operation, and negative if the operation was canceled. If the transmission was interrupted, the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error: -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and remains valid until the (non-null) <code>readCallback</code> completes, and <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a52545a2ed93fbb0ceb412b1a307568d1">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#a29fb5a562e6984a8025af18f0ce273a8">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#a3639d28ed0d0fd3bd2d9e100c7cf61f2">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a9fcff7d3b744f8dbb05a094b203523e5"></a><!-- doxytag: member="btlsc::CbChannel::readvRaw" ref="a9fcff7d3b744f8dbb05a094b203523e5" args="(const btls::Iovec *buffers, int numBuffers, const ReadCallback &amp;readCallback, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::readvRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>readCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to <em>atomically</em> read from this channel into the specified sequence of <code>buffers</code> of the specified sequence length <code>numBuffers</code> <em>up</em> <em>to</em> the respective number of bytes as defined by the <code>length</code> method of each <code>Iovec</code> structure; execute the specified <code>readCallback</code> functor after this read operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous
         events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>readCallback</code> will not be invoked).</p>
<p>When invoked, <code>readCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful for this method only when "status" is zero). A non-negative "status" indicates the total number of bytes read into <code>buffers</code>. If "status" is positive, the atomic ("raw") vector-read operation completed; "status" equals the requested number of bytes (i.e., the sum of the lengths of the <code>numBuffers</code> <code>buffers</code> or <code>numBytes</code>) upon success. In either case, "augStatus" has no meaning. If "status" is zero, the atomic read operation did not complete, in which case "augStatus" is positive if an "asynchronous event" interrupted the operation, and negative if the operation was canceled. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffers</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffers</code> has sufficient capacity to hold the requested data and remains valid until the (non-null) <code>readCallback</code> completes, and <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a1ecc6a8b0701c4efba44238c3f934bce">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#a028aa5fdce088af97656ed948edbfa83">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#a76bda3000b2f1ff38127af706c2f93c4">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a8cc6b0bd0b4cf6070d6b164a1726a7e1"></a><!-- doxytag: member="btlsc::CbChannel::bufferedRead" ref="a8cc6b0bd0b4cf6070d6b164a1726a7e1" args="(int numBytes, const BufferedReadCallback &amp;bufferedReadCallback, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::bufferedRead </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a808401f2ddc7b467842899e3bf5dbd9d">BufferedReadCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bufferedReadCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to read the specified <code>numBytes</code> from this channel into a channel-supplied buffer; execute the specified <code>bufferedReadCallback</code> functor after this read operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>bufferedReadCallback</code> will not be invoked).</p>
<p>When invoked, <code>bufferedReadCallback</code> is passed the address of a non-modifiable character "buffer", an integer "status", and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to <code>numBytes</code>, the operation was successful and "buffer" contains <code>numBytes</code> of incoming data (which will remain valid only until the callback completes). Otherwise, if "status" is non-negative (incomplete read), it indicates the number of (accessible) bytes in "buffer", in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event, and negative ("status" identically 0) if this operation was canceled. If the transmission is partial, the data is retained in the channel's buffer and the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of "buffer" undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code> and <code>bufferedReadCallback</code> is non-null. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a416d04df6e1eed713b22d1a54b812f06">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#afe26a4b1f56a27676742ac4af1fb1559">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#a803ebf8f45bf7cc1438fae299ecd477d">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a6ac1deccdd7bdcf1a949638e532c2ed9"></a><!-- doxytag: member="btlsc::CbChannel::bufferedReadRaw" ref="a6ac1deccdd7bdcf1a949638e532c2ed9" args="(int numBytes, const BufferedReadCallback &amp;bufferedReadCallback, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::bufferedReadRaw </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a808401f2ddc7b467842899e3bf5dbd9d">BufferedReadCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bufferedReadCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to <em>atomically</em> read <em>up</em> <em>to</em> the specified <code>numBytes</code> from this channel into a channel-supplied buffer; execute the specified <code>bufferedReadCallback</code> functor after this read operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous
         events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>bufferedReadCallback</code> will not be invoked).</p>
<p>When invoked, <code>bufferedReadCallback</code> is passed the address of a non-modifiable character "buffer", an integer "status", and a second integer "augStatus" (which is meaningful for this method only when "status" is zero). A non-negative "status" indicates the total number of bytes read into "buffer". If "status" is positive, the atomic OS-level ("raw") read operation completed; "status" equals <code>numBytes</code> upon success. In either case, "augStatus" has no meaning. If "status" is zero, the atomic read operation did not complete, in which case "augStatus" is positive if an "asynchronous
         event" interrupted the operation, and negative if the operation was canceled. If the transmission is incomplete (i.e., "status" less than <code>numBytes</code>) the data is retained in the channel's buffer and the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of "buffer" undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code> and <code>bufferedReadCallback</code> is non-null. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#abd30ff4a008cac332c9ce43469560df7">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#a7b244f581d2610dbcbd0b7a77dfc94da">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#a02ddd67c3ef60fd63111bd39d6b311f6">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ac58ed54ff869f449e6672a6bd470ff2d"></a><!-- doxytag: member="btlsc::CbChannel::write" ref="ac58ed54ff869f449e6672a6bd470ff2d" args="(const char *buffer, int numBytes, const WriteCallback &amp;writeCallback, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::write </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to write the specified <code>numBytes</code> from the specified <code>buffer</code> to this channel; execute the specified <code>writeCallback</code> functor after this write operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>writeCallback</code> will not be invoked).</p>
<p>When invoked, <code>writeCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to <code>numBytes</code>, the operation was successful and all <code>numBytes</code> of data were transmitted to the channel. Otherwise, if "status" is non-negative (incomplete write), it indicates the number of bytes written from <code>buffer</code>, in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event, and negative ("status" identically 0) if this operation was canceled. If the transmission is incomplete, the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> remains valid until the (non-null) <code>writeCallback</code> completes and <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a62ef59df712d2ee0ef3a8d127bb2620d">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#aceddf2e82892b0a1a4df41df937a9245">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#aaeff45232dfb1ec68bcd19dd8ae120cb">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ab07c45b0997c2e66e3b28943be4e1948"></a><!-- doxytag: member="btlsc::CbChannel::writeRaw" ref="ab07c45b0997c2e66e3b28943be4e1948" args="(const char *buffer, int numBytes, const WriteCallback &amp;writeCallback, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::writeRaw </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to <em>atomically</em> write <em>up</em> <em>to</em> the specified <code>numBytes</code> from the specified <code>buffer</code> to this channel; execute the specified <code>writeCallback</code> functor after this write operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous
         events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>writeCallback</code> will not be invoked).</p>
<p>When invoked, <code>writeCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful for this method only when "status" is zero). A non-negative "status" indicates the number of bytes written from <code>buffer</code>. If "status" is positive, the atomic OS-level ("raw") write operation completed; "status" equals <code>numBytes</code> upon success. In either case, "augStatus" has no meaning. If "status" is zero, the atomic write operation did not complete, in which case "augStatus" is positive if an "asynchronous
         event" interrupted the operation, and negative if the operation was canceled. If the transmission was interrupted, the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> remains valid until the (non-null) <code>writeCallback</code> completes and <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a12b513082dc06b92b9db8d1aeb3784ba">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#a2d4bdc0158177ff02c8ed5a584d11a3f">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#a0122a4bfe5757a9fbc8fba77abe42031">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ace33a3f5d0ae273230d79898827dd21f"></a><!-- doxytag: member="btlsc::CbChannel::writevRaw" ref="ace33a3f5d0ae273230d79898827dd21f" args="(const btls::Iovec *buffers, int numBuffers, const WriteCallback &amp;writeCallback, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a9055edca375e2f69c0ba043e1765d7c8">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#ab0ec62a200ac9ea554cd198af64710d1">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#a0ccb99e407eb0982a4e939932b36a54c">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ae3d0fe91594c169bc3b0123d7124e758"></a><!-- doxytag: member="btlsc::CbChannel::writevRaw" ref="ae3d0fe91594c169bc3b0123d7124e758" args="(const btls::Ovec *buffers, int numBuffers, const WriteCallback &amp;writeCallback, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to <em>atomically</em> write <em>up</em> <em>to</em> the total number of bytes indicated by the specified sequence of <code>buffers</code> of the specified sequence length <code>numBuffers</code> the respective number of bytes as defined by the <code>length</code> method of each <code>Ovec</code> (or <code>Iovec</code>) structure; execute the specified <code>writeCallback</code> functor after this write operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>writeCallback</code> will not be invoked).</p>
<p>When invoked, <code>writeCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful for this method only when "status" is zero). A non-negative "status" indicates the total number of bytes written from <code>buffers</code>. If "status" is positive, the atomic ("raw") vector-write operation completed; "status" equals the requested number of bytes (i.e., the sum of the lengths of the <code>numBuffers</code> <code>buffers</code>) upon success. In either case, "augStatus" has no meaning. If "status" is zero, the atomic write operation did not complete, in which case "augStatus" is positive if an "asynchronous event" interrupted the operation, and negative if the operation was canceled. If the transmission is incomplete, the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless the total number of bytes to be written is <em>positive</em> and <code>buffers</code> (and the data to which it refers) remains valid until the (non-null) <code>writeCallback</code> completes. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#acec4c27697a8e74de7375330e7da25dc">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#af706da2510bbc10e4cf43ef050e73c92">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#ad90a4dbbde1f7ff193e094cc6a39796f">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a2e12ce40b22aabba8689d4325efea1b4"></a><!-- doxytag: member="btlsc::CbChannel::bufferedWrite" ref="a2e12ce40b22aabba8689d4325efea1b4" args="(const char *buffer, int numBytes, const WriteCallback &amp;writeCallback, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::bufferedWrite </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to write the specified <code>numBytes</code> from the specified <code>buffer</code> to this channel; execute the specified <code>writeCallback</code> functor after this write operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>writeCallback</code> will not be invoked). Note that the contents of <code>buffer</code> need not be preserved after this method returns (except for the purpose of initiating a retry in the event that this operation results in a partial write).</p>
<p>When invoked, <code>writeCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to <code>numBytes</code>, the operation was successful and all <code>numBytes</code> of data were transmitted to the channel. Otherwise, if "status" is non-negative (incomplete write), it indicates the number of bytes written from <code>buffer</code>, in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event and negative (with "status" identically 0) if this operation was canceled. If the transmission is incomplete, the remaining buffered data is discarded, but the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a223deed4d16145d04f823202e19d29c5">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#ad7cdab6c8de6acaef9e2181714fa3ad9">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#a7a91dd41ca9ac7e937a0b7b4997fb5db">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a2e102b37af56ff4502dde940d7ac46fd"></a><!-- doxytag: member="btlsc::CbChannel::bufferedWritev" ref="a2e102b37af56ff4502dde940d7ac46fd" args="(const btls::Iovec *buffers, int numBuffers, const WriteCallback &amp;writeCallback, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::bufferedWritev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a4385dc5bdf3c24db84647511d9543d67">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#acd6f0ffa6afe69e8c7abaed73486c4a9">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#ac81b4a31cf04a6426b837e158698f2d8">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a7c153666e294299a83bff84ffcc6dc08"></a><!-- doxytag: member="btlsc::CbChannel::bufferedWritev" ref="a7c153666e294299a83bff84ffcc6dc08" args="(const btls::Ovec *buffers, int numBuffers, const WriteCallback &amp;writeCallback, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::bufferedWritev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to write to this channel from the specified sequence of <code>buffers</code> of the specified sequence length <code>numBuffers</code> the respective number of bytes as defined by the <code>length</code> method of each <code>Ovec</code> (or <code>Iovec</code>) structure; execute the specified <code>writeCallback</code> functor after this write operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>writeCallback</code> will not be invoked). Note that neither <code>buffers</code> nor the data to which it refers need be preserved after this method returns (except for the purpose of initiating a retry in the event that this operation results in a partial write).</p>
<p>When invoked, <code>writeCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to the total number bytes to be written (i.e., the sum of calls to <code>length</code> on the <code>numBuffers</code> <code>buffers</code>), all indicated data was transmitted to the channel. Otherwise, if "status" is non-negative (incomplete write), it indicates the number of bytes written in sequence from the indicated buffers, in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event, and negative ("status" identically 0) if this operation was canceled. If the transmission is incomplete, the remaining buffered data is discarded, but the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless the total number of bytes to be written is <em>positive</em>. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a2c57f3ecfccce5df2d6dbc3649b4c8c4">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#aa498d10ad0ddab1d8a4282f918892cdb">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#adf2092948bf5aa09f93c1735ff8fb261">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a92c1e71d3d0378dcbe198018ab14a2ea"></a><!-- doxytag: member="btlsc::CbChannel::cancelAll" ref="a92c1e71d3d0378dcbe198018ab14a2ea" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlsc::CbChannel::cancelAll </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all enqueued operations from both the read queue and the write queue of this channel, and, in turn, invoke each callback with a 0 "status" and a negative "augStatus". Note that the validity of this channel is not altered by this operation. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a5652c0452212bcafe88c9c907c63b86b">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#a4e2c47f34a2231f79dfabcf96857718d">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#ac8c66eb74304ce991c3811d7fc03b615">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a98b8fbce01bfbf03f1d1b5b9c67c3eb9"></a><!-- doxytag: member="btlsc::CbChannel::cancelRead" ref="a98b8fbce01bfbf03f1d1b5b9c67c3eb9" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlsc::CbChannel::cancelRead </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all enqueued read operations from this channel, and, in turn, invoke each read callback with a 0 "status" and a negative "augStatus". Note that the validity of this channel is not altered by this operation. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#af41eed2fc66559489f6fe7c5ef5b24bb">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#a8c4b23b69ea5b9437d5b60df9a9abece">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#ac82c329f8224828c97898e1f2a13affa">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a1a6e0c4c40a1401ad43003c38f997a00"></a><!-- doxytag: member="btlsc::CbChannel::cancelWrite" ref="a1a6e0c4c40a1401ad43003c38f997a00" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlsc::CbChannel::cancelWrite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all enqueued write operations from this channel, and, in turn, invoke each write callback with a 0 "status" and a negative "augStatus". Note that the validity of this channel is not altered by this operation. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a79264d75172634db34eb22d38aa4f360">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#aa36e3388dd763bbfee8636f594d30c79">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#a0bbcb20bb2f617dc597322bbe504e0a3">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ad1d652169b74a4a7c8609547e242898a"></a><!-- doxytag: member="btlsc::CbChannel::invalidate" ref="ad1d652169b74a4a7c8609547e242898a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlsc::CbChannel::invalidate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make this channel invalid; no new operations can be initiated successfully. Pending operations are not affected. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a4864a8e61648ff1937000b69ee2c721b">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#ac131d05d998fa5e85fcbc3612031abb7">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#ab0571ee84ab8150fabd6fc0e6ec8e4cb">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a5e223877ed9b0eea354960757769b9eb"></a><!-- doxytag: member="btlsc::CbChannel::invalidateRead" ref="a5e223877ed9b0eea354960757769b9eb" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlsc::CbChannel::invalidateRead </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invalidate the read portion of this channel; no new read operations can be initiated successfully. Pending operations are not affected. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a499f8c5cd13158d13fef1e3d19ace089">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#a3778be0ebbdbd11bbe5ff6837c7a84c5">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#ad05229f8931313666a25448996a2d546">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a88e8f4b0da32d77b35de2c22e4720448"></a><!-- doxytag: member="btlsc::CbChannel::invalidateWrite" ref="a88e8f4b0da32d77b35de2c22e4720448" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlsc::CbChannel::invalidateWrite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invalidate the write portion of this channel; no new write operations can be initiated successfully. Pending operations are not affected. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a3487bc24a009b33eb76e84468827951d">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#acf8bf06f822acd4e62046309159a0270">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#a8a1235fe3bcdb3fb92f042a9262865e6">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a8d33bdf80527d19a95559d9834c63814"></a><!-- doxytag: member="btlsc::CbChannel::isInvalidRead" ref="a8d33bdf80527d19a95559d9834c63814" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::isInvalidRead </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if the read portion of this (full-duplex) channel is invalid (e.g., due to a read error or an explicit call to <code>invalidateRead</code>), and 0 otherwise. Once the read portion of a channel is invalid, no new read operations can be initiated successfully. Note that a 0 return value cannot be relied upon to indicate that the read portion of this channel <em>is</em> valid. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#aa2ec0ed55d1935bbb08b7d02d0df6bb2">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#a015ccf112db2eb3107e9c0704262cd3e">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#ae35bb78022aceb10843a31c7b242219d">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aa69b72f04f1d01ccad96923c61bb7a14"></a><!-- doxytag: member="btlsc::CbChannel::isInvalidWrite" ref="aa69b72f04f1d01ccad96923c61bb7a14" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::isInvalidWrite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if the write portion of this (full-duplex) channel is invalid (e.g., due to a write error or an explicit call to <code>invalidateWrite</code>), and 0 otherwise. Once the write portion of a channel is invalid, no new write operations can be initiated successfully. Note that a 0 return value cannot be relied upon to indicate that the write portion of this channel <em>is</em> valid. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#ac4f00d6d10f9b96decb221c455ca42f9">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#a1ceb2a6b4e064f3f0024500c13d16cde">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#a1f92429f8ba6fa6ea5861dc4e136918b">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ac13128f3bb11696dd22ad286efe9bd64"></a><!-- doxytag: member="btlsc::CbChannel::numPendingReadOperations" ref="ac13128f3bb11696dd22ad286efe9bd64" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::numPendingReadOperations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the total number of pending read operations for this channel. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a69c8bd173c687d362ce45c587f4c5055">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#ac93805eb683df565df916fbefd9b5201">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#a24cbbcd7ffd03c60342bd3cd05401a50">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ac653cbfea8a41ce9eaf71bd85f87acb7"></a><!-- doxytag: member="btlsc::CbChannel::numPendingWriteOperations" ref="ac653cbfea8a41ce9eaf71bd85f87acb7" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsc::CbChannel::numPendingWriteOperations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the total number of pending write operations for this channel. </p>

<p>Implemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a7257e2a9567be86f2e7b9758045ab2ed">btlsc::TimedCbChannel</a>, <a class="el" href="classbtlsos_1_1TcpCbChannel.html#a4abaa4191af9b6f2062712beb5ebe66a">btlsos::TcpCbChannel</a>, and <a class="el" href="classbtlsos_1_1TcpTimedCbChannel.html#a236610d35b7e6f2fd5c80b97330fc525">btlsos::TcpTimedCbChannel</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlsc__cbchannel_8h_source.html">btlsc_cbchannel.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:14 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
