<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslstl_equalto.h                                                   -*-C++-*-
#ifndef INCLUDED_BSLSTL_EQUALTO
#define INCLUDED_BSLSTL_EQUALTO

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a binary functor conforming to the C++11 &#39;equal_to&#39; spec.
//
//@CLASSES:
//  equal_to: C++11-compliant binary functor applying &#39;operator==&#39;
//
//@SEE_ALSO: bslstl_unorderedmap, bslstl_unorderedset
//
//@DESCRIPTION: This component provides the C+11 standard binary comparison
// functor, &#39;bsl::equal_to&#39;, that evaluates equality of two &#39;VALUE_TYPE&#39;
// objects through the &#39;operator==&#39;.  The application of the functor to two
// different objects &#39;o1&#39; and &#39;o2&#39; returns true if &#39;o1 == o2&#39;.  Note that this
// the for use as keys in the standard unordered associative containers such as
// &#39;bsl::unordered_map&#39; and &#39;bsl::unordered_set&#39;.  Also note that this class is
// an empty POD type.
//
///Usage
///-----
// This section illustrates intended usage of this component.
//
///Example 1: Creating and Using a List Set
/// - - - - - - - - - - - - - - - - - - - -
// Suppose we want to keep a set of a small number of elements, and the only
// comparison operation we have on the type of the elements is an equality
// operator.  We can keep a singly-linked list of the elements, and
// exhaustively use the comparison operator to see if a given value exists in
// the list, forming a primitive set.
//
// First, we define our &#39;ListSet&#39; template class:
//..
//  template &lt;typename TYPE, typename EQUALS = bsl::equal_to&lt;TYPE&gt; &gt;
//  class ListSet {
//      // This class implements a crude implementation of a set, that will
//      // keep a set of values and be able to determine if an element is a
//      // member of the set.  Unlike a &#39;bsl::set&#39; or &#39;bsl::unordered_set&#39;, no
//      // hash function or transitive &#39;operator&lt;&#39; is required -- only a
//      // transitive &#39;EQUALS&#39; operator.
//      //
//      // The &#39;TYPE&#39; template parameter must have a public copy constructor
//      // and destructor available.
//      //
//      // The &#39;EQUALS&#39; template parameter must a function with a function
//      // whose signature is
//      //..
//      //  bool operator()(const TYPE&amp; lhs, const TYPE&amp; rhs) const;
//      //..
//      // and which returns &#39;true&#39; if &#39;lhs&#39; and &#39;rhs&#39; are equivalent and
//      // &#39;false&#39; otherwise.  This equivalence relation must be transitive and
//      // symmetric.  The comparator must have a default constructor and
//      // destructor which are public.
//
//      // PRIVATE TYPES
//      struct Node {
//          TYPE  d_value;
//          Node *d_next;
//      };
//
//      // DATA
//      EQUALS            d_comparator;
//      Node             *d_nodeList;
//      bslma::Allocator *d_allocator_p;
//
//    private:
//      // NOT IMPLEMENTED
//      ListSet(const ListSet&amp;);
//      ListSet&amp; operator=(const ListSet&amp;);
//
//    public:
//      // CREATORS
//      explicit
//      ListSet(bslma::Allocator *allocator = 0)
//      : d_comparator()
//      , d_nodeList(0)
//      , d_allocator_p(bslma::Default::allocator(allocator))
//          // Create an empty &quot;ListSet&#39; using the specified &#39;allocator&#39;, or
//          // the default allocator if none is specified.
//      {}
//
//      ~ListSet()
//          // Release all memory used by this &#39;ListSet&#39;
//      {
//          for (Node *node = d_nodeList; node; ) {
//              Node *toDelete = node;
//              node = node-&gt;d_next;
//
//              d_allocator_p-&gt;deleteObject(toDelete);
//          }
//      }
//
//      // MANIPULATOR
//      bool insert(const TYPE&amp; value)
//          // If &#39;value&#39; isn&#39;t contained in this &#39;ListSet&#39;, add it and return
//          // &#39;true&#39;, otherwise, return &#39;false&#39; with no change to the
//          // &#39;ListSet&#39;.
//      {
//          if (count(value)) {
//              return false;                                         // RETURN
//          }
//
//          Node *node = (Node *) d_allocator_p-&gt;allocate(sizeof(Node));
//          bslalg::ScalarPrimitives::copyConstruct(&amp;node-&gt;d_value,
//                                                  value,
//                                                  d_allocator_p);
//          node-&gt;d_next = d_nodeList;
//          d_nodeList = node;
//
//          return true;
//      }
//
//      int count(const TYPE&amp; value) const
//          // Return the number of nodes whose &#39;d_value&#39; field is equivalent
//          // to the specified &#39;value&#39;, which will always be 0 or 1.
//      {
//          for (Node *node = d_nodeList; node; node = node-&gt;d_next) {
//              if (d_comparator(node-&gt;d_value, value)) {
//                  return 1;                                         // RETURN
//              }
//          }
//
//          return 0;
//      }
//  };
//..
// Then, in &#39;main&#39;, we declare an instance of &#39;ListSet&#39; storing &#39;int&#39;s.  The
// default definition of &#39;bsl::equal_to&#39; will work nicely:
//..
//  ListSet&lt;int&gt; lsi;
//..
// Now, we insert several values into our &#39;ListSet&#39;.  Note that successful
// insertions return &#39;true&#39; while redundant ones return &#39;false&#39; with no effect:
//..
//  assert(true  == lsi.insert( 5));
//  assert(false == lsi.insert( 5));
//  assert(false == lsi.insert( 5));
//  assert(true  == lsi.insert(11));
//  assert(true  == lsi.insert(17));
//  assert(true  == lsi.insert(81));
//  assert(true  == lsi.insert(32));
//  assert(false == lsi.insert(17));
//..
// Finally, we observe that our &#39;count&#39; method successfully distinguishes
// between values that have been stored in our &#39;ListSet&#39; and those that
// haven&#39;t:
//..
//  assert(0 == lsi.count( 7));
//  assert(1 == lsi.count( 5));
//  assert(0 == lsi.count(13));
//  assert(1 == lsi.count(11));
//  assert(0 == lsi.count(33));
//  assert(1 == lsi.count(32));
//..
///Example 2: Using Our List Set For a Custom Type
///- - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we want to have a list set containing objects of a custom type.  We
// can specialize the &#39;equal_to&#39; comparator to also work on our custom type
// as well.  We will re-use the &#39;ListSet&#39; template class from example 1, and
// create a new custom type.
//
// First, we define a type &#39;StringThing&#39;, which will contain a &#39;const char *&#39;
// pointer, it will be a very simple type, that is implicitly castable to or
// from a &#39;const char *&#39;.  It has no &#39;operator==&#39; defined, so &#39;equal_to&#39; will
// need to be explicitly specialized for it:
//..
//  class StringThing {
//      // This class holds a pointer to zero-terminated string.  It is
//      // implicitly convertible to and from a &#39;const char *&#39;.  The difference
//      // between this type and a &#39;const char *&#39; is that &#39;operator==&#39; will
//      // properly compare two objects of this type for equality of strings
//      // rather than equality of pointers.
//
//      // DATA
//      const char *d_string;    // held, not owned
//
//    public:
//      // CREATOR
//      StringThing(const char *string)                             // IMPLICIT
//      : d_string(string)
//          // Create a &#39;StringThing&#39; object out of the specified &#39;string&#39;.
//      {}
//
//      // ACCESSOR
//      operator const char *() const
//          // Implicitly cast this &#39;StringThing&#39; object to a &#39;const char *&#39;
//          // that refers to the same buffer.
//      {
//          return d_string;
//      }
//  };
//..
// Then, we specialize &#39;equal_to&#39; to be able to compare two &#39;StringThing&#39;s.
//..
//  namespace bsl {
//
//  template &lt;&gt;
//  struct equal_to&lt;StringThing&gt; {
//      bool operator()(const StringThing&amp; lhs,
//                      const StringThing&amp; rhs) const
//      {
//          return !strcmp(lhs, rhs);
//      }
//  };
//
//  }  // close namespace bsl
//..
// Next, in &#39;main&#39;, we declare a &#39;ListSet&#39; containing &#39;StringThing&#39;s:
//..
//  ListSet&lt;StringThing&gt; lsst;
//..
// Then, we insert a number of values, and observe that redundant inserts
// return &#39;false&#39; with no effect:
//..
//  assert(true  == lsst.insert(&quot;woof&quot;));
//  assert(true  == lsst.insert(&quot;meow&quot;));
//  assert(true  == lsst.insert(&quot;arf&quot;));
//  assert(false == lsst.insert(&quot;woof&quot;));
//  assert(true  == lsst.insert(&quot;bark&quot;));
//  assert(false == lsst.insert(&quot;meow&quot;));
//  assert(false == lsst.insert(&quot;woof&quot;));
//..
// Now, we observe that our &#39;count&#39; method successfully distinguishes between
// values that have been stored in &#39;lsst&#39; and those that haven&#39;t:
//..
//  assert(1 == lsst.count(&quot;meow&quot;));
//  assert(0 == lsst.count(&quot;woo&quot;));
//  assert(1 == lsst.count(&quot;woof&quot;));
//  assert(1 == lsst.count(&quot;arf&quot;));
//  assert(0 == lsst.count(&quot;chomp&quot;));
//..
// Finally, we copy values into a buffer and observe that this makes no
// difference to &#39;count&#39;s results:
//..
//  char buffer[10];
//  strcpy(buffer, &quot;meow&quot;);
//  assert(1 == lsst.count(buffer));
//  strcpy(buffer, &quot;bite&quot;);
//  assert(0 == lsst.count(buffer));
//..

// Prevent &#39;bslstl&#39; headers from being included directly in &#39;BSL_OVERRIDES_STD&#39;
// mode.  Doing so is unsupported, and is likely to cause compilation errors.
#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
#error &quot;&lt;bslstl_equalto.h&gt; header can&#39;t be included directly in \
BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYCOPYABLE
#include &lt;bslmf_istriviallycopyable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYDEFAULTCONSTRUCTIBLE
#include &lt;bslmf_istriviallydefaultconstructible.h&gt;
#endif

namespace bsl
{

                       // ===============
                       // struct equal_to
                       // ===============

template&lt;class VALUE_TYPE&gt;
struct equal_to {
    // This &#39;struct&#39; defines a binary comparison functor applying &#39;operator==&#39;
    // to two &#39;VALUE_TYPE&#39; objects.  This class conforms to the C++11 standard
    // specification of &#39;std::equal_to&#39; that does not require inheriting from
    // &#39;std::binary_function&#39;.  Note that this class is an empty POD type.

    // PUBLIC TYPES -- STANDARD TYPEDEFS
    typedef VALUE_TYPE first_argument_type;
    typedef VALUE_TYPE second_argument_type;
    typedef bool       result_type;

    //! equal_to() = default;
        // Create a &#39;equal_to&#39; object.

    //! equal_to(const equal_to&amp; original) = default;
        // Create a &#39;equal_to&#39; object.  Note that as
        // &#39;equal_to&#39; is an empty (stateless) type, this operation
        // will have no observable effect.

    //! ~equal_to() = default;
        // Destroy this object.

    // MANIPULATORS
    //! equal_to&amp; operator=(const equal_to&amp;) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // a return a reference providing modifiable access to this object.
        // Note that as &#39;equal_to&#39; is an empty (stateless) type,
        // this operation will have no observable effect.

    // ACCESSORS
    bool operator()(const VALUE_TYPE&amp; lhs, const VALUE_TYPE&amp; rhs) const;
        // Return &#39;true&#39; if the specified &#39;lhs&#39; compares equal to the specified
        // &#39;rhs&#39; using the equality-comparison operator, &#39;lhs == rhs&#39;.
};

}  // close namespace bsl

namespace bsl {

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                       // --------------------
                       // struct bsl::equal_to
                       // --------------------

// ACCESSORS
template&lt;class VALUE_TYPE&gt;
inline
bool equal_to&lt;VALUE_TYPE&gt;::operator()(const VALUE_TYPE&amp; lhs,
                                      const VALUE_TYPE&amp; rhs) const
{
    return lhs == rhs;
}

}  // close namespace bsl

// ============================================================================
//                                TYPE TRAITS
// ============================================================================

// Type traits for &#39;equal_to&#39;
//: o &#39;equal_to&#39; is a stateless POD, trivially constructible, copyable, and
//:   moveable.

namespace bsl {

template&lt;class VALUE_TYPE&gt;
struct is_trivially_default_constructible&lt;equal_to&lt;VALUE_TYPE&gt; &gt;
: bsl::true_type
{};

template&lt;class VALUE_TYPE&gt;
struct is_trivially_copyable&lt;equal_to&lt;VALUE_TYPE&gt; &gt;
: bsl::true_type
{};

}  // close namespace bsl

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
