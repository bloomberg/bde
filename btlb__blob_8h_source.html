<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// btlb_blob.h                                                        -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BTLB_BLOB
#define INCLUDED_BTLB_BLOB

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an indexed set of buffers from multiple sources.
//
//@CLASSES:
//        btlb::BlobBuffer: in-core representation of a shared buffer
// btlb::BlobBufferFactory: factory of blob buffers
//              btlb::Blob: indexed sequence of buffers
//
//@SEE_ALSO: bcema_sharedptr, btlb_pooledblobbufferfactory
//
//@DESCRIPTION: This component provides an indexed sequence (&#39;btlb::Blob&#39;) of
// &#39;btlb::BlobBuffer&#39; objects allocated from potentially multiple
// &#39;btlb::BlobBufferFactory&#39; objects.  A &#39;btlb::BlobBuffer&#39; is a simple in-core
// value object owning a shared pointer to a memory buffer.  Therefore, the
// lifetime of the underlying memory is determined by shared ownership between
// the blob buffer, the blob(s) that may contain it, and any other entities
// that may share ownership of the memory buffer.
//
// Logically, a &#39;btlb::Blob&#39; can be thought of as a sequence of bytes (although
// not contiguous).  Each buffer in a blob contributes its own size to the
// blob, with the total size of a blob being the sum of sizes over all its
// buffers.  A prefix of these bytes, collectively referred to as the data of
// the blob, are defined by the data length, which can be set by the user using
// the &#39;setLength&#39; method.  Note that the data length never exceeds the total
// size.  When setting the length to a value greater than the total size, the
// latter is increased automatically by adding buffers created from a factory
// passed at construction; the behavior is undefined if no factory was supplied
// at construction.
//
// The blob also updates its data length during certain operations (e.g.,
// insertion/removal of buffers containing some data bytes), as well as several
// attributes driven by the data length.  The first bytes numbered by the data
// length belong to the data buffers.  Note that all data buffers, except
// perhaps the last, contribute all their bytes to the &#39;btlb::Blob&#39; data.  The
// last data buffer contributes anywhere between one and all of its bytes to
// the &#39;btlb::Blob&#39; data.  The number of data buffers (returned by the
// &#39;numDataBuffers&#39; method), as well as the last data buffer length (returned
// by &#39;lastDataBufferLength&#39;), are maintained by &#39;btlb::Blob&#39; automatically
// when setting the length to a new value.
//
// Buffers which do not contain data are referred to as capacity buffers.  The
// total size of a blob does not decrease when setting the length to a value
// smaller than the current length.  Instead, any data buffer that no longer
// contains data after the call to &#39;setLength&#39; becomes a capacity buffer, and
// may become a data buffer again later if setting length past its prefix size.
//
// This design is intended to allow very efficient re-assignment of buffers (or
// part of buffers using shared pointer aliasing) between different blobs,
// without copying of the underlying data, while promoting efficient allocation
// of resources (via retaining capacity).  Thus, &#39;btlb::Blob&#39; is an
// advantageous replacement for &#39;btlb::PooledBufferChain&#39; when manipulation of
// the sequence, sharing of portions of the sequence, and lifetime management
// of individual portions of the sequence, are desired.  Another added
// flexibility of &#39;btlb::Blob&#39; is the possibility for buffers in the sequence
// to have different sizes (as opposed to a uniform fixed size for
// &#39;btlb::PooledBufferChain&#39;).  When choosing whether to use a &#39;btlb::Blob&#39; vs.
// a &#39;btlb::PooledBufferChain&#39;, one must consider the added flexibility versus
// the added cost of shared ownership for each individual buffer and random
// access to the buffer.
//
///Thread Safety
///-------------
// Different instances of the classes defined in this component can be
// concurrently modified by different threads.  Thread safety of a particular
// instance is not guaranteed, and therefore must be handled by the user.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: A Simple Blob Buffer Factory
///- - - - - - - - - - - - - - - - - - - -
// Classes that implement the &#39;btlb::BlobBufferFactory&#39; protocol are used to
// allocate &#39;btlb::BlobBuffer&#39; objects.  A simple implementation follows:
//..
//  class SimpleBlobBufferFactory : public btlb::BlobBufferFactory {
//      // This factory creates blob buffers of a fixed size specified at
//      // construction.
//
//      // DATA
//      bsl::size_t       d_bufferSize;
//      bslma::Allocator *d_allocator_p;
//
//    private:
//      // Not implemented:
//      SimpleBlobBufferFactory(const SimpleBlobBufferFactory&amp;);
//      SimpleBlobBufferFactory&amp; operator=(const SimpleBlobBufferFactory&amp;);
//
//    public:
//      // CREATORS
//      explicit SimpleBlobBufferFactory(int               bufferSize = 1024,
//                                       bslma::Allocator *basicAllocator = 0);
//      ~SimpleBlobBufferFactory();
//
//      // MANIPULATORS
//      void allocate(btlb::BlobBuffer *buffer);
//  };
//
//  SimpleBlobBufferFactory::SimpleBlobBufferFactory(
//                                            int               bufferSize,
//                                            bslma::Allocator *basicAllocator)
//  : d_bufferSize(bufferSize)
//  , d_allocator_p(bslma::Default::allocator(basicAllocator))
//  {
//  }
//
//  SimpleBlobBufferFactory::~SimpleBlobBufferFactory()
//  {
//  }
//
//  void SimpleBlobBufferFactory::allocate(btlb::BlobBuffer *buffer)
//  {
//      bsl::shared_ptr&lt;char&gt; shptr(
//                              (char *) d_allocator_p-&gt;allocate(d_bufferSize),
//                              d_allocator_p);
//
//      buffer-&gt;reset(shptr, d_bufferSize);
//  }
//..
// Note that should the user desire a blob buffer factory for his/her
// application, a better implementation that pools buffers is available in the
// &#39;btlb_pooledblobbufferfactory&#39; component.
//
///Simple Blob Usage
///- - - - - - - - -
// Blobs can be created just by passing a factory that is responsible to
// allocate the &#39;btlb::BlobBuffer&#39;.  The following simple program illustrates
// how.
//..
//  {
//      SimpleBlobBufferFactory myFactory(1024);
//
//      btlb::Blob blob(&amp;myFactory);
//      assert(0    == blob.length());
//      assert(0    == blob.totalSize());
//
//      blob.setLength(512);
//      assert( 512 == blob.length());
//      assert(1024 == blob.totalSize());
//..
// Users need to access buffers directly in order to read/write data.
//..
//      char data[] = &quot;12345678901234567890&quot;; // 20 bytes
//      assert(0 != blob.numBuffers());
//      assert(static_cast&lt;int&gt;(sizeof(data)) &lt;= blob.buffer(0).size());
//      bsl::memcpy(blob.buffer(0).data(), data, sizeof(data));
//
//      blob.setLength(sizeof(data));
//      assert(sizeof data == blob.length());
//      assert(       1024 == blob.totalSize());
//..
// A &#39;btlb::BlobBuffer&#39; can easily be re-assigned from one blob to another with
// no copy.  In that case, the memory held by the buffer will be returned to
// its factory when the last blob referencing the buffer is destroyed.  For the
// following example, a blob will be created using the default constructor.  In
// this case, the &#39;btlb::Blob&#39; object will not able to grow on its own.
// Calling &#39;setLength&#39; for a number equal or greater than &#39;totalSize()&#39; will
// result in undefined behavior.
//..
//      btlb::Blob dest;
//      assert(   0 == dest.length());
//      assert(   0 == dest.totalSize());
//
//      assert(0 != blob.numBuffers());
//      dest.appendBuffer(blob.buffer(0));
//      assert(   0 == dest.length());
//      assert(1024 == dest.totalSize());
//..
// Note that at this point, the logical length (returned by &#39;length&#39;) of this
// object has not changed.  &#39;setLength&#39; must be called explicitly by the user
// if the logical length of the &#39;btlb::Blob&#39; must be changed:
//..
//      dest.setLength(dest.buffer(0).size());
//      assert(1024 == dest.length());
//      assert(1024 == dest.totalSize());
//..
// Sharing only a part of a buffer is also possible through shared pointer
// aliasing.  In the following example, a buffer that contains only bytes 11-16
// from the first buffer of &#39;blob&#39; will be appended to &#39;blob&#39;.
//..
//      assert(0 != blob.numBuffers());
//      assert(16 &lt;= blob.buffer(0).size());
//
//      bsl::shared_ptr&lt;char&gt; shptr(blob.buffer(0).buffer(),
//                                  blob.buffer(0).data() + 10);
//          // &#39;shptr&#39; is now an alias of &#39;blob.buffer(0).buffer()&#39;.
//
//      btlb::BlobBuffer partialBuffer(shptr, 6);
//      dest.appendBuffer(partialBuffer);
//          // The last buffer of &#39;dest&#39; contains only bytes 11-16 from
//          // &#39;blob.buffer(0)&#39;.
//  }
//..
//
///Example 2: Data-Oriented Manipulation of a Blob
///- - - - - - - - - - - - - - - - - - - - - - - -
// There are several typical ways of manipulating a blob: the simplest lets the
// blob automatically manage the length, by using only &#39;prependBuffer&#39;,
// &#39;appendBuffer&#39;, and &#39;insertBuffer&#39;.  Consider the following typical
// utilities (these utilities are to illustrate usage, they are not meant to be
// copy-pasted into application programs although they can provide a foundation
// for application utilities):
//..
//  void prependProlog(btlb::Blob         *blob,
//                     const bsl::string&amp;  prolog,
//                     bslma::Allocator   *allocator = 0);
//      // Prepend the specified &#39;prolog&#39; to the specified &#39;blob&#39;, using the
//      // optionally specified &#39;allocator&#39; to supply any memory (or the
//      // currently installed default allocator if &#39;allocator&#39; is 0).  The
//      // behavior is undefined unless &#39;blob&#39; points to an initialized
//      // &#39;btlb::Blob&#39; instance.
//
//  template &lt;class DELETER&gt;
//  void composeMessage(btlb::Blob         *blob,
//                      const bsl::string&amp;  prolog,
//                      char * const       *vectors,
//                      const int          *vectorSizes,
//                      int                 numVectors,
//                      const DELETER&amp;      deleter,
//                      bslma::Allocator   *allocator = 0);
//      // Load into the specified &#39;blob&#39; the data composed of the specified
//      // &#39;prolog&#39; and of the payload in the &#39;numVectors&#39; buffers pointed to
//      // by the specified &#39;vectors&#39; of the respective &#39;vectorSizes&#39;.
//      // Ownership of the vectors is transferred to the &#39;blob&#39; which will use
//      // the specified &#39;deleter&#39; to destroy them.  Use the optionally
//      // specified &#39;allocator&#39; to supply memory, or the currently installed
//      // default allocator if &#39;allocator&#39; is 0.  Note that any buffer
//      // belonging to &#39;blob&#39; prior to composing the message is not longer in
//      // &#39;blob&#39; after composing the message.  Note also that &#39;blob&#39; need not
//      // have been created with a blob buffer factory.  The behavior is
//      // undefined unless &#39;blob&#39; points to an initialized &#39;btlb::Blob&#39;
//      // instance.
//
//  int timestampMessage(btlb::Blob *blob, bslma::Allocator *allocator = 0);
//      // Insert a timestamp data buffer immediately after the prolog buffer
//      // and prior to any payload buffer.  Return the number of bytes
//      // inserted.  Use the optionally specified &#39;allocator&#39; to supply
//      // memory, or the currently installed default allocator if &#39;allocator&#39;
//      // is 0.  The behavior is undefined unless the specified &#39;blob&#39; points
//      // to an initialized &#39;btlb::Blob&#39; instance with at least one data
//      // buffer.
//..
// A possible implementation using only &#39;prependBuffer&#39;, &#39;appendBuffer&#39;, and
// &#39;insertBuffer&#39; could be as follows:
//..
//  void prependProlog(btlb::Blob         *blob,
//                     const bsl::string&amp;  prolog,
//                     bslma::Allocator   *allocator)
//  {
//      BSLS_ASSERT(blob);
//
//      (void)allocator;
//
//      int prologLength = prolog.length();
//      SimpleBlobBufferFactory fa(prologLength + sizeof(int));
//      btlb::BlobBuffer prologBuffer;
//      fa.allocate(&amp;prologBuffer);
//
//      bslx::MarshallingUtil::putInt32(prologBuffer.data(), prologLength);
//      bsl::memcpy(prologBuffer.data() + sizeof(int),
//                  prolog.c_str(),
//                  prologLength);
//      BSLS_ASSERT(prologBuffer.size() == prologLength + sizeof(int));
//
//      blob-&gt;prependDataBuffer(prologBuffer);
//  }
//..
// Note that the length of &#39;blob&#39; in the above implementation is automatically
// incremented by &#39;prologBuffer.size()&#39;.  Consider instead:
//..
//      blob-&gt;insertBuffer(0, prologBuffer);
//..
// which inserts the prologBuffer before the first buffer of &#39;blob&#39;.  This call
// will almost always adjust the length properly *except* if the length of
// &#39;blob&#39; is 0 before the insertion (i.e., the message has an empty payload).
// In that case, the resulting &#39;blob&#39; will still be empty after
// &#39;prependProlog&#39;, which, depending on the intention of the programmer, could
// be intended (avoid sending empty messages) or could be (most likely) a
// mistake.
//
// The &#39;composeMessage&#39; implementation is simplified by using &#39;prependProlog&#39;:
//..
//  template &lt;class DELETER&gt;
//  void composeMessage(btlb::Blob         *blob,
//                      const bsl::string&amp;  prolog,
//                      char * const       *vectors,
//                      const int          *vectorSizes,
//                      int                 numVectors,
//                      const DELETER&amp;      deleter,
//                      bslma::Allocator   *allocator)
//  {
//      BSLS_ASSERT(blob);
//      BSLS_ASSERT(vectors);
//      BSLS_ASSERT(0 &lt;= numVectors);
//
//      blob-&gt;removeAll();
//      prependProlog(blob, prolog, allocator);
//
//      for (int i = 0; i &lt; numVectors; ++i) {
//          bsl::shared_ptr&lt;char&gt; shptr(vectors[i], deleter, allocator);
//          btlb::BlobBuffer partialBuffer(shptr, vectorSizes[i]);
//          blob-&gt;appendDataBuffer(partialBuffer);
//              // The last buffer of &#39;dest&#39; contains only bytes 11-16 from
//              // &#39;blob.buffer(0)&#39;.
//      }
//  }
//..
// Note that the &#39;deleter&#39; is used to destroy the buffers transferred by
// &#39;vectors&#39;, but not the prolog buffer.
//
// Timestamping a message is done by creating a buffer holding a timestamp, and
// inserting it after the prolog and before the payload of the message.  Note
// that in typical messages, timestamps would be part of the prolog itself, so
// this is a somewhat contrived example for exposition only.
//..
//  int timestampMessage(btlb::Blob *blob, bslma::Allocator *allocator)
//  {
//      BSLS_ASSERT(blob);
//      BSLS_ASSERT(0 &lt; blob-&gt;numDataBuffers());
//
//      btlb::BlobBuffer buffer;
//      bdlt::Datetime now = bdlt::CurrentTime::utc();
//
//      SimpleBlobBufferFactory fa(128, allocator);
//      btlb::BlobBuffer timestampBuffer;
//      fa.allocate(&amp;timestampBuffer);
//
//      bslx::ByteOutStream bdexStream(20150826);
//      now.bdexStreamOut(bdexStream, 1);
//      BSLS_ASSERT(bdexStream);
//      BSLS_ASSERT(bdexStream.length() &lt; 128);
//      bsl::memcpy(timestampBuffer.data(),
//                  bdexStream.data(),
//                  bdexStream.length());
//      timestampBuffer.setSize(bdexStream.length());
//..
// Now that we have fabricated the buffer holding the current data and time, we
// must insert it into the blob after the first buffer (i.e., before the buffer
// at index 1).  Note however that the payload could be empty, a condition
// tested by the fact that there is only one data buffer in &#39;blob&#39;.  In that
// case, it would be a mistake to use &#39;insertBuffer&#39; since it would not modify
// the length of the blob.
//..
//      if (1 &lt; blob-&gt;numDataBuffers()) {
//          blob-&gt;insertBuffer(1, timestampBuffer);
//      } else {
//          blob-&gt;appendDataBuffer(timestampBuffer);
//      }
//
//      return bdexStream.length();
//  }
//..
// Note that the call to &#39;appendDataBuffer&#39; also takes care of the possibility
// that the first buffer of &#39;blob&#39; may not be full to capacity (if the length
// of the blob was smaller than the buffer size, only the first
// &#39;blob-&gt;length()&#39; bytes would contain prolog data).  In that case, that
// buffer is trimmed before appending the &#39;timestampBuffer&#39; so that the first
// byte of the &#39;timestampBuffer&#39; appears immediately next to the last prolog
// byte, and the blob length is automatically incremented by the size of the
// &#39;timestampBuffer&#39;.

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITBITWISEMOVEABLE
#include &lt;bslalg_typetraitbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include &lt;bslalg_typetraits.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSL_MEMORY
#include &lt;bsl_memory.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {
namespace btlb {

                             // ================
                             // class BlobBuffer
                             // ================

class BlobBuffer {
    // &#39;BlobBuffer&#39; is a simple in-core representation of a shared buffer.
    // This class is exception-neutral with no guarantee of rollback: if an
    // exception is thrown during the invocation of a method on a pre-existing
    // instance, the container is left in a valid state, but its value is
    // undefined.  In no event is memory leaked.

    // DATA
    bsl::shared_ptr&lt;char&gt; d_buffer;  // shared buffer
    int                   d_size;    // buffer size (in bytes)

    // FRIENDS
    friend bool operator==(const BlobBuffer&amp;, const BlobBuffer&amp;);

    friend bool operator!=(const BlobBuffer&amp;, const BlobBuffer&amp;);

  public:
    // CREATORS
    BlobBuffer();
        // Create a blob buffer representing a null buffer.  Note that the
        // &#39;size&#39; and &#39;data&#39; methods of a default-constructed blob buffer both
        // return 0.

    BlobBuffer(const bsl::shared_ptr&lt;char&gt;&amp; buffer, int size);
        // Create a blob buffer representing the specified &#39;buffer&#39; of the
        // specified &#39;size&#39;.  Undefined unless &#39;0 &lt;= size&#39;.

    BlobBuffer(const BlobBuffer&amp; original);
        // Create a blob buffer having the same value as the specified
        // &#39;original&#39; blob buffer.

    ~BlobBuffer();
        // Destroy this blob buffer.

    // MANIPULATORS
    BlobBuffer&amp; operator=(const BlobBuffer&amp; rhs);
        // Assign to this blob buffer the value of the specified &#39;rhs&#39; blob
        // buffer, and return a reference to this modifiable blob buffer.

    void reset();
        // Reset this blob buffer to its default-constructed state.

    void reset(const bsl::shared_ptr&lt;char&gt;&amp; buffer, int size);
        // Set the buffer represented by this object to the specified &#39;buffer&#39;
        // of the specified &#39;size&#39;.  Undefined unless &#39;0 &lt;= size&#39;.

    bsl::shared_ptr&lt;char&gt;&amp; buffer();
        // Return a reference to the shared pointer to the modifiable buffer
        // represented by this object.

    void setSize(int size);
        // Set the size of this blob buffer to the specified &#39;size&#39;.  The
        // behavior is undefined unless &#39;0 &lt;= size&#39; and the capacity of the
        // buffer returned by the &#39;buffer&#39; method is at least &#39;size&#39; bytes.

    // ACCESSORS
    const bsl::shared_ptr&lt;char&gt;&amp; buffer() const;
        // Return a reference to the non-modifiable shared pointer to the
        // buffer represented by this object.

    char *data() const;
        // Return the address of the modifiable buffer represented by this
        // object.

    int size() const;
        // Return the size of the buffer represented by this object.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object as a hexadecimal dump on the specified &#39;stream&#39;,
        // and return a reference to the modifiable &#39;stream&#39;.  Note that the
        // optionally specified &#39;level&#39; and &#39;spacesPerLevel&#39; arguments are
        // specified for interface compatibility only and are effectively
        // ignored.
};
}  // close package namespace

// TYPE TRAITS

namespace bslmf {

template &lt;&gt;
struct IsBitwiseMoveable&lt;BloombergLP::btlb::BlobBuffer&gt;
    : IsBitwiseMoveable&lt;bsl::shared_ptr&lt;char&gt; &gt;::type
{};

}  // close namespace bslmf

namespace btlb {

// FREE OPERATORS
bool operator==(const BlobBuffer&amp; lhs, const BlobBuffer&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; blob buffers have the
    // same value, and &#39;false&#39; otherwise.  Two blob buffers have the same value
    // if they represent the same buffer of the same size.

bool operator!=(const BlobBuffer&amp; lhs, const BlobBuffer&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; blob buffers do not have
    // the same value, and &#39;false&#39; otherwise.  Two blob buffers do not have the
    // same value if they do not represent the same buffer of the same size.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const BlobBuffer&amp; buffer);
    // Format the specified blob &#39;buffer&#39; to the specified output &#39;stream&#39;, and
    // return a reference to the modifiable &#39;stream&#39;.

                         // =======================
                         // class BlobBufferFactory
                         // =======================

class BlobBufferFactory {
    // This class defines a base-level protocol for a &#39;BlobBuffer&#39; factory.

  public:
    // CREATORS
    virtual ~BlobBufferFactory();
        // Destroy this blob buffer factory.

    // MANIPULATORS
    virtual void allocate(BlobBuffer *buffer) = 0;
        // Allocate a blob buffer from this blob buffer factory, and load it
        // into the specified &#39;buffer&#39;.
};

                                // ==========
                                // class Blob
                                // ==========

class Blob {
    // &#39;Blob&#39; is an in-core container for &#39;BlobBuffer&#39; objects.  This class is
    // exception-neutral with no guarantee of rollback: if an exception is
    // thrown during the invocation of a method on a pre-existing instance, the
    // container is left in a valid state, but its value is undefined.  In no
    // event is memory leaked.

    // DATA
    bsl::vector&lt;BlobBuffer&gt;  d_buffers;             // buffer sequence

    int                            d_totalSize;           // capacity of blob
                                                          // (in bytes)

    int                            d_dataLength;          // length (in bytes)
                                                          // of user-managed
                                                          // data

    int                            d_dataIndex;           // index of the last
                                                          // data buffer

    int                            d_preDataIndexLength;  // sum of the lengths
                                                          // of all data
                                                          // buffers, excluding
                                                          // the last one

    BlobBufferFactory       *d_bufferFactory_p;     // factory used to
                                                          // grow blob (held)

    // FRIENDS
    friend bool operator==(const Blob&amp;, const Blob&amp;);
    friend bool operator!=(const Blob&amp;, const Blob&amp;);

  private:
    // PRIVATE MANIPULATORS
    void slowSetLength(int length);
        // &quot;Slow&quot; setLength.

    // PRIVATE ACCESSORS
    int assertInvariants() const;
        // Assert the invariants of this object and return 0 on success.

  public:
    // CREATORS
    explicit Blob(bslma::Allocator *basicAllocator = 0);
        // Create an empty blob having no factory to allocate blob buffers.
        // Since there is no factory, the behavior is undefined if the length
        // of the blob is set beyond the total size.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    explicit Blob(BlobBufferFactory *factory,
                  bslma::Allocator  *basicAllocator = 0);
        // Create an empty blob using the specified &#39;factory&#39; to allocate blob
        // buffers.  Optionally specify a &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.

    Blob(const BlobBuffer  *buffers,
         int                numBuffers,
         BlobBufferFactory *factory,
         bslma::Allocator  *basicAllocator = 0);
        // Create a blob that initially holds the specified &#39;numBuffers&#39;
        // buffers referenced by the specified &#39;buffers&#39;, and uses the
        // specified &#39;factory&#39; to allocate blob buffers.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    Blob(const Blob&amp;        original,
         BlobBufferFactory *factory,
         bslma::Allocator  *basicAllocator = 0);
        // Create a blob that holds the same buffers as the specified
        // &#39;original&#39; blob, and uses the specified &#39;factory&#39; to allocate blob
        // buffers.  Optionally specify a &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.

    Blob(const Blob&amp; original, bslma::Allocator *basicAllocator = 0);
        // Create a blob that holds the same buffers as the specified
        // &#39;original&#39; blob, and has no factory to allocate blob buffers.  Since
        // there is no factory, the behavior is undefined if the length of the
        // blob is set beyond the total size.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    ~Blob();
        // Destroy this blob.

    // MANIPULATORS
    Blob&amp; operator=(const Blob&amp; rhs);
        // Assign to this blob the value of the specified &#39;rhs&#39; blob, and
        // return a reference to this modifiable blob.

    void appendBuffer(const BlobBuffer&amp; buffer);
        // Append the specified &#39;buffer&#39; after the last buffer of this blob.
        // The length of this blob is unaffected.  Note that this operation is
        // equivalent to &#39;insert(numBuffers(), buffer)&#39;, but is more efficient.

    void appendDataBuffer(const BlobBuffer&amp; buffer);
        // Append the specified &#39;buffer&#39; after the last *data* buffer of this
        // blob; the last data buffer is trimmed, if necessary.  The length of
        // this blob is incremented by the size of &#39;buffer&#39;.  The behavior is
        // undefined unless &#39;0 &lt; buffer.size()&#39;.  Note that this operation is
        // equivalent to:
        //..
        //  const int n = blob.length();
        //  blob.trimLastDataBuffer();
        //  blob.insert(numDataBuffers(), buffer);
        //  blob.setLength(n + buffer.size());
        //..
        // but is more efficient.

    void insertBuffer(int index, const BlobBuffer&amp; buffer);
        // Insert the specified &#39;buffer&#39; at the specified &#39;index&#39; in this blob.
        // Increment the length of this blob by the size of &#39;buffer&#39; if
        // &#39;buffer&#39; is inserted *before* the logical end of this blob.  The
        // length of this blob is _unchanged_ if inserting at a position
        // following all data buffers (e.g., inserting into an empty blob or
        // inserting a buffer to increase capacity); in that case, the blob
        // length must be changed by an explicit call to &#39;setLength&#39;.  Buffers
        // at &#39;index&#39; and higher positions (if any) are shifted up by one index
        // position.  The behavior is undefined unless
        // &#39;0 &lt;= index &lt;= numBuffers()&#39;.

    void prependDataBuffer(const BlobBuffer&amp; buffer);
        // Insert the specified &#39;buffer&#39; before the beginning of this blob.
        // The length of this blob is incremented by the length of the
        // prepended buffer.  The behavior is undefined unless
        // &#39;0 &lt; buffer.size()&#39;.  Note that this operation is equivalent to:
        //..
        //  const int n = blob.length();
        //  blob.insert(0, buffer);
        //  blob.setLength(n + buffer.size());
        //..
        // but is more efficient.

    void removeAll();
        // Remove all blob buffers from this blob, and set its length to 0.

    void removeBuffer(int index);
        // Remove the buffer at the specified &#39;index&#39; from this blob, and
        // decrement the length of this blob by the size of &#39;buffer&#39; if the
        // buffer at &#39;index&#39; contains data bytes (i.e., if the first byte of
        // &#39;buffer&#39; occurs before the logical end of this blob).  Buffers at
        // positions higher than &#39;index&#39; (if any) are shifted down by one index
        // position.  The behavior is undefined unless
        // &#39;0 &lt;= index &lt; numBuffers()&#39;.

    void reserveBufferCapacity(int numBuffers);
        // Allocate sufficient capacity to store at least the specified
        // &#39;numBuffers&#39; buffers.  The behavior is undefined unless
        // &#39;0 &lt;= numBuffers&#39;.  Note that this method does not change the length
        // of this blob or add any buffers to it.

    void setLength(int length);
        // Set the length of this blob to the specified &#39;length&#39; and, if
        // &#39;length&#39; is greater than its total size, grow this blob by appending
        // buffers allocated using this object&#39;s underlying
        // &#39;BlobBufferFactory&#39;.  The behavior is undefined if &#39;length&#39; is a
        // negative value, or if the new length requires growing the blob and
        // this blob has no underlying factory.

    void swapBufferRaw(int index, BlobBuffer *srcBuffer);
        // Swap the blob buffer at the specified &#39;index&#39; with the specified
        // &#39;srcBuffer&#39;.  The behavior is undefined unless
        // &#39;0 &lt;= index &lt; numBuffers()&#39; and
        // &#39;srcBuffer-&gt;size() == buffer(index).size()&#39;.  Note that other than
        // the buffer swap the state of this object remains unchanged.

    void trimLastDataBuffer();
        // Set the size of the last data buffer to &#39;lastDataBufferLength()&#39;.
        // If there are no data buffers, or if the last data buffer is full
        // (i.e., its size is &#39;lastDataBufferLength()&#39;), then this method has
        // no effect.  Note that the length of the blob is unchanged, and that
        // capacity buffers (i.e., of indices &#39;numDataBuffers()&#39; and higher)
        // are *not* removed.

    void moveBuffers(Blob *srcBlob);
        // Remove all blob buffers from this blob and move the buffers held by
        // the specified &#39;srcBlob&#39; to this blob.  Note that this method is
        // logically equivalent to:
        //..
        //  *this = *srcBlob;
        //  srcBlob-&gt;removeAll();
        //..
        // but its implementation is more efficient.

    void moveDataBuffers(Blob *srcBlob);
        // Remove all blob buffers from this blob and move the data buffers
        // held by the specified &#39;srcBlob&#39; to this blob.

    void moveAndAppendDataBuffers(Blob *srcBlob);
        // Move the data buffers held by the specified &#39;srcBlob&#39; to this blob
        // appending them to the current data buffers of this blob.

    // ACCESSORS
    const BlobBuffer&amp; buffer(int index) const;
        // Return a reference to the non-modifiable blob buffer at the
        // specified &#39;index&#39; in this blob.  The behavior is undefined unless
        // &#39;0 &lt;= index &lt; numBuffers()&#39;.

    int lastDataBufferLength() const;
        // Return the length of the last blob buffer in this blob, or 0 if this
        // blob is of 0 length.

    int length() const;
        // Return the length of this blob.

    int numDataBuffers() const;
        // Return the number of blob buffers containing data in this blob.

    int numBuffers() const;
        // Return the number of blob buffers held by this blob.

    int totalSize() const;
        // Return the sum of the sizes of all blob buffers in this blob (i.e.,
        // the capacity of this blob).
};
}  // close package namespace

// TYPE TRAITS

namespace bslmf {

template &lt;&gt;
struct IsBitwiseMoveable&lt;BloombergLP::btlb::Blob&gt;
    : IsBitwiseMoveable&lt;bsl::vector&lt;BloombergLP::btlb::BlobBuffer&gt; &gt;::type
{};
}  // close namespace bslmf

namespace bslma {

template &lt;&gt;
struct UsesBslmaAllocator&lt;BloombergLP::btlb::Blob&gt; : bsl::true_type
{};
}  // close namespace bslma

namespace btlb {

// FREE OPERATORS
bool operator==(const Blob&amp; lhs, const Blob&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; blobs have the same
    // value, and &#39;false&#39; otherwise.  Two blobs have the same value if they
    // hold the same buffers, and have the same length.

bool operator!=(const Blob&amp; lhs, const Blob&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; blobs do not have the
    // same value, and &#39;false&#39; otherwise.  Two blobs do not have the same value
    // if they do not hold the same buffers, or do not have the same length.

// ============================================================================
//                             INLINE DEFINITIONS
// ============================================================================

                             // ================
                             // class BlobBuffer
                             // ================

// CREATORS
inline
BlobBuffer::BlobBuffer()
: d_size(0)
{
}

inline
BlobBuffer::BlobBuffer(const bsl::shared_ptr&lt;char&gt;&amp; buffer,
                       int                          size)
: d_buffer(buffer)
, d_size(size)
{
    BSLS_ASSERT(0 &lt;= size);
}

inline
BlobBuffer::BlobBuffer(const BlobBuffer&amp; original)
: d_buffer(original.d_buffer)
, d_size(original.d_size)
{
}

inline
BlobBuffer::~BlobBuffer()
{
}

// MANIPULATORS
inline
bsl::shared_ptr&lt;char&gt;&amp; BlobBuffer::buffer()
{
    return d_buffer;
}

inline
void BlobBuffer::setSize(int size)
{
    BSLS_ASSERT_SAFE(0 &lt;= size);

    d_size = size;
}

// ACCESSORS
inline
const bsl::shared_ptr&lt;char&gt;&amp; BlobBuffer::buffer() const
{
    return d_buffer;
}

inline
char *BlobBuffer::data() const
{
    return d_buffer.get();
}

inline
int BlobBuffer::size() const
{
    return d_size;
}
}  // close package namespace

// FREE OPERATORS
inline
bool btlb::operator==(const BlobBuffer&amp; lhs, const BlobBuffer&amp; rhs)
{
    return lhs.d_buffer.get() == rhs.d_buffer.get()
        &amp;&amp; lhs.d_size         == rhs.d_size;
}

inline
bool btlb::operator!=(const BlobBuffer&amp; lhs, const BlobBuffer&amp; rhs)
{
    return lhs.d_buffer.get() != rhs.d_buffer.get()
        || lhs.d_size         != rhs.d_size;
}

namespace btlb {

                                // ==========
                                // class Blob
                                // ==========

// MANIPULATORS
inline
void Blob::reserveBufferCapacity(int numBuffers)
{
    BSLS_ASSERT_SAFE(0 &lt;= numBuffers);

    d_buffers.reserve(numBuffers);
}

// ACCESSORS
inline
const BlobBuffer&amp; Blob::buffer(int index) const
{
    BSLS_ASSERT_SAFE(0 &lt;= index);
    BSLS_ASSERT_SAFE(     index &lt; static_cast&lt;int&gt;(d_buffers.size()));

    return d_buffers[index];
}

inline
int Blob::lastDataBufferLength() const
{
    return d_dataLength - d_preDataIndexLength;
}

inline
int Blob::length() const
{
    return d_dataLength;
}

inline
int Blob::numBuffers() const
{
    return static_cast&lt;int&gt;(d_buffers.size());
}

inline
int Blob::numDataBuffers() const
{
    return d_dataLength != 0 ? d_dataIndex + 1 : 0;
}

inline
int Blob::totalSize() const
{
    return d_totalSize;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
