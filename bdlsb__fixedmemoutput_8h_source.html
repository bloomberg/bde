<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlsb_fixedmemoutput.h                                             -*-C++-*-
#ifndef INCLUDED_BDLSB_FIXEDMEMOUTPUT
#define INCLUDED_BDLSB_FIXEDMEMOUTPUT

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a basic output stream buffer using a client buffer.
//
//@CLASSES:
//  bdlsb::FixedMemOutput: basic output stream buffer using client memory
//
//@SEE_ALSO: bdlsb_fixedmemoutstreambuf
//
//@DESCRIPTION: This component implements the output portion of the
// &#39;bsl::basic_streambuf&#39; protocol using a client-supplied memory buffer.
// Method names correspond to the protocol-specified method names.  Clients
// supply the character buffer at stream buffer construction, and can later
// reinitialize the stream buffer with a different character buffer by calling
// the &#39;pubsetbuf&#39; method.  The only difference between this component and
// &#39;bdlsb_fixedmemoutstreambuf&#39; is that the class &#39;bdlsb::FixedMemOutput&#39; does
// *not* derive from a &#39;bsl::streambuf&#39; and does not support locales.  This is
// advantageous for performance reasons, as the overhead of the initialization
// and virtual function calls of a &#39;bsl::streambuf&#39; can be undesirable.  The
// &#39;bdlsb::FixedMemOutput&#39; is designed to be used by generic template code that
// must be instantiated on a type that matches the interface of
// &#39;bsl::streambuf&#39;, but does not require an actual &#39;bsl::streambuf&#39;, in
// particular &#39;bslx_genericoutstream&#39;.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Basic Use of &#39;bdlsb::FixedMemOutput&#39;
///- - - - - - - - - - - - - - - - - - - - - - - -
// This example demonstrates instantiating a template, bslx::GenericOutStream&#39;,
// on a &#39;bdlsb::FixedMemOutput&#39; object and using the &#39;bslx::GenericOutStream&#39;
// object to stream out some data.
//
// First, we create an object of our stream buffer:
//..
//  enum { k_STREAMBUF_CAPACITY = 30 };
//
//  char                  buffer[k_STREAMBUF_CAPACITY];
//  bdlsb::FixedMemOutput streamBuf(buffer, k_STREAMBUF_CAPACITY);
//..
// Then, we create an instance of &#39;bslx::GenericOutStream&#39; using &#39;streamBuf&#39;,
// with an arbitrary value for its &#39;versionSelector&#39;, and externalize some
// values:
//..
//  bslx::GenericOutStream&lt;bdlsb::FixedMemOutput&gt; outStream(&amp;streamBuf,
//                                                          20150707);
//  outStream.putInt32(1);
//  outStream.putInt32(2);
//  outStream.putInt8(&#39;c&#39;);
//  outStream.putString(bsl::string(&quot;hello&quot;));
//..
// Finally, we compare the contents of the buffer to the expected value:
//..
//  assert(15 == streamBuf.length());
//  assert( 0 == bsl::memcmp(streamBuf.data(),
//                           &quot;\x00\x00\x00\x01\x00\x00\x00\x02&quot;&quot;c\x05&quot;&quot;hello&quot;,
//                           15));
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_ALGORITHM
#include &lt;bsl_algorithm.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDLIB
#include &lt;bsl_cstdlib.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTRING
#include &lt;bsl_cstring.h&gt;
#endif

#ifndef INCLUDED_BSL_IOS
#include &lt;bsl_ios.h&gt;  // &#39;bsl::streamsize&#39;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSL_LOCALE
#include &lt;bsl_locale.h&gt;
#endif

#ifndef INCLUDED_BSL_STREAMBUF
#include &lt;bsl_streambuf.h&gt;
#endif

namespace BloombergLP {
namespace bdlsb {

                              // ==============
                              // FixedMemOutput
                              // ==============

class FixedMemOutput {
    // This class, like &#39;bdlsb::FixedMemOutStreamBuf&#39;, implements the output
    // functionality of the &#39;basic_streambuf&#39; interface, using client-supplied
    // &#39;char *&#39; memory.  It has an identical interface to
    // &#39;bdlsb::FixedMemOutStreamBuf&#39; but does *not* inherit from
    // &#39;bsl::streambuf&#39;.  Thus, it is suitable for use as template parameter to
    // &#39;bslx::GenericOutStream&#39; (but not to &#39;bslx::StreambufOutStream&#39;).  Note
    // that this class is not designed to be derived from.

  public:
    // TYPES
    typedef char                             char_type;
    typedef bsl::char_traits&lt;char&gt;::int_type int_type;
    typedef bsl::char_traits&lt;char&gt;::pos_type pos_type;
    typedef bsl::char_traits&lt;char&gt;::off_type off_type;
    typedef bsl::char_traits&lt;char&gt;           traits_type;

  private:
    // PRIVATE TYPE
    typedef bsls::Types::IntPtr              IntPtr;

    // PRIVATE DATA MEMBERS
    char            *d_buffer_p;  // output buffer
    bsl::streamsize  d_capacity;  // length of output buffer
    pos_type         d_pos;       // output cursor

    // NOT IMPLEMENTED
    FixedMemOutput(const FixedMemOutput&amp;);
    FixedMemOutput&amp; operator=(const FixedMemOutput&amp;);

  public:
    // CREATORS
    FixedMemOutput(char *buffer, bsl::streamsize length);
        // Create an empty stream buffer that uses the specified character
        // &#39;buffer&#39; of the specified &#39;length&#39;.  The behavior is undefined
        // unless &#39;length == 0&#39; or &#39;length &gt; 0 &amp;&amp; buffer != 0&#39;.
        // Note that &#39;buffer&#39; is held but not owned.

    //! ~FixedMemOutput();
        // Destroy this stream buffer.  Note that this method&#39;s definition is
        // compiler generated.

    // MANIPULATORS
    char *data();
        // Return a pointer providing modifiable access to the character buffer
        // held by this stream buffer (supplied at construction).

                             // *** 27.5.2.2.1 locales: ***

    bsl::locale pubimbue(const bsl::locale&amp; loc);
        // Associate the specified locale &#39;loc&#39; to this stream buffer.
        // Operation has no effect, because locales are not supported by this
        // component.  Return default constructed bsl::locale object.

                             // *** 27.5.2.2.2 buffer and positioning: ***

    FixedMemOutput *pubsetbuf(char            *buffer,
                              bsl::streamsize  length);
        // Reset the internal buffer of this stream to the specified &#39;buffer&#39;
        // of the specified &#39;length&#39;.  Note that the next write operation will
        // start at the beginning of &#39;buffer&#39;.

    pos_type pubseekoff(off_type                offset,
                        bsl::ios_base::seekdir  fixedPosition,
                        bsl::ios_base::openmode which =
                            bsl::ios_base::in | bsl::ios_base::out);
        // Set the position indicator to the relative specified &#39;offset&#39; from
        // the base position indicated by the specified &#39;fixedPosition&#39; and
        // return the resulting absolute position on success or pos_type(-1)
        // on failure.  Optionally specify &#39;which&#39; area of the stream buffer.
        // The seek operation will fail if &#39;which&#39; does not include the flag
        // &#39;bsl::ios_base::out&#39; or if the resulting absolute position is less
        // than zero or greater than the value returned by &#39;length&#39;.

    pos_type pubseekpos(pos_type                position,
                        bsl::ios_base::openmode which =
                            bsl::ios_base::in | bsl::ios_base::out);
        // Set the position indicator to the specified &#39;position&#39; and return
        // the resulting absolute position on success or pos_type(-1) on
        // failure.  Optionally specify &#39;which&#39; area of the stream buffer.  The
        // &#39;seekpos&#39; operation will fail if &#39;which&#39; does not include the flag
        // &#39;bsl::ios_base::out&#39; or if position is less then zero or greater
        // than the value returned by &#39;length&#39;.

    int pubsync();
        // Synchronizes the controlled character sequence (the buffers) with
        // the associated character sequence.  Operation has no effect, because
        // the stream is always kept in sync (no buffered output).  Return 0.

                             // *** 27.5.2.2.5 Put area: ***

    int_type sputc(char c);
        // Write the specified character &#39;c&#39; to this buffer.  Return &#39;c&#39;, or
        // &#39;traits_type::eof()&#39; if the end of the write buffer is reached.

    bsl::streamsize sputn(const char *s, bsl::streamsize length);
        // Write the specified &#39;length&#39; characters at the specified address &#39;s&#39;
        // to this buffer.  Return the number of characters written, which is
        // either &#39;length&#39; or the distance from the current write position to
        // the end of the write buffer, whichever is smaller, and move the
        // write cursor position by this amount.

    // ACCESSORS
    bsl::streamsize capacity() const;
        // Return the size in bytes of the buffer held by this stream buffer.

    const char *data() const;
        // Return a pointer providing non-modifiable access to the character
        // buffer held by this stream buffer (supplied at construction).

    bsl::streamsize length() const;
        // Return the number of characters from the beginning of the buffer to
        // the current write position.

                             // *** 27.5.2.2.1 locales: ***

    bsl::locale getloc() const;
        // Return the current default locale.  Operation has no effect, because
        // locales are not supported by this component.  Return default
        // constructed bsl::locale object.

};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                              // --------------
                              // FixedMemOutput
                              // --------------

// CREATORS
inline
FixedMemOutput::FixedMemOutput(char            *buffer,
                               bsl::streamsize  length)
: d_buffer_p(buffer)
, d_capacity(length)
, d_pos(0)
{
    BSLS_ASSERT_SAFE(buffer || 0 == length);
    BSLS_ASSERT_SAFE(0 &lt;= length);
}

// MANIPULATORS
inline
char *FixedMemOutput::data()
{
    return d_buffer_p;
}

inline
bsl::locale FixedMemOutput::pubimbue(const bsl::locale&amp;)
{
    return bsl::locale();
}

inline
FixedMemOutput *FixedMemOutput::pubsetbuf(char            *buffer,
                                          bsl::streamsize  length)
{
    BSLS_ASSERT_SAFE(buffer || 0 == length);
    BSLS_ASSERT_SAFE(0 &lt;= length);

    d_buffer_p = buffer;
    d_capacity = length;
    d_pos      = 0;

    return this;
}

inline
int FixedMemOutput::pubsync()
{
    // Nothing to do, the buffer is always up to date.
    return 0;
}

inline
FixedMemOutput::int_type FixedMemOutput::sputc(char c)
{
    if (d_pos &gt;= d_capacity) {
        return traits_type::eof();                                    // RETURN
    }
    d_buffer_p[static_cast&lt;IntPtr&gt;(d_pos)] = c;
    d_pos += 1;
    return traits_type::to_int_type(c);
}

inline
bsl::streamsize FixedMemOutput::sputn(const char      *s,
                                      bsl::streamsize  length)
{
    BSLS_ASSERT_SAFE(s);
    BSLS_ASSERT_SAFE(0 &lt;= length);

    pos_type current = d_pos;
    d_pos += length;
    if (d_pos &gt; d_capacity) {
        d_pos  = d_capacity;
        length = static_cast&lt;bsl::streamsize&gt;(d_capacity - current);
    }
    bsl::memcpy(d_buffer_p + static_cast&lt;IntPtr&gt;(current), s, length);
    return length;
}

// ACCESSORS
inline
bsl::streamsize FixedMemOutput::capacity() const
{
    return d_capacity;
}

inline
const char *FixedMemOutput::data() const
{
    return d_buffer_p;
}

inline
bsl::locale FixedMemOutput::getloc() const
{
    return bsl::locale();
}

inline
bsl::streamsize FixedMemOutput::length() const
{
    return bsl::streamsize(d_pos);
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
