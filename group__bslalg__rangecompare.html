<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslalg_rangecompare Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslalg_rangecompare<br/>
<small>
[<a class="el" href="group__bslalg.html">Package bslalg</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide algorithms to compare iterator-ranges of elements.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslalg.html">bslalg</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Defining Equality Comparison Operators on a Container</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide algorithms to compare iterator-ranges of elements. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbslalg_1_1RangeCompare.html">bslalg::RangeCompare</a> </td><td>comparison algorithms for iterator ranges  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslmf__isbitwiseequalitycomparable.html" title="Provide a type trait for bitwise equality.">Component bslmf_isbitwiseequalitycomparable</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a utility <code>struct</code>, <code><a class="el" href="structbslalg_1_1RangeCompare.html">bslalg::RangeCompare</a></code>, that defines two overloaded class methods, <code>equal</code> and <code>lexicographical</code>, for comparing two ranges, each specified by a pair of input iterators that are compliant with the C++11 standard [24.2.3]. The <code>equal</code> method determines whether two specified ranges compare equal. The <code>lexicographical</code> method determines whether the first range compares lexicographically less than, equal to, or greater than the second range. Under certain circumstances, <code><a class="el" href="structbslalg_1_1RangeCompare.html#a7512bb3d99340d59d531bb7d0a5b4ae0">bslalg::RangeCompare::equal</a></code> and <code><a class="el" href="structbslalg_1_1RangeCompare.html#a5101bca5996296c274b770c755d5a879">bslalg::RangeCompare::lexicographical</a></code> may perform optimized comparisons, as described below. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="structbslalg_1_1RangeCompare.html#a7512bb3d99340d59d531bb7d0a5b4ae0">bslalg::RangeCompare::equal</a></code> may perform a bit-wise comparison of the two ranges when the following two criteria are met: <ul>
<li>
The input iterators are convertible to a pointer type.  </li>
<li>
The trait <code><a class="el" href="structbslmf_1_1IsBitwiseEqualityComparable.html">bslmf::IsBitwiseEqualityComparable</a></code> is declared for the type of the objects in the ranges being compared.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="structbslalg_1_1RangeCompare.html#a5101bca5996296c274b770c755d5a879">bslalg::RangeCompare::lexicographical</a></code> may perform a bit-wise comparison of the two ranges when the following criterion is met: <ul>
<li>
The input iterators are convertible to pointers to a wide or unsigned  </li>
</ul>
character type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that a class having the <code><a class="el" href="structbslmf_1_1IsBitwiseEqualityComparable.html">bslmf::IsBitwiseEqualityComparable</a></code> trait can be described as bit-wise comparable and should meet the following criteria: <ul>
<li>
The values represented by two objects belonging to the class are the same if and only if each of the data members in the class has the same value in both objects.  </li>
<li>
The class layout includes no padding.  </li>
<li>
The class has no virtual members.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that this component is for use primarily by the <code>bslstl</code> package. Other clients should use the STL algorithms (in headers <code>&lt;bsl_algorithm.h&gt;</code> and <code>&lt;bsl_memory.h&gt;</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Defining Equality Comparison Operators on a Container: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example we will use the <code><a class="el" href="structbslalg_1_1RangeCompare.html#a7512bb3d99340d59d531bb7d0a5b4ae0">bslalg::RangeCompare::equal</a></code> class method to implement the equality comparison operators for an iterable container type residing in the <code>bslstl</code> package, and highlight the circumstances under which the optimization provided by the class method may be applied. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose that we have a new iterable container type that will be included in the <code>bslstl</code> package, and we wish to define comparison operators for the container. If the container has an iterator that provides access to the container's elements in a consistent order, and the elements themselves are equality-comparable, we can implement the container's equality comparison operators by pair-wise comparing each of the elements over the entire range of elements in both containers. In such cases the container can use the <code><a class="el" href="structbslalg_1_1RangeCompare.html#a7512bb3d99340d59d531bb7d0a5b4ae0">bslalg::RangeCompare::equal</a></code> class method to equal-compare the container's elements, taking advantage of the optimizations the class method provides for bit-wise equality-comparable objects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create an elided definition of a container class, <code>MyContainer</code>, which provides read-only iterators of the type <code>MyContainer::ConstIterator</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> VALUE_TYPE&gt;
  <span class="keyword">class </span>MyContainer {
      <span class="comment">// This class implements a container, semantically similar to</span>
      <span class="comment">// &#39;std::vector&#39;, holding objects of the (template parameter) type</span>
      <span class="comment">// &#39;VALUE_TYPE&#39;.</span>

    <span class="keyword">private</span>:
      <span class="comment">// DATA</span>
      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// PUBLIC TYPES</span>
      <span class="keyword">typedef</span> <span class="keyword">const</span> VALUE_TYPE *ConstIterator;
          <span class="comment">// This &#39;typedef&#39; provides an alias for the type of iterator</span>
          <span class="comment">// providing non-modifiable access to the elements in the</span>
          <span class="comment">// container.</span>

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> MyContainer(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an empty &#39;MyContainer&#39; object having no capacity.</span>
          <span class="comment">// Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If</span>
          <span class="comment">// &#39;basicAllocator&#39; is 0, the currently installed default allocator</span>
          <span class="comment">// is used.</span>

      <span class="comment">// ...</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="comment">// ...</span>

      <span class="keywordtype">void</span> push_back(<span class="keyword">const</span> VALUE_TYPE&amp; value);
          <span class="comment">// Append the specified &#39;value&#39; at the past-the-end position in</span>
          <span class="comment">// this container, increasing the container&#39;s capacity if needed.</span>

      <span class="comment">// ...</span>

      <span class="comment">// ACCESSORS</span>
      ConstIterator begin() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the first</span>
          <span class="comment">// element in this container.</span>

      ConstIterator end() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the</span>
          <span class="comment">// past-the-end element in this container.</span>

      std::size_t size() <span class="keyword">const</span>;
          <span class="comment">// Return the number of elements in this container.</span>

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Notice that <code>ConstIterator</code> is defined as a pointer type, which is one of the criteria required to enable the optimizations provided by the <code><a class="el" href="structbslalg_1_1RangeCompare.html#a7512bb3d99340d59d531bb7d0a5b4ae0">bslalg::RangeCompare::equal</a></code> class method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we declare the equality comparison operators for <code>MyContainer</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> VALUE_TYPE&gt;
  <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#aed5308d4f7d1542d6eeb8acedec974d3">operator==</a>(<span class="keyword">const</span> MyContainer&lt;VALUE_TYPE&gt;&amp; lhs,
                  <span class="keyword">const</span> MyContainer&lt;VALUE_TYPE&gt;&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same</span>
      <span class="comment">// value, and &#39;false&#39; otherwise.  Two &#39;MyContainer&#39; objects have the</span>
      <span class="comment">// same value if they have the same length, and each element in &#39;lhs&#39;</span>
      <span class="comment">// has the same value as the corresponding element in &#39;rhs&#39;.</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> VALUE_TYPE&gt;
  <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#acf8107f12ec28380f11b968856544276">operator!=</a>(<span class="keyword">const</span> MyContainer&lt;VALUE_TYPE&gt;&amp; lhs,
                  <span class="keyword">const</span> MyContainer&lt;VALUE_TYPE&gt;&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  Two &#39;MyContainer&#39; objects do</span>
      <span class="comment">// not have the same value if they do not have the same length, or if</span>
      <span class="comment">// any element in &#39;lhs&#39; does not have the same value as the</span>
      <span class="comment">// corresponding element in &#39;rhs&#39;.</span>
</pre></div><br/>
<br/>
 Next, we implement the equality comparison operators using <code><a class="el" href="structbslalg_1_1RangeCompare.html#a7512bb3d99340d59d531bb7d0a5b4ae0">bslalg::RangeCompare::equal</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> VALUE_TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#aed5308d4f7d1542d6eeb8acedec974d3">operator==</a>(<span class="keyword">const</span> MyContainer&lt;VALUE_TYPE&gt;&amp; lhs,
                  <span class="keyword">const</span> MyContainer&lt;VALUE_TYPE&gt;&amp; rhs)
  {
      <span class="keywordflow">return</span> BloombergLP::bslalg::RangeCompare::equal(lhs.begin(),
                                                      lhs.end(),
                                                      lhs.size(),
                                                      rhs.begin(),
                                                      rhs.end(),
                                                      rhs.size());
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> VALUE_TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#acf8107f12ec28380f11b968856544276">operator!=</a>(<span class="keyword">const</span> MyContainer&lt;VALUE_TYPE&gt;&amp; lhs,
                  <span class="keyword">const</span> MyContainer&lt;VALUE_TYPE&gt;&amp; rhs)
  {
      <span class="keywordflow">return</span> !BloombergLP::bslalg::RangeCompare::equal(lhs.begin(),
                                                       lhs.end(),
                                                       lhs.size(),
                                                       rhs.begin(),
                                                       rhs.end(),
                                                       rhs.size());
  }
</pre></div><br/>
<br/>
 Then, we create the elided definition of a value-semantic class, <code>MyString</code>, together with its definition of <code>operator==</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyString {
      <span class="comment">// This class provides a simple, elided string class that conforms to</span>
      <span class="comment">// the &#39;bslma::Allocator&#39; model.</span>

    <span class="keyword">private</span>:
      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span>             *d_start_p;      <span class="comment">// storage for the string</span>
      std::size_t       d_length;       <span class="comment">// length of the string</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;  <span class="comment">// memory allocator (held, not owned)</span>

      <span class="comment">// ...</span>

      <span class="comment">// FRIENDS</span>
      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#aed5308d4f7d1542d6eeb8acedec974d3">operator==</a>(<span class="keyword">const</span> MyString&amp;, <span class="keyword">const</span> MyString&amp;);
      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> MyString(<span class="keyword">const</span> <span class="keywordtype">char</span>       *<span class="keywordtype">string</span>,
                        <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;MyString&#39; object initialized to the value of the</span>
          <span class="comment">// specified &#39;string&#39;.  Optionally specify a &#39;basicAllocator&#39; used</span>
          <span class="comment">// to supply memory.  If &#39;basicAllocator&#39; is 0, the currently</span>
          <span class="comment">// installed default allocator is used.</span>

      <span class="comment">// ...</span>
  };

  <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#aed5308d4f7d1542d6eeb8acedec974d3">operator==</a>(<span class="keyword">const</span> MyString&amp; lhs, <span class="keyword">const</span> MyString&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.d_length == rhs.d_length
          &amp;&amp; 0 == std::strncmp(lhs.d_start_p, rhs.d_start_p, lhs.d_length);
  }
</pre></div><br/>
<br/>
 Notice that <code>MyString</code> is not bit-wise comparable because the address values of the <code>d_start_p</code> pointer data members in two <code>MyString</code> objects will be different, even if the string values of the two objects are the same. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we create two <code>MyContainer&lt;MyString&gt;</code> objects, and compare them using <code>operator==</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyContainer&lt;MyString&gt; c1;
  MyContainer&lt;MyString&gt; c2;

  c1.push_back(MyString(<span class="stringliteral">&quot;hello&quot;</span>));
  c1.push_back(MyString(<span class="stringliteral">&quot;goodbye&quot;</span>));

  c2.push_back(MyString(<span class="stringliteral">&quot;hello&quot;</span>));
  c2.push_back(MyString(<span class="stringliteral">&quot;goodbye&quot;</span>));

  assert(c1 == c2);
</pre></div><br/>
<br/>
 Here, the call to the <code><a class="el" href="structbslalg_1_1RangeCompare.html#a7512bb3d99340d59d531bb7d0a5b4ae0">bslalg::RangeCompare::equal</a></code> class method in <code>operator==</code> will perform an unoptimized pair-wise comparison of the elements in <code>c1</code> and <code>c2</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we create the elided definition of another value-semantic class, <code>MyPoint</code>, together with its definition of <code>operator==</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyPoint {
      <span class="comment">// This class provides a simple, elided point type that is bit-wise</span>
      <span class="comment">// comparable with other objects of the same type.</span>

    <span class="keyword">private</span>:
      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span> d_x;  <span class="comment">// the x-coordinate of the point</span>
      <span class="keywordtype">int</span> d_y;  <span class="comment">// the y-coordinate of the point</span>

      <span class="comment">// FRIENDS</span>
      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#aed5308d4f7d1542d6eeb8acedec974d3">operator==</a>(<span class="keyword">const</span> MyPoint&amp;, <span class="keyword">const</span> MyPoint&amp;);
      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// TRAITS</span>
      <a class="code" href="group__bslalg__typetraits.html#gab7a247c93e0d83c005ceb01cc291937b">BSLALG_DECLARE_NESTED_TRAITS</a>(MyPoint,
                    BloombergLP::bslalg::TypeTraitBitwiseEqualityComparable);

      <span class="comment">// CREATORS</span>
      MyPoint(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y);
          <span class="comment">// Create a &#39;MyPoint&#39; object whose x- and y-coordinates have the</span>
          <span class="comment">// specified &#39;x&#39; and &#39;y&#39; values, respectively.</span>

      <span class="comment">// ...</span>
  };

  <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#aed5308d4f7d1542d6eeb8acedec974d3">operator==</a>(<span class="keyword">const</span> MyPoint&amp; lhs, <span class="keyword">const</span> MyPoint&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.d_x == rhs.d_x &amp;&amp; lhs.d_y == rhs.d_y;
  }
</pre></div><br/>
<br/>
 Notice that the value of a <code>MyPoint</code> object derives from the values of all of its data members, and that no padding is required for alignment. Furthermore, <code>MyPoint</code> has no virtual methods. Therefore, <code>MyPoint</code> objects are bit-wise comparable, and we can correctly declare the <code><a class="el" href="structbslalg_1_1TypeTraitBitwiseEqualityComparable.html">bslalg::TypeTraitBitwiseEqualityComparable</a></code> trait for the class, as shown above under the public <code>TRAITS</code> section. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Now, we create two <code>MyContainer&lt;MyPoint&gt;</code> objects and compare them using <code>operator==</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyContainer&lt;MyPoint&gt; c3;
  MyContainer&lt;MyPoint&gt; c4;

  c3.push_back(MyPoint(1, 2));
  c3.push_back(MyPoint(3, 4));

  c4.push_back(MyPoint(1, 2));
  c4.push_back(MyPoint(3, 4));

  assert(c3 == c4);  <span class="comment">// potentially optimized</span>
</pre></div><br/>
<br/>
 Here, the call to <code><a class="el" href="structbslalg_1_1RangeCompare.html#a7512bb3d99340d59d531bb7d0a5b4ae0">bslalg::RangeCompare::equal</a></code> in <code>operator==</code> may take advantage of the fact that <code>MyPoint</code> is bit-wise comparable and perform the comparison by directly bit-wise comparing the entire range of elements contained in the <code>MyContainer&lt;MyPoint&gt;</code> objects. This comparison can provide a significant performance boost over the comparison between two <code>MyContainer&lt;MyPoint&gt;</code> objects in which the nested <code>TypeTraitBitwiseEqualityComparable</code> trait is not associated with the <code>MyPoint</code> class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, note that we can instantiate <code>MyContainer</code> with <code>int</code> or any other primitive type as the <code>VALUE_TYPE</code> and still benefit from the optimized comparison operators, because primitive (i.e.: fundamental, enumerated, and pointer) types are inherently bit-wise comparable: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyContainer&lt;int&gt; c5;
  MyContainer&lt;int&gt; c6;

  c5.push_back(1);
  c5.push_back(2);
  c5.push_back(3);

  c6.push_back(1);
  c6.push_back(2);
  c6.push_back(3);

  assert(c5 == c6);  <span class="comment">// potentially optimized</span>
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:41 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
