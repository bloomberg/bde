<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslstl_stringref Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_stringref<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a reference to a <code>const</code> string.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslstl.html">bslstl</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Efficiency and Usage Considerations</a> </li>
<li>
<a href="#3.2">Caveats</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Basic Operations</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a reference to a <code>const</code> string. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRefImp</a> </td><td>reference wrapper for a generic string  </td></tr>
<tr>
<td><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a> </td><td>reference wrapper for a <code>char</code> string  </td></tr>
<tr>
<td><a class="el" href="namespacebslstl.html#adb41ff59615d4ad2799e48a19ed5c1b1">bslstl::StringRefWide</a> </td><td>reference wrapper for a <code>wchar_t</code> string  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines two classes, <code>bsls::StringRef</code> and <code>bsls::StringRefWide</code>, each providing a reference to a non-modifiable string value having an external representation. The type of characters in the string value can be either <code>char</code> (for <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>) or <code>wchar_t</code> (for <code><a class="el" href="namespacebslstl.html#adb41ff59615d4ad2799e48a19ed5c1b1">bslstl::StringRefWide</a></code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The invariant of <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> is that it always has a valid non-modifiable <code>std::string</code> value, where non-empty string values have an external representation. Empty string values do not need to have an external representation. Most operations on <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> objects have reference semantics and apply to the string value: e.g., <code>operator==</code> compares string values, not whether <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> objects reference the same string object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The only operations that do not apply to the string value (i.e., that have pointer semantics) are copy construction and assignment. These operations produce a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> object with the same external representation as the original <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> object, which is a stronger post-condition than having <code>operator==</code> return <code>true</code> for two <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> objects that have the same value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The standard notion of substitutability defined by the <code>operator==</code> does not necessarily apply to <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> since <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> is not a value-semantic type (because of the external representation). Therefore there can be a plausible sequence of operations applied to two "equal" <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> objects that result in objects that don't compare equal. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The string value that is represented by a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> object need not be null-terminated. Moreover, the string may contain embedded null characters. As such, the string referenced by <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, in general, is not a C-style string. Moreover, the notion of a null-string value is not supported. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The address and extent of the string referenced by <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> are indicated by the <code>data</code> and <code>length</code> accessors, respectively. The referenced string is also indicated by the <code>begin</code> and <code>end</code> accessors that return STL-compatible iterators to the beginning of the string and one character past the end of the string, respectively. An overloaded <code>operator[]</code> is also provided for direct by-index access to individual characters in the string. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Several overloaded free operators are provided for <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> objects (as well as variants for all combinations involving <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> and <code>std::string</code>, and <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> and <code>char *</code>) for (1) lexicographic comparison of values, and (2) concatenation of values (producing an <code>std::string</code>); also provided is an overloaded free <code>operator&lt;&lt;</code> for writing the value of a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> object to a specified output stream. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>bsl::hash</code> template class is specialized for <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> to enable the use of <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> with STL hash containers (e.g., <code>bsl::hash_set</code> and <code>bsl::hash_map</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="efficiency_and_usage_considerations"></a> <a class="anchor" id="description.efficiency_and_usage_considerations"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Efficiency and Usage Considerations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Using <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> to pass strings as function arguments can be considerably more efficient than passing <code>bsl::string</code> objects by <code>const</code> reference. First, consider a hypothetical class method in which the parameter is a reference to a non-modifiable <code>bsl::string</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> MyClass::setLabel(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; label)
  {
      d_label = label;  <span class="comment">// &#39;MyClass::d_label&#39; is of type &#39;bsl::string&#39;</span>
  }
</pre></div><br/>
<br/>
 Then, consider a typical call to this method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyClass myClassObj;
  myClassObj.setLabel(<span class="stringliteral">&quot;hello&quot;</span>);
</pre></div><br/>
<br/>
 As a side-effect of this call, a temporary <code>bsl::string</code> containing a <em>copy</em> of "hello" is created (using the default allocator), that value is copied to <code>d_label</code>, and the temporary is eventually destroyed. The call thus requires the string data to be copied twice (as well as a possible allocation and deallocation). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, consider the same method taking a reference to a non-modifiable <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> MyClass::setLabel(<span class="keyword">const</span> <a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>&amp; label)
  {
      d_label.assign(label.<a class="code" href="classbslstl_1_1StringRefImp.html#a3edc3a7145921428485d2b400edc8e0f">begin</a>(), label.<a class="code" href="classbslstl_1_1StringRefImp.html#adeb6bfb5198edb141869f5417aff27a7">end</a>());
  }
</pre></div><br/>
<br/>
 Now: <br/>
<br/>
<div class="fragment"><pre class="fragment">  myClassObj.setLabel(<span class="stringliteral">&quot;hello&quot;</span>);
</pre></div><br/>
<br/>
 This call has the side-effect of creating a temporary <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> object, which is likely to be more efficient than creating a temporary <code>bsl::string</code> (even which is implemented using the short-string optimization). In this case, instead of copying the <em>contents</em> of "hello", the <em>address</em> of the literal string is copied. In addition, <code>bsl::strlen</code> is applied to the string in order to locate its end. There are <em>no</em> allocations done on behalf of the temporary object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="caveats"></a> <a class="anchor" id="description.caveats"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Caveats: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>1) The string referenced by <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> need not be null-terminated, and, in fact, may <em>contain</em> embedded null characters. Thus, it is generally not valid to pass the address returned by the <code>data</code> accessor to Standard C functions that expect a null-terminated string (e.g., <code>std::strlen</code>, <code>std::strcmp</code>, etc.). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>2) The string referenced by <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> must remain valid as long as the <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> references that string. Lifetime issues should be carefully considered when, for example, returning a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> object from a function or storing a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> object in a container. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>3) Passing a null string to any function (e.g., <code>operator==</code>) without also passing a 0 length results in undefined behavior. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippets of code illustrate basic and varied use of the <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a function, <code>getNumBlanks</code>, that returns the number of blank (<code>'&nbsp;'</code>) characters contained in the string referenced by a specified <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;algorithm&gt;</span>

  <span class="keywordtype">int</span> getNumBlanks(<span class="keyword">const</span> <a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>&amp; stringRef)
      <span class="comment">// Return the number of blank (&#39; &#39;) characters in the string referenced</span>
      <span class="comment">// by the specified &#39;stringRef&#39;.</span>
  {
      <span class="keywordflow">return</span> std::count(stringRef.<a class="code" href="classbslstl_1_1StringRefImp.html#a3edc3a7145921428485d2b400edc8e0f">begin</a>(), stringRef.<a class="code" href="classbslstl_1_1StringRefImp.html#adeb6bfb5198edb141869f5417aff27a7">end</a>(), <span class="charliteral">&#39; &#39;</span>);
  }
</pre></div><br/>
<br/>
 Notice that the function delegates the work to the <code>std::count</code> STL algorithm. This delegation is made possible by the STL-compatible iterators provided by the <code>begin</code> and <code>end</code> accessors. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, call <code>getNumBlanks</code> on a default constructed <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> emptyRef;
  <span class="keywordtype">int</span> numBlanks = getNumBlanks(emptyRef);
  assert(0 == numBlanks);

  assert(<span class="stringliteral">&quot;&quot;</span>         == emptyRef);
  assert(<span class="stringliteral">&quot;anything&quot;</span> &gt;= emptyRef);
</pre></div><br/>
<br/>
 Notice that the behavior a default constructed <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> object behaves the same as if it referenced an empty string. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we (implicitly) construct a <code>bsl::string</code> object from <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> empty(emptyRef);
  assert(0 == empty.size());
</pre></div><br/>
<br/>
 Then, we call <code>getNumBlanks</code> on a string literal and assert that the number of blanks returned is as expected: <br/>
<br/>
<div class="fragment"><pre class="fragment">  numBlanks = getNumBlanks(<span class="stringliteral">&quot;Good things come to those who wait.&quot;</span>);
  assert(6 == numBlanks);
</pre></div><br/>
<br/>
 Next, we define a longer string literal, <code>poem</code>, that we will use in the rest of this usage example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">char</span> poem[] =                  <span class="comment">// by William Butler Yeats (1865-1939)</span>
      |....5....|....5....|....5....|....5....|   <span class="comment">//  length  blanks</span>
                                                  <span class="comment">//</span>
      <span class="stringliteral">&quot;O love is the crooked thing,\n&quot;</span>            <span class="comment">//    29      5</span>
      <span class="stringliteral">&quot;There is nobody wise enough\n&quot;</span>             <span class="comment">//    28      4</span>
      <span class="stringliteral">&quot;To find out all that is in it,\n&quot;</span>          <span class="comment">//    31      7</span>
      <span class="stringliteral">&quot;For he would be thinking of love\n&quot;</span>        <span class="comment">//    33      6</span>
      <span class="stringliteral">&quot;Till the stars had run away\n&quot;</span>             <span class="comment">//    28      5</span>
      <span class="stringliteral">&quot;And the shadows eaten the moon.\n&quot;</span>         <span class="comment">//    32      5</span>
      <span class="stringliteral">&quot;Ah, penny, brown penny, brown penny,\n&quot;</span>    <span class="comment">//    37      5</span>
      <span class="stringliteral">&quot;One cannot begin it too soon.&quot;</span>;            <span class="comment">//    29      5</span>
                                                  <span class="comment">//          ----</span>
                                                  <span class="comment">//    total: 42</span>

  numBlanks = getNumBlanks(poem);
  assert(42 == numBlanks);
</pre></div><br/>
<br/>
 Then, we construct a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> object, <code>line</code>, that refers to only the first line of the <code>poem</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> line(poem, 29);
  numBlanks = getNumBlanks(line);

  assert( 5 == numBlanks);
  assert(29 == line.<a class="code" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">length</a>());
  assert( 0 == std::strncmp(poem, line.<a class="code" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">data</a>(), line.<a class="code" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">length</a>()));
</pre></div><br/>
<br/>
 Next, we use the <code>assign</code> method to make <code>line</code> refer to the second line of the <code>poem</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  line.<a class="code" href="group__bslstl__string.html#ga3b257d66c0c5074edfa0973939bb6179">assign</a>(poem + 29, poem + 57);
  numBlanks = getNumBlanks(line);
  assert(4 == numBlanks);
  assert((57 - 29) == line.<a class="code" href="group__bslstl__string.html#ga78edaba5c76c2e2f09067f478be101d2">length</a>());
  assert(<span class="stringliteral">&quot;There is nobody wise enough\n&quot;</span> == line);
</pre></div><br/>
<br/>
 Then, we call <code>getNumBlanks</code> with a <code>bsl::string</code> initialized to the contents of the <code>poem</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> poemString(poem);
  numBlanks = getNumBlanks(poemString);
  assert(42 == numBlanks);
  assert(<a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>(poemString) == poemString);
  assert(<a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>(poemString) == poemString.c_str());
</pre></div><br/>
<br/>
 Next, we make a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> object that refers to a string that will be able to hold embedded null characters: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">char</span> poemWithNulls[512];
  <span class="keyword">const</span> <span class="keywordtype">int</span> poemLength = std::strlen(poem);
  assert(poemLength &lt; 512);

  std::memcpy(poemWithNulls, poem, poemLength + 1);
  assert(0 == std::strcmp(poem, poemWithNulls));
</pre></div><br/>
<br/>
 Now, we replace each occurrence of a <code>\n</code> in <code>poemWithNulls</code> with a yielding <code>\0</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  std::replace(poemWithNulls, poemWithNulls + poemLength, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;\0&#39;</span>);
  assert(0 != std::strcmp(poem, poemWithNulls));
</pre></div><br/>
<br/>
 Finally, we observe that <code>poemWithNulls</code> has the same number of blank characters as the original <code>poem</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  numBlanks = getNumBlanks(<a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a>(poemWithNulls, poemLength));
  assert(42 == numBlanks);
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:43 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
