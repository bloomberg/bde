<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// ball_transmission.h                                                -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALL_TRANSMISSION
#define INCLUDED_BALL_TRANSMISSION

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Enumerate the set of states for log record transmission.
//
//@CLASSES:
//   ball::Transmission: namespace for log record transmission states
//
//@SEE_ALSO: ball_context, ball_observer
//
//@DESCRIPTION: This component provides a namespace, &#39;ball::Transmission&#39;, for
// the &#39;enum&#39; type &#39;ball::Transmission::Cause&#39;.  &#39;Cause&#39; enumerates the list of
// conditions (or states) that can cause a log record to be transmitted.  In
// addition, this component supports functions that convert the &#39;Cause&#39;
// enumerators to a well-defined ASCII representation.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Syntax
///- - - - - - - - -
// The following snippets of code provide a simple illustration of
// &#39;ball::Transmission&#39; usage.
//
// First create a variable &#39;cause&#39; of type &#39;ball::Transmission::Cause&#39; and
// initialize it to the value &#39;ball::Transmission::e_TRIGGER_ALL&#39;:
//..
//  ball::Transmission::Cause cause = ball::Transmission::e_TRIGGER_ALL;
//..
// Next, store a pointer to its ASCII representation in a variable &#39;asciiCause&#39;
// of type &#39;const char *&#39;:
//..
//  const char *asciiCause = ball::Transmission::toAscii(cause);
//  assert(0 == strcmp(asciiCause, &quot;TRIGGER_ALL&quot;));
//..
// Finally, print the value of &#39;cause&#39; to &#39;bsl::cout&#39;.
//..
//  bsl::cout &lt;&lt; cause &lt;&lt; bsl::endl;
//..
// This statement produces the following output on &#39;stdout&#39;:
//..
//  TRIGGER_ALL
//..
//
///Example 2: Logging
/// - - - - - - - - -
// The &#39;Cause&#39; enumeration defined in this component allows a logging system
// to describe the condition causing the publication of a log message.  One
// possible interpretation of three of these conditions is as follows:
//
//: &#39;e_PASSTHROUGH&#39;:
//:   indicate that a message is being output as a stand-alone message.
//:
//: &#39;e_TRIGGER&#39;:
//:   indicate that a message is being output as part of a dump of all
//:   messages archived for the current thread.
//:
//: &#39;e_TRIGGER_ALL&#39;:
//:    indicate that a message is being output as part of a dump of all
//:    messages archived for *all* threads.
//
// This example illustrates the use of &#39;ball::Transmission::Cause&#39; by a
// hypothetical logging system.
//
// We define a simple logger class named &#39;my_Logger&#39;.  Assume that &#39;my_Logger&#39;
// accepts messages from clients (e.g., the threads in a multi-threaded
// application) and archives them in-core.  Further assume that the message
// archive is bounded in size in which case &#39;my_Logger&#39; removes older messages
// to make room for newer ones as the need arises.  When a thread encounters
// an unusual, unexpected, or undesirable condition that it wishes to bring to
// the attention of an operator (say, sitting at a console terminal), it
// &quot;publishes&quot; the message.  That is the role of the &#39;publish&#39; method in the
// interface of &#39;my_Logger&#39;:
//..
//  // my_logger.h
//
//  class my_Logger {
//    // ...
//    public:
//      my_Logger();
//      ~my_Logger();
//      void publish(const char *message, ball::Transmission::Cause cause);
//      // ...
//  };
//..
// The &#39;publish&#39; method, defined in the following, shows the different actions
// that are taken for the three distinct causes of log message publication:
//..
//  // my_logger.cpp
//
//  my_Logger::my_Logger() { }
//
//  my_Logger::~my_Logger() { }
//
//  void my_Logger::publish(const char               *message,
//                          ball::Transmission::Cause  cause)
//  {
//      using namespace std;
//      switch (cause) {
//        case ball::Transmission::e_PASSTHROUGH: {
//          cout &lt;&lt; ball::Transmission::toAscii(cause) &lt;&lt; &quot;:\t&quot; &lt;&lt; message
//               &lt;&lt; endl;
//        } break;
//        case ball::Transmission::e_TRIGGER: {
//          cout &lt;&lt; ball::Transmission::toAscii(cause) &lt;&lt; &quot;:\t&quot; &lt;&lt; message
//               &lt;&lt; endl;
//          cout &lt;&lt; &quot;\t[ dump all messages archived for current thread ]&quot;
//               &lt;&lt; endl;
//        } break;
//        case ball::Transmission::e_TRIGGER_ALL: {
//          cout &lt;&lt; ball::Transmission::toAscii(cause) &lt;&lt; &quot;:\t&quot; &lt;&lt; message
//               &lt;&lt; endl;
//          cout &lt;&lt; &quot;\t[ dump all messages archived for *all* threads ]&quot;
//               &lt;&lt; endl;
//        } break;
//        default: {
//          cout &lt;&lt; &quot;***ERROR*** Unsupported Message Cause: &quot;  &lt;&lt; message
//               &lt;&lt; endl;
//          return;
//        } break;
//      }
//  }
//
//  // ...
//..
// Finally, we create a &#39;my_Logger&#39; object and &#39;publish&#39; three (simplistic)
// messages, each with a different cause:
//..
//  my_Logger logger;
//
//  const char *MSG_PASSTHROUGH = &quot;report relatively minor problem&quot;;
//  const char *MSG_TRIGGER     = &quot;report serious thread-specific problem&quot;;
//  const char *MSG_TRIGGER_ALL = &quot;report process-impacting problem&quot;;
//
//  logger.publish(MSG_PASSTHROUGH, ball::Transmission::e_PASSTHROUGH);
//  logger.publish(MSG_TRIGGER,     ball::Transmission::e_TRIGGER);
//  logger.publish(MSG_TRIGGER_ALL, ball::Transmission::e_TRIGGER_ALL);
//..
// The following output is produced on &#39;stdout&#39;:
//..
//  PASSTHROUGH:    report relatively minor problem
//  TRIGGER:        report serious thread-specific problem
//                  [ dump all messages archived for current thread ]
//  TRIGGER_ALL:    report process-impacting problem
//                  [ dump all messages archived for *all* threads ]
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif


namespace BloombergLP {

namespace ball {
                        // ========================
                        // struct Transmission
                        // ========================

struct Transmission {
    // This struct provides a namespace for enumerating the causes of the
    // transmission of a log record.

  public:
    // TYPES
    enum Cause {
        e_PASSTHROUGH        = 0,  // single record emitted; caused locally
        e_TRIGGER            = 1,  // all records emitted; caused locally
        e_TRIGGER_ALL        = 2,  // all records emitted; caused remotely
        e_MANUAL_PUBLISH     = 3,  // manually publish a single record
        e_MANUAL_PUBLISH_ALL = 4,  // manually publish all records
        e_END                = 5   // end flag for asynchronous publication

    };

    enum {
        e_LENGTH = e_MANUAL_PUBLISH_ALL + 1
    };
        // Define &#39;LENGTH&#39; to be the number of consecutively-valued enumerators
        // in the range &#39;[ e_PASSTHROUGH .. e_MANUAL_PUBLISH_ALL ]&#39;.

  private:
    // PRIVATE CLASS METHODS
    static void print(bsl::ostream&amp; stream, Transmission::Cause value);
        // Write to the specified &#39;stream&#39; the string representation of the
        // specified enumeration &#39;value&#39;.

  public:
    // CLASS METHODS
    static bsl::ostream&amp; streamOut(bsl::ostream&amp;       stream,
                                   Transmission::Cause value);
        // Format the specified &#39;value&#39; to the specified output &#39;stream&#39; and
        // return a reference to the modifiable &#39;stream&#39;.

    static const char *toAscii(Transmission::Cause value);
        // Return the string representation exactly matching the enumerator
        // name corresponding to the specified enumeration &#39;value&#39;.

};

// FREE OPERATORS
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, Transmission::Cause rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and return a
    // reference to the modifiable &#39;stream&#39;.

// ============================================================================
//                              INLINE DEFINITIONS
// ============================================================================

                        // ------------------------
                        // struct Transmission
                        // ------------------------

// CLASS METHODS
inline
bsl::ostream&amp; Transmission::streamOut(bsl::ostream&amp;       stream,
                                      Transmission::Cause value)
{
    print(stream, value);
    return stream;
}

}  // close package namespace

// FREE OPERATORS
inline
bsl::ostream&amp; ball::operator&lt;&lt;(bsl::ostream&amp;       stream,
                               Transmission::Cause rhs)
{
    return Transmission::streamOut(stream, rhs);
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
