<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslma_autodestructor Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslma_autodestructor<br/>
<small>
[<a class="el" href="group__bslma.html">Package bslma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a range proctor to manage an array of objects.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a range proctor to manage an array of objects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslma_1_1AutoDestructor.html">bslma::AutoDestructor</a> </td><td>range proctor to manage an array of objects  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__destructorguard.html" title="Provide a guard to unconditionally manage an object.">Component bslma_destructorguard</a>, <a class="el" href="group__bslma__destructorproctor.html" title="Provide a proctor to conditionally manage an object.">Component bslma_destructorproctor</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a range proctor class template to manage an array of (otherwise-unmanaged) objects of parameterized <code>TYPE</code> supplied at construction. Unless explicitly released, the contiguous managed objects are destroyed automatically when the range proctor goes out of scope by calling each (managed) object's destructor. Note that after a proctor object releases its managed objects, the same proctor can be reused to conditionally manage another contiguous sequence of objects by invoking the <code>reset</code> method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbslma_1_1AutoDestructor.html">bslma::AutoDestructor</a></code> is normally used to achieve <em>exception</em> <em>safety</em> in an <em>exception</em> <em>neutral</em> way by automatically destroying (otherwise-unmanaged) orphaned objects for an "in-place" array should an exception occur. The following example illustrates the insertion operation for a generic array. Assume that the array initially contains the following five elements: <br/>
<br/>
<div class="fragment"><pre class="fragment">     0     1     2     3     4
   _____ _____ _____ _____ _____ __
  | <span class="stringliteral">&quot;A&quot;</span> | <span class="stringliteral">&quot;B&quot;</span> | <span class="stringliteral">&quot;C&quot;</span> | <span class="stringliteral">&quot;D&quot;</span> | <span class="stringliteral">&quot;E&quot;</span> |
  `=====^=====^=====^=====^=====^==
</pre></div><br/>
<br/>
 To insert an element "F" at index position 2, the existing elements at index positions 2, 3, and 4 (i.e., "C", "D", and "E") are first shifted right to create an empty spot at the specified insert destination (we assume here and below that the array has sufficient capacity). The elements have to be shifted one by one by invoking the copy constructor (immediately followed by destroying the original elements). However, should any of the copy construction operations throw, all allocated resources from every previous copy construction would be leaked. Using the <code><a class="el" href="classbslma_1_1AutoDestructor.html">bslma::AutoDestructor</a></code> prevents the leak by invoking the destructor of each of the previously copied elements should the proctor go out of scope before the <code>release</code> method of the proctor is called (such as when the function exits prematurely due to an exception): <br/>
<br/>
<div class="fragment"><pre class="fragment">     0     1     2     3     4     5     6
   _____ _____ _____ _____ _____ _____ _____
  | <span class="stringliteral">&quot;A&quot;</span> | <span class="stringliteral">&quot;B&quot;</span> | <span class="stringliteral">&quot;C&quot;</span> | <span class="stringliteral">&quot;D&quot;</span> | <span class="stringliteral">&quot;E&quot;</span> |xxxxx|xxxxx|
  `=====^=====^=====^=====^=====^=====^=====<span class="stringliteral">&#39;</span>
<span class="stringliteral">  my_Array                            ^----- bslma::AutoDestructor</span>
<span class="stringliteral">  (length = 5)                           (origin = 6, length = 0)</span>
<span class="stringliteral"></span>
<span class="stringliteral">   Note: &quot;xxxxx&quot; denotes uninitialized memory.</span>
</pre></div><br/>
<br/>
 As each of the elements at index positions beyond the insertion position is shifted up by one index position, the proctor (i.e., the proctor's length) is <em>decremented</em>, thereby <em>extending</em> by one the sequence of elements it manages <em>below</em> its origin (note that when the proctor's length is non- positive, the element at the origin is <em>not</em> managed). At the same time, the array's length is <em>decremented</em> to ensure that each array element is always being managed (during an allocation attempt) either by the proctor or the array itself, but not both: <br/>
<br/>
<div class="fragment"><pre class="fragment">     0     1     2     3     4     5     6
   _____ _____ _____ _____ _____ _____ _____
  | <span class="stringliteral">&quot;A&quot;</span> | <span class="stringliteral">&quot;B&quot;</span> | <span class="stringliteral">&quot;C&quot;</span> | <span class="stringliteral">&quot;D&quot;</span> |xxxxx| <span class="stringliteral">&quot;E&quot;</span> |xxxxx|
  `=====^=====^=====^=====^=====^=====^=====<span class="stringliteral">&#39;</span>
<span class="stringliteral">  my_Array                      ^----------- bslma::AutoDestructor</span>
<span class="stringliteral">  (length = 4)                          (origin = 6, length = -1)</span>
<span class="stringliteral"></span>
<span class="stringliteral">   Note: Configuration after shifting up one element.</span>
</pre></div><br/>
<br/>
 When all elements are shifted, the <code><a class="el" href="classbslma_1_1AutoDestructor.html">bslma::AutoDestructor</a></code> will protect the entire range of shifted objects: <br/>
<br/>
<div class="fragment"><pre class="fragment">     0     1     2     3     4     5     6
   _____ _____ _____ _____ _____ _____ _____
  | <span class="stringliteral">&quot;A&quot;</span> | <span class="stringliteral">&quot;B&quot;</span> |xxxxx| <span class="stringliteral">&quot;C&quot;</span> | <span class="stringliteral">&quot;D&quot;</span> | <span class="stringliteral">&quot;E&quot;</span> |xxxxx|
  `=====^=====^=====^=====^=====^=====^=====<span class="stringliteral">&#39;</span>
<span class="stringliteral">  my_Array          ^----------------------- bslma::AutoDestructor</span>
<span class="stringliteral">  (length = 2)                           (origin = 6, length = -3)</span>
<span class="stringliteral"></span>
<span class="stringliteral">    Note: Configuration after shifting up three elements.</span>
</pre></div><br/>
<br/>
 Next, a new copy of element "F" must be created. If, during creation, an allocation fails and an exception is thrown, the array (now of length 2) is in a valid state, while the proctor is responsible for destroying the orphaned elements at index positions 3, 4, and 5. If no exception is thrown, the proctor's <code>release</code> method is called, releasing its control over the temporarily-managed contents: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_array.h</span>
  <span class="comment">// ...</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>my_Array {
      <span class="comment">// This class implements an &quot;in-place&quot; array of objects of</span>
      <span class="comment">// parameterized &#39;TYPE&#39; stored contiguously in memory.</span>

      <span class="comment">// DATA</span>
      TYPE             *d_array_p;      <span class="comment">// dynamically allocated array</span>
      <span class="keywordtype">int</span>               d_length;       <span class="comment">// logical length of this array</span>
      <span class="keywordtype">int</span>               d_size;         <span class="comment">// physical capacity of this array</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;  <span class="comment">// allocator (held, not owned)</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_Array(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;my_Array&#39; object having an initial length and capacity</span>
          <span class="comment">// of 0.  Optionally specify a &#39;basicAllocator&#39; used to supply</span>
          <span class="comment">// memory.  If &#39;basicAllocator&#39; is 0, the currently installed</span>
          <span class="comment">// default allocator is used.</span>

      my_Array(<span class="keywordtype">int</span> initialCapacity, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;my_Array&#39; object having an initial length of 0 and</span>
          <span class="comment">// the specified &#39;initialCapacity&#39;.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      <span class="comment">// ...</span>

      ~my_Array();
          <span class="comment">// Destroy this &#39;my_Array&#39; object and all elements currently</span>
          <span class="comment">// stored.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="comment">// ...</span>

      <span class="keywordtype">void</span> insert(<span class="keywordtype">int</span> dstIndex, <span class="keyword">const</span> TYPE&amp; <span class="keywordtype">object</span>);
          <span class="comment">// Insert (a copy of) the specified &#39;object&#39; of parameterized</span>
          <span class="comment">// &#39;TYPE&#39; at the specified &#39;dstIndex&#39; position of this array.  All</span>
          <span class="comment">// values with initial indices at or above &#39;dstIndex&#39; are shifted</span>
          <span class="comment">// up by one index position.  The behavior is undefined unless</span>
          <span class="comment">// &#39;0 &lt;= dstIndex&#39; and &#39;dstIndex&#39; is less than the number of items</span>
          <span class="comment">// in this array.</span>

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Note that the rest of the <code>my_Array</code> interface (above) and implementation (below) is omitted as the portion shown is sufficient to demonstrate the use of <code><a class="el" href="classbslma_1_1AutoDestructor.html">bslma::AutoDestructor</a></code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  my_Array&lt;TYPE&gt;::my_Array(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_array_p(0)
  , d_length(0)
  , d_size(0)
  , d_allocator_p(bslma::Default::allocator(basicAllocator))
  {
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  my_Array&lt;TYPE&gt;::~my_Array()
  {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d_length; ++i) {
          d_array_p[i].~TYPE();
      }
      d_allocator_p-&gt;deallocate(d_array_p);
  }
</pre></div><br/>
<br/>
 The elided implementation of the following <code>insert</code> function (which shows code for the case above, i.e., there is sufficient capacity) is sufficient to illustrate the use of <code><a class="el" href="classbslma_1_1AutoDestructor.html">bslma::AutoDestructor</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> my_Array&lt;TYPE&gt;::insert(<span class="keywordtype">int</span> dstIndex, <span class="keyword">const</span> TYPE&amp; <span class="keywordtype">object</span>)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt;= dstIndex);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(dstIndex &lt;= d_length);

      <span class="keywordflow">if</span> (d_size == d_length) {  <span class="comment">// resize needed</span>
          <span class="comment">// ...</span>
      }

      <span class="keyword">const</span> TYPE *tmp = &amp;object;

      <span class="keywordflow">if</span> ((d_array_p + dstIndex &lt;= &amp;<span class="keywordtype">object</span>)
       &amp;&amp; (&amp;<span class="keywordtype">object</span> &lt; d_array_p + d_length)) {  <span class="comment">// self-aliasing</span>
          tmp = &amp;<span class="keywordtype">object</span> + 1;
      }

      <span class="comment">//**************************************************************</span>
      <span class="comment">// Note the use of the auto destructor on &#39;d_array_p&#39; (below). *</span>
      <span class="comment">//**************************************************************</span>

      <a class="code" href="classbslma_1_1AutoDestructor.html">bslma::AutoDestructor&lt;TYPE&gt;</a> autoDtor(&amp;d_array_p[d_length + 1], 0);
      <span class="keywordtype">int</span> origLen = d_length;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = d_length - 1; i &gt;= dstIndex; --i, --autoDtor,
                                                                --d_length) {
          <span class="keyword">new</span>(&amp;d_array_p[i + 1]) TYPE(d_array_p[i], d_allocator_p);
                                                         <span class="comment">// copy to new index</span>
          d_array_p[i].~TYPE();                          <span class="comment">// destroy original</span>
      }

      <span class="keyword">new</span>(&amp;d_array_p[dstIndex]) TYPE(*tmp, d_allocator_p);

      <span class="comment">//*****************************************************</span>
      <span class="comment">// Note that the auto destructor is released (below). *</span>
      <span class="comment">//*****************************************************</span>

      autoDtor.release();

      d_length = origLen + 1;
  }
</pre></div><br/>
<br/>
 Note that the <code>insert</code> method assumes the copy constructor of <code>TYPE</code> takes an allocator as a second argument. In production code, a constructor proxy that checks the traits of <code>TYPE</code> (to determine whether <code>TYPE</code> indeed uses <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>) should be used (see <code>bslalg_constructorproxy</code>). </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:41 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
