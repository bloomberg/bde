<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslalg_bidirectionallinklistutil.h                                 -*-C++-*-
#ifndef INCLUDED_BSLALG_BIDIRECTIONALLINKLISTUTIL
#define INCLUDED_BSLALG_BIDIRECTIONALLINKLISTUTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide utilities to maintain bidirectional list data structures.
//
//@CLASSES:
//  bslalg::BidirectionalLinkListUtil: utilities to maintain linked lists
//
//@SEE_ALSO: bslalg_bidirectionallink, bslalg_hashtableimputil
//
//@DESCRIPTION: This component provides a namespace,
// &#39;bslalg::BidirectionalLinkListUtil&#39;, containing utility functions for
// operating on doubly linked lists with nodes of type
// &#39;bslalg::BidirectionalLink&#39;.  The operations assume that the linked lists
// are either 0 terminated (on both ends) or terminate with sentinel (valid)
// nodes.  The main operations include insertion and removal of a node from a
// list of nodes, and the *splicing* of ranges from one list into another one.
// Splicing is the operation of moving a sub-list, or range, of elements from
// one linked list and into a second list, at a specified position.
//
///Usage
///-----
// This section illustrates intended usage of this component.
//
///Example 1: Creating and Using a List Template Class
///- - - - - - - - - - - - - - - - - - - - - - - - - -
// First, since &#39;Link&#39; neither has a constructor nor is a POD (which would make
// aggregate initialization possible), we create a function &#39;makeLink&#39; to
// assemble a link from two pointers:
//..
//  Link makeLink(Link *prev, Link *next)
//  {
//      Link result;
//      result.setPreviousLink(prev);
//      result.setNextLink(    next);
//
//      return result;
//  }
//..
// Then, we create a function that will, passed two links that are endpoints
// of a linked list from the specified &#39;first&#39; to &#39;last&#39; though the &#39;nextLink&#39;
// pointers, count the number of nodes in the list including both endpoints.
//..
//  int length(Link *first, Link *last)
//  {
//      int result = 0;
//      Link *p = first;
//      while (p &amp;&amp; ++result &amp;&amp; last != p) {
//          p = p-&gt;nextLink();
//      }
//
//      return result;
//  }
//..
// Next, in our &#39;main&#39;, we declare a &#39;typedef&#39; for the component name and a
// a constant &#39;invalid&#39; garbage pointer we use when we want data to be garbage.
//..
//  typedef BidirectionalLinkListUtil Util;
//  Link * const invalid = (Link *) 0XBADDEED5;
//..
// Then, we create a linked list of links and use &#39;isWellFormed&#39; to verify
// that it is well formed, and call the &#39;length&#39; method we just created to
// verify its length.
//..
//  Link usageData[] = {
//      makeLink(0,             &amp;usageData[1]),
//      makeLink(&amp;usageData[0], &amp;usageData[2]),
//      makeLink(&amp;usageData[1], &amp;usageData[3]),
//      makeLink(&amp;usageData[2], 0            )  };
//
//  assert(Util::isWellFormed(      &amp;usageData[0], &amp;usageData[3]));
//  assert(4 == length(&amp;usageData[0], &amp;usageData[3]));
//..
// Next, we create two new links &#39;front&#39; and &#39;back&#39;, and initialize them with
// garbage:
//..
//  Link front = makeLink(invalid, invalid);
//  Link back  = makeLink(invalid, invalid);
//..
// Then, we use our component&#39;s &#39;insertLinkBeforeTarget&#39; and
// &#39;insertLinkAfterTarget&#39; to concatenate &#39;front&#39; to the front of the list and
// &#39;back&#39; to its rear:
//..
//  Util::insertLinkBeforeTarget(&amp;front, &amp;usageData[0]);
//  Util::insertLinkAfterTarget( &amp;back,  &amp;usageData[3]);
//..
// Next, We examine the new list and verify we now have a well-formed list, 2
// longer than the old list:
//..
//  assert(0 == front.previousLink());
//  assert(0 == back .nextLink());
//  assert(Util::isWellFormed(          &amp;front, &amp;back));
//  assert(6 == length(&amp;front, &amp;back));
//..
// Then, we use our component&#39;s &#39;unlink&#39; method to remove two nodes from our
// list.  Note that the state of the removed nodes is undefined:
//..
//  Util::unlink(&amp;usageData[1]);
//  Util::unlink(&amp;usageData[3]);
//..
// Next, we verify that the new list is well formed and 2 elements shorter than
// it was before we removed those two nodes:
//..
//  assert(Util::isWellFormed(&amp;front, &amp;back));
//  assert(4 == length(&amp;front, &amp;back));
//..
// Then, we weave the two discarded nodes into a new, second list of two nodes,
// and use &#39;isWellFormed&#39; and &#39;length&#39; to verify it is as we expect:
//..
//  usageData[1] = makeLink(0, &amp;usageData[3]);
//  usageData[3] = makeLink(&amp;usageData[1], 0);
//  assert(Util::isWellFormed(&amp;usageData[1], &amp;usageData[3]));
//  assert(2 ==        length(&amp;usageData[1], &amp;usageData[3]));
//..
// Next, we use our component&#39;s &#39;spliceListBeforeTarget&#39; method to remove the
// middle nodes from the longer list and append them to the end of shorter
// list.  Note that the splicing function not only adds the sequence to the new
// list, it also splices the list the sequence is removed from so that both are
// well-formed lists:
//..
//  Util::spliceListBeforeTarget(&amp;usageData[0],
//                               &amp;usageData[2],
//                               &amp;usageData[3]);
//..
// Then, we use &#39;isWellFormed&#39; and &#39;length&#39; to verify the state of our two
// lists:
//..
//  assert(Util::isWellFormed(&amp;usageData[1], &amp;usageData[3]));
//  assert(4 ==        length(&amp;usageData[1], &amp;usageData[3]));
//
//  assert(Util::isWellFormed(&amp;front, &amp;back));
//  assert(2 ==        length(&amp;front, &amp;back));
//..
// Next, we call &#39;spliceListBeforeTarget&#39; again to join our two lists into one:
//..
//  Util::spliceListBeforeTarget(&amp;usageData[1],
//                               &amp;usageData[3],
//                               &amp;back);
//..
// Now, we use &#39;isWellFormed&#39; and &#39;length&#39; to verify the state of our one
// remaining list:
//..
//  assert(Util::isWellFormed(&amp;front, &amp;back));
//  assert(6 ==        length(&amp;front, &amp;back));
//  assert(0 == front.previousLink());
//  assert(0 == back .nextLink());
//..
// Finally, we traverse our list in both directions, examining each node to
// verify all the links and that the sequence is as expected:
//..
//  Link *p = &amp;front;
//  assert(0 == p-&gt;previousLink());
//  p = p-&gt;nextLink();
//  assert(&amp;usageData[1] == p);
//  p = p-&gt;nextLink();
//  assert(&amp;usageData[0] == p);
//  p = p-&gt;nextLink();
//  assert(&amp;usageData[2] == p);
//  p = p-&gt;nextLink();
//  assert(&amp;usageData[3] == p);
//  p = p-&gt;nextLink();
//  assert(&amp;back         == p);
//  assert(0 == p-&gt;nextLink());
//
//  p = p-&gt;previousLink();
//  assert(&amp;usageData[3] == p);
//  p = p-&gt;previousLink();
//  assert(&amp;usageData[2] == p);
//  p = p-&gt;previousLink();
//  assert(&amp;usageData[0] == p);
//  p = p-&gt;previousLink();
//  assert(&amp;usageData[1] == p);
//  p = p-&gt;previousLink();
//  assert(&amp;front        == p);
//  assert(0 == p-&gt;previousLink());
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

namespace BloombergLP
{

namespace bslalg
{

class BidirectionalLink;

                        // ========================================
                        // struct bslalg::BidirectionalLinkListUtil
                        // ========================================

struct BidirectionalLinkListUtil {
    // This &#39;struct&#39; provides a namespace for utility functions that manipulate
    // linked lists based on &#39;bslalg::BidirectionalLink&#39; nodes, including
    // insertion, removal, and *splicing*.

    // CLASS METHODS
    static
    void insertLinkBeforeTarget(BidirectionalLink *newNode,
                                BidirectionalLink *target);
        // Insert the specified &#39;newNode&#39; before the specified &#39;target&#39; node in
        // the linked list that contains &#39;target&#39;.  If &#39;target&#39; is 0, then the
        // value of the attributes &#39;nextLink&#39; and &#39;previousLink&#39; of &#39;newNode&#39;
        // is set to 0.  After successful execution of this function the values
        // of the &#39;previousLink&#39; and &#39;nextLink&#39; attributes of all the links in
        // the list appropriately reflect the operation.  The behavior is
        // undefined unless &#39;0 == target-&gt;previousLink()&#39; is true or
        // &#39;isWellFormed(target-&gt;previousLink(), target)&#39; is true.

    static
    void insertLinkAfterTarget(BidirectionalLink *newNode,
                               BidirectionalLink *target);
        // Insert the specified &#39;newNode&#39; after the specified &#39;target&#39; node in
        // the linked list that contains &#39;target&#39;.  If the node following
        // &#39;target&#39; is 0, then set the &#39;nextLink&#39; attribute of &#39;newNode&#39; to 0.
        // After successful execution of this function the values of the
        // &#39;previousLink&#39; and &#39;nextLink&#39; attributes of all the links in the
        // list appropriately reflect the operation.  The behavior is undefined
        // unless &#39;0 != newNode&#39; and &#39;0 != target&#39;.  The behavior is also
        // undefined unless &#39;0 == target-&gt;nextLink()&#39; is true or
        // &#39;isWellFormed(target, target-&gt;nextLink())&#39; are true.

    static
    bool isWellFormed(BidirectionalLink *head, BidirectionalLink *tail);
        // Return true if the bidirectional list starting from the specified
        // &#39;head&#39;, and ending with the specified &#39;tail&#39; is well formed.  A
        // bidirectional list is well formed if &#39;tail == head&#39; (0 values are
        // allowed) or all of the following conditions are met (note that
        // &#39;head&#39; is renamed to &#39;h&#39; and &#39;tail&#39; to &#39;t&#39; for brevity):
        //
        //: 1 &#39;h&#39; and &#39;t&#39; are valid addresses.
        //:
        //: 2 &#39;h-&gt;nextLink()-&gt;previousLink() == h&#39; is true.
        //:
        //: 3 &#39;!h-&gt;previousLink() || h-&gt;previousLink()-&gt;nextLink() == h&#39;
        //:    is true.
        //:
        //: 4 &#39;t-&gt;previousLink()-&gt;nextLink() == t&#39; is true.
        //:
        //: 5 &#39;!t-&gt;nextLink() || t-&gt;nextLink()-&gt;previousLink() == t&#39;
        //:    is true.
        //:
        //: 6 For each &#39;link&#39; in the list different than &#39;h&#39; and &#39;t&#39; both
        //:   &#39;link-&gt;nextLink()-&gt;previousLink() == link&#39; and
        //:   &#39;link-&gt;previousLink()-&gt;nextLink() == link&#39; are true.
        //
        // The behavior is undefined unless &#39;tail&#39; can be reached from &#39;head&#39;
        // following the chain of &#39;nextLink&#39; attributes of all the nodes in the
        // open range &#39;[head, tail)&#39;.

    static
    void spliceListBeforeTarget(BidirectionalLink *first,
                                BidirectionalLink *last,
                                BidirectionalLink *target);
        // Unlink and move (splice) the elements of a doubly-linked list
        // included in the closed range &#39;[first, last]&#39; out of their original
        // list and into another doubly-linked list before the specified
        // &#39;target&#39; node.  If &#39;target&#39; is 0, then the the elements are
        // extracted and form a new list such that &#39;0 == first-&gt;previousLink()&#39;
        // and &#39;0 == last-&gt;nextLink()&#39; .  After successful execution of this
        // function the values of the &#39;previousLink&#39; and &#39;nextLink&#39; attributes
        // of all the links in the origin and destination lists appropriately
        // reflect the operation.  The behavior is undefined unless both
        // &#39;first&#39; and &#39;last&#39; are non-zero members of the same linked list;
        // &#39;first&#39; precedes &#39;last&#39; in the list, or &#39;first == last&#39;; &#39;target&#39; is
        // not a node contained in the closed range &#39;[first, last]&#39;; and
        // &#39;isWellFormed(first, last)&#39; is true.

    static
    void unlink(BidirectionalLink *node);
        // Unlink the specified &#39;node&#39; from the linked list of which it is a
        // member.  After successful execution of this function the values of
        // the &#39;previousLink&#39; and &#39;nextLink&#39; attributes of all the links in the
        // origin and destination lists appropriately reflect the operation
        // Note that this method does *not* change the value for the &#39;nextLink&#39;
        // and &#39;previousLink&#39; attributes of &#39;node&#39;.  The behavior is
        // undefined unless &#39;!node-&gt;previousLink()&#39;, &#39;!node-&gt;nextLink()&#39;, or
        // &#39;isWellFormed(node-&gt;previousLink(), node-&gt;nextLink())&#39; are true.
};

}  // close namespace BloombergLP::bslalg

}  // close namespace BloombergLP

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
