<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslma_deallocatorguard.h                                           -*-C++-*-
#ifndef INCLUDED_BSLMA_DEALLOCATORGUARD
#define INCLUDED_BSLMA_DEALLOCATORGUARD

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a guard to unconditionally manage a block of memory.
//
//@CLASSES:
//  bslma::DeallocatorGuard: guard to unconditionally manage a block of memory
//
//@SEE_ALSO: bslma_deallocatorproctor, bslma_autodeallocator
//
//@DESCRIPTION: This component provides a guard class template to
// unconditionally manage a block of (otherwise-unmanaged) memory.  The managed
// memory is deallocated automatically when the guard object goes out of scope
// using the &#39;deallocate&#39; method of the parameterized &#39;ALLOCATOR&#39; (allocator or
// pool) supplied at construction.
//
///Requirement
///-----------
// The parameterized &#39;ALLOCATOR&#39; type of the &#39;bslma::DeallocatorGuard&#39; class
// template must provide a (possibly &#39;virtual&#39;) method:
//..
//  void deallocate(void *address);
//..
// to deallocate memory at the specified &#39;address&#39; (originally supplied by the
// &#39;ALLOCATOR&#39; object).
//
///Usage
///-----
// A &#39;bslma::DeallocatorGuard&#39; can be used to ensure that a dynamically
// allocated raw memory resource is safely deallocated in the presense of
// multiple return satements or exceptions in an exception-neutral way (i.e.,
// without the need for &#39;try&#39;/&#39;catch&#39; blocks).  In this simple example,
// consider the function &#39;evaluatePassword&#39; which attempts to determine how
// secure a given password might be:
//..
//  double evaluatePassword(const char *password, bslma::Allocator *allocator);
//      // Evaluate the strength of the specified &#39;password&#39;, using the
//      // specified &#39;allocator&#39; to supply memory for evaluation.  Return a
//      // real value in the range &#39;[ 0.0 .. 1.0 ]&#39; where 0.0 indicates the
//      // weakest password, and 1.0 the strongest.
//..
// This function will be implemented in terms of three *exception* *neutral*
// subroutines, each of which operates on a writable copy of the
// null-terminated password, (perturbing its contents slightly) and requiring
// unbounded amounts of scratch memory (to be allocated and deallocated from a
// supplied allocator):
//..
//  int subroutine1(char *inOut, bslma::Allocator *allocator);
//  int subroutine2(char *inOut, bslma::Allocator *allocator);
//  int subroutine3(char *inOut, bslma::Allocator *allocator);
//..
// A final subroutine is then used to determine and return the score:
//..
//  double finalSubroutine(const char *result);
//..
// The top-level routine is implemented as follows:
//..
//  double evaluatePassword(const char *password, bslma::Allocator *allocator)
//  {
//
//      // Set up local writable copy of password in buffer.
//
//      int size = strlen(password) + 1;
//      char *buffer = (char *)allocator-&gt;allocate(size);
//      memcpy(buffer, password, size);
//
//      //**************************************************************
//      //* Note the use of the deallocator guard on &#39;buffer&#39; (below). *
//      //**************************************************************
//
//      bslma::DeallocatorGuard&lt;bslma::Allocator&gt; guard(buffer, allocator);
//
//      // Process and evaluate the supplied password.
//
//      if (0 != subroutine1(buffer, allocator)) {
//          return 0.0;                                               // RETURN
//      }
//      if (0 != subroutine2(buffer, allocator)) {
//          return 0.2;                                               // RETURN
//      }
//      if (0 != subroutine3(buffer, allocator)) {
//          return 0.4;                                               // RETURN
//      }
//
//      return finalSubroutine(buffer);
//
//  }  // note that &#39;buffer&#39; is deallocated at end of block regardless
//..
// Notice that if any of the initial (numbered) subroutines returns a non-zero
// status value, the top-level &#39;evaluatePassword&#39; routine returns immediately
// with a predetermined score.  Moreover, each of these routines may encounter
// a &#39;bad_alloc&#39; exception should the supplied allocator fail to return the
// requested memory.  Even if all of these subroutines evaluates successfully,
// the score calculated using &#39;finalEval&#39; is returned directly by
// &#39;evaluatePassword&#39;, yet we still need to deallocate &#39;buffer&#39;.  By guarding
// buffer with a &#39;bslma::DeallocatorGuard&#39; as shown above, all of these issues
// are fully addressed, and the top-level routine is also *exception* *neutral*
// as desired.

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

namespace BloombergLP {

namespace bslma {

                        // ======================
                        // class DeallocatorGuard
                        // ======================

template &lt;class ALLOCATOR&gt;
class DeallocatorGuard {
    // This class implements a guard that unconditionally deallocates a block
    // of managed memory upon destruction by invoking the &#39;deallocate&#39; method
    // of an allocator (or pool) of parameterized &#39;ALLOCATOR&#39; type supplied to
    // it at construction.  The managed memory must have been supplied by the
    // allocator (or pool), which must remain valid throughout the lifetime of
    // the guard object.

    // DATA
    void      *d_memory_p;     // address of managed memory
    ALLOCATOR *d_allocator_p;  // allocator or pool (held, not owned)

    // NOT IMPLEMENTED
    DeallocatorGuard(const DeallocatorGuard&amp;);
    DeallocatorGuard&amp; operator=(const DeallocatorGuard&amp;);

  public:
    // CREATORS
    DeallocatorGuard(void *memory, ALLOCATOR *allocator);
        // Create a deallocator guard that unconditionally manages the
        // specified &#39;memory&#39; block, and that uses the specified &#39;allocator&#39; to
        // deallocate &#39;memory&#39; upon destruction of this guard.  The behavior is
        // undefined unless &#39;memory&#39; and &#39;allocator&#39; are non-zero, and
        // &#39;allocator&#39; supplied &#39;memory&#39;.  Note that &#39;allocator&#39; must remain
        // valid throughout the lifetime of this guard.

    ~DeallocatorGuard();
        // Destroy this deallocator guard and deallocate the block of memory it
        // manages by invoking the &#39;deallocate&#39; method of the allocator (or
        // pool) that was supplied with the address of the (managed) memory at
        // construction.
};

// ============================================================================
//                      INLINE AND TEMPLATE FUNCTION DEFINITIONS
// ============================================================================

                        // ----------------------
                        // class DeallocatorGuard
                        // ----------------------

// CREATORS
template &lt;class ALLOCATOR&gt;
inline
DeallocatorGuard&lt;ALLOCATOR&gt;::DeallocatorGuard(void      *memory,
                                              ALLOCATOR *allocator)
: d_memory_p(memory)
, d_allocator_p(allocator)
{
    BSLS_ASSERT_SAFE(memory);
    BSLS_ASSERT_SAFE(allocator);
}

template &lt;class ALLOCATOR&gt;
inline
DeallocatorGuard&lt;ALLOCATOR&gt;::~DeallocatorGuard()
{
    BSLS_ASSERT_SAFE(d_memory_p);
    BSLS_ASSERT_SAFE(d_allocator_p);

    d_allocator_p-&gt;deallocate(d_memory_p);
}

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
