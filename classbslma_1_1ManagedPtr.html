<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Class bslma::ManagedPtr</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslma.html">bslma</a>      </li>
      <li><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt; TARGET_TYPE &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>bslma::ManagedPtr&lt; TARGET_TYPE &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslma::ManagedPtr" -->
<p><code>#include &lt;<a class="el" href="bslma__managedptr_8h_source.html">bslma_managedptr.h</a>&gt;</code></p>

<p><a href="classbslma_1_1ManagedPtr-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbslma_1_1ManagedPtrDeleter.html#a1be897cc4bf64af791944bd9b8f42b75">ManagedPtrDeleter::Deleter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#afda656bd737f271d5457db053d145f32">DeleterFunc</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#aa7d6dd0552680e0a14669c747638b89c">ManagedPtr</a> (<a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>=0, <a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class MANAGED_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a16d83f0108ba16c9f615282014375606">ManagedPtr</a> (MANAGED_TYPE *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a426e73fa3907726778e1c5a410d48e8b">ManagedPtr</a> (<a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#aaa9f2596745ae2f482f6c8a001afa027">ManagedPtr</a> (<a class="el" href="classbslma_1_1ManagedPtr__Ref.html">ManagedPtr_Ref</a>&lt; TARGET_TYPE &gt; ref)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ALIASED_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#adce03c94854b50fc2d35c6fd3f3a620e">ManagedPtr</a> (<a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a>&lt; ALIASED_TYPE &gt; &amp;alias, TARGET_TYPE *ptr)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class MANAGED_TYPE , class FACTORY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#ae026c2418637882d81a523125a1cd738">ManagedPtr</a> (MANAGED_TYPE *ptr, FACTORY_TYPE *factory)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FACTORY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#ad7696e213a5321f018f97a543d84df88">ManagedPtr</a> (<a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>, FACTORY_TYPE *factory)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a02c58a5028f61ca6b1eee4cfc438f941">ManagedPtr</a> (TARGET_TYPE *ptr, void *cookie, <a class="el" href="classbslma_1_1ManagedPtr.html#afda656bd737f271d5457db053d145f32">DeleterFunc</a> deleter)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class MANAGED_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#aab16b52de709ca885e3af1ec6daf111d">ManagedPtr</a> (MANAGED_TYPE *ptr, void *cookie, <a class="el" href="classbslma_1_1ManagedPtr.html#afda656bd737f271d5457db053d145f32">DeleterFunc</a> deleter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a4203395d11260ca98cac36cb2f396845">~ManagedPtr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a54d2e576e512511a2df0fdfeef1d11a9">operator=</a> (<a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a3205ad28d53a8f995f116052c90dea9a">operator=</a> (<a class="el" href="classbslma_1_1ManagedPtr__Ref.html">ManagedPtr_Ref</a>&lt; TARGET_TYPE &gt; ref)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a7279d025bfe24aa466e4b16847390b5b">operator=</a> (<a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class REFERENCED_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a2abfbbbb9ed75f21b1d688477ecebf85">operator ManagedPtr_Ref&lt; REFERENCED_TYPE &gt;</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#ab929c98b414c3feabd00d8e4430b60d1">clear</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class MANAGED_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a0eee37981ad3dee3ba6b4f3360a4b8c5">load</a> (MANAGED_TYPE *ptr)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class MANAGED_TYPE , class FACTORY_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a073451ac2c66e6b7caaf794e553bfd34">load</a> (MANAGED_TYPE *ptr, FACTORY_TYPE *factory)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class MANAGED_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a37203c128f2dea44b26d0e8ac2c85d70">load</a> (MANAGED_TYPE *ptr, void *cookie, <a class="el" href="classbslma_1_1ManagedPtr.html#afda656bd737f271d5457db053d145f32">DeleterFunc</a> deleter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a17fc0ebc524eb94c90b06122e8e448eb">load</a> (<a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>=0, void *cookie=0, <a class="el" href="classbslma_1_1ManagedPtr.html#afda656bd737f271d5457db053d145f32">DeleterFunc</a> deleter=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ALIASED_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#acf50f35b32c6b2a8d6638d21fa2df9b8">loadAlias</a> (<a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a>&lt; ALIASED_TYPE &gt; &amp;alias, TARGET_TYPE *ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbslma_1_1ManagedPtr__PairProxy.html">ManagedPtr_PairProxy</a><br class="typebreak"/>
&lt; TARGET_TYPE, <br class="typebreak"/>
<a class="el" href="classbslma_1_1ManagedPtrDeleter.html">ManagedPtrDeleter</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a826d9856966f92aefdbcc2ef2b019861">release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TARGET_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a6c1facdee268423bd611bc3e382ae1a9">release</a> (<a class="el" href="classbslma_1_1ManagedPtrDeleter.html">ManagedPtrDeleter</a> *deleter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#af96bb8356e57e2ab6037d45f7f594d86">reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a706df5bd259bd244636eae65003e858b">swap</a> (<a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a6178b46544d9621a32b623062d32a74f">operator BoolType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbslmf_1_1AddReference.html">bslmf::AddReference</a><br class="typebreak"/>
&lt; TARGET_TYPE &gt;::Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#ad8629f0fbe9ae3088e9c07069a548b8f">operator*</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TARGET_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a7a985054043e5ac19a51b6db8f4f4f6f">operator-&gt;</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbslma_1_1ManagedPtrDeleter.html">ManagedPtrDeleter</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a3d979e298134421c44100723dadc56fd">deleter</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TARGET_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a83325a674a64bd8c45607d2822df0d8e">get</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TARGET_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#a806661d834efd84fb953db1c69d5fb53">ptr</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1ManagedPtr.html#aae3e51c1ec8b8048bfc4e29453966a63">ManagedPtr</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class TARGET_TYPE&gt;<br/>
 class bslma::ManagedPtr&lt; TARGET_TYPE &gt;</h3>

<p>This class is a "smart pointer" that refers to a <em>target</em> object accessed via a pointer to the specified parameter type, <code>TARGET_TYPE</code>, and that supports sole ownership of a <em>managed</em> object that is potentially of a different type, and may be an entirely different object from the target object. A managed pointer ensures that the object it manages is destroyed when the managed pointer is destroyed (or re-assigned), using the "deleter" supplied along with the managed object. The target object referenced by a managed pointer may be accessed using either the <code>-&gt;</code> operator, or the dereference operator (operator <code>*</code>). The specified <code>TARGET_TYPE</code> may be <code>const</code>-qualified, but may not be <code>volatile</code>-qualified, nor may it be a reference type.</p>
<p>A managed pointer may be <em>empty</em>, in which case it neither refers to a target object nor owns a managed object. An empty managed pointer is the equivalent of a null pointer: Such a managed pointer is not de-referenceable, and tests as <code>false</code> in boolean expressions.</p>
<p>A managed pointer for which the managed object is not the same object as the target is said to <em>alias</em> the managed object (see the section "Aliasing" in the component-level documentation). </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="afda656bd737f271d5457db053d145f32"></a><!-- doxytag: member="bslma::ManagedPtr::DeleterFunc" ref="afda656bd737f271d5457db053d145f32" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbslma_1_1ManagedPtrDeleter.html#a1be897cc4bf64af791944bd9b8f42b75">ManagedPtrDeleter::Deleter</a> <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::<a class="el" href="classbslma_1_1ManagedPtr.html#afda656bd737f271d5457db053d145f32">DeleterFunc</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa7d6dd0552680e0a14669c747638b89c"></a><!-- doxytag: member="bslma::ManagedPtr::ManagedPtr" ref="aa7d6dd0552680e0a14669c747638b89c" args="(bsl::nullptr_t=0, bsl::nullptr_t=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::<a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty managed pointer. Note that this constructor is necessary to match null-pointer literal arguments, in order to break ambiguities and provide valid type deduction with the other constructor templates in this class. </p>

</div>
</div>
<a class="anchor" id="a16d83f0108ba16c9f615282014375606"></a><!-- doxytag: member="bslma::ManagedPtr::ManagedPtr" ref="a16d83f0108ba16c9f615282014375606" args="(MANAGED_TYPE *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class MANAGED_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::<a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">MANAGED_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a managed pointer having a target object referenced by the specified <code>ptr</code>, owning the managed object <code>*ptr</code>, and having a deleter that uses the currently installed default allocator to destroy the managed object when invoked (e.g., when this managed pointer object is destroyed), unless <code>0 == ptr</code>, in which case create an empty managed pointer. The deleter will invoke the destructor of <code>MANAGED_TYPE</code> rather than the destructor of <code>TARGET_TYPE</code>. This constructor will not compile unless <code>MANAGED_TYPE *</code> is convertible to <code>TARGET_TYPE *</code>. The behavior is undefined unless the managed object (if any) can be destroyed by the currently installed default allocator, or if the the lifetime of the managed object is already managed by another object. Note that this behavior allows <code><a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a></code> to be defined for <code>void</code> pointers, and to call the correct destructor for the managed object, even if the destructor for <code>TARGET_TYPE</code> is not declared as <code>virtual</code>. </p>

</div>
</div>
<a class="anchor" id="a426e73fa3907726778e1c5a410d48e8b"></a><!-- doxytag: member="bslma::ManagedPtr::ManagedPtr" ref="a426e73fa3907726778e1c5a410d48e8b" args="(ManagedPtr &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::<a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a>&lt; TARGET_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a managed pointer having the same target object as the specified <code>original</code>, and transfer the ownership of the object managed by the <code>original</code> (if any) to this managed pointer, then reset <code>original</code> as empty. </p>

</div>
</div>
<a class="anchor" id="aaa9f2596745ae2f482f6c8a001afa027"></a><!-- doxytag: member="bslma::ManagedPtr::ManagedPtr" ref="aaa9f2596745ae2f482f6c8a001afa027" args="(ManagedPtr_Ref&lt; TARGET_TYPE &gt; ref)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::<a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr__Ref.html">ManagedPtr_Ref</a>&lt; TARGET_TYPE &gt;&nbsp;</td>
          <td class="paramname"> <em>ref</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IMPLICIT: Create a managed pointer having the same target object as the managed pointer referenced by the specified <code>ref</code>, and transfer ownership of the managed object owned by the managed pointer referenced by <code>ref</code>, then reset the managed pointer referenced by <code>ref</code> as empty. This constructor is used to create a managed pointer from a managed pointer rvalue, or from a managed pointer to a "compatible" type, where "compatible" means a built-in conversion from <code>COMPATIBLE_TYPE *</code> to <code>TARGET_TYPE *</code> is defined, e.g., <code>derived *</code> -&gt; <code>base *</code>, <code>int *</code> -&gt; <code>const int *</code>, or <code>anyType *</code> -&gt; <code>void *</code>. </p>

</div>
</div>
<a class="anchor" id="adce03c94854b50fc2d35c6fd3f3a620e"></a><!-- doxytag: member="bslma::ManagedPtr::ManagedPtr" ref="adce03c94854b50fc2d35c6fd3f3a620e" args="(ManagedPtr&lt; ALIASED_TYPE &gt; &amp;alias, TARGET_TYPE *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ALIASED_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::<a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a>&lt; ALIASED_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a managed pointer that takes ownership of the object managed by the specified <code>alias</code>, but which uses the specified <code>ptr</code> to refer to its target object, unless <code>0 == ptr</code>, in which case create an empty managed pointer. Reset <code>alias</code> as empty if ownership of its managed object is transferred. The behavior is undefined if <code>alias</code> is empty, but <code>0 != ptr</code>. Note that destroying or re-assigning a managed pointer created with this constructor will destroy the object originally managed by <code>alias</code> (unless <code>release</code> is called first); the destructor for <code>*ptr</code> is not called directly. </p>

</div>
</div>
<a class="anchor" id="ae026c2418637882d81a523125a1cd738"></a><!-- doxytag: member="bslma::ManagedPtr::ManagedPtr" ref="ae026c2418637882d81a523125a1cd738" args="(MANAGED_TYPE *ptr, FACTORY_TYPE *factory)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class MANAGED_TYPE , class FACTORY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::<a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">MANAGED_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FACTORY_TYPE *&nbsp;</td>
          <td class="paramname"> <em>factory</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a managed pointer having a target object referenced by the specified <code>ptr</code>, owning the managed object <code>*ptr</code>, and having a deleter that will call <code>factory-&gt;deleteObject(ptr)</code> to destroy the managed object when invoked (e.g., when this managed pointer object is destroyed), unless <code>0 == ptr</code>, in which case create an empty managed pointer. The deleter will invoke the destructor of <code>MANAGED_TYPE</code> rather than the destructor of <code>TARGET_TYPE</code>. This constructor will not compile unless <code>MANAGED_TYPE *</code> is convertible to <code>TARGET_TYPE *</code>. The behavior is undefined unless the managed object (if any) can be destroyed by the specified <code>factory</code>, or if the the lifetime of the managed object is already managed by another object. Note that <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, and any class publicly and unambiguously derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, meets the requirements for <code>FACTORY_TYPE</code>. </p>

</div>
</div>
<a class="anchor" id="ad7696e213a5321f018f97a543d84df88"></a><!-- doxytag: member="bslma::ManagedPtr::ManagedPtr" ref="ad7696e213a5321f018f97a543d84df88" args="(bsl::nullptr_t, FACTORY_TYPE *factory)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class FACTORY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::<a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FACTORY_TYPE *&nbsp;</td>
          <td class="paramname"> <em>factory</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty managed pointer. Note that the specified <code>factory</code> is ignored, as an empty managed pointer does not call its deleter. </p>

</div>
</div>
<a class="anchor" id="a02c58a5028f61ca6b1eee4cfc438f941"></a><!-- doxytag: member="bslma::ManagedPtr::ManagedPtr" ref="a02c58a5028f61ca6b1eee4cfc438f941" args="(TARGET_TYPE *ptr, void *cookie, DeleterFunc deleter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::<a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr.html#afda656bd737f271d5457db053d145f32">DeleterFunc</a>&nbsp;</td>
          <td class="paramname"> <em>deleter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a managed pointer having a target object referenced by the specified <code>ptr</code>, owning the managed object <code>*ptr</code>, and having a deleter that will invoke the specified <code>deleter</code> with the address of the currently managed object, and with the specified <code>cookie</code> (that the deleter can use for its own purposes), unless <code>0 == ptr</code>, in which case create an empty managed pointer. This constructor will not compile unless <code>MANAGED_TYPE*</code> is convertible to <code>TARGET_TYPE*</code>. The deleter will invoke the destructor of <code>MANAGED_TYPE</code> rather than the destructor of <code>TARGET_TYPE</code>. The behavior is undefined if <code>ptr</code> is already managed by another object, or if <code>0 == deleter &amp;&amp; 0 != ptr</code>. Note that this declaration is required only because the deprecated overloads create an ambiguity in this case. It should be removed when the deprecated overloads are removed. </p>

</div>
</div>
<a class="anchor" id="aab16b52de709ca885e3af1ec6daf111d"></a><!-- doxytag: member="bslma::ManagedPtr::ManagedPtr" ref="aab16b52de709ca885e3af1ec6daf111d" args="(MANAGED_TYPE *ptr, void *cookie, DeleterFunc deleter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class MANAGED_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::<a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">MANAGED_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr.html#afda656bd737f271d5457db053d145f32">DeleterFunc</a>&nbsp;</td>
          <td class="paramname"> <em>deleter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a managed pointer having a target object referenced by the specified <code>ptr</code>, owning the managed object <code>*ptr</code>, and having a deleter that will invoke the specified <code>deleter</code> with the address of the currently managed object, and with the specified <code>cookie</code> (that the deleter can use for its own purposes), unless <code>0 == ptr</code>, in which case create an empty managed pointer. This constructor will not compile unless <code>MANAGED_TYPE*</code> is convertible to <code>TARGET_TYPE*</code>. The deleter will invoke the destructor of <code>MANAGED_TYPE</code> rather than the destructor of <code>TARGET_TYPE</code>. The behavior is undefined if <code>ptr</code> is already managed by another object, or if <code>0 == deleter &amp;&amp; 0 != ptr</code>. </p>

</div>
</div>
<a class="anchor" id="a4203395d11260ca98cac36cb2f396845"></a><!-- doxytag: member="bslma::ManagedPtr::~ManagedPtr" ref="a4203395d11260ca98cac36cb2f396845" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::~<a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this managed pointer object. Destroy the object managed by this managed pointer by invoking the user-supplied deleter, unless this managed pointer is empty, in which case the deleter will <em>not</em> be called. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a54d2e576e512511a2df0fdfeef1d11a9"></a><!-- doxytag: member="bslma::ManagedPtr::operator=" ref="a54d2e576e512511a2df0fdfeef1d11a9" args="(ManagedPtr &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a>&amp; <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a>&lt; TARGET_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this object and the specified <code>rhs</code> manage the same object, return a reference to this managed pointer; otherwise destroy the manged object owned by this managed pointer, then transfer ownership of the managed object owned by <code>rhs</code>, and set this managed pointer to point to the target object currently referenced by <code>rhs</code>, then reset <code>rhs</code> as empty, and return a reference to this managed pointer. </p>

</div>
</div>
<a class="anchor" id="a3205ad28d53a8f995f116052c90dea9a"></a><!-- doxytag: member="bslma::ManagedPtr::operator=" ref="a3205ad28d53a8f995f116052c90dea9a" args="(ManagedPtr_Ref&lt; TARGET_TYPE &gt; ref)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a>&amp; <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr__Ref.html">ManagedPtr_Ref</a>&lt; TARGET_TYPE &gt;&nbsp;</td>
          <td class="paramname"> <em>ref</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this object and the managed pointer reference by the specified <code>ref</code> manage the same object, return a reference to this managed pointer; otherwise destroy the manged object owned by this managed pointer, then transfer ownership of the managed object owned by the managed pointer referenced by <code>ref</code>, and set this managed pointer to point to the target object currently referenced the managed pointer referenced by <code>ref</code>; then reset the managed pointer referenced by <code>ref</code> as empty, and return a reference to this managed pointer. This operator is (implicitly) used to assign from a managed pointer rvalue, or from a managed pointer to a "compatible" type, where "compatible" means a built-in conversion from <code>MANAGED_TYPE *</code> to <code>TARGET_TYPE *</code> is defined, e.g., <code>derived *</code> -&gt; <code>base *</code>, <code>T *</code> -&gt; <code>const T *</code>, or <code>T *</code> -&gt; <code>void *</code>. </p>

</div>
</div>
<a class="anchor" id="a7279d025bfe24aa466e4b16847390b5b"></a><!-- doxytag: member="bslma::ManagedPtr::operator=" ref="a7279d025bfe24aa466e4b16847390b5b" args="(bsl::nullptr_t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a>&amp; <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the current managed object (if any) and reset this managed pointer as empty. </p>

</div>
</div>
<a class="anchor" id="a2abfbbbb9ed75f21b1d688477ecebf85"></a><!-- doxytag: member="bslma::ManagedPtr::operator ManagedPtr_Ref&lt; REFERENCED_TYPE &gt;" ref="a2abfbbbb9ed75f21b1d688477ecebf85" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class REFERENCED_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::operator <a class="el" href="classbslma_1_1ManagedPtr__Ref.html">ManagedPtr_Ref</a>&lt; REFERENCED_TYPE &gt; </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a managed pointer reference, referring to this object. Note that this conversion operator is used implicitly to allow the construction of managed pointers from rvalues because temporaries cannot be passed by references offering modifiable access. </p>

</div>
</div>
<a class="anchor" id="ab929c98b414c3feabd00d8e4430b60d1"></a><!-- doxytag: member="bslma::ManagedPtr::clear" ref="ab929c98b414c3feabd00d8e4430b60d1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>[!DEPRECATED!] Use <code>reset</code> instead.</p>
<p>Destroy the current managed object (if any) and reset this managed pointer as empty. </p>

</div>
</div>
<a class="anchor" id="a0eee37981ad3dee3ba6b4f3360a4b8c5"></a><!-- doxytag: member="bslma::ManagedPtr::load" ref="a0eee37981ad3dee3ba6b4f3360a4b8c5" args="(MANAGED_TYPE *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class MANAGED_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::load </td>
          <td>(</td>
          <td class="paramtype">MANAGED_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the currently managed object, if any. Then, set the target object of this managed pointer to be that referenced by the specified <code>ptr</code>, take ownership of <code>*ptr</code> as the currently managed object, and set a deleter that uses the currently installed default allocator to destroy the managed object when invoked (e.g., when this managed pointer object is destroyed), unless <code>0 == ptr</code>, in which case reset this managed pointer as empty. The deleter will invoke the destructor of <code>MANAGED_TYPE</code> rather than the destructor of <code>TARGET_TYPE</code>. This function will not compile unless <code>MANAGED_TYPE *</code> is convertible to <code>TARGET_TYPE *</code>. The behavior is undefined unless the managed object (if any) can be destroyed by the currently installed default allocator, or if the the lifetime of the managed object is already managed by another object. </p>

</div>
</div>
<a class="anchor" id="a073451ac2c66e6b7caaf794e553bfd34"></a><!-- doxytag: member="bslma::ManagedPtr::load" ref="a073451ac2c66e6b7caaf794e553bfd34" args="(MANAGED_TYPE *ptr, FACTORY_TYPE *factory)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class MANAGED_TYPE , class FACTORY_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::load </td>
          <td>(</td>
          <td class="paramtype">MANAGED_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FACTORY_TYPE *&nbsp;</td>
          <td class="paramname"> <em>factory</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the currently managed object, if any. Then, set the target object of this managed pointer to be that referenced by the specified <code>ptr</code>, take ownership of <code>*ptr</code> as the currently managed object, and set a deleter that calls <code>factory-&gt;deleteObject(ptr)</code> to destroy the managed object when invoked (e.g., when this managed pointer object is destroyed), unless <code>0 == ptr</code>, in which case reset this managed pointer as empty. The deleter will invoke the destructor of <code>MANAGED_TYPE</code> rather than the destructor of <code>TARGET_TYPE</code>. This function will not compile unless <code>MANAGED_TYPE *</code> is convertible to <code>TARGET_TYPE *</code>. The behavior is undefined unless the managed object (if any) can be destroyed by the specified <code>factory</code>, or if <code>0 == factory &amp;&amp; 0 != ptr</code>, or if the the lifetime of the managed object is already managed by another object. Note that <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, and any class publicly and unambiguously derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, meets the requirements for <code>FACTORY_TYPE</code>. </p>

</div>
</div>
<a class="anchor" id="a37203c128f2dea44b26d0e8ac2c85d70"></a><!-- doxytag: member="bslma::ManagedPtr::load" ref="a37203c128f2dea44b26d0e8ac2c85d70" args="(MANAGED_TYPE *ptr, void *cookie, DeleterFunc deleter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class MANAGED_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::load </td>
          <td>(</td>
          <td class="paramtype">MANAGED_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr.html#afda656bd737f271d5457db053d145f32">DeleterFunc</a>&nbsp;</td>
          <td class="paramname"> <em>deleter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the currently managed object, if any. Then, set the target object of this managed pointer to be that referenced by the specified <code>ptr</code>, take ownership of <code>*ptr</code> as the currently managed object, and set a deleter that will invoke the specified <code>deleter</code> with the address of the currently managed object, and with the specified <code>cookie</code> (that the deleter can use for its own purposes), unless <code>0 == ptr</code>, in which case reset this managed pointer as empty. The behavior is undefined if <code>ptr</code> is already managed by another object, or if <code>0 == deleter &amp;&amp; 0 != ptr</code>. Note that GCC 3.4 and earlier versions have a bug in template type deduction/overload resolution that causes ambiguities if this signature is available. This function will be restored on that platform once the deprecated signatures are finally removed. </p>

</div>
</div>
<a class="anchor" id="a17fc0ebc524eb94c90b06122e8e448eb"></a><!-- doxytag: member="bslma::ManagedPtr::load" ref="a17fc0ebc524eb94c90b06122e8e448eb" args="(bsl::nullptr_t=0, void *cookie=0, DeleterFunc deleter=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacebsl.html#a15d68a87901fa9543f847ada4ee76fd3">bsl::nullptr_t</a>&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr.html#afda656bd737f271d5457db053d145f32">DeleterFunc</a>&nbsp;</td>
          <td class="paramname"> <em>deleter</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the current managed object (if any) and reset this managed pointer as empty. Note that the optionally specified <code>cookie</code> and <code>deleter</code> will be ignored, as empty managed pointers do not invoke a deleter. </p>

</div>
</div>
<a class="anchor" id="acf50f35b32c6b2a8d6638d21fa2df9b8"></a><!-- doxytag: member="bslma::ManagedPtr::loadAlias" ref="acf50f35b32c6b2a8d6638d21fa2df9b8" args="(ManagedPtr&lt; ALIASED_TYPE &gt; &amp;alias, TARGET_TYPE *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class ALIASED_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::loadAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a>&lt; ALIASED_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the specified <code>alias</code> manages the same object as this managed pointer, set the target object of this managed pointer to be that referenced by the specified <code>ptr</code>; otherwise, destroy the currently managed object (if any), and if <code>alias</code> is empty, reset this managed pointer as empty, otherwise transfer ownership (and the deleter) of the object managed by <code>alias</code>, and set the target object of this managed pointer to be that referenced by <code>ptr</code>. The behavior is undefined if <code>0 == ptr</code> and <code>alias</code> is not empty, or if <code>0 != ptr</code> and <code>alias</code> is empty, or if <code>ptr</code> is already managed by a managed pointer other than <code>alias</code>. Note that this establishes a managed pointer where <code>ptr</code> aliases <code>alias</code>. The managed object for <code>alias</code> will ultimately be destroyed, and the destructor for <code>ptr</code> is not called directly. </p>

</div>
</div>
<a class="anchor" id="a826d9856966f92aefdbcc2ef2b019861"></a><!-- doxytag: member="bslma::ManagedPtr::release" ref="a826d9856966f92aefdbcc2ef2b019861" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbslma_1_1ManagedPtr__PairProxy.html">ManagedPtr_PairProxy</a>&lt;TARGET_TYPE, <a class="el" href="classbslma_1_1ManagedPtrDeleter.html">ManagedPtrDeleter</a>&gt; <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a raw pointer to the current target object (if any) and the deleter for the currently managed object, and reset this managed pointer as empty. It is undefined behavior to run the returned deleter unless the returned pointer to target object is not null. </p>

</div>
</div>
<a class="anchor" id="a6c1facdee268423bd611bc3e382ae1a9"></a><!-- doxytag: member="bslma::ManagedPtr::release" ref="a6c1facdee268423bd611bc3e382ae1a9" args="(ManagedPtrDeleter *deleter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TARGET_TYPE* <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtrDeleter.html">ManagedPtrDeleter</a> *&nbsp;</td>
          <td class="paramname"> <em>deleter</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load the specified <code>deleter</code> for the currently managed object and reset this managed pointer as empty. Return a raw pointer to the target object (if any) managed by this pointer. It is undefined behavior to run the returned deleter unless the returned pointer to target object is not null. </p>

</div>
</div>
<a class="anchor" id="af96bb8356e57e2ab6037d45f7f594d86"></a><!-- doxytag: member="bslma::ManagedPtr::reset" ref="af96bb8356e57e2ab6037d45f7f594d86" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the current managed object (if any) and reset this managed pointer as empty. </p>

</div>
</div>
<a class="anchor" id="a706df5bd259bd244636eae65003e858b"></a><!-- doxytag: member="bslma::ManagedPtr::swap" ref="a706df5bd259bd244636eae65003e858b" args="(ManagedPtr &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a>&lt; TARGET_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value and ownership of this managed pointer with the specified <code>other</code> managed pointer. </p>

</div>
</div>
<a class="anchor" id="a6178b46544d9621a32b623062d32a74f"></a><!-- doxytag: member="bslma::ManagedPtr::operator BoolType" ref="a6178b46544d9621a32b623062d32a74f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::operator BoolType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a value of "unspecified bool" type that evaluates to <code>false</code> if this managed pointer is empty, and <code>true</code> otherwise. Note that this conversion operator allows a managed pointer to be used within a conditional context, such as within an <code>if</code> or <code>while</code> statement, but does <em>not</em> allow managed pointers to be compared (e.g., via <code>&lt;</code> or <code>&gt;</code>). Note that a superior solution is available in C++11 using the <code>explicit operator bool()</code> syntax, that removes the need for a special boolean-like type and private equality comparison operators. </p>

</div>
</div>
<a class="anchor" id="ad8629f0fbe9ae3088e9c07069a548b8f"></a><!-- doxytag: member="bslma::ManagedPtr::operator*" ref="ad8629f0fbe9ae3088e9c07069a548b8f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbslmf_1_1AddReference.html">bslmf::AddReference</a>&lt;TARGET_TYPE&gt;::Type <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the target object. The behavior is undefined if this managed pointer is empty, or if <code>TARGET_TYPE</code> is <code>void</code> or <code>const void</code>. </p>

</div>
</div>
<a class="anchor" id="a7a985054043e5ac19a51b6db8f4f4f6f"></a><!-- doxytag: member="bslma::ManagedPtr::operator&#45;&gt;" ref="a7a985054043e5ac19a51b6db8f4f4f6f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TARGET_TYPE* <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the target object, or 0 if this managed pointer is empty. </p>

</div>
</div>
<a class="anchor" id="a3d979e298134421c44100723dadc56fd"></a><!-- doxytag: member="bslma::ManagedPtr::deleter" ref="a3d979e298134421c44100723dadc56fd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbslma_1_1ManagedPtrDeleter.html">ManagedPtrDeleter</a>&amp; <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::deleter </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable deleter information associated with this managed pointer. Behavior is undefined if this managed pointer is empty. </p>

</div>
</div>
<a class="anchor" id="a83325a674a64bd8c45607d2822df0d8e"></a><!-- doxytag: member="bslma::ManagedPtr::get" ref="a83325a674a64bd8c45607d2822df0d8e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TARGET_TYPE* <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the target object, or 0 if this managed pointer is empty. </p>

</div>
</div>
<a class="anchor" id="a806661d834efd84fb953db1c69d5fb53"></a><!-- doxytag: member="bslma::ManagedPtr::ptr" ref="a806661d834efd84fb953db1c69d5fb53" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TARGET_TYPE* <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; TARGET_TYPE &gt;::ptr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>[!DEPRECATED!]: Use <code>get</code> instead.</p>
<p>Return the address of the target object, or 0 if this managed pointer is empty. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="aae3e51c1ec8b8048bfc4e29453966a63"></a><!-- doxytag: member="bslma::ManagedPtr::ManagedPtr" ref="aae3e51c1ec8b8048bfc4e29453966a63" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classbslma_1_1ManagedPtr.html">ManagedPtr</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>required only for alias support </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslma__managedptr_8h_source.html">bslma_managedptr.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:34 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
