<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlde_utf8util Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlde_utf8util<br/>
<small>
[<a class="el" href="group__bdlde.html">Package bdlde</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide basic utilities for UTF-8 encodings.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlde.html">bdlde</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Validating Strings and Counting Unicode Code Points</a> </li>
<li>
<a href="#3.1.2">Example 2: Advancing Code Points</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide basic utilities for UTF-8 encodings. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbdlde_1_1Utf8Util.html">bdlde::Utf8Util</a> </td><td>namespace for utilities for UTF-8 encodings  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides, within the <code><a class="el" href="structbdlde_1_1Utf8Util.html">bdlde::Utf8Util</a></code> <code>struct</code>, a suite of static functions supporting UTF-8 encoded strings. Two interfaces are provided for each function, one where the length of the string (in <em>bytes</em>) is passed as a separate argument, and one where the string is passed as a null-terminated C-style string. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A string is deemed to contain valid UTF-8 if it is compliant with RFC 3629, meaning that only 1-, 2-, 3-, and 4-byte sequences are allowed. Values above <code>U+10ffff</code> are also not allowed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Three types of functions are provided: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
<code>isValid</code>, which checks for validity, per RFC 3629, of a (candidate) UTF-8 string. "Overlong values", that is, values encoded in more bytes than necessary, are not tolerated; nor are "surrogate values", which are values in the range <code>[U+d800 .. U+dfff]</code>.  </li>
<li>
<code>advanceIfValid</code> and <code>advanceRaw</code>, which advance some number of Unicode code points, each of which may be encoded in multiple bytes in a UTF-8 string. <code>advanceRaw</code> assumes the string is valid UTF-8, while <code>advanceIfValid</code> checks the input for validity and stops advancing if a sequence is encountered that is not valid UTF-8.  </li>
<li>
<code>numCodePointsIfValid</code> and <code>numCodePointsRaw</code>, which return the number of Unicode code points in a UTF-8 string. Note that <code>numCodePointsIfValid</code> both validates a (candidate) UTF-8 string and counts the number of Unicode code points that it contains.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Embedded null bytes are allowed in strings that are accompanied by an explicit length argument. Naturally, null-terminated C-style strings cannot contain embedded null code points. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The UTF-8 format is described in the RFC 3629 document at: <br/>
<br/>
<div class="fragment"><pre class="fragment">  http:<span class="comment">//tools.ietf.org/html/rfc3629</span>
</pre></div><br/>
<br/>
 and in Wikipedia at: <br/>
<br/>
<div class="fragment"><pre class="fragment">  http:<span class="comment">//en.wikipedia.org/wiki/Utf-8</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_validating_strings_and_counting_unicode_code_points"></a> <a class="anchor" id="usage.example_1~3A_validating_strings_and_counting_unicode_code_points"></a> <a class="anchor" id="description.usage.example_1~3A_validating_strings_and_counting_unicode_code_points"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Validating Strings and Counting Unicode Code Points: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this usage example, we will encode some Unicode code points in UTF-8 strings and demonstrate which ones are valid and which ones are not. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we build an unquestionably valid UTF-8 string: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> string;
  utf8Append(&amp;<span class="keywordtype">string</span>, 0xff00);
  utf8Append(&amp;<span class="keywordtype">string</span>, 0x856);
  utf8Append(&amp;<span class="keywordtype">string</span>, <span class="charliteral">&#39;a&#39;</span>);
  utf8Append(&amp;<span class="keywordtype">string</span>, 0x1008aa);
  utf8Append(&amp;<span class="keywordtype">string</span>, 0xfff);
  utf8Append(&amp;<span class="keywordtype">string</span>, <span class="charliteral">&#39;w&#39;</span>);
  utf8Append(&amp;<span class="keywordtype">string</span>, 0x1abcd);
  utf8Append(&amp;<span class="keywordtype">string</span>, <span class="charliteral">&#39;.&#39;</span>);
  utf8Append(&amp;<span class="keywordtype">string</span>, <span class="charliteral">&#39;\n&#39;</span>);
</pre></div><br/>
<br/>
 Then, we check its validity and measure its length: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<span class="keyword">true</span> == <a class="code" href="structbdlde_1_1Utf8Util.html#a6872ed1f090c6d55b2afd05f705a3f9d">bdlde::Utf8Util::isValid</a>(<span class="keywordtype">string</span>.data(), <span class="keywordtype">string</span>.length()));
  assert(<span class="keyword">true</span> == <a class="code" href="structbdlde_1_1Utf8Util.html#a6872ed1f090c6d55b2afd05f705a3f9d">bdlde::Utf8Util::isValid</a>(<span class="keywordtype">string</span>.c_str()));

  assert(   9 == <a class="code" href="structbdlde_1_1Utf8Util.html#a9311f1d8f031e8cef368c4fa207fed07">bdlde::Utf8Util::numCodePointsRaw</a>(<span class="keywordtype">string</span>.data(),
                                                   <span class="keywordtype">string</span>.length()));
  assert(   9 == <a class="code" href="structbdlde_1_1Utf8Util.html#a9311f1d8f031e8cef368c4fa207fed07">bdlde::Utf8Util::numCodePointsRaw</a>(<span class="keywordtype">string</span>.c_str()));
</pre></div><br/>
<br/>
 Next, we encode a lone surrogate value, which is not allowed: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> stringWithSurrogate = string;
  utf8Append(&amp;stringWithSurrogate, 0xd8ab);
</pre></div><br/>
<br/>
 assert(false == <a class="el" href="structbdlde_1_1Utf8Util.html#a6872ed1f090c6d55b2afd05f705a3f9d">bdlde::Utf8Util::isValid</a>(stringWithSurrogate.data(), stringWithSurrogate.length())); assert(false == <a class="el" href="structbdlde_1_1Utf8Util.html#a6872ed1f090c6d55b2afd05f705a3f9d">bdlde::Utf8Util::isValid</a>(stringWithSurrogate.c_str())); <br/>
<br/>
<div class="fragment"><pre class="fragment"> Then, we cannot use <span class="stringliteral">&#39;numCodePointsRaw&#39;</span> to count the code points in
 <span class="stringliteral">&#39;stringWithSurrogate&#39;</span>, since the behavior of that method is undefined unless
 the <span class="keywordtype">string</span> is valid.  Instead, the <span class="stringliteral">&#39;numCodePointsIfValid&#39;</span> method can be used
 on strings whose validity we are uncertain of:
</pre></div><br/>
<br/>
 const char *invalidPosition = 0; </dd></dl>
<dl class="user"><dt><b></b></dt><dd>assert(-1 == <a class="el" href="structbdlde_1_1Utf8Util.html#ab1944729545e10b34e5f1e69152aed5f">bdlde::Utf8Util::numCodePointsIfValid</a>( &amp;invalidPosition, stringWithSurrogate.data(), stringWithSurrogate.length())); assert(invalidPosition == stringWithSurrogate.data() + string.length()); </dd></dl>
<dl class="user"><dt><b></b></dt><dd>invalidPosition = 0; // reset </dd></dl>
<dl class="user"><dt><b></b></dt><dd>assert(-1 == <a class="el" href="structbdlde_1_1Utf8Util.html#ab1944729545e10b34e5f1e69152aed5f">bdlde::Utf8Util::numCodePointsIfValid</a>( &amp;invalidPosition, stringWithSurrogate.c_str())); assert(invalidPosition == stringWithSurrogate.data() + string.length()); <br/>
<br/>
<div class="fragment"><pre class="fragment"> Now, we encode 0, which is allowed.  However, note that we cannot use any
 interfaces that take a null-terminated <span class="keywordtype">string</span> <span class="keywordflow">for</span> <span class="keyword">this</span> <span class="keywordflow">case</span>:
</pre></div><br/>
<br/>
 bsl::string stringWithNull = string; utf8AppendOneByte(&amp;stringWithNull, 0); <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<span class="keyword">true</span> == <a class="code" href="structbdlde_1_1Utf8Util.html#a6872ed1f090c6d55b2afd05f705a3f9d">bdlde::Utf8Util::isValid</a>(stringWithNull.data(),
                                          stringWithNull.length()));

  assert(  10 == <a class="code" href="structbdlde_1_1Utf8Util.html#a9311f1d8f031e8cef368c4fa207fed07">bdlde::Utf8Util::numCodePointsRaw</a>(stringWithNull.data(),
                                                   stringWithNull.length()));
</pre></div><br/>
<br/>
 Finally, we encode <code>0x61</code> (<code>a</code>) as an overlong value using 2 bytes, which is not valid UTF-8 (since <code>a</code> can be "encoded" in 1 byte): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> stringWithOverlong = string;
  utf8AppendTwoBytes(&amp;stringWithOverlong, <span class="charliteral">&#39;a&#39;</span>);

  assert(<span class="keyword">false</span> == <a class="code" href="structbdlde_1_1Utf8Util.html#a6872ed1f090c6d55b2afd05f705a3f9d">bdlde::Utf8Util::isValid</a>(stringWithOverlong.<a class="code" href="group__bslstl__string.html#gae34ea0881e46716098b4a684ed41e136">data</a>(),
                                           stringWithOverlong.<a class="code" href="group__bslstl__string.html#ga3c33f63f9d195be7499bd2f7cdb085ff">length</a>()));
  assert(<span class="keyword">false</span> == <a class="code" href="structbdlde_1_1Utf8Util.html#a6872ed1f090c6d55b2afd05f705a3f9d">bdlde::Utf8Util::isValid</a>(stringWithOverlong.<a class="code" href="group__bslstl__string.html#gacef38ff51dcfc556fa13dda42a2665df">c_str</a>()));
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_advancing_code_points"></a> <a class="anchor" id="usage.example_2~3A_advancing_code_points"></a> <a class="anchor" id="description.usage.example_2~3A_advancing_code_points"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Advancing Code Points: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we will use the various <code>advance</code> functions to advance through a UTF-8 string. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, build the string using <code>utf8Append</code>, keeping track of how many bytes are in each Unicode code point: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> string;
  utf8Append(&amp;<span class="keywordtype">string</span>, 0xff00);        <span class="comment">// 3 bytes</span>
  utf8Append(&amp;<span class="keywordtype">string</span>, 0x1ff);         <span class="comment">// 2 bytes</span>
  utf8Append(&amp;<span class="keywordtype">string</span>, <span class="charliteral">&#39;a&#39;</span>);           <span class="comment">// 1 byte</span>
  utf8Append(&amp;<span class="keywordtype">string</span>, 0x1008aa);      <span class="comment">// 4 bytes</span>
  utf8Append(&amp;<span class="keywordtype">string</span>, 0x1abcd);       <span class="comment">// 4 bytes</span>
  <span class="keywordtype">string</span> += <span class="stringliteral">&quot;\xe3\x8f\xfe&quot;</span>;           <span class="comment">// 3 bytes (invalid 3-byte sequence,</span>
 the first 2 bytes are valid but the
 last continuation byte is invalid)
  utf8Append(&amp;<span class="keywordtype">string</span>, <span class="charliteral">&#39;w&#39;</span>);           <span class="comment">// 1 byte</span>
  utf8Append(&amp;<span class="keywordtype">string</span>, <span class="charliteral">&#39;\n&#39;</span>);          <span class="comment">// 1 byte</span>
</pre></div><br/>
<br/>
 Then, declare a few variables we'll need: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> rc, status;
  <span class="keyword">const</span> <span class="keywordtype">char</span> *result;
  <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> start = <span class="keywordtype">string</span>.c_str();
</pre></div><br/>
<br/>
 Next, try advancing 2 code points, then 3, then 4, observing that the value returned is the number of Unicode code points advanced. Note that since we're only advancing over valid UTF-8, we can use either <code>advanceRaw</code> or <code>advanceIfValid</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  rc = <a class="code" href="structbdlde_1_1Utf8Util.html#a9d29fd59f70ba1252f5b5c0f1cac7adb">bdlde::Utf8Util::advanceRaw</a>(              &amp;result, start, 2);
  assert(2 == rc);
  assert(3 + 2 == result - start);

  rc = <a class="code" href="structbdlde_1_1Utf8Util.html#a8341fc531de02b1da2493d7500d90b73">bdlde::Utf8Util::advanceIfValid</a>(&amp;status, &amp;result, start, 2);
  assert(0 == status);
  assert(2 == rc);
  assert(3 + 2 == result - start);

  rc = <a class="code" href="structbdlde_1_1Utf8Util.html#a9d29fd59f70ba1252f5b5c0f1cac7adb">bdlde::Utf8Util::advanceRaw</a>(             &amp;result, start, 3);
  assert(0 == status);
  assert(3 == rc);
  assert(3 + 2 + 1 == result - start);

  rc = <a class="code" href="structbdlde_1_1Utf8Util.html#a8341fc531de02b1da2493d7500d90b73">bdlde::Utf8Util::advanceIfValid</a>(&amp;status, &amp;result, start, 3);
  assert(0 == status);
  assert(3 == rc);
  assert(3 + 2 + 1 == result - start);

  rc = <a class="code" href="structbdlde_1_1Utf8Util.html#a9d29fd59f70ba1252f5b5c0f1cac7adb">bdlde::Utf8Util::advanceRaw</a>(             &amp;result, start, 4);
  assert(4 == rc);
  assert(3 + 2 + 1 + 4 == result - start);

  rc = <a class="code" href="structbdlde_1_1Utf8Util.html#a8341fc531de02b1da2493d7500d90b73">bdlde::Utf8Util::advanceIfValid</a>(&amp;status, &amp;result, start, 4);
  assert(0 == status);
  assert(4 == rc);
  assert(3 + 2 + 1 + 4 == result - start);
</pre></div><br/>
<br/>
 Then, try advancing by more code points than are present using <code>advanceIfValid</code>, and wind up stopping when we encounter invalid input. The behavior of <code>advanceRaw</code> is undefined if it is used on invalid input, so we cannot use it here. Also note that we will stop at the beginning of the invalid Unicode code point, and not at the first incorrect byte, which is two bytes later: <br/>
<br/>
<div class="fragment"><pre class="fragment">  rc = <a class="code" href="structbdlde_1_1Utf8Util.html#a8341fc531de02b1da2493d7500d90b73">bdlde::Utf8Util::advanceIfValid</a>(&amp;status, &amp;result, start, INT_MAX);
  assert(0 != status);
  assert(5 == rc);
  assert(3 + 2 + 1 + 4 + 4                 == result - start);
  assert(static_cast&lt;int&gt;(<span class="keywordtype">string</span>.length()) &gt;  result - start);
</pre></div><br/>
<br/>
 Now, doctor the string to replace the invalid code point with a valid one, so the string is entirely correct UTF-8: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">string</span>[3 + 2 + 1 + 4 + 4 + 2] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(0x8a);
</pre></div><br/>
<br/>
 Finally, advance using both functions by more code points than are in the string and in both cases wind up at the end of the string. Note that <code>advanceIfValid</code> does not return an error (non-zero) value to <code>status</code> when it encounters the end of the string: <br/>
<br/>
<div class="fragment"><pre class="fragment">  rc = <a class="code" href="structbdlde_1_1Utf8Util.html#a9d29fd59f70ba1252f5b5c0f1cac7adb">bdlde::Utf8Util::advanceRaw</a>(             &amp;result, start, INT_MAX);
  assert(8 == rc);
  assert(3 + 2 + 1 + 4 + 4 + 3 + 1 + 1     == result - start);
  assert(static_cast&lt;int&gt;(<span class="keywordtype">string</span>.length()) == result - start);

  rc = <a class="code" href="structbdlde_1_1Utf8Util.html#a8341fc531de02b1da2493d7500d90b73">bdlde::Utf8Util::advanceIfValid</a>(&amp;status, &amp;result, start, INT_MAX);
  assert(0 == status);
  assert(8 == rc);
  assert(3 + 2 + 1 + 4 + 4 + 3 + 1 + 1     == result - start);
  assert(static_cast&lt;int&gt;(<span class="keywordtype">string</span>.length()) == result - start);
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:43 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
