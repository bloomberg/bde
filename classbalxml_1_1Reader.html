<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class balxml::Reader</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebalxml.html">balxml</a>      </li>
      <li><a class="el" href="classbalxml_1_1Reader.html">balxml::Reader</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>balxml::Reader Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="balxml::Reader" -->
<p><code>#include &lt;<a class="el" href="balxml__reader_8h_source.html">balxml_reader.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for balxml::Reader:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbalxml_1_1Reader.png" usemap="#balxml::Reader_map" alt=""/>
  <map id="balxml::Reader_map" name="balxml::Reader_map">
<area href="classbalxml_1_1MiniReader.html" alt="balxml::MiniReader" shape="rect" coords="0,56,150,80"/>
<area href="classbalxml_1_1ValidatingReader.html" alt="balxml::ValidatingReader" shape="rect" coords="160,56,310,80"/>
</map>
</div>

<p><a href="classbalxml_1_1Reader-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3">NodeType</a> { <br/>
&nbsp;&nbsp;<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3aaacc94f51f70bf96fffaf97d8d881d7d">e_NODE_TYPE_NONE</a> =  0, 
<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3a678d1d09a9c4cf1a4792bfe06322ca33">e_NODE_TYPE_ELEMENT</a> =  1, 
<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3a438400044360fcbf61af5a448799a562">e_NODE_TYPE_TEXT</a> =  2, 
<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3a039d72aefc7fa85159272c439be0cf86">e_NODE_TYPE_CDATA</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3ae52e65963e1f3f712f8376722de62981">e_NODE_TYPE_ENTITY_REFERENCE</a> =  4, 
<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3a10988a1b6babad2dff4b03285e9de915">e_NODE_TYPE_ENTITY</a> =  5, 
<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3a96d16ed474f30f5a4e917577217e956e">e_NODE_TYPE_PROCESSING_INSTRUCTION</a> =  6, 
<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3af00ad190b2e5d381da57f7cf10729115">e_NODE_TYPE_COMMENT</a> =  7, 
<br/>
&nbsp;&nbsp;<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3ac72d6704fe20dea7e4afafe6a26f3bf4">e_NODE_TYPE_DOCUMENT</a> =  8, 
<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3a3240e2cfeef77bfe0f0deb1b7f05b213">e_NODE_TYPE_DOCUMENT_TYPE</a> =  9, 
<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3a6274bbc243e09bb94b11eb0ba48f8d82">e_NODE_TYPE_DOCUMENT_FRAGMENT</a> =  10, 
<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3a92e38a8dfd5f79ca002f85e378b1a033">e_NODE_TYPE_NOTATION</a> =  11, 
<br/>
&nbsp;&nbsp;<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3a8139581378c8664949514732ebce9719">e_NODE_TYPE_WHITESPACE</a> =  12, 
<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3a805792741c93fa89da23173d03a600c3">e_NODE_TYPE_SIGNIFICANT_WHITESPACE</a> =  13, 
<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3ae55356b6948b5ce8f36eebc4fdb516ec">e_NODE_TYPE_END_ELEMENT</a> =  14, 
<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3acb3cdf96b7bd19c14406f30b90ed9b0d">e_NODE_TYPE_END_ENTITY</a> =  15, 
<br/>
&nbsp;&nbsp;<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3a6f984f75fdfe29a73da64783d4496026">e_NODE_TYPE_XML_DECLARATION</a> =  16
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a><br class="typebreak"/>
&lt; bsl::streambuf &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a4670ff0cf5c1a1ed23f0ea655979c660">StreamBufPtr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function<br class="typebreak"/>
&lt; <a class="el" href="classbslma_1_1ManagedPtr.html">StreamBufPtr</a>(const char <br class="typebreak"/>
*location, const char <br class="typebreak"/>
*namespaceUri)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#ab7e056f9c4efa21874ddcf9314140575">XmlResolverFunctor</a> )</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a0bb724e39a0e7175a2e0c96bed634956">~Reader</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#abdc693b017b613505aff63eb6badd80a">dumpNode</a> (bsl::ostream &amp;os) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#ade79af54564096a1e4f7d904115460b6">isFatalError</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a057c0ab7fdc0025e7857033df185af76">isError</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a796db0a12836250c8882ff55d9bfe903">isWarning</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a17099694cfbee74686c799fc3a68883b">setPrefixStack</a> (<a class="el" href="classbalxml_1_1PrefixStack.html">PrefixStack</a> *prefixes)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a65e0d2af41eec4d5b735bcf5003abe1a">setResolver</a> (<a class="el" href="classbalxml_1_1Reader.html#ab7e056f9c4efa21874ddcf9314140575">XmlResolverFunctor</a> resolver)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a4e2febd7c2f865970e5abad75a71fdf4">open</a> (const char *filename, const char *encoding=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#ac8a8a9c0218f647f423af95d302b150d">open</a> (const char *buffer, bsl::size_t size, const char *url=0, const char *encoding=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a3f6f67c57c66b6f98a121be5562189b0">open</a> (bsl::streambuf *stream, const char *url=0, const char *encoding=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a09e572709808938f96034cf10d20ec41">close</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a277ab8dd9f06507b115b96e39002faf7">advanceToNextNode</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a95fec9fda7e752a1b44d0ef90673c5a7">lookupAttribute</a> (<a class="el" href="classbalxml_1_1ElementAttribute.html">ElementAttribute</a> *attribute, int index) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a94fc47d06c060a995136a2ab419f0c06">lookupAttribute</a> (<a class="el" href="classbalxml_1_1ElementAttribute.html">ElementAttribute</a> *attribute, const char *qname) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a5a68fca3c867dc550459713a91b1e2ad">lookupAttribute</a> (<a class="el" href="classbalxml_1_1ElementAttribute.html">ElementAttribute</a> *attribute, const char *localName, const char *namespaceUri) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a57d723428bc1a40f5cf41746102fbbee">lookupAttribute</a> (<a class="el" href="classbalxml_1_1ElementAttribute.html">ElementAttribute</a> *attribute, const char *localName, int namespaceId) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a580a2e6d82feb20c252aa4853c345dab">setOptions</a> (unsigned int flags)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a1d9d3e5ede19671b54d2c12257a19cef">documentEncoding</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbalxml_1_1Reader.html#ab7e056f9c4efa21874ddcf9314140575">XmlResolverFunctor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a6508f1ecc9a55b00b1e50411c69c4cd0">resolver</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a4ed721a98ef8a61c2f2a85bd21c246b8">isOpen</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classbalxml_1_1ErrorInfo.html">ErrorInfo</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#abcc1bf177fe83320f7a8801838708967">errorInfo</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#aad034b14046b07e3904ba03f9e980f6f">getLineNumber</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#ab429efa2e6c44a70f003f3bf2ab7fc33">getColumnNumber</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbalxml_1_1PrefixStack.html">PrefixStack</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#af0e9dbf0604ca07e58cd5357f9e8fe23">prefixStack</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3">NodeType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a4b4d7656699f1c66fc052e753f2a19dc">nodeType</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#ae3854574e8ca51c846da858bc089e4a6">nodeName</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#ab007e9b5153425add355772a2d1fab7c">nodeLocalName</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#ac75ea2445343b44e765f6c240dc12f07">nodePrefix</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#af1b43ad6d72ccde7e8d8e899b1c85bfa">nodeNamespaceId</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#afd9165e1fc132731ea65f54d17497fcc">nodeNamespaceUri</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a0c9764ebd80a3beee651d44c3686a744">nodeBaseUri</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#abbe9b9bba50315cda46bf5da6139a8ac">nodeHasValue</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#af446508cd5cc4caf9202c20297802a9d">nodeValue</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a60ad6509d81b74dc24809796fed720fb">nodeDepth</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#afd4b002d0859bc45b28e8a140640ba65">numAttributes</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a09187382bd2b82e46743de5fc6670ffc">isEmptyElement</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a60cb69fc512b4592fe99022df99f4b2a">options</a> () const =0</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbalxml_1_1Reader.html#a62b917e5b4aecd944e1d6c129af8937a">nodeTypeAsString</a> (<a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3">NodeType</a> nodeType)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This abstract class defines an interface for fast, forward-only access to XML data. An object belonging to a derived-class implementation of this protocol is required to be re-usable, such that a new XML document can be parsed using the same reader object by calling <code>close</code> followed by another <code>open</code>. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a4670ff0cf5c1a1ed23f0ea655979c660"></a><!-- doxytag: member="balxml::Reader::StreamBufPtr" ref="a4670ff0cf5c1a1ed23f0ea655979c660" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt;bsl::streambuf&gt; <a class="el" href="classbslma_1_1ManagedPtr.html">balxml::Reader::StreamBufPtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab7e056f9c4efa21874ddcf9314140575"></a><!-- doxytag: member="balxml::Reader::XmlResolverFunctor" ref="ab7e056f9c4efa21874ddcf9314140575" args=")" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;<a class="el" href="classbslma_1_1ManagedPtr.html">StreamBufPtr</a>(const char *location, const char *namespaceUri) <a class="el" href="classbalxml_1_1Reader.html#ab7e056f9c4efa21874ddcf9314140575">balxml::Reader::XmlResolverFunctor</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type for a user supplied functor that finds and opens an external resource for the specified <code>location</code> and/or <code>namespaceUri</code> and returns that resource as a managed pointer to a stream. The <code>location</code> argument specifies the location of the external resource and is typically a filename or a URI, depending on the context. The <code>namespaceUri</code> argument always refers to the XML namespace of the entity to be resolved. A conforming functor returns an empty managed pointer if it cannot resolve the resource. For example, the reader may use a resolver to open an external entity, even if the reader does not do validation (see definition of <code>&lt;!ENTITY&gt;</code> in the XML standard). Note that either argument can be NULL in situations where its value is not needed or can be computed from the other argument. </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a96d821892acdd3b8565421be14c438f3"></a><!-- doxytag: member="balxml::Reader::NodeType" ref="a96d821892acdd3b8565421be14c438f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3">balxml::Reader::NodeType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Node types, returned by <code>nodeType</code> method, which represent a XML syntactic construct within a document. Note: Not every implementation of <code><a class="el" href="classbalxml_1_1Reader.html">Reader</a></code> will distinguish among all of the node types. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3aaacc94f51f70bf96fffaf97d8d881d7d"></a><!-- doxytag: member="e_NODE_TYPE_NONE" ref="a96d821892acdd3b8565421be14c438f3aaacc94f51f70bf96fffaf97d8d881d7d" args="" -->e_NODE_TYPE_NONE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3a678d1d09a9c4cf1a4792bfe06322ca33"></a><!-- doxytag: member="e_NODE_TYPE_ELEMENT" ref="a96d821892acdd3b8565421be14c438f3a678d1d09a9c4cf1a4792bfe06322ca33" args="" -->e_NODE_TYPE_ELEMENT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3a438400044360fcbf61af5a448799a562"></a><!-- doxytag: member="e_NODE_TYPE_TEXT" ref="a96d821892acdd3b8565421be14c438f3a438400044360fcbf61af5a448799a562" args="" -->e_NODE_TYPE_TEXT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3a039d72aefc7fa85159272c439be0cf86"></a><!-- doxytag: member="e_NODE_TYPE_CDATA" ref="a96d821892acdd3b8565421be14c438f3a039d72aefc7fa85159272c439be0cf86" args="" -->e_NODE_TYPE_CDATA</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3ae52e65963e1f3f712f8376722de62981"></a><!-- doxytag: member="e_NODE_TYPE_ENTITY_REFERENCE" ref="a96d821892acdd3b8565421be14c438f3ae52e65963e1f3f712f8376722de62981" args="" -->e_NODE_TYPE_ENTITY_REFERENCE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3a10988a1b6babad2dff4b03285e9de915"></a><!-- doxytag: member="e_NODE_TYPE_ENTITY" ref="a96d821892acdd3b8565421be14c438f3a10988a1b6babad2dff4b03285e9de915" args="" -->e_NODE_TYPE_ENTITY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3a96d16ed474f30f5a4e917577217e956e"></a><!-- doxytag: member="e_NODE_TYPE_PROCESSING_INSTRUCTION" ref="a96d821892acdd3b8565421be14c438f3a96d16ed474f30f5a4e917577217e956e" args="" -->e_NODE_TYPE_PROCESSING_INSTRUCTION</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3af00ad190b2e5d381da57f7cf10729115"></a><!-- doxytag: member="e_NODE_TYPE_COMMENT" ref="a96d821892acdd3b8565421be14c438f3af00ad190b2e5d381da57f7cf10729115" args="" -->e_NODE_TYPE_COMMENT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3ac72d6704fe20dea7e4afafe6a26f3bf4"></a><!-- doxytag: member="e_NODE_TYPE_DOCUMENT" ref="a96d821892acdd3b8565421be14c438f3ac72d6704fe20dea7e4afafe6a26f3bf4" args="" -->e_NODE_TYPE_DOCUMENT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3a3240e2cfeef77bfe0f0deb1b7f05b213"></a><!-- doxytag: member="e_NODE_TYPE_DOCUMENT_TYPE" ref="a96d821892acdd3b8565421be14c438f3a3240e2cfeef77bfe0f0deb1b7f05b213" args="" -->e_NODE_TYPE_DOCUMENT_TYPE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3a6274bbc243e09bb94b11eb0ba48f8d82"></a><!-- doxytag: member="e_NODE_TYPE_DOCUMENT_FRAGMENT" ref="a96d821892acdd3b8565421be14c438f3a6274bbc243e09bb94b11eb0ba48f8d82" args="" -->e_NODE_TYPE_DOCUMENT_FRAGMENT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3a92e38a8dfd5f79ca002f85e378b1a033"></a><!-- doxytag: member="e_NODE_TYPE_NOTATION" ref="a96d821892acdd3b8565421be14c438f3a92e38a8dfd5f79ca002f85e378b1a033" args="" -->e_NODE_TYPE_NOTATION</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3a8139581378c8664949514732ebce9719"></a><!-- doxytag: member="e_NODE_TYPE_WHITESPACE" ref="a96d821892acdd3b8565421be14c438f3a8139581378c8664949514732ebce9719" args="" -->e_NODE_TYPE_WHITESPACE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3a805792741c93fa89da23173d03a600c3"></a><!-- doxytag: member="e_NODE_TYPE_SIGNIFICANT_WHITESPACE" ref="a96d821892acdd3b8565421be14c438f3a805792741c93fa89da23173d03a600c3" args="" -->e_NODE_TYPE_SIGNIFICANT_WHITESPACE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3ae55356b6948b5ce8f36eebc4fdb516ec"></a><!-- doxytag: member="e_NODE_TYPE_END_ELEMENT" ref="a96d821892acdd3b8565421be14c438f3ae55356b6948b5ce8f36eebc4fdb516ec" args="" -->e_NODE_TYPE_END_ELEMENT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3acb3cdf96b7bd19c14406f30b90ed9b0d"></a><!-- doxytag: member="e_NODE_TYPE_END_ENTITY" ref="a96d821892acdd3b8565421be14c438f3acb3cdf96b7bd19c14406f30b90ed9b0d" args="" -->e_NODE_TYPE_END_ENTITY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a96d821892acdd3b8565421be14c438f3a6f984f75fdfe29a73da64783d4496026"></a><!-- doxytag: member="e_NODE_TYPE_XML_DECLARATION" ref="a96d821892acdd3b8565421be14c438f3a6f984f75fdfe29a73da64783d4496026" args="" -->e_NODE_TYPE_XML_DECLARATION</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0bb724e39a0e7175a2e0c96bed634956"></a><!-- doxytag: member="balxml::Reader::~Reader" ref="a0bb724e39a0e7175a2e0c96bed634956" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual balxml::Reader::~Reader </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. The implementation for this pure abstract base class does nothing. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a62b917e5b4aecd944e1d6c129af8937a"></a><!-- doxytag: member="balxml::Reader::nodeTypeAsString" ref="a62b917e5b4aecd944e1d6c129af8937a" args="(NodeType nodeType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const char* balxml::Reader::nodeTypeAsString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3">NodeType</a>&nbsp;</td>
          <td class="paramname"> <em>nodeType</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a string representation for the specified <code>nodeType</code> code or "(* UNKNOWN NODE TYPE *)" if <code>nodeType</code> is not one of the values enumerated in <code>NodeType</code>. </p>

</div>
</div>
<a class="anchor" id="abdc693b017b613505aff63eb6badd80a"></a><!-- doxytag: member="balxml::Reader::dumpNode" ref="abdc693b017b613505aff63eb6badd80a" args="(bsl::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void balxml::Reader::dumpNode </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print the information about the current node to the specified output <code>os</code> stream. </p>

</div>
</div>
<a class="anchor" id="ade79af54564096a1e4f7d904115460b6"></a><!-- doxytag: member="balxml::Reader::isFatalError" ref="ade79af54564096a1e4f7d904115460b6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool balxml::Reader::isFatalError </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the derived object encountered a fatal error. This method is equivalent to a call to <code><a class="el" href="classbalxml_1_1Reader.html#abcc1bf177fe83320f7a8801838708967">errorInfo()</a>.<a class="el" href="classbalxml_1_1Reader.html#ade79af54564096a1e4f7d904115460b6">isFatalError()</a>;</code> </p>

</div>
</div>
<a class="anchor" id="a057c0ab7fdc0025e7857033df185af76"></a><!-- doxytag: member="balxml::Reader::isError" ref="a057c0ab7fdc0025e7857033df185af76" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool balxml::Reader::isError </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the derived object encountered a error. This method is equivalent to a call to <code><a class="el" href="classbalxml_1_1Reader.html#abcc1bf177fe83320f7a8801838708967">errorInfo()</a>.<a class="el" href="classbalxml_1_1Reader.html#a057c0ab7fdc0025e7857033df185af76">isError()</a>;</code> </p>

</div>
</div>
<a class="anchor" id="a796db0a12836250c8882ff55d9bfe903"></a><!-- doxytag: member="balxml::Reader::isWarning" ref="a796db0a12836250c8882ff55d9bfe903" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool balxml::Reader::isWarning </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the derived object encountered a warning. This method is equivalent to a call to <code><a class="el" href="classbalxml_1_1Reader.html#abcc1bf177fe83320f7a8801838708967">errorInfo()</a>.<a class="el" href="classbalxml_1_1Reader.html#a796db0a12836250c8882ff55d9bfe903">isWarning()</a>;</code> </p>

</div>
</div>
<a class="anchor" id="a17099694cfbee74686c799fc3a68883b"></a><!-- doxytag: member="balxml::Reader::setPrefixStack" ref="a17099694cfbee74686c799fc3a68883b" args="(PrefixStack *prefixes)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void balxml::Reader::setPrefixStack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbalxml_1_1PrefixStack.html">PrefixStack</a> *&nbsp;</td>
          <td class="paramname"> <em>prefixes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the prefix stack to the stack at the optionally specified <code>prefixes</code> address or disable prefix stack support if <code>prefixes</code> is null. This stack is used to push and pop namespace prefixes as the parse progresses, so that, at any point, the stack will reflect the set of active prefixes for the current node. It is legitimate to pass a stack that already contains prefixes, these prefixes shall be preserved when <code>close</code> is called, i.e., the prefix stack shall be returned to the stack depth it had when <code>setPrefixStack</code> was called. The behavior is undefined if this method is called after calling <code>open</code> and before calling <code>close</code>. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a957358ad6db084fbdfa1fa78f3a03586">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a65e0d2af41eec4d5b735bcf5003abe1a"></a><!-- doxytag: member="balxml::Reader::setResolver" ref="a65e0d2af41eec4d5b735bcf5003abe1a" args="(XmlResolverFunctor resolver)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void balxml::Reader::setResolver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbalxml_1_1Reader.html#ab7e056f9c4efa21874ddcf9314140575">XmlResolverFunctor</a>&nbsp;</td>
          <td class="paramname"> <em>resolver</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the external XML resource resolver to the specified <code>resolver</code>. The XML resource resolver is used by the <code>balxml_reader</code> to find and open an external resources (See the <code>XmlResolverFunctor</code> typedef for more details). The XML resource resolver remains valid; it is not effected by a call to <code>close</code> and should be available until the reader is destroyed. The behavior is undefined if this method is called after calling <code>open</code> and before calling <code>close</code>. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#aeb2036599e393e7500eaa8bc9887c570">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a4e2febd7c2f865970e5abad75a71fdf4"></a><!-- doxytag: member="balxml::Reader::open" ref="a4e2febd7c2f865970e5abad75a71fdf4" args="(const char *filename, const char *encoding=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int balxml::Reader::open </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>encoding</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set up the reader for parsing using the data contained in the XML file described by the specified <code>filename</code>, and set the encoding value to the optionally specified <code>encoding</code> ("ASCII", "UTF-8", etc). Returns 0 on success and non-zero otherwise. The encoding passed to <code><a class="el" href="classbalxml_1_1Reader.html#a4e2febd7c2f865970e5abad75a71fdf4">Reader::open</a></code> will take effect only when there is no encoding information in the original document, i.e., the encoding information obtained from the XML file described by the <code>filename</code> trumps all. If there is no encoding provided within the document and <code>encoding</code> is null or a blank string is passed, then set the encoding to the default "UTF-8". It is an error to <code>open</code> a reader that is already open. Note that the reader will not be on a valid node until <code>advanceToNextNode</code> is called. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#ae430799d7c299e72ce76ad4bfc46ab51">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="ac8a8a9c0218f647f423af95d302b150d"></a><!-- doxytag: member="balxml::Reader::open" ref="ac8a8a9c0218f647f423af95d302b150d" args="(const char *buffer, bsl::size_t size, const char *url=0, const char *encoding=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int balxml::Reader::open </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>url</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>encoding</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set up the reader for parsing using the data contained in the specified (XML) <code>buffer</code> of the specified <code>size</code>, set the base URL to the optionally specified <code>url</code> and set the encoding value to the optionally specified <code>encoding</code> ("ASCII", "UTF-8", etc). Return 0 on success and non-zero otherwise. If <code>url</code> is null or a blank string is passed, then base URL will be empty. The encoding passed to <code><a class="el" href="classbalxml_1_1Reader.html#a4e2febd7c2f865970e5abad75a71fdf4">Reader::open</a></code> will take effect only when there is no encoding information in the original document, i.e., the encoding information obtained from the (XML) <code>buffer</code> trumps all. If there is no encoding provided within the document and <code>encoding</code> is null or a blank string is passed, then set the encoding to the default "UTF-8". It is an error to <code>open</code> a reader that is already open. Note that the reader will not be on a valid node until <code>advanceToNextNode</code> is called. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#ab46ae2a6cfcf7c9fff2e71793c124568">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a3f6f67c57c66b6f98a121be5562189b0"></a><!-- doxytag: member="balxml::Reader::open" ref="a3f6f67c57c66b6f98a121be5562189b0" args="(bsl::streambuf *stream, const char *url=0, const char *encoding=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int balxml::Reader::open </td>
          <td>(</td>
          <td class="paramtype">bsl::streambuf *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>url</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>encoding</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set up the reader for parsing using the data contained in the specified (XML) <code>stream</code>, set the base URL to the optionally specified <code>url</code> and set the encoding value to the optionally specified <code>encoding</code> ("ASCII", "UTF-8", etc). Return 0 on success and non-zero otherwise. If <code>url</code> is null or a blank string is passed, then base URL will be empty. The encoding passed to <code><a class="el" href="classbalxml_1_1Reader.html#a4e2febd7c2f865970e5abad75a71fdf4">Reader::open</a></code> will take effect only when there is no encoding information in the original document, i.e., the encoding information obtained from the (XML) <code>stream</code> trumps all. If there is no encoding provided within the document and <code>encoding</code> is null or a blank string is passed, then set the encoding to the default "UTF-8". It is an error to <code>open</code> a reader that is already open. Note that the reader will not be on a valid node until <code>advanceToNextNode</code> is called. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a76c085e34c7fb32e6d90d85c334779c7">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a09e572709808938f96034cf10d20ec41"></a><!-- doxytag: member="balxml::Reader::close" ref="a09e572709808938f96034cf10d20ec41" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void balxml::Reader::close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the reader. Most, but not all state is reset. Specifically, the XML resource resolver and the prefix stack remain. The prefix stack shall be returned to the stack depth it had when <code>setPrefixStack</code> was called. Call the method <code>open</code> to reuse the reader. Note that <code>close</code> invalidates all strings and data structures obtained via <code><a class="el" href="classbalxml_1_1Reader.html">Reader</a></code> accessors. E.g., the pointer returned from <code>nodeName</code> for this node will not be valid once <code>close</code> is called. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a4b7184ad552b986388c23f3c9bc68bc6">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a277ab8dd9f06507b115b96e39002faf7"></a><!-- doxytag: member="balxml::Reader::advanceToNextNode" ref="a277ab8dd9f06507b115b96e39002faf7" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int balxml::Reader::advanceToNextNode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move to the next node in the data steam created by <code>open</code> thus allowing the node's properties to be queried via the <code><a class="el" href="classbalxml_1_1Reader.html">Reader</a></code> accessors. Return 0 on successful read, 1 if there are no more nodes to read, and a negative number otherwise. Note that each call to <code>advanceToNextNode</code> invalidates strings and data structures returned when <code><a class="el" href="classbalxml_1_1Reader.html">Reader</a></code> accessors where call for the "prior node". E.g., the pointer returned from <code>nodeName</code> for this node will not be valid once <code>advanceToNextNode</code> is called. Note that the reader will not be on a valid node until the first call to <code>advanceToNextNode</code> after the reader is opened. TBD: add comment about insignificant white space. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a00528b649e0db78ac695f595f5451d1a">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a95fec9fda7e752a1b44d0ef90673c5a7"></a><!-- doxytag: member="balxml::Reader::lookupAttribute" ref="a95fec9fda7e752a1b44d0ef90673c5a7" args="(ElementAttribute *attribute, int index) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int balxml::Reader::lookupAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbalxml_1_1ElementAttribute.html">ElementAttribute</a> *&nbsp;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the attribute at the specified <code>index</code> in the current node, and fill in the specified <code>attribute</code> structure. Return 0 on success, 1 if no attribute is found at the <code>index</code>, and an a negative value otherwise. The strings that were filled into the <code>attribute</code> structure are invalid upon the next <code>advanceToNextNode</code> or <code>close</code> is called. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a4d65ab6a1c2ac045e05d7f36d112ae5a">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a94fc47d06c060a995136a2ab419f0c06"></a><!-- doxytag: member="balxml::Reader::lookupAttribute" ref="a94fc47d06c060a995136a2ab419f0c06" args="(ElementAttribute *attribute, const char *qname) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int balxml::Reader::lookupAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbalxml_1_1ElementAttribute.html">ElementAttribute</a> *&nbsp;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>qname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the attribute with the specified <code>qname</code> (qualified name) in the current node, and fill in the specified <code>attribute</code> structure. Return 0 on success, 1 if there is no attribute found with <code>qname</code>, and a negative value otherwise. The strings that were filled into the <code>attribute</code> structure are invalid upon the next <code>advanceToNextNode</code> or <code>close</code> is called. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a848c7f3bf8d4a821933de9f4d4fc6158">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a5a68fca3c867dc550459713a91b1e2ad"></a><!-- doxytag: member="balxml::Reader::lookupAttribute" ref="a5a68fca3c867dc550459713a91b1e2ad" args="(ElementAttribute *attribute, const char *localName, const char *namespaceUri) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int balxml::Reader::lookupAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbalxml_1_1ElementAttribute.html">ElementAttribute</a> *&nbsp;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>localName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>namespaceUri</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the attribute with the specified <code>localName</code> and specified <code>namespaceUri</code> in the current node, and fill in the specified <code>attribute</code> structure. Return 0 on success, 1 if there is no attribute found with <code>localName</code> and <code>namespaceUri</code>, and a negative value otherwise. If <code>namespaceUri</code> == 0 or a blank string is passed, then the document's default namespace will be used. The strings that were filled into the <code>attribute</code> structure are invalid upon the next <code>advanceToNextNode</code> or <code>close</code> is called. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a411db3c93d33155f727bfdb1f49c1a2e">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a57d723428bc1a40f5cf41746102fbbee"></a><!-- doxytag: member="balxml::Reader::lookupAttribute" ref="a57d723428bc1a40f5cf41746102fbbee" args="(ElementAttribute *attribute, const char *localName, int namespaceId) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int balxml::Reader::lookupAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbalxml_1_1ElementAttribute.html">ElementAttribute</a> *&nbsp;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>localName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>namespaceId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the attribute with the specified <code>localName</code> and specified <code>namespaceId</code> in the current node, and fill in the specified <code>attribute</code> structure. Return 0 on success, 1 if there is no attribute found with <code>localName</code> and <code>namespaceId</code>, and a negative value otherwise. If <code>namespaceId</code> == -1, then the document's default namespace will be used. The strings that were filled into the <code>attribute</code> structure are invalid upon the next <code>advanceToNextNode</code> or <code>close</code> is called. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a025c80dcbb79085699e81da81ac4c05b">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a580a2e6d82feb20c252aa4853c345dab"></a><!-- doxytag: member="balxml::Reader::setOptions" ref="a580a2e6d82feb20c252aa4853c345dab" args="(unsigned int flags)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void balxml::Reader::setOptions </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the options to the flags in the specified <code>flags</code>. The options for the reader are persistent, i.e., the options are not reset by <code>close</code>. The behavior is undefined if this method is called after calling <code>open</code> and before calling <code>close</code>; except that derived classes are permitted to specify valid behavior for calling this function for specific arguments while the reader is open. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#ab171fee4e3b02d4bb6f4e8f2b15d8675">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a1d9d3e5ede19671b54d2c12257a19cef"></a><!-- doxytag: member="balxml::Reader::documentEncoding" ref="a1d9d3e5ede19671b54d2c12257a19cef" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* balxml::Reader::documentEncoding </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the document encoding or NULL on error. The returned pointer is owned by this object and must not be modified or deallocated by the caller. The returned pointer becomes invalid when <code>close</code> is called or the reader is destroyed. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a7c45d48897e61ce382159e3f7fe06996">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a6508f1ecc9a55b00b1e50411c69c4cd0"></a><!-- doxytag: member="balxml::Reader::resolver" ref="a6508f1ecc9a55b00b1e50411c69c4cd0" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbalxml_1_1Reader.html#ab7e056f9c4efa21874ddcf9314140575">XmlResolverFunctor</a> balxml::Reader::resolver </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the external XML resource resolver. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a988a7128e9aab63f60930ed3ea4d744f">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a4ed721a98ef8a61c2f2a85bd21c246b8"></a><!-- doxytag: member="balxml::Reader::isOpen" ref="a4ed721a98ef8a61c2f2a85bd21c246b8" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool balxml::Reader::isOpen </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if <code>open</code> was called successfully and <code>close</code> has not yet been called and false otherwise. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a280e2af4c836c35a406b0c75cc7984e1">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="abcc1bf177fe83320f7a8801838708967"></a><!-- doxytag: member="balxml::Reader::errorInfo" ref="abcc1bf177fe83320f7a8801838708967" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classbalxml_1_1ErrorInfo.html">ErrorInfo</a>&amp; balxml::Reader::errorInfo </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable error information for this reader. The returned value becomes invalid when <code>close</code> is called or the reader is destroyed. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#adaaa5cb737f9ef497516591d873e7b91">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="aad034b14046b07e3904ba03f9e980f6f"></a><!-- doxytag: member="balxml::Reader::getLineNumber" ref="aad034b14046b07e3904ba03f9e980f6f" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int balxml::Reader::getLineNumber </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current line number within the input stream. The current line is the last line for which the reader has not yet seen a newline. Lines are counted starting at one from the time a stream is provided to <code>open</code>. Return 0 if not available. Note that a derived-class implementation is not required to count lines and may just return 0. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#aefe93b7901322b85f5dbdda6a1cbbfe8">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="ab429efa2e6c44a70f003f3bf2ab7fc33"></a><!-- doxytag: member="balxml::Reader::getColumnNumber" ref="ab429efa2e6c44a70f003f3bf2ab7fc33" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int balxml::Reader::getColumnNumber </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current column number within the input stream. The current column number is the number of characters since the last newline was read by the reader plus one, i.e., the first column of each line is column number one. Return 0 if not available. Note that a derived-class implementation is not required to count columns and may just return 0. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a7631700680defcbcf38469c7d2ed4d92">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="af0e9dbf0604ca07e58cd5357f9e8fe23"></a><!-- doxytag: member="balxml::Reader::prefixStack" ref="af0e9dbf0604ca07e58cd5357f9e8fe23" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbalxml_1_1PrefixStack.html">PrefixStack</a>* balxml::Reader::prefixStack </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pointer to the modifiable prefix stack that is used by this reader to manage namespace prefixes or 0 if namespace support is disabled. The behavior is undefined if the returned prefix stack is augmented in any way after calling <code>open</code> and before calling <code>close</code>. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#af390ce958b5ba59a877c5b6cb16a43cd">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a4b4d7656699f1c66fc052e753f2a19dc"></a><!-- doxytag: member="balxml::Reader::nodeType" ref="a4b4d7656699f1c66fc052e753f2a19dc" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbalxml_1_1Reader.html#a96d821892acdd3b8565421be14c438f3">NodeType</a> balxml::Reader::nodeType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the node type of the current node if the reader <code>isOpen</code> and has not encounter an error and <code>Reader::NONE</code> otherwise. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#abedf00a33a850977c14711495a55b206">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="ae3854574e8ca51c846da858bc089e4a6"></a><!-- doxytag: member="balxml::Reader::nodeName" ref="ae3854574e8ca51c846da858bc089e4a6" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* balxml::Reader::nodeName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the qualified name of the current node if the current node has a name and NULL otherwise. The returned pointer is owned by this object and must not be modified or deallocated by the caller. The returned pointer becomes invalid upon the next <code>advanceToNextNode</code>, when <code>close</code> is called or the reader is destroyed. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a4c8cbaf7ac53b25160ac95e849e2dec4">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="ab007e9b5153425add355772a2d1fab7c"></a><!-- doxytag: member="balxml::Reader::nodeLocalName" ref="ab007e9b5153425add355772a2d1fab7c" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* balxml::Reader::nodeLocalName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the local name of the current node if the current node has a local name and NULL otherwise. The returned pointer is owned by this object and must not be modified or deallocated by the caller. The returned pointer becomes invalid upon the next <code>advanceToNextNode</code>, when <code>close</code> is called or the reader is destroyed. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a6c091ce30e2bc83805fd143c6cd63909">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="ac75ea2445343b44e765f6c240dc12f07"></a><!-- doxytag: member="balxml::Reader::nodePrefix" ref="ac75ea2445343b44e765f6c240dc12f07" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* balxml::Reader::nodePrefix </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the prefix name of the current node if the correct node has a prefix name and NULL otherwise. The returned pointer is owned by this object and must not be modified or deallocated by the caller. The returned pointer becomes invalid upon the next <code>advanceToNextNode</code>, when <code>close</code> is called or the reader is destroyed. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#ad0e54d8b2cc58103b17266b511e347c6">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="af1b43ad6d72ccde7e8d8e899b1c85bfa"></a><!-- doxytag: member="balxml::Reader::nodeNamespaceId" ref="af1b43ad6d72ccde7e8d8e899b1c85bfa" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int balxml::Reader::nodeNamespaceId </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the namespace ID of the current node if the current node has a namespace id and a negative number otherwise. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#af6419aa04b926f69d1d5e51bd21ef1a4">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="afd9165e1fc132731ea65f54d17497fcc"></a><!-- doxytag: member="balxml::Reader::nodeNamespaceUri" ref="afd9165e1fc132731ea65f54d17497fcc" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* balxml::Reader::nodeNamespaceUri </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the namespace URI name of the current node if the current node has a namespace URI and NULL otherwise. The returned pointer is owned by this object and must not be modified or deallocated by the caller. The returned pointer becomes invalid upon the next <code>advanceToNextNode</code>, when <code>close</code> is called or the reader is destroyed. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a30fb7c4b8d2265d69333c28d0f255b33">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a0c9764ebd80a3beee651d44c3686a744"></a><!-- doxytag: member="balxml::Reader::nodeBaseUri" ref="a0c9764ebd80a3beee651d44c3686a744" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* balxml::Reader::nodeBaseUri </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the base URI name of the current node if the current node has a base URI and NULL otherwise. The returned pointer is owned by this object and must not be modified or deallocated by the caller. The returned pointer becomes invalid upon the next <code>advanceToNextNode</code>, when <code>close</code> is called or the reader is destroyed. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#abf5b1c87560446fa14ce790b3f31d554">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="abbe9b9bba50315cda46bf5da6139a8ac"></a><!-- doxytag: member="balxml::Reader::nodeHasValue" ref="abbe9b9bba50315cda46bf5da6139a8ac" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool balxml::Reader::nodeHasValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the current node has a value and false otherwise. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a853e8faf865d8f8163b77985aa80b162">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="af446508cd5cc4caf9202c20297802a9d"></a><!-- doxytag: member="balxml::Reader::nodeValue" ref="af446508cd5cc4caf9202c20297802a9d" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* balxml::Reader::nodeValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the value of the current node if the current node has a value and NULL otherwise. The returned pointer is owned by this object and must not be modified or deallocated by the caller. The returned pointer becomes invalid upon the next <code>advanceToNextNode</code>, when <code>close</code> is called or the reader is destroyed. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#af408695c683ddf42f9f192082ffa3a30">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a60ad6509d81b74dc24809796fed720fb"></a><!-- doxytag: member="balxml::Reader::nodeDepth" ref="a60ad6509d81b74dc24809796fed720fb" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int balxml::Reader::nodeDepth </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the nesting depth of the current node in the XML document. The root node has depth 0. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a5f385281a78b013364f3895f36a05cbd">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="afd4b002d0859bc45b28e8a140640ba65"></a><!-- doxytag: member="balxml::Reader::numAttributes" ref="afd4b002d0859bc45b28e8a140640ba65" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int balxml::Reader::numAttributes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of attributes for the current node if that node has attributes and 0 otherwise. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a46ff4a3b07a2104bbb8912d2c625a39b">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a09187382bd2b82e46743de5fc6670ffc"></a><!-- doxytag: member="balxml::Reader::isEmptyElement" ref="a09187382bd2b82e46743de5fc6670ffc" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool balxml::Reader::isEmptyElement </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the current node is an element (i.e., node type is <code>BAEXML_NODE_TYPE_ELEMENT</code>) that ends with <code>/&gt;</code>; and false otherwise. Note that <code>&lt;a/&gt;</code> will be considered empty but <code>&lt;a&gt;&lt;/a&gt;</code> will not. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a8f8333ae4113dbf81e012aa3aa1e1de3">balxml::MiniReader</a>.</p>

</div>
</div>
<a class="anchor" id="a60cb69fc512b4592fe99022df99f4b2a"></a><!-- doxytag: member="balxml::Reader::options" ref="a60cb69fc512b4592fe99022df99f4b2a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int balxml::Reader::options </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the option flags. </p>

<p>Implemented in <a class="el" href="classbalxml_1_1MiniReader.html#a4ab4ce6b45ea349b570c400214f2036e">balxml::MiniReader</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="balxml__reader_8h_source.html">balxml_reader.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:08 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
