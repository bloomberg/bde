<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslmt_qlock Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslmt_qlock<br/>
<small>
[<a class="el" href="group__bslmt.html">Package bslmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide small, statically-initializable mutex lock.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslmt.html">bslmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">The <code>bslmt::QLockGuard</code> Class</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Using <code>bslmt::QLock</code> to Implement a Thread-Safe Singleton</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide small, statically-initializable mutex lock. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbslmt_1_1QLock.html">bslmt::QLock</a> </td><td>Small, statically-initializable intra-process mutex  </td></tr>
<tr>
<td><a class="el" href="classbslmt_1_1QLockGuard.html">bslmt::QLockGuard</a> </td><td>Automatic locking-unlocking of <a class="el" href="structbslmt_1_1QLock.html">bslmt::QLock</a>  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslmt__mutex.html" title="Provide a platform-independent mutex.">Component bslmt_mutex</a>, bslmt_atomictypes, <a class="el" href="group__bslmt__lockguard.html" title="Provide a generic proctor for synchronization objects.">Component bslmt_lockguard</a>, <a class="el" href="group__bslmt__once.html" title="Provide a thread-safe way to execute code once per process.">Component bslmt_once</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a portable and efficient lock for ensuring that only one thread at a time enters a specific "critical region" -- a section of code that accesses a shared resource -- <code>bslmt::Qlock</code> and its associated <code><a class="el" href="classbslmt_1_1QLockGuard.html">bslmt::QLockGuard</a></code>. The functionality of the <code><a class="el" href="structbslmt_1_1QLock.html">bslmt::QLock</a></code> class overlaps those of the <code><a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a></code> and <code><a class="el" href="structbsls_1_1SpinLock.html" title="A mutex using &quot;busy waiting&quot; atomic operations.">bsls::SpinLock</a></code> classes, but with different usage and performance characteristics, as shown in the following grid: <br/>
<br/>
<div class="fragment"><pre class="fragment">                                    | QLock | Mutex | SpinLock
 -----------------------------------+-------+-------+---------
 Memory footprint                   | small | large | small
 Cost of construction/destruction   | cheap | costly| cheap
 Statically initializable           | yes   | no    | yes
 Speed at low contention            | fast  | fast  | fast
 Speed at high contention           | slow  | fast  | very slow
 Suitable <span class="keywordflow">for</span> <span class="keywordtype">long</span> critical regions | yes   | yes   | no
 Fair                               | yes   | no    | no
</pre></div><br/>
<br/>
 The performance trade-offs for a QLock are quite different than those for a conventional mutex. QLocks are best suited for low-contention applications where large numbers of locks may be needed. For example, a node-based data structure that needs a lock for each node can benefit from the small size and low initialization cost of a QLock compared to that of a conventional mutex. A <code><a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a></code> object cannot be initialized statically because some platforms (e.g., Windows XP) do not have a native statically-initializable mutex type. A <code><a class="el" href="structbslmt_1_1QLock.html">bslmt::QLock</a></code> object, in contrast is statically initializable on all platforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The performance characteristics of a QLock are very similar to those of a SpinLock. However, a QLock is much more suitable than a SpinLock for situations where the critical region is more than a few instructions long. Also, although QLocks are best for low-contention situations, they do not degrade nearly as badly as SpinLocks if there is a lot of contention for the lock. They also use significantly fewer CPU cycles in high-contention situations than do SpinLocks. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A unique characteristic of QLocks is that they are fair. If there is contention for a lock, each thread is given the lock in the order in which it requested it. Consequently, every thread competing for the lock will get a chance before any other thread can have a second turn; no thread is ever "starved" out of the critical region. This fairness comes at a cost, however, in that the scheduler is given less leeway to schedule threads in the most efficient manner. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="the_bslmt~3A~3Aqlockguard_class"></a> <a class="anchor" id="description.the_bslmt~3A~3Aqlockguard_class"></a> <a class="anchor" id="the_bslmt"></a> <a class="anchor" id="description.the_bslmt"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>The bslmt::QLockGuard Class: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="structbslmt_1_1QLock.html">bslmt::QLock</a></code> is different from other locking classes such as <code><a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a></code> and <code><a class="el" href="structbsls_1_1SpinLock.html" title="A mutex using &quot;busy waiting&quot; atomic operations.">bsls::SpinLock</a></code> in that it cannot be manipulated except through the auxiliary <code><a class="el" href="classbslmt_1_1QLockGuard.html">bslmt::QLockGuard</a></code> class. The reason for this limited interface is that a QLock requires a small amount of additional storage for each thread that is holding or waiting for the lock. The <code><a class="el" href="classbslmt_1_1QLockGuard.html">bslmt::QLockGuard</a></code> provides this extra storage efficiently on the stack. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In typical usage, a <code><a class="el" href="classbslmt_1_1QLockGuard.html">bslmt::QLockGuard</a></code> is created as a local (stack) variable, acquires the lock in its constructor and releases the lock in its destructor. If the lock is in use at construction time, then the current thread blocks until the lock becomes available. Although the QLock itself is intended to be shared among multiple threads, the guard object must never be used by more than one thread at a time. When multiple threads want to acquire the same QLock, each must use its own <code><a class="el" href="classbslmt_1_1QLockGuard.html">bslmt::QLockGuard</a></code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbslmt_1_1QLockGuard.html">bslmt::QLockGuard</a></code> also provides the following manipulators typical of locking classes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> lock();    <span class="comment">// Acquire the lock, waiting if necessary</span>
  <span class="keywordtype">int</span> tryLock();  <span class="comment">// Acquire the lock if possible.  Fail if lock is in use.</span>
  <span class="keywordtype">void</span> unlock();  <span class="comment">// Free the lock.</span>
</pre></div><br/>
<br/>
 As with other types of mutexes, only one thread my hold the lock at a time. Other threads attempting to call <code>lock</code> will block until the lock becomes available. However, it is important to remember that the manipulators listed above are only pass-through operations on the shared <code><a class="el" href="structbslmt_1_1QLock.html">bslmt::QLock</a></code> object. In other words, upon return from calling <code>lock</code> on a <code><a class="el" href="classbslmt_1_1QLockGuard.html">bslmt::QLockGuard</a></code> object, a thread has actually acquired the lock to the underlying <code><a class="el" href="structbslmt_1_1QLock.html">bslmt::QLock</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Although it is only a proxy for the actual QLock, <code>lock</code>/<code>unlock</code>/<code>tryLock</code> interface of <code><a class="el" href="classbslmt_1_1QLockGuard.html">bslmt::QLockGuard</a></code> allows it to be treated as though it were itself a lock. In particular, it is possible to instantiate the <code><a class="el" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard</a></code> and <code><a class="el" href="classbslmt_1_1LockGuardUnlock.html">bslmt::LockGuardUnlock</a></code> class templates using <code><a class="el" href="classbslmt_1_1QLockGuard.html">bslmt::QLockGuard</a></code>. This layering of guard classes is useful for creating regions where the QLock is locked or unlocked. For example, if a thread acquires a QLock and then needs to temporarily relinquish it, it could use a <code><a class="el" href="classbslmt_1_1LockGuardUnlock.html">bslmt::LockGuardUnlock</a></code> as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> Node::update()
  {
     <a class="code" href="classbslmt_1_1QLockGuard.html">bslmt::QLockGuard</a> qguard(&amp;d_qlock);  <span class="comment">// &#39;d_qlock&#39; is a &#39;bslmt::QLock&#39;.</span>
     readLunarState();
     <span class="keywordflow">if</span> (d_moonIsFull) {
         <span class="comment">// Free lock while we sleep</span>
         <a class="code" href="classbslmt_1_1LockGuardUnlock.html">bslmt::LockGuardUnlock&lt;bslmt::QLockGuard&gt;</a> unlock(&amp;qguard)
         sleep(TWENTY_FOUR_HOURS);
     }
     <span class="comment">// Lock has been re-acquired</span>
     ...
  }
</pre></div><br/>
<br/>
 The behavior is undefined if <code>unlock</code> is invoked from a thread that did not successfully acquire the lock, or if <code>lock</code> is called twice in a thread without an intervening call to <code>unlock</code> (i.e., <code><a class="el" href="classbslmt_1_1QLockGuard.html">bslmt::QLockGuard</a></code> is non-recursive). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_bslmt~3A~3Aqlock_to_implement_a_thread-safe_singleton"></a> <a class="anchor" id="usage.example_1~3A_using_bslmt~3A~3Aqlock_to_implement_a_thread-safe_singleton"></a> <a class="anchor" id="description.usage.example_1~3A_using_bslmt~3A~3Aqlock_to_implement_a_thread-safe_singleton"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using bslmt::QLock to Implement a Thread-Safe Singleton: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>For this example, assume that we have the need to use the string "Hello" repeatedly in the form of an <code>bsl::string</code> object. Rather than construct the string each time we use it, it would be nice to have only one copy so that we can amortize the memory allocation and construction cost over all the uses of the string. It is thus logical to have a single, static variable (a singleton) of type <code>bsl::string</code> initialized with the value, "Hello". Unfortunately, as this is a multithreaded application, there is the danger that more than one thread will attempt to initialize the singleton simultaneously, causing a memory leak at best and memory corruption at worse. To solve this problem, we use a <code><a class="el" href="structbslmt_1_1QLock.html">bslmt::QLock</a></code> to synchronize access to the singleton. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We begin by wrapping the singleton in a function: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; helloString()
  {
</pre></div><br/>
<br/>
 This function defines two static variables, a pointer to the singleton, and a QLock to control access to the singleton. Note that both of these variables are statically initialized, so there is no need for a run-time constructor and hence no danger of a race condition among threads. The need for static initialization is the main reason we choose to use <code><a class="el" href="structbslmt_1_1QLock.html">bslmt::QLock</a></code> over <code><a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> *singletonPtr = 0;
      <span class="keyword">static</span> <a class="code" href="structbslmt_1_1QLock.html">bslmt::QLock</a> qlock = BSLMT_QLOCK_INITIALIZER;
</pre></div><br/>
<br/>
 Before checking the status of the singleton pointer, we must make sure that we are not accessing the pointer at the same time that some other thread is modifying the pointer. We do this by acquiring the lock by constructing a <code><a class="el" href="classbslmt_1_1QLockGuard.html">bslmt::QLockGuard</a></code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbslmt_1_1QLockGuard.html">bslmt::QLockGuard</a> qlockGuard(&amp;qlock);
</pre></div><br/>
<br/>
 Now we are inside the critical region. If the pointer has not already been set, we can initialize the singleton knowing that no other thread is manipulating or accessing these variables at the same time. Note that this critical region involves constructing a variable of type <code>bsl::string</code>. This operation, while not ultra-expensive, is too lengthy for comfortably holding a spinlock. Again, the characteristics of <code><a class="el" href="structbslmt_1_1QLock.html">bslmt::QLock</a></code> are superior to the alternatives for this application. (It is worth noting that the QLock concept was created specifically to permit this kind of one-time processing. See also <code>bslmt_once</code>.) <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (! singletonPtr) {
          <span class="keyword">static</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> singleton(<span class="stringliteral">&quot;Hello&quot;</span>);
          singletonPtr = &amp;singleton;
      }
</pre></div><br/>
<br/>
 Finally, we return a reference to the singleton. The destructor for <code><a class="el" href="classbslmt_1_1QLockGuard.html">bslmt::QLockGuard</a></code> will automatically unlock the QLock and allow another thread into the critical region. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">return</span> *singletonPtr;
  }
</pre></div><br/>
<br/>
 The following test program shows how our singleton function can be called. Note that <code>hello1</code> and <code>hello2</code> have the same address, demonstrating that there was only one string created. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> usageExample1()
  {
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> EXPECTED(<span class="stringliteral">&quot;Hello&quot;</span>);

      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; hello1 = helloString();
      assert(hello1 == EXPECTED);

      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; hello2 = helloString();
      assert(hello2  == EXPECTED);
      assert(&amp;hello2 == &amp;hello1);

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:01 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
