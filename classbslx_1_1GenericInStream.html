<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bslx::GenericInStream</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslx.html">bslx</a>      </li>
      <li><a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream&lt; STREAMBUF &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslx::GenericInStream&lt; STREAMBUF &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslx::GenericInStream" -->
<p><code>#include &lt;<a class="el" href="bslx__genericinstream_8h_source.html">bslx_genericinstream.h</a>&gt;</code></p>

<p><a href="classbslx_1_1GenericInStream-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a15a373ee6523576322ed586b46df4fd5">GenericInStream</a> (STREAMBUF *streamBuf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a1d92ee6de1e5db6f93496d830fc9e116">~GenericInStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a40bece5dde7c14aad91680a080b74b1f">getLength</a> (int &amp;length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a80ed8cf8fad69f1fc1acf73c3ee47cab">getVersion</a> (int &amp;version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a47798cb0407b393108dbbd882ac3ed06">invalidate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a1c464213ca46cec9e9db1b017837648b">getInt64</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a9c7a097e48c7f350991e3779736278c5">getUint64</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a9a347e95f75f2e308dddc49560b00f7a">getInt56</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a6072161026044573b9aae8982fc3ef0b">getUint56</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a36fac1d971fc41e8d5aae7d5607a2678">getInt48</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#ac50a927add351aec815ed41ace07373d">getUint48</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a1a78a34e107b77f00de31373e06213a8">getInt40</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a45aaf414657f7b62ddcfc0b0f91c16ae">getUint40</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a023d80bc0ee3766ee4adbe9dd7ae1edb">getInt32</a> (int &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a6ecac0e9557432dd815383ae6fc640f8">getUint32</a> (unsigned int &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a26be633c972b07d5d4f84e43292d1c5f">getInt24</a> (int &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a747a6a4f483c3a6a275f7fc1133e3f23">getUint24</a> (unsigned int &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a4f27e4240231aa9071d98d0e78210ba4">getInt16</a> (short &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a7e33d7704ab21f3613dac565ceb68924">getUint16</a> (unsigned short &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a7155b36c8c9cdd6097858f23ff9b7ea0">getInt8</a> (char &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#ac5a6c6a29d5eb66bf74c985dbbdc373d">getInt8</a> (signed char &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a4a8a92d425e18776cc06fbfa006c43e0">getUint8</a> (char &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#ae219ddd5210b8a2e1b5905d1d1d347ba">getUint8</a> (unsigned char &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a0681d17a2983f953fa7382fa56eac3ac">getFloat64</a> (double &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#ab18efc4f60fc8347bd052b140797eb3b">getFloat32</a> (float &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#afae4ba7dd6e19862ad40d307895c0584">getString</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a56a9cff890b8be58323fcd9aca59f307">getArrayInt64</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#ad05ac7e8bf4cfd7ce8ee3a2147440dc6">getArrayUint64</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#ae8ab9a46caafd606862c3618120b7981">getArrayInt56</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a9c33483be9b95c149ed45beeb68b3a77">getArrayUint56</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#aef9b87cf2b7cf2b2d0890b366aad14ae">getArrayInt48</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a4ccb26afbd73c7df303c137726da54f4">getArrayUint48</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a34a8c68c0e888367199cc8adc0e7148e">getArrayInt40</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#ae74655f9397c920670a2a86d98327d3d">getArrayUint40</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#af2bff5c360225d7d13d1b6b3704e6575">getArrayInt32</a> (int *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a6744631624db629a58a9dcefb1036bb7">getArrayUint32</a> (unsigned int *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a5d11d1096d76c6f4d5fa4e4ba8453daa">getArrayInt24</a> (int *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a39b6b19ff2d2fe28bc955bb6aa6cf198">getArrayUint24</a> (unsigned int *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a97854d354645a1d4234bae4598fd5119">getArrayInt16</a> (short *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a10287521fc7be876d461341dfd1d7d90">getArrayUint16</a> (unsigned short *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#abb56f49ae8349c65d212a2a07490d0cc">getArrayInt8</a> (char *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a4365cf5010a5c1d91ef8a0d155fa8220">getArrayInt8</a> (signed char *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a7e9003ee82e9cce4422247e228fdbebe">getArrayUint8</a> (char *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#ac54cd56f03696d6a6efdfa32f61ff917">getArrayUint8</a> (unsigned char *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a929a08ba166f542de24736fc0273b5ae">getArrayFloat64</a> (double *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a9b4b6ef4d4734af8927e45c4032f35f4">getArrayFloat32</a> (float *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#a8d103e97c8fb1e60a1b1ebb4021ca687">operator const void *</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1GenericInStream.html#aa49b883cfd38487bc994704fd811f34d">isValid</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class STREAMBUF&gt;<br/>
 class bslx::GenericInStream&lt; STREAMBUF &gt;</h3>

<p>This class provides input methods to unexternalize values, and C-style arrays of values, of the fundamental integral and floating-point types, as well as <code>bsl::string</code> values, using a byte format documented in the <code>bslx_byteoutstream</code> component. In particular, each <code>get</code> method of this class is guaranteed to read stream data written by the corresponding <code>put</code> method of <code><a class="el" href="classbslx_1_1GenericOutStream.html">bslx::GenericOutStream</a></code>. Note that attempting to read beyond the end of a stream will automatically invalidate the stream. See the <code>bslx</code> package-level documentation for the definition of the BDEX <code>InStream</code> protocol. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a15a373ee6523576322ed586b46df4fd5"></a><!-- doxytag: member="bslx::GenericInStream::GenericInStream" ref="a15a373ee6523576322ed586b46df4fd5" args="(STREAMBUF *streamBuf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::<a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> </td>
          <td>(</td>
          <td class="paramtype">STREAMBUF *&nbsp;</td>
          <td class="paramname"> <em>streamBuf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an input byte stream that reads its input from the specified <code>streamBuf</code>. </p>

</div>
</div>
<a class="anchor" id="a1d92ee6de1e5db6f93496d830fc9e116"></a><!-- doxytag: member="bslx::GenericInStream::~GenericInStream" ref="a1d92ee6de1e5db6f93496d830fc9e116" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::~<a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a40bece5dde7c14aad91680a080b74b1f"></a><!-- doxytag: member="bslx::GenericInStream::getLength" ref="a40bece5dde7c14aad91680a080b74b1f" args="(int &amp;length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getLength </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the most-significant bit of the one byte of this stream at the current cursor location is set, assign to the specified <code>length</code> the four-byte, two's complement integer (in host byte order) comprised of the four bytes of this stream at the current cursor location (in network byte order) with the most-significant bit unset; otherwise, assign to <code>length</code> the one-byte, two's complement integer comprised of the one byte of this stream at the current cursor location. Update the cursor location and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>length</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a80ed8cf8fad69f1fc1acf73c3ee47cab"></a><!-- doxytag: member="bslx::GenericInStream::getVersion" ref="a80ed8cf8fad69f1fc1acf73c3ee47cab" args="(int &amp;version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getVersion </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>version</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>version</code> the one-byte, two's complement unsigned integer comprised of the one byte of this stream at the current cursor location, update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>version</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a47798cb0407b393108dbbd882ac3ed06"></a><!-- doxytag: member="bslx::GenericInStream::invalidate" ref="a47798cb0407b393108dbbd882ac3ed06" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::invalidate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put this input stream in an invalid state. This function has no effect if this stream is already invalid. Note that this function should be called whenever a value extracted from this stream is determined to be invalid, inconsistent, or otherwise incorrect. </p>

</div>
</div>
<a class="anchor" id="a1c464213ca46cec9e9db1b017837648b"></a><!-- doxytag: member="bslx::GenericInStream::getInt64" ref="a1c464213ca46cec9e9db1b017837648b" args="(bsls::Types::Int64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getInt64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the eight-byte, two's complement integer (in host byte order) comprised of the eight bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a9c7a097e48c7f350991e3779736278c5"></a><!-- doxytag: member="bslx::GenericInStream::getUint64" ref="a9c7a097e48c7f350991e3779736278c5" args="(bsls::Types::Uint64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getUint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the eight-byte, two's complement unsigned integer (in host byte order) comprised of the eight bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a9a347e95f75f2e308dddc49560b00f7a"></a><!-- doxytag: member="bslx::GenericInStream::getInt56" ref="a9a347e95f75f2e308dddc49560b00f7a" args="(bsls::Types::Int64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getInt56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the seven-byte, two's complement integer (in host byte order) comprised of the seven bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a6072161026044573b9aae8982fc3ef0b"></a><!-- doxytag: member="bslx::GenericInStream::getUint56" ref="a6072161026044573b9aae8982fc3ef0b" args="(bsls::Types::Uint64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getUint56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the seven-byte, two's complement unsigned integer (in host byte order) comprised of the seven bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a36fac1d971fc41e8d5aae7d5607a2678"></a><!-- doxytag: member="bslx::GenericInStream::getInt48" ref="a36fac1d971fc41e8d5aae7d5607a2678" args="(bsls::Types::Int64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getInt48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the six-byte, two's complement integer (in host byte order) comprised of the six bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="ac50a927add351aec815ed41ace07373d"></a><!-- doxytag: member="bslx::GenericInStream::getUint48" ref="ac50a927add351aec815ed41ace07373d" args="(bsls::Types::Uint64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getUint48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the six-byte, two's complement unsigned integer (in host byte order) comprised of the six bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a1a78a34e107b77f00de31373e06213a8"></a><!-- doxytag: member="bslx::GenericInStream::getInt40" ref="a1a78a34e107b77f00de31373e06213a8" args="(bsls::Types::Int64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getInt40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the five-byte, two's complement integer (in host byte order) comprised of the five bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a45aaf414657f7b62ddcfc0b0f91c16ae"></a><!-- doxytag: member="bslx::GenericInStream::getUint40" ref="a45aaf414657f7b62ddcfc0b0f91c16ae" args="(bsls::Types::Uint64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getUint40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the five-byte, two's complement unsigned integer (in host byte order) comprised of the five bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a023d80bc0ee3766ee4adbe9dd7ae1edb"></a><!-- doxytag: member="bslx::GenericInStream::getInt32" ref="a023d80bc0ee3766ee4adbe9dd7ae1edb" args="(int &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getInt32 </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the four-byte, two's complement integer (in host byte order) comprised of the four bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a6ecac0e9557432dd815383ae6fc640f8"></a><!-- doxytag: member="bslx::GenericInStream::getUint32" ref="a6ecac0e9557432dd815383ae6fc640f8" args="(unsigned int &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getUint32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the four-byte, two's complement unsigned integer (in host byte order) comprised of the four bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a26be633c972b07d5d4f84e43292d1c5f"></a><!-- doxytag: member="bslx::GenericInStream::getInt24" ref="a26be633c972b07d5d4f84e43292d1c5f" args="(int &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getInt24 </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the three-byte, two's complement integer (in host byte order) comprised of the three bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a747a6a4f483c3a6a275f7fc1133e3f23"></a><!-- doxytag: member="bslx::GenericInStream::getUint24" ref="a747a6a4f483c3a6a275f7fc1133e3f23" args="(unsigned int &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getUint24 </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the three-byte, two's complement unsigned integer (in host byte order) comprised of the three bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a4f27e4240231aa9071d98d0e78210ba4"></a><!-- doxytag: member="bslx::GenericInStream::getInt16" ref="a4f27e4240231aa9071d98d0e78210ba4" args="(short &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getInt16 </td>
          <td>(</td>
          <td class="paramtype">short &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the two-byte, two's complement integer (in host byte order) comprised of the two bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a7e33d7704ab21f3613dac565ceb68924"></a><!-- doxytag: member="bslx::GenericInStream::getUint16" ref="a7e33d7704ab21f3613dac565ceb68924" args="(unsigned short &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getUint16 </td>
          <td>(</td>
          <td class="paramtype">unsigned short &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the two-byte, two's complement unsigned integer (in host byte order) comprised of the two bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a7155b36c8c9cdd6097858f23ff9b7ea0"></a><!-- doxytag: member="bslx::GenericInStream::getInt8" ref="a7155b36c8c9cdd6097858f23ff9b7ea0" args="(char &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getInt8 </td>
          <td>(</td>
          <td class="paramtype">char &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac5a6c6a29d5eb66bf74c985dbbdc373d"></a><!-- doxytag: member="bslx::GenericInStream::getInt8" ref="ac5a6c6a29d5eb66bf74c985dbbdc373d" args="(signed char &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getInt8 </td>
          <td>(</td>
          <td class="paramtype">signed char &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the one-byte, two's complement integer comprised of the one byte of this stream at the current cursor location, update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a4a8a92d425e18776cc06fbfa006c43e0"></a><!-- doxytag: member="bslx::GenericInStream::getUint8" ref="a4a8a92d425e18776cc06fbfa006c43e0" args="(char &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getUint8 </td>
          <td>(</td>
          <td class="paramtype">char &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae219ddd5210b8a2e1b5905d1d1d347ba"></a><!-- doxytag: member="bslx::GenericInStream::getUint8" ref="ae219ddd5210b8a2e1b5905d1d1d347ba" args="(unsigned char &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getUint8 </td>
          <td>(</td>
          <td class="paramtype">unsigned char &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the one-byte, two's complement unsigned integer comprised of the one byte of this stream at the current cursor location, update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that the value will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a0681d17a2983f953fa7382fa56eac3ac"></a><!-- doxytag: member="bslx::GenericInStream::getFloat64" ref="a0681d17a2983f953fa7382fa56eac3ac" args="(double &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getFloat64 </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the eight-byte IEEE double-precision floating-point number (in host byte order) comprised of the eight bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="ab18efc4f60fc8347bd052b140797eb3b"></a><!-- doxytag: member="bslx::GenericInStream::getFloat32" ref="ab18efc4f60fc8347bd052b140797eb3b" args="(float &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getFloat32 </td>
          <td>(</td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the four-byte IEEE single-precision floating-point number (in host byte order) comprised of the four bytes of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="afae4ba7dd6e19862ad40d307895c0584"></a><!-- doxytag: member="bslx::GenericInStream::getString" ref="afae4ba7dd6e19862ad40d307895c0584" args="(bsl::string &amp;variable)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variable</code> the string comprised of the length of the string (see <code>getLength</code>) and the string data (see <code>getUint8</code>), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a56a9cff890b8be58323fcd9aca59f307"></a><!-- doxytag: member="bslx::GenericInStream::getArrayInt64" ref="a56a9cff890b8be58323fcd9aca59f307" args="(bsls::Types::Int64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayInt64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive eight-byte, two's complement integers (in host byte order) comprised of each of the specified <code>numVariables</code> eight-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="ad05ac7e8bf4cfd7ce8ee3a2147440dc6"></a><!-- doxytag: member="bslx::GenericInStream::getArrayUint64" ref="ad05ac7e8bf4cfd7ce8ee3a2147440dc6" args="(bsls::Types::Uint64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayUint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive eight-byte, two's complement unsigned integers (in host byte order) comprised of each of the specified <code>numVariables</code> eight-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="ae8ab9a46caafd606862c3618120b7981"></a><!-- doxytag: member="bslx::GenericInStream::getArrayInt56" ref="ae8ab9a46caafd606862c3618120b7981" args="(bsls::Types::Int64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayInt56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive seven-byte, two's complement integers (in host byte order) comprised of each of the specified <code>numVariables</code> seven-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a9c33483be9b95c149ed45beeb68b3a77"></a><!-- doxytag: member="bslx::GenericInStream::getArrayUint56" ref="a9c33483be9b95c149ed45beeb68b3a77" args="(bsls::Types::Uint64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayUint56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive seven-byte, two's complement unsigned integers (in host byte order) comprised of each of the specified <code>numVariables</code> seven-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="aef9b87cf2b7cf2b2d0890b366aad14ae"></a><!-- doxytag: member="bslx::GenericInStream::getArrayInt48" ref="aef9b87cf2b7cf2b2d0890b366aad14ae" args="(bsls::Types::Int64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayInt48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive six-byte, two's complement integers (in host byte order) comprised of each of the specified <code>numVariables</code> six-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a4ccb26afbd73c7df303c137726da54f4"></a><!-- doxytag: member="bslx::GenericInStream::getArrayUint48" ref="a4ccb26afbd73c7df303c137726da54f4" args="(bsls::Types::Uint64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayUint48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive six-byte, two's complement unsigned integers (in host byte order) comprised of each of the specified <code>numVariables</code> six-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a34a8c68c0e888367199cc8adc0e7148e"></a><!-- doxytag: member="bslx::GenericInStream::getArrayInt40" ref="a34a8c68c0e888367199cc8adc0e7148e" args="(bsls::Types::Int64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayInt40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive five-byte, two's complement integers (in host byte order) comprised of each of the specified <code>numVariables</code> five-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="ae74655f9397c920670a2a86d98327d3d"></a><!-- doxytag: member="bslx::GenericInStream::getArrayUint40" ref="ae74655f9397c920670a2a86d98327d3d" args="(bsls::Types::Uint64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayUint40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive five-byte, two's complement unsigned integers (in host byte order) comprised of each of the specified <code>numVariables</code> five-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="af2bff5c360225d7d13d1b6b3704e6575"></a><!-- doxytag: member="bslx::GenericInStream::getArrayInt32" ref="af2bff5c360225d7d13d1b6b3704e6575" args="(int *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayInt32 </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive four-byte, two's complement integers (in host byte order) comprised of each of the specified <code>numVariables</code> four-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a6744631624db629a58a9dcefb1036bb7"></a><!-- doxytag: member="bslx::GenericInStream::getArrayUint32" ref="a6744631624db629a58a9dcefb1036bb7" args="(unsigned int *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayUint32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive four-byte, two's complement unsigned integers (in host byte order) comprised of each of the specified <code>numVariables</code> four-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a5d11d1096d76c6f4d5fa4e4ba8453daa"></a><!-- doxytag: member="bslx::GenericInStream::getArrayInt24" ref="a5d11d1096d76c6f4d5fa4e4ba8453daa" args="(int *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayInt24 </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive three-byte, two's complement integers (in host byte order) comprised of each of the specified <code>numVariables</code> three-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numValues</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a39b6b19ff2d2fe28bc955bb6aa6cf198"></a><!-- doxytag: member="bslx::GenericInStream::getArrayUint24" ref="a39b6b19ff2d2fe28bc955bb6aa6cf198" args="(unsigned int *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayUint24 </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive three-byte, two's complement unsigned integers (in host byte order) comprised of each of the specified <code>numVariables</code> three-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a97854d354645a1d4234bae4598fd5119"></a><!-- doxytag: member="bslx::GenericInStream::getArrayInt16" ref="a97854d354645a1d4234bae4598fd5119" args="(short *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayInt16 </td>
          <td>(</td>
          <td class="paramtype">short *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive two-byte, two's complement integers (in host byte order) comprised of each of the specified <code>numVariables</code> two-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a10287521fc7be876d461341dfd1d7d90"></a><!-- doxytag: member="bslx::GenericInStream::getArrayUint16" ref="a10287521fc7be876d461341dfd1d7d90" args="(unsigned short *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayUint16 </td>
          <td>(</td>
          <td class="paramtype">unsigned short *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive two-byte, two's complement unsigned integers (in host byte order) comprised of each of the specified <code>numVariables</code> two-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="abb56f49ae8349c65d212a2a07490d0cc"></a><!-- doxytag: member="bslx::GenericInStream::getArrayInt8" ref="abb56f49ae8349c65d212a2a07490d0cc" args="(char *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayInt8 </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4365cf5010a5c1d91ef8a0d155fa8220"></a><!-- doxytag: member="bslx::GenericInStream::getArrayInt8" ref="a4365cf5010a5c1d91ef8a0d155fa8220" args="(signed char *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayInt8 </td>
          <td>(</td>
          <td class="paramtype">signed char *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive one-byte, two's complement integers comprised of each of the specified <code>numVariables</code> one-byte sequences of this stream at the current cursor location, update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be sign-extended. </p>

</div>
</div>
<a class="anchor" id="a7e9003ee82e9cce4422247e228fdbebe"></a><!-- doxytag: member="bslx::GenericInStream::getArrayUint8" ref="a7e9003ee82e9cce4422247e228fdbebe" args="(char *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayUint8 </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac54cd56f03696d6a6efdfa32f61ff917"></a><!-- doxytag: member="bslx::GenericInStream::getArrayUint8" ref="ac54cd56f03696d6a6efdfa32f61ff917" args="(unsigned char *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayUint8 </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive one-byte, two's complement unsigned integers comprised of each of the specified <code>numVariables</code> one-byte sequences of this stream at the current cursor location, update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that each of the values will be zero-extended. </p>

</div>
</div>
<a class="anchor" id="a929a08ba166f542de24736fc0273b5ae"></a><!-- doxytag: member="bslx::GenericInStream::getArrayFloat64" ref="a929a08ba166f542de24736fc0273b5ae" args="(double *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayFloat64 </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive eight-byte IEEE double-precision floating-point numbers (in host byte order) comprised of each of the specified <code>numVariables</code> eight-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="a9b4b6ef4d4734af8927e45c4032f35f4"></a><!-- doxytag: member="bslx::GenericInStream::getArrayFloat32" ref="a9b4b6ef4d4734af8927e45c4032f35f4" args="(float *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">GenericInStream</a>&amp; <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::getArrayFloat32 </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to the specified <code>variables</code> the consecutive four-byte IEEE single-precision floating-point numbers (in host byte order) comprised of each of the specified <code>numVariables</code> four-byte sequences of this stream at the current cursor location (in network byte order), update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="a8d103e97c8fb1e60a1b1ebb4021ca687"></a><!-- doxytag: member="bslx::GenericInStream::operator const void *" ref="a8d103e97c8fb1e60a1b1ebb4021ca687" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::operator const void * </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a non-zero value if this stream is valid, and 0 otherwise. An invalid stream is a stream in which insufficient or invalid data was detected during an extraction operation. Note that an empty stream will be valid unless an extraction attempt or explicit invalidation causes it to be otherwise. </p>

</div>
</div>
<a class="anchor" id="aa49b883cfd38487bc994704fd811f34d"></a><!-- doxytag: member="bslx::GenericInStream::isValid" ref="aa49b883cfd38487bc994704fd811f34d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAMBUF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbslx_1_1GenericInStream.html">bslx::GenericInStream</a>&lt; STREAMBUF &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this stream is valid, and <code>false</code> otherwise. An invalid stream is a stream in which insufficient or invalid data was detected during an extraction operation. Note that an empty stream will be valid unless an extraction attempt or explicit invalidation causes it to be otherwise. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslx__genericinstream_8h_source.html">bslx_genericinstream.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:11 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
