<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslim_printer Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslim_printer<br/>
<small>
[<a class="el" href="group__bslim.html">Package bslim</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a mechanism to implement standard <code>print</code> methods.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslim.html">bslim</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: <code>print</code> Method for a Value-Semantic Class</a> </li>
<li>
<a href="#3.1.2">Example 2: <code>print</code> Method for a Mechanism Class</a> </li>
<li>
<a href="#3.1.3">Example 3: Foreign (3rd - Party) Classes, and Printing STL Containers</a> </li>
<li>
<a href="#3.1.4">Example 4: Printing Ranges, and Typed Pointers</a> </li>
<li>
<a href="#3.1.5">Example 5: <code>print</code> Method for a Low-Level Value-Semantic Class</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a mechanism to implement standard <code>print</code> methods. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslim_1_1Printer.html">bslim::Printer</a> </td><td>mechanism to implement standard <code>print</code> methods  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a mechanism class, <code>Printer</code>, that, in many cases, simplifies the implementation of types providing a <code>print</code> method with the signature: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bsl::ostream&amp; print(bsl::ostream&amp; stream,
                      <span class="keywordtype">int</span>           level          = 0,
                      <span class="keywordtype">int</span>           spacesPerLevel = 4) <span class="keyword">const</span>;
      <span class="comment">// Format this object to the specified output &#39;stream&#39; at the (absolute</span>
      <span class="comment">// value of) the optionally specified indentation &#39;level&#39; and return a</span>
      <span class="comment">// reference to &#39;stream&#39;.  If &#39;level&#39; is specified, optionally specify</span>
      <span class="comment">// &#39;spacesPerLevel&#39;, the number of spaces per indentation level for</span>
      <span class="comment">// this and all of its nested objects.  If &#39;level&#39; is negative,</span>
      <span class="comment">// suppress indentation of the first line.  If &#39;spacesPerLevel&#39; is</span>
      <span class="comment">// negative format the entire output on one line, suppressing all but</span>
      <span class="comment">// the initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is</span>
      <span class="comment">// not valid on entry, this operation has no effect.</span>
</pre></div><br/>
<br/>
 Note that all value-semantic types are expected to provide this method. Use of the <code>Printer</code> mechanism provides a uniform style of output formatting: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
Enclose the object's salient attributes with square brackets.  </li>
<li>
Prefix each attribute with the attribute's name, separated by an "equal" sign surrounded by space characters (" = ").  </li>
<li>
If the attributes are to be printed on multiple lines, then print them with one more level of indentation than that of the enclosing brackets. If any of the attributes are compositions, then the composite values must be printed with an additional level of indentation.  </li>
<li>
If the attributes are to be printed on a single line, then separate each value with a single space character.  </li>
<li>
For small, common types, such as <code>bdet_Date</code>, the names of attributes, equal sign, and brackets may be omitted, with the entire value represented on a single line in a custom format. For example, the <code>bdet_Date::print</code> method emits the date value in the format: 01JAN2001.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, consider a class having two attributes, "ticker", represented by a <code>bsl::string</code>, and "price", represented by a <code>double</code>. The output for a <code>print</code> method that produces standardized output for <code>print(bsl::cout, 0, -4)</code> (single-line output) is shown below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  [ ticker = <span class="stringliteral">&quot;ABC&quot;</span> price = 65.89 ]
</pre></div><br/>
<br/>
 Output for <code>print(bsl::cout, 0, 4)</code> (multi-line output) is shown below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  [
      ticker = <span class="stringliteral">&quot;ABC&quot;</span>
      price = 65.89
  ]
</pre></div><br/>
<br/>
 The <code>Printer</code> mechanism provides methods and method templates to format data as described above. <code>Printer</code> objects are instantiated with the target stream to be written to, and the values of the indentation level of the data, <code>level</code>, and the spaces per level, <code>spacesPerLevel</code>. The methods provided by <code>Printer</code>, <code>printAttribute</code>, <code>printValue</code>, <code>printOrNull</code>, <code>printHexAddr</code> and <code>printForeign</code>, use these values for formatting. The <code>start</code> and <code>end</code> methods print the enclosing brackets of the output. In order to generate the standard output format, <code>start</code> should be called before any of the other methods, and <code>end</code> should be called after all the other methods have been called. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the following examples, we examine the implementation of the <code>print</code> method of different types of classes using <code>Printer</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_print_method_for_a_value-semantic_class"></a> <a class="anchor" id="usage.example_1~3A_print_method_for_a_value-semantic_class"></a> <a class="anchor" id="description.usage.example_1~3A_print_method_for_a_value-semantic_class"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: print Method for a Value-Semantic Class: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we demonstrate how to use <code>Printer</code> to implement the standard <code>print</code> function of a value-semantic class having multiple attributes. Suppose we have a class, <code>RecordAttributes</code>, that provides a container for a fixed set of attributes. A <code>RecordAttributes</code> object has two attributes, "timestamp", of type <code>my::Datetime</code>, and "processID", of type <code>int</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>StockTrade {
      <span class="comment">// This class represents the properties of a stock trace.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> d_ticker;        <span class="comment">// ticker symbol</span>
      <span class="keywordtype">double</span>      d_price;         <span class="comment">// stock price</span>
      <span class="keywordtype">double</span>      d_quantity;      <span class="comment">// quanity traded</span>

    <span class="keyword">public</span>:
      ...

      <span class="comment">// ACCESSORS</span>
      bsl::ostream&amp; print(bsl::ostream&amp; stream,
                          <span class="keywordtype">int</span>           level = 0,
                          <span class="keywordtype">int</span>           spacesPerLevel = 4)<span class="keyword"> const</span>
<span class="keyword">      </span>{
          <span class="keywordflow">if</span> (stream.bad()) {
              <span class="keywordflow">return</span> stream;                                        <span class="comment">// RETURN</span>
          }

          <a class="code" href="classbslim_1_1Printer.html">bslim::Printer</a> printer(&amp;stream, level, spacesPerLevel);
          printer.start();
          printer.printAttribute(<span class="stringliteral">&quot;ticker&quot;</span>,   d_ticker);
          printer.printAttribute(<span class="stringliteral">&quot;price&quot;</span>,    d_price);
          printer.printAttribute(<span class="stringliteral">&quot;quantity&quot;</span>, d_quantity);
          printer.end();

          <span class="keywordflow">return</span> stream;
      }
  };
</pre></div><br/>
<br/>
 Sample output for <code>StockTrade::print(bsl::cout, 0, -4)</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  [ ticker = <span class="stringliteral">&quot;IBM&quot;</span> price = 107.3 quantity = 200 ]
</pre></div><br/>
<br/>
 Sample output for <code>StockTrade::print(bsl::cout, 0, 4)</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  [
      ticker = <span class="stringliteral">&quot;IBM&quot;</span>
      price = 107.3
      quantity = 200
  ]
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_print_method_for_a_mechanism_class"></a> <a class="anchor" id="usage.example_2~3A_print_method_for_a_mechanism_class"></a> <a class="anchor" id="description.usage.example_2~3A_print_method_for_a_mechanism_class"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: print Method for a Mechanism Class: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we discuss the implementation of <code>print</code> for a mechanism class. A mechanism class does not have any salient attributes that define its value (as a mechanism does not have a "value"). However, the <code>print</code> method may be implemented to output the internal state of an object of such a type, e.g., for debugging purposes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, consider a memory manager class, <code>BlockList</code>, that maintains a linked list of memory blocks: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>BlockList {
      <span class="comment">// This class implements a low-level memory manager that allocates and</span>
      <span class="comment">// manages a sequence of memory blocks.</span>

      <span class="comment">// TYPES</span>
      <span class="keyword">struct </span>Block {
          <span class="comment">// This &#39;struct&#39; overlays the beginning of each managed block of</span>
          <span class="comment">// allocated memory, implementing a doubly-linked list of managed</span>
          <span class="comment">// blocks, and thereby enabling constant-time deletions from, as</span>
          <span class="comment">// well as additions to, the list of blocks.</span>

          Block                               *d_next_p;       <span class="comment">// next</span>
                                                               <span class="comment">// pointer</span>

          Block                              **d_addrPrevNext; <span class="comment">// enable</span>
                                                               <span class="comment">// delete</span>

          <a class="code" href="structbsls_1_1AlignmentUtil.html#a8e9ba3fe648c80e5b29ae2d0920b61c8">bsls::AlignmentUtil::MaxAlignedType</a>   d_memory;      <span class="comment">// force</span>
                                                               <span class="comment">// alignment</span>
      };

      <span class="comment">// DATA</span>
      Block           *d_head_p;      <span class="comment">// address of first block of memory</span>
                                      <span class="comment">// (or 0)</span>

      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p; <span class="comment">// memory allocator; held, but not</span>
                                       <span class="comment">// owned</span>

    <span class="keyword">public</span>:
      <span class="comment">// ...</span>
      <span class="comment">// ACCESSORS</span>
      <span class="comment">// ...</span>
      bsl::ostream&amp; print(bsl::ostream&amp; stream,
                          <span class="keywordtype">int</span>           level          = 0,
                          <span class="keywordtype">int</span>           spacesPerLevel = 4) <span class="keyword">const</span>;
  };
</pre></div><br/>
<br/>
 For the purposes of debugging, it may be useful to print the starting address of every memory block in a <code>BlockList</code>, which can be done using the <code>printHexAddr</code> method of the <code>Printer</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bsl::ostream&amp; BlockList::print(bsl::ostream&amp; stream,
                                 <span class="keywordtype">int</span>           level,
                                 <span class="keywordtype">int</span>           spacesPerLevel)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">if</span> (stream.bad()) {
          <span class="keywordflow">return</span> stream;                                            <span class="comment">// RETURN</span>
      }

      <a class="code" href="classbslim_1_1Printer.html">bslim::Printer</a> printer(&amp;stream, level, spacesPerLevel);
      printer.start();
      <span class="keywordflow">for</span> (Block *it = d_head_p; it; it = it-&gt;d_next_p) {
          printer.printHexAddr(it, 0);
      }
      printer.end();

      <span class="keywordflow">return</span> stream;
  }
</pre></div><br/>
<br/>
 Sample output for 'BlockListprint(bsl::cout, 0, -4): <br/>
<br/>
<div class="fragment"><pre class="fragment">  [ 0x0012fab4 0x0012fab8 ]
</pre></div><br/>
<br/>
 Sample output for 'BlockListprint(bsl::cout, 0, 4): <br/>
<br/>
<div class="fragment"><pre class="fragment">  [
      0x0012fab4
      0x0012fab8
  ]
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_foreign_(3rd_-_party)_classes,_and_printing_stl_containers"></a> <a class="anchor" id="usage.example_3~3A_foreign_(3rd_-_party)_classes,_and_printing_stl_containers"></a> <a class="anchor" id="description.usage.example_3~3A_foreign_(3rd_-_party)_classes,_and_printing_stl_containers"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.1.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Foreign (3rd - Party) Classes, and Printing STL Containers: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we use a <code>Printer</code> object to help format the properties of a class supplied by a third-party that does not implement the standard <code>print</code> method. Consider a struct, <code>ThirdPartyStruct</code>, defined in <code>/usr/include/thirdparty.h</code> that has no standard <code>print</code> method. We will be using this struct within another class <code>Customer</code>, storing some <code>Customer</code> objects in a map, and printing the map. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>ThirdPartyStruct {
      <span class="comment">// Suppose this struct is defined somewhere in</span>
      <span class="comment">// &#39;/usr/include/thirdparty.h&#39;, we have no control over it and hence</span>
      <span class="comment">// cannot add a .print method to it.</span>

      <span class="keyword">enum</span> { PRIVATE  = 1,
             WRITABLE = 2 };

      <span class="keywordtype">short</span> pid;              <span class="comment">// process id</span>
      <span class="keywordtype">short</span> access_flags;     <span class="comment">// options</span>
      <span class="keywordtype">char</span> user_id[20];       <span class="comment">// userid</span>
  };
</pre></div><br/>
<br/>
 We create a struct <code>MyThirdPartyStructPrintUtil</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>MyThirdPartyStructPrintUtil {
      <span class="keyword">static</span>
      bsl::ostream&amp; print(bsl::ostream&amp;           stream,
                          <span class="keyword">const</span> ThirdPartyStruct&amp; data,
                          <span class="keywordtype">int</span>                     level = 0,
                          <span class="keywordtype">int</span>                      spacesPerLevel = 4);
          <span class="comment">// You write this function in your own code to accommodate</span>
          <span class="comment">// &#39;ThirdPartyStruct&#39;.</span>
  };

  bsl::ostream&amp; MyThirdPartyStructPrintUtil::print(
                                      bsl::ostream&amp;           stream,
                                      <span class="keyword">const</span> ThirdPartyStruct&amp; data,
                                      <span class="keywordtype">int</span>                     level,
                                      <span class="keywordtype">int</span>                     spacesPerLevel)
  {
      <a class="code" href="classbslim_1_1Printer.html">bslim::Printer</a> printer(&amp;stream, level, spacesPerLevel);
      printer.start();
      printer.printAttribute(<span class="stringliteral">&quot;pid&quot;</span>,          data.pid);
      printer.printAttribute(<span class="stringliteral">&quot;access_flags&quot;</span>, data.access_flags);
      printer.printAttribute(<span class="stringliteral">&quot;user_id&quot;</span>,      data.user_id);
      printer.end();

      <span class="keywordflow">return</span> stream;
  }
</pre></div><br/>
<br/>
 We create a class <code>Customer</code> that has a <code>ThirdPartyStruct</code> in it: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Customer {
      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>      d_companyName;
      ThirdPartyStruct d_thirdPartyStruct;
      <span class="keywordtype">bool</span>             d_loyalCustomer;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      Customer() {}

      Customer(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; companyName,
               <span class="keywordtype">short</span>              pid,
               <span class="keywordtype">short</span>              accessFlags,
               <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; userId,
               <span class="keywordtype">bool</span>               loyalCustomer)
      : d_companyName(companyName)
      , d_loyalCustomer(loyalCustomer)
      {
          d_thirdPartyStruct.pid = pid;
          d_thirdPartyStruct.access_flags = accessFlags;
          bsl::strcpy(d_thirdPartyStruct.user_id, userId.<a class="code" href="group__bslstl__string.html#gae8d40a93bd2ebc7ae696c6f63b3995c9">c_str</a>());
      }

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">void</span> print(bsl::ostream&amp; stream,
                 <span class="keywordtype">int</span>           level = 0,
                 <span class="keywordtype">int</span>           spacesPerLevel = 4)<span class="keyword"> const</span>
<span class="keyword">      </span>{
          <a class="code" href="classbslim_1_1Printer.html">bslim::Printer</a> printer(&amp;stream, level, spacesPerLevel);
          printer.start();
          printer.printAttribute(<span class="stringliteral">&quot;CompanyName&quot;</span>, d_companyName);
          printer.printForeign(d_thirdPartyStruct,
                               &amp;MyThirdPartyStructPrintUtil::print,
                               <span class="stringliteral">&quot;ThirdPartyStruct&quot;</span>);
          printer.printAttribute(<span class="stringliteral">&quot;LoyalCustomer&quot;</span>, d_loyalCustomer);
          printer.end();
      }
  };
</pre></div><br/>
<br/>
 We then create some <code>Customer</code> objects and put them in a map: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myFunc()
  {
      <a class="code" href="classbsl_1_1map.html">bsl::map&lt;int, Customer&gt;</a> myMap;
      myMap[7] = Customer(<span class="stringliteral">&quot;Honeywell&quot;</span>,
                          27,
                          ThirdPartyStruct::PRIVATE,
                          <span class="stringliteral">&quot;hw&quot;</span>,
                          <span class="keyword">true</span>);
      myMap[5] = Customer(<span class="stringliteral">&quot;IBM&quot;</span>,
                          32,
                          ThirdPartyStruct::WRITABLE,
                          <span class="stringliteral">&quot;ibm&quot;</span>,
                          <span class="keyword">false</span>);
      myMap[8] = Customer(<span class="stringliteral">&quot;Burroughs&quot;</span>,
                          45,
                          0,
                          <span class="stringliteral">&quot;burr&quot;</span>,
                          <span class="keyword">true</span>);
</pre></div><br/>
<br/>
 Now we print the map <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbslim_1_1Printer.html">bslim::Printer</a> printer(&amp;cout, 0, 4);
      printer.start();
      printer.printValue(myMap);
      printer.end();
  }
</pre></div><br/>
<br/>
 The following is written to <code>stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  [
      [
          [
              5
              [
                  CompanyName = <span class="stringliteral">&quot;IBM&quot;</span>
                  ThirdPartyStruct = [
                      pid = 32
                      access_flags = 2
                      user_id = <span class="stringliteral">&quot;ibm&quot;</span>
                  ]
                  LoyalCustomer = false
              ]
          ]
          [
              7
              [
                  CompanyName = <span class="stringliteral">&quot;Honeywell&quot;</span>
                  ThirdPartyStruct = [
                      pid = 27
                      access_flags = 1
                      user_id = <span class="stringliteral">&quot;hw&quot;</span>
                  ]
                  LoyalCustomer = true
              ]
          ]
          [
              8
              [
                  CompanyName = <span class="stringliteral">&quot;Burroughs&quot;</span>
                  ThirdPartyStruct = [
                      pid = 45
                      access_flags = 0
                      user_id = <span class="stringliteral">&quot;burr&quot;</span>
                  ]
                  LoyalCustomer = true
              ]
          ]
      ]
  ]
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_4~3A_printing_ranges,_and_typed_pointers"></a> <a class="anchor" id="usage.example_4~3A_printing_ranges,_and_typed_pointers"></a> <a class="anchor" id="description.usage.example_4~3A_printing_ranges,_and_typed_pointers"></a> <a class="anchor" id="example_4"></a> <a class="anchor" id="usage.example_4"></a> <a class="anchor" id="description.usage.example_4"></a> <a class="anchor" id="3.1.4"></a> </dd></dl>
<dl class="user"><dt><b>Example 4: Printing Ranges, and Typed Pointers: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this examples we demonstrate two capabilities of a <code><a class="el" href="classbslim_1_1Printer.html">bslim::Printer</a></code> object: printing a range of elements using iterators and printing a pointer type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>printValue</code> or <code>printAttribute</code> methods of <code><a class="el" href="classbslim_1_1Printer.html">bslim::Printer</a></code> will print out all of the elements in the range specified by a pair of iterator arguments, which can be of any type that provides appropriately behaving operators <code>++</code>, <code>*</code>, and <code>==</code> (a non-void pointer would qualify). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When <code>bslim</code> encounters a single pointer of type <code>TYPE *</code>, where <code>TYPE</code> is neither <code>void</code> nor <code>char</code>, the pointer value is printed out in hex followed by printing out the value of <code>TYPE</code>. A compile error will occur if bslim is unable to print out <code>TYPE</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As an example, we print out a range of pointers to sets. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First we create 3 sets and populate them with different values. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1set.html">bsl::set&lt;int&gt;</a> Set;

  Set s0, s1, s2;

  s0.insert(0);
  s0.insert(1);
  s0.insert(2);

  s1.insert(4);
  s1.insert(5);

  s2.insert(8);
</pre></div><br/>
<br/>
 Then, we store the addresses to those 3 sets into a fixed-length array: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> Set *setArray[] = { &amp;s0, &amp;s1, &amp;s2 };
  <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_SET_ARRAY = <span class="keyword">sizeof</span> setArray / <span class="keyword">sizeof</span> *setArray;
</pre></div><br/>
<br/>
 Next we use <code>printValue</code> to print a range of values by supplying an iterator to the beginning and end of the range, in the address of <code>setArray</code> and the address one past the end of <code>setArray</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslim_1_1Printer.html">bslim::Printer</a> printer(&amp;cout, 0, -1);
  printer.printValue(setArray + 0, setArray + NUM_SET_ARRAY);
</pre></div><br/>
<br/>
 The expected output is: <br/>
<br/>
<div class="fragment"><pre class="fragment">  [ 0xffbfd688 [ 0 1 2 ] 0xffbfd678 [ 4 5 ] 0xffbfd668 [ 8 ] ]
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_5~3A_print_method_for_a_low-level_value-semantic_class"></a> <a class="anchor" id="usage.example_5~3A_print_method_for_a_low-level_value-semantic_class"></a> <a class="anchor" id="description.usage.example_5~3A_print_method_for_a_low-level_value-semantic_class"></a> <a class="anchor" id="example_5"></a> <a class="anchor" id="usage.example_5"></a> <a class="anchor" id="description.usage.example_5"></a> <a class="anchor" id="3.1.5"></a> </dd></dl>
<dl class="user"><dt><b>Example 5: print Method for a Low-Level Value-Semantic Class: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>For very simple classes, it may be desirable always to format the attributes on a single line. In this example, we discuss the <code>print</code> method formatting for such a low-level value semantic class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Usually, single-line or multi-line formatting options are specified by the value of the <code>spacesPerLevel</code> argument, but for a simple class that always prints on a single line, the only difference between the single- and multi-line cases is that a newline character is printed at the end of the output for the multi-line case. For such classes, the "name" of the attribute and the enclosing brackets may be omitted as well. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, consider a class, <code>DateTz</code>, having as attributes a local date and a time offset: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>DateTz {
      <span class="comment">// This &#39;class&#39; represents a date value explicitly in a local time</span>
      <span class="comment">// zone.  The offset of that time (in minutes) from UTC is also part of</span>
      <span class="comment">// the value of this class.</span>

    <span class="keyword">private</span>:
      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span> d_localDate;  <span class="comment">// date in YYYYMMDD format, local to the timezone</span>
                        <span class="comment">// indicated by &#39;d_offset&#39;</span>

      <span class="keywordtype">int</span> d_offset;     <span class="comment">// offset from UTC (in minutes)</span>

    <span class="keyword">public</span>:
      <span class="comment">// ...</span>
      <span class="comment">// ACCESSORS</span>
      bsl::ostream&amp; print(bsl::ostream&amp; stream,
                          <span class="keywordtype">int</span>           level          = 0,
                          <span class="keywordtype">int</span>           spacesPerLevel = 4) <span class="keyword">const</span>;
      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 The <code>Printer</code> class may be used in this case to print the start and end indentation by passing a <code>suppressBracket</code> flag to the <code>start</code> and <code>end</code> methods. The value itself can be written to the stream directly without using <code>Printer</code>. Note that to ensure correct formatting of the value in the presence of a call to <code>setw</code> on the stream, the output must be written to a <code>bsl::ostringstream</code> first; the string containing the output can then be written to the specified <code>stream</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bsl::ostream&amp; DateTz::print(bsl::ostream&amp; stream,
                              <span class="keywordtype">int</span>           level,
                              <span class="keywordtype">int</span>           spacesPerLevel)<span class="keyword"> const</span>
<span class="keyword">  </span>{
     <span class="keywordflow">if</span> (stream.bad()) {
         <span class="keywordflow">return</span> stream;                                             <span class="comment">// RETURN</span>
     }

     <a class="code" href="classbsl_1_1basic__ostringstream.html">bsl::ostringstream</a> tmp;
     tmp &lt;&lt; d_localDate;

     <span class="keyword">const</span> <span class="keywordtype">char</span> sign    = d_offset &lt; 0 ? <span class="charliteral">&#39;-&#39;</span> : <span class="charliteral">&#39;+&#39;</span>;
     <span class="keyword">const</span> <span class="keywordtype">int</span>  minutes = <span class="charliteral">&#39;-&#39;</span> == sign ? -d_offset : d_offset;
     <span class="keyword">const</span> <span class="keywordtype">int</span>  hours   = minutes / 60;

     <span class="comment">// space usage: +-  hh  mm  nil</span>
     <span class="keyword">const</span> <span class="keywordtype">int</span> SIZE = 1 + 2 + 2 + 1;
     <span class="keywordtype">char</span> buf[SIZE];

     <span class="comment">// Use at most 2 digits for &#39;hours&#39;</span>
     <span class="keywordflow">if</span> (hours &lt; 100) {
         bsl::sprintf(buf, <span class="stringliteral">&quot;%c%02d%02d&quot;</span>, sign, hours, minutes % 60);
     }
     <span class="keywordflow">else</span> {
         bsl::sprintf(buf, <span class="stringliteral">&quot;%cXX%02d&quot;</span>, sign, minutes % 60);
     }

     tmp &lt;&lt; buf;

     <a class="code" href="classbslim_1_1Printer.html">bslim::Printer</a> printer(&amp;stream, level, spacesPerLevel);
     printer.start(<span class="keyword">true</span>);
     stream &lt;&lt; tmp.<a class="code" href="group__bslstl__ostringstream.html#ga23ddb310164dea8c696231517b0e1f5e">str</a>();
     printer.end(<span class="keyword">true</span>);

     <span class="keywordflow">return</span> stream &lt;&lt; bsl::flush;
  }
</pre></div><br/>
<br/>
 Sample output for 'DateTzprint(bsl::cout, 0, -4): <br/>
<br/>
<div class="fragment"><pre class="fragment">  01JAN2011-0500
</pre></div><br/>
<br/>
 Sample output for 'DateTzprint(bsl::cout, 0, 4): <br/>
<br/>
<div class="fragment"><pre class="fragment">  01JAN2011-0500&lt;\n&gt;
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:20 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
