<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: ball_recordbuffer Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component ball_recordbuffer<br/>
<small>
[<a class="el" href="group__ball.html">Package ball</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a protocol for managing log record handles.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceball.html">ball</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Defining a Concrete <code>RecordBuffer</code> Type</a> </li>
<li>
<a href="#3.1.2">Implementation Notes</a> </li>
<li>
<a href="#3.1.3">Example 2: Using a <code>ball::RecordBuffer</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a protocol for managing log record handles. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classball_1_1RecordBuffer.html">ball::RecordBuffer</a> </td><td>protocol class for managing log record handles  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__ball__record.html" title="Provide a container for all fields of a log record.">Component ball_record</a>, <a class="el" href="group__ball__fixedsizerecordbuffer.html" title="Provide a thread-safe fixed-size buffer of record handles.">Component ball_fixedsizerecordbuffer</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines the base-level protocol, <code><a class="el" href="classball_1_1RecordBuffer.html">ball::RecordBuffer</a></code>, for managing record handles (specifically instances of <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;<a class="el" href="classball_1_1Record.html">ball::Record</a>&gt;</code>) in a double-ended buffer. In particular, the <code><a class="el" href="classball_1_1RecordBuffer.html">ball::RecordBuffer</a></code> protocol class provides abstract methods to push a record handle into either end (back or front) of the buffer (<code>pushBack</code> and <code>pushFront</code>), to obtain read-only access to the log record positioned at either end (<code>back</code> and <code>front</code>) and to remove the record positioned at either end (<code>popBack</code> and <code>popFront</code>). Note that the classes implementing this protocol are supposed to manage record handles and not the records themselves, specifically, they should not allocate the memory for records and should not explicitly destroy records (a record is destroyed automatically when the reference count associated with its handle becomes zero). The push methods (<code>pushBack</code> and <code>pushFront</code>) are not guaranteed to succeed. Concrete implementations implementations are permitted to remove records from the buffer in order to attempt to accommodate a push request (which implies that, after a successful call to a push method, <code>length</code> is not guaranteed to be more than one, and an unsuccessful call to a push method is permitted to leave the buffer empty). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_defining_a_concrete_recordbuffer_type"></a> <a class="anchor" id="usage.example_1~3A_defining_a_concrete_recordbuffer_type"></a> <a class="anchor" id="description.usage.example_1~3A_defining_a_concrete_recordbuffer_type"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Defining a Concrete RecordBuffer Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example shows the definition of a simple concrete record buffer. The requisite steps are: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
Define a concrete class derived from <code><a class="el" href="classball_1_1RecordBuffer.html">ball::RecordBuffer</a></code>.  </li>
<li>
Implement all pure virtual functions.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The concrete thread-safe <code>my_RecordBuffer</code> class in this example implements the <code><a class="el" href="classball_1_1RecordBuffer.html">ball::RecordBuffer</a></code> protocol by delegating to an instance of 'bslvector&lt;<a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;<a class="el" href="classball_1_1Record.html">ball::Record</a>&gt; &gt; ': <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_recordbuffer.h</span>

  <span class="keyword">class </span>my_RecordBuffer : <span class="keyword">public</span> <a class="code" href="ball__category_8h.html#a999861d42e34880988db462fdc96354d">ball</a>::RecordBuffer {
      <span class="comment">// This class provides a thread-safe implementation of the</span>
      <span class="comment">// &#39;ball::RecordBuffer&#39; protocol.  This implementation employs a vector</span>
      <span class="comment">// to hold an unlimited number of record handles.</span>

      <span class="keyword">mutable</span> <a class="code" href="classbslmt_1_1RecursiveMutex.html">bslmt::RecursiveMutex</a> d_mutex;
                                   <span class="comment">// thread safety provider (see</span>
                                   <span class="comment">// the implementation notes for the</span>
                                   <span class="comment">// justification for using recursive mutex</span>
                                   <span class="comment">// rather a plain mutex)</span>

      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::shared_ptr&lt;ball::Record&gt;</a> &gt;
                         d_buffer; <span class="comment">// buffer of record handles</span>

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      my_RecordBuffer(<span class="keyword">const</span> my_RecordBuffer&amp;);
      my_RecordBuffer&amp; operator=(<span class="keyword">const</span> my_RecordBuffer&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_RecordBuffer();
      <span class="keyword">virtual</span> ~my_RecordBuffer();

      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> beginSequence();
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> endSequence();
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> popBack();
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> popFront();
      <span class="keyword">virtual</span> <span class="keywordtype">int</span> pushBack(<span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;ball::Record&gt;</a>&amp; handle);
      <span class="keyword">virtual</span> <span class="keywordtype">int</span> pushFront(
                   <span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;ball::Record&gt;</a>&amp; handle);
      <span class="keyword">virtual</span> <span class="keywordtype">void</span> removeAll();

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;ball::Record&gt;</a>&amp; back() <span class="keyword">const</span>;
      <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;ball::Record&gt;</a>&amp; front() <span class="keyword">const</span>;
      <span class="keyword">virtual</span> <span class="keywordtype">int</span> length() <span class="keyword">const</span>;
  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="implementation_notes"></a> <a class="anchor" id="usage.implementation_notes"></a> <a class="anchor" id="description.usage.implementation_notes"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Implementation Notes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Recursive mutex (rather than plain mutex) is chosen to provide thread safety. This allows the manipulation of the record buffer between the call to <code>beginSequence</code> and <code>endSequence</code>. If we had used plain mutex, calling any method on the record buffer between the calls to <code>beginSequence</code> and <code>endSequence</code> would result in a deadlock. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  my_RecordBuffer::my_RecordBuffer() { }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_RecordBuffer::beginSequence()
  {
      d_mutex.lock();
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_RecordBuffer::endSequence()
  {
      d_mutex.unlock();
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_RecordBuffer::popBack()
  {
      <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt;</a> guard(&amp;d_mutex);
      d_buffer.pop_back();
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_RecordBuffer::popFront()
  {
      <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt;</a> guard(&amp;d_mutex);
      d_buffer.erase(d_buffer.begin());
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> my_RecordBuffer::pushBack(
                       <span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;ball::Record&gt;</a>&amp; handle)
  {
      <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt;</a> guard(&amp;d_mutex);
      d_buffer.push_back(handle);
      <span class="keywordflow">return</span> 0;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> my_RecordBuffer::pushFront(
                       <span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;ball::Record&gt;</a>&amp; handle)
  {
      <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt;</a> guard(&amp;d_mutex);
      d_buffer.insert(d_buffer.begin(), handle);
      <span class="keywordflow">return</span> 0;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_RecordBuffer::removeAll()
  {
      <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt;</a> guard(&amp;d_mutex);
      d_buffer.clear();
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;ball::Record&gt;</a>&amp; my_RecordBuffer::back()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt;</a> guard(&amp;d_mutex);
      <span class="keywordflow">return</span> d_buffer.back();
  }

  <span class="keyword">inline</span>
  <span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;ball::Record&gt;</a>&amp; my_RecordBuffer::front()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt;</a> guard(&amp;d_mutex);
      <span class="keywordflow">return</span> d_buffer.front();
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> my_RecordBuffer::length()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::RecursiveMutex&gt;</a> guard(&amp;d_mutex);
      <span class="keywordflow">return</span> d_buffer.size();
  }
</pre></div><br/>
<br/>
 Note that we always implement a virtual destructor (non-inline) in the .cpp file (to indicate the <em>unique</em> location of the class's virtual table): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_recordbuffer.cpp</span>

  my_RecordBuffer::~my_RecordBuffer() { }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_using_a_ball~3A~3Arecordbuffer"></a> <a class="anchor" id="usage.example_2~3A_using_a_ball~3A~3Arecordbuffer"></a> <a class="anchor" id="description.usage.example_2~3A_using_a_ball~3A~3Arecordbuffer"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.1.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Using a ball::RecordBuffer: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates working with the <code><a class="el" href="classball_1_1RecordBuffer.html">ball::RecordBuffer</a></code> protocol. We implement a function <code>processRecord</code> that processes a specified record handle based on its severity. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> processRecord(<span class="keyword">const</span> <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;ball::Record&gt;</a>&amp; handle,
                           <a class="code" href="classball_1_1RecordBuffer.html">ball::RecordBuffer</a>&amp;            buffer)
      <span class="comment">// Process the specified &#39;handle&#39;, based on it&#39;s severity.  Records</span>
      <span class="comment">// (encapsulated in &#39;handle&#39;) with severity equal to or *greater*</span>
      <span class="comment">// severe than (i.e., with *numerical* value *less* than or equal to)</span>
      <span class="comment">// &#39;ball::Severity::e_WARN&#39; are pushed back into the specified</span>
      <span class="comment">// &#39;buffer&#39;.  Records with a severity equal to or more severe than</span>
      <span class="comment">// &#39;ball::Severity::e_ERROR&#39; are (in addition to get pushed back</span>
      <span class="comment">// into the &#39;buffer&#39;) printed to &#39;stdout&#39;, and then each record</span>
      <span class="comment">// contained in &#39;buffer&#39; is in turn printed to &#39;stdout&#39; and then</span>
      <span class="comment">// removed from &#39;buffer&#39;.  That is, any severity level equal to or</span>
      <span class="comment">// more severe than &#39;ball::Severity::e_ERROR&#39; triggers a trace-back</span>
      <span class="comment">// of all records accumulated in the buffer and flushes the buffer.</span>
      <span class="comment">// The function is thread safe and thus allows multiple concurrent</span>
      <span class="comment">// invocations of this function with the same record buffer.</span>

  {
      <span class="keywordtype">int</span> severity = handle-&gt;fixedFields().severity();

      <span class="keywordflow">if</span> (<a class="code" href="structball_1_1Severity.html#af49f66189615b9475c9cced03afde384a784431e47d4121459476d62efde5b97e" title="a potentially problematic condition">ball::Severity::e_WARN</a> &gt;= severity) {
          buffer.<a class="code" href="classball_1_1RecordBuffer.html#ad659495ac5e0754df0064dc076171f0d">pushBack</a>(handle);
      }
      <span class="keywordflow">if</span> (<a class="code" href="structball_1_1Severity.html#af49f66189615b9475c9cced03afde384a40f100f08c6215870b466657f74cf5d2" title="a condition that will cause incorrect behavior">ball::Severity::e_ERROR</a> &gt;= severity) {
          bsl::cout &lt;&lt; *handle;
          buffer.<a class="code" href="classball_1_1RecordBuffer.html#afb3d78c8aa992f0f0db341c5493e1abe">beginSequence</a>(); <span class="comment">// lock the buffer before traversing</span>
          <span class="keywordtype">int</span> length = buffer.<a class="code" href="classball_1_1RecordBuffer.html#a7383de5134a98a8e27689e23ee1f4645">length</a>();
          <span class="keywordflow">while</span> (length--) {
              bsl::cout &lt;&lt; buffer.<a class="code" href="classball_1_1RecordBuffer.html#a3f639361cf28dd37a114f4abb5b6e346">back</a>();
              buffer.<a class="code" href="classball_1_1RecordBuffer.html#ac48c69f944127cb3921521a5cef0df25">popBack</a>();
          }
          buffer.<a class="code" href="classball_1_1RecordBuffer.html#a8c56bafa11d79af1faf4db4a82f90fb8">endSequence</a>();   <span class="comment">// unlock the buffer after traversing</span>
      }

  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:26 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
