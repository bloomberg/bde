<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslstl_sharedptr.h                                                 -*-C++-*-
#ifndef INCLUDED_BSLSTL_SHAREDPTR
#define INCLUDED_BSLSTL_SHAREDPTR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$ $CSID$&quot;)

//@PURPOSE: Provide a generic reference-counted shared pointer wrapper.
//
//@CLASSES:
//  bsl::shared_ptr: shared pointer
//  bsl::weak_ptr: &quot;weak&quot; reference to reference-counted shared object
//  bslstl::SharedPtrUtil: shared pointer utility functions
//  bslstl::SharedPtrNilDeleter: no-op deleter
//
//@SEE_ALSO: bslma_managedptr, bslma_sharedptrrep
//
//@DESCRIPTION: This component implements a thread-safe, generic,
// reference-counted &quot;smart pointer&quot; to support &quot;shared ownership&quot; of objects
// of (template parameter) &#39;ELEMENT_TYPE&#39;.  Shared pointers implement a form of
// the &quot;envelope/letter&quot; idiom.  For each shared object, a representation that
// manages the number of references to it is created.  Many shared pointers can
// simultaneously refer to the same shared object by storing a reference to the
// same representation.  Shared pointers also implement the &quot;construction is
// acquisition, destruction is release&quot; idiom.  When a shared pointer is
// created it increments the number of shared references to the shared object
// that was specified to its constructor (or was referred to by a shared
// pointer passed to the copy constructor).  When a shared pointer is assigned
// to or destroyed, then the number of shared references to the shared object
// is decremented.  When all references to the shared object are released, both
// the representation and the object are destroyed.  &#39;bsl::shared_ptr&#39; emulates
// the interface of a native pointer.  The shared object may be accessed
// directly using the &#39;-&gt;&#39; operator, or the dereference operator (operator &#39;*&#39;)
// can be used to obtain a reference to the shared object.
//
// This component also provides a mechanism, &#39;bsl::weak_ptr&#39;, used to create
// weak references to reference-counted shared (&#39;bsl::shared_ptr&#39;) objects.  A
// weak reference provides conditional access to a shared object managed by a
// &#39;bsl::shared_ptr&#39;, but, unlike a shared (or &quot;strong&quot;) reference, does not
// affect the shared object&#39;s lifetime.  An object having even one shared
// reference to it will not be destroyed, but an object having only weak
// references would have been destroyed when the last shared reference was
// released.
//
// A weak pointer can be constructed from another weak pointer or a
// &#39;bsl::shared_ptr&#39;.  To access the shared object referenced by a weak pointer
// clients must first obtain a shared pointer to that object using the &#39;lock&#39;
// method.  If the shared object has been destroyed (as indicated by the
// &#39;expired&#39; method), then &#39;lock&#39; returns a shared pointer in the default
// constructed (empty) state.
//
// This component also provides a functor, &#39;bslstl::SharedPtrNilDeleter&#39;, which
// may used to create a shared pointer that takes no action when the last
// shared reference is destroyed.
//
// This component also provides a utility class, &#39;bslstl::SharedPtrUtil&#39;, which
// provides several functions that are frequently used with shared pointers.
//
//
///Thread-Safety
///-------------
// This section qualifies the thread-safety of &#39;bsl::shared_ptr&#39; objects and
// &#39;bsl::weak_ptr&#39; objects themselves rather than the thread-safety of the
// objects being referenced.
//
// It is safe to access or modify two distinct &#39;shared_ptr&#39; (or
// &#39;bsl::weak_ptr&#39;) objects simultaneously, each from a separate thread, even
// if they share ownership of a common object.  It is safe to access a single
// &#39;bsl::shared_ptr&#39; (or &#39;bsl::weak_ptr&#39;) object simultaneously from two or
// more separate threads, provided no other thread is simultaneously modifying
// the object.  It is not safe to access or modify a &#39;bsl::shared_ptr&#39; (or
// &#39;bsl::weak_ptr&#39;) object in one thread while another thread modifies the same
// object.
//
// It is safe to access, modify, copy, or delete a shared pointer (or weak
// pointer) in one thread, while other threads access or modify other shared
// pointers and weak pointers pointing to or managing the same object (the
// reference count is managed using atomic operations).  However, there is no
// guarantee regarding the safety of accessing or modifying the object
// *referred* *to* by the shared pointer simultaneously from multiple threads.
//
///Shared and Weak References
///--------------------------
// There are two types of references to shared objects:
//
// 1) A shared reference allows users to share the ownership of an object and
// control its lifetime.  A shared object is destroyed only when the last
// shared reference to it is released.  A shared reference to an object can be
// obtained by creating a &#39;shared_ptr&#39; referring to it.
//
// 2) A weak reference provides users conditional access to an object without
// sharing its ownership (or affecting its lifetime).  A shared object can be
// destroyed even if there are weak references to it.  A weak reference to an
// object can be obtained by creating a &#39;weak_ptr&#39; referring to the object from
// a &#39;shared_ptr&#39; referring to that object.
//
///In-place/Out-of-place Representations
///-------------------------------------
// &#39;shared_ptr&#39; provides two types of representations: an out-of-place
// representation, and an in-place representation.  Out-of-place
// representations are used to refer to objects that are constructed externally
// to their associated representations.  Out-of-place objects are provided to a
// shared pointer by passing their address along with the deleter that should
// be used to destroy the object when all references to it have been released.
// In-place objects can be constructed directly within a shared pointer
// representation (see &#39;createInplace&#39;).
//
// Below we provide a diagram illustrating the differences between the two
// representations for a shared pointer to an &#39;int&#39;.  First we create an &#39;int&#39;
// object on the heap, initialized to 10, and pass its address to a shared
// pointer constructor, resulting in an out-of-place representation for the
// shared object:
//..
//  bslma::NewDeleteAllocator nda;
//  int *value = new (nda) int(10);
//  shared_ptr&lt;int&gt; outOfPlaceSharedPtr(value, &amp;nda);
//..
// Next we create an in-place representation of a shared &#39;int&#39; object that is
// also initialized to 10:
//..
//  shared_ptr&lt;int&gt; inPlaceSharedPtr;
//  inPlaceSharedPtr.createInplace(&amp;nda, 10);
//..
// The memory layouts of these two representations are shown below (where
// &#39;d_ptr_p&#39; refers to the shared object and &#39;d_rep_p&#39; refers to the
// representation):
//..
//  Out-of-Place Representation                 In-Place Representation
//  ----------------------------              ----------------------------
//
//  +------------+                            +------------+
//  |            |                            |            |
//  |  d_ptr_p ------&gt;+-----------+           |  d_ptr_p ---------+
//  |            |    |     10    |           |            |      |
//  |            |    +-----------+           |            |      |
//  |            |                            |            |      |
//  |  d_rep_p ------&gt;+-----------+           |  d_rep_p ------&gt;+-v---------+
//  |            |    | reference |           |            |    |+---------+|
//  |            |    |  counts   |           |            |    ||    10   ||
//  +------------+    +-----------+           +------------+    |+---------+|
//                                                              | reference |
//                                                              |  counts   |
//                                                              +-----------+
//..
// An out-of-place representation is generally less efficient than an in-place
// representation since it usually requires at least two allocations (one to
// construct the object and one to construct the shared pointer representation
// for the object).
//
// Creating an in-place shared pointer does not require the template parameter
// type to inherit from a special class (such as
// &#39;bsl::enable_shared_from_this&#39;); in that case, &#39;shared_ptr&#39; supports up to
// fourteen arguments that can be passed directly to the object&#39;s constructor.
// For in-place representations, both the object and the representation can be
// constructed in one allocation as opposed to two, effectively creating an
// &quot;intrusive&quot; reference counter.  Note that the size of the allocation is
// determined at compile-time from the combined footprint of the object and of
// the reference counts.  It is also possible to create shared pointers to
// buffers whose sizes are determined at runtime, although such buffers consist
// of raw (uninitialized) memory.
//
///Weak Pointers using &quot;in-place&quot; or Pooled Shared Pointer Representations
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// A weak pointer that is not in the empty state shares a common representation
// (used to refer to the shared object) with the shared (or other weak) pointer
// from which it was constructed, and holds this representation until it is
// either destroyed or reset.  This common representation is not destroyed and
// deallocated (although the shared object itself may have been destroyed)
// until all weak references to that common representation have been released.
//
// Due to this behavior the *memory* *footprint* of shared objects that are
// constructed &quot;in-place&quot; in the shared pointer representation (see above) is
// not deallocated until all weak references to that shared object are
// released.  Note that a shared object is always destroyed when the last
// shared reference to it is released.  Also note that the same behavior
// applies if the shared object were obtained from a class that pools shared
// pointer representations (for example, &#39;bcec_SharedObjectPool&#39;).
//
// For example suppose we have a class with a large memory footprint:
//..
//  class ClassWithLargeFootprint {
//      // This class has a large memory footprint.
//
//      // TYPES
//      enum { BUFFER_SIZE = 1024 };
//          // The size of the buffer owned by this &#39;class&#39;.
//
//      // DATA
//      char d_buffer[BUFFER_SIZE];
//
//      // ...
//  };
//..
// We then create an &quot;in-place&quot; shared pointer to an object of
// &#39;ClassWithLargeFootprint&#39; using the &#39;createInplace&#39; method of &#39;shared_ptr&#39;.
// The &#39;sp&#39; shared pointer representation of &#39;sp&#39; will create a
// &#39;ClassWithLargeFootprint&#39; object &quot;in-place&quot;:
//..
//  shared_ptr&lt;ClassWithLargeFootprint&gt; sp;
//  sp.createInplace();
//..
// Next we construct a weak pointer from this (in-place) shared pointer:
//..
//  weak_ptr&lt;ClassWithLargeFootprint&gt; wp(sp);
//..
// Now releasing all shared references to the shared object (using the &#39;reset&#39;
// function) causes the object&#39;s destructor to be called, but the
// representation is not destroyed (and the object&#39;s footprint is not
// deallocated) until &#39;wp&#39; releases its weak reference:
//..
//  sp.reset(); // The object&#39;s footprint is not deallocated until all weak
//              // references to it are released.
//
//  wp.reset(); // The release of the *last* weak reference results in the
//              // destruction and deallocation of the representation and the
//              // object&#39;s footprint.
//..
// If a shared object has a large footprint, and the client anticipates there
// will be weak references to it, then an out-of-place shared pointer
// representation may be preferred because it destroys the shared object and
// deallocates its footprint when the last *shared* reference is released,
// regardless of whether there are any outstanding weak references to the same
// representation.
//
///Correct Usage of the Allocator Model
///------------------------------------
// Note that once constructed, there is no difference in type, usage, or
// efficiency between in-place and out-of-place shared pointers, except that an
// in-place shared pointer will exhibit greater locality of reference and
// faster destruction (because there is only one allocated block).  Also note
// that an object created with an allocator needs to have this allocator
// specified as its last constructor argument, but this allocator may be
// different from the one passed as the first argument to &#39;createInplace&#39;.
//
// For example, consider the following snippet of code:
//..
//  bslma::Allocator *allocator1, *allocator2;
//  // ...
//  shared_ptr&lt;bsl::string&gt; ptr;
//  ptr.createInplace(allocator1, bsl::string(&quot;my string&quot;), allocator2);
//..
// Here &#39;allocator1&#39; is used to obtain the shared pointer representation and
// the in-place &#39;bsl::string&#39; object, and &#39;allocator2&#39; is used by the
// &#39;bsl::string&#39; object (having the value &quot;my string&quot;) for its memory
// allocations.  Typically, both allocators will be the same, and so the same
// allocator will need to be specified twice.
//
///Deleters
///--------
// When the last shared reference to a shared object is released, the object is
// destroyed using the &quot;deleter&quot; provided when the associated shared pointer
// representation was created.  &#39;shared_ptr&#39; supports two kinds of &quot;deleter&quot;
// objects, which vary in how they are invoked.  A &quot;function-like&quot; deleter is
// any language entity that can be invoked such that the expression
// &#39;deleterInstance(objectPtr)&#39; is a valid expression, and a &quot;factory&quot; deleter
// is any language entity that can be invoked such that the expression
// &#39;deleterInstance.deleteObject(objectPtr)&#39; is a valid expression, where
// &#39;deleterInstance&#39; is an instance of the &quot;deleter&quot; object, and &#39;objectPtr&#39; is
// a pointer to the shared object.  In summary:
//..
//  Deleter                     Expression used to destroy &#39;objectPtr&#39;
//  - - - - - - - - - - - -     - - - - - - - - - - - - - - - - - - -
//  &quot;function-like&quot;             deleterInstance(objectPtr);
//  &quot;factory&quot;                   deleterInstance.deleteObject(objectPtr);
//..
// The following are examples of function-like deleters that delete an object
// of &#39;my_Type&#39;:
//..
//  void deleteObject(my_Type *object);
//      // Delete the specified &#39;object&#39;.
//
//  void releaseObject(my_Type *object);
//      // Release the specified &#39;object&#39;.
//
//  struct FunctionLikeDeleterObject {
//      // This &#39;struct&#39; provides an &#39;operator()&#39; that can be used to delete a
//      // &#39;my_Type&#39; object.
//
//      void operator()(my_Type *object);
//          // Destroy the specified &#39;object&#39;.
//  };
//..
// The following, on the other hand is an example of a factory deleter:
//..
//  class my_Factory {
//
//     // . . .
//
//     // MANIPULATORS
//     my_Type *createObject(bslma::Allocator *basicAllocator = 0);
//         // Create a &#39;my_Type&#39; object.  Optionally specify a
//         // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//         // 0, the currently installed default allocator is used.
//
//     void deleteObject(my_Type *object);
//         // Delete the specified &#39;object&#39;.
//  };
//
//  class my_Allocator : public bslma::Allocator { /* ... */ };
//..
// Note that &#39;deleteObject&#39; is provided by all &#39;bslma&#39; allocators and by any
// object that implements the &#39;bcema_Deleter&#39; protocol.  Thus, any of these
// objects can be used as a factory deleter.  The purpose of this design is to
// allow &#39;bslma&#39; allocators and factories to be used seamlessly as deleters.
//
// The selection of which expression is used by &#39;shared_ptr&#39; to destroy a
// shared object is based on how the deleter is passed to the shared pointer
// object: Deleters that are passed by *address* are assumed to be factory
// deleters (unless they are function pointers), while those that are passed by
// *value* are assumed to be function-like.  Note that if the wrong interface
// is used for a deleter, i.e., if a function-like deleter is passed by
// pointer, or a factory deleter is passed by value, and the expression used to
// delete the object is invalid, a compiler diagnostic will be emitted
// indicating the error.
//
// In general, deleters should have defined behavior when called with a null
// pointer.  In all cases, throwing an exception out of a copy constructor for
// a deleter will yield undefined behavior.
//
// The following are examples of constructing shared pointers with the
// addresses of factory deleters:
//..
//  my_Factory factory;
//  my_Type *myPtr1 = factory.createObject();
//  shared_ptr&lt;my_Type&gt; mySharedPtr1(myPtr1, &amp;factory, 0);
//
//  bdema_SequentialAllocator sa;
//  my_Type *myPtr2 = new (sa) my_Type(&amp;sa);
//  shared_ptr&lt;my_Type&gt; mySharedPtr2(myPtr2, &amp;sa);
//..
// Note that the deleters are passed *by address* in the above examples.
//
// The following are examples of constructing shared pointers with
// function-like deleters:
//..
//  my_Type *getObject(bslma::Allocator *basicAllocator = 0);
//
//  my_Type *myPtr3 = getObject();
//  shared_ptr&lt;my_Type&gt; mySharedPtr3(myPtr3, &amp;deleteObject);
//
//  my_Type *myPtr4 = getObject();
//  FunctionLikeDeleterObject deleter;
//  shared_ptr&lt;my_Type&gt; mySharedPtr4(myPtr4, deleter, &amp;sa);
//..
// Note that &#39;deleteObject&#39; is also passed by address, but &#39;deleter&#39; is passed
// by value in the above examples.  Function-like deleter objects (passed by
// value) are stored by value in the representation and therefore *must* be
// copy-constructible.  Note that even though the deleter may be passed by
// reference, it is a copy (owned by the shared pointer representation) that is
// invoked and thus the &#39;deleterInstance&#39; is not required, nor assumed, to be
// non-modifiable.  (For the example above, note that &#39;operator()&#39; is
// intentionally *not* defined &#39;const&#39;.)
//
///Aliasing
///--------
// &#39;shared_ptr&#39; supports a powerful &quot;aliasing&quot; feature.  That is, a shared
// pointer can be constructed to refer to a shared object of a certain type
// while the shared pointer representation it holds refers to a shared object
// of any (possibly different) type.  All references are applied to the
// &quot;aliased&quot; shared object referred to by the representation and is used for
// reference counting.  This &quot;aliased&quot; shared object is passed to the deleter
// upon destruction of the last instance of that shared pointer.  Consider the
// following snippet of code:
//..
//  class Event { /* ... */ };
//  void getEvents(bsl::list&lt;Event&gt; *list);
//
//  void enqueueEvents(bcec_Queue&lt;shared_ptr&lt;Event&gt; &gt; *queue)
//  {
//      bsl::list&lt;Event&gt; eventList;
//      getEvents(&amp;eventList);
//      for (bsl::list&lt;Event&gt;::iterator it = eventList.begin();
//           it != eventList.end();
//           ++it) {
//          shared_ptr&lt;Event&gt; e;
//          e.createInplace(0, *it);  // Copy construct the event into a new
//                                    // shared ptr.
//          queue-&gt;pushBack(e);
//      }
//  }
//..
// In the above example, &#39;getEvents&#39; loads into the provided &#39;bsl::list&#39; a
// sequence of event objects.  The &#39;enqueueEvents&#39; function constructs an empty
// list and calls &#39;getEvents&#39; to fill the list with &#39;Event&#39; objects.  Once the
// event list is filled, each event item is pushed as a shared pointer
// (presumably because events are &quot;expensive&quot; to construct and may be
// referenced simultaneously from multiple threads) onto the provided queue.
// Since the individual event items are contained by value within the list,
// pointers to them cannot be passed if it cannot be guaranteed that they will
// not live beyond the lifetime of the list itself.  Therefore, an expensive
// copy operation is required to create individually-managed instances of each
// of the list items.  The &#39;createInplace&#39; operation is used to reduce the
// number of required allocations, but this might still be too expensive.  Now
// consider the following alternate implementation of &#39;enqueueEvents&#39; using the
// &#39;shared_ptr&#39; aliasing feature:
//..
//  void enqueueEvents(bcec_Queue&lt;shared_ptr&lt;Event&gt; &gt; *queue)
//  {
//      shared_ptr&lt;bsl::list&lt;Event&gt; &gt; eventList;
//      eventList.createInplace(0);  // Construct a shared pointer
//                                   // to the event list containing
//                                   // all of the events.
//      getEvents(eventList.get());
//
//      for (bsl::list&lt;Event&gt;::iterator it = eventList-&gt;begin();
//           it != eventList-&gt;end();
//           ++it) {
//          // Push each event onto the queue as an alias of the &#39;eventList&#39;
//          // shared pointer.  When all the alias references have been
//          // released, the event list will be destroyed deleting all the
//          // events at once.
//
//          queue-&gt;pushBack(shared_ptr&lt;Event&gt;(eventList, &amp;*it));
//      }
//  }
//..
// In the implementation above, we create a single shared pointer to the
// &#39;Event&#39; list, &#39;eventList&#39;, and use that to create &#39;Event&#39; shared pointers
// that are aliased to &#39;eventList&#39;.  The lifetime of each &#39;Event&#39; object is
// then tied to the &#39;eventList&#39; and it will not be destroyed until the
// &#39;eventList&#39; is destroyed.
//
///Type Casting
///------------
// A &#39;shared_ptr&#39; object of a given type can be implicitly or explicitly cast
// to a &#39;shared_ptr&#39; of another type.
//
///Implicit Casting
/// - - - - - - - -
// As with native pointers, a shared pointer to a derived type can be directly
// assigned to a shared pointer to a base type.  In other words, if the
// following statements are valid:
//..
//  class A { virtual void foo(); };  // polymorphic type
//  class B : public A {};
//  B *bp = 0;
//  A *ap = bp;
//..
// then the following statements:
//..
//  shared_ptr&lt;B&gt; spb;
//  shared_ptr&lt;A&gt; spa;
//  spa = spb;
//..
// and:
//..
//  shared_ptr&lt;B&gt; spb;
//  shared_ptr&lt;A&gt; spa(spb);
//..
// are also valid.  Note that in all of the above cases, the destructor of &#39;B&#39;
// will be invoked when the object is destroyed even if &#39;A&#39; does not provide a
// virtual destructor.
//
///Explicit Casting
/// - - - - - - - -
// Through &quot;aliasing&quot;, a shared pointer of any type can be explicitly cast to a
// shared pointer of any other type using any legal cast expression.  For
// example, to statically cast a shared pointer to type &#39;A&#39; (&#39;shared_ptr&lt;A&gt;&#39;)
// to a shared pointer to type &#39;B&#39; (&#39;shared_ptr&lt;B&gt;&#39;), one can simply do the
// following:
//..
//  shared_ptr&lt;A&gt; spa;
//  shared_ptr&lt;B&gt; spb(spa, static_cast&lt;B *&gt;(spa.get()));
//..
// or even the less safe C-style cast:
//..
//  shared_ptr&lt;A&gt; spa;
//  shared_ptr&lt;B&gt; spb(spa, (B *)(spa.get()));
//..
// For convenience, several utility functions are provided to perform common
// C++ casts.  Dynamic casts, static casts, and &#39;const&#39; casts are all provided.
// Explicit casting is supported through the &#39;bslstl::SharedPtrUtil&#39; utility.
// The following example demonstrates the dynamic casting of a shared pointer
// to type &#39;A&#39; (&#39;shared_ptr&lt;A&gt;&#39;) to a shared pointer to type &#39;B&#39;
// (&#39;shared_ptr&lt;B&gt;&#39;):
//..
//  bslma::NewDeleteAllocator nda;
//  shared_ptr&lt;A&gt; sp1(new (nda) A(), &amp;nda);
//  shared_ptr&lt;B&gt; sp2 = bslstl::SharedPtrUtil::dynamicCast&lt;B&gt;(sp1);
//  shared_ptr&lt;B&gt; sp3;
//  bslstl::SharedPtrUtil::dynamicCast(&amp;sp3, sp1);
//  shared_ptr&lt;B&gt; sp4;
//  sp4 = bslstl::SharedPtrUtil::dynamicCast&lt;B&gt;(sp1);
//..
// To test if the cast succeeded, simply test if the target shared pointer
// refers to a non-null value (assuming the source was not null, of course):
//..
//  if (sp2) {
//      // The cast succeeded.
//  } else {
//      // The cast failed.
//  }
//..
// As previously stated, the shared object will be destroyed correctly
// regardless of how it is cast.
//
///Converting to and from &#39;BloombergLP::bslma::ManagedPtr&#39;
///-------------------------------------------------------
// A &#39;shared_ptr&#39; can be converted to a &#39;BloombergLP::bslma::ManagedPtr&#39; while
// still retaining proper reference counting.  When a shared pointer is
// converted to a &#39;BloombergLP::bslma::ManagedPtr&#39;, the number of references to
// the shared object is incremented.  When the managed pointer is destroyed (if
// not transferred to another managed pointer first), the number of references
// will be decremented.  If the number of references reaches zero, then the
// shared object will be destroyed.  The &#39;managedPtr&#39; function can be used to
// create a managed pointer from a shared pointer.
//
// A &#39;shared_ptr&#39; also can be constructed from a
// &#39;BloombergLP::bslma::ManagedPtr&#39;.  The resulting shared pointer takes over
// the management of the object and will use the deleter from the original
// &#39;BloombergLP::bslma::ManagedPtr&#39; to destroy the managed object when all the
// references to that shared object are released.
//
///Weak Pointers using &quot;in-place&quot; or Pooled Shared Pointer Representations
///-----------------------------------------------------------------------
// A weak pointer that is not in the empty state shares a common representation
// (used to refer to the shared object) with the shared (or other weak) pointer
// from which it was constructed, and holds this representation until it is
// either destroyed or reset.  This common representation is not destroyed and
// deallocated (although the shared object itself may have been destroyed)
// until all weak references to that common representation have been released.
//
// Due to this behavior the memory footprint of shared objects that are
// constructed &quot;in-place&quot; in the shared pointer representation (refer to the
// component-level documentation of &#39;bsl::shared_ptr&#39; for more information on
// shared pointers with &quot;in-place&quot; representations) is not deallocated until
// all weak references to that shared object are released.  Note that a shared
// object is always destroyed when the last shared reference to it is released.
// Also note that the same behavior is applicable if the shared objects were
// obtained from a class that pools shared pointer representations (for
// example, &#39;bcec_SharedObjectPool&#39;).
//
// For example suppose we have a class with a large memory footprint:
//..
//  class ClassWithLargeFootprint {
//      // This class has a large memory footprint.
//
//      // TYPES
//      enum { BUFFER_SIZE = 1024 };
//          // The size of the buffer owned by this &#39;class&#39;.
//
//      // DATA
//      char d_buffer[BUFFER_SIZE];
//
//      // ...
//  };
//..
// We then create an &quot;in-place&quot; shared pointer to an object of
// &#39;ClassWithLargeFootprint&#39; using the &#39;createInplace&#39; method of
// &#39;bsl::shared_ptr&#39;.  The &#39;sp&#39; shared pointer representation of &#39;sp&#39; will
// create a &#39;ClassWithLargeFootprint&#39; object &quot;in-place&quot;:
//..
//  bsl::shared_ptr&lt;ClassWithLargeFootprint&gt; sp;
//  sp.createInplace();
//..
// Next we construct a weak pointer from this (in-place) shared pointer:
//..
//  bsl::weak_ptr&lt;ClassWithLargeFootprint&gt; wp(sp);
//..
// Now releasing all shared references to the shared object (using the &#39;reset&#39;
// function) causes the object&#39;s destructor to be called, but the
// representation is not destroyed (and the object&#39;s footprint is not
// deallocated) until &#39;wp&#39; releases its weak reference:
//..
//  sp.reset(); // The object&#39;s footprint is not deallocated until all weak
//              // references to it are released.
//
//  wp.reset(); // The release of the *last* weak reference results in the
//              // destruction and deallocation of the representation and the
//              // object&#39;s footprint.
//..
// If a shared object has a large footprint, and the client anticipates there
// will be weak references to it, then it may be advisable to create an
// out-of-place shared pointer representation, which destroys the shared object
// and deallocates its footprint when the last *shared* reference to it is
// released, regardless of whether there are any outstanding weak references to
// the same representation.
//
///C++ Standard Compliance
///-----------------------
// This component provides a (subset of a) standard-compliant implementation of
// &#39;std::shared_ptr&#39; and &#39;std::weak_ptr&#39; (section 20.7.2, [util.smartptr], of
// the ISO C++11 standard)).  Its interface is limited to the set of operations
// that can be implemented by an implementation of the C++03 language, e,g.,
// there is no specific support for rvalue references.  It does not support the
// atomic shared pointer interface, nor does it collaborate with types that
// derive from &#39;std::enable_shared_this&#39;: using &#39;shared_ptr&#39; with such types
// will result in (very destructive) undefined behavior.
//
// This component supports allocators following the &#39;bslma::Allocator&#39; protocol
// in addition to the C++ Standard Allocators (section 17.6.3.5,
// [allocator.requirements]) and interoperation with &#39;bslma::ManagedPtr&#39; smart
// pointers.
//
///Usage
///-----
// The following examples demonstrate various features and uses of shared
// pointers.
//
///Example 1 - Basic Usage
///- - - - - - - - - - - -
// The following example demonstrates the creation of a shared pointer.  First,
// we declare the type of object that we wish to manage:
//..
//  class MyUser {
//      // DATA
//      bsl::string d_name;
//      int         d_id;
//
//    public:
//      // CREATORS
//      MyUser(bslma::Allocator *alloc = 0) : d_name(alloc), d_id(0) {}
//      MyUser(const bsl::string&amp; name, int id, bslma::Allocator *alloc = 0)
//      : d_name(name, alloc)
//      , d_id(id)
//      {
//      }
//      MyUser(const MyUser&amp; original, bslma::Allocator *alloc = 0)
//      : d_name(original.d_name, alloc)
//      , d_id(original.d_id)
//      {
//      }
//
//      // MANIPULATORS
//      void setName(const bsl::string&amp; name) { d_name = name; }
//      void setId(int id) { d_id = id; }
//
//      // ACCESSORS
//      const bsl::string&amp; name() const { return d_name; }
//      int id() const { return d_id; }
//  };
//..
// The &#39;createUser&#39; utility function (below) creates a &#39;MyUser&#39; object using
// the provided allocator and returns a shared pointer to the newly-created
// object.  Note that the shared pointer&#39;s internal representation will also be
// allocated using the same allocator.  Also note that if &#39;allocator&#39; is 0, the
// currently-installed default allocator is used.
//..
//  shared_ptr&lt;MyUser&gt; createUser(bsl::string       name,
//                                     int               id,
//                                     bslma::Allocator *allocator = 0)
//  {
//      allocator = bslma::Default::allocator(allocator);
//      MyUser *user = new (*allocator) MyUser(name, id, allocator);
//      return shared_ptr&lt;MyUser&gt;(user, allocator);
//  }
//..
// Since the &#39;createUser&#39; function both allocates the object and creates the
// shared pointer, it can benefit from the in-place facilities to avoid an
// extra allocation.  Again, note that the representation will also be
// allocated using the same allocator (see the section &quot;Correct Usage of the
// Allocator Model&quot; above).  Also note that if &#39;allocator&#39; is 0, the
// currently-installed default allocator is used.
//..
//  shared_ptr&lt;MyUser&gt; createUser2(bsl::string       name,
//                                      int               id,
//                                      bslma::Allocator *allocator = 0)
//  {
//      shared_ptr&lt;MyUser&gt; user;
//      user.createInplace(allocator, name, id, allocator);
//      return user;
//  }
//..
// Note that the shared pointer allocates both the reference count and the
// &#39;MyUser&#39; object in a single region of memory (which is the memory that will
// eventually be deallocated), but refers to the &#39;MyUser&#39; object only.
//
///Using Custom Deleters
///- - - - - - - - - - -
// The following examples demonstrate the use of custom deleters with shared
// pointers.
//
///Example 2 - Nil deleters
///  -  -  -  -  -  -  -  -
// There are cases when an interface calls for an object to be passed as a
// shared pointer, but the object being passed is not owned by the caller
// (e.g., a pointer to a static variable).  In these cases, it is possible to
// create a shared pointer specifying &#39;bslstl::SharedPtrNilDeleter&#39; as the
// deleter.  The deleter function provided by &#39;bslstl::SharedPtrNilDeleter&#39; is
// a no-op and does not delete the object.  The following example demonstrates
// the use of &#39;shared_ptr&#39; using a &#39;bslstl::SharedPtrNilDeleter&#39;.  The code
// uses the &#39;MyUser&#39; class defined in Example 1.  In this example, an
// asynchronous transaction manager is implemented.  Transactions are enqueued
// into the transaction manager to be processed at some later time.  The user
// associated with the transaction is passed as a shared pointer.  Transactions
// can originate from the &quot;system&quot; or from &quot;users&quot;.
//
// We first declare the transaction manager and transaction info classes:
//..
//  class MyTransactionInfo {
//      // Transaction Info...
//  };
//
//  class MyTransactionManager {
//
//      // PRIVATE MANIPULATORS
//      int enqueueTransaction(shared_ptr&lt;MyUser&gt;  user,
//                             const MyTransactionInfo&amp; transaction);
//    public:
//      // CLASS METHODS
//      static MyUser *systemUser(bslma::Allocator *basicAllocator = 0);
//
//      // MANIPULATORS
//      int enqueueSystemTransaction(const MyTransactionInfo&amp; transaction);
//
//      int enqueueUserTransaction(const MyTransactionInfo&amp; transaction,
//                                 shared_ptr&lt;MyUser&gt;  user);
//
//  };
//..
// The &#39;systemUser&#39; class method returns the same &#39;MyUser&#39; object and should
// not be destroyed by its users:
//..
//  MyUser *MyTransactionManager::systemUser(
//                                      bslma::Allocator */* basicAllocator */)
//  {
//      static MyUser *systemUserSingleton;
//      if (!systemUserSingleton) {
//          // instantiate singleton in a thread-safe manner passing
//          // &#39;basicAllocator&#39;
//
//          // . . .
//      }
//      return systemUserSingleton;
//  }
//..
// For enqueuing user transactions, simply proxy the information to
// &#39;enqueueTransaction&#39;.
//..
//  inline
//  int MyTransactionManager::enqueueUserTransaction(
//                                  const MyTransactionInfo&amp; transaction,
//                                  shared_ptr&lt;MyUser&gt;  user)
//  {
//      return enqueueTransaction(user, transaction);
//  }
//..
// For system transactions, we must use the &#39;MyUser&#39; objected returned from the
// &#39;systemUser&#39; &#39;static&#39; method.  Since we do not own the returned object, we
// cannot directly construct a &#39;shared_ptr&#39; object for it: doing so would
// result in the singleton being destroyed when the last reference to the
// shared pointer is released.  To solve this problem, we construct a
// &#39;shared_ptr&#39; object for the system user using a nil deleter.  When the last
// reference to the shared pointer is released, although the deleter will be
// invoked to destroy the object, it will do nothing.
//..
//  int MyTransactionManager::enqueueSystemTransaction(
//                                        const MyTransactionInfo&amp; transaction)
//  {
//      shared_ptr&lt;MyUser&gt; user(systemUser(),
//                                   bslstl::SharedPtrNilDeleter(),
//                                   0);
//      return enqueueTransaction(user, transaction);
//  }
//..
//
///Example 3 - Basic Weak Pointer Usage
/// - - - - - - - - - - - - - - - - - -
// This example illustrates the basic syntax needed to create and use a
// &#39;bsl::weak_ptr&#39;.  Suppose that we want to construct a weak pointer that
// refers to an &#39;int&#39; managed by a shared pointer.  Next we define the shared
// pointer and assign a value to the shared &#39;int&#39;:
//..
//  bsl::shared_ptr&lt;int&gt; intPtr;
//  intPtr.createInplace(bslma::Default::allocator());
//  *intPtr = 10;
//  assert(10 == *intPtr);
//..
// Next we construct a weak pointer to the &#39;int&#39;:
//..
//  bsl::weak_ptr&lt;int&gt; intWeakPtr(intPtr);
//  assert(!intWeakPtr.expired());
//..
// &#39;bsl::weak_ptr&#39; does not provide direct access to the shared object being
// referenced.  To access and manipulate the &#39;int&#39; from the weak pointer, we
// have to obtain a shared pointer from it:
//..
//  bsl::shared_ptr&lt;int&gt; intPtr2 = intWeakPtr.lock();
//  assert(intPtr2);
//  assert(10 == *intPtr2);
//
//  *intPtr2 = 20;
//  assert(20 == *intPtr);
//  assert(20 == *intPtr2);
//..
// We remove the weak reference to the shared &#39;int&#39; by calling the &#39;reset&#39;
// method:
//..
//  intWeakPtr.reset();
//  assert(intWeakPtr.expired());
//..
// Note that resetting the weak pointer does not affect the shared pointers
// referencing the &#39;int&#39; object:
//..
//  assert(20 == *intPtr);
//  assert(20 == *intPtr2);
//..
// Now, we construct another weak pointer referencing the shared &#39;int&#39;:
//..
//  bsl::weak_ptr&lt;int&gt; intWeakPtr2(intPtr);
//  assert(!intWeakPtr2.expired());
//..
// Finally &#39;reset&#39; all shared references to the &#39;int&#39;, which will cause the
// weak pointer to become &quot;expired&quot;; any subsequent attempt to obtain a shared
// pointer from the weak pointer will return a shared pointer in the default
// constructed (empty) state:
//..
//  intPtr.reset();
//  intPtr2.reset();
//  assert(intWeakPtr2.expired());
//  assert(!intWeakPtr2.lock());
//..
// Example 4 - Breaking cyclical dependencies
//- - - - - - - - - - - - - - - - - - - - - -
// Weak pointers are frequently used to break cyclical dependencies between
// objects that store references to each other via a shared pointer.  Consider
// for example a simplified news alert system that sends news alerts to users
// based on keywords that they register for.  The user information is stored in
// the &#39;User&#39; class and the details of the news alert are stored in the &#39;Alert&#39;
// class.  The class definitions for &#39;User&#39; and &#39;Alert&#39; are provided below
// (with any code not relevant to this example elided):
//..
//  class Alert;
//
//  class User {
//      // This class stores the user information required for listening to
//      // alerts.
//
//      bsl::vector&lt;bsl::shared_ptr&lt;Alert&gt; &gt; d_alerts;  // alerts user is
//                                                      // registered for
//
//      // ...
//
//    public:
//      // MANIPULATORS
//      void addAlert(const bsl::shared_ptr&lt;Alert&gt;&amp; alertPtr)
//      {
//          // Add the specified &#39;alertPtr&#39; to the list of alerts being
//          // monitored by this user.
//
//          d_alerts.push_back(alertPtr);
//      }
//
//      // ...
//  };
//..
// Now we define an alert class, &#39;Alert&#39;:
//..
//  class Alert {
//      // This class stores the alert information required for sending
//      // alerts.
//
//      bsl::vector&lt;bsl::shared_ptr&lt;User&gt; &gt; d_users;  // users registered
//                                                    // for this alert
//
//    public:
//      // MANIPULATORS
//      void addUser(const bsl::shared_ptr&lt;User&gt;&amp; userPtr)
//      {
//          // Add the specified &#39;userPtr&#39; to the list of users monitoring this
//          // alert.
//
//          d_users.push_back(userPtr);
//      }
//
//      // ...
//  };
//
//..
// Even though we have released &#39;alertPtr&#39; and &#39;userPtr&#39; there still exists a
// cyclic reference between the two objects, so none of the objects are
// destroyed.
//
// We can break this cyclical dependency we define a modified alert class
// &#39;ModifiedAlert&#39; that stores a weak pointer to a &#39;ModifiedUser&#39; object.
// Below is the definition for the &#39;ModifiedUser&#39; class that is identical to
// the &#39;User&#39; class, the only difference being that it stores shared pointer to
// &#39;ModifiedAlert&#39;s instead of &#39;Alert&#39;s:
//..
//  class ModifiedAlert;
//
//  class ModifiedUser {
//      // This class stores the user information required for listening to
//      // alerts.
//
//      bsl::vector&lt;bsl::shared_ptr&lt;ModifiedAlert&gt; &gt; d_alerts;// alerts user is
//                                                            // registered for
//
//      // ...
//
//    public:
//      // MANIPULATORS
//      void addAlert(const bsl::shared_ptr&lt;ModifiedAlert&gt;&amp; alertPtr)
//      {
//          // Add the specified &#39;alertPtr&#39; to the list of alerts being
//          // monitored by this user.
//
//          d_alerts.push_back(alertPtr);
//      }
//
//      // ...
//  };
//..
// Now we define the &#39;ModifiedAlert&#39; class:
//..
//  class ModifiedAlert {
//      // This class stores the alert information required for sending
//      // alerts.
//
//..
// Note that the user is stored by a weak pointer instead of by a shared
// pointer:
//..
//      bsl::vector&lt;bsl::weak_ptr&lt;ModifiedUser&gt; &gt; d_users;  // users registered
//                                                          // for this alert
//
//    public:
//      // MANIPULATORS
//      void addUser(const bsl::weak_ptr&lt;ModifiedUser&gt;&amp; userPtr)
//      {
//          // Add the specified &#39;userPtr&#39; to the list of users monitoring this
//          // alert.
//
//          d_users.push_back(userPtr);
//      }
//
//      // ...
//  };
//..
//
// Usage example 5 - Caching example
// - - - - - - - - - - - - - - - - -
// Suppose we want to implement a peer to peer file sharing system that allows
// users to search for files that match specific keywords.  A simplistic
// version of such a system with code not relevant to the usage example elided
// would have the following parts:
//
// a) A peer manager class that maintains a list of all connected peers and
// updates the list based on incoming peer requests and disconnecting peers.
// The following would be a simple interface for the Peer and PeerManager
// classes:
//..
//  class Peer {
//      // This class stores all the relevant information for a peer.
//
//      // ...
//  };
//
//  class PeerManager {
//      // This class acts as a manager of peers and adds and removes peers
//      // based on peer requests and disconnections.
//
//      // DATA
//..
// The peer objects are stored by shared pointer to allow peers to be passed to
// search results and still allow their asynchronous destruction when peers
// disconnect.
//..
//      bsl::map&lt;int, bsl::shared_ptr&lt;Peer&gt; &gt; d_peers;
//
//      // ...
//  };
//..
// b) A peer cache class that stores a subset of the peers that are used for
// sending search requests.  The cache may select peers based on their
// connection bandwidth, relevancy of previous search results, etc.  For
// brevity the population and flushing of this cache is not shown:
//..
//  class PeerCache {
//      // This class caches a subset of all peers that match certain criteria
//      // including connection bandwidth, relevancy of previous search
//      // results, etc.
//
//..
// Note that the cached peers are stored as a weak pointer so as not to
// interfere with the cleanup of Peer objects by the PeerManager if a Peer goes
// down.
//..
//      // DATA
//      bsl::list&lt;bsl::weak_ptr&lt;Peer&gt; &gt; d_cachedPeers;
//
//    public:
//      // TYPES
//      typedef bsl::list&lt;bsl::weak_ptr&lt;Peer&gt; &gt;::const_iterator PeerConstIter;
//
//      // ...
//
//      // ACCESSORS
//      PeerConstIter begin() const { return d_cachedPeers.begin(); }
//      PeerConstIter end() const   { return d_cachedPeers.end(); }
//  };
//..
// c) A search result class that stores a search result and encapsulates a peer
// with the file name stored by the peer that best matches the specified
// keywords:
//..
//  class SearchResult {
//      // This class provides a search result and encapsulates a particular
//      // peer and filename combination that matches a specified set of
//      // keywords.
//
//..
// The peer is stored as a weak pointer because when the user decides to select
// a particular file to download from this peer, the peer might have
// disconnected.
//..
//      // DATA
//      bsl::weak_ptr&lt;Peer&gt; d_peer;
//      bsl::string         d_filename;
//
//    public:
//      // CREATORS
//      SearchResult(const bsl::weak_ptr&lt;Peer&gt;&amp; peer,
//                   const bsl::string&amp;         filename)
//      : d_peer(peer)
//      , d_filename(filename)
//      {
//      }
//
//      // ...
//
//      // ACCESSORS
//      const bsl::weak_ptr&lt;Peer&gt;&amp; peer() const { return d_peer; }
//      const bsl::string&amp; filename() const { return d_filename; }
//  };
//..
// d) A search function that takes a list of keywords and returns available
// results by searching the cached peers:
//..
//  ;
//
//  void search(bsl::vector&lt;SearchResult&gt;       */* results */,
//              const PeerCache&amp;                 peerCache,
//              const bsl::vector&lt;bsl::string&gt;&amp;  /* keywords */)
//  {
//      for (PeerCache::PeerConstIter iter = peerCache.begin();
//           iter != peerCache.end();
//           ++iter) {
//..
// First we check if the peer is still connected by acquiring a shared pointer
// to the peer.  If the acquire operation succeeds then we can send the peer a
// request to send back the file best matching the specified keywords:
//..
//          bsl::shared_ptr&lt;Peer&gt; peerSharedPtr = iter-&gt;lock();
//          if (peerSharedPtr) {
//
//              // Search the peer for file best matching the specified
//              // keywords and if a file is found add the returned
//              // SearchResult object to result.
//
//              // ...
//          }
//      }
//  }
//..
// e) A download function that downloads a file selected by the user:
//..
//  void download(const SearchResult&amp; result)
//  {
//      bsl::shared_ptr&lt;Peer&gt; peerSharedPtr = result.peer().lock();
//      if (peerSharedPtr) {
//          // Download the result.filename() file from peer knowing that
//          // the peer is still connected.
//      }
//  }
//..

// Prevent &#39;bslstl&#39; headers from being included directly in &#39;BSL_OVERRIDES_STD&#39;
// mode.  Doing so is unsupported, and is likely to cause compilation errors.
#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
#error &quot;include &lt;bsl_memory.h&gt; instead of &lt;bslstl_sharedptr.h&gt; in \
BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ALLOCATOR
#include &lt;bslstl_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ALLOCATORTRAITS
#include &lt;bslstl_allocatortraits.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_HASH
#include &lt;bslstl_hash.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_PAIR
#include &lt;bslstl_pair.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_SHAREDPTRALLOCATEINPLACEREP
#include &lt;bslstl_sharedptrallocateinplacerep.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_SHAREDPTRALLOCATEOUTOFPLACEREP
#include &lt;bslstl_sharedptrallocateoutofplacerep.h&gt;
#endif

#ifndef INCLUDED_BSLALG_HASHUTIL
#include &lt;bslalg_hashutil.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SCALARPRIMITIVES
#include &lt;bslalg_scalarprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMA_MANAGEDPTR
#include &lt;bslma_managedptr.h&gt;
#endif

#ifndef INCLUDED_BSLMA_SHAREDPTRINPLACEREP
#include &lt;bslma_sharedptrinplacerep.h&gt;
#endif

#ifndef INCLUDED_BSLMA_SHAREDPTROUTOFPLACEREP
#include &lt;bslma_sharedptroutofplacerep.h&gt;
#endif

#ifndef INCLUDED_BSLMA_SHAREDPTRREP
#include &lt;bslma_sharedptrrep.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ADDLVALUEREFERENCE
#include &lt;bslmf_addlvaluereference.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ADDPOINTER
#include &lt;bslmf_addpointer.h&gt;
#endif

#ifndef INCLUDED_BSLMF_CONDITIONAL
#include &lt;bslmf_conditional.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ENABLEIF
#include &lt;bslmf_enableif.h&gt;
#endif

#ifndef INCLUDED_BSLMF_HASPOINTERSEMANTICS
#include &lt;bslmf_haspointersemantics.h&gt;
#endif

#ifndef INCLUDED_BSLMF_INTEGRALCONSTANT
#include &lt;bslmf_integralconstant.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISFUNCTION
#include &lt;bslmf_isfunction.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISPOINTER
#include &lt;bslmf_ispointer.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYCOPYABLE
#include &lt;bslmf_istriviallycopyable.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_COMPILERFEATURES
#include &lt;bsls_compilerfeatures.h&gt;
#endif

#ifndef INCLUDED_BSLS_NATIVESTD
#include &lt;bsls_nativestd.h&gt;
#endif

#ifndef INCLUDED_BSLS_NULLPTR
#include &lt;bsls_nullptr.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSLS_UNSPECIFIEDBOOL
#include &lt;bsls_unspecifiedbool.h&gt;
#endif

#ifndef INCLUDED_BSLS_UTIL
#include &lt;bsls_util.h&gt;
#endif

#ifndef INCLUDED_FUNCTIONAL
#include &lt;functional&gt;            // to specialize &#39;std::less&#39;
#define INCLUDED_FUNCTIONAL
#endif

#ifndef INCLUDED_MEMORY
#include &lt;memory&gt;                // &#39;std::auto_ptr&#39;
#define INCLUDED_MEMORY
#endif

#ifndef INCLUDED_OSTREAM
#include &lt;ostream&gt;               // &#39;std::basic_ostream&#39;
#define INCLUDED_OSTREAM
#endif

#ifndef INCLUDED_STDDEF_H
#include &lt;stddef.h&gt;               // &#39;size_t&#39;, &#39;ptrdiff_t&#39;
#define INCLUDED_STDDEF_H
#endif

namespace bsl {

template &lt;class ELEMENT_TYPE&gt;
class shared_ptr;

template &lt;class ELEMENT_TYPE&gt;
class weak_ptr;

                        // ================
                        // class shared_ptr
                        // ================

template &lt;class ELEMENT_TYPE&gt;
class shared_ptr {
    // This class provides a thread-safe reference-counted &quot;smart pointer&quot; to
    // support &quot;shared ownership&quot; of objects: a shared pointer ensures that the
    // shared object is destroyed, using the appropriate deletion method, only
    // when there are no shared references to it.  The object (of template
    // parameter type &#39;ELEMENT_TYPE&#39;) referred to by a shared pointer may be
    // accessed directly using the &#39;-&gt;&#39; operator, or the dereference operator
    // (operator &#39;*&#39;) can be used to obtain a reference to that object.
    //
    // Note that the object referred to by a shared pointer representation is
    // usually the same as the object referred to by that shared pointer (of
    // the same &#39;ELEMENT_TYPE&#39;), but this need not always be true in the
    // presence of conversions or &quot;aliasing&quot;: the object referred to (of
    // template parameter type &#39;ELEMENT_TYPE&#39;) by the shared pointer may differ
    // from the object of type &#39;COMPATIBLE_TYPE&#39; (see the &quot;Aliasing&quot; section in
    // the component-level documentation) referred to by the shared pointer
    // representation.
    //
    // More generally, this class supports a complete set of *in*-*core*
    // pointer semantic operations.

    // DATA
    ELEMENT_TYPE                     *d_ptr_p; // pointer to the shared object

    BloombergLP::bslma::SharedPtrRep *d_rep_p; // pointer to the representation
                                               // object that manages the
                                               // shared object

    // PRIVATE TYPES
    typedef shared_ptr&lt;ELEMENT_TYPE&gt; SelfType;
        // &#39;SelfType&#39; is an alias to this &#39;class&#39;, for compilers that do not
        // recognize plain &#39;shared_ptr&#39;.

    typedef typename BloombergLP::bsls::UnspecifiedBool&lt;shared_ptr&gt;::BoolType
                                                                      BoolType;

    // FRIENDS
    template &lt;class COMPATIBLE_TYPE&gt;
    friend class shared_ptr;

  private:
    // PRIVATE CLASS METHODS
    template &lt;class INPLACE_REP&gt;
    static BloombergLP::bslma::SharedPtrRep *makeInternalRep(
                                        ELEMENT_TYPE                     *,
                                        INPLACE_REP                      *,
                                        BloombergLP::bslma::SharedPtrRep *rep);
        // Return the specified &#39;rep&#39;.

    template &lt;class COMPATIBLE_TYPE, class ALLOCATOR&gt;
    static BloombergLP::bslma::SharedPtrRep *makeInternalRep(
                                     COMPATIBLE_TYPE               *ptr,
                                     ALLOCATOR                     *,
                                     BloombergLP::bslma::Allocator *allocator);
        // Return the address of a new out-of-place representation for a shared
        // pointer that manages the specified &#39;ptr&#39; and uses the specified
        // &#39;allocator&#39; to destroy the object pointed to by &#39;ptr&#39;.  Use
        // &#39;allocator&#39; to supply memory.

    template &lt;class COMPATIBLE_TYPE, class DELETER&gt;
    static BloombergLP::bslma::SharedPtrRep *makeInternalRep(
                                                      COMPATIBLE_TYPE *ptr,
                                                      DELETER         *deleter,
                                                     ...);
        // Return the address of a new out-of-place representation for a shared
        // pointer that manages the specified &#39;ptr&#39; and uses the specified
        // &#39;deleter&#39; to destroy the object pointed to by &#39;ptr&#39;.  Use the
        // currently installed default allocator to supply memory.

  public:
    // TYPES
    typedef ELEMENT_TYPE element_type;
        // &#39;element_type&#39; is an alias to the &#39;ELEMENT_TYPE&#39; template parameter.
        // Note that &#39;element_type&#39; refers to the same type as &#39;ElementType&#39;.

    typedef ELEMENT_TYPE ElementType;
        // &#39;ElementType&#39; is an alias to the &#39;ELEMENT_TYPE&#39; template parameter.

    // CREATORS
    shared_ptr();
        // Create an empty shared pointer, i.e., a shared pointer with no
        // representation that does not refer to any object and has no
        // deleter.

    shared_ptr(bsl::nullptr_t);                                     // IMPLICIT
        // Create an empty shared pointer, i.e., a shared pointer with no
        // representation that does not refer to any object and has no
        // deleter.


    template &lt;class COMPATIBLE_TYPE&gt;
    explicit shared_ptr(COMPATIBLE_TYPE *ptr);
        // Create a shared pointer that manages a modifiable object of
        // (template parameter) type &#39;COMPATIBLE_TYPE&#39; and refers to the
        // specified &#39;(ELEMENT_TYPE *)ptr&#39;.  The currently installed default
        // allocator is used to allocate and deallocate the internal
        // representation of the shared pointer.  When all references have been
        // released, the object pointed to by the managed pointer will be
        // destroyed by a call to &#39;delete ptr&#39;.  If &#39;COMPATIBLE_TYPE *&#39; is not
        // implicitly convertible to &#39;ELEMENT_TYPE *&#39;, then a compiler
        // diagnostic will be emitted indicating the error.  If &#39;ptr&#39; is 0,
        // then this shared pointer will still allocate an internal
        // representation to share ownership of that empty state, which will be
        // reclaimed when the last reference is destroyed.  If an exception is
        // thrown allocating storage for the representation, then &#39;delete ptr&#39;
        // will be called.  Note that if &#39;ptr&#39; is a null-pointer constant, the
        // compiler will actually select the &#39;shared_ptr(bsl::nullptr_t)&#39;
        // constructor, resulting in an empty shared pointer.

    template &lt;class COMPATIBLE_TYPE&gt;
    shared_ptr(COMPATIBLE_TYPE               *ptr,
               BloombergLP::bslma::Allocator *basicAllocator);
        // Create a shared pointer that manages a modifiable object of
        // (template parameter) type &#39;COMPATIBLE_TYPE&#39; and refers to the
        // specified &#39;ptr&#39; cast to a pointer to the (template parameter) type
        // &#39;ELEMENT_TYPE&#39;.  If the specified &#39;basicAllocator&#39; is not 0 then
        // &#39;basicAllocator&#39; is used to allocate and deallocate the internal
        // representation of the shared pointer and to destroy the shared
        // object when all references have been released; otherwise, the
        // currently installed default allocator is used.  If
        // &#39;COMPATIBLE_TYPE *&#39; is not implicitly convertible to
        // &#39;ELEMENT_TYPE *&#39;, then a compiler diagnostic will be emitted
        // indicating the error.  If &#39;ptr&#39; is 0, then this shared pointer will
        // still allocate an internal representation to share ownership of that
        // empty state, which will be reclaimed when the last reference is
        // destroyed.  Note that if &#39;ptr&#39; is a null-pointer constant, the
        // compiler will actually select the
        // &#39;shared_ptr(bsl::nullptr_t, BloombergLP::bslma::Allocator *)&#39;
        // constructor, resulting in an empty shared pointer.  Note that if
        // &#39;basicAllocator&#39; is a pointer to a class derived from
        // &#39;bslma::Allocator&#39;, the compiler will actually select the following
        // (more general) constructor that has the same behavior:
        //..
        //  template &lt;class COMPATIBLE_TYPE, class DELETER&gt;
        //  shared_ptr(COMPATIBLE_TYPE *ptr, DELETER * deleter);
        //..

    shared_ptr(ELEMENT_TYPE *ptr, BloombergLP::bslma::SharedPtrRep *rep);
        // Create a shared pointer that takes ownership of the specified &#39;rep&#39;
        // and refers to the modifiable object at the specified &#39;ptr&#39; address.
        // The number of references to &#39;rep&#39; is *NOT* incremented.  Note that
        // if &#39;rep&#39; is a pointer to a class derived from
        // &#39;BloombergLP::bslma::SharedPtrRep&#39;, the compiler will actually
        // select the following (more general) constructor that has the same
        // behavior:
        //..
        //  template &lt;class COMPATIBLE_TYPE, class DELETER&gt;
        //  shared_ptr(COMPATIBLE_TYPE *ptr, DELETER * deleter);
        //..

    template &lt;class COMPATIBLE_TYPE, class DELETER&gt;
    shared_ptr(COMPATIBLE_TYPE *ptr, DELETER *deleter);
        // Create a shared pointer that manages a modifiable object of
        // (template parameter) type &#39;COMPATIBLE_TYPE&#39;, refers to the specified
        // &#39;ptr&#39; cast to a pointer to the (template parameter) type
        // &#39;ELEMENT_TYPE&#39;, and uses the specified &#39;deleter&#39; to delete the
        // shared object when all references have been released.  Use the
        // currently installed default allocator to allocate and deallocate the
        // internal representation of the shared pointer, unless &#39;DELETER&#39; is a
        // class derived from either &#39;bslma::Allocator&#39; or
        // &#39;bslma::SharedPtrRep&#39;; if &#39;DELETER&#39; is a class derived from
        // &#39;bslma::allocator&#39;, create a shared pointer as if calling the
        // constructor:
        //..
        //  template &lt;class COMPATIBLE_TYPE&gt;
        //  shared_ptr(COMPATIBLE_TYPE               *ptr,
        //             BloombergLP::bslma::Allocator *basicAllocator);
        //..
        // If &#39;DELETER&#39; is a class derived from &#39;bslma::SharedPtrRep&#39;, create a
        // shared pointer as if calling the constructor:
        //..
        //  shared_ptr(ELEMENT_TYPE                     *ptr,
        //             BloombergLP::bslma::SharedPtrRep *rep);
        //..
        // If &#39;DELETER&#39; does not derive from either &#39;bslma::Allocator&#39; or
        // &#39;BloombergLP::bslma::SharedPtrRep&#39;, then &#39;deleter&#39; shall be a
        // pointer to a factory object that exposes a member function that can
        // be invoked as &#39;deleteObject(ptr)&#39; that will be called to destroy the
        // object at the &#39;ptr&#39; address (i.e., &#39;deleter-&gt;deleteObject(ptr)&#39; will
        // be called to delete the shared object).  (See the &quot;Deleters&quot; section
        // in the component-level documentation.)  If &#39;COMPATIBLE_TYPE *&#39; is
        // not implicitly convertible to &#39;ELEMENT_TYPE *&#39;, then a compiler
        // diagnostic will be emitted indicating the error.  If &#39;ptr&#39; is 0,
        // then the null pointer will be reference counted, and the deleter
        // will be called when the last reference is destroyed.  If an
        // exception is thrown when allocating storage for the internal
        // representation, then &#39;deleter(ptr)&#39; will be called.  Note that this
        // method is a BDE extension and not part of the C++ standard
        // interface.

    template &lt;class COMPATIBLE_TYPE, class DELETER&gt;
    shared_ptr(COMPATIBLE_TYPE               *ptr,
               DELETER                        deleter,
               BloombergLP::bslma::Allocator *basicAllocator = 0);
        // Create a shared pointer that manages a modifiable object of
        // (template parameter) type &#39;COMPATIBLE_TYPE&#39;, refers to the specified
        // &#39;(ELEMENT_TYPE *)ptr&#39;, and uses the specified &#39;deleter&#39; to delete
        // the shared object when all references have been released.
        // Optionally specify a &#39;basicAllocator&#39; to allocate and deallocate the
        // internal representation of the shared pointer (including a copy of
        // &#39;deleter&#39;).  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.  &#39;DELETER&#39; shall be either a function
        // pointer or a function-like deleter that may be invoked to destroy
        // the object referred to by a single argument of type
        // &#39;COMPATIBLE_TYPE *&#39; (i.e., &#39;deleter(ptr)&#39; will be called to destroy
        // the shared object).  (See the &quot;Deleters&quot; section in the component-
        // level documentation.)  If &#39;COMPATIBLE_TYPE *&#39; is not implicitly
        // convertible to &#39;ELEMENT_TYPE *&#39;, then a compiler diagnostic will be
        // emitted indicating the error.  If &#39;ptr&#39; is 0, then the null pointer
        // will be reference counted, and &#39;deleter(ptr)&#39; will be called when
        // the last reference is destroyed.  If an exception is thrown when
        // allocating storage for the internal representation then
        // &#39;deleter(ptr)&#39; will be called.  The behavior is undefined unless the
        // constructor making a copy of &#39;deleter&#39; does not throw an exception.

    template &lt;class COMPATIBLE_TYPE, class DELETER, class ALLOCATOR&gt;
    shared_ptr(COMPATIBLE_TYPE                *ptr,
               DELETER                         deleter,
               ALLOCATOR                       basicAllocator,
               typename ALLOCATOR::value_type * = 0);
        // Create a shared pointer that manages a modifiable object of
        // (template parameter) type &#39;COMPATIBLE_TYPE&#39;, refers to the specified
        // &#39;ptr&#39; cast to a pointer to the (template parameter) type
        // &#39;ELEMENT_TYPE&#39;, and uses the specified &#39;deleter&#39; to delete the
        // shared object when all references have been released.  Use the
        // specified &#39;basicAllocator&#39; to allocate and deallocate the internal
        // representation of the shared pointer (including a copy of the
        // &#39;deleter&#39;).  The (template parameter) type &#39;DELETER&#39; shall be either
        // a function pointer or a function-like deleter that may be invoked to
        // destroy the object referred to by a single argument of type
        // &#39;COMPATIBLE_TYPE *&#39; (i.e., &#39;deleter(ptr)&#39; will be called to destroy
        // the shared object).  (See the &quot;Deleters&quot; section in the component-
        // level documentation.)  The (template parameter) type &#39;ALLOCATOR&#39;
        // shall satisfy the Allocator requirements of the C++ standard (C++11
        // 17.6.3.5, [allocator.requirements]).  If &#39;COMPATIBLE_TYPE *&#39; is not
        // implicitly convertible to &#39;ELEMENT_TYPE *&#39;, then a compiler
        // diagnostic will be emitted indicating the error.  If &#39;ptr&#39; is 0,
        // then the null pointer will be reference counted, and &#39;deleter(ptr)&#39;
        // will be called when the last reference is destroyed.  If an
        // exception is thrown when allocating storage for the internal
        // representation, then &#39;deleter(ptr)&#39; will be called.  The behavior is
        // undefined unless the constructor making a copy of &#39;deleter&#39; does not
        // throw an exception.  Note that the final dummy parameter is a simple
        // SFINAE check that the (template parameter) &#39;ALLOCATOR&#39; type probably
        // satisfies the standard allocator requirements; in particular, it
        // will not match pointer types, so any pointers to &#39;bslma::Allocator&#39;
        // derived classes will dispatch to the constructor above this, and not
        // be greedily matched to a generic type parameter.

    shared_ptr(nullptr_t                      nullPointerLiteral,
               BloombergLP::bslma::Allocator *basicAllocator);
        // Create an empty shared pointer.  The specified &#39;nullPointerLiteral&#39;
        // and &#39;basicAllocator&#39; are not used.  Note that use of this
        // constructor is equivalent to calling the default constructor.

    template &lt;class DELETER&gt;
    shared_ptr(nullptr_t                      nullPointerLiteral,
               DELETER                        deleter,
               BloombergLP::bslma::Allocator *basicAllocator = 0);
        // Create a shared pointer that reference-counts the null pointer, and
        // calls the specified &#39;deleter&#39; with a null pointer (i.e., invokes
        // &#39;deleter((ELEMENT_TYPE *)0)&#39;) when the last shared reference is
        // destroyed.  The specified &#39;nullPointerLiteral&#39; is not used.
        // Optionally specify a &#39;basicAllocator&#39; to allocate and deallocate the
        // internal representation of the shared pointer (including a copy of
        // &#39;deleter&#39;).  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.  If an exception is thrown when
        // allocating storage for the internal representation, then
        // &#39;deleter((ELEMENT_TYPE *)0)&#39; will be called.  The behavior is
        // undefined unless &#39;deleter&#39; can be called with a null pointer, and
        // unless the constructor making a copy of &#39;deleter&#39; does not throw an
        // exception.

    template &lt;class DELETER, class ALLOCATOR&gt;
    shared_ptr(nullptr_t                       nullPointerLiteral,
               DELETER                         deleter,
               ALLOCATOR                       basicAllocator,
               typename ALLOCATOR::value_type * = 0);
        // Create a shared pointer that reference-counts the null pointer,
        // calls the specified &#39;deleter&#39; with a null pointer (i.e., invokes
        // &#39;deleter((ELEMENT_TYPE *)0)&#39;) when the last shared reference is
        // destroyed, and uses the specified &#39;basicAllocator&#39; to allocate and
        // deallocate the internal representation of the shared pointer
        // (including a copy of the &#39;deleter&#39;).  The (template parameter) type
        // &#39;DELETER&#39; shall be either a function pointer or a function-like
        // deleter (See the &quot;Deleters&quot; section in the component- level
        // documentation).  The (template parameter) type &#39;ALLOCATOR&#39; shall
        // satisfy the Allocator requirements of the C++ standard (C++11
        // 17.6.3.5, [allocator.requirements]).  The specified
        // &#39;nullPointerLiteral&#39; is not used.  If an exception is thrown when
        // allocating storage for the internal representation then
        // &#39;deleter((ELEMENT_TYPE *)0)&#39; will be called.  The behavior is
        // undefined unless &#39;deleter&#39; can be called with a null pointer, and
        // unless the constructor making a copy of &#39;deleter&#39; does not throw an
        // exception.  Note that the final dummy parameter is a simple SFINAE
        // check that the &#39;ALLOCATOR&#39; type probably satisfies the standard
        // allocator requirements; in particular, it will not match pointer
        // types, so any pointers to &#39;bslma::Allocator&#39; derived classes will
        // dispatch to the constructor above this, and not be greedily matched
        // to a generic type parameter.

    template &lt;class COMPATIBLE_TYPE&gt;
    shared_ptr(
          BloombergLP::bslma::ManagedPtr&lt;COMPATIBLE_TYPE&gt;  managedPtr,
          BloombergLP::bslma::Allocator                   *basicAllocator = 0);
                                                                    // IMPLICIT
        // Create a shared pointer that takes over the management of the
        // modifiable object (if any) previously managed by the specified
        // &#39;managedPtr&#39; to the (template parameter) type &#39;COMPATIBLE_TYPE&#39;, and
        // that refers to &#39;(ELEMENT_TYPE *)managedPtr.ptr()&#39;.  The deleter used
        // in the &#39;managedPtr&#39; will be used to destroy the shared object when
        // all references have been released.  Optionally specify a
        // &#39;basicAllocator&#39; used to allocate and deallocate the internal
        // representation of the shared pointer.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.  If
        // &#39;COMPATIBLE_TYPE *&#39; is not implicitly convertible to
        // &#39;ELEMENT_TYPE *&#39;, then a compiler diagnostic will be emitted
        // indicating the error.  Note that if &#39;managedPtr&#39; is empty, then an
        // empty shared pointer is created and &#39;basicAllocator&#39; is ignored.

    template &lt;class COMPATIBLE_TYPE&gt;
    explicit shared_ptr(
                   native_std::auto_ptr&lt;COMPATIBLE_TYPE&gt;&amp;  autoPtr,
                   BloombergLP::bslma::Allocator          *basicAllocator = 0);
        // Create a shared pointer that takes over the management of the
        // modifiable object previously managed by the specified &#39;autoPtr&#39; to
        // the (template parameter) type &#39;COMPATIBLE_TYPE&#39;, and that refers to
        // &#39;(ELEMENT_TYPE *)autoPtr.get()&#39;.  &#39;delete(autoPtr.release())&#39; will
        // be called to destroy the shared object when all references have been
        // released.  Optionally specify a &#39;basicAllocator&#39; used to allocate
        // and deallocate the internal representation of the shared pointer.
        // If &#39;basicAllocator&#39; is 0, the currently installed default allocator
        // is used.  If &#39;COMPATIBLE_TYPE *&#39; is not implicitly convertible to
        // &#39;ELEMENT_TYPE *&#39;, then a compiler diagnostic will be emitted
        // indicating the error.

    explicit shared_ptr(
                   native_std::auto_ptr_ref&lt;ELEMENT_TYPE&gt;  autoRef,
                   BloombergLP::bslma::Allocator          *basicAllocator = 0);
        // Create a shared pointer that takes over the management of the
        // modifiable object of (template parameter) type &#39;COMPATIBLE_TYPE&#39;
        // previously managed by the auto pointer object that the specified
        // &#39;autoRef&#39; refers to; this shared pointer refers to the same object
        // that it manages, and &#39;delete(get())&#39; will be called to destroy the
        // shared object when all references have been released.  Optionally
        // specify a &#39;basicAllocator&#39; used to allocate and deallocate the
        // internal representation of the shared pointer.  If &#39;basicAllocator&#39;
        // is 0, the currently installed default allocator is used.  If
        // &#39;COMPATIBLE_TYPE *&#39; is not implicitly convertible to
        // &#39;ELEMENT_TYPE *&#39;, then a compiler diagnostic will be emitted
        // indicating the error.

    template &lt;class ANY_TYPE&gt;
    shared_ptr(const shared_ptr&lt;ANY_TYPE&gt;&amp;  source,
               ELEMENT_TYPE                *object);
        // Create a shared pointer that manages the same modifiable object (if
        // any) as the specified &#39;source&#39; shared pointer to the (template
        // parameter) type &#39;ANY_TYPE&#39;, and that refers to the modifiable object
        // at the specified &#39;object&#39; address.  The resulting shared pointer is
        // known as an &quot;alias&quot; of &#39;source&#39;.  Note that typically the objects
        // referred to by &#39;source&#39; and &#39;object&#39; have identical lifetimes (e.g.,
        // one might be a part of the other), so that the deleter for &#39;source&#39;
        // will destroy them both, but they do not necessarily have the same
        // type.  Also note that if &#39;source&#39; is empty, then an empty shared
        // pointer is created, even if &#39;object&#39; is not null (in which case this
        // empty shared pointer will refer to the same object as &#39;object&#39;).
        // Likewise note that if &#39;object&#39; is null and &#39;source&#39; is not empty,
        // then a reference-counted null pointer alias will be created.

    template &lt;class COMPATIBLE_TYPE&gt;
    shared_ptr(const shared_ptr&lt;COMPATIBLE_TYPE&gt;&amp; other);
        // Create a shared pointer that manages the same modifiable object (if
        // any) as the specified &#39;other&#39; shared pointer to the (template
        // parameter) type &#39;COMPATIBLE_TYPE&#39;, uses the same deleter as &#39;other&#39;
        // to destroy the shared object, and refers to
        // &#39;(ELEMENT_TYPE*)other.get()&#39;.  If &#39;COMPATIBLE_TYPE *&#39; is not
        // implicitly convertible to &#39;ELEMENT_TYPE *&#39;, then a compiler
        // diagnostic will be emitted indicating the error.  Note that if
        // &#39;other&#39; is empty, then an empty shared pointer is created.

    shared_ptr(const shared_ptr&amp; original);
        // Create a shared pointer that refers to and manages the same object
        // (if any) as the specified &#39;original&#39; shared pointer, and used the
        // same deleter as &#39;original&#39; to destroy the shared object.  Note that
        // if &#39;original&#39; is empty, then an empty shared pointer is created.

    template&lt;class COMPATIBLE_TYPE&gt;
    explicit shared_ptr(const weak_ptr&lt;COMPATIBLE_TYPE&gt;&amp; ptr);
        // Create a shared pointer that refers to and manages the same object
        // as the specified &#39;ptr&#39; if &#39;false == ptr.expired()&#39;; otherwise,
        // create a shared pointer in the empty state.  Note that the
        // referenced and managed objects may be different if &#39;ptr&#39; was created
        // from a &#39;shared_ptr&#39; in an aliasing state.

    ~shared_ptr();
        // Destroy this shared pointer.  If this shared pointer refers to a
        // (possibly shared) object, then release the reference to that object,
        // and destroy the shared object using its associated deleter if this
        // shared pointer is the last reference to that object.

    // MANIPULATORS
    shared_ptr&amp; operator=(const shared_ptr&amp; rhs);
        // Make this shared pointer manage the same modifiable object as the
        // specified &#39;rhs&#39; shared pointer to the (template parameter) type
        // &#39;COMPATIBLE_TYPE&#39;, use the same deleter as &#39;rhs&#39;, and refer to
        // &#39;(ELEMENT_TYPE *)rhs.get()&#39;; return a reference providing modifiable
        // access to this shared pointer.  Note that if &#39;rhs&#39; is empty, then
        // this shared pointer will also be empty after the assignment.  Also
        // note that if &#39;*this&#39; is the same object as &#39;rhs&#39;, then this method
        // has no effect.

    template &lt;class COMPATIBLE_TYPE&gt;
    shared_ptr&amp; operator=(const shared_ptr&lt;COMPATIBLE_TYPE&gt;&amp; rhs);
        // Make this shared pointer refer to and manage the same modifiable
        // object as the specified &#39;rhs&#39; shared pointer to the (template
        // parameter) type &#39;COMPATIBLE_TYPE&#39;, using the same deleter as &#39;rhs&#39;
        // and referring to &#39;(ELEMENT_TYPE *)rhs.get()&#39;, and return a reference
        // to this modifiable shared pointer.  If this shared pointer is
        // already managing a (possibly shared) object, then release the shared
        // reference to that object, and destroy it using its associated
        // deleter if this shared pointer held the last shared reference to
        // that object.  Note that if &#39;rhs&#39; is empty, then this shared pointer
        // will also be empty after the assignment.

    template &lt;class COMPATIBLE_TYPE&gt;
    shared_ptr&amp; operator=(native_std::auto_ptr&lt;COMPATIBLE_TYPE&gt; rhs);
        // Transfer, to this shared pointer, ownership of the modifiable object
        // managed by the specified &#39;rhs&#39; auto pointer to the (template
        // parameter) type &#39;COMPATIBLE_TYPE&#39;, and make this shared pointer
        // refer to &#39;(ELEMENT_TYPE *)rhs.get()&#39;.  &#39;delete(autoPtr.release())&#39;
        // will be called to destroy the shared object when all references have
        // been released.  If this shared pointer is already managing a
        // (possibly shared) object, then release the reference to that shared
        // object, and destroy it using its associated deleter if this shared
        // pointer held the last shared reference to that object.  Note that if
        // &#39;rhs&#39; is empty, then this shared pointer will be empty after the
        // assignment.

    void reset();
        // Reset this shared pointer to the empty state.  If this shared
        // pointer is managing a (possibly shared) object, then release the
        // reference to the shared object, calling the associated deleter to
        // destroy the shared object if this shared pointer is the last shared
        // reference.

    template &lt;class COMPATIBLE_TYPE&gt;
    void reset(COMPATIBLE_TYPE *ptr);
        // Modify this shared pointer to manage the modifiable object of the
        // (template parameter) type &#39;COMPATIBLE_TYPE&#39; at the specified &#39;ptr&#39;
        // address and to refer to &#39;(ELEMENT_TYPE *)ptr&#39;.  If this shared
        // pointer is already managing a (possibly shared) object, then, unless
        // an exception is thrown allocating memory to manage &#39;ptr&#39;, release
        // the reference to the shared object, calling the associated deleter
        // to destroy the shared object if this shared pointer is the last
        // reference.  The currently installed default allocator is used to
        // allocate the internal representation of this shared pointer, and the
        // shared object will be destroyed by a call to &#39;delete ptr&#39; when all
        // references have been released.  If an exception is thrown allocating
        // the internal representation, then &#39;delete ptr&#39; is called and this
        // shared pointer retains ownership of its original object.  If
        // &#39;COMPATIBLE_TYPE*&#39; is not implicitly convertible to &#39;ELEMENT_TYPE*&#39;,
        // then a compiler diagnostic will be emitted indicating the error.
        // Note that if &#39;ptr&#39; is 0, then this shared pointer will still
        // allocate an internal representation to share ownership of that empty
        // state, which will be reclaimed when the last reference is destroyed.

    template &lt;class COMPATIBLE_TYPE, class DELETER&gt;
    void reset(COMPATIBLE_TYPE *ptr, DELETER deleter);
        // Modify this shared pointer to manage the modifiable object of the
        // (template parameter) type &#39;COMPATIBLE_TYPE&#39; at the specified &#39;ptr&#39;
        // address, refer to &#39;(ELEMENT_TYPE *)ptr&#39;, and use the specified
        // &#39;deleter&#39; to delete the shared object when all references have been
        // released.  If this shared pointer is already managing a (possibly
        // shared) object, then unless an exception is thrown allocating memory
        // to manage &#39;ptr&#39;, release the reference to the shared object, calling
        // the associated deleter to destroy the shared object if this shared
        // pointer is the last reference.  If &#39;DELETER&#39; is an object type, then
        // &#39;deleter&#39; is assumed to be a function-like deleter that may be
        // invoked to destroy the object referred to by a single argument of
        // type &#39;COMPATIBLE_TYPE *&#39; (i.e., &#39;deleter(ptr)&#39; will be called to
        // destroy the shared object).  If &#39;DELETER&#39; is a pointer type that is
        // not a function pointer, then &#39;deleter&#39; shall be a pointer to a
        // factory object that exposes a member function that can be invoked as
        // &#39;deleteObject(ptr)&#39; that will be called to destroy the object at the
        // &#39;ptr&#39; address (i.e., &#39;deleter-&gt;deleteObject(ptr)&#39; will be called to
        // delete the shared object).  (See the &quot;Deleters&quot; section in the
        // component-level documentation.)  If &#39;DELETER&#39; is also a pointer to
        // &#39;bslma::Allocator&#39; or to a class derived from &#39;bslma::Allocator&#39;,
        // then that allocator will also be used to allocate and destroy the
        // internal representation of this shared pointer when all references
        // have been released; otherwise, the currently installed default
        // allocator is used to allocate and destroy the internal
        // representation of this shared pointer when all references have been
        // released.  If an exception is thrown allocating the internal
        // representation, then &#39;deleter(ptr)&#39; is called (or
        // &#39;deleter-&gt;deleteObject(ptr)&#39; for factory-type deleters) and this
        // shared pointer retains ownership of its original object.  If
        // &#39;COMPATIBLE_TYPE*&#39; is not implicitly convertible to &#39;ELEMENT_TYPE*&#39;,
        // then a compiler diagnostic will be emitted indicating the error.
        // Note that, for factory deleters, &#39;deleter&#39; must remain valid until
        // all references to &#39;ptr&#39; have been released.  If &#39;ptr&#39; is 0, then an
        // internal representation will still be allocated, and this shared
        // pointer will share ownership of a copy of &#39;deleter&#39;.  Further note
        // that this function is logically equivalent to:
        //..
        //  *this = shared_ptr&lt;ELEMENT_TYPE&gt;(ptr, deleter);
        //..


    template &lt;class COMPATIBLE_TYPE, class DELETER, class ALLOCATOR&gt;
    void reset(COMPATIBLE_TYPE *ptr,
               DELETER          deleter,
               ALLOCATOR        basicAllocator);
        // Modify this shared pointer to manage the modifiable object of the
        // (template parameter) type &#39;COMPATIBLE_TYPE&#39; at the specified &#39;ptr&#39;
        // address, refer to &#39;(ELEMENT_TYPE *)ptr&#39; and use the specified
        // &#39;deleter&#39; to delete the shared object when all references have been
        // released.  Use the specified &#39;basicAllocator&#39; to allocate and
        // deallocate the internal representation of the shared pointer.  If
        // this shared pointer is already managing a (possibly shared) object,
        // then, unless an exception is thrown allocating memory to manage
        // &#39;ptr&#39;, release the shared reference to that shared object, and
        // destroy it using its associated deleter if this shared pointer held
        // the last shared reference to that object.  If &#39;DELETER&#39; is a
        // reference type, then &#39;deleter&#39; is assumed to be a function-like
        // deleter that may be invoked to destroy the object referred to by a
        // single argument of type &#39;COMPATIBLE_TYPE *&#39; (i.e., &#39;deleter(ptr)&#39;
        // will be called to destroy the shared object).  If &#39;DELETER&#39; is a
        // pointer type, then &#39;deleter&#39; is assumed to be a pointer to a factory
        // object that exposes a member function that can be invoked as
        // &#39;deleteObject(ptr)&#39; that will be called to destroy the object at the
        // &#39;ptr&#39; address (i.e., &#39;deleter-&gt;deleteObject(ptr)&#39; will be called to
        // delete the shared object).  (See the &quot;Deleters&quot; section in the
        // component-level documentation.)  If an exception is thrown
        // allocating the internal representation, then &#39;deleter(ptr)&#39; is
        // called (or &#39;deleter-&gt;deleteObject(ptr)&#39; for factory-type deleters)
        // and this shared pointer retains ownership of its original object.
        // The behavior is undefined unless &#39;deleter(ptr)&#39; is a well-defined
        // expression (or &#39;deleter-&gt;deleteObject(ptr)&#39; for factory-type
        // deleters), and unless the copy constructor for &#39;deleter&#39; does not
        // throw an exception.  If &#39;COMPATIBLE_TYPE *&#39; is not implicitly
        // convertible to &#39;ELEMENT_TYPE *&#39;, then a compiler diagnostic will be
        // emitted indicating the error.  Note that, for factory deleters, the
        // &#39;deleter&#39; must remain valid until all references to &#39;ptr&#39; have been
        // released.  Also note that if &#39;ptr&#39; is 0, then an internal
        // representation will still be allocated, and this shared pointer will
        // share ownership of a copy of &#39;deleter&#39;.  Further note that this
        // function is logically equivalent to:
        //..
        //  *this = shared_ptr&lt;ELEMENT_TYPE&gt;(ptr, deleter, basicAllocator);
        //..

    template &lt;class ANY_TYPE&gt;
    void reset(const shared_ptr&lt;ANY_TYPE&gt;&amp; source, ELEMENT_TYPE *ptr);
        // Modify this shared pointer to manage the same modifiable object (if
        // any) as the specified &#39;source&#39; shared pointer to the (template
        // parameter) type &#39;ANY_TYPE&#39;, and refer to the modifiable object at
        // the specified &#39;ptr&#39; address (i.e., make this shared pointer an
        // &quot;alias&quot; of &#39;source&#39;).  If this shared pointer is already managing a
        // (possibly shared) object, then release the reference to the shared
        // object, calling the associated deleter to destroy the shared object
        // if this shared pointer is the last reference.  Note that typically
        // the objects referred to by &#39;source&#39; and &#39;ptr&#39; have identical
        // lifetimes (e.g., one might be a part of the other), so that the
        // deleter for &#39;source&#39; will destroy them both, but do not necessarily
        // have the same type.  Also note that if &#39;source&#39; is empty, then this
        // shared pointer will be reset to an empty state, even if &#39;ptr&#39; is not
        // null (in which case this empty shared pointer will refer to the same
        // object as &#39;ptr&#39;).  Likewise note that if &#39;ptr&#39; is null and &#39;source&#39;
        // is not empty, then this shared pointer will be reset to a
        // (reference-counted) null pointer alias.  Further note that the
        // behavior of this method is the same as &#39;loadAlias(source, ptr)&#39;.

    void swap(shared_ptr&amp; other);
        // Efficiently exchange the states of this shared pointer and the
        // specified &#39;other&#39; shared pointer such that each will refer to the
        // object formerly referred to by the other and each will manage the
        // object formerly managed by the other.

    // ADDITIONAL BSL MANIPULATORS
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator = 0);
        // Create &quot;in-place&quot; in a large enough contiguous memory region both an
        // internal representation for this shared pointer and a
        // default-constructed object of &#39;ELEMENT_TYPE&#39;, and make this shared
        // pointer refer to the newly-created &#39;ELEMENT_TYPE&#39; object.
        // Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.  If an exception is thrown during allocation or construction
        // of the &#39;ELEMENT_TYPE&#39; object, this shared pointer will be unchanged.
        // Otherwise, if this shared pointer is already managing a (possibly
        // shared) object, then release the shared reference to that shared
        // object, and destroy it using its associated deleter if this shared
        // pointer held the last shared reference to that object.  Note that
        // the allocator argument is *not* passed to the constructor for
        // &#39;ELEMENT_TYPE&#39;; to construct an in-place &#39;ELEMENT_TYPE&#39; with an
        // allocator, use one of the other variants of &#39;createInplace&#39; below.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES)
# if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES)
    template &lt;class... ARGS&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       ARGS&amp;&amp;...                      args);
        // Create &quot;in-place&quot; in a large enough contiguous memory region, using
        // the specified &#39;basicAllocator&#39; to supply memory, both an internal
        // representation for this shared pointer and an object of
        // &#39;ELEMENT_TYPE&#39; using the &#39;ELEMENT_TYPE&#39; constructor that takes the
        // specified &#39;args...&#39; arguments, and make this shared pointer refer to
        // the newly-created &#39;ELEMENT_TYPE&#39; object.  If an exception is thrown
        // during the construction of the &#39;ELEMENT_TYPE&#39; object, this shared
        // pointer will be unchanged.  Otherwise, if this shared pointer is
        // already managing a (possibly shared) object, then release the shared
        // reference to that shared object, and destroy it using its associated
        // deleter if this shared pointer held the last shared reference to
        // that object.  Note that the allocator argument is *not* implicitly
        // passed to the constructor for &#39;ELEMENT_TYPE&#39;; to construct an object
        // of &#39;ELEMENT_TYPE&#39; with an allocator, pass the allocator as one of
        // the arguments (typically the last argument).
# else
    template &lt;class... ARGS&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       const ARGS&amp;...                 args);
        // Create &quot;in-place&quot; in a large enough contiguous memory region, using
        // the specified &#39;basicAllocator&#39; to supply memory, both an internal
        // representation for this shared pointer and an object of
        // &#39;ELEMENT_TYPE&#39; using the &#39;ELEMENT_TYPE&#39; constructor that takes the
        // specified &#39;args...&#39; arguments, and make this shared pointer refer to
        // the newly-created &#39;ELEMENT_TYPE&#39; object.  If an exception is thrown
        // during the construction of the &#39;ELEMENT_TYPE&#39; object, this shared
        // pointer will be unchanged.  Otherwise, if this shared pointer is
        // already managing a (possibly shared) object, then release the shared
        // reference to that shared object, and destroy it using its associated
        // deleter if this shared pointer held the last shared reference to
        // that object.  Note that the allocator argument is *not* implicitly
        // passed to the constructor for &#39;ELEMENT_TYPE&#39;; to construct an object
        // of &#39;ELEMENT_TYPE&#39; with an allocator, pass the allocator as one of
        // the arguments (typically the last argument).

# endif  // BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#else
    template &lt;class A1&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       const A1&amp;                      a1);
    template &lt;class A1, class A2&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       const A1&amp;                      a1,
                       const A2&amp;                      a2);
    template &lt;class A1, class A2, class A3&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       const A1&amp;                      a1,
                       const A2&amp;                      a2,
                       const A3&amp;                      a3);
    template &lt;class A1, class A2, class A3, class A4&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       const A1&amp;                      a1,
                       const A2&amp;                      a2,
                       const A3&amp;                      a3,
                       const A4&amp;                      a4);
    template &lt;class A1, class A2, class A3, class A4, class A5&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       const A1&amp;                      a1,
                       const A2&amp;                      a2,
                       const A3&amp;                      a3,
                       const A4&amp;                      a4,
                       const A5&amp;                      a5);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       const A1&amp;                      a1,
                       const A2&amp;                      a2,
                       const A3&amp;                      a3,
                       const A4&amp;                      a4,
                       const A5&amp;                      a5,
                       const A6&amp;                      a6);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       const A1&amp;                      a1,
                       const A2&amp;                      a2,
                       const A3&amp;                      a3,
                       const A4&amp;                      a4,
                       const A5&amp;                      a5,
                       const A6&amp;                      a6,
                       const A7&amp;                      a7);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7, class A8&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       const A1&amp;                      a1,
                       const A2&amp;                      a2,
                       const A3&amp;                      a3,
                       const A4&amp;                      a4,
                       const A5&amp;                      a5,
                       const A6&amp;                      a6,
                       const A7&amp;                      a7,
                       const A8&amp;                      a8);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7, class A8, class A9&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       const A1&amp;                      a1,
                       const A2&amp;                      a2,
                       const A3&amp;                      a3,
                       const A4&amp;                      a4,
                       const A5&amp;                      a5,
                       const A6&amp;                      a6,
                       const A7&amp;                      a7,
                       const A8&amp;                      a8,
                       const A9&amp;                      a9);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7, class A8, class A9, class A10&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       const A1&amp;                      a1,
                       const A2&amp;                      a2,
                       const A3&amp;                      a3,
                       const A4&amp;                      a4,
                       const A5&amp;                      a5,
                       const A6&amp;                      a6,
                       const A7&amp;                      a7,
                       const A8&amp;                      a8,
                       const A9&amp;                      a9,
                       const A10&amp;                     a10);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7, class A8, class A9, class A10, class A11&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       const A1&amp;                      a1,
                       const A2&amp;                      a2,
                       const A3&amp;                      a3,
                       const A4&amp;                      a4,
                       const A5&amp;                      a5,
                       const A6&amp;                      a6,
                       const A7&amp;                      a7,
                       const A8&amp;                      a8,
                       const A9&amp;                      a9,
                       const A10&amp;                     a10,
                       const A11&amp;                     a11);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7, class A8, class A9, class A10, class A11, class A12&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       const A1&amp;                      a1,
                       const A2&amp;                      a2,
                       const A3&amp;                      a3,
                       const A4&amp;                      a4,
                       const A5&amp;                      a5,
                       const A6&amp;                      a6,
                       const A7&amp;                      a7,
                       const A8&amp;                      a8,
                       const A9&amp;                      a9,
                       const A10&amp;                     a10,
                       const A11&amp;                     a11,
                       const A12&amp;                     a12);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7, class A8, class A9, class A10, class A11, class A12,
              class A13&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       const A1&amp;                      a1,
                       const A2&amp;                      a2,
                       const A3&amp;                      a3,
                       const A4&amp;                      a4,
                       const A5&amp;                      a5,
                       const A6&amp;                      a6,
                       const A7&amp;                      a7,
                       const A8&amp;                      a8,
                       const A9&amp;                      a9,
                       const A10&amp;                     a10,
                       const A11&amp;                     a11,
                       const A12&amp;                     a12,
                       const A13&amp;                     a13);
    template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
              class A7, class A8, class A9, class A10, class A11, class A12,
              class A13, class A14&gt;
    void createInplace(BloombergLP::bslma::Allocator *basicAllocator,
                       const A1&amp;                      a1,
                       const A2&amp;                      a2,
                       const A3&amp;                      a3,
                       const A4&amp;                      a4,
                       const A5&amp;                      a5,
                       const A6&amp;                      a6,
                       const A7&amp;                      a7,
                       const A8&amp;                      a8,
                       const A9&amp;                      a9,
                       const A10&amp;                     a10,
                       const A11&amp;                     a11,
                       const A12&amp;                     a12,
                       const A13&amp;                     a13,
                       const A14&amp;                     a14);
        // Create &quot;in-place&quot; in a large enough contiguous memory region, using
        // the specified &#39;basicAllocator&#39; to supply memory, both an internal
        // representation for this shared pointer and an object of
        // &#39;ELEMENT_TYPE&#39; using the &#39;ELEMENT_TYPE&#39; constructor that takes the
        // specified arguments &#39;a1&#39; up to &#39;aN&#39; where &#39;N&#39; (at most 14) is the
        // number of arguments passed to this method, and make this shared
        // pointer refer to the newly-created &#39;ELEMENT_TYPE&#39; object.  If an
        // exception is thrown during the construction of the &#39;ELEMENT_TYPE&#39;
        // object, this shared pointer will be unchanged.  Otherwise, if this
        // shared pointer is already managing a (possibly shared) object, then
        // release the shared reference to that shared object, and destroy it
        // using its associated deleter if this shared pointer held the last
        // shared reference to that object.  Note that the allocator argument
        // is *not* implicitly passed to the constructor for &#39;ELEMENT_TYPE&#39;;
        // to construct an object of &#39;ELEMENT_TYPE&#39; with an allocator, pass the
        // allocator as one of the arguments (typically the last argument).

#endif  // BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES

    template &lt;class ANY_TYPE&gt;
    void loadAlias(const shared_ptr&lt;ANY_TYPE&gt;&amp;  source,
                   ELEMENT_TYPE                *object);
        // [!DEPRECATED!] Use &#39;reset&#39; instead.
        //
        // Modify this shared pointer to manage the same modifiable object (if
        // any) as the specified &#39;source&#39; shared pointer to the (template
        // parameter) type &#39;ANY_TYPE&#39;, and refer to the modifiable object at
        // the specified &#39;object&#39; address (i.e., make this shared pointer an
        // &quot;alias&quot; of &#39;source&#39;).  If this shared pointer is already managing a
        // (possibly shared) object, then release the shared reference to that
        // shared object, and destroy it using its associated deleter if this
        // shared pointer held the last shared reference to that object.  Note
        // that typically the objects referred to by &#39;source&#39; and &#39;object&#39; have
        // identical lifetimes (e.g., one might be a part of the other), so
        // that the deleter for &#39;source&#39; will destroy them both, but they do
        // not necessarily have the same type.  Also note that if &#39;source&#39; is
        // empty, then this shared pointer will be reset to an empty state,
        // even if &#39;object&#39; is not null (in which case this empty shared
        // pointer will refer to the same object as &#39;object&#39;).  Likewise note
        // that if &#39;object&#39; is null and &#39;source&#39; is not empty, then this shared
        // pointer will be reset to a (reference-counted) null pointer alias.
        // Also note that this function is logically equivalent to:
        //..
        //  *this = shared_ptr&lt;ELEMENT_TYPE&gt;(source, object);
        //..
        // Further note that the behavior of this method is the same as
        // &#39;reset(source, object)&#39;.

    pair&lt;ELEMENT_TYPE *, BloombergLP::bslma::SharedPtrRep *&gt; release();
        // Return the pair consisting of the addresses of the modifiable
        // &#39;ELEMENT_TYPE&#39; object referred to, and the representation shared by,
        // this shared pointer, and reset this shared pointer to the empty
        // state, referring to no object, with no effect on the representation.
        // The reference counter is not modified nor is the shared object
        // deleted; if the reference count of the representation is greater
        // than one, then it is not safe to release the representation (thereby
        // destroying the shared object), but it is always safe to create
        // another shared pointer with the representation using the constructor
        // with the signature
        // &#39;shared_ptr(ELEMENT_TYPE                     *ptr,
        //             BloombergLP::bslma::SharedPtrRep *rep)&#39;.
        // Note that this function returns a pair of null pointers if this
        // shared pointer is empty.


    // ACCESSORS
    operator BoolType() const;
        // Return a value of an &quot;unspecified bool&quot; type that evaluates to
        // &#39;false&#39; if this shared pointer does not refer to an object, and
        // &#39;true&#39; otherwise.  Note that this conversion operator allows a
        // shared pointer to be used within a conditional context (e.g., within
        // an &#39;if&#39; or &#39;while&#39; statement), but does *not* allow shared pointers
        // to unrelated types to be compared (e.g., via &#39;&lt;&#39; or &#39;&gt;&#39;).

    typename add_lvalue_reference&lt;ELEMENT_TYPE&gt;::type
    operator*() const;
        // Return a reference providing modifiable access to the object
        // referred to by this shared pointer.  The behavior is undefined
        // unless this shared pointer refers to an object, and &#39;ELEMENT_TYPE&#39;
        // is not (potentially &#39;const&#39; or &#39;volatile&#39; qualified) &#39;void&#39;.

    ELEMENT_TYPE *operator-&gt;() const;
        // Return the address providing modifiable access to the object
        // referred to by this shared pointer, or 0 if this shared pointer does
        // not refer to an object.  Note that applying this operator
        // conventionally (e.g., to invoke a method) to an shared pointer that
        // does not refer to an object will result in undefined behavior.

    ELEMENT_TYPE *get() const;
        // Return the address providing modifiable access to the object
        // referred to by this shared pointer, or 0 if this shared pointer does
        // not refer to an object.

    template&lt;class ANY_TYPE&gt;
    bool owner_before(const shared_ptr&lt;ANY_TYPE&gt;&amp; other) const;
    template&lt;class ANY_TYPE&gt;
    bool owner_before(const weak_ptr&lt;ANY_TYPE&gt;&amp; other) const;
        // Return &#39;true&#39; if the address of the
        // &#39;BloombergLP::bslma::SharedPtrRep&#39; object used by this shared
        // pointer is ordered before the address of the
        // &#39;BloombergLP::bslma::SharedPtrRep&#39; object used by the specified
        // &#39;other&#39; shared pointer under the total ordering defined by
        // &#39;std::less&lt;BloombergLP::bslma::SharedPtrRep *&gt;&#39;, and &#39;false&#39;
        // otherwise.

    bool unique() const;
        // Return &#39;true&#39; if this shared pointer is not empty and does not share
        // ownership of the object it managed with any other shared pointer,
        // and &#39;false&#39; otherwise.  Note that a shared pointer with a custom
        // deleter can refer to a null pointer without being empty, and so may
        // be &#39;unique&#39;.

    long use_count() const;
        // Return a &quot;snapshot&quot; of the number of shared pointers (including this
        // one) that share ownership of the object managed by this shared
        // pointer.  Note that 0 is returned if this shared pointer is empty.

    // ADDITIONAL BSL ACCESSORS
    typename add_lvalue_reference&lt;ELEMENT_TYPE&gt;::type
    operator[](ptrdiff_t index) const;
        // Return a reference providing modifiable access to the object at the
        // specified &#39;index&#39; offset in the object referred to by this shared
        // pointer.  The behavior is undefined unless this shared pointer is
        // not empty, &#39;ELEMENT_TYPE&#39; is not &#39;void&#39; (a compiler error will be
        // generated if this operator is instantiated within the
        // &#39;shared_ptr&lt;void&gt;&#39; class), and this shared pointer refers to an
        // array of &#39;ELEMENT_TYPE&#39; objects.  Note that this method is logically
        // equivalent to &#39;*(get() + index)&#39;.

    BloombergLP::bslma::ManagedPtr&lt;ELEMENT_TYPE&gt; managedPtr() const;
        // Return a managed pointer that refers to the same object as this
        // shared pointer and that has a deleter that decrements the reference
        // count for the shared object.

    BloombergLP::bslma::SharedPtrRep *rep() const;
        // Return the address providing modifiable access to the
        // &#39;BloombergLP::bslma::SharedPtrRep&#39; object used by this shared
        // pointer, or 0 if this shared pointer is empty.

};

// FREE OPERATORS
template &lt;class LHS_TYPE, class RHS_TYPE&gt;
bool operator==(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs,
                const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; shared pointer refers to the same
    // object (if any) as that referred to by the specified &#39;rhs&#39; shared
    // pointer (if any), and &#39;false&#39; otherwise; a compiler diagnostic will be
    // emitted indicating the error unless a (raw) pointer to &#39;LHS_TYPE&#39; can
    // be compared to a (raw) pointer to &#39;RHS_TYPE&#39;.  Note that two shared
    // pointers that compare equal do not necessarily manage the same object
    // due to aliasing.

template &lt;class LHS_TYPE, class RHS_TYPE&gt;
bool operator!=(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs,
                const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; shared pointer does not refer to
    // the same object (if any) as that referred to by the specified &#39;rhs&#39;
    // shared pointer (if any), and &#39;false&#39; otherwise; a compiler diagnostic
    // will be emitted indicating the error unless a (raw) pointer to
    // &#39;LHS_TYPE&#39; can be compared to a (raw) pointer to &#39;RHS_TYPE&#39;.  Note that
    // two shared pointers that do not compare equal may manage the same object
    // due to aliasing.

template&lt;class LHS_TYPE, class RHS_TYPE&gt;
bool operator&lt;(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs,
               const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the address of the object that the specified &#39;lhs&#39;
    // shared pointer refers to is ordered before the address of the object
    // that the specified &#39;rhs&#39; shared pointer refers to under the total
    // ordering supplied by &#39;std::less&lt;T *&gt;&#39;, where &#39;T *&#39; is the composite
    // pointer type of &#39;LHS_TYPE *&#39; and &#39;RHS_TYPE *&#39;, and &#39;false&#39; otherwise.

template&lt;class LHS_TYPE, class RHS_TYPE&gt;
bool operator&gt;(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs,
               const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the address of the object that the specified &#39;lhs&#39;
    // shared pointer refers to is ordered after the address of the object
    // that the specified &#39;rhs&#39; shared pointer refers to under the total
    // ordering supplied by &#39;std::less&lt;T *&gt;&#39;, where &#39;T *&#39; is the composite
    // pointer type of &#39;LHS_TYPE *&#39; and &#39;RHS_TYPE *&#39;, and &#39;false&#39; otherwise.

template&lt;class LHS_TYPE, class RHS_TYPE&gt;
bool operator&lt;=(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs,
                const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; shared pointer refers to the same
    // object as the specified &#39;rhs&#39; shared pointer, or if the address of the
    // object referred to by &#39;lhs&#39; (if any) is ordered before the address of
    // the object referred to by &#39;rhs&#39; (if any) under the total ordering
    // supplied by &#39;std::less&lt;T *&gt;&#39;, where &#39;T *&#39; is the composite pointer type
    // of &#39;LHS_TYPE *&#39; and &#39;RHS_TYPE *&#39;, and &#39;false&#39; otherwise.

template&lt;class LHS_TYPE, class RHS_TYPE&gt;
bool operator&gt;=(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs,
                const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; shared pointer refers to the same
    // object as the specified &#39;rhs&#39; shared pointer, or if the address of the
    // object referred to by &#39;lhs&#39; (if any) is ordered after the address of the
    // object referred to by &#39;rhs&#39; (if any) under the total ordering supplied
    // by &#39;std::less&lt;T *&gt;&#39;, where &#39;T *&#39; is the composite pointer type of
    // &#39;LHS_TYPE *&#39; and &#39;RHS_TYPE *&#39;, and &#39;false&#39; otherwise.

template &lt;class LHS_TYPE&gt;
bool operator==(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs, nullptr_t);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; shared pointer does not refer to an
    // object, and &#39;false&#39; otherwise.

template &lt;class RHS_TYPE&gt;
bool operator==(nullptr_t, const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;rhs&#39; shared pointer does not refer to an
    // object, and &#39;false&#39; otherwise.

template &lt;class LHS_TYPE&gt;
bool operator!=(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs, nullptr_t);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; shared pointer refers to an object,
    // and &#39;false&#39; otherwise.

template &lt;class RHS_TYPE&gt;
bool operator!=(nullptr_t, const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;rhs&#39; shared pointer refers to an object,
    // and &#39;false&#39; otherwise.

template &lt;class LHS_TYPE&gt;
bool operator&lt;(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs, nullptr_t);
    // Return &#39;true&#39; if the address of the object referred to by the specified
    // &#39;lhs&#39; shared pointer is ordered before the null-pointer value under the
    // total ordering supplied by &#39;std::less&lt;LHS_TYPE *&gt;&#39;, and &#39;false&#39;
    // otherwise.

template &lt;class RHS_TYPE&gt;
bool operator&lt;(nullptr_t, const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the address of the object referred to by the specified
    // &#39;rhs&#39; shared pointer is ordered after the null-pointer value under the
    // total ordering supplied by &#39;std::less&lt;RHS_TYPE *&gt;&#39;, and &#39;false&#39;
    // otherwise.

template &lt;class LHS_TYPE&gt;
bool operator&lt;=(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs, nullptr_t);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; shared pointer does not refer to an
    // object, or if the address of the object referred to by &#39;lhs&#39; is ordered
    // before the null-pointer value under the total ordering supplied by
    // &#39;std::less&lt;LHS_TYPE *&gt;&#39;, and &#39;false&#39; otherwise.

template &lt;class RHS_TYPE&gt;
bool operator&lt;=(nullptr_t, const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;rhs&#39; shared pointer does not refer to an
    // object, or if the address of the object referred to by &#39;rhs&#39; is ordered
    // after the null-pointer value under the total ordering supplied by
    // &#39;std::less&lt;RHS_TYPE *&gt;&#39;, and &#39;false&#39; otherwise.

template &lt;class LHS_TYPE&gt;
bool operator&gt;(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs, nullptr_t);
    // Return &#39;true&#39; if the address of the object referred to by the specified
    // &#39;lhs&#39; shared pointer is ordered after the null-pointer value under the
    // total ordering supplied by &#39;std::less&lt;LHS_TYPE *&gt;&#39;, and &#39;false&#39;
    // otherwise.

template &lt;class RHS_TYPE&gt;
bool operator&gt;(nullptr_t, const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the address of the object referred to by the specified
    // &#39;rhs&#39; shared pointer is ordered before the null-pointer value under the
    // total ordering supplied by &#39;std::less&lt;RHS_TYPE *&gt;&#39;, and &#39;false&#39;
    // otherwise.

template &lt;class LHS_TYPE&gt;
bool operator&gt;=(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs, nullptr_t);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; shared pointer does not refer to an
    // object, or if the address of the object referred to by &#39;lhs&#39; is ordered
    // after the null-pointer value under the total ordering supplied by
    // &#39;std::less&lt;LHS_TYPE *&gt;&#39;, and &#39;false&#39; otherwise.

template &lt;class RHS_TYPE&gt;
bool operator&gt;=(nullptr_t, const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;rhs&#39; shared pointer does not refer to an
    // object, or if the address of the object referred to by &#39;rhs&#39; is ordered
    // before the null-pointer value under the total ordering supplied by
    // &#39;std::less&lt;RHS_TYPE *&gt;&#39;, and &#39;false&#39; otherwise.

template&lt;class CHAR_TYPE, class CHAR_TRAITS, class ELEMENT_TYPE&gt;
native_std::basic_ostream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;
operator&lt;&lt;(native_std::basic_ostream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp; stream,
           const shared_ptr&lt;ELEMENT_TYPE&gt;&amp;                    rhs);
    // Print to the specified &#39;stream&#39; the address of the shared object
    // referred to by the specified &#39;rhs&#39; shared pointer and return a reference
    // to the modifiable &#39;stream&#39;.

// ASPECTS
template &lt;class HASHALG, class ELEMENT_TYPE&gt;
void hashAppend(HASHALG&amp; hashAlg, const shared_ptr&lt;ELEMENT_TYPE&gt;&amp; input);
    // Pass the address of the object referred to by the specified &#39;input&#39;
    // shared pointer to the specified &#39;hashAlg&#39; hashing algorithm of (template
    // parameter) type &#39;HASHALG&#39;.

template &lt;class ELEMENT_TYPE&gt;
void swap(shared_ptr&lt;ELEMENT_TYPE&gt;&amp; a, shared_ptr&lt;ELEMENT_TYPE&gt;&amp; b);
    // Efficiently exchange the states of the specified &#39;a&#39; and &#39;b&#39; shared
    // pointers such that each will refer to the object formerly referred to by
    // the other, and each will manage the object formerly managed by the
    // other.

// STANDARD FREE FUNCTIONS
template&lt;class DELETER, class ELEMENT_TYPE&gt;
DELETER *get_deleter(const shared_ptr&lt;ELEMENT_TYPE&gt;&amp; p);
    // Return the address of deleter used by the specified &#39;p&#39; shared pointer
    // if the (template parameter) type &#39;DELETER&#39; is the type of the deleter
    // installed in &#39;p&#39;, and a null pointer value otherwise.

// STANDARD CAST FUNCTIONS
template&lt;class TO_TYPE, class FROM_TYPE&gt;
shared_ptr&lt;TO_TYPE&gt; const_pointer_cast(const shared_ptr&lt;FROM_TYPE&gt;&amp; source);
    // Return a &#39;shared_ptr&lt;TO_TYPE&gt;&#39; object sharing ownership of the same
    // object as the specified &#39;source&#39; shared pointer to the (template
    // parameter) &#39;FROM_TYPE&#39;, and referring to
    // &#39;const_cast&lt;TO_TYPE *&gt;(source.get())&#39;.  Note that if &#39;source&#39; cannot be
    // &#39;const&#39;-cast to &#39;TO_TYPE *&#39;, then a compiler diagnostic will be emitted
    // indicating the error.

template&lt;class TO_TYPE, class FROM_TYPE&gt;
shared_ptr&lt;TO_TYPE&gt; dynamic_pointer_cast(const shared_ptr&lt;FROM_TYPE&gt;&amp; source);
    // Return a &#39;shared_ptr&lt;TO_TYPE&gt;&#39; object sharing ownership of the same
    // object as the specified &#39;source&#39; shared pointer to the (template
    // parameter) &#39;FROM_TYPE&#39;, and referring to
    // &#39;dynamic_cast&lt;TO_TYPE*&gt;(source.get())&#39;.  If &#39;source&#39; cannot be
    // dynamically cast to &#39;TO_TYPE *&#39;, then an empty &#39;shared_ptr&lt;TO_TYPE&gt;&#39;
    // object is returned.

template&lt;class TO_TYPE, class FROM_TYPE&gt;
shared_ptr&lt;TO_TYPE&gt; static_pointer_cast(const shared_ptr&lt;FROM_TYPE&gt;&amp; source);
    // Return a &#39;shared_ptr&lt;TO_TYPE&gt;&#39; object sharing ownership of the same
    // object as the specified &#39;source&#39; shared pointer to the (template
    // parameter) &#39;FROM_TYPE&#39;, and referring to
    // &#39;static_cast&lt;TO_TYPE *&gt;(source.get())&#39;.  Note that if &#39;source&#39; cannot be
    // statically cast to &#39;TO_TYPE *&#39;, then a compiler diagnostic will be
    // emitted indicating the error.

// STANDARD FACTORY FUNCTIONS
#if defined(BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES)
# if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES)
template&lt;class ELEMENT_TYPE, class ALLOC, class... ARGS&gt;
#   if defined(BSLS_PLATFORM_CMP_GNU)
    // work-around for gcc variadic template bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#   else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#   endif
allocate_shared(ALLOC a, ARGS&amp;&amp;... args);
    // Return a &#39;shared_ptr&#39; object referring to and managing a new
    // &#39;ELEMENT_TYPE&#39; object.  The specified &#39;basicAllocator&#39; will be used to
    // supply a single contiguous region of memory holding the returned shared
    // pointer&#39;s internal representation and the new &#39;ELEMENT_TYPE&#39; object,
    // which is initialized by calling &#39;allocator_traits&lt;ALLOC&gt;::construct&#39;
    // passing &#39;basicAllocator&#39;, an &#39;ELEMENT_TYPE *&#39; pointer to space for the
    // new shared object, and the specified arguments
    // &#39;std::forward&lt;ARGS&gt;(args)...&#39;.  Note that the allocator argument is
    // *not* implicitly passed to the constructor for &#39;ELEMENT_TYPE&#39;;
    // typically, to construct an object of &#39;ELEMENT_TYPE&#39; with an allocator,
    // pass the allocator as one of the arguments (frequently the last
    // argument), but note that some allocators will perform this customization
    // in their &#39;construct&#39; implementation.

template&lt;class ELEMENT_TYPE, class ALLOC, class... ARGS&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC *a, ARGS&amp;&amp;... args);
    // Return a &#39;shared_ptr&#39; object referring to and managing a new
    // &#39;ELEMENT_TYPE&#39; object.  The specified &#39;basicAllocator&#39; will be used to
    // supply a single contiguous region of memory holding the returned shared
    // pointer&#39;s internal representation and the new &#39;ELEMENT_TYPE&#39; object,
    // which is initialized using the &#39;ELEMENT_TYPE&#39; constructor that takes the
    // specified arguments &#39;std::forward&lt;ARGS&gt;(args)...&#39;.  If &#39;ELEMENT_TYPE&#39;
    // uses &#39;blsma&#39; allocators, then the default allocator is passed as an
    // extra argument in the final position.

template&lt;class ELEMENT_TYPE, class... ARGS&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(ARGS&amp;&amp;... args);
    // Return a &#39;shared_ptr&#39; object referring to and managing a new
    // &#39;ELEMENT_TYPE&#39; object.  The default allocator will be used to supply a
    // single contiguous region of memory holding the returned shared pointer&#39;s
    // internal representation and the new &#39;ELEMENT_TYPE&#39; object, which is
    // initialized using the &#39;ELEMENT_TYPE&#39; constructor that takes the
    // specified arguments &#39;std::forward&lt;ARGS&gt;(args)...&#39;.  If &#39;ELEMENT_TYPE&#39;
    // uses &#39;blsma&#39; allocators, then the default allocator is passed as an
    // extra argument in the final position.
# else

template&lt;class ELEMENT_TYPE, class ALLOC, class... ARGS&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC a, const ARGS&amp;... args);
    // Return a &#39;shared_ptr&#39; object referring to and managing a new
    // &#39;ELEMENT_TYPE&#39; object.  The specified &#39;basicAllocator&#39; will be used to
    // supply a single contiguous region of memory holding the returned shared
    // pointer&#39;s internal representation and the new &#39;ELEMENT_TYPE&#39; object,
    // which is initialized by calling &#39;allocator_traits&lt;ALLOC&gt;::construct&#39;
    // passing &#39;basicAllocator&#39;, an &#39;ELEMENT_TYPE *&#39; pointer to space for the
    // new shared object, and the specified arguments &#39;args...&#39;.  Note that the
    // allocator argument is *not* implicitly passed to the constructor for
    // &#39;ELEMENT_TYPE&#39;; typically, to construct an object of &#39;ELEMENT_TYPE&#39; with
    // an allocator, pass the allocator as one of the arguments (frequently the
    // last argument), but note that some allocators will perform this
    // customization in their &#39;construct&#39; implementation.

template&lt;class ELEMENT_TYPE, class ALLOC, class... ARGS&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC *a, const ARGS&amp;... args);
    // Return a &#39;shared_ptr&#39; object referring to and managing a new
    // &#39;ELEMENT_TYPE&#39; object.  The specified &#39;basicAllocator&#39; will be used to
    // supply a single contiguous region of memory holding the returned shared
    // pointer&#39;s internal representation and the new &#39;ELEMENT_TYPE&#39; object,
    // which is initialized using the &#39;ELEMENT_TYPE&#39; constructor that takes the
    // specified arguments &#39;args...&#39;.  If &#39;ELEMENT_TYPE&#39; uses &#39;blsma&#39;
    // allocators, then the default allocator is passed as an extra argument in
    // the final position.

template&lt;class ELEMENT_TYPE, class... ARGS&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(const ARGS&amp;... args);
    // Return a &#39;shared_ptr&#39; object referring to and managing a new
    // &#39;ELEMENT_TYPE&#39; object.  The default allocator will be used to supply a
    // single contiguous region of memory holding the returned shared pointer&#39;s
    // internal representation and the new &#39;ELEMENT_TYPE&#39; object, which is
    // initialized using the &#39;ELEMENT_TYPE&#39; constructor that takes the
    // specified arguments &#39;args...&#39;.  If &#39;ELEMENT_TYPE&#39; uses &#39;blsma&#39;
    // allocators, then the default allocator is passed as an extra argument in
    // the final position.

# endif  // BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#else
template &lt;class ELEMENT_TYPE, class ALLOC&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
allocate_shared(ALLOC basicAllocator);

template &lt;class ELEMENT_TYPE, class ALLOC, class A1&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
allocate_shared(ALLOC     basicAllocator,
                const A1&amp; a1);

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
allocate_shared(ALLOC     basicAllocator,
                const A1&amp; a1,
                const A2&amp; a2);

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
allocate_shared(ALLOC     basicAllocator,
                const A1&amp; a1,
                const A2&amp; a2,
                const A3&amp; a3);

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
allocate_shared(ALLOC     basicAllocator,
                const A1&amp; a1,
                const A2&amp; a2,
                const A3&amp; a3,
                const A4&amp; a4);

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
allocate_shared(ALLOC     basicAllocator,
                const A1&amp; a1,
                const A2&amp; a2,
                const A3&amp; a3,
                const A4&amp; a4,
                const A5&amp; a5);

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
allocate_shared(ALLOC     basicAllocator,
                const A1&amp; a1,
                const A2&amp; a2,
                const A3&amp; a3,
                const A4&amp; a4,
                const A5&amp; a5,
                const A6&amp; a6);

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
allocate_shared(ALLOC     basicAllocator,
                const A1&amp; a1,
                const A2&amp; a2,
                const A3&amp; a3,
                const A4&amp; a4,
                const A5&amp; a5,
                const A6&amp; a6,
                const A7&amp; a7);

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
allocate_shared(ALLOC     basicAllocator,
                const A1&amp; a1,
                const A2&amp; a2,
                const A3&amp; a3,
                const A4&amp; a4,
                const A5&amp; a5,
                const A6&amp; a6,
                const A7&amp; a7,
                const A8&amp; a8);

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
allocate_shared(ALLOC     basicAllocator,
                const A1&amp; a1,
                const A2&amp; a2,
                const A3&amp; a3,
                const A4&amp; a4,
                const A5&amp; a5,
                const A6&amp; a6,
                const A7&amp; a7,
                const A8&amp; a8,
                const A9&amp; a9);

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
allocate_shared(ALLOC      basicAllocator,
                const A1&amp;  a1,
                const A2&amp;  a2,
                const A3&amp;  a3,
                const A4&amp;  a4,
                const A5&amp;  a5,
                const A6&amp;  a6,
                const A7&amp;  a7,
                const A8&amp;  a8,
                const A9&amp;  a9,
                const A10&amp; a10);

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
allocate_shared(ALLOC      basicAllocator,
                const A1&amp;  a1,
                const A2&amp;  a2,
                const A3&amp;  a3,
                const A4&amp;  a4,
                const A5&amp;  a5,
                const A6&amp;  a6,
                const A7&amp;  a7,
                const A8&amp;  a8,
                const A9&amp;  a9,
                const A10&amp; a10,
                const A11&amp; a11);

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11, class A12&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
allocate_shared(ALLOC      basicAllocator,
                const A1&amp;  a1,
                const A2&amp;  a2,
                const A3&amp;  a3,
                const A4&amp;  a4,
                const A5&amp;  a5,
                const A6&amp;  a6,
                const A7&amp;  a7,
                const A8&amp;  a8,
                const A9&amp;  a9,
                const A10&amp; a10,
                const A11&amp; a11,
                const A12&amp; a12);

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11, class A12, class A13&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
allocate_shared(ALLOC      basicAllocator,
                const A1&amp;  a1,
                const A2&amp;  a2,
                const A3&amp;  a3,
                const A4&amp;  a4,
                const A5&amp;  a5,
                const A6&amp;  a6,
                const A7&amp;  a7,
                const A8&amp;  a8,
                const A9&amp;  a9,
                const A10&amp; a10,
                const A11&amp; a11,
                const A12&amp; a12,
                const A13&amp; a13);

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11, class A12, class A13, class A14&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
allocate_shared(ALLOC      basicAllocator,
                const A1&amp;  a1,
                const A2&amp;  a2,
                const A3&amp;  a3,
                const A4&amp;  a4,
                const A5&amp;  a5,
                const A6&amp;  a6,
                const A7&amp;  a7,
                const A8&amp;  a8,
                const A9&amp;  a9,
                const A10&amp; a10,
                const A11&amp; a11,
                const A12&amp; a12,
                const A13&amp; a13,
                const A14&amp; a14);
    // Return a &#39;shared_ptr&#39; object referring to and managing a new
    // &#39;ELEMENT_TYPE&#39; object.  The specified &#39;basicAllocator&#39; will be used to
    // supply a single contiguous region of memory holding the returned shared
    // pointer&#39;s internal representation and the new &#39;ELEMENT_TYPE&#39; object,
    // which is initialized by calling &#39;allocator_traits&lt;ALLOC&gt;::construct&#39;
    // passing &#39;basicAllocator&#39;, an &#39;ELEMENT_TYPE *&#39; pointer to space for the
    // new shared object, and the specified arguments &#39;a1&#39; up to &#39;aN&#39; where &#39;N&#39;
    // (at most 14) is the number of arguments passed to this method.  Note
    // that the allocator argument is *not* implicitly passed to the
    // constructor for &#39;ELEMENT_TYPE&#39;; typically, to construct an object of
    // &#39;ELEMENT_TYPE&#39; with an allocator, pass the allocator as one of the
    // arguments (frequently the last argument), but note that some allocators
    // will perform this customization in their &#39;construct&#39; implementation.

template &lt;class ELEMENT_TYPE, class ALLOC&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC *basicAllocator);
template &lt;class ELEMENT_TYPE, class ALLOC, class A1&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC     *basicAllocator,
                                         const A1&amp;  a1);
template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC     *basicAllocator,
                                         const A1&amp;  a1,
                                         const A2&amp;  a2);
template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC     *basicAllocator,
                                         const A1&amp;  a1,
                                         const A2&amp;  a2,
                                         const A3&amp;  a3);
template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC     *basicAllocator,
                                         const A1&amp;  a1,
                                         const A2&amp;  a2,
                                         const A3&amp;  a3,
                                         const A4&amp;  a4);
template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC     *basicAllocator,
                                         const A1&amp;  a1,
                                         const A2&amp;  a2,
                                         const A3&amp;  a3,
                                         const A4&amp;  a4,
                                         const A5&amp;  a5);
template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC     *basicAllocator,
                                         const A1&amp;  a1,
                                         const A2&amp;  a2,
                                         const A3&amp;  a3,
                                         const A4&amp;  a4,
                                         const A5&amp;  a5,
                                         const A6&amp;  a6);
template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC     *basicAllocator,
                                         const A1&amp;  a1,
                                         const A2&amp;  a2,
                                         const A3&amp;  a3,
                                         const A4&amp;  a4,
                                         const A5&amp;  a5,
                                         const A6&amp;  a6,
                                         const A7&amp;  a7);
template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC     *basicAllocator,
                                         const A1&amp;  a1,
                                         const A2&amp;  a2,
                                         const A3&amp;  a3,
                                         const A4&amp;  a4,
                                         const A5&amp;  a5,
                                         const A6&amp;  a6,
                                         const A7&amp;  a7,
                                         const A8&amp;  a8);
template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC     *basicAllocator,
                                         const A1&amp;  a1,
                                         const A2&amp;  a2,
                                         const A3&amp;  a3,
                                         const A4&amp;  a4,
                                         const A5&amp;  a5,
                                         const A6&amp;  a6,
                                         const A7&amp;  a7,
                                         const A8&amp;  a8,
                                         const A9&amp;  a9);
template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC     *basicAllocator,
                                         const A1&amp;  a1,
                                         const A2&amp;  a2,
                                         const A3&amp;  a3,
                                         const A4&amp;  a4,
                                         const A5&amp;  a5,
                                         const A6&amp;  a6,
                                         const A7&amp;  a7,
                                         const A8&amp;  a8,
                                         const A9&amp;  a9,
                                         const A10&amp; a10);
template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC     *basicAllocator,
                                         const A1&amp;  a1,
                                         const A2&amp;  a2,
                                         const A3&amp;  a3,
                                         const A4&amp;  a4,
                                         const A5&amp;  a5,
                                         const A6&amp;  a6,
                                         const A7&amp;  a7,
                                         const A8&amp;  a8,
                                         const A9&amp;  a9,
                                         const A10&amp; a10,
                                         const A11&amp; a11);
template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11, class A12&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC     *basicAllocator,
                                         const A1&amp;  a1,
                                         const A2&amp;  a2,
                                         const A3&amp;  a3,
                                         const A4&amp;  a4,
                                         const A5&amp;  a5,
                                         const A6&amp;  a6,
                                         const A7&amp;  a7,
                                         const A8&amp;  a8,
                                         const A9&amp;  a9,
                                         const A10&amp; a10,
                                         const A11&amp; a11,
                                         const A12&amp; a12);
template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11, class A12, class A13&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC     *basicAllocator,
                                         const A1&amp;  a1,
                                         const A2&amp;  a2,
                                         const A3&amp;  a3,
                                         const A4&amp;  a4,
                                         const A5&amp;  a5,
                                         const A6&amp;  a6,
                                         const A7&amp;  a7,
                                         const A8&amp;  a8,
                                         const A9&amp;  a9,
                                         const A10&amp; a10,
                                         const A11&amp; a11,
                                         const A12&amp; a12,
                                         const A13&amp; a13);
template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11, class A12, class A13, class A14&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; allocate_shared(ALLOC     *basicAllocator,
                                         const A1&amp;  a1,
                                         const A2&amp;  a2,
                                         const A3&amp;  a3,
                                         const A4&amp;  a4,
                                         const A5&amp;  a5,
                                         const A6&amp;  a6,
                                         const A7&amp;  a7,
                                         const A8&amp;  a8,
                                         const A9&amp;  a9,
                                         const A10&amp; a10,
                                         const A11&amp; a11,
                                         const A12&amp; a12,
                                         const A13&amp; a13,
                                         const A14&amp; a14);
    // Return a &#39;shared_ptr&#39; object referring to and managing a new
    // &#39;ELEMENT_TYPE&#39; object.  The specified &#39;basicAllocator&#39; will be used to
    // supply a single contiguous region of memory holding the returned shared
    // pointer&#39;s internal representation and the new &#39;ELEMENT_TYPE&#39; object,
    // which is initialized using the &#39;ELEMENT_TYPE&#39; constructor that takes the
    // specified arguments &#39;a1&#39; up to &#39;aN&#39; where &#39;N&#39; (at most 14) is the number
    // of arguments passed to this method.  If &#39;ELEMENT_TYPE&#39; uses &#39;blsma&#39;
    // allocators, then the default allocator is passed as an extra argument in
    // the final position.

template &lt;class ELEMENT_TYPE&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared();
template &lt;class ELEMENT_TYPE, class A1&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(const A1&amp; a1);
template &lt;class ELEMENT_TYPE, class A1, class A2&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(const A1&amp; a1, const A2&amp; a2);
template &lt;class ELEMENT_TYPE, class A1, class A2, class A3&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(const A1&amp; a1, const A2&amp; a2, const A3&amp; a3);
template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(const A1&amp; a1,
                                     const A2&amp; a2,
                                     const A3&amp; a3,
                                     const A4&amp; a4);
template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(const A1&amp; a1,
                                     const A2&amp; a2,
                                     const A3&amp; a3,
                                     const A4&amp; a4,
                                     const A5&amp; a5);
template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(const A1&amp; a1,
                                     const A2&amp; a2,
                                     const A3&amp; a3,
                                     const A4&amp; a4,
                                     const A5&amp; a5,
                                     const A6&amp; a6);
template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(const A1&amp; a1,
                                     const A2&amp; a2,
                                     const A3&amp; a3,
                                     const A4&amp; a4,
                                     const A5&amp; a5,
                                     const A6&amp; a6,
                                     const A7&amp; a7);
template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7, class A8&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(const A1&amp; a1,
                                     const A2&amp; a2,
                                     const A3&amp; a3,
                                     const A4&amp; a4,
                                     const A5&amp; a5,
                                     const A6&amp; a6,
                                     const A7&amp; a7,
                                     const A8&amp; a8);
template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7, class A8, class A9&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(const A1&amp; a1,
                                     const A2&amp; a2,
                                     const A3&amp; a3,
                                     const A4&amp; a4,
                                     const A5&amp; a5,
                                     const A6&amp; a6,
                                     const A7&amp; a7,
                                     const A8&amp; a8,
                                     const A9&amp; a9);
template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7, class A8, class A9, class A10&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(const A1&amp;  a1,
                                     const A2&amp;  a2,
                                     const A3&amp;  a3,
                                     const A4&amp;  a4,
                                     const A5&amp;  a5,
                                     const A6&amp;  a6,
                                     const A7&amp;  a7,
                                     const A8&amp;  a8,
                                     const A9&amp;  a9,
                                     const A10&amp; a10);
template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7, class A8, class A9, class A10, class A11&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(const A1&amp;  a1,
                                     const A2&amp;  a2,
                                     const A3&amp;  a3,
                                     const A4&amp;  a4,
                                     const A5&amp;  a5,
                                     const A6&amp;  a6,
                                     const A7&amp;  a7,
                                     const A8&amp;  a8,
                                     const A9&amp;  a9,
                                     const A10&amp; a10,
                                     const A11&amp; a11);
template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7, class A8, class A9, class A10, class A11,
          class A12&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(const A1&amp;  a1,
                                     const A2&amp;  a2,
                                     const A3&amp;  a3,
                                     const A4&amp;  a4,
                                     const A5&amp;  a5,
                                     const A6&amp;  a6,
                                     const A7&amp;  a7,
                                     const A8&amp;  a8,
                                     const A9&amp;  a9,
                                     const A10&amp; a10,
                                     const A11&amp; a11,
                                     const A12&amp; a12);
template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7, class A8, class A9, class A10, class A11,
          class A12, class A13&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(const A1&amp;  a1,
                                     const A2&amp;  a2,
                                     const A3&amp;  a3,
                                     const A4&amp;  a4,
                                     const A5&amp;  a5,
                                     const A6&amp;  a6,
                                     const A7&amp;  a7,
                                     const A8&amp;  a8,
                                     const A9&amp;  a9,
                                     const A10&amp; a10,
                                     const A11&amp; a11,
                                     const A12&amp; a12,
                                     const A13&amp; a13);
template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7, class A8, class A9, class A10, class A11,
          class A12, class A13, class A14&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; make_shared(const A1&amp;  a1,
                                     const A2&amp;  a2,
                                     const A3&amp;  a3,
                                     const A4&amp;  a4,
                                     const A5&amp;  a5,
                                     const A6&amp;  a6,
                                     const A7&amp;  a7,
                                     const A8&amp;  a8,
                                     const A9&amp;  a9,
                                     const A10&amp; a10,
                                     const A11&amp; a11,
                                     const A12&amp; a12,
                                     const A13&amp; a13,
                                     const A14&amp; a14);
    // Return a &#39;shared_ptr&#39; object referring to and managing a new
    // &#39;ELEMENT_TYPE&#39; object.  The default allocator will be used to supply a
    // single contiguous region of memory holding the returned shared pointer&#39;s
    // internal representation and the new &#39;ELEMENT_TYPE&#39; object, which is
    // initialized using the &#39;ELEMENT_TYPE&#39; constructor that takes the
    // specified arguments &#39;a1&#39; up to &#39;aN&#39; where &#39;N&#39; (at most 14) is the number
    // of arguments passed to this method.  If &#39;ELEMENT_TYPE&#39; uses &#39;blsma&#39;
    // allocators, then the default allocator is passed as an extra argument in
    // the final position.
#endif  // BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES

                        // ==============
                        // class weak_ptr
                        // ==============

template &lt;class ELEMENT_TYPE&gt;
class weak_ptr {
    // This &#39;class&#39; provides a mechanism to create weak references to
    // reference-counted shared (&#39;shared_ptr&#39;) objects.  A weak reference
    // provides conditional access to a shared object managed by a
    // &#39;shared_ptr&#39;, but, unlike a shared (or &quot;strong&quot;) reference, does not
    // affect the shared object&#39;s lifetime.

    // DATA
    ELEMENT_TYPE                     *d_ptr_p; // pointer to the referenced
                                               // object

    BloombergLP::bslma::SharedPtrRep *d_rep_p; // pointer to the representation
                                               // object that manages the
                                               // shared object (held, not
                                               // owned)

    // FRIENDS
    template &lt;class COMPATIBLE_TYPE&gt;
    friend class weak_ptr;
        // This &#39;friend&#39; declaration provides access to the internal data
        // members while constructing a weak pointer from a weak pointer of a
        // different type.

  public:
    // TYPES
    typedef ELEMENT_TYPE element_type;
        // &#39;element_type&#39; is an alias for the &#39;ELEMENT_TYPE&#39; parameter of this
        // class template.


    // CREATORS
    weak_ptr();
        // Create a weak pointer in the empty state and referring to no object,
        // i.e., a weak pointer having no representation.

    weak_ptr(const weak_ptr&amp; original);
        // Create a weak pointer that refers to the same object (if any) as the
        // specified &#39;original&#39; weak pointer, and increment the number of weak
        // references to the object managed by &#39;original&#39; (if any).  Note that
        // if &#39;original&#39; is in the empty state, this weak pointer will be
        // initialized to the empty state.

    template &lt;class COMPATIBLE_TYPE&gt;
    weak_ptr(const shared_ptr&lt;COMPATIBLE_TYPE&gt;&amp; other);             // IMPLICIT
    template &lt;class COMPATIBLE_TYPE&gt;
    weak_ptr(const weak_ptr&lt;COMPATIBLE_TYPE&gt;&amp; other);               // IMPLICIT
        // Create a weak pointer that refers to the same object (if any) as the
        // specified &#39;other&#39; (shared or weak) pointer of the (template
        // parameter) &#39;COMPATIBLE_TYPE&#39;, and increment the number of weak
        // references to the object managed by &#39;other&#39; (if any).  If
        // &#39;COMPATIBLE_TYPE *&#39; is not implicitly convertible to
        // &#39;ELEMENT_TYPE *&#39;, then a compiler diagnostic will be emitted.  Note
        // that if &#39;other&#39; is in the empty state, this weak pointer will be
        // initialized to the empty state.

    ~weak_ptr();
        // Destroy this weak pointer object.  If this weak pointer manages a
        // (possibly shared) object, release the weak reference to that object.

    // MANIPULATORS
    weak_ptr&amp; operator=(const weak_ptr&amp; rhs);
        // Make this weak pointer refer to the same object (if any) as the
        // specified &#39;rhs&#39; weak pointer.  Decrement the number of weak
        // references to the object this weak pointer manages (if any), and
        // increment the number of weak references to the object managed by
        // &#39;rhs&#39; (if any).  Return a reference providing modifiable access to
        // this weak pointer.  Note that if &#39;rhs&#39; is in the empty state, this
        // weak pointer will be set to the empty state.

    template &lt;class COMPATIBLE_TYPE&gt;
    weak_ptr&amp; operator=(const shared_ptr&lt;COMPATIBLE_TYPE&gt;&amp; rhs);
    template &lt;class COMPATIBLE_TYPE&gt;
    weak_ptr&amp; operator=(const weak_ptr&lt;COMPATIBLE_TYPE&gt;&amp; rhs);
        // Make this weak pointer refer to the same object (if any) as the
        // specified &#39;rhs&#39; (shared or weak) pointer to the (template parameter)
        // &#39;COMPATIBLE_TYPE&#39;.  Decrement the number of weak references to the
        // object to which this weak pointer currently manages (if any), and
        // increment the number of weak references to the object managed by
        // &#39;rhs&#39; (if any).  Return a reference providing modifiable access to
        // this weak pointer.  If &#39;COMPATIBLE_TYPE *&#39; is not implicitly
        // convertible to &#39;TYPE *&#39;, then a compiler diagnostic will be emitted.
        // Note that if &#39;rhs&#39; is in the empty state, this weak pointer will be
        // set to the empty state.

    void reset();
        // Reset this weak pointer to the empty state.  If this weak pointer
        // manages a (possibly shared) object, then decrement the number of
        // weak references to that object.

    void swap(weak_ptr&amp; other);
        // Efficiently exchange the states of this weak pointer and the
        // specified &#39;other&#39; weak pointer such that each will refer to the
        // object (if any) and representation (if any) formerly referred to and
        // managed by the other.

    // ACCESSORS
    bool expired() const;
        // Return &#39;true&#39; if this weak pointer is in the empty state or the
        // object that it originally referenced has been destroyed, and &#39;false&#39;
        // otherwise.

    shared_ptr&lt;ELEMENT_TYPE&gt; lock() const;
        // Return a shared pointer to the object referred to by this weak
        // pointer if &#39;false == expired()&#39;, and a shared pointer in the empty
        // state otherwise.

    template &lt;class ANY_TYPE&gt;
    bool owner_before(const shared_ptr&lt;ANY_TYPE&gt;&amp; other) const;
    template &lt;class ANY_TYPE&gt;
    bool owner_before(const weak_ptr&lt;ANY_TYPE&gt;&amp; other) const;
        // Return &#39;true&#39; if the address of the
        // &#39;BloombergLP::bslma::SharedPtrRep&#39; object used by this weak pointer
        // is ordered before the address of the
        // &#39;BloombergLP::bslma::SharedPtrRep&#39; object used by the specified
        // &#39;other&#39; shared pointer under the total ordering defined by
        // &#39;std::less&lt;BloombergLP::bslma::SharedPtrRep *&gt;&#39;, and &#39;false&#39;
        // otherwise.

    BloombergLP::bslma::SharedPtrRep *rep() const;
        // Return the address providing modifiable access to the
        // &#39;BloombergLP::bslma::SharedPtrRep&#39; object held by this weak pointer,
        // or 0 if this weak pointer is in the empty state.

    long use_count() const;
        // Return a &quot;snapshot&quot; of the current number of shared pointers that
        // share ownership of the object referred to by this weak pointer, or 0
        // if this weak pointer is in the empty state.

};

// ASPECTS
template &lt;class ELEMENT_TYPE&gt;
void swap(weak_ptr&lt;ELEMENT_TYPE&gt;&amp; a, weak_ptr&lt;ELEMENT_TYPE&gt;&amp; b);
    // Efficiently exchange the states of the specified &#39;a&#39; and &#39;b&#39; weak
    // pointers such that each will refer to the object (if any) and
    // representation formerly referred to by the other.

                        // =========================
                        // class hash specialization
                        // =========================

// A partial specialization of &#39;bsl::hash&#39; is no longer necessary, as the
// primary template has the correct behavior once &#39;hashAppend&#39; is defined.

}  // close namespace bsl

namespace BloombergLP {
namespace bslstl {

                            // ====================
                            // struct SharedPtrUtil
                            // ====================

struct SharedPtrUtil {
    // This &#39;struct&#39; provides a namespace for operations on shared pointers.

    // CLASS METHODS
    static
    bsl::shared_ptr&lt;char&gt;
    createInplaceUninitializedBuffer(size_t            bufferSize,
                                     bslma::Allocator *basicAllocator = 0);
        // Return a shared pointer with an in-place representation holding a
        // newly-created uninitialized buffer of the specified &#39;bufferSize&#39; (in
        // bytes).  Optionally specify a &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.

    static void throwBadWeakPtr();
        // Throw a &#39;bsl::bad_weak_ptr&#39; exception.

    // CASTING FUNCTIONS
    template &lt;class TARGET, class SOURCE&gt;
    static
    void constCast(bsl::shared_ptr&lt;TARGET&gt;        *target,
                   const bsl::shared_ptr&lt;SOURCE&gt;&amp;  source);
        // Load into the specified &#39;target&#39; an aliased shared pointer sharing
        // ownership of the object managed by the specified &#39;source&#39; shared
        // pointer and referring to &#39;const_cast&lt;TARGET *&gt;(source.get())&#39;.  If
        // &#39;*target&#39; is already managing a (possibly shared) object, then
        // release the shared reference to that object, and destroy it using
        // its associated deleter if that shared pointer held the last shared
        // reference to that object.  Note that a compiler diagnostic will be
        // emitted indicating an error unless
        // &#39;const_cast&lt;TARGET *&gt;(source.get())&#39; is a valid expression.

    template &lt;class TARGET, class SOURCE&gt;
    static
    bsl::shared_ptr&lt;TARGET&gt; constCast(const bsl::shared_ptr&lt;SOURCE&gt;&amp; source);
        // Return a &#39;bsl::shared_ptr&lt;TARGET&gt;&#39; object sharing ownership of the
        // same object as the specified &#39;source&#39; shared pointer to the
        // (template parameter) &#39;SOURCE&#39; type, and referring to
        // &#39;const_cast&lt;TARGET *&gt;(source.get())&#39;.  Note that a compiler
        // diagnostic will be emitted indicating an error unless
        // &#39;const_cast&lt;TARGET *&gt;(source.get())&#39; is a valid expression.

    template &lt;class TARGET, class SOURCE&gt;
    static
    void dynamicCast(bsl::shared_ptr&lt;TARGET&gt;        *target,
                     const bsl::shared_ptr&lt;SOURCE&gt;&amp;  source);
        // Load into the specified &#39;target&#39; an aliased shared pointer sharing
        // ownership of the object managed by the specified &#39;source&#39; shared
        // pointer and referring to &#39;dynamic_cast&lt;TARGET *&gt;(source.get())&#39;.  If
        // &#39;*target&#39; is already managing a (possibly shared) object, then
        // release the shared reference to that object, and destroy it using
        // its associated deleter if that shared pointer held the last shared
        // reference to that object.  If
        // &#39;0 == dynamic_cast&lt;TARGET*&gt;(source.get())&#39; then &#39;*target&#39; shall be
        // reset to an empty state that does not refer to an object.  Note that
        // a compiler diagnostic will be emitted indicating an error unless
        // &#39;dynamic_cast&lt;TARGET *&gt;(source.get())&#39; is a valid expression.

    template &lt;class TARGET, class SOURCE&gt;
    static
    bsl::shared_ptr&lt;TARGET&gt; dynamicCast(const bsl::shared_ptr&lt;SOURCE&gt;&amp; source);
        // Return a &#39;bsl::shared_ptr&lt;TARGET&gt;&#39; object sharing ownership of the
        // same object as the specified &#39;source&#39; shared pointer to the
        // (template parameter) &#39;SOURCE&#39; type, and referring to
        // &#39;dynamic_cast&lt;TARGET *&gt;(source.get())&#39;.  If that would return a
        // shared pointer referring to nothing (&#39;0 == get()&#39;) then instead
        // return an (empty) default constructed shared pointer. Note that a
        // compiler diagnostic will be emitted indicating an error unless
        // &#39;dynamic_cast&lt;TARGET *&gt;(source.get())&#39; is a valid expression..

    template &lt;class TARGET, class SOURCE&gt;
    static
    void staticCast(bsl::shared_ptr&lt;TARGET&gt;        *target,
                    const bsl::shared_ptr&lt;SOURCE&gt;&amp;  source);
        // Load into the specified &#39;target&#39; an aliased shared pointer sharing
        // ownership of the object managed by the specified &#39;source&#39; shared
        // pointer and referring to &#39;static_cast&lt;TARGET *&gt;(source.get())&#39;.  If
        // &#39;*target&#39; is already managing a (possibly shared) object, then
        // release the shared reference to that object, and destroy it using
        // its associated deleter if that shared pointer held the last shared
        // reference to that object.  Note that a compiler diagnostic will be
        // emitted indicating an error unless
        // &#39;static_cast&lt;TARGET *&gt;(source.get())&#39; is a valid expression.

    template &lt;class TARGET, class SOURCE&gt;
    static
    bsl::shared_ptr&lt;TARGET&gt; staticCast(const bsl::shared_ptr&lt;SOURCE&gt;&amp; source);
        // Return a &#39;bsl::shared_ptr&lt;TARGET&gt;&#39; object sharing ownership of the
        // same object as the specified &#39;source&#39; shared pointer to the
        // (template parameter) &#39;SOURCE&#39; type, and referring to
        // &#39;static_cast&lt;TARGET *&gt;(source.get())&#39;.  Note that a compiler
        // diagnostic will be emitted indicating an error unless
        // &#39;static_cast&lt;TARGET *&gt;(source.get())&#39; is a valid expression.
};

                         // ==========================
                         // struct SharedPtrNilDeleter
                         // ==========================

struct SharedPtrNilDeleter {
    // This &#39;struct&#39; provides a function-like shared pointer deleter that does
    // nothing when invoked.

    // ACCESSORS
    void operator()(const void *) const;
        // No-Op.
};

                       // ===============================
                       // struct SharedPtr_DefaultDeleter
                       // ===============================

struct SharedPtr_DefaultDeleter {
    // This &#39;struct&#39; provides a function-like shared pointer deleter that
    // invokes &#39;delete&#39; with the passed pointer.

    // ACCESSORS
    template &lt;class ANY_TYPE&gt;
    void operator()(ANY_TYPE *ptr) const;
        // Call &#39;delete&#39; with the specified &#39;ptr&#39;.
};

                        // ==========================
                        // class SharedPtr_RepProctor
                        // ==========================

class SharedPtr_RepProctor {
    // This &#39;class&#39; implements a proctor that, unless its &#39;release&#39; method has
    // previously been invoked, automatically releases a reference held by the
    // &#39;bslma::SharedPtrRep&#39; object that is supplied at construction.

  private:
    // DATA
    bslma::SharedPtrRep *d_rep_p;    // Address of representation being managed

  private:
    // NOT IMPLEMENTED
    SharedPtr_RepProctor(const SharedPtr_RepProctor&amp;);
    SharedPtr_RepProctor&amp; operator=(const SharedPtr_RepProctor&amp;);

  public:
    // CREATORS
    explicit SharedPtr_RepProctor(bslma::SharedPtrRep *rep);
        // Create a &#39;SharedPtr_RepProctor&#39; that conditionally manages the
        // specified &#39;rep&#39; (if non-zero).

    ~SharedPtr_RepProctor();
        // Destroy this &#39;SharedPtr_RepProctor&#39;, and dispose of (deallocate) the
        // &#39;bslma::SharedPtrRep&#39; it manages (if any).  If no such object is
        // currently being managed, this method has no effect.  Note that the
        // destructor of the &#39;bslma::SharedPtrRep&#39; will not be called as the
        // reference count will not be decremented.

    // MANIPULATORS
    void release();
        // Release from management the object currently managed by this
        // proctor.  If no object is currently being managed, this method has
        // no effect.
};

}  // close package namespace
}  // close enterprise namespace

// ============================================================================
//                           INLINE DEFINITIONS
// ============================================================================

namespace bsl {

                            // ----------------
                            // class shared_ptr
                            // ----------------

// PRIVATE CLASS METHODS
template &lt;class ELEMENT_TYPE&gt;
template &lt;class INPLACE_REP&gt;
inline
BloombergLP::bslma::SharedPtrRep *
shared_ptr&lt;ELEMENT_TYPE&gt;::makeInternalRep(
                                         ELEMENT_TYPE                     *,
                                         INPLACE_REP                      *,
                                         BloombergLP::bslma::SharedPtrRep *rep)
{
    return rep;
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE, class ALLOCATOR&gt;
inline
BloombergLP::bslma::SharedPtrRep *
shared_ptr&lt;ELEMENT_TYPE&gt;::makeInternalRep(
                                      COMPATIBLE_TYPE               *ptr,
                                      ALLOCATOR                     *,
                                      BloombergLP::bslma::Allocator *allocator)
{
    typedef BloombergLP::bslma::SharedPtrOutofplaceRep&lt;
                                               COMPATIBLE_TYPE,
                                               BloombergLP::bslma::Allocator *&gt;
                                                                      RepMaker;

    return RepMaker::makeOutofplaceRep(ptr, allocator, allocator);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE, class DELETER&gt;
inline
BloombergLP::bslma::SharedPtrRep *
shared_ptr&lt;ELEMENT_TYPE&gt;::makeInternalRep(COMPATIBLE_TYPE *ptr,
                                          DELETER         *deleter,
                                          ...)
{
    typedef BloombergLP::bslma::SharedPtrOutofplaceRep&lt;COMPATIBLE_TYPE,
                                                       DELETER *&gt;     RepMaker;

    return RepMaker::makeOutofplaceRep(ptr, deleter, 0);
}

// CREATORS
template &lt;class ELEMENT_TYPE&gt;
inline
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr()
: d_ptr_p(0)
, d_rep_p(0)
{
}

template &lt;class ELEMENT_TYPE&gt;
inline
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(bsl::nullptr_t)
: d_ptr_p(0)
, d_rep_p(0)
{
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE&gt;
inline
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(COMPATIBLE_TYPE *ptr)
: d_ptr_p(ptr)
{
    typedef BloombergLP::bslstl::SharedPtr_DefaultDeleter Deleter;
    typedef BloombergLP::bslma::SharedPtrOutofplaceRep&lt;COMPATIBLE_TYPE,
                                                       Deleter&gt;       RepMaker;

    d_rep_p = RepMaker::makeOutofplaceRep(ptr, Deleter(), 0);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE&gt;
inline
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(
                                 COMPATIBLE_TYPE               *ptr,
                                 BloombergLP::bslma::Allocator *basicAllocator)
: d_ptr_p(ptr)
{
    typedef BloombergLP::bslma::SharedPtrOutofplaceRep&lt;
                                               COMPATIBLE_TYPE,
                                               BloombergLP::bslma::Allocator *&gt;
                                                                      RepMaker;

    d_rep_p = RepMaker::makeOutofplaceRep(ptr, basicAllocator, basicAllocator);
}

template &lt;class ELEMENT_TYPE&gt;
inline
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(ELEMENT_TYPE                     *ptr,
                                     BloombergLP::bslma::SharedPtrRep *rep)
: d_ptr_p(ptr)
, d_rep_p(rep)
{
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE, class DISPATCH&gt;
inline
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(COMPATIBLE_TYPE *ptr,
                                     DISPATCH        *dispatch)
: d_ptr_p(ptr)
, d_rep_p(makeInternalRep(ptr, dispatch, dispatch))
{
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE, class DELETER&gt;
inline
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(
                                 COMPATIBLE_TYPE               *ptr,
                                 DELETER                        deleter,
                                 BloombergLP::bslma::Allocator *basicAllocator)
: d_ptr_p(ptr)
{
    typedef BloombergLP::bslma::SharedPtrOutofplaceRep&lt;COMPATIBLE_TYPE,
                                                       DELETER&gt; RepMaker;

    d_rep_p = RepMaker::makeOutofplaceRep(ptr, deleter, basicAllocator);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE, class DELETER, class ALLOCATOR&gt;
inline
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(COMPATIBLE_TYPE *ptr,
                                     DELETER          deleter,
                                     ALLOCATOR        basicAllocator,
                                     typename ALLOCATOR::value_type *)
: d_ptr_p(ptr)
{
#ifdef BSLS_PLATFORM_CMP_MSVC
    // This is not quite C++11 &#39;decay&#39; as we do not need to worry about array
    // types, and do not want to remove reference or cv-qualification from
    // DELETER otherwise.  This works around a Microsoft bug turning function
    // pointers into function references.

    typedef typename bsl::conditional&lt;bsl::is_function&lt;DELETER&gt;::value,
                                      typename bsl::add_pointer&lt;DELETER&gt;::type,
                                      DELETER&gt;::type DeleterType;
#else
    typedef DELETER DeleterType;
#endif

    typedef
    BloombergLP::bslstl::SharedPtrAllocateOutofplaceRep&lt;COMPATIBLE_TYPE,
                                                        DeleterType,
                                                        ALLOCATOR&gt; RepMaker;

    d_rep_p = RepMaker::makeOutofplaceRep(ptr, deleter, basicAllocator);
}

template &lt;class ELEMENT_TYPE&gt;
inline
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(nullptr_t,
                                     BloombergLP::bslma::Allocator *)
: d_ptr_p(0)
, d_rep_p(0)
{
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class DELETER&gt;
inline
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(
                                 nullptr_t,
                                 DELETER                        deleter,
                                 BloombergLP::bslma::Allocator *basicAllocator)
: d_ptr_p(0)
{
    typedef BloombergLP::bslma::SharedPtrOutofplaceRep&lt;ELEMENT_TYPE,
                                                       DELETER&gt; RepMaker;

    if (bsl::is_convertible&lt;DELETER, BloombergLP::bslma::Allocator *&gt;::value &amp;&amp;
        bsl::is_pointer&lt;DELETER&gt;::value) {
        d_rep_p = 0;
    }
    else {
        d_rep_p = RepMaker::makeOutofplaceRep((ELEMENT_TYPE *)0,
                                              deleter,
                                              basicAllocator);
    }
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class DELETER, class ALLOCATOR&gt;
inline
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(
                                nullptr_t,
                                DELETER                         deleter,
                                ALLOCATOR                       basicAllocator,
                                typename ALLOCATOR::value_type *)
: d_ptr_p(0)
{
#ifdef BSLS_PLATFORM_CMP_MSVC
    // This is not quite C++11 &#39;decay&#39; as we do not need to worry about array
    // types, and do not want to remove reference or cv-qualification from
    // DELETER otherwise.  This works around a Microsoft bug turning function
    // pointers into function references.

    typedef typename bsl::conditional&lt;bsl::is_function&lt;DELETER&gt;::value,
                                      typename bsl::add_pointer&lt;DELETER&gt;::type,
                                      DELETER&gt;::type DeleterType;
#else
    typedef DELETER DeleterType;
#endif

    typedef
    BloombergLP::bslstl::SharedPtrAllocateOutofplaceRep&lt;ELEMENT_TYPE,
                                                        DeleterType,
                                                        ALLOCATOR&gt; RepMaker;

    d_rep_p = RepMaker::makeOutofplaceRep((ELEMENT_TYPE *)0,
                                          deleter,
                                          basicAllocator);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE&gt;
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(
               BloombergLP::bslma::ManagedPtr&lt;COMPATIBLE_TYPE&gt;  managedPtr,
               BloombergLP::bslma::Allocator                   *basicAllocator)
: d_ptr_p(managedPtr.ptr())
, d_rep_p(0)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;
                     BloombergLP::bslma::ManagedPtr&lt;ELEMENT_TYPE&gt; &gt; Rep;

    if (d_ptr_p) {
        if (&amp;BloombergLP::bslma::SharedPtrRep::managedPtrDeleter ==
                                              managedPtr.deleter().deleter()) {
            d_rep_p = static_cast&lt;BloombergLP::bslma::SharedPtrRep *&gt;
                                       (managedPtr.release().second.factory());
        }
        else {
            basicAllocator =
                        BloombergLP::bslma::Default::allocator(basicAllocator);
            Rep *rep = new (*basicAllocator) Rep(basicAllocator);
            (*rep-&gt;ptr()) = managedPtr;
            d_rep_p = rep;
        }
    }
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE&gt;
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(
                        native_std::auto_ptr&lt;COMPATIBLE_TYPE&gt;&amp;  autoPtr,
                        BloombergLP::bslma::Allocator          *basicAllocator)
: d_ptr_p(autoPtr.get())
, d_rep_p(0)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;
                                   native_std::auto_ptr&lt;COMPATIBLE_TYPE&gt; &gt; Rep;

    if (d_ptr_p) {
        basicAllocator =
                        BloombergLP::bslma::Default::allocator(basicAllocator);
        Rep *rep = new (*basicAllocator) Rep(basicAllocator);
        (*rep-&gt;ptr()) = autoPtr;
        d_rep_p = rep;
    }
}

template &lt;class ELEMENT_TYPE&gt;
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(
                        native_std::auto_ptr_ref&lt;ELEMENT_TYPE&gt;  autoRef,
                        BloombergLP::bslma::Allocator          *basicAllocator)
: d_ptr_p(0)
, d_rep_p(0)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;
                                      native_std::auto_ptr&lt;ELEMENT_TYPE&gt; &gt; Rep;

    native_std::auto_ptr&lt;ELEMENT_TYPE&gt; autoPtr(autoRef);
    if (autoPtr.get()) {
        basicAllocator =
                        BloombergLP::bslma::Default::allocator(basicAllocator);
        Rep *rep = new (*basicAllocator) Rep(basicAllocator);
        d_ptr_p = autoPtr.get();
        (*rep-&gt;ptr()) = autoPtr;
        d_rep_p = rep;
    }
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class ANY_TYPE&gt;
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(const shared_ptr&lt;ANY_TYPE&gt;&amp;  source,
                                     ELEMENT_TYPE                *object)
: d_ptr_p(object)
, d_rep_p(source.d_rep_p)
{
    if (d_rep_p) {
        d_rep_p-&gt;acquireRef();
    }
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE&gt;
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(const shared_ptr&lt;COMPATIBLE_TYPE&gt;&amp; other)
: d_ptr_p(other.d_ptr_p)
, d_rep_p(other.d_rep_p)
{
    if (d_ptr_p) {
        d_rep_p-&gt;acquireRef();
    } else {
        d_rep_p = 0;
    }
}

template &lt;class ELEMENT_TYPE&gt;
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(const shared_ptr&amp; original)
: d_ptr_p(original.d_ptr_p)
, d_rep_p(original.d_rep_p)
{
    if (d_ptr_p) {
        d_rep_p-&gt;acquireRef();
    } else {
        d_rep_p = 0;
    }
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE&gt;
shared_ptr&lt;ELEMENT_TYPE&gt;::shared_ptr(const weak_ptr&lt;COMPATIBLE_TYPE&gt;&amp; other)
: d_ptr_p(0)
, d_rep_p(0)
{
    // This implementation handles two awkward cases:
    //
    // i) a ref-counted null pointer, means we cannot simply test &#39;if (!value)&#39;
    // ii) a null pointer aliasing a non-null pointer is still expired, and so
    //     should throw.

    SelfType value = other.lock();
    if (other.expired()) {
        // Test after lock to avoid a race between testing &#39;expired&#39; and
        // claiming the lock.

        BloombergLP::bslstl::SharedPtrUtil::throwBadWeakPtr();
    }

    swap(value);
}

template &lt;class ELEMENT_TYPE&gt;
shared_ptr&lt;ELEMENT_TYPE&gt;::~shared_ptr()
{
    if (d_rep_p) {
        d_rep_p-&gt;releaseRef();
    }
}

// MANIPULATORS
template &lt;class ELEMENT_TYPE&gt;
shared_ptr&lt;ELEMENT_TYPE&gt;&amp;
shared_ptr&lt;ELEMENT_TYPE&gt;::operator=(const shared_ptr&amp; rhs)
{
    // Instead of testing &#39;&amp;rhs == this&#39;, which happens infrequently, optimize
    // for when reps are the same.

    if (rhs.d_rep_p == d_rep_p) {
        d_ptr_p = rhs.d_ptr_p;
    }
    else {
        SelfType(rhs).swap(*this);
    }

    return *this;
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE&gt;
shared_ptr&lt;ELEMENT_TYPE&gt;&amp;
shared_ptr&lt;ELEMENT_TYPE&gt;::operator=(const shared_ptr&lt;COMPATIBLE_TYPE&gt;&amp; rhs)
{
    // Instead of testing &#39;&amp;rhs == this&#39;, which happens infrequently, optimize
    // for when reps are the same.

    if (rhs.d_rep_p == d_rep_p) {
        d_ptr_p = rhs.d_ptr_p;
    }
    else {
        SelfType(rhs).swap(*this);
    }

    return *this;
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE&gt;
inline
shared_ptr&lt;ELEMENT_TYPE&gt;&amp;
shared_ptr&lt;ELEMENT_TYPE&gt;::operator=(native_std::auto_ptr&lt;COMPATIBLE_TYPE&gt; rhs)
{
    SelfType(rhs).swap(*this);
    return *this;
}

template &lt;class ELEMENT_TYPE&gt;
inline
void shared_ptr&lt;ELEMENT_TYPE&gt;::reset()
{
    BloombergLP::bslma::SharedPtrRep *rep = d_rep_p;

    // Clear &#39;d_rep_p&#39; first so that a self-referencing shared pointer&#39;s
    // destructor does not try to call &#39;releaseRef&#39; again.

    d_rep_p = 0;
    d_ptr_p = 0;

    if (rep) {
        rep-&gt;releaseRef();
    }
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE&gt;
inline
void shared_ptr&lt;ELEMENT_TYPE&gt;::reset(COMPATIBLE_TYPE *ptr)
{
    SelfType(ptr).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE, class DELETER&gt;
inline
void shared_ptr&lt;ELEMENT_TYPE&gt;::reset(COMPATIBLE_TYPE *ptr,
                                     DELETER          deleter)
{
    SelfType(ptr, deleter).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE, class DELETER, class ALLOCATOR&gt;
inline
void shared_ptr&lt;ELEMENT_TYPE&gt;::reset(COMPATIBLE_TYPE *ptr,
                                     DELETER          deleter,
                                     ALLOCATOR        basicAllocator)
{
    SelfType(ptr, deleter, basicAllocator).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class ANY_TYPE&gt;
inline
void shared_ptr&lt;ELEMENT_TYPE&gt;::reset(const shared_ptr&lt;ANY_TYPE&gt;&amp;  source,
                                     ELEMENT_TYPE                *ptr)
{
    // Optimize for the (expected) common case where aliases are managing the
    // same data structure.

    if (source.d_rep_p == d_rep_p &amp;&amp; ptr) {
        d_ptr_p = ptr;
    }
    else {
        SelfType(source, ptr).swap(*this);
    }
}

template &lt;class ELEMENT_TYPE&gt;
inline
void shared_ptr&lt;ELEMENT_TYPE&gt;::swap(shared_ptr&lt;ELEMENT_TYPE&gt;&amp; other)
{
    // We directly implement swapping of two pointers, rather than simply
    // calling &#39;bsl::swap&#39; or using &#39;bslalg::SwapUtil&#39;, to avoid (indirectly)
    // including the platform &lt;algorithm&gt; header, which may transitively
    // include other standard headers.  This reduces the risk of
    // platform-specific cycles, which have been observed to cause problems.

    ELEMENT_TYPE *tempPtr_p = d_ptr_p;
    d_ptr_p       = other.d_ptr_p;
    other.d_ptr_p = tempPtr_p;

    BloombergLP::bslma::SharedPtrRep *tempRep_p = d_rep_p;
    d_rep_p       = other.d_rep_p;
    other.d_rep_p = tempRep_p;
}

// ADDITIONAL BSL MANIPULATORS
template&lt;class ELEMENT_TYPE&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;
    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}

#if defined(BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES)
# if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES)
template &lt;class ELEMENT_TYPE&gt;
template &lt;class... ARGS&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 ARGS&amp;&amp;...                      args)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;

    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator,
                              BloombergLP::bsls::Util::forward&lt;ARGS&gt;(args)...);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}
# else
template &lt;class ELEMENT_TYPE&gt;
template &lt;class... ARGS&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 const ARGS&amp;...                 args)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;

    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator, args...);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}
# endif  // BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#else
template &lt;class ELEMENT_TYPE&gt;
template &lt;class A1&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 const A1&amp;                      a1)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;
    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator, a1);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class A1, class A2&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 const A1&amp;                      a1,
                                 const A2&amp;                      a2)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;
    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator, a1, a2);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class A1, class A2, class A3&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 const A1&amp;                      a1,
                                 const A2&amp;                      a2,
                                 const A3&amp;                      a3)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;
    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator, a1, a2, a3);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class A1, class A2, class A3, class A4&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 const A1&amp;                      a1,
                                 const A2&amp;                      a2,
                                 const A3&amp;                      a3,
                                 const A4&amp;                      a4)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;
    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator, a1, a2, a3, a4);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 const A1&amp;                      a1,
                                 const A2&amp;                      a2,
                                 const A3&amp;                      a3,
                                 const A4&amp;                      a4,
                                 const A5&amp;                      a5)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;
    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator, a1, a2, a3, a4, a5);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 const A1&amp;                      a1,
                                 const A2&amp;                      a2,
                                 const A3&amp;                      a3,
                                 const A4&amp;                      a4,
                                 const A5&amp;                      a5,
                                 const A6&amp;                      a6)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;
    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator,
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 const A1&amp;                      a1,
                                 const A2&amp;                      a2,
                                 const A3&amp;                      a3,
                                 const A4&amp;                      a4,
                                 const A5&amp;                      a5,
                                 const A6&amp;                      a6,
                                 const A7&amp;                      a7)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;
    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator,
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7, class A8&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 const A1&amp;                      a1,
                                 const A2&amp;                      a2,
                                 const A3&amp;                      a3,
                                 const A4&amp;                      a4,
                                 const A5&amp;                      a5,
                                 const A6&amp;                      a6,
                                 const A7&amp;                      a7,
                                 const A8&amp;                      a8)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;
    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator,
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7,
                                         a8);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7, class A8, class A9&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 const A1&amp;                      a1,
                                 const A2&amp;                      a2,
                                 const A3&amp;                      a3,
                                 const A4&amp;                      a4,
                                 const A5&amp;                      a5,
                                 const A6&amp;                      a6,
                                 const A7&amp;                      a7,
                                 const A8&amp;                      a8,
                                 const A9&amp;                      a9)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;
    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator,
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7,
                                         a8,
                                         a9);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7, class A8, class A9, class A10&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 const A1&amp;                      a1,
                                 const A2&amp;                      a2,
                                 const A3&amp;                      a3,
                                 const A4&amp;                      a4,
                                 const A5&amp;                      a5,
                                 const A6&amp;                      a6,
                                 const A7&amp;                      a7,
                                 const A8&amp;                      a8,
                                 const A9&amp;                      a9,
                                 const A10&amp;                     a10)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;
    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator,
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7,
                                         a8,
                                         a9,
                                         a10);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7, class A8, class A9, class A10, class A11&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 const A1&amp;                      a1,
                                 const A2&amp;                      a2,
                                 const A3&amp;                      a3,
                                 const A4&amp;                      a4,
                                 const A5&amp;                      a5,
                                 const A6&amp;                      a6,
                                 const A7&amp;                      a7,
                                 const A8&amp;                      a8,
                                 const A9&amp;                      a9,
                                 const A10&amp;                     a10,
                                 const A11&amp;                     a11)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;
    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator,
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7,
                                         a8,
                                         a9,
                                         a10,
                                         a11);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7, class A8, class A9, class A10, class A11, class A12&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 const A1&amp;                      a1,
                                 const A2&amp;                      a2,
                                 const A3&amp;                      a3,
                                 const A4&amp;                      a4,
                                 const A5&amp;                      a5,
                                 const A6&amp;                      a6,
                                 const A7&amp;                      a7,
                                 const A8&amp;                      a8,
                                 const A9&amp;                      a9,
                                 const A10&amp;                     a10,
                                 const A11&amp;                     a11,
                                 const A12&amp;                     a12)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;
    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator,
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7,
                                         a8,
                                         a9,
                                         a10,
                                         a11,
                                         a12);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7, class A8, class A9, class A10, class A11, class A12,
          class A13&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 const A1&amp;                      a1,
                                 const A2&amp;                      a2,
                                 const A3&amp;                      a3,
                                 const A4&amp;                      a4,
                                 const A5&amp;                      a5,
                                 const A6&amp;                      a6,
                                 const A7&amp;                      a7,
                                 const A8&amp;                      a8,
                                 const A9&amp;                      a9,
                                 const A10&amp;                     a10,
                                 const A11&amp;                     a11,
                                 const A12&amp;                     a12,
                                 const A13&amp;                     a13)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;
    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator,
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7,
                                         a8,
                                         a9,
                                         a10,
                                         a11,
                                         a12,
                                         a13);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class A1, class A2, class A3, class A4, class A5, class A6,
          class A7, class A8, class A9, class A10, class A11, class A12,
          class A13, class A14&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::createInplace(
                                 BloombergLP::bslma::Allocator *basicAllocator,
                                 const A1&amp;                      a1,
                                 const A2&amp;                      a2,
                                 const A3&amp;                      a3,
                                 const A4&amp;                      a4,
                                 const A5&amp;                      a5,
                                 const A6&amp;                      a6,
                                 const A7&amp;                      a7,
                                 const A8&amp;                      a8,
                                 const A9&amp;                      a9,
                                 const A10&amp;                     a10,
                                 const A11&amp;                     a11,
                                 const A12&amp;                     a12,
                                 const A13&amp;                     a13,
                                 const A14&amp;                     a14)
{
    typedef BloombergLP::bslma::SharedPtrInplaceRep&lt;ELEMENT_TYPE&gt; Rep;
    basicAllocator = BloombergLP::bslma::Default::allocator(basicAllocator);
    Rep *rep = new (*basicAllocator) Rep(basicAllocator,
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7,
                                         a8,
                                         a9,
                                         a10,
                                         a11,
                                         a12,
                                         a13,
                                         a14);
    SelfType(rep-&gt;ptr(), rep).swap(*this);
}
#endif  // BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES

template &lt;class ELEMENT_TYPE&gt;
template &lt;class ANY_TYPE&gt;
void
shared_ptr&lt;ELEMENT_TYPE&gt;::loadAlias(const shared_ptr&lt;ANY_TYPE&gt;&amp;  source,
                                    ELEMENT_TYPE                *object)
{
    if (source.d_rep_p == d_rep_p &amp;&amp; object) {
        d_ptr_p = object;
    }
    else {
        SelfType(source, object).swap(*this);
    }
}

template &lt;class ELEMENT_TYPE&gt;
pair&lt;ELEMENT_TYPE *, BloombergLP::bslma::SharedPtrRep *&gt;
shared_ptr&lt;ELEMENT_TYPE&gt;::release()
{
    pair&lt;ELEMENT_TYPE *, BloombergLP::bslma::SharedPtrRep *&gt; ret(d_ptr_p,
                                                                 d_rep_p);
    d_ptr_p = 0;
    d_rep_p = 0;
    return ret;
}


// ACCESSORS
template &lt;class ELEMENT_TYPE&gt;
inline
#if defined(BSLS_PLATFORM_CMP_IBM)
shared_ptr&lt;ELEMENT_TYPE&gt;::operator typename shared_ptr::BoolType() const
#else
shared_ptr&lt;ELEMENT_TYPE&gt;::operator BoolType() const
#endif
{
    return BloombergLP::bsls::UnspecifiedBool&lt;shared_ptr&gt;::makeValue(d_ptr_p);
}

template &lt;class ELEMENT_TYPE&gt;
inline
typename add_lvalue_reference&lt;ELEMENT_TYPE&gt;::type
shared_ptr&lt;ELEMENT_TYPE&gt;::operator*() const
{
    BSLS_ASSERT_SAFE(d_ptr_p);

    return *d_ptr_p;
}

template &lt;class ELEMENT_TYPE&gt;
inline
ELEMENT_TYPE *shared_ptr&lt;ELEMENT_TYPE&gt;::operator-&gt;() const
{
    return d_ptr_p;
}

template &lt;class ELEMENT_TYPE&gt;
inline
ELEMENT_TYPE *shared_ptr&lt;ELEMENT_TYPE&gt;::get() const
{
    return d_ptr_p;
}

template &lt;class ELEMENT_TYPE&gt;
template&lt;class ANY_TYPE&gt;
inline
bool shared_ptr&lt;ELEMENT_TYPE&gt;::owner_before(
                                       const shared_ptr&lt;ANY_TYPE&gt;&amp; other) const
{
    return native_std::less&lt;BloombergLP::bslma::SharedPtrRep *&gt;()(rep(),
                                                                  other.rep());
}

template &lt;class ELEMENT_TYPE&gt;
template&lt;class ANY_TYPE&gt;
inline
bool
shared_ptr&lt;ELEMENT_TYPE&gt;::owner_before(const weak_ptr&lt;ANY_TYPE&gt;&amp; other) const
{
    return native_std::less&lt;BloombergLP::bslma::SharedPtrRep *&gt;()(rep(),
                                                                  other.rep());
}

template &lt;class ELEMENT_TYPE&gt;
inline
bool shared_ptr&lt;ELEMENT_TYPE&gt;::unique() const
{
    return 1 == use_count();
}

template &lt;class ELEMENT_TYPE&gt;
inline
long shared_ptr&lt;ELEMENT_TYPE&gt;::use_count() const
{
    return d_rep_p ? d_rep_p-&gt;numReferences() : 0;
}

// ADDITIONAL BSL ACCESSORS
template &lt;class ELEMENT_TYPE&gt;
inline
typename add_lvalue_reference&lt;ELEMENT_TYPE&gt;::type
shared_ptr&lt;ELEMENT_TYPE&gt;::operator[](ptrdiff_t index) const
{
    BSLS_ASSERT_SAFE(d_ptr_p);

    return *(d_ptr_p + index);
}

template &lt;class ELEMENT_TYPE&gt;
BloombergLP::bslma::ManagedPtr&lt;ELEMENT_TYPE&gt;
shared_ptr&lt;ELEMENT_TYPE&gt;::managedPtr() const
{
    if (d_rep_p) {
        d_rep_p-&gt;acquireRef();
    }
    BloombergLP::bslma::ManagedPtr&lt;ELEMENT_TYPE&gt; ptr(d_ptr_p,
                                                     d_rep_p,
                         &amp;BloombergLP::bslma::SharedPtrRep::managedPtrDeleter);
    return ptr;
}

template &lt;class ELEMENT_TYPE&gt;
inline
BloombergLP::bslma::SharedPtrRep *shared_ptr&lt;ELEMENT_TYPE&gt;::rep() const
{
    return d_rep_p;
}


                        // --------------
                        // class weak_ptr
                        // --------------

// CREATORS
template &lt;class ELEMENT_TYPE&gt;
inline
weak_ptr&lt;ELEMENT_TYPE&gt;::weak_ptr()
: d_ptr_p(0)
, d_rep_p(0)
{
}

template &lt;class ELEMENT_TYPE&gt;
weak_ptr&lt;ELEMENT_TYPE&gt;::weak_ptr(const weak_ptr&lt;ELEMENT_TYPE&gt;&amp; original)
: d_ptr_p(original.d_ptr_p)
, d_rep_p(original.d_rep_p)
{
    if (d_rep_p) {
        d_rep_p-&gt;acquireWeakRef();
    }
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE&gt;
weak_ptr&lt;ELEMENT_TYPE&gt;::weak_ptr(const shared_ptr&lt;COMPATIBLE_TYPE&gt;&amp; other)
: d_ptr_p(other.get())
, d_rep_p(other.rep())
{
    if (d_rep_p) {
        d_rep_p-&gt;acquireWeakRef();
    }
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE&gt;
weak_ptr&lt;ELEMENT_TYPE&gt;::weak_ptr(const weak_ptr&lt;COMPATIBLE_TYPE&gt;&amp; other)
: d_ptr_p(other.d_ptr_p)
, d_rep_p(other.d_rep_p)
{
    if (d_rep_p) {
        d_rep_p-&gt;acquireWeakRef();
    }
}

template &lt;class ELEMENT_TYPE&gt;
inline
weak_ptr&lt;ELEMENT_TYPE&gt;::~weak_ptr()
{
    if (d_rep_p) {
        d_rep_p-&gt;releaseWeakRef();
    }
}

// MANIPULATORS
template &lt;class ELEMENT_TYPE&gt;
weak_ptr&lt;ELEMENT_TYPE&gt;&amp; weak_ptr&lt;ELEMENT_TYPE&gt;::operator=(
                                             const weak_ptr&lt;ELEMENT_TYPE&gt;&amp; rhs)
{
    weak_ptr&lt;ELEMENT_TYPE&gt; tmp(rhs);
    tmp.swap(*this);
    return *this;
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE&gt;
weak_ptr&lt;ELEMENT_TYPE&gt;&amp; weak_ptr&lt;ELEMENT_TYPE&gt;::operator=(
                                        const shared_ptr&lt;COMPATIBLE_TYPE&gt;&amp; rhs)
{
    weak_ptr&lt;ELEMENT_TYPE&gt; tmp(rhs);
    tmp.swap(*this);
    return *this;
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class COMPATIBLE_TYPE&gt;
weak_ptr&lt;ELEMENT_TYPE&gt;&amp; weak_ptr&lt;ELEMENT_TYPE&gt;::operator=(
                                          const weak_ptr&lt;COMPATIBLE_TYPE&gt;&amp; rhs)
{
    weak_ptr&lt;ELEMENT_TYPE&gt; tmp(rhs);
    tmp.swap(*this);
    return *this;
}

template &lt;class ELEMENT_TYPE&gt;
inline
void weak_ptr&lt;ELEMENT_TYPE&gt;::reset()
{
    if (d_rep_p) {
        d_rep_p-&gt;releaseWeakRef();
    }

    d_ptr_p = 0;
    d_rep_p = 0;
}

template &lt;class ELEMENT_TYPE&gt;
inline
void weak_ptr&lt;ELEMENT_TYPE&gt;::swap(weak_ptr&lt;ELEMENT_TYPE&gt;&amp; other)
{
    // We directly implement swapping of two pointers, rather than simply
    // calling &#39;bsl::swap&#39; or using &#39;bslalg::SwapUtil&#39;, to avoid (indirectly)
    // including the platform &lt;algorithm&gt; header, which may transitively
    // include other standard headers.  This reduces the risk of
    // platform-specific cycles, which have been observed to cause problems.

    ELEMENT_TYPE *tempPtr_p = d_ptr_p;
    d_ptr_p       = other.d_ptr_p;
    other.d_ptr_p = tempPtr_p;

    BloombergLP::bslma::SharedPtrRep *tempRep_p = d_rep_p;
    d_rep_p       = other.d_rep_p;
    other.d_rep_p = tempRep_p;
}

// ACCESSORS
template &lt;class ELEMENT_TYPE&gt;
inline
bool weak_ptr&lt;ELEMENT_TYPE&gt;::expired() const
{
    return !(d_rep_p &amp;&amp; d_rep_p-&gt;numReferences());
}

template &lt;class ELEMENT_TYPE&gt;
shared_ptr&lt;ELEMENT_TYPE&gt; weak_ptr&lt;ELEMENT_TYPE&gt;::lock() const
{
    if (d_rep_p &amp;&amp; d_rep_p-&gt;tryAcquireRef()) {
        return shared_ptr&lt;ELEMENT_TYPE&gt;(d_ptr_p, d_rep_p);            // RETURN
    }
    return shared_ptr&lt;ELEMENT_TYPE&gt;();
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class ANY_TYPE&gt;
inline
bool
weak_ptr&lt;ELEMENT_TYPE&gt;::owner_before(const shared_ptr&lt;ANY_TYPE&gt;&amp; other) const
{
    return native_std::less&lt;BloombergLP::bslma::SharedPtrRep *&gt;()(d_rep_p,
                                                                  other.rep());
}

template &lt;class ELEMENT_TYPE&gt;
template &lt;class ANY_TYPE&gt;
inline
bool
weak_ptr&lt;ELEMENT_TYPE&gt;::owner_before(const weak_ptr&lt;ANY_TYPE&gt;&amp; other) const
{
    return native_std::less&lt;BloombergLP::bslma::SharedPtrRep *&gt;()(
                                                                d_rep_p,
                                                                other.d_rep_p);
}

template &lt;class ELEMENT_TYPE&gt;
inline
BloombergLP::bslma::SharedPtrRep *weak_ptr&lt;ELEMENT_TYPE&gt;::rep() const
{
    return d_rep_p;
}

template &lt;class ELEMENT_TYPE&gt;
inline
long weak_ptr&lt;ELEMENT_TYPE&gt;::use_count() const
{
    return d_rep_p ? d_rep_p-&gt;numReferences() : 0;
}


}  // close namespace bsl

namespace BloombergLP {
namespace bslstl {

                            // --------------------
                            // struct SharedPtrUtil
                            // --------------------

// CLASS METHODS
template &lt;class TARGET, class SOURCE&gt;
inline
void SharedPtrUtil::constCast(bsl::shared_ptr&lt;TARGET&gt;        *target,
                              const bsl::shared_ptr&lt;SOURCE&gt;&amp;  source)
{
    target-&gt;reset(source, const_cast&lt;TARGET *&gt;(source.get()));
}

template &lt;class TARGET, class SOURCE&gt;
inline
bsl::shared_ptr&lt;TARGET&gt;
SharedPtrUtil::constCast(const bsl::shared_ptr&lt;SOURCE&gt;&amp; source)
{
    return bsl::shared_ptr&lt;TARGET&gt;(source,
                                   const_cast&lt;TARGET *&gt;(source.get()));
}

template &lt;class TARGET, class SOURCE&gt;
inline
void SharedPtrUtil::dynamicCast(bsl::shared_ptr&lt;TARGET&gt;        *target,
                                const bsl::shared_ptr&lt;SOURCE&gt;&amp;  source)
{
    if (TARGET *castPtr = dynamic_cast&lt;TARGET *&gt;(source.get())) {
        target-&gt;reset(source, castPtr);
    }
    else {
        target-&gt;reset();
    }
}

template &lt;class TARGET, class SOURCE&gt;
inline
bsl::shared_ptr&lt;TARGET&gt;
SharedPtrUtil::dynamicCast(const bsl::shared_ptr&lt;SOURCE&gt;&amp; source)
{
    if (TARGET *castPtr = dynamic_cast&lt;TARGET *&gt;(source.get())) {
        return bsl::shared_ptr&lt;TARGET&gt;(source, castPtr);              // RETURN
    }

    return bsl::shared_ptr&lt;TARGET&gt;();
}

template &lt;class TARGET, class SOURCE&gt;
inline
void SharedPtrUtil::staticCast(bsl::shared_ptr&lt;TARGET&gt;        *target,
                               const bsl::shared_ptr&lt;SOURCE&gt;&amp;  source)
{
    target-&gt;reset(source, static_cast&lt;TARGET *&gt;(source.get()));
}

template &lt;class TARGET, class SOURCE&gt;
inline
bsl::shared_ptr&lt;TARGET&gt;
SharedPtrUtil::staticCast(const bsl::shared_ptr&lt;SOURCE&gt;&amp; source)
{
    return bsl::shared_ptr&lt;TARGET&gt;(source,
                                   static_cast&lt;TARGET *&gt;(source.get()));
}

                        // --------------------------
                        // struct SharedPtrNilDeleter
                        // --------------------------

// ACCESSORS
inline
void SharedPtrNilDeleter::operator()(const void *) const
{
}

                        // -------------------------------
                        // struct SharedPtr_DefaultDeleter
                        // -------------------------------

// ACCESSORS
template &lt;class ANY_TYPE&gt;
inline
void SharedPtr_DefaultDeleter::operator()(ANY_TYPE *ptr) const
{
    delete ptr;
}

                        // --------------------------
                        // class SharedPtr_RepProctor
                        // --------------------------

// CREATORS
inline
SharedPtr_RepProctor::SharedPtr_RepProctor(bslma::SharedPtrRep *rep)
: d_rep_p(rep)
{
}

inline
SharedPtr_RepProctor::~SharedPtr_RepProctor()
{
    if (d_rep_p) {
        d_rep_p-&gt;disposeRep();
    }
}

// MANIPULATORS
inline
void SharedPtr_RepProctor::release()
{
    d_rep_p = 0;
}

}  // close package namespace
}  // close enterprise namespace

// FREE OPERATORS
template &lt;class LHS_TYPE, class RHS_TYPE&gt;
inline
bool bsl::operator==(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs,
                     const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs)
{
    return lhs.get() == rhs.get();
}

template &lt;class LHS_TYPE, class RHS_TYPE&gt;
inline
bool bsl::operator!=(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs,
                     const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs)
{
    return !(lhs == rhs);
}

template &lt;class LHS_TYPE, class RHS_TYPE&gt;
inline
bool bsl::operator&lt;(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs,
                    const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs)
{
    return native_std::less&lt;const void *&gt;()(lhs.get(), rhs.get());
}

template &lt;class LHS_TYPE, class RHS_TYPE&gt;
inline
bool bsl::operator&gt;(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs,
                    const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs)
{
    return rhs &lt; lhs;
}

template &lt;class LHS_TYPE, class RHS_TYPE&gt;
inline
bool bsl::operator&lt;=(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs,
                     const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs)
{
    return !(rhs &lt; lhs);
}

template &lt;class LHS_TYPE, class RHS_TYPE&gt;
inline
bool bsl::operator&gt;=(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs,
                     const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs)
{
    return !(lhs &lt; rhs);
}

template &lt;class LHS_TYPE&gt;
inline
bool bsl::operator==(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs, bsl::nullptr_t)
{
    return !lhs;
}

template &lt;class RHS_TYPE&gt;
inline
bool bsl::operator==(bsl::nullptr_t, const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs)
{
    return !rhs;
}

template &lt;class LHS_TYPE&gt;
inline
bool bsl::operator!=(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs, bsl::nullptr_t)
{
    return static_cast&lt;bool&gt;(lhs);
}

template &lt;class RHS_TYPE&gt;
inline
bool bsl::operator!=(bsl::nullptr_t, const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs)
{
    return static_cast&lt;bool&gt;(rhs);
}

template &lt;class LHS_TYPE&gt;
inline
bool bsl::operator&lt;(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs, bsl::nullptr_t)
{
    return native_std::less&lt;LHS_TYPE *&gt;()(lhs.get(), 0);
}

template &lt;class RHS_TYPE&gt;
inline
bool bsl::operator&lt;(bsl::nullptr_t, const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs)
{
    return native_std::less&lt;RHS_TYPE *&gt;()(0, rhs.get());
}

template &lt;class LHS_TYPE&gt;
inline
bool bsl::operator&lt;=(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs, bsl::nullptr_t)
{
    return !native_std::less&lt;LHS_TYPE *&gt;()(0, lhs.get());
}

template &lt;class RHS_TYPE&gt;
inline
bool bsl::operator&lt;=(bsl::nullptr_t, const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs)
{
    return !native_std::less&lt;RHS_TYPE *&gt;()(rhs.get(), 0);
}

template &lt;class LHS_TYPE&gt;
inline
bool bsl::operator&gt;(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs, bsl::nullptr_t)
{
    return native_std::less&lt;LHS_TYPE *&gt;()(0, lhs.get());
}

template &lt;class RHS_TYPE&gt;
inline
bool bsl::operator&gt;(bsl::nullptr_t, const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs)
{
    return native_std::less&lt;RHS_TYPE *&gt;()(rhs.get(), 0);
}

template &lt;class LHS_TYPE&gt;
inline
bool bsl::operator&gt;=(const shared_ptr&lt;LHS_TYPE&gt;&amp; lhs, bsl::nullptr_t)
{
    return !native_std::less&lt;LHS_TYPE *&gt;()(lhs.get(), 0);
}

template &lt;class RHS_TYPE&gt;
inline
bool bsl::operator&gt;=(bsl::nullptr_t, const shared_ptr&lt;RHS_TYPE&gt;&amp; rhs)
{
    return !native_std::less&lt;RHS_TYPE *&gt;()(0, rhs.get());
}

template &lt;class CHAR_TYPE, class CHAR_TRAITS, class ELEMENT_TYPE&gt;
inline
native_std::basic_ostream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp;
bsl::operator&lt;&lt;(native_std::basic_ostream&lt;CHAR_TYPE, CHAR_TRAITS&gt;&amp; stream,
                const shared_ptr&lt;ELEMENT_TYPE&gt;&amp;                    rhs)
{
    return stream &lt;&lt; rhs.get();
}

// ASPECTS
template &lt;class HASHALG, class ELEMENT_TYPE&gt;
inline
void bsl::hashAppend(HASHALG&amp; hashAlg, const shared_ptr&lt;ELEMENT_TYPE&gt;&amp; input)
{
    hashAppend(hashAlg, input.get());
}

template &lt;class ELEMENT_TYPE&gt;
inline
void bsl::swap(shared_ptr&lt;ELEMENT_TYPE&gt;&amp; a, shared_ptr&lt;ELEMENT_TYPE&gt;&amp; b)
{
    a.swap(b);
}

template &lt;class ELEMENT_TYPE&gt;
inline
void bsl::swap(weak_ptr&lt;ELEMENT_TYPE&gt;&amp; a, weak_ptr&lt;ELEMENT_TYPE&gt;&amp; b)
{
    a.swap(b);
}

// STANDARD FREE FUNCTIONS
template&lt;class DELETER, class ELEMENT_TYPE&gt;
inline
DELETER *bsl::get_deleter(const shared_ptr&lt;ELEMENT_TYPE&gt;&amp; p)
{
    BloombergLP::bslma::SharedPtrRep *rep = p.rep();
    return rep ? static_cast&lt;DELETER *&gt;(rep-&gt;getDeleter(typeid(DELETER))) : 0;
}

// STANDARD CAST FUNCTIONS
template&lt;class TO_TYPE, class FROM_TYPE&gt;
inline
bsl::shared_ptr&lt;TO_TYPE&gt;
bsl::const_pointer_cast(const shared_ptr&lt;FROM_TYPE&gt;&amp; source)
{
    return shared_ptr&lt;TO_TYPE&gt;(source, const_cast&lt;TO_TYPE *&gt;(source.get()));
}

template&lt;class TO_TYPE, class FROM_TYPE&gt;
inline
bsl::shared_ptr&lt;TO_TYPE&gt;
bsl::dynamic_pointer_cast(const shared_ptr&lt;FROM_TYPE&gt;&amp; source)
{
    if (TO_TYPE *castPtr = dynamic_cast&lt;TO_TYPE *&gt;(source.get())) {
        return shared_ptr&lt;TO_TYPE&gt;(source, castPtr);                  // RETURN
    }

    return shared_ptr&lt;TO_TYPE&gt;();
}

template&lt;class TO_TYPE, class FROM_TYPE&gt;
inline
bsl::shared_ptr&lt;TO_TYPE&gt;
bsl::static_pointer_cast(const shared_ptr&lt;FROM_TYPE&gt;&amp; source)
{
    return shared_ptr&lt;TO_TYPE&gt;(source, static_cast&lt;TO_TYPE *&gt;(source.get()));
}

// STANDARD FACTORY FUNCTIONS
#if defined(BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES)
# if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES)
template&lt;class ELEMENT_TYPE, class ALLOC, class... ARGS&gt;
#if defined(BSLS_PLATFORM_CMP_GNU)
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC a, ARGS&amp;&amp;... args)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(a);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(
                              a,
                              rep_p-&gt;ptr(),
                              BloombergLP::bsls::Util::forward&lt;ARGS&gt;(args)...);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template&lt;class ELEMENT_TYPE, class ALLOC, class... ARGS&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt; bsl::allocate_shared(ALLOC *a, ARGS&amp;&amp;... args)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(
                              bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                              BloombergLP::bsls::Util::forward&lt;ARGS&gt;(args)...);
}

template&lt;class ELEMENT_TYPE, class... ARGS&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared(ARGS&amp;&amp;... args)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(
                              BloombergLP::bslma::Default::allocator(),
                              BloombergLP::bsls::Util::forward&lt;ARGS&gt;(args)...);
}
# else
template&lt;class ELEMENT_TYPE, class ALLOC, class... ARGS&gt;
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC a, const ARGS&amp;... args)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(a);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);

    bsl::allocator_traits&lt;ALLOC&gt;::construct(a, rep_p-&gt;ptr(), args...);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template&lt;class ELEMENT_TYPE, class ALLOC, class... ARGS&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC *a, const ARGS&amp;... args)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                                         args...);
}

template&lt;class ELEMENT_TYPE, class... ARGS&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared(const ARGS&amp;... args)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(
                              BloombergLP::bslma::Default::allocator(),
                              args...);
}
# endif  // BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES
#else
template &lt;class ELEMENT_TYPE, class ALLOC&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC basicAllocator)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(basicAllocator);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(basicAllocator, rep_p-&gt;ptr());
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC basicAllocator, const A1&amp; a1)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(basicAllocator);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(basicAllocator, rep_p-&gt;ptr(), a1);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC basicAllocator, const A1&amp; a1, const A2&amp; a2)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(basicAllocator);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(basicAllocator,
                                            rep_p-&gt;ptr(),
                                            a1,
                                            a2);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC     basicAllocator,
                     const A1&amp; a1,
                     const A2&amp; a2,
                     const A3&amp; a3)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(basicAllocator);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(basicAllocator,
                                            rep_p-&gt;ptr(),
                                            a1,
                                            a2,
                                            a3);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC     basicAllocator,
                     const A1&amp; a1,
                     const A2&amp; a2,
                     const A3&amp; a3,
                     const A4&amp; a4)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(basicAllocator);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(basicAllocator,
                                            rep_p-&gt;ptr(),
                                            a1,
                                            a2,
                                            a3,
                                            a4);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC     basicAllocator,
                     const A1&amp; a1,
                     const A2&amp; a2,
                     const A3&amp; a3,
                     const A4&amp; a4,
                     const A5&amp; a5)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(basicAllocator);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(basicAllocator,
                                            rep_p-&gt;ptr(),
                                            a1,
                                            a2,
                                            a3,
                                            a4,
                                            a5);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC     basicAllocator,
                     const A1&amp; a1,
                     const A2&amp; a2,
                     const A3&amp; a3,
                     const A4&amp; a4,
                     const A5&amp; a5,
                     const A6&amp; a6)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(basicAllocator);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(basicAllocator,
                                            rep_p-&gt;ptr(),
                                            a1,
                                            a2,
                                            a3,
                                            a4,
                                            a5,
                                            a6);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC     basicAllocator,
                     const A1&amp; a1,
                     const A2&amp; a2,
                     const A3&amp; a3,
                     const A4&amp; a4,
                     const A5&amp; a5,
                     const A6&amp; a6,
                     const A7&amp; a7)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(basicAllocator);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(basicAllocator,
                                            rep_p-&gt;ptr(),
                                            a1,
                                            a2,
                                            a3,
                                            a4,
                                            a5,
                                            a6,
                                            a7);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC     basicAllocator,
                     const A1&amp; a1,
                     const A2&amp; a2,
                     const A3&amp; a3,
                     const A4&amp; a4,
                     const A5&amp; a5,
                     const A6&amp; a6,
                     const A7&amp; a7,
                     const A8&amp; a8)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(basicAllocator);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(basicAllocator,
                                            rep_p-&gt;ptr(),
                                            a1,
                                            a2,
                                            a3,
                                            a4,
                                            a5,
                                            a6,
                                            a7,
                                            a8);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC     basicAllocator,
                     const A1&amp; a1,
                     const A2&amp; a2,
                     const A3&amp; a3,
                     const A4&amp; a4,
                     const A5&amp; a5,
                     const A6&amp; a6,
                     const A7&amp; a7,
                     const A8&amp; a8,
                     const A9&amp; a9)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(basicAllocator);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(basicAllocator,
                                            rep_p-&gt;ptr(),
                                            a1,
                                            a2,
                                            a3,
                                            a4,
                                            a5,
                                            a6,
                                            a7,
                                            a8,
                                            a9);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC      basicAllocator,
                     const A1&amp;  a1,
                     const A2&amp;  a2,
                     const A3&amp;  a3,
                     const A4&amp;  a4,
                     const A5&amp;  a5,
                     const A6&amp;  a6,
                     const A7&amp;  a7,
                     const A8&amp;  a8,
                     const A9&amp;  a9,
                     const A10&amp; a10)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(basicAllocator);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(basicAllocator,
                                            rep_p-&gt;ptr(),
                                            a1,
                                            a2,
                                            a3,
                                            a4,
                                            a5,
                                            a6,
                                            a7,
                                            a8,
                                            a9,
                                            a10);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC      basicAllocator,
                     const A1&amp;  a1,
                     const A2&amp;  a2,
                     const A3&amp;  a3,
                     const A4&amp;  a4,
                     const A5&amp;  a5,
                     const A6&amp;  a6,
                     const A7&amp;  a7,
                     const A8&amp;  a8,
                     const A9&amp;  a9,
                     const A10&amp; a10,
                     const A11&amp; a11)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(basicAllocator);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(basicAllocator,
                                            rep_p-&gt;ptr(),
                                            a1,
                                            a2,
                                            a3,
                                            a4,
                                            a5,
                                            a6,
                                            a7,
                                            a8,
                                            a9,
                                            a10,
                                            a11);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11, class A12&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC      basicAllocator,
                     const A1&amp;  a1,
                     const A2&amp;  a2,
                     const A3&amp;  a3,
                     const A4&amp;  a4,
                     const A5&amp;  a5,
                     const A6&amp;  a6,
                     const A7&amp;  a7,
                     const A8&amp;  a8,
                     const A9&amp;  a9,
                     const A10&amp; a10,
                     const A11&amp; a11,
                     const A12&amp; a12)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(basicAllocator);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(basicAllocator,
                                            rep_p-&gt;ptr(),
                                            a1,
                                            a2,
                                            a3,
                                            a4,
                                            a5,
                                            a6,
                                            a7,
                                            a8,
                                            a9,
                                            a10,
                                            a11,
                                            a12);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11, class A12, class A13&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC      basicAllocator,
                     const A1&amp;  a1,
                     const A2&amp;  a2,
                     const A3&amp;  a3,
                     const A4&amp;  a4,
                     const A5&amp;  a5,
                     const A6&amp;  a6,
                     const A7&amp;  a7,
                     const A8&amp;  a8,
                     const A9&amp;  a9,
                     const A10&amp; a10,
                     const A11&amp; a11,
                     const A12&amp; a12,
                     const A13&amp; a13)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(basicAllocator);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(basicAllocator,
                                            rep_p-&gt;ptr(),
                                            a1,
                                            a2,
                                            a3,
                                            a4,
                                            a5,
                                            a6,
                                            a7,
                                            a8,
                                            a9,
                                            a10,
                                            a11,
                                            a12,
                                            a13);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11, class A12, class A13, class A14&gt;
#if defined(BSLS_PLATFORM_CMP_IBM) // work-around for xlc partial ordering bug
typename bsl::enable_if&lt;!bsl::is_pointer&lt;ALLOC&gt;::value,
                        bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;::type
#else
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
#endif
bsl::allocate_shared(ALLOC      basicAllocator,
                     const A1&amp;  a1,
                     const A2&amp;  a2,
                     const A3&amp;  a3,
                     const A4&amp;  a4,
                     const A5&amp;  a5,
                     const A6&amp;  a6,
                     const A7&amp;  a7,
                     const A8&amp;  a8,
                     const A9&amp;  a9,
                     const A10&amp; a10,
                     const A11&amp; a11,
                     const A12&amp; a12,
                     const A13&amp; a13,
                     const A14&amp; a14)
{
    typedef BloombergLP::bslstl::SharedPtrAllocateInplaceRep&lt;ELEMENT_TYPE,
                                                             ALLOC&gt; Rep;
    Rep *rep_p = Rep::makeRep(basicAllocator);

    BloombergLP::bslstl::SharedPtr_RepProctor proctor(rep_p);
    bsl::allocator_traits&lt;ALLOC&gt;::construct(basicAllocator,
                                            rep_p-&gt;ptr(),
                                            a1,
                                            a2,
                                            a3,
                                            a4,
                                            a5,
                                            a6,
                                            a7,
                                            a8,
                                            a9,
                                            a10,
                                            a11,
                                            a12,
                                            a13,
                                            a14);
    proctor.release();
    return shared_ptr&lt;ELEMENT_TYPE&gt;(rep_p-&gt;ptr(), rep_p);
}

template &lt;class ELEMENT_TYPE, class ALLOC&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC *a)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a));
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC *a, const A1&amp; a1)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                                         a1);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC *a, const A1&amp; a1, const A2&amp; a2)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                                         a1,
                                         a2);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC *a, const A1&amp; a1, const A2&amp; a2, const A3&amp; a3)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                                         a1,
                                         a2,
                                         a3);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC     *a,
                     const A1&amp;  a1,
                     const A2&amp;  a2,
                     const A3&amp;  a3,
                     const A4&amp;  a4)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                                         a1,
                                         a2,
                                         a3,
                                         a4);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC     *a,
                     const A1&amp;  a1,
                     const A2&amp;  a2,
                     const A3&amp;  a3,
                     const A4&amp;  a4,
                     const A5&amp;  a5)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC     *a,
                     const A1&amp;  a1,
                     const A2&amp;  a2,
                     const A3&amp;  a3,
                     const A4&amp;  a4,
                     const A5&amp;  a5,
                     const A6&amp;  a6)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC     *a,
                     const A1&amp;  a1,
                     const A2&amp;  a2,
                     const A3&amp;  a3,
                     const A4&amp;  a4,
                     const A5&amp;  a5,
                     const A6&amp;  a6,
                     const A7&amp;  a7)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC     *a,
                     const A1&amp;  a1,
                     const A2&amp;  a2,
                     const A3&amp;  a3,
                     const A4&amp;  a4,
                     const A5&amp;  a5,
                     const A6&amp;  a6,
                     const A7&amp;  a7,
                     const A8&amp;  a8)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7,
                                         a8);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC     *a,
                     const A1&amp;  a1,
                     const A2&amp;  a2,
                     const A3&amp;  a3,
                     const A4&amp;  a4,
                     const A5&amp;  a5,
                     const A6&amp;  a6,
                     const A7&amp;  a7,
                     const A8&amp;  a8,
                     const A9&amp;  a9)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7,
                                         a8,
                                         a9);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC      *a,
                     const A1&amp;   a1,
                     const A2&amp;   a2,
                     const A3&amp;   a3,
                     const A4&amp;   a4,
                     const A5&amp;   a5,
                     const A6&amp;   a6,
                     const A7&amp;   a7,
                     const A8&amp;   a8,
                     const A9&amp;   a9,
                     const A10&amp;  a10)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7,
                                         a8,
                                         a9,
                                         a10);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC      *a,
                     const A1&amp;   a1,
                     const A2&amp;   a2,
                     const A3&amp;   a3,
                     const A4&amp;   a4,
                     const A5&amp;   a5,
                     const A6&amp;   a6,
                     const A7&amp;   a7,
                     const A8&amp;   a8,
                     const A9&amp;   a9,
                     const A10&amp;  a10,
                     const A11&amp;  a11)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7,
                                         a8,
                                         a9,
                                         a10,
                                         a11);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11, class A12&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC      *a,
                     const A1&amp;   a1,
                     const A2&amp;   a2,
                     const A3&amp;   a3,
                     const A4&amp;   a4,
                     const A5&amp;   a5,
                     const A6&amp;   a6,
                     const A7&amp;   a7,
                     const A8&amp;   a8,
                     const A9&amp;   a9,
                     const A10&amp;  a10,
                     const A11&amp;  a11,
                     const A12&amp;  a12)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7,
                                         a8,
                                         a9,
                                         a10,
                                         a11,
                                         a12);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11, class A12, class A13&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC      *a,
                     const A1&amp;   a1,
                     const A2&amp;   a2,
                     const A3&amp;   a3,
                     const A4&amp;   a4,
                     const A5&amp;   a5,
                     const A6&amp;   a6,
                     const A7&amp;   a7,
                     const A8&amp;   a8,
                     const A9&amp;   a9,
                     const A10&amp;  a10,
                     const A11&amp;  a11,
                     const A12&amp;  a12,
                     const A13&amp;  a13)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7,
                                         a8,
                                         a9,
                                         a10,
                                         a11,
                                         a12,
                                         a13);
}

template &lt;class ELEMENT_TYPE, class ALLOC, class A1, class A2, class A3,
          class A4, class A5, class A6, class A7, class A8, class A9,
          class A10, class A11, class A12, class A13, class A14&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::allocate_shared(ALLOC      *a,
                     const A1&amp;   a1,
                     const A2&amp;   a2,
                     const A3&amp;   a3,
                     const A4&amp;   a4,
                     const A5&amp;   a5,
                     const A6&amp;   a6,
                     const A7&amp;   a7,
                     const A8&amp;   a8,
                     const A9&amp;   a9,
                     const A10&amp;  a10,
                     const A11&amp;  a11,
                     const A12&amp;  a12,
                     const A13&amp;  a13,
                     const A14&amp;  a14)
{
    return allocate_shared&lt;ELEMENT_TYPE&gt;(bsl::allocator&lt;ELEMENT_TYPE&gt;(a),
                                         a1,
                                         a2,
                                         a3,
                                         a4,
                                         a5,
                                         a6,
                                         a7,
                                         a8,
                                         a9,
                                         a10,
                                         a11,
                                         a12,
                                         a13,
                                         a14);
}

template &lt;class ELEMENT_TYPE&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared()
{
    return
       allocate_shared&lt;ELEMENT_TYPE&gt;(BloombergLP::bslma::Default::allocator());
}

template &lt;class ELEMENT_TYPE, class A1&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared(const A1&amp; a1)
{
    return
        allocate_shared&lt;ELEMENT_TYPE&gt;(BloombergLP::bslma::Default::allocator(),
                                      a1);
}

template &lt;class ELEMENT_TYPE, class A1, class A2&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt; bsl::make_shared(const A1&amp; a1, const A2&amp; a2)
{
    return
        allocate_shared&lt;ELEMENT_TYPE&gt;(BloombergLP::bslma::Default::allocator(),
                                      a1,
                                      a2);
}

template &lt;class ELEMENT_TYPE, class A1, class A2, class A3&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::make_shared(const A1&amp; a1, const A2&amp; a2, const A3&amp; a3)
{
    return
        allocate_shared&lt;ELEMENT_TYPE&gt;(BloombergLP::bslma::Default::allocator(),
                                      a1,
                                      a2,
                                      a3);
}

template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::make_shared(const A1&amp; a1, const A2&amp; a2, const A3&amp; a3, const A4&amp; a4)
{
    return
        allocate_shared&lt;ELEMENT_TYPE&gt;(BloombergLP::bslma::Default::allocator(),
                                      a1,
                                      a2,
                                      a3,
                                      a4);
}

template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::make_shared(const A1&amp; a1,
                 const A2&amp; a2,
                 const A3&amp; a3,
                 const A4&amp; a4,
                 const A5&amp; a5)
{
    return
        allocate_shared&lt;ELEMENT_TYPE&gt;(BloombergLP::bslma::Default::allocator(),
                                      a1,
                                      a2,
                                      a3,
                                      a4,
                                      a5);
}

template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::make_shared(const A1&amp; a1,
                 const A2&amp; a2,
                 const A3&amp; a3,
                 const A4&amp; a4,
                 const A5&amp; a5,
                 const A6&amp; a6)
{
    return
        allocate_shared&lt;ELEMENT_TYPE&gt;(BloombergLP::bslma::Default::allocator(),
                                      a1,
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6);
}

template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::make_shared(const A1&amp; a1,
                 const A2&amp; a2,
                 const A3&amp; a3,
                 const A4&amp; a4,
                 const A5&amp; a5,
                 const A6&amp; a6,
                 const A7&amp; a7)
{
    return
        allocate_shared&lt;ELEMENT_TYPE&gt;(BloombergLP::bslma::Default::allocator(),
                                      a1,
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7);
}

template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7, class A8&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::make_shared(const A1&amp; a1,
                 const A2&amp; a2,
                 const A3&amp; a3,
                 const A4&amp; a4,
                 const A5&amp; a5,
                 const A6&amp; a6,
                 const A7&amp; a7,
                 const A8&amp; a8)
{
    return
        allocate_shared&lt;ELEMENT_TYPE&gt;(BloombergLP::bslma::Default::allocator(),
                                      a1,
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8);
}

template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7, class A8, class A9&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::make_shared(const A1&amp; a1,
                 const A2&amp; a2,
                 const A3&amp; a3,
                 const A4&amp; a4,
                 const A5&amp; a5,
                 const A6&amp; a6,
                 const A7&amp; a7,
                 const A8&amp; a8,
                 const A9&amp; a9)
{
    return
        allocate_shared&lt;ELEMENT_TYPE&gt;(BloombergLP::bslma::Default::allocator(),
                                      a1,
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      a9);
}

template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7, class A8, class A9, class A10&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::make_shared(const A1&amp;  a1,
                 const A2&amp;  a2,
                 const A3&amp;  a3,
                 const A4&amp;  a4,
                 const A5&amp;  a5,
                 const A6&amp;  a6,
                 const A7&amp;  a7,
                 const A8&amp;  a8,
                 const A9&amp;  a9,
                 const A10&amp; a10)
{
    return
        allocate_shared&lt;ELEMENT_TYPE&gt;(BloombergLP::bslma::Default::allocator(),
                                      a1,
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      a9,
                                      a10);
}

template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7, class A8, class A9, class A10, class A11&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::make_shared(const A1&amp;  a1,
                 const A2&amp;  a2,
                 const A3&amp;  a3,
                 const A4&amp;  a4,
                 const A5&amp;  a5,
                 const A6&amp;  a6,
                 const A7&amp;  a7,
                 const A8&amp;  a8,
                 const A9&amp;  a9,
                 const A10&amp; a10,
                 const A11&amp; a11)
{
    return
        allocate_shared&lt;ELEMENT_TYPE&gt;(BloombergLP::bslma::Default::allocator(),
                                      a1,
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      a9,
                                      a10,
                                      a11);
}

template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7, class A8, class A9, class A10, class A11,
          class A12&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::make_shared(const A1&amp;  a1,
                 const A2&amp;  a2,
                 const A3&amp;  a3,
                 const A4&amp;  a4,
                 const A5&amp;  a5,
                 const A6&amp;  a6,
                 const A7&amp;  a7,
                 const A8&amp;  a8,
                 const A9&amp;  a9,
                 const A10&amp; a10,
                 const A11&amp; a11,
                 const A12&amp; a12)
{
    return
        allocate_shared&lt;ELEMENT_TYPE&gt;(BloombergLP::bslma::Default::allocator(),
                                      a1,
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      a9,
                                      a10,
                                      a11,
                                      a12);
}

template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7, class A8, class A9, class A10, class A11,
          class A12, class A13&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::make_shared(const A1&amp;  a1,
                 const A2&amp;  a2,
                 const A3&amp;  a3,
                 const A4&amp;  a4,
                 const A5&amp;  a5,
                 const A6&amp;  a6,
                 const A7&amp;  a7,
                 const A8&amp;  a8,
                 const A9&amp;  a9,
                 const A10&amp; a10,
                 const A11&amp; a11,
                 const A12&amp; a12,
                 const A13&amp; a13)
{
    return
        allocate_shared&lt;ELEMENT_TYPE&gt;(BloombergLP::bslma::Default::allocator(),
                                      a1,
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      a9,
                                      a10,
                                      a11,
                                      a12,
                                      a13);
}

template &lt;class ELEMENT_TYPE, class A1, class A2, class A3, class A4, class A5,
          class A6, class A7, class A8, class A9, class A10, class A11,
          class A12, class A13, class A14&gt;
inline
bsl::shared_ptr&lt;ELEMENT_TYPE&gt;
bsl::make_shared(const A1&amp;  a1,
                 const A2&amp;  a2,
                 const A3&amp;  a3,
                 const A4&amp;  a4,
                 const A5&amp;  a5,
                 const A6&amp;  a6,
                 const A7&amp;  a7,
                 const A8&amp;  a8,
                 const A9&amp;  a9,
                 const A10&amp; a10,
                 const A11&amp; a11,
                 const A12&amp; a12,
                 const A13&amp; a13,
                 const A14&amp; a14)
{
    return
        allocate_shared&lt;ELEMENT_TYPE&gt;(BloombergLP::bslma::Default::allocator(),
                                      a1,
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      a9,
                                      a10,
                                      a11,
                                      a12,
                                      a13,
                                      a14);
}

#endif  // BSLS_COMPILERFEATURES_SUPPORT_VARIADIC_TEMPLATES

// ============================================================================
//                              TYPE TRAITS
// ============================================================================

// Type traits for smart pointers:
//: o &#39;shared_ptr&#39; has pointer semantics, but &#39;weak_ptr&#39; does not.
//:
//: o Although &#39;shared_ptr&#39; constructs with an allocator, it does not &#39;use&#39; an
//:   allocator in the manner of the &#39;UsesBslmaAllocator&#39; trait, and should be
//:   explicitly specialized as a clear sign to code inspection tools.
//:
//: o Smart pointers are bitwise-movable as long as there is no opportunity for
//:   holding a pointer to internal state in the immediate object itself.  As
//:   &#39;d_ptr_p&#39; is never exposed by reference, it is not possible to create an
//:   internal pointer, so the trait should be &#39;true&#39;.

namespace BloombergLP {

namespace bslma {

template &lt;class ELEMENT_TYPE&gt;
struct UsesBslmaAllocator&lt; ::bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;
    : bsl::false_type
{};

}  // close traits namespace

namespace bslmf {

template &lt;class ELEMENT_TYPE&gt;
struct HasPointerSemantics&lt; ::bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;
    : bsl::true_type
{};

template &lt;class ELEMENT_TYPE&gt;
struct IsBitwiseMoveable&lt; ::bsl::shared_ptr&lt;ELEMENT_TYPE&gt; &gt;
    : bsl::true_type
{};

template &lt;class ELEMENT_TYPE&gt;
struct IsBitwiseMoveable&lt; ::bsl::weak_ptr&lt;ELEMENT_TYPE&gt; &gt;
    : bsl::true_type
{};

}  // close traits namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
