<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslx_marshallingutil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslx_marshallingutil<br/>
<small>
[<a class="el" href="group__bslx.html">Package bslx</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Support platform-independent marshalling of fundamental types.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslx.html">bslx</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Note on Function Naming and Interface</a> </li>
<li>
<a href="#3.2">IEEE 754 Double-Precision Format</a> </li>
<li>
<a href="#3.3">IEEE 754 Single-Precision Format</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: Round-Trip Marshalling</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Support platform-independent marshalling of fundamental types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbslx_1_1MarshallingUtil.html">bslx::MarshallingUtil</a> </td><td>namespace for put/get marshalling functions  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslx__byteinstream.html" title="Provide a stream class for unexternalization of fundamental types.">Component bslx_byteinstream</a>, <a class="el" href="group__bslx__byteoutstream.html" title="Provide a stream class for externalization of fundamental types.">Component bslx_byteoutstream</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a byte-array-based implementation, <code><a class="el" href="structbslx_1_1MarshallingUtil.html">bslx::MarshallingUtil</a></code>, for a suite of marshalling functions used to convert values (and arrays of values) of the following fundamental integer and floating-point types: <br/>
<br/>
<div class="fragment"><pre class="fragment">      C++ TYPE          REQUIRED CONTENT OF ANY PLATFORM-NEUTRAL FORMAT
      --------          -----------------------------------------------
      Int64             least significant 64 bits (<span class="keywordtype">signed</span>)
      Uint64            least significant 64 bits (<span class="keywordtype">unsigned</span>)
      <span class="keywordtype">int</span>               least significant 32 bits (<span class="keywordtype">signed</span>)
      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      least significant 32 bits (<span class="keywordtype">unsigned</span>)
      <span class="keywordtype">short</span>             least significant 16 bits (<span class="keywordtype">signed</span>)
      <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>    least significant 16 bits (<span class="keywordtype">unsigned</span>)
      <span class="keywordtype">char</span>              least significant  8 bits (platform-dependent)
      <span class="keywordtype">signed</span> <span class="keywordtype">char</span>       least significant  8 bits (<span class="keywordtype">signed</span>)
      <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>     least significant  8 bits (<span class="keywordtype">unsigned</span>)
      <span class="keywordtype">double</span>            IEEE standard 8-byte floating-point value
      <span class="keywordtype">float</span>             IEEE standard 4-byte floating-point value
</pre></div><br/>
<br/>
 In addition to basic marshalling functions, where each marshalled instance of a fundamental type occupies the same number of bytes in the stream (regardless of its value), this component provides an interface for efficient marshalling of integer types. In particular, 64-bit values can be streamed as 40-, 48-, 56-, or 64-bit values, and 32-bit values can be streamed as 24- or 32-bit values. Marshalled integers are written and assumed to be in two's complement, big-endian format (i.e., network byte order). Floating-point formats are described below. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="note_on_function_naming_and_interface"></a> <a class="anchor" id="description.note_on_function_naming_and_interface"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Note on Function Naming and Interface: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The names and interfaces of the functions of <code><a class="el" href="structbslx_1_1MarshallingUtil.html">bslx::MarshallingUtil</a></code> follow a systematic fashion explained below. This makes it easier to guess the name and signature of the intended function. In what follows, <code>buffer</code> is always of type <code>char *</code> or <code>const char *</code> depending on whether it is used as an input or an output, and <code>variable</code> and <code>value</code> are of a type that depends on the name of the function and intended width, with <code>variable</code> used as an output, while <code>value</code> is used as an input. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Here are the <code>get...</code> functions for integral and floating-point scalar types: <br/>
<br/>
<div class="fragment"><pre class="fragment">   Name                           <a class="code" href="classBind__ImplSelector_1_1Type.html">Type</a> of <span class="stringliteral">&#39;variable&#39;</span>           Notes
   ----                           ------------------           -----
   getIntNN(variable, buffer)     bsls::Types::Int64 *         NN=64,56,48,40
                                  <span class="keywordtype">int</span> *                        NN=32,24
                                  <span class="keywordtype">short</span> *                      NN=16
                                  <span class="keywordtype">char</span> *                       NN=8
                                  <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *                NN=8
                                  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *              NN=8

   getUintNN(variable, buffer)    bsls::Types::Uint64 *        NN=64,56,48,40
                                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *               NN=32,24
                                  <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> *             NN=16

   getFloatNN(variable, buffer)   <span class="keywordtype">double</span> *                     NN=64
                                  <span class="keywordtype">float</span> *                      NN=32
</pre></div><br/>
<br/>
 Here are the <code>put...</code> functions for scalar types. Note that there is no <code>putUintNN</code> since <code>putIntNN</code> applies equally to unsigned <code>NN</code>-bit values (through a conversion to a signed value): <br/>
<br/>
<div class="fragment"><pre class="fragment">   Name                           <a class="code" href="classBind__ImplSelector_1_1Type.html">Type</a> of <span class="stringliteral">&#39;value&#39;</span>              Notes
   ----                           ---------------              -----
   putIntNN(buffer, value)        bsls::Types::Int64           NN=64,56,48,40
                                  <span class="keywordtype">int</span>                          NN=32,24,16,8

   putFloatNN(buffer, value)      <span class="keywordtype">double</span>                       NN=64
                                  <span class="keywordtype">float</span>                        NN=32
</pre></div><br/>
<br/>
 Here are the <code>getArray...</code> functions for integral and floating-point scalar array types: <br/>
<br/>
<div class="fragment"><pre class="fragment">   Name                           <a class="code" href="classBind__ImplSelector_1_1Type.html">Type</a> of <span class="stringliteral">&#39;variables&#39;</span>          Notes
   ----                           ----------------             -----
   getArrayIntNN(variables,       <a class="code" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *         NN=64,56,48,40
                 buffer,          <span class="keywordtype">int</span> *                        NN=32,24
                 numVariables)    short *                      NN=16
                                  <span class="keywordtype">char</span> *                       NN=8
                                  <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *                NN=8
                                  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *              NN=8

   getArrayUintNN(variables,      bsls::Types::Uint64 *        NN=64,56,48,40
                  buffer,         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *               NN=32,24
                  numVariables)   <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> *             NN=16

   getArrayFloatNN(variables,     <span class="keywordtype">double</span> *                     NN=64
                   buffer,        <span class="keywordtype">float</span> *                      NN=32
                   numVariables)
</pre></div><br/>
<br/>
 Finally, the <code>putArray...</code> functions follow. Note that this time there is an overload for unsigned types, but that the function name is still <code>putArrayInt...</code> for arrays of both signed and unsigned integrals: <br/>
<br/>
<div class="fragment"><pre class="fragment">   Name                           <a class="code" href="classBind__ImplSelector_1_1Type.html">Type</a> of <span class="stringliteral">&#39;values&#39;</span>             Notes
   ----                           ---------------              -----
   putArrayIntNN(buffer,          <span class="keyword">const</span> <a class="code" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *   NN=64,56,48,40
                 values,          <span class="keyword">const</span> <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *  NN=64,56,48,40
                 numValues)       const <span class="keywordtype">int</span> *                  NN=32,24
                                  const <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *         NN=32,24
                                  const <span class="keywordtype">short</span> *                NN=16
                                  const <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> *       NN=16
                                  const <span class="keywordtype">char</span> *                 NN=8
                                  const <span class="keywordtype">signed</span> <span class="keywordtype">char</span> *          NN=8
                                  const <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *        NN=8

   putArrayFloatNN(buffer,        const <span class="keywordtype">double</span> *               NN=64
                   values,        const <span class="keywordtype">float</span> *                NN=32
                   numValues)
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="ieee_754_double-precision_format"></a> <a class="anchor" id="description.ieee_754_double-precision_format"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>IEEE 754 Double-Precision Format: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code>double</code> is assumed to be <em>at</em> <em>least</em> 64 bits in size. The externalized byte representation of a 64-bit floating-point value is defined to conform to the IEEE double-precision format illustrated below. If the native representation of a 64-bit floating-point value does not match this format, a conversion process to and from this format is performed. This conversion may (of course) be lossy: <br/>
<br/>
<div class="fragment"><pre class="fragment">  sign bit    11-bit exponent             52-bit significand
    /        /                           /
  +-+-----------+----------------------------------------------------+
  |s|e10......e0|m51...............................................m0|
  +-+-----------+----------------------------------------------------+
  LSB                                                              MSB
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="ieee_754_single-precision_format"></a> <a class="anchor" id="description.ieee_754_single-precision_format"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>IEEE 754 Single-Precision Format: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code>float</code> is assumed to be <em>at</em> <em>least</em> 32 bits in size. The externalized byte representation of a 32-bit floating-point value is defined to conform to the IEEE single-precision format illustrated below. If the native representation of a 32-bit floating-point value does not match this format, a conversion process to and from this format is performed. This conversion may (of course) be lossy: <br/>
<br/>
<div class="fragment"><pre class="fragment">  sign bit    8-bit exponent        23-bit significand
     /       /                     /
    +-+--------+-----------------------+
    |s|e7....e0|m22..................m0|
    +-+--------+-----------------------+
    LSB                              MSB
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_round-trip_marshalling"></a> <a class="anchor" id="usage.example_1~3A_round-trip_marshalling"></a> <a class="anchor" id="description.usage.example_1~3A_round-trip_marshalling"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Round-Trip Marshalling: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="structbslx_1_1MarshallingUtil.html">bslx::MarshallingUtil</a></code> component can be used stand-alone to marshal a platform-neutral representation of fundamental data and arrays of fundamental data to and from a buffer. In this example, the round-trip marshalling of an <code>int</code> and an array of <code>int</code> values will be demonstrated. First, declare the buffer and the data to be marshalled: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">char</span> buffer[32];
  <span class="keywordtype">int</span>  value = 17;
  <span class="keywordtype">int</span>  values[] = { 1, 2, 3 };
</pre></div><br/>
<br/>
 Then, marshal all data into the <code>buffer</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbslx_1_1MarshallingUtil.html#a2679531dc11461725b20ebdee1772dac">bslx::MarshallingUtil::putInt32</a>(buffer + 0, value);
  <a class="code" href="structbslx_1_1MarshallingUtil.html#a487e82891e43cd9aa7368db1e4a8490e">bslx::MarshallingUtil::putArrayInt32</a>(buffer + 4, values, 3);
</pre></div><br/>
<br/>
 Next, declare variables to hold the values to be extracted from the <code>buffer</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> newValue = 0;
  <span class="keywordtype">int</span> newValues[] = { 0, 0, 0 };
</pre></div><br/>
<br/>
 Finally, marshal the data from the <code>buffer</code> to these variables and confirm the round-trip marshalling was successful: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbslx_1_1MarshallingUtil.html#ad3ce04566d725f79a8e26c5c7a9a9f3c">bslx::MarshallingUtil::getInt32</a>(&amp;newValue, buffer + 0);
  <a class="code" href="structbslx_1_1MarshallingUtil.html#a75cfdf72ffeddca1fe5e3cd073b4070a">bslx::MarshallingUtil::getArrayInt32</a>(newValues, buffer + 4, 3);

  assert(newValue     == value);
  assert(newValues[0] == values[0]);
  assert(newValues[1] == values[1]);
  assert(newValues[2] == values[2]);
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:01 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
