<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlb_bigendian.h                                                   -*-C++-*-
#ifndef INCLUDED_BDLB_BIGENDIAN
#define INCLUDED_BDLB_BIGENDIAN

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide big-endian integer types.
//
//@CLASSES:
//  bdlb::BigEndianInt16:  signed 16-bit in-core big-endian integer
//  bdlb::BigEndianUint16: unsigned 16-bit in-core big-endian integer
//  bdlb::BigEndianInt32:  signed 32-bit in-core big-endian integer
//  bdlb::BigEndianUint32: unsigned 32-bit in-core big-endian integer
//  bdlb::BigEndianInt64:  signed 64-bit in-core big-endian integer
//  bdlb::BigEndianUint64: unsigned 64-bit in-core big-endian integer
//
//@SEE_ALSO: bsls_types
//
//@DESCRIPTION: This component provides generic in-core big-endian integer
// types &#39;bdlb::BigEndianInt16&#39;, &#39;bdlb::BigEndianUint16&#39;,
// &#39;bdlb::BigEndianInt32&#39;, &#39;bdlb::BigEndianUint32&#39;, &#39;bdlb::BigEndianInt64&#39; and
// &#39;bdlb::BigEndianUint64&#39; that store integral values that they represent in a
// big-endian byte order.  For example, an integer value 0x01020304 will be
// internally stored by the &#39;bdlb::BigEndianInt32&#39; object as 0x04030201 on
// little-endian platforms.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
/// Example 1: Basic Use of &#39;bdlb::BigEndian&#39;
/// - - - - - - - - - - - - - - - - - - - - -
// This example demonstrates using &#39;bdlb::BigEndian&#39; types to represent a
// structure meant to be exchanged over the network ( which historically uses
// big-endian byte order ) or stored in-core as big-endian integers.  First, we
// define the structure:
//..
//  struct ProtocolHeader {
//      // This structure represents the header of the protocol.  All integer
//      // values are stored in the network byte-order (i.e., big-endian).
//
//      bdlb::BigEndianUint16 d_protocolVersion;
//      bdlb::BigEndianUint16 d_messageType;
//      bdlb::BigEndianUint32 d_messageLength;
//  };
//..
// Next, we prepare in-memory representation of the protocol header with
// protocol version set to &#39;0x1&#39;, message type set to &#39;0x02&#39; and message length
// set to &#39;0x1234&#39; in the big-endian byte order (most significant bytes first):
//..
//  const char buffer[8] = { 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x12, 0x34 };
//..
// Now, we create an instance of the &#39;ProtocolHeader&#39; structure and emulate
// packet reception over the network:
//..
//  struct ProtocolHeader header;
//  assert(8 == sizeof(header));
//  memcpy(static_cast&lt;void*&gt;(&amp;header), buffer, 8);
//..
// Next, we verify that actual in-core values depend on the endianess of the
// underlying platform:
//..
//  #ifdef BSLS_PLATFORM_IS_LITTLE_ENDIAN
//  assert(0x0100 ==
//         static_cast&lt;short&gt;(*(reinterpret_cast&lt;unsigned short*&gt;(
//                                               &amp;header.d_protocolVersion))));
//
//  assert(0x0200 ==
//         static_cast&lt;short&gt;(*(reinterpret_cast&lt;unsigned short*&gt;(
//                                               &amp;header.d_messageType))));
//
//  assert(0x34120000 == *(reinterpret_cast&lt;unsigned int*&gt;(
//                                               &amp;header.d_messageLength)));
//  #endif // BSLS_PLATFORM_IS_LITTLE_ENDIAN
//
//  #ifdef BSLS_PLATFORM_IS_BIG_ENDIAN
//  assert(0x01 ==
//         static_cast&lt;short&gt;(*(reinterpret_cast&lt;unsigned short*&gt;(
//                                               &amp;header.d_protocolVersion))));
//
//  assert(0x02 ==
//         static_cast&lt;short&gt;(*(reinterpret_cast&lt;unsigned short*&gt;(
//                                               &amp;header.d_messageType))));
//
//  assert(0x1234 == *(reinterpret_cast&lt;unsigned int*&gt;(
//                                               &amp;header.d_messageLength)));
//  #endif // BSLS_PLATFORM_IS_BIG_ENDIAN
//..
// Finally, we verify that the received protocol header can be validated on
// platforms of any endianess:
//..
//  assert(0x01   == header.d_protocolVersion);
//  assert(0x02   == header.d_messageType);
//  assert(0x1234 == header.d_messageLength);
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLB_PRINTMETHODS
#include &lt;bdlb_printmethods.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYCOPYABLE
#include &lt;bslmf_istriviallycopyable.h&gt;
#endif

#ifndef INCLUDED_BSLS_BYTEORDER
#include &lt;bsls_byteorder.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

namespace BloombergLP {
namespace bdlb {

                         // ====================
                         // class BigEndianInt16
                         // ====================

class BigEndianInt16 {
    // This class provides a container for an in-core representation of a
    // signed 16-bit big-endian integer.  It supports a complete set of *value*
    // *semantic* operations, including copy construction, assignment, equality
    // comparison, &#39;bsl::ostream&#39; printing, and BDEX serialization.  Note that
    // the copy constructor and copy-assignment operator are provided by the
    // compiler.  Any object of this class can be converted to a &#39;short&#39;
    // allowing comparison with any other object of this class.  This class is
    // *exception* *neutral* with no guarantee of rollback: if an exception is
    // thrown during the invocation of a method on a pre-existing object, the
    // object is left in a valid state, but its value is undefined.  In no
    // event is memory leaked.  Finally, *aliasing* (e.g., using all or part of
    // an object as both source and destination) is supported in all cases.

    // DATA
    short d_value;  // in-core value (network byte-order)

    // FRIENDS
    friend bool operator==(const BigEndianInt16&amp; lhs,
                           const BigEndianInt16&amp; rhs);
    friend bool operator!=(const BigEndianInt16&amp; lhs,
                           const BigEndianInt16&amp; rhs);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(BigEndianInt16, bsl::is_trivially_copyable);
    BSLMF_NESTED_TRAIT_DECLARATION(BigEndianInt16, bdlb::HasPrintMethod);

    // CLASS METHODS
    static BigEndianInt16 make(short value);
        // Create and initialize a &#39;BigEndianInt16&#39; object that stores the
        // specified &#39;value&#39; as a signed 16-bit big-endian integer.


    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that the &#39;versionSelector&#39; is expected to be formatted
        // as &#39;yyyymmdd&#39;, a date representation.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // CREATORS
    //! BigEndianInt16() = default;
    //! BigEndianInt16(const BigEndianInt16&amp; other) = default;
    //! ~BigEndianInt16() = default;

    // MANIPULATORS
    //! BigEndianInt16&amp; operator=(const BigEndianInt16&amp; other) = default;

    BigEndianInt16&amp; operator=(short value);
        // Store in this object the specified &#39;value&#39; as a signed 16-bit
        // big-endian integer, and return a reference to this modifiable
        // object.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // ACCESSORS
    operator short() const;
        // Return the value stored in this object as a &#39;short&#39; in the native
        // byte-order.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the (absolute
        // value of) the optionally specified indentation &#39;level&#39; and return a
        // reference to &#39;stream&#39;.  If &#39;level&#39; is specified, optionally specify
        // &#39;spacesPerLevel&#39;, the number of spaces per indentation level for
        // this and all of its nested objects.  If &#39;level&#39; is negative,
        // suppress indentation of the first line.  If &#39;spacesPerLevel&#39; is
        // negative, format the entire output on one line, suppressing all but
        // the initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is
        // not valid on entry, this operation has no effect.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write this value to the specified output &#39;stream&#39; using the
        // specified &#39;version&#39; format, and return a reference to &#39;stream&#39;.  If
        // &#39;stream&#39; is initially invalid, this operation has no effect.  If
        // &#39;version&#39; is not supported, &#39;stream&#39; is invalidated but otherwise
        // unmodified.  Note that &#39;version&#39; is not written to &#39;stream&#39;.  See
        // the &#39;bslx&#39; package-level documentation for more information on BDEX
        // streaming of value-semantic types and containers.
};

// FREE OPERATORS
bool operator==(const BigEndianInt16&amp; lhs, const BigEndianInt16&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; &#39;BigEndianInt16&#39; objects
    // have the same value, and &#39;false&#39; otherwise.  Two &#39;BigEndianInt16&#39;
    // objects have the same value if and only if the respective integral
    // network byte-order values that they represent have the same value.

bool operator!=(const BigEndianInt16&amp; lhs, const BigEndianInt16&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; &#39;BigEndianInt16&#39; objects
    // do not have the same value, and &#39;false&#39; otherwise.  Two &#39;BigEndianInt16&#39;
    // objects do not have the same value if and only if the respective
    // integral network byte-order values that they represent do not have the
    // same value.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;         stream,
                         const BigEndianInt16&amp; integer);
    // Write the specified &#39;integer&#39; to the specified output &#39;stream&#39; and
    // return a reference to the modifiable &#39;stream&#39;.

                         // =====================
                         // class BigEndianUint16
                         // =====================

class BigEndianUint16 {
    // This class provides a container for an in-core representation of an
    // unsigned 16-bit big-endian integer.  It supports a complete set of
    // *value* *semantic* operations, including copy construction, assignment,
    // equality comparison, &#39;bsl::ostream&#39; printing, and BDEX serialization.
    // Note that the copy constructor and copy-assignment operator are provided
    // by the compiler.  Any object of this class can be converted to an
    // &#39;unsigned short&#39; allowing comparison with any other object of this
    // class.  This class is *exception* *neutral* with no guarantee of
    // rollback: if an exception is thrown during the invocation of a method on
    // a pre-existing object, the object is left in a valid state, but its
    // value is undefined.  In no event is memory leaked.  Finally, *aliasing*
    // (e.g., using all or part of an object as both source and destination) is
    // supported in all cases.

    // DATA
    unsigned short d_value;  // in-core value (network byte-order)

    // FRIENDS
    friend bool operator==(const BigEndianUint16&amp; lhs,
                           const BigEndianUint16&amp; rhs);
    friend bool operator!=(const BigEndianUint16&amp; lhs,
                           const BigEndianUint16&amp; rhs);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(BigEndianUint16,
                                   bsl::is_trivially_copyable);
    BSLMF_NESTED_TRAIT_DECLARATION(BigEndianUint16, bdlb::HasPrintMethod);

    // CLASS METHODS
    static BigEndianUint16 make(unsigned short value);
        // Create and initialize a &#39;BigEndianUint16&#39; object that stores the
        // specified &#39;value&#39; as a unsigned 16-bit big-endian integer.


    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that the &#39;versionSelector&#39; is expected to be formatted
        // as &#39;yyyymmdd&#39;, a date representation.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // CREATORS
    //! BigEndianUint16() = default;
    //! BigEndianUint16(const BigEndianUint16&amp; other) = default;
    //! ~BigEndianUint16() = default;

    // MANIPULATORS
    //! BigEndianUint16&amp; operator=(const BigEndianUint16&amp; other) = default;

    BigEndianUint16&amp; operator=(unsigned short value);
        // Store in this object the specified &#39;value&#39; as an unsigned 16-bit
        // big-endian integer, and return a reference to this modifiable
        // object.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // ACCESSORS
    operator unsigned short() const;
        // Return the value stored in this object as a &#39;unsigned short&#39; in the
        // native byte-order.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the (absolute
        // value of) the optionally specified indentation &#39;level&#39; and return a
        // reference to &#39;stream&#39;.  If &#39;level&#39; is specified, optionally specify
        // &#39;spacesPerLevel&#39;, the number of spaces per indentation level for
        // this and all of its nested objects.  If &#39;level&#39; is negative,
        // suppress indentation of the first line.  If &#39;spacesPerLevel&#39; is
        // negative, format the entire output on one line, suppressing all but
        // the initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is
        // not valid on entry, this operation has no effect.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write this value to the specified output &#39;stream&#39; using the
        // specified &#39;version&#39; format, and return a reference to &#39;stream&#39;.  If
        // &#39;stream&#39; is initially invalid, this operation has no effect.  If
        // &#39;version&#39; is not supported, &#39;stream&#39; is invalidated but otherwise
        // unmodified.  Note that &#39;version&#39; is not written to &#39;stream&#39;.  See
        // the &#39;bslx&#39; package-level documentation for more information on BDEX
        // streaming of value-semantic types and containers.
};

// FREE OPERATORS
bool operator==(const BigEndianUint16&amp; lhs, const BigEndianUint16&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; &#39;BigEndianUint16&#39; objects
    // have the same value, and &#39;false&#39; otherwise.  Two &#39;BigEndianUint16&#39;
    // objects have the same value if and only if the respective integral
    // network byte-order values that they represent have the same value.

bool operator!=(const BigEndianUint16&amp; lhs, const BigEndianUint16&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; &#39;BigEndianUint16&#39; objects
    // do not have the same value, and &#39;false&#39; otherwise.  Two
    // &#39;BigEndianUint16&#39; objects do not have the same value if and only if the
    // respective integral network byte-order values that they represent do not
    // have the same value.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;          stream,
                         const BigEndianUint16&amp; integer);
    // Write the specified &#39;integer&#39; to the specified output &#39;stream&#39;, and
    // return a reference to the modifiable &#39;stream&#39;.

                         // ====================
                         // class BigEndianInt32
                         // ====================

class BigEndianInt32 {
    // This class provides a container for an in-core representation of a
    // signed 32-bit big-endian integer.  It supports a complete set of *value*
    // *semantic* operations, including copy construction, assignment, equality
    // comparison, &#39;bsl::ostream&#39; printing, and BDEX serialization.  Note that
    // the copy constructor and copy-assignment operator are provided by the
    // compiler.  Any object of this class can be converted to an &#39;int&#39;
    // allowing comparison with any other object of this class.  This class is
    // *exception* *neutral* with no guarantee of rollback: if an exception is
    // thrown during the invocation of a method on a pre-existing object, the
    // object is left in a valid state, but its value is undefined.  In no
    // event is memory leaked.  Finally, *aliasing* (e.g., using all or part of
    // an object as both source and destination) is supported in all cases.

    // DATA
    int d_value;  // in-core value (network byte-order)

    // FRIENDS
    friend bool operator==(const BigEndianInt32&amp; lhs,
                           const BigEndianInt32&amp; rhs);
    friend bool operator!=(const BigEndianInt32&amp; lhs,
                           const BigEndianInt32&amp; rhs);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(BigEndianInt32, bsl::is_trivially_copyable);
    BSLMF_NESTED_TRAIT_DECLARATION(BigEndianInt32, bdlb::HasPrintMethod);

    // CLASS METHODS
    static BigEndianInt32 make(int value);
        // Create and initialize a &#39;BigEndianInt32&#39; object that stores the
        // specified &#39;value&#39; as a signed 32-bit big-endian integer.


    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that the &#39;versionSelector&#39; is expected to be formatted
        // as &#39;yyyymmdd&#39;, a date representation.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // CREATORS
    //! BigEndianInt32() = default;
    //! BigEndianInt32(const BigEndianInt32&amp; other) = default;
    //! ~BigEndianInt32() = default;

    // MANIPULATORS
    //! BigEndianInt32&amp; operator=(const BigEndianInt32&amp; other) = default;

    BigEndianInt32&amp; operator=(int value);
        // Store in this object the specified &#39;value&#39; as a signed 32-bit
        // big-endian integer, and return a reference to this modifiable
        // object.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // ACCESSORS
    operator int() const;
        // Return the value stored in this object as a &#39;int&#39; in the native
        // byte-order.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the (absolute
        // value of) the optionally specified indentation &#39;level&#39; and return a
        // reference to &#39;stream&#39;.  If &#39;level&#39; is specified, optionally specify
        // &#39;spacesPerLevel&#39;, the number of spaces per indentation level for
        // this and all of its nested objects.  If &#39;level&#39; is negative,
        // suppress indentation of the first line.  If &#39;spacesPerLevel&#39; is
        // negative, format the entire output on one line, suppressing all but
        // the initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is
        // not valid on entry, this operation has no effect.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write this value to the specified output &#39;stream&#39; using the
        // specified &#39;version&#39; format, and return a reference to &#39;stream&#39;.  If
        // &#39;stream&#39; is initially invalid, this operation has no effect.  If
        // &#39;version&#39; is not supported, &#39;stream&#39; is invalidated but otherwise
        // unmodified.  Note that &#39;version&#39; is not written to &#39;stream&#39;.  See
        // the &#39;bslx&#39; package-level documentation for more information on BDEX
        // streaming of value-semantic types and containers.
};

// FREE OPERATORS
bool operator==(const BigEndianInt32&amp; lhs, const BigEndianInt32&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; &#39;BigEndianInt32&#39; objects
    // have the same value, and &#39;false&#39; otherwise.  Two &#39;BigEndianInt32&#39;
    // objects have the same value if and only if the respective integral
    // network byte-order values that they represent have the same value.

bool operator!=(const BigEndianInt32&amp; lhs, const BigEndianInt32&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; &#39;BigEndianInt32&#39; objects
    // do not have the same value, and &#39;false&#39; otherwise.  Two &#39;BigEndianInt32&#39;
    // objects do not have the same value if and only if the respective
    // integral network byte-order values that they represent do not have the
    // same value.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;         stream,
                         const BigEndianInt32&amp; integer);
    // Write the specified &#39;integer&#39; to the specified output &#39;stream&#39;, and
    // return a reference to the modifiable &#39;stream&#39;.

                         // =====================
                         // class BigEndianUint32
                         // =====================

class BigEndianUint32 {
    // This class provides a container for an in-core representation of an
    // unsigned 32-bit big-endian integer.  It supports a complete set of
    // *value* *semantic* operations, including copy construction, assignment,
    // equality comparison, &#39;bsl::ostream&#39; printing, and BDEX serialization.
    // Note that the copy constructor and copy-assignment operator are provided
    // by the compiler.  Any object of this class can be converted to an
    // &#39;unsigned int&#39; allowing comparison with any other object of this class.
    // This class is *exception* *neutral* with no guarantee of rollback: if an
    // exception is thrown during the invocation of a method on a pre-existing
    // object, the object is left in a valid state, but its value is undefined.
    // In no event is memory leaked.  Finally, *aliasing* (e.g., using all or
    // part of an object as both source and destination) is supported in all
    // cases.

    // DATA
    unsigned int d_value;  // in-core value (network byte-order)

    // FRIENDS
    friend bool operator==(const BigEndianUint32&amp; lhs,
                           const BigEndianUint32&amp; rhs);
    friend bool operator!=(const BigEndianUint32&amp; lhs,
                           const BigEndianUint32&amp; rhs);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(BigEndianUint32,
                                   bsl::is_trivially_copyable);
    BSLMF_NESTED_TRAIT_DECLARATION(BigEndianUint32, bdlb::HasPrintMethod);

    // CLASS METHODS
    static BigEndianUint32 make(unsigned int value);
        // Create and initialize a &#39;BigEndianUint32&#39; object that stores the
        // specified &#39;value&#39; as a unsigned 32-bit big-endian integer.


    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that the &#39;versionSelector&#39; is expected to be formatted
        // as &#39;yyyymmdd&#39;, a date representation.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // CREATORS
    //! BigEndianUint32() = default;
    //! BigEndianUint32(const BigEndianUint32&amp; other) = default;
    //! ~BigEndianUint32() = default;

    // MANIPULATORS
    //! BigEndianUint32&amp; operator=(const BigEndianUint32&amp; other) = default;

    BigEndianUint32&amp; operator=(unsigned int value);
        // Store in this object the specified &#39;value&#39; as an unsigned 32-bit
        // big-endian integer, and return a reference to this modifiable
        // object.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // ACCESSORS
    operator unsigned int() const;
        // Return the value stored in this object as a &#39;unsigned int&#39; in the
        // native byte-order.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the (absolute
        // value of) the optionally specified indentation &#39;level&#39; and return a
        // reference to &#39;stream&#39;.  If &#39;level&#39; is specified, optionally specify
        // &#39;spacesPerLevel&#39;, the number of spaces per indentation level for
        // this and all of its nested objects.  If &#39;level&#39; is negative,
        // suppress indentation of the first line.  If &#39;spacesPerLevel&#39; is
        // negative, format the entire output on one line, suppressing all but
        // the initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is
        // not valid on entry, this operation has no effect.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write this value to the specified output &#39;stream&#39; using the
        // specified &#39;version&#39; format, and return a reference to &#39;stream&#39;.  If
        // &#39;stream&#39; is initially invalid, this operation has no effect.  If
        // &#39;version&#39; is not supported, &#39;stream&#39; is invalidated but otherwise
        // unmodified.  Note that &#39;version&#39; is not written to &#39;stream&#39;.  See
        // the &#39;bslx&#39; package-level documentation for more information on BDEX
        // streaming of value-semantic types and containers.
};

// FREE OPERATORS
bool operator==(const BigEndianUint32&amp; lhs, const BigEndianUint32&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; &#39;BigEndianUint32&#39; objects
    // have the same value, and &#39;false&#39; otherwise.  Two &#39;BigEndianUint32&#39;
    // objects have the same value if and only if the respective integral
    // network byte-order values that they represent have the same value.

bool operator!=(const BigEndianUint32&amp; lhs, const BigEndianUint32&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; &#39;BigEndianUint32&#39; objects
    // do not have the same value, and &#39;false&#39; otherwise.  Two
    // &#39;BigEndianUint32&#39; objects do not have the same value if and only if the
    // respective integral network byte-order values that they represent do not
    // have the same value.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;          stream,
                         const BigEndianUint32&amp; integer);
    // Write the specified &#39;integer&#39; to the specified output &#39;stream&#39;, and
    // return a reference to the modifiable &#39;stream&#39;.

                         // ====================
                         // class BigEndianInt64
                         // ====================

class BigEndianInt64 {
    // This class provides a container for an in-core representation of a
    // signed 64-bit big-endian integer.  It supports a complete set of *value*
    // *semantic* operations, including copy construction, assignment, equality
    // comparison, &#39;bsl::ostream&#39; printing, and BDEX serialization.  Note that
    // the copy constructor and copy-assignment operator are provided by the
    // compiler.  Any object of this class can be converted to an &#39;Int64&#39;
    // allowing comparison with any other object of this class.  This class is
    // *exception* *neutral* with no guarantee of rollback: if an exception is
    // thrown during the invocation of a method on a pre-existing object, the
    // object is left in a valid state, but its value is undefined.  In no
    // event is memory leaked.  Finally, *aliasing* (e.g., using all or part of
    // an object as both source and destination) is supported in all cases.

    // DATA
    bsls::Types::Int64 d_value;  // in-core value (network byte-order)

    // FRIENDS
    friend bool operator==(const BigEndianInt64&amp; lhs,
                           const BigEndianInt64&amp; rhs);
    friend bool operator!=(const BigEndianInt64&amp; lhs,
                           const BigEndianInt64&amp; rhs);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(BigEndianInt64, bsl::is_trivially_copyable);
    BSLMF_NESTED_TRAIT_DECLARATION(BigEndianInt64, bdlb::HasPrintMethod);

    // CLASS METHODS
    static BigEndianInt64 make(bsls::Types::Int64 value);
        // Create and initialize a &#39;BigEndianInt64&#39; object that stores the
        // specified &#39;value&#39; as a signed 64-bit big-endian integer.


    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that the &#39;versionSelector&#39; is expected to be formatted
        // as &#39;yyyymmdd&#39;, a date representation.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // CREATORS
    //! BigEndianInt64() = default;
    //! BigEndianInt64(const BigEndianInt64&amp; other) = default;
    //! ~BigEndianInt64() = default;

    // MANIPULATORS
    //! BigEndianInt64&amp; operator=(const BigEndianInt64&amp; other) = default;

    BigEndianInt64&amp; operator=(bsls::Types::Int64 value);
        // Store in this object the specified &#39;value&#39; as a signed 64-bit
        // big-endian integer, and return a reference to this modifiable
        // object.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // ACCESSORS
    operator bsls::Types::Int64() const;
        // Return the value stored in this object as a &#39;bsls::Types::Int64&#39; in
        // the native byte-order.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the (absolute
        // value of) the optionally specified indentation &#39;level&#39; and return a
        // reference to &#39;stream&#39;.  If &#39;level&#39; is specified, optionally specify
        // &#39;spacesPerLevel&#39;, the number of spaces per indentation level for
        // this and all of its nested objects.  If &#39;level&#39; is negative,
        // suppress indentation of the first line.  If &#39;spacesPerLevel&#39; is
        // negative, format the entire output on one line, suppressing all but
        // the initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is
        // not valid on entry, this operation has no effect.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write this value to the specified output &#39;stream&#39; using the
        // specified &#39;version&#39; format, and return a reference to &#39;stream&#39;.  If
        // &#39;stream&#39; is initially invalid, this operation has no effect.  If
        // &#39;version&#39; is not supported, &#39;stream&#39; is invalidated but otherwise
        // unmodified.  Note that &#39;version&#39; is not written to &#39;stream&#39;.  See
        // the &#39;bslx&#39; package-level documentation for more information on BDEX
        // streaming of value-semantic types and containers.
};

// FREE OPERATORS
bool operator==(const BigEndianInt64&amp; lhs, const BigEndianInt64&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; &#39;BigEndianInt64&#39; objects
    // have the same value, and &#39;false&#39; otherwise.  Two &#39;BigEndianInt64&#39;
    // objects have the same value if and only if the respective integral
    // network byte-order values that they represent have the same value.

bool operator!=(const BigEndianInt64&amp; lhs, const BigEndianInt64&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; &#39;BigEndianInt64&#39; objects
    // do not have the same value, and &#39;false&#39; otherwise.  Two &#39;BigEndianInt64&#39;
    // objects do not have the same value if and only if the respective
    // integral network byte-order values that they represent do not have the
    // same value.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;         stream,
                         const BigEndianInt64&amp; integer);
    // Write the specified &#39;integer&#39; to the specified output &#39;stream&#39;, and
    // return a reference to the modifiable &#39;stream&#39;.

                         // =====================
                         // class BigEndianUint64
                         // =====================

class BigEndianUint64 {
    // This class provides a container for an in-core representation of an
    // unsigned 64-bit big-endian integer.  It supports a complete set of
    // *value* *semantic* operations, including copy construction, assignment,
    // equality comparison, &#39;bsl::ostream&#39; printing, and BDEX serialization.
    // Note that the copy constructor and copy-assignment operator are provided
    // by the compiler.  Any object of this class can be converted to a
    // &#39;Uint64&#39; allowing comparison with any other object of this class.  This
    // class is *exception* *neutral* with no guarantee of rollback: if an
    // exception is thrown during the invocation of a method on a pre-existing
    // object, the object is left in a valid state, but its value is undefined.
    // In no event is memory leaked.  Finally, *aliasing* (e.g., using all or
    // part of an object as both source and destination) is supported in all
    // cases.

    // DATA
    bsls::Types::Uint64 d_value;  // in-core value (network byte-order)

    // FRIENDS
    friend bool operator==(const BigEndianUint64&amp; lhs,
                           const BigEndianUint64&amp; rhs);
    friend bool operator!=(const BigEndianUint64&amp; lhs,
                           const BigEndianUint64&amp; rhs);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(BigEndianUint64,
                                   bsl::is_trivially_copyable);
    BSLMF_NESTED_TRAIT_DECLARATION(BigEndianUint64, bdlb::HasPrintMethod);

    // CLASS METHODS
    static BigEndianUint64 make(bsls::Types::Uint64 value);
        // Create and initialize a &#39;BigEndianInt64&#39; object that stores the
        // specified &#39;value&#39; as an unsigned 64-bit big-endian integer.


    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that the &#39;versionSelector&#39; is expected to be formatted
        // as &#39;yyyymmdd&#39;, a date representation.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // CREATORS
    //! BigEndianUint64() = default;
    //! BigEndianUint64(const BigEndianUint64&amp; other) = default;
    //! ~BigEndianUint64() = default;

    // MANIPULATORS
    //! BigEndianUint64&amp; operator=(const BigEndianUint64&amp; other) = default;

    BigEndianUint64&amp; operator=(bsls::Types::Uint64 value);
        // Store in this object the specified &#39;value&#39; as an unsigned 64-bit
        // big-endian integer, and return a reference to this modifiable
        // object.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // ACCESSORS
    operator bsls::Types::Uint64() const;
        // Return the value stored in this object as a &#39;bsls::Types::Uint64&#39; in
        // the native byte-order.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the (absolute
        // value of) the optionally specified indentation &#39;level&#39; and return a
        // reference to &#39;stream&#39;.  If &#39;level&#39; is specified, optionally specify
        // &#39;spacesPerLevel&#39;, the number of spaces per indentation level for
        // this and all of its nested objects.  If &#39;level&#39; is negative,
        // suppress indentation of the first line.  If &#39;spacesPerLevel&#39; is
        // negative, format the entire output on one line, suppressing all but
        // the initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is
        // not valid on entry, this operation has no effect.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write this value to the specified output &#39;stream&#39; using the
        // specified &#39;version&#39; format, and return a reference to &#39;stream&#39;.  If
        // &#39;stream&#39; is initially invalid, this operation has no effect.  If
        // &#39;version&#39; is not supported, &#39;stream&#39; is invalidated but otherwise
        // unmodified.  Note that &#39;version&#39; is not written to &#39;stream&#39;.  See
        // the &#39;bslx&#39; package-level documentation for more information on BDEX
        // streaming of value-semantic types and containers.
};

// FREE OPERATORS
bool operator==(const BigEndianUint64&amp; lhs, const BigEndianUint64&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; &#39;BigEndianUint64&#39; objects
    // have the same value, and &#39;false&#39; otherwise.  Two &#39;BigEndianUint64&#39;
    // objects have the same value if and only if the respective integral
    // network byte-order values that they represent have the same value.

bool operator!=(const BigEndianUint64&amp; lhs, const BigEndianUint64&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; &#39;BigEndianUint64&#39; objects
    // do not have the same value, and &#39;false&#39; otherwise.  Two
    // &#39;BigEndianUint64&#39; objects do not have the same value if and only if the
    // respective integral network byte-order values that they represent do not
    // have the same value.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const BigEndianUint64&amp; integer);
    // Write the specified &#39;integer&#39; to the specified output &#39;stream&#39;, and
    // return a reference to the modifiable &#39;stream&#39;.

// ============================================================================
//                               INLINE DEFINITIONS
// ============================================================================

                         // --------------------
                         // class BigEndianInt16
                         // --------------------

// CLASS METHODS
inline
BigEndianInt16 BigEndianInt16::make(short value)
{
    BigEndianInt16 ret;
    return ret = value;
}


inline
int BigEndianInt16::maxSupportedBdexVersion(int /* versionSelector */)
{
    return 1;
}

// MANIPULATORS
inline
BigEndianInt16&amp; BigEndianInt16::operator=(short value)
{
    d_value = BSLS_BYTEORDER_HOST_U16_TO_BE(value);
    return *this;
}

template &lt;class STREAM&gt;
STREAM&amp; BigEndianInt16::bdexStreamIn(STREAM&amp; stream, int version)
{
    if (stream) {
        switch (version) {
          case 1: {
            stream.getArrayUint8(reinterpret_cast&lt;unsigned char *&gt;(&amp;d_value),
                                 sizeof d_value);
          } break;
          default: {
            stream.invalidate();
          }
        }
    }
    return stream;
}
}  // close package namespace

// ACCESSORS
inline
bdlb::BigEndianInt16::operator short() const
{
    return BSLS_BYTEORDER_BE_U16_TO_HOST(d_value);
}

namespace bdlb {
template &lt;class STREAM&gt;
STREAM&amp; BigEndianInt16::bdexStreamOut(STREAM&amp; stream, int version) const
{
    switch (version) {
      case 1: {
        stream.putArrayUint8(reinterpret_cast&lt;const unsigned char *&gt;(&amp;d_value),
                             sizeof d_value);
      } break;
      default: {
        stream.invalidate();
      }
    }
    return stream;
}
}  // close package namespace

// FREE OPERATORS
inline
bool bdlb::operator==(const BigEndianInt16&amp; lhs, const BigEndianInt16&amp; rhs)
{
    return lhs.d_value == rhs.d_value;
}

inline
bool bdlb::operator!=(const BigEndianInt16&amp; lhs, const BigEndianInt16&amp; rhs)
{
    return lhs.d_value != rhs.d_value;
}

inline
bsl::ostream&amp; bdlb::operator&lt;&lt;(bsl::ostream&amp;         stream,
                               const BigEndianInt16&amp; integer)
{
    integer.print(stream, 0, -1);
    return stream;
}

namespace bdlb {
                         // ---------------------
                         // class BigEndianUint16
                         // ---------------------

// CLASS METHODS
inline
BigEndianUint16 BigEndianUint16::make(unsigned short value)
{
    BigEndianUint16 ret;
    return ret = value;
}


inline
int BigEndianUint16::maxSupportedBdexVersion(int /* versionSelector */)
{
    return 1;
}

// MANIPULATORS
inline
BigEndianUint16&amp; BigEndianUint16::operator=(unsigned short value)
{
    d_value = BSLS_BYTEORDER_HOST_U16_TO_BE(value);
    return *this;
}

template &lt;class STREAM&gt;
STREAM&amp; BigEndianUint16::bdexStreamIn(STREAM&amp; stream, int version)
{
    if (stream) {
        switch (version) {
          case 1: {
            stream.getArrayUint8(reinterpret_cast&lt;unsigned char *&gt;(&amp;d_value),
                                 sizeof d_value);
          } break;
          default: {
            stream.invalidate();
          }
        }
    }
    return stream;
}
}  // close package namespace

// ACCESSORS
inline
bdlb::BigEndianUint16::operator unsigned short() const
{
    return BSLS_BYTEORDER_BE_U16_TO_HOST(d_value);
}

namespace bdlb {
template &lt;class STREAM&gt;
STREAM&amp; BigEndianUint16::bdexStreamOut(STREAM&amp; stream, int version) const
{
    switch (version) {
      case 1: {
        stream.putArrayUint8(reinterpret_cast&lt;const unsigned char *&gt;(&amp;d_value),
                             sizeof d_value);
      } break;
      default: {
        stream.invalidate();
      }
    }
    return stream;
}
}  // close package namespace

// FREE OPERATORS
inline
bool bdlb::operator==(const BigEndianUint16&amp; lhs, const BigEndianUint16&amp; rhs)
{
    return lhs.d_value == rhs.d_value;
}

inline
bool bdlb::operator!=(const BigEndianUint16&amp; lhs, const BigEndianUint16&amp; rhs)
{
    return lhs.d_value != rhs.d_value;
}

inline
bsl::ostream&amp; bdlb::operator&lt;&lt;(bsl::ostream&amp;          stream,
                               const BigEndianUint16&amp; integer)
{
    integer.print(stream, 0, -1);
    return stream;
}

namespace bdlb {
                         // --------------------
                         // class BigEndianInt32
                         // --------------------

// CLASS METHODS
inline
BigEndianInt32 BigEndianInt32::make(int value)
{
    BigEndianInt32 ret;
    return ret = value;
}


inline
int BigEndianInt32::maxSupportedBdexVersion(int /* versionSelector */)
{
    return 1;
}

// MANIPULATORS
inline
BigEndianInt32&amp; BigEndianInt32::operator=(int value)
{
    d_value = BSLS_BYTEORDER_HOST_U32_TO_BE(value);
    return *this;
}

template &lt;class STREAM&gt;
STREAM&amp; BigEndianInt32::bdexStreamIn(STREAM&amp; stream, int version)
{
    switch (version) {
      case 1: {
        stream.getArrayUint8(reinterpret_cast&lt;unsigned char *&gt;(&amp;d_value),
                             sizeof d_value);
      } break;
      default: {
        stream.invalidate();
      }
    }
    return stream;
}
}  // close package namespace

// ACCESSORS
inline
bdlb::BigEndianInt32::operator int() const
{
    return BSLS_BYTEORDER_BE_U32_TO_HOST(d_value);
}

namespace bdlb {
template &lt;class STREAM&gt;
STREAM&amp; BigEndianInt32::bdexStreamOut(STREAM&amp; stream, int version) const
{
    switch (version) {
      case 1: {
        stream.putArrayUint8(reinterpret_cast&lt;const unsigned char *&gt;(&amp;d_value),
                             sizeof d_value);
      } break;
      default: {
        stream.invalidate();
      }
    }
    return stream;
}
}  // close package namespace

// FREE OPERATORS
inline
bool bdlb::operator==(const BigEndianInt32&amp; lhs, const BigEndianInt32&amp; rhs)
{
    return lhs.d_value == rhs.d_value;
}

inline
bool bdlb::operator!=(const BigEndianInt32&amp; lhs, const BigEndianInt32&amp; rhs)
{
    return lhs.d_value != rhs.d_value;
}

inline
bsl::ostream&amp; bdlb::operator&lt;&lt;(bsl::ostream&amp;         stream,
                               const BigEndianInt32&amp; integer)
{
    integer.print(stream, 0, -1);
    return stream;
}

namespace bdlb {
                         // ---------------------
                         // class BigEndianUint32
                         // ---------------------

// CLASS METHODS
inline
BigEndianUint32 BigEndianUint32::make(unsigned int value)
{
    BigEndianUint32 ret;
    return ret = value;
}


inline
int BigEndianUint32::maxSupportedBdexVersion(int /* versionSelector */)
{
    return 1;
}

// MANIPULATORS
inline
BigEndianUint32&amp; BigEndianUint32::operator=(unsigned int value)
{
    d_value = BSLS_BYTEORDER_HOST_U32_TO_BE(value);
    return *this;
}

template &lt;class STREAM&gt;
STREAM&amp; BigEndianUint32::bdexStreamIn(STREAM&amp; stream, int version)
{
    if (stream) {
        switch (version) {
          case 1: {
            stream.getArrayUint8(reinterpret_cast&lt;unsigned char *&gt;(&amp;d_value),
                                 sizeof d_value);
          } break;
          default: {
            stream.invalidate();
          }
        }
    }
    return stream;
}
}  // close package namespace

// ACCESSORS
inline
bdlb::BigEndianUint32::operator unsigned int() const
{
    return BSLS_BYTEORDER_BE_U32_TO_HOST(d_value);
}

namespace bdlb {
template &lt;class STREAM&gt;
STREAM&amp; BigEndianUint32::bdexStreamOut(STREAM&amp; stream, int version) const
{
    switch (version) {
      case 1: {
        stream.putArrayUint8(reinterpret_cast&lt;const unsigned char *&gt;(&amp;d_value),
                             sizeof d_value);
      } break;
      default: {
        stream.invalidate();
      }
    }
    return stream;
}
}  // close package namespace

// FREE OPERATORS
inline
bool bdlb::operator==(const BigEndianUint32&amp; lhs, const BigEndianUint32&amp; rhs)
{
    return lhs.d_value == rhs.d_value;
}

inline
bool bdlb::operator!=(const BigEndianUint32&amp; lhs, const BigEndianUint32&amp; rhs)
{
    return lhs.d_value != rhs.d_value;
}

inline
bsl::ostream&amp; bdlb::operator&lt;&lt;(bsl::ostream&amp;          stream,
                               const BigEndianUint32&amp; integer)
{
    integer.print(stream, 0, -1);
    return stream;
}

namespace bdlb {
                         // --------------------
                         // class BigEndianInt64
                         // --------------------

// CLASS METHODS
inline
BigEndianInt64 BigEndianInt64::make(bsls::Types::Int64 value)
{
    BigEndianInt64 ret;
    return ret = value;
}


inline
int BigEndianInt64::maxSupportedBdexVersion(int /* versionSelector */)
{
    return 1;
}

// MANIPULATORS
inline
BigEndianInt64&amp; BigEndianInt64::operator=(bsls::Types::Int64 value)
{
    d_value = BSLS_BYTEORDER_HOST_U64_TO_BE(value);
    return *this;
}

template &lt;class STREAM&gt;
STREAM&amp; BigEndianInt64::bdexStreamIn(STREAM&amp; stream, int version)
{
    switch (version) {
      case 1: {
        stream.getArrayUint8(reinterpret_cast&lt;unsigned char *&gt;(&amp;d_value),
                             sizeof d_value);
      } break;
      default: {
        stream.invalidate();
      }
    }
    return stream;
}
}  // close package namespace

// ACCESSORS
inline
bdlb::BigEndianInt64::operator bsls::Types::Int64() const
{
    return BSLS_BYTEORDER_BE_U64_TO_HOST(d_value);
}

namespace bdlb {
template &lt;class STREAM&gt;
STREAM&amp; BigEndianInt64::bdexStreamOut(STREAM&amp; stream, int version) const
{
    switch (version) {
      case 1: {
        stream.putArrayUint8(reinterpret_cast&lt;const unsigned char *&gt;(&amp;d_value),
                             sizeof d_value);
      } break;
      default: {
        stream.invalidate();
      }
    }
    return stream;
}
}  // close package namespace

// FREE OPERATORS
inline
bool bdlb::operator==(const BigEndianInt64&amp; lhs, const BigEndianInt64&amp; rhs)
{
    return lhs.d_value == rhs.d_value;
}

inline
bool bdlb::operator!=(const BigEndianInt64&amp; lhs, const BigEndianInt64&amp; rhs)
{
    return lhs.d_value != rhs.d_value;
}

inline
bsl::ostream&amp; bdlb::operator&lt;&lt;(bsl::ostream&amp;         stream,
                               const BigEndianInt64&amp; integer)
{
    integer.print(stream, 0, -1);
    return stream;
}

namespace bdlb {
                         // ---------------------
                         // class BigEndianUint64
                         // ---------------------

// CLASS METHODS
inline
BigEndianUint64 BigEndianUint64::make(bsls::Types::Uint64 value)
{
    BigEndianUint64 ret;
    return ret = value;
}


inline
int BigEndianUint64::maxSupportedBdexVersion(int /* versionSelector */)
{
    return 1;
}

// MANIPULATORS
inline
BigEndianUint64&amp; BigEndianUint64::operator=(bsls::Types::Uint64 value)
{
    d_value = BSLS_BYTEORDER_HOST_U64_TO_BE(value);
    return *this;
}

template &lt;class STREAM&gt;
STREAM&amp; BigEndianUint64::bdexStreamIn(STREAM&amp; stream, int version)
{
    switch (version) {
      case 1: {
        stream.getArrayUint8(reinterpret_cast&lt;unsigned char *&gt;(&amp;d_value),
                             sizeof d_value);
      } break;
      default: {
        stream.invalidate();
      }
    }
    return stream;
}
}  // close package namespace

// ACCESSORS
inline
bdlb::BigEndianUint64::operator bsls::Types::Uint64() const
{
    return BSLS_BYTEORDER_BE_U64_TO_HOST(d_value);
}

namespace bdlb {
template &lt;class STREAM&gt;
STREAM&amp; BigEndianUint64::bdexStreamOut(STREAM&amp; stream, int version) const
{
    switch (version) {
      case 1: {
        stream.putArrayUint8(reinterpret_cast&lt;const unsigned char *&gt;(&amp;d_value),
                             sizeof d_value);
      } break;
      default: {
        stream.invalidate();
      }
    }
    return stream;
}
}  // close package namespace

// FREE OPERATORS
inline
bool bdlb::operator==(const BigEndianUint64&amp; lhs, const BigEndianUint64&amp; rhs)
{
    return lhs.d_value == rhs.d_value;
}

inline
bool bdlb::operator!=(const BigEndianUint64&amp; lhs, const BigEndianUint64&amp; rhs)
{
    return lhs.d_value != rhs.d_value;
}

inline
bsl::ostream&amp; bdlb::operator&lt;&lt;(bsl::ostream&amp;          stream,
                               const BigEndianUint64&amp; integer)
{
    integer.print(stream, 0, -1);
    return stream;
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
