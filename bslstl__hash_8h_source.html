<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslstl_hash.h                                                      -*-C++-*-
#ifndef INCLUDED_BSLSTL_HASH
#define INCLUDED_BSLSTL_HASH

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a namespace for hash functions.
//
//@CLASSES:
//  bsl::hash: hash function for fundamental types
//
//@SEE_ALSO: bsl+stdhdrs
//
//@DESCRIPTION: This component provides a template unary functor, &#39;bsl::hash&#39;,
// implementing the &#39;std::hash&#39; functor.  &#39;bsl::hash&#39; applies a C++ standard
// compliant, implementation defined, hash function to fundamental types
// returning the result of such application.
//
/// Standard Hash Function
// According to the C++ standard the requirements of a standard hash function
// &#39;h&#39; are:
//
//: 1 Return a &#39;size_t&#39; value between 0 and
//:   &#39;numeric_limits&lt;std::size_t&gt;::max()&#39;
//:
//: 2 The value returned must depend only on the argument &#39;k&#39;.  For multiple
//:   evaluations with the same argument &#39;k&#39;, the value returned must be
//:   always the same.
//:
//: 3 The function should not modify it&#39;s argument.
//
///Usage
///-----
// This section illustrates intended usage of this component.
//
///Example 1: Creating and Using a Hash Cross Reference
/// - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we already have an array of unique values of type &#39;TYPE&#39;, for which
// &#39;operator==&#39; is defined, and we want to be able to quickly look up whether
// an element is in the array, without exhaustively applying &#39;operator==&#39; to
// all the elements in sequence.  The array itself is guaranteed not to change
// for the duration of our interest in it.
//
// The problem is much simpler than building a general-purpose hash table,
// because we know how many elements our cross reference will contain in
// advance, so we will never have to dynamically grow the number of &#39;buckets&#39;.
// We do not need to copy the values into our own area, so we don&#39;t have to
// create storage for them, or require that a copy constructor or destructor be
// available.  We only require that they have a transitive, symmetric
// equivalence operation &#39;bool operator==&#39; and that a hash function be
// provided.
//
// We will need a hash function -- the hash function is a function that will
// take as input an object of the type stored in our array, and yield a
// &#39;size_t&#39; value which will be very randomized.  Ideally, the slightest change
// in the value of the &#39;TYPE&#39; object will result in a large change in the value
// returned by the hash function.  In a good hash function, typically half the
// bits of the return value will change for a 1-bit change in the hashed value.
// We then use the result of the hash function to index into our array of
// &#39;buckets&#39;.  Each &#39;bucket&#39; is simply a pointer to a value in our original
// array of &#39;TYPE&#39; objects.  We will resolve hash collisions in our array
// through &#39;linear probing&#39;, where we will search consecutive buckets following
// the bucket where the collision occurred, testing occupied buckets for
// equality with the value we are searching on, and concluding that the value
// is not in the table if we encounter an empty bucket before we encounter one
// referring to an equal element.
//
// An important quality of the hash function is that if two values are
// equivalent, they must yield the same hash value.
//
// First, we define our &#39;HashCrossReference&#39; template class, with the two type
// parameters &#39;TYPE&quot; (the type being referenced&#39; and &#39;HASHER&#39;, which defaults
// to &#39;bsl::hash&lt;TYPE&gt;&#39;.  For common types of &#39;TYPE&#39; such as &#39;int&#39;, a
// specialization of &#39;bsl::hash&#39; is already defined:
//..
//  template &lt;class TYPE, class HASHER = bsl::hash&lt;TYPE&gt; &gt;
//  class HashCrossReference {
//      // This table leverages a hash table to provide a fast lookup of an
//      // external, non-owned, array of values of configurable type.
//      //
//      // The only requirement for &#39;TYPE&#39; is that it have a transitive,
//      // symmetric &#39;operator==&#39; function.  There is no requirement that it
//      // have any kind of creator defined.
//      //
//      // The &#39;HASHER&#39; template parameter type must be a functor with a
//      // function of the following signature:
//      //..
//      //  size_t operator()(const TYPE)  const; or
//      //  size_t operator()(const TYPE&amp;) const; or
//      //..
//      // and &#39;HASHER&#39; must have a publicly available default constructor and
//      // destructor.
//
//      // DATA
//      const TYPE       *d_values;             // Array of values table is to
//                                              // cross-reference.  Held, not
//                                              // owned.
//      size_t            d_numValues;          // Length of &#39;d_values&#39;.
//      const TYPE      **d_bucketArray;        // Contains ptrs into
//                                              // &#39;d_values&#39;
//      unsigned          d_bucketArrayMask;    // Will always be &#39;2^N - 1&#39;.
//      HASHER            d_hasher;
//      bool              d_valid;              // Object was properly
//                                              // initialized.
//      bslma::Allocator *d_allocator_p;        // held, not owned
//
//    private:
//      // PRIVATE ACCESSORS
//      bool lookup(size_t      *idx,
//                  const TYPE&amp;  value,
//                  size_t       hashValue) const
//          // Look up the specified &#39;value&#39;, having hash value &#39;hashValue&#39;,
//          // and return its index in &#39;d_bucketArray&#39;.  If not found, return
//          // the vacant entry in &#39;d_bucketArray&#39; where it should be inserted.
//          // Return &#39;true&#39; if &#39;value is found and &#39;false&#39; otherwise.
//      {
//          const TYPE *ptr;
//          for (*idx = hashValue &amp; d_bucketArrayMask;
//                                (ptr = d_bucketArray[*idx]);
//                                     *idx = (*idx + 1) &amp; d_bucketArrayMask) {
//              if (value == *ptr) {
//                  return true;                                      // RETURN
//              }
//          }
//          // value was not found in table
//
//          return false;
//      }
//
//    public:
//      // CREATORS
//      HashCrossReference(const TYPE       *valuesArray,
//                         size_t            numValues,
//                         bslma::Allocator *allocator = 0)
//          // Create a hash cross reference referring to the array of value.
//      : d_values(valuesArray)
//      , d_numValues(numValues)
//      , d_hasher()
//      , d_valid(true)
//      , d_allocator_p(bslma::Default::allocator(allocator))
//      {
//          size_t bucketArrayLength = 4;
//          while (bucketArrayLength &lt; numValues * 4) {
//              bucketArrayLength *= 2;
//              BSLS_ASSERT_OPT(bucketArrayLength);
//          }
//          d_bucketArrayMask = bucketArrayLength - 1;
//          d_bucketArray = (const TYPE **) d_allocator_p-&gt;allocate(
//                                        bucketArrayLength * sizeof(TYPE **));
//          memset(d_bucketArray,  0, bucketArrayLength * sizeof(TYPE *));
//
//          for (unsigned i = 0; i &lt; numValues; ++i) {
//              const TYPE&amp; value = d_values[i];
//              size_t idx;
//              if (lookup(&amp;idx, value, d_hasher(value))) {
//                  // Duplicate value.  Fail.
//
//                  printf(&quot;Error: entries %u and %u have the same value\n&quot;,
//                              i, (unsigned) (d_bucketArray[idx] - d_values));
//                  d_valid = false;
//
//                  // don&#39;t return, continue reporting other redundant
//                  // entries.
//              }
//              else {
//                  d_bucketArray[idx] = &amp;d_values[i];
//              }
//          }
//      }
//
//      ~HashCrossReference()
//          // Free up memory used by this cross-reference.
//      {
//          d_allocator_p-&gt;deallocate(d_bucketArray);
//      }
//
//      // ACCESSORS
//      int count(const TYPE&amp; value) const
//          // Return 1 if the specified &#39;value&#39; is found in the cross
//          // reference and 0 otherwise.
//      {
//          BSLS_ASSERT_OPT(d_valid);
//
//          size_t idx;
//          return lookup(&amp;idx, value, d_hasher(value));
//      }
//
//      bool isValid() const
//          // Return &#39;true&#39; if this cross reference was successfully
//          // constructed and &#39;false&#39; otherwise.
//      {
//          return d_valid;
//      }
//  };
//..
// Then, In &#39;main&#39;, we will first use our cross-reference to cross-reference a
// collection of integer values.  We define our array and take its length:
//..
//  const int ints[] = { 23, 42, 47, 56, 57, 61, 62, 63, 70, 72, 79 };
//  enum { NUM_INTS = sizeof ints / sizeof *ints };
//..
// Now, we create our cross-reference &#39;hcri&#39; and verify it constructed
// properly.  Note that we don&#39;t specify the second template parameter &#39;HASHER&#39;
// and let it default to &#39;bsl::hash&lt;int&gt;&#39;, which is already defined by
// bslstl_hash:
//..
//  HashCrossReference&lt;int&gt; hcri(ints, NUM_INTS);
//  assert(hcri.isValid());
//..
// Finally, we use &#39;hcri&#39; to verify numbers that were and were not in the
// collection:
//..
//  assert(1 == hcri.count(23));
//  assert(1 == hcri.count(42));
//  assert(1 == hcri.count(47));
//  assert(1 == hcri.count(56));
//  assert(0 == hcri.count( 3));
//  assert(0 == hcri.count(31));
//  assert(0 == hcri.count(37));
//  assert(0 == hcri.count(58));
//..
//
///Example 2: Using &#39;hashAppend&#39; from &#39;bslh&#39; with &#39;HashCrossReference&#39;
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// We want to specialize &#39;bsl::hash&#39; for a custom class. We can use the the
// modular hashing system implemented in &#39;bslh&#39; rather than explicitly
// specializing &#39;bsl::hash&#39;. We will re-use the &#39;HashCrossReference&#39; template
// class defined in Example 1.
//
// First, we declare &#39;Point&#39;, a class that allows us to identify a loction on a
// two dimensional cartesian plane.
//..
//
//  class Point {
//      // This class is a value semantic type that represents as two
//      // dimensional location on a cartesian plane.
//
//    private:
//      int    d_x;
//      int    d_y;
//      double d_distToOrigin; // This value will be accessed a lot, so we
//                             // cache it rather than recalculating every
//                             // time.
//
//    public:
//      Point (int x, int y);
//          // Create a &#39;Point&#39; with the specified &#39;x&#39; and &#39;y&#39; coordinates
//
//      double distanceToOrigin();
//          // Return the distance from the origin (0, 0) to this point.
//
//..
// Then, we declare &#39;operator==&#39; as a friend so that we will be able to compare
// two points.
//..
//      friend bool operator==(const Point &amp;left, const Point &amp;right);
//
//..
// Next, we declare &#39;hashAppend&#39; as a friend so that we will be able hash a
// &#39;Point&#39;.
//..
//      template &lt;class HASH_ALGORITHM&gt;
//      friend
//      void hashAppend(HASH_ALGORITHM &amp;hashAlg, const Point &amp;point);
//          // Apply the specified &#39;hashAlg&#39; to the specified &#39;point&#39;
//  };
//
//  Point::Point(int x, int y) : d_x(x), d_y(y) {
//      d_distToOrigin = sqrt(static_cast&lt;long double&gt;(d_x * d_x) +
//                            static_cast&lt;long double&gt;(d_y * d_y));
//  }
//
//  double Point::distanceToOrigin() {
//      return d_distToOrigin;
//  }
//
//..
// Then, we define &#39;operator==&#39;. Notice how it only checks salient attributes -
// attributes that contribute to the value of the class. We ignore
// &#39;d_distToOrigin&#39; which is not required to determine equality.
//..
//  bool operator==(const Point &amp;left, const Point &amp;right)
//  {
//      return (left.d_x == right.d_x) &amp;&amp; (left.d_y == right.d_y);
//  }
//
//..
// Next, we define &#39;hashAppend&#39;. This method will allow any hashing algorithm
// to be applied to &#39;Point&#39;. This is the extent of the work that needs to be
// done by type creators. They do not need to implement any algorithms, they
// just need to call out the salient attributes (which have already been
// determined by &#39;operator==&#39;) by calling &#39;hashAppend&#39; on them.
//..
//  template &lt;class HASH_ALGORITHM&gt;
//  void hashAppend(HASH_ALGORITHM &amp;hashAlg, const Point &amp;point)
//  {
//      using ::BloombergLP::bslh::hashAppend;
//      hashAppend(hashAlg, point.d_x);
//      hashAppend(hashAlg, point.d_y);
//  }
//
//..
// Then, we declare another value semantic type, &#39;Box&#39; that will have point as
// one of its salient attributes.
//..
//  class Box {
//      // This class is a value semantic type that represents a box drawn on
//      // to a cartesian plane.
//
//    private:
//      Point d_position;
//      int d_length;
//      int d_width;
//
//    public:
//      Box(Point position, int length, int width);
//          // Create a box with the specified &#39;length&#39; and &#39;width&#39;, with its
//          // upper left corner at the specified &#39;position&#39;
//
//..
// Next, we declare &#39;operator==&#39; and &#39;hashAppend&#39; as we did before.
//..
//      friend bool operator==(const Box &amp;left, const Box &amp;right);
//
//      template &lt;class HASH_ALGORITHM&gt;
//      friend
//      void hashAppend(HASH_ALGORITHM &amp;hashAlg, const Box &amp;box);
//          // Apply the specified &#39;hashAlg&#39; to the specified &#39;box&#39;
//  };
//
//  Box::Box(Point position, int length, int width) : d_position(position),
//                                                    d_length(length),
//                                                    d_width(width) { }
//
//..
// Then, we define &#39;operator==&#39;. This time all of the data members contribute
// to equality.
//..
//  bool operator==(const Box &amp;left, const Box &amp;right)
//  {
//      return (left.d_position == right.d_position) &amp;&amp;
//             (left.d_length   == right.d_length) &amp;&amp;
//             (left.d_width    == right.d_width);
//  }
//
//..
// Next, we define &#39;hashAppend&#39; for &#39;Box&#39;. Notice how as well as calling
// &#39;hashAppend&#39; on fundamental types, we can also call it on our user defined
// type &#39;Point&#39;. Calling &#39;hashAppend&#39; on &#39;Point&#39; will propogate the hashing
// algorithm functor &#39;hashAlg&#39; down to the fundamental types that make up
// &#39;Point&#39;, and those types will then be passed into the algorithm functor.
//..
//  template &lt;class HASH_ALGORITHM&gt;
//  void hashAppend(HASH_ALGORITHM &amp;hashAlg, const Box &amp;box)
//  {
//      hashAppend(hashAlg, box.d_position);
//      hashAppend(hashAlg, box.d_length);
//      hashAppend(hashAlg, box.d_width);
//  }
//..
// Then, we want to use our cross reference on a &#39;Box&#39;.  We create an array of
// unique &#39;Box&#39;s and take its length:
//..
//
//      Box boxes[] = { Box(Point(0, 0), 2, 3),
//                      Box(Point(1, 0), 1, 1),
//                      Box(Point(0, 1), 1, 5),
//                      Box(Point(1, 1), 5, 6),
//                      Box(Point(2, 1), 1, 13),
//                      Box(Point(0, 4), 3, 3),
//                      Box(Point(3, 2), 2, 17) };
//      enum { NUM_BOXES = sizeof boxes / sizeof *boxes };
//
//..
// Next, we create our cross-reference &#39;hcrsts&#39; and verify that it constructed
// properly.  Note we don&#39;t pass a second parameter template argument and let
// &#39;HASHER&#39; default to &#39;bsl::hash&lt;TYPE&gt;&#39;. Since we have not specialized
// &#39;bsl::hash&#39; for &#39;Box&#39;, &#39;bsl::hash&lt;TYPE&gt;&#39; will attempt to use &#39;bslh::hash&lt;&gt;&#39;
// to hash &#39;Box&#39;.
//..
//
//      HashCrossReference&lt;Box&gt; hcrsts(boxes, NUM_BOXES);
//      ASSERT(hcrsts.isValid());
//
//..
// Now, we verify that each element in our array registers with count:
//..
//      for(int i = 0; i &lt; NUM_BOXES; ++i) {
//          ASSERT(1 == hcrsts.count(boxes[i]));
//      }
//
//..
// Finally, we verify that elements not in our original array are correctly
// identified as not being in the set:
//..
//      ASSERT(0 == hcrsts.count(Box(Point(3, 3), 3, 3)));
//      ASSERT(0 == hcrsts.count(Box(Point(3, 2), 1, 0)));
//      ASSERT(0 == hcrsts.count(Box(Point(1, 2), 3, 4)));
//      ASSERT(0 == hcrsts.count(Box(Point(33, 23), 13, 3)));
//      ASSERT(0 == hcrsts.count(Box(Point(30, 37), 34, 13)));
//..


// Prevent &#39;bslstl&#39; headers from being included directly in &#39;BSL_OVERRIDES_STD&#39;
// mode.  Doing so is unsupported, and is likely to cause compilation errors.
#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
#error &quot;&lt;bslstl_hash.h&gt; header can&#39;t be included directly in \
BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLALG_HASHUTIL
#include &lt;bslalg_hashutil.h&gt;
#endif

#ifndef INCLUDED_BSLH_HASH
#include &lt;bslh_hash.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYCOPYABLE
#include &lt;bslmf_istriviallycopyable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYDEFAULTCONSTRUCTIBLE
#include &lt;bslmf_istriviallydefaultconstructible.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_COMPILERFEATURES
#include &lt;bsls_compilerfeatures.h&gt;
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;  // for &#39;std::size_t&#39;
#define INCLUDED_CSTDDEF
#endif


namespace bsl {

                          // ==================
                          // class bslstl::hash
                          // ==================

template &lt;class TYPE&gt;
struct hash : ::BloombergLP::bslh::Hash&lt;&gt; {
    // Empty base class for hashing. This class, and all explicit and partial
    // specializations of this class, shall conform to the C++11 Hash
    // Requirements (C++11 17.6.3.4, [hash.requirements]). Unless this template
    // is explicitly specialized, it will use the defualt hash algorithm
    // provided by &#39;bslh::Hash&lt;&gt;&#39; to supply hash values. In order to hash a
    // user defined type using &#39;bsl::hash&#39;, &#39;bsl::hash&#39; must be explicitly
    // specialized for the type, or, perferably, &#39;hashAppend&#39; must be
    // implemented for the type. For more details on &#39;hashAppend&#39; and
    // &#39;bslh::Hash&#39; see the component &#39;bslh_hash&#39;.
};

// ============================================================================
//                  SPECIALIZATIONS FOR FUNDAMENTAL TYPES
// ============================================================================

template &lt;class BSLSTL_KEY&gt;
struct hash&lt;const BSLSTL_KEY&gt; : hash&lt;BSLSTL_KEY&gt; {
    // This class provides hashing functionality for constant key types, by
    // delegating to the same function for non-constant key types.
};

template &lt;&gt;
struct hash&lt;bool&gt; {
    // Specialization of &#39;hash&#39; for &#39;bool&#39; values.

    // STANDARD TYPEDEFS
    typedef bool argument_type;
    typedef std::size_t result_type;

    //! hash() = default;
        // Create a &#39;hash&#39; object.

    //! hash(const hash&amp; original) = default;
        // Create a &#39;hash&#39; object.  Note that as &#39;hash&#39; is an empty (stateless)
        // type, this operation will have no observable effect.

    //! ~hash() = default;
        // Destroy this object.

    // MANIPULATORS
    //! hash&amp; operator=(const hash&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that as &#39;hash&#39; is an empty (stateless) type, this operation will
        // have no observable effect.

    // ACCESSORS
    std::size_t operator()(bool x) const;
        // Return a hash value computed using the specified &#39;x&#39;.
};

template &lt;&gt;
struct hash&lt;char&gt; {
    // Specialization of &#39;hash&#39; for &#39;char&#39; values.

    // STANDARD TYPEDEFS
    typedef char argument_type;
    typedef std::size_t result_type;

    //! hash() = default;
        // Create a &#39;hash&#39; object.

    //! hash(const hash&amp; original) = default;
        // Create a &#39;hash&#39; object.  Note that as &#39;hash&#39; is an empty (stateless)
        // type, this operation will have no observable effect.

    //! ~hash() = default;
        // Destroy this object.

    // MANIPULATORS
    //! hash&amp; operator=(const hash&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that as &#39;hash&#39; is an empty (stateless) type, this operation will
        // have no observable effect.

    // ACCESSORS
    std::size_t operator()(char x) const;
        // Return a hash value computed using the specified &#39;x&#39;.
};

template &lt;&gt;
struct hash&lt;signed char&gt; {
    // Specialization of &#39;hash&#39; for &#39;signed&#39; &#39;char&#39; values.

    // STANDARD TYPEDEFS
    typedef signed char argument_type;
    typedef std::size_t result_type;

    //! hash() = default;
        // Create a &#39;hash&#39; object.

    //! hash(const hash&amp; original) = default;
        // Create a &#39;hash&#39; object.  Note that as &#39;hash&#39; is an empty (stateless)
        // type, this operation will have no observable effect.

    //! ~hash() = default;
        // Destroy this object.

    // MANIPULATORS
    //! hash&amp; operator=(const hash&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that as &#39;hash&#39; is an empty (stateless) type, this operation will
        // have no observable effect.

    // ACCESSORS
    std::size_t operator()(signed char x) const;
        // Return a hash value computed using the specified &#39;x&#39;.
};

template &lt;&gt;
struct hash&lt;unsigned char&gt; {
    // Specialization of &#39;hash&#39; for &#39;unsigned&#39; &#39;char&#39; values.

    // STANDARD TYPEDEFS
    typedef unsigned char argument_type;
    typedef std::size_t result_type;

    //! hash() = default;
        // Create a &#39;hash&#39; object.

    //! hash(const hash&amp; original) = default;
        // Create a &#39;hash&#39; object.  Note that as &#39;hash&#39; is an empty (stateless)
        // type, this operation will have no observable effect.

    //! ~hash() = default;
        // Destroy this object.

    // MANIPULATORS
    //! hash&amp; operator=(const hash&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that as &#39;hash&#39; is an empty (stateless) type, this operation will
        // have no observable effect.

    // ACCESSORS
    std::size_t operator()(unsigned char x) const;
        // Return a hash value computed using the specified &#39;x&#39;.
};

template &lt;&gt;
struct hash&lt;wchar_t&gt; {
    // Specialization of &#39;hash&#39; for &#39;wchar_t&#39; values.

    // STANDARD TYPEDEFS
    typedef wchar_t argument_type;
    typedef std::size_t result_type;

    //! hash() = default;
        // Create a &#39;hash&#39; object.

    //! hash(const hash&amp; original) = default;
        // Create a &#39;hash&#39; object.  Note that as &#39;hash&#39; is an empty (stateless)
        // type, this operation will have no observable effect.

    //! ~hash() = default;
        // Destroy this object.

    // MANIPULATORS
    //! hash&amp; operator=(const hash&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that as &#39;hash&#39; is an empty (stateless) type, this operation will
        // have no observable effect.

    // ACCESSORS
    std::size_t operator()(wchar_t x) const;
        // Return a hash value computed using the specified &#39;x&#39;.
};

template &lt;&gt;
struct hash&lt;short&gt; {
    // Specialization of &#39;hash&#39; for &#39;short&#39; values.

    // STANDARD TYPEDEFS
    typedef short argument_type;
    typedef std::size_t result_type;

    //! hash() = default;
        // Create a &#39;hash&#39; object.

    //! hash(const hash&amp; original) = default;
        // Create a &#39;hash&#39; object.  Note that as &#39;hash&#39; is an empty (stateless)
        // type, this operation will have no observable effect.

    //! ~hash() = default;
        // Destroy this object.

    // MANIPULATORS
    //! hash&amp; operator=(const hash&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that as &#39;hash&#39; is an empty (stateless) type, this operation will
        // have no observable effect.

    // ACCESSORS
    std::size_t operator()(short x) const;
        // Return a hash value computed using the specified &#39;x&#39;.
};

template &lt;&gt;
struct hash&lt;unsigned short&gt; {
    // Specialization of &#39;hash&#39; for &#39;unsigned&#39; &#39;short&#39; values.

    // STANDARD TYPEDEFS
    typedef unsigned short argument_type;
    typedef std::size_t result_type;

    //! hash() = default;
        // Create a &#39;hash&#39; object.

    //! hash(const hash&amp; original) = default;
        // Create a &#39;hash&#39; object.  Note that as &#39;hash&#39; is an empty (stateless)
        // type, this operation will have no observable effect.

    //! ~hash() = default;
        // Destroy this object.

    // MANIPULATORS
    //! hash&amp; operator=(const hash&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that as &#39;hash&#39; is an empty (stateless) type, this operation will
        // have no observable effect.

    // ACCESSORS
    std::size_t operator()(unsigned short x) const;
        // Return a hash value computed using the specified &#39;x&#39;.
};

template &lt;&gt;
struct hash&lt;int&gt; {
    // Specialization of &#39;hash&#39; for &#39;int&#39; values.

    // STANDARD TYPEDEFS
    typedef int argument_type;
    typedef std::size_t result_type;

    //! hash() = default;
        // Create a &#39;hash&#39; object.

    //! hash(const hash&amp; original) = default;
        // Create a &#39;hash&#39; object.  Note that as &#39;hash&#39; is an empty (stateless)
        // type, this operation will have no observable effect.

    //! ~hash() = default;
        // Destroy this object.

    // MANIPULATORS
    //! hash&amp; operator=(const hash&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that as &#39;hash&#39; is an empty (stateless) type, this operation will
        // have no observable effect.

    // ACCESSORS
    std::size_t operator()(int x) const;
        // Return a hash value computed using the specified &#39;x&#39;.
};

template &lt;&gt;
struct hash&lt;unsigned int&gt; {
    // Specialization of &#39;hash&#39; for &#39;unsigned&#39; &#39;int&#39; values.

    // STANDARD TYPEDEFS
    typedef unsigned int argument_type;
    typedef std::size_t result_type;

    //! hash() = default;
        // Create a &#39;hash&#39; object.

    //! hash(const hash&amp; original) = default;
        // Create a &#39;hash&#39; object.  Note that as &#39;hash&#39; is an empty (stateless)
        // type, this operation will have no observable effect.

    //! ~hash() = default;
        // Destroy this object.

    // MANIPULATORS
    //! hash&amp; operator=(const hash&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that as &#39;hash&#39; is an empty (stateless) type, this operation will
        // have no observable effect.

    // ACCESSORS
    std::size_t operator()(unsigned int x) const;
        // Return a hash value computed using the specified &#39;x&#39;.
};

template &lt;&gt;
struct hash&lt;long&gt; {
    // Specialization of &#39;hash&#39; for &#39;long&#39; values.

    // STANDARD TYPEDEFS
    typedef long argument_type;
    typedef std::size_t result_type;

    //! hash() = default;
        // Create a &#39;hash&#39; object.

    //! hash(const hash&amp; original) = default;
        // Create a &#39;hash&#39; object.  Note that as &#39;hash&#39; is an empty (stateless)
        // type, this operation will have no observable effect.

    //! ~hash() = default;
        // Destroy this object.

    // MANIPULATORS
    //! hash&amp; operator=(const hash&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that as &#39;hash&#39; is an empty (stateless) type, this operation will
        // have no observable effect.

    // ACCESSORS
    std::size_t operator()(long x) const;
        // Return a hash value computed using the specified &#39;x&#39;.
};

template &lt;&gt;
struct hash&lt;unsigned long&gt; {
    // Specialization of &#39;hash&#39; for &#39;unsigned&#39; &#39;long&#39; values.

    // STANDARD TYPEDEFS
    typedef unsigned long argument_type;
    typedef std::size_t result_type;

    //! hash() = default;
        // Create a &#39;hash&#39; object.

    //! hash(const hash&amp; original) = default;
        // Create a &#39;hash&#39; object.  Note that as &#39;hash&#39; is an empty (stateless)
        // type, this operation will have no observable effect.

    //! ~hash() = default;
        // Destroy this object.

    // MANIPULATORS
    //! hash&amp; operator=(const hash&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that as &#39;hash&#39; is an empty (stateless) type, this operation will
        // have no observable effect.

    // ACCESSORS
    std::size_t operator()(unsigned long x) const;
        // Return a hash value computed using the specified &#39;x&#39;.
};

template &lt;&gt;
struct hash&lt;long long&gt; {
    // Specialization of &#39;hash&#39; for &#39;long long&#39; values.

    // STANDARD TYPEDEFS
    typedef long long argument_type;
    typedef std::size_t result_type;

    //! hash() = default;
        // Create a &#39;hash&#39; object.

    //! hash(const hash&amp; original) = default;
        // Create a &#39;hash&#39; object.  Note that as &#39;hash&#39; is an empty (stateless)
        // type, this operation will have no observable effect.

    //! ~hash() = default;
        // Destroy this object.

    // MANIPULATORS
    //! hash&amp; operator=(const hash&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that as &#39;hash&#39; is an empty (stateless) type, this operation will
        // have no observable effect.

    // ACCESSORS
    std::size_t operator()(long long x) const;
        // Return a hash value computed using the specified &#39;x&#39;.
};

template &lt;&gt;
struct hash&lt;unsigned long long&gt; {
    // Specialization of &#39;hash&#39; for &#39;unsigned&#39; &#39;long long&#39; values.

    // STANDARD TYPEDEFS
    typedef unsigned long long argument_type;
    typedef std::size_t result_type;

    //! hash() = default;
        // Create a &#39;hash&#39; object.

    //! hash(const hash&amp; original) = default;
        // Create a &#39;hash&#39; object.  Note that as &#39;hash&#39; is an empty (stateless)
        // type, this operation will have no observable effect.

    //! ~hash() = default;
        // Destroy this object.

    // MANIPULATORS
    //! hash&amp; operator=(const hash&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that as &#39;hash&#39; is an empty (stateless) type, this operation will
        // have no observable effect.

    // ACCESSORS
    std::size_t operator()(unsigned long long x) const;
        // Return a hash value computed using the specified &#39;x&#39;.
};

// ============================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ============================================================================

inline
std::size_t hash&lt;bool&gt;::operator()(bool x) const
{
    return x;
}

inline
std::size_t hash&lt;char&gt;::operator()(char x) const
{
    return x;
}

inline
std::size_t hash&lt;signed char&gt;::operator()(signed char x) const
{
    return x;
}

inline
std::size_t hash&lt;unsigned char&gt;::operator()(unsigned char x) const
{
    return x;
}

inline
std::size_t hash&lt;wchar_t&gt;::operator()(wchar_t x) const
{
    return x;
}

inline
std::size_t hash&lt;short&gt;::operator()(short x) const
{
    return x;
}

inline
std::size_t hash&lt;unsigned short&gt;::operator()(unsigned short x) const
{
    return x;
}

inline
std::size_t hash&lt;int&gt;::operator()(int x) const
{
    return x;
}

inline
std::size_t hash&lt;unsigned int&gt;::operator()(unsigned int x) const
{
    return x;
}

inline
std::size_t hash&lt;long&gt;::operator()(long x) const
{
    return x;
}

inline
std::size_t hash&lt;unsigned long&gt;::operator()(unsigned long x) const
{
    return x;
}


#ifdef BSLS_PLATFORM_CPU_64_BIT
inline
std::size_t hash&lt;long long&gt;::operator()(long long x) const
{
    BSLMF_ASSERT(sizeof (long long) == sizeof (std::size_t));
    return x;
}

inline
std::size_t hash&lt;unsigned long long&gt;::operator()(unsigned long long x) const
{
    BSLMF_ASSERT(sizeof (long long) == sizeof (std::size_t));
    return x;
}

#else // BSLS_PLATFORM_CPU_32_BIT

inline
std::size_t hash&lt;long long&gt;::operator()(long long x) const
{
    BSLMF_ASSERT(sizeof (long long) &gt; sizeof (std::size_t));

    // The mangling algorithm won&#39;t work unless these conditions hold:

    BSLMF_ASSERT(sizeof (std::size_t) * 8 == 32);
    BSLMF_ASSERT(sizeof (long long) * 8 == 64);

    // Return a simple mangling of the 64-bits of &#39;x&#39; to generate a 32-bit hash
    // value (xor the high and low 32 bits together).

    return static_cast&lt;std::size_t&gt;((x ^ (x &gt;&gt; 32)) &amp; 0xFFFFFFFF);
}

inline
std::size_t hash&lt;unsigned long long&gt;::operator()(unsigned long long x) const
{
    BSLMF_ASSERT(sizeof (long long) &gt; sizeof (std::size_t));

    // The mangling algorithm won&#39;t work unless these conditions hold:

    BSLMF_ASSERT(sizeof (std::size_t) * 8 == 32);
    BSLMF_ASSERT(sizeof (unsigned long long) * 8 == 64);

    // Return a simple mangling of the 64-bits of &#39;x&#39; to generate a 32-bit hash
    // value (xor the high and low 32 bits together).

    return static_cast&lt;std::size_t&gt;((x ^ (x &gt;&gt; 32)) &amp; 0xFFFFFFFF);
}
#endif

// ============================================================================
//                                TYPE TRAITS
// ============================================================================

// Type traits for STL &#39;hash&#39;
//: o &#39;bsl::hash&lt;TYPE&gt;&#39; is trivially default constructible.
//: o &#39;bsl::hash&lt;TYPE&gt;&#39; is trivially copyable.
//: o &#39;bsl::hash&lt;TYPE&gt;&#39; is bitwise movable.

template &lt;class TYPE&gt;
struct is_trivially_default_constructible&lt;hash&lt;TYPE&gt; &gt;
: bsl::true_type
{};

template &lt;class TYPE&gt;
struct is_trivially_copyable&lt;hash&lt;TYPE&gt; &gt;
: bsl::true_type
{};

}  // close namespace bsl

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
