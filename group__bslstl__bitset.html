<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslstl_bitset Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_bitset<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL-compliant bitset class.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1bitset.html">bsl::bitset&lt; N &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1bitset_1_1reference.html">bsl::bitset&lt; N &gt;::reference</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga294f39c30a4d6990ad808c999db547f9">bsl::bitset::reference::operator=</a> (bool x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#gaf39e4355df95308cbeb61c9ec75d34bd">bsl::bitset::reference::operator=</a> (const reference &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga556ed9c89a9dd6b162131704680ecae1">bsl::bitset::reference::flip</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga42ab68a97fc9cecfcce517b9adb362b0">bsl::bitset::reference::operator bool</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga6f0505659b82bcaa51871a119d96fc2a">bsl::bitset::reference::operator~</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga5fdfa8dd28d4793c1408b61ad6c3833e">bsl::bitset::bitset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga6e531d48a17f7ad8ad1bc5fe51d64d6a">bsl::bitset::bitset</a> (unsigned long val)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga44fbb9ccda20fbd9bf7764029f221fc3">bsl::bitset::bitset</a> (const native_std::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt; &amp;str, typename native_std::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type pos=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga36df1ba613868032d0084e054fe1ae82">bsl::bitset::bitset</a> (const native_std::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt; &amp;str, typename native_std::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type pos, typename native_std::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga4d5688759ce705c80ffad199b89bdd93">bsl::bitset::bitset</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt; &amp;str, typename <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type pos=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga959ff227f22d9ee67d8ef52dac530844">bsl::bitset::bitset</a> (const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt; &amp;str, typename <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type pos, typename <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bitset &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#gaeeec8b1e4e60bc3437d550221df90da4">bsl::bitset::operator&amp;=</a> (const bitset &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bitset &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga4c1a37daf57257c976ff0cd1f9deec3f">bsl::bitset::operator|=</a> (const bitset &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bitset &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga3834881fe0e5556459deaa97a98e56b0">bsl::bitset::operator^=</a> (const bitset &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bitset &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#gad528d8380dc10645204f63e16ac403eb">bsl::bitset::operator&lt;&lt;=</a> (std::size_t pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bitset &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#gae5028ddd47321df47e4a583cc735b49a">bsl::bitset::operator&gt;&gt;=</a> (std::size_t pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bitset &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga7402a8158a32511d16d1289645cb1854">bsl::bitset::flip</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bitset &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga9dc530c12dc97a1b8d6df52b3579ef07">bsl::bitset::flip</a> (std::size_t pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bitset &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga6fc61fbd9acbea27f4f15e901e941ae1">bsl::bitset::reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bitset &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga423e8679355ea9e56a2ddfda712222f6">bsl::bitset::reset</a> (std::size_t pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bitset &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga0bcfa36ddb4d9acbc8083053dfc676c2">bsl::bitset::set</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bitset &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga4241ccdeb3d61880677bc28f644a14ca">bsl::bitset::set</a> (std::size_t pos, int val=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga58e4f6c410d6871938f27c3615e37dc9">bsl::bitset::operator[]</a> (std::size_t pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bitset&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga294bcb6479efaf385ef2f9955b40f0d2">bsl::bitset::operator&lt;&lt;</a> (std::size_t pos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bitset&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#gaaa80d19b0fb73ee5d915b166f83c836b">bsl::bitset::operator&gt;&gt;</a> (std::size_t pos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bitset&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#gacccb4db03581bad09809fb4bfef55fee">bsl::bitset::operator~</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class TRAITS , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">basic_string&lt; CHAR_TYPE, <br class="typebreak"/>
TRAITS, ALLOCATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#gab426b26632ff4b30da79c666bddb430f">bsl::bitset::to_string</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga528dd8b88402323b356c15a029277757">bsl::bitset::operator[]</a> (std::size_t pos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#gafe2f16c98874032583b3b3dfa37afcfc">bsl::bitset::operator==</a> (const bitset &amp;rhs) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga6921ff4be26e8547903e217932e401a1">bsl::bitset::operator!=</a> (const bitset &amp;rhs) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#gabdf1741abbe2a4fb4ff2c2a16c27003d">bsl::bitset::any</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga9dc00511ea32aa857eda89980759ea21">bsl::bitset::none</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga9fd0d05b1ba2ab1dd55b7756fabe3fc8">bsl::bitset::size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga04b4e7536481f87961d5680978a101cf">bsl::bitset::count</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga0f468eb799a47dd9783b6d600f79ee14">bsl::bitset::test</a> (size_t pos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga0c5baa02e3100eb328ad1e0440dce78b">bsl::bitset::to_ulong</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bitset&lt; N &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga060694dd688617141953e388c40853ab">bsl::operator&amp;</a> (const bitset&lt; N &gt; &amp;lhs, const bitset&lt; N &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bitset&lt; N &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga600580f51a11bd8cebfc76701b8b95fd">bsl::operator|</a> (const bitset&lt; N &gt; &amp;lhs, const bitset&lt; N &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bitset&lt; N &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga647dad04e0c0bc7a4878b53acc99fb40">bsl::operator^</a> (const bitset&lt; N &gt; &amp;lhs, const bitset&lt; N &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class TRAITS , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_istream&lt; CHAR_TYPE, <br class="typebreak"/>
TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga9594d63ffa3d8d079eb96e3ff77ee16e">bsl::operator&gt;&gt;</a> (std::basic_istream&lt; CHAR_TYPE, TRAITS &gt; &amp;is, bitset&lt; N &gt; &amp;x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CHAR_TYPE , class TRAITS , std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; CHAR_TYPE, <br class="typebreak"/>
TRAITS &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga85fb82ba96cea34775f63b967f323931">bsl::operator&lt;&lt;</a> (std::basic_ostream&lt; CHAR_TYPE, TRAITS &gt; &amp;os, const bitset&lt; N &gt; &amp;x)</td></tr>
<tr><td colspan="2"><h2><a name="friend-members"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__bitset.html#ga811ee22ffe70f7ebb2829f620f369cdb">bsl::bitset::reference</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Determining if a Number is Prime (Sieve of Eratosthenes)</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL-compliant bitset class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a> </td><td>STL-compatible bitset template  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bsl+stdhdrs </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component is for internal use only. Please include <code>&lt;bsl_bitset.h&gt;</code> instead and use <code><a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a></code> directly. This component implements a static bitset class that is suitable for use as an implementation of the <code>std::bitset</code> class template. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_determining_if_a_number_is_prime_(sieve_of_eratosthenes)"></a> <a class="anchor" id="usage.example_1~3A_determining_if_a_number_is_prime_(sieve_of_eratosthenes)"></a> <a class="anchor" id="description.usage.example_1~3A_determining_if_a_number_is_prime_(sieve_of_eratosthenes)"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Determining if a Number is Prime (Sieve of Eratosthenes): </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we want to write a function to determine whether or not a given number is prime. One way to implement this function is by using what's called the Sieve of Eratosthenes. The basic idea of this algorithm is to repeatedly walk the sequence of integer values and mark any numbers up to and including the particular value of interest that are integer multiples of first 2, then 3, then 5, etc. (skipping 4 because it was previously marked when we walked the sequence by 2's). Once we have walked the sequence with all primes up to and including the square root of the number of interest, we check to see if that number has been marked: If it has, it's composite; otherwise it's prime. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When implementing this classic algorithm, we need an efficient way of representing a flag for each potential prime number. The following illustrates how we can use <code><a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a></code> to accomplish this result, provided we know an upper bound on supplied candidate values at compile time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we begin to define a function template that will determine whether or not a given candidate value is prime: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MAX_VALUE&gt;
  <span class="keywordtype">bool</span> isPrime(<span class="keywordtype">int</span> candidate)
      <span class="comment">// Return &#39;true&#39; if the specified &#39;candidate&#39; value is a prime number,</span>
      <span class="comment">// and &#39;false&#39; otherwise.  The behavior is undefined unless</span>
      <span class="comment">// &#39;2 &lt;= candidate &lt;= MAX_VALUE&#39;</span>
  {
      <a class="code" href="group__bslmf__assert.html#ga25a196cf9f296d429b37512e9ad8ee27">BSLMF_ASSERT</a>(2 &lt;= MAX_VALUE);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(2 &lt;= candidate); <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(candidate &lt;= MAX_VALUE);
</pre></div><br/>
<br/>
 Then, we declare a <code><a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a></code>, <code>compositeFlags</code>, that will contain flags indicating whether a value corresponding to a given index is known to be composite (<code>true</code>) or is still potentially prime (<code>false</code>) up to and including the compile-time constant template parameter, <code>MAX_VALUE</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// Candidate primes in the &#39;[2 .. MAX_VALUE]&#39; range.</span>

      <a class="code" href="classbsl_1_1bitset.html">bsl::bitset&lt;MAX_VALUE + 1&gt;</a> compositeFlags;
</pre></div><br/>
<br/>
 Next, we observe that a default-constructed <code><a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a></code> has no flags set, We can check this by asserting that the <code>none</code> method returns true, by asserting that the <code>any</code> method returns false, or by asserting that the <code>count</code> of set bits is 0: <br/>
<br/>
<div class="fragment"><pre class="fragment">      assert(<span class="keyword">true</span>  == compositeFlags.<a class="code" href="group__bslstl__bitset.html#ga9dc00511ea32aa857eda89980759ea21">none</a>());
      assert(<span class="keyword">false</span> == compositeFlags.<a class="code" href="group__bslstl__bitset.html#gabdf1741abbe2a4fb4ff2c2a16c27003d">any</a>());
      assert(0     == compositeFlags.<a class="code" href="group__bslstl__bitset.html#ga04b4e7536481f87961d5680978a101cf">count</a>());
</pre></div><br/>
<br/>
 Then, we note that a <code><a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a></code> has a fixed <code>size</code> (the set can't be grown or shrunk) and verify that <code>size</code> is the same as the template argument used to create the <code><a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      assert(MAX_VALUE + 1 == compositeFlags.<a class="code" href="group__bslstl__bitset.html#ga9fd0d05b1ba2ab1dd55b7756fabe3fc8">size</a>());
</pre></div><br/>
<br/>
 Next, we compute <code>sqrt(candidate)</code>, which is as far as we need to look: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// We need to cast the &#39;sqrt&#39; argument to avoid an overload ambiguity.</span>
      <span class="keyword">const</span> <span class="keywordtype">int</span> sqrtOfCandidate = std::sqrt(static_cast&lt;double&gt;(candidate))
                                + 0.01;  <span class="comment">// fudge factor</span>
</pre></div><br/>
<br/>
 Now, we loop from 2 to <code>sqrtOfCandidate</code>, and use the sieve algorithm to eliminate non-primes: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// Note that we treat &#39;false&#39; values as potential primes,</span>
      <span class="comment">// since that is how &#39;bsl::bitset&#39; is default-initialized.</span>

      <span class="keywordflow">for</span> (std::size_t i = 2; i &lt;= sqrtOfCandidate; ++i) {
          <span class="keywordflow">if</span> (compositeFlags[i]) {
              <span class="keywordflow">continue</span>; <span class="comment">// Skip this value: it&#39;s flagged as composite, so all</span>
                        <span class="comment">// of its multiples are already flagged as composite</span>
                        <span class="comment">// as well.</span>
          }

          <span class="keywordflow">for</span> (std::size_t flagValue = i;
               flagValue &lt;= candidate;
               flagValue += i) {
              compositeFlags[flagValue] = <span class="keyword">true</span>;
          }

          <span class="keywordflow">if</span> (<span class="keyword">true</span> == compositeFlags[candidate]) {
              <span class="keywordflow">return</span> <span class="keyword">false</span>;                                         <span class="comment">// RETURN</span>
          }
      }

      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(<span class="keyword">false</span> == compositeFlags[candidate]);

      <span class="keywordflow">return</span> <span class="keyword">true</span>;
  }
</pre></div><br/>
<br/>
 Notice that if we don't return <code>false</code> from the loop, none of the lower numbers evenly divided the candidate value; hence, it is a prime number. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, we can exercise our <code>isPrime</code> function with an upper bound of 10,000: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { UPPER_BOUND = 10000 };

  assert(1 == isPrime&lt;UPPER_BOUND&gt;(2));
  assert(1 == isPrime&lt;UPPER_BOUND&gt;(3));
  assert(0 == isPrime&lt;UPPER_BOUND&gt;(4));
  assert(1 == isPrime&lt;UPPER_BOUND&gt;(5));
  assert(0 == isPrime&lt;UPPER_BOUND&gt;(6));
  assert(1 == isPrime&lt;UPPER_BOUND&gt;(7));
  assert(0 == isPrime&lt;UPPER_BOUND&gt;(8));
  assert(0 == isPrime&lt;UPPER_BOUND&gt;(9));
  assert(0 == isPrime&lt;UPPER_BOUND&gt;(10));
  <span class="comment">// ...</span>
  assert(1 == isPrime&lt;UPPER_BOUND&gt;(9973));
  assert(0 == isPrime&lt;UPPER_BOUND&gt;(9975));
  assert(0 == isPrime&lt;UPPER_BOUND&gt;(10000));
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga294f39c30a4d6990ad808c999db547f9"></a><!-- doxytag: member="bsl::bitset::reference::operator=" ref="ga294f39c30a4d6990ad808c999db547f9" args="(bool x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference&amp; <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::reference::operator= </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf39e4355df95308cbeb61c9ec75d34bd"></a><!-- doxytag: member="bsl::bitset::reference::operator=" ref="gaf39e4355df95308cbeb61c9ec75d34bd" args="(const reference &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference&amp; <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::reference::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1bitset_1_1reference.html">reference</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga556ed9c89a9dd6b162131704680ecae1"></a><!-- doxytag: member="bsl::bitset::reference::flip" ref="ga556ed9c89a9dd6b162131704680ecae1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference&amp; <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::reference::flip </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga42ab68a97fc9cecfcce517b9adb362b0"></a><!-- doxytag: member="bsl::bitset::reference::operator bool" ref="ga42ab68a97fc9cecfcce517b9adb362b0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::reference::operator bool </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6f0505659b82bcaa51871a119d96fc2a"></a><!-- doxytag: member="bsl::bitset::reference::operator~" ref="ga6f0505659b82bcaa51871a119d96fc2a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::reference::operator~ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5fdfa8dd28d4793c1408b61ad6c3833e"></a><!-- doxytag: member="bsl::bitset::bitset" ref="ga5fdfa8dd28d4793c1408b61ad6c3833e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::bitset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a bitset with all bits initialized to 0. </p>

</div>
</div>
<a class="anchor" id="ga6e531d48a17f7ad8ad1bc5fe51d64d6a"></a><!-- doxytag: member="bsl::bitset::bitset" ref="ga6e531d48a17f7ad8ad1bc5fe51d64d6a" args="(unsigned long val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::bitset </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a bitset with its first <code>M</code> bit positions correspond to bit values in the specified <code>val</code>. <code>M</code> is the smaller of the parameterized <code>N</code> and <code>8 * sizeof(unsigned long)</code>. If <code>M &lt; N</code>, the remaining bit positions are initialized to 0. </p>

</div>
</div>
<a class="anchor" id="ga44fbb9ccda20fbd9bf7764029f221fc3"></a><!-- doxytag: member="bsl::bitset::bitset" ref="ga44fbb9ccda20fbd9bf7764029f221fc3" args="(const native_std::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt; &amp;str, typename native_std::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type pos=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class CHAR_TYPE , class TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::bitset </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename native_std::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type&nbsp;</td>
          <td class="paramname"> <em>pos</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga36df1ba613868032d0084e054fe1ae82"></a><!-- doxytag: member="bsl::bitset::bitset" ref="ga36df1ba613868032d0084e054fe1ae82" args="(const native_std::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt; &amp;str, typename native_std::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type pos, typename native_std::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class CHAR_TYPE , class TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::bitset </td>
          <td>(</td>
          <td class="paramtype">const native_std::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename native_std::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename native_std::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a bitset with its first <code>M</code> bit positions correspond to the characters in the specified <code>pos</code> of the specified <code>str</code>. <code>M</code> is the smaller of the parameterized <code>N</code> and <code>str.length()</code>. If <code>M &lt; N</code>, the remaining bit positions are initialized to 0. The behavior is undefined if the characters in the specified <code>str</code> is not <code>0</code> and not <code>1</code>. </p>

</div>
</div>
<a class="anchor" id="ga4d5688759ce705c80ffad199b89bdd93"></a><!-- doxytag: member="bsl::bitset::bitset" ref="ga4d5688759ce705c80ffad199b89bdd93" args="(const bsl::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt; &amp;str, typename bsl::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type pos=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class CHAR_TYPE , class TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::bitset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type&nbsp;</td>
          <td class="paramname"> <em>pos</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga959ff227f22d9ee67d8ef52dac530844"></a><!-- doxytag: member="bsl::bitset::bitset" ref="ga959ff227f22d9ee67d8ef52dac530844" args="(const bsl::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt; &amp;str, typename bsl::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type pos, typename bsl::basic_string&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class CHAR_TYPE , class TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::bitset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a>&lt; CHAR_TYPE, TRAITS, ALLOCATOR &gt;::size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a bitset with its first <code>M</code> bit positions correspond to the characters in the specified <code>pos</code> of the specified <code>str</code>. <code>M</code> is the smaller of the parameterized <code>N</code> and <code>str.length()</code>. If <code>M &lt; N</code>, the remaining bit positions are initialized to 0. The behavior is undefined if the characters in the specified <code>str</code> is not 0 and not 1. </p>

</div>
</div>
<a class="anchor" id="gaeeec8b1e4e60bc3437d550221df90da4"></a><!-- doxytag: member="bsl::bitset::operator&amp;=" ref="gaeeec8b1e4e60bc3437d550221df90da4" args="(const bitset &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset&amp; <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear each bit of this bitset for each corresponding bit that is 0 in the specified <code>rhs</code>, and leaves all other bits unchanged. Return a reference to this modifiable bitset. Note that this is equivalent to a bitwise OR. </p>

</div>
</div>
<a class="anchor" id="ga4c1a37daf57257c976ff0cd1f9deec3f"></a><!-- doxytag: member="bsl::bitset::operator|=" ref="ga4c1a37daf57257c976ff0cd1f9deec3f" args="(const bitset &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset&amp; <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set each bit of this bitset for each corresponding bit that is 1 in the specified <code>rhs</code>, and leaves all other bits unchanged. Return a reference to this modifiable bitset. Note that this is equivalent to a bitwise AND. </p>

</div>
</div>
<a class="anchor" id="ga3834881fe0e5556459deaa97a98e56b0"></a><!-- doxytag: member="bsl::bitset::operator^=" ref="ga3834881fe0e5556459deaa97a98e56b0" args="(const bitset &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset&amp; <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Toggle each bit of this bitset for each corresponding bit that is 1 in the specified <code>rhs</code>, and leaves all other bits unchanged. Return a reference to this modifiable bitset. Note that this is equivalent to a bitwise XOR. </p>

</div>
</div>
<a class="anchor" id="gad528d8380dc10645204f63e16ac403eb"></a><!-- doxytag: member="bsl::bitset::operator&lt;&lt;=" ref="gad528d8380dc10645204f63e16ac403eb" args="(std::size_t pos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset&amp; <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shift the bits of this bitset left (towards the most significant bit) by the specified <code>pos</code> and return a reference to this modifiable bitset. For all bits with position I where <code>I &lt;= pos</code>, the new value is 0. The behavior is undefined unless <code>pos &lt;= N</code>. </p>

</div>
</div>
<a class="anchor" id="gae5028ddd47321df47e4a583cc735b49a"></a><!-- doxytag: member="bsl::bitset::operator&gt;&gt;=" ref="gae5028ddd47321df47e4a583cc735b49a" args="(std::size_t pos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset&amp; <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shift the bits of this bitset right (towards the least significant bit) by the specified <code>pos</code> and return a reference to this modifiable bitset. For all bits with position I where <code>I &gt; N - pos</code>, the new value is 0. The behavior is undefined unless <code>pos &lt;= N</code>. </p>

</div>
</div>
<a class="anchor" id="ga7402a8158a32511d16d1289645cb1854"></a><!-- doxytag: member="bsl::bitset::flip" ref="ga7402a8158a32511d16d1289645cb1854" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset&amp; <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::flip </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Toggle all bits of this bitset and return a reference to this modifiable bitset. </p>

</div>
</div>
<a class="anchor" id="ga9dc530c12dc97a1b8d6df52b3579ef07"></a><!-- doxytag: member="bsl::bitset::flip" ref="ga9dc530c12dc97a1b8d6df52b3579ef07" args="(std::size_t pos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset&amp; <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::flip </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Toggle the bit at the specified <code>pos</code> of this bitset and return a reference to this modifiable bitset. </p>

</div>
</div>
<a class="anchor" id="ga6fc61fbd9acbea27f4f15e901e941ae1"></a><!-- doxytag: member="bsl::bitset::reset" ref="ga6fc61fbd9acbea27f4f15e901e941ae1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset&amp; <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set all bits of this bitset to 0 and return a reference to this modifiable bitset. </p>

</div>
</div>
<a class="anchor" id="ga423e8679355ea9e56a2ddfda712222f6"></a><!-- doxytag: member="bsl::bitset::reset" ref="ga423e8679355ea9e56a2ddfda712222f6" args="(std::size_t pos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset&amp; <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the bit at the specified <code>pos</code> of this bitset to 0 and return a reference to this modifiable bitset. </p>

</div>
</div>
<a class="anchor" id="ga0bcfa36ddb4d9acbc8083053dfc676c2"></a><!-- doxytag: member="bsl::bitset::set" ref="ga0bcfa36ddb4d9acbc8083053dfc676c2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset&amp; <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::set </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set all bits of this bitset to 1 and return a reference to this modifiable bitset. </p>

</div>
</div>
<a class="anchor" id="ga4241ccdeb3d61880677bc28f644a14ca"></a><!-- doxytag: member="bsl::bitset::set" ref="ga4241ccdeb3d61880677bc28f644a14ca" args="(std::size_t pos, int val=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset&amp; <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::set </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>val</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the bit at the specified <code>pos</code> of this bitset to 1 and return a reference to this modifiable bitset. Optionally specify <code>val</code> as the value to set the bit. If <code>val</code> is non-zero, the bit is set to 1, otherwise the bit is set to 0. </p>

</div>
</div>
<a class="anchor" id="ga58e4f6c410d6871938f27c3615e37dc9"></a><!-- doxytag: member="bsl::bitset::operator[]" ref="ga58e4f6c410d6871938f27c3615e37dc9" args="(std::size_t pos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code>reference</code> to the modifiable bit position at the specified <code>pos</code>. </p>

</div>
</div>
<a class="anchor" id="ga294bcb6479efaf385ef2f9955b40f0d2"></a><!-- doxytag: member="bsl::bitset::operator&lt;&lt;" ref="ga294bcb6479efaf385ef2f9955b40f0d2" args="(std::size_t pos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a bitset constructed from shifting this bitset left by the specified <code>pos</code>. </p>

</div>
</div>
<a class="anchor" id="gaaa80d19b0fb73ee5d915b166f83c836b"></a><!-- doxytag: member="bsl::bitset::operator&gt;&gt;" ref="gaaa80d19b0fb73ee5d915b166f83c836b" args="(std::size_t pos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a bitset constructed from shifting this bitset right by the specified <code>pos</code>. </p>

</div>
</div>
<a class="anchor" id="gacccb4db03581bad09809fb4bfef55fee"></a><!-- doxytag: member="bsl::bitset::operator~" ref="gacccb4db03581bad09809fb4bfef55fee" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::operator~ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Toggle all bits of this bitset and return a reference to this modifiable bitset. </p>

</div>
</div>
<a class="anchor" id="gab426b26632ff4b30da79c666bddb430f"></a><!-- doxytag: member="bsl::bitset::to_string" ref="gab426b26632ff4b30da79c666bddb430f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;class CHAR_TYPE , class TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt; <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::to_string </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> representation of this bitset, where bit value 1 is represented with <code>1</code> and bit value 0 is represented with <code>0</code>. The most-significant bit is placed at the beginning of the string, and the least-significant bit is placed at the end of the string. </p>

</div>
</div>
<a class="anchor" id="ga528dd8b88402323b356c15a029277757"></a><!-- doxytag: member="bsl::bitset::operator[]" ref="ga528dd8b88402323b356c15a029277757" args="(std::size_t pos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the value of the bit position at the specified <code>pos</code>. </p>

</div>
</div>
<a class="anchor" id="gafe2f16c98874032583b3b3dfa37afcfc"></a><!-- doxytag: member="bsl::bitset::operator==" ref="gafe2f16c98874032583b3b3dfa37afcfc" args="(const bitset &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>rhs</code> has the same value as this bitset and <code>false</code> otherwise. Two bitsets have the same value when the sequence and value of bits they hold are the same. </p>

</div>
</div>
<a class="anchor" id="ga6921ff4be26e8547903e217932e401a1"></a><!-- doxytag: member="bsl::bitset::operator!=" ref="ga6921ff4be26e8547903e217932e401a1" args="(const bitset &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1bitset.html">bitset</a>&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>rhs</code> do not have the same value as this bitset and <code>false</code> otherwise. Two bitset do not have the same value when either the sequence or the value of bits they hold are not the same. </p>

</div>
</div>
<a class="anchor" id="gabdf1741abbe2a4fb4ff2c2a16c27003d"></a><!-- doxytag: member="bsl::bitset::any" ref="gabdf1741abbe2a4fb4ff2c2a16c27003d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::any </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if any of the bits in this bitset has the value of 1 and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga9dc00511ea32aa857eda89980759ea21"></a><!-- doxytag: member="bsl::bitset::none" ref="ga9dc00511ea32aa857eda89980759ea21" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::none </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if all the bits in this bitset has the value of 0 and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga9fd0d05b1ba2ab1dd55b7756fabe3fc8"></a><!-- doxytag: member="bsl::bitset::size" ref="ga9fd0d05b1ba2ab1dd55b7756fabe3fc8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of bits this bitset holds. </p>

</div>
</div>
<a class="anchor" id="ga04b4e7536481f87961d5680978a101cf"></a><!-- doxytag: member="bsl::bitset::count" ref="ga04b4e7536481f87961d5680978a101cf" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of bits in this bitset that have the value of 1. </p>

</div>
</div>
<a class="anchor" id="ga0f468eb799a47dd9783b6d600f79ee14"></a><!-- doxytag: member="bsl::bitset::test" ref="ga0f468eb799a47dd9783b6d600f79ee14" args="(size_t pos) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::test </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the bit at the specified <code>pos</code> has the value of 1 and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga0c5baa02e3100eb328ad1e0440dce78b"></a><!-- doxytag: member="bsl::bitset::to_ulong" ref="ga0c5baa02e3100eb328ad1e0440dce78b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a>&lt; N &gt;::to_ulong </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an <code>unsigned</code> <code>long</code> value that has the same bit value as the bitset. Note that the behavior is undefined if the bitset cannot be represented as an <code>unsigned</code> <code>long</code>. </p>

</div>
</div>
<a class="anchor" id="ga060694dd688617141953e388c40853ab"></a><!-- doxytag: member="bsl::operator&amp;" ref="ga060694dd688617141953e388c40853ab" args="(const bitset&lt; N &gt; &amp;lhs, const bitset&lt; N &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset&lt;N&gt; bsl::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const bitset&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitset&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code>bitset</code> that results from a bitwise AND of the specified <code>lhs</code> and <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="ga600580f51a11bd8cebfc76701b8b95fd"></a><!-- doxytag: member="bsl::operator|" ref="ga600580f51a11bd8cebfc76701b8b95fd" args="(const bitset&lt; N &gt; &amp;lhs, const bitset&lt; N &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset&lt;N&gt; bsl::operator| </td>
          <td>(</td>
          <td class="paramtype">const bitset&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitset&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code>bitset</code> that results from a bitwise OR of the specified <code>lhs</code> and <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="ga647dad04e0c0bc7a4878b53acc99fb40"></a><!-- doxytag: member="bsl::operator^" ref="ga647dad04e0c0bc7a4878b53acc99fb40" args="(const bitset&lt; N &gt; &amp;lhs, const bitset&lt; N &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bitset&lt;N&gt; bsl::operator^ </td>
          <td>(</td>
          <td class="paramtype">const bitset&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitset&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code>bitset</code> that results from a bitwise XOR of the specified <code>lhs</code> and <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="ga9594d63ffa3d8d079eb96e3ff77ee16e"></a><!-- doxytag: member="bsl::operator&gt;&gt;" ref="ga9594d63ffa3d8d079eb96e3ff77ee16e" args="(std::basic_istream&lt; CHAR_TYPE, TRAITS &gt; &amp;is, bitset&lt; N &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class TRAITS , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_istream&lt;CHAR_TYPE, TRAITS&gt;&amp; bsl::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_istream&lt; CHAR_TYPE, TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bitset&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga85fb82ba96cea34775f63b967f323931"></a><!-- doxytag: member="bsl::operator&lt;&lt;" ref="ga85fb82ba96cea34775f63b967f323931" args="(std::basic_ostream&lt; CHAR_TYPE, TRAITS &gt; &amp;os, const bitset&lt; N &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class TRAITS , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;CHAR_TYPE, TRAITS&gt;&amp; bsl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; CHAR_TYPE, TRAITS &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bitset&lt; N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Friends</h2>
<a class="anchor" id="ga811ee22ffe70f7ebb2829f620f369cdb"></a><!-- doxytag: member="bsl::bitset::reference" ref="ga811ee22ffe70f7ebb2829f620f369cdb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class reference<code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:04 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
