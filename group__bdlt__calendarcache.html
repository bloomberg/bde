<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlt_calendarcache Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlt_calendarcache<br/>
<small>
[<a class="el" href="group__bdlt.html">Package bdlt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an efficient cache for read-only <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> objects.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html">bdlt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Using a <code>bdlt::CalendarCache</code></a> </li>
<li>
<a href="#3.2.2">Example 2: A Calendar Cache with a Timeout</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an efficient cache for read-only <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> objects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlt_1_1CalendarCache.html">bdlt::CalendarCache</a> </td><td>cache for read-only calendars that are loaded on demand  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlt__calendar.html" title="Provide fast repository for accessing weekend/holiday information.">Component bdlt_calendar</a>, <a class="el" href="group__bdlt__calendarloader.html" title="Provide a protocol (or pure interface) for loading calendars.">Component bdlt_calendarloader</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines the <code><a class="el" href="classbdlt_1_1CalendarCache.html">bdlt::CalendarCache</a></code> class, a cache for read-only <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> objects. The <code><a class="el" href="classbdlt_1_1CalendarCache.html">bdlt::CalendarCache</a></code> class defines two methods for fetching calendars from the cache: a manipulator called <code>getCalendar</code> and an accessor called <code>lookupCalendar</code>. Calendars are identified by name using C-style strings, and both retrieval methods return a <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;const <a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a>&gt;</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The first time a calendar is requested from the cache using the <code>getCalendar</code> manipulator, the identified calendar is loaded into the cache using the loader that was supplied upon construction of the cache (see <code>bdlt_calendarloader</code>); a reference to that newly-loaded calendar is then returned. Subsequent requests for the same calendar, using either the <code>getCalendar</code> or <code>lookupCalendar</code> method, are efficiently satisfied by returning references to the cached instance. The <code>lookupCalendar</code> accessor differs from the <code>getCalendar</code> manipulator in that when a request is made through the accessor for a calendar that is <em>not</em> present in the cache, the calendar is not loaded as a side-effect. In this case, an empty <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;const <a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a>&gt;</code> is returned instead, which is effectively a null pointer. Note that the calendar-naming convention in effect for a given cache is determined by the concrete loader supplied at construction of the cache. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Calendars stored in a cache can be explicitly invalidated; the <code>invalidate</code> method is used to invalidate a single calendar and <code>invalidateAll</code> invalidates all calendars in the cache. Invalidated calendars are removed from the cache. However, a calendar that has been invalidated in the cache remains valid to all outstanding references to it, obtained via earlier calls to the <code>getCalendar</code> and <code>lookupCalendar</code> methods, until all of those references have been destroyed. Note that a subsequent request, using the <code>getCalendar</code> manipulator, for a calendar that has been invalidated incurs the overhead of once again loading that calendar into the cache. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Calendars can also be invalidated on the basis of a timeout. To use this feature of <code><a class="el" href="classbdlt_1_1CalendarCache.html">bdlt::CalendarCache</a></code>, a <code><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a></code> timeout must be supplied at construction. When a timeout is in effect for a cache, requests for a calendar from the cache using the <code>getCalendar</code> manipulator may incur the reloading of the calendar if the one in the cache has expired (i.e., the time interval defined by the timeout value has elapsed since the calendar was last loaded). In the case of the <code>lookupCalendar</code> accessor, an empty <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;const <a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a>&gt;</code> is returned if the requested calendar is found to have expired. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlt_1_1CalendarCache.html">bdlt::CalendarCache</a></code> class is fully thread-safe (see <code>bsldoc_glossary</code>) provided that the allocator supplied at construction and the default allocator in effect during the lifetime of cache objects are both fully thread-safe. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example illustrates how to use a <code><a class="el" href="classbdlt_1_1CalendarCache.html">bdlt::CalendarCache</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_a_bdlt~3A~3Acalendarcache"></a> <a class="anchor" id="usage.example_1~3A_using_a_bdlt~3A~3Acalendarcache"></a> <a class="anchor" id="description.usage.example_1~3A_using_a_bdlt~3A~3Acalendarcache"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using a bdlt::CalendarCache: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example shows basic use of a <code><a class="el" href="classbdlt_1_1CalendarCache.html">bdlt::CalendarCache</a></code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we assume a hypothetical calendar loader, <code>MyCalendarLoader</code>, the details of which are not important other than that it supports calendars identified by "DE", "FR", and "US", which nominally identify the major holidays in Germany, France, and the United States, respectively. Furthermore, we cite two specific dates of interest: 2011/07/04, which was a holiday in the US (Independence Day), but not in France, and 2011/07/14, which was a holiday in France (Bastille Day), but not in the US. Note that neither of these dates were holidays in Germany. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create a calendar loader, an instance of <code>MyCalendarLoader</code>, and use it, in turn, to create a cache. For the purposes of this example, it is sufficient to let the cache use the default allocator: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyCalendarLoader    loader;
  <a class="code" href="classbdlt_1_1CalendarCache.html">bdlt::CalendarCache</a> cache(&amp;loader);
</pre></div><br/>
<br/>
 Next, we retrieve the calendar <code>usA</code>, identified by "US", verify that the loading of that calendar into the cache was successful (<code>usA.get()</code> is non-null), and verify that 2011/07/04 is recognized as a holiday in the "US" calendar, whereas 2011/07/14 is not: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;const bdlt::Calendar&gt;</a> usA = cache.getCalendar(<span class="stringliteral">&quot;US&quot;</span>);

                            assert( usA.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
                            assert( usA-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7,  4)));
                            assert(!usA-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7, 14)));
</pre></div><br/>
<br/>
 Then, we fetch the calendar identified by "FR", this time verifying that 2011/07/14 is recognized as a holiday in the "FR" calendar, but 2011/07/04 is not: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;const bdlt::Calendar&gt;</a> frA = cache.getCalendar(<span class="stringliteral">&quot;FR&quot;</span>);

                            assert( frA.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
                            assert(!frA-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7,  4)));
                            assert( frA-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7, 14)));
</pre></div><br/>
<br/>
 Next, we retrieve the "FR" calendar again, this time via the <code>lookupCalendar</code> accessor, and note that the request is satisfied by the calendar that is already in the cache: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <a class="code" href="classbdlt_1_1CalendarCache.html">bdlt::CalendarCache</a>&amp; readonlyCache = cache;

  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;const bdlt::Calendar&gt;</a> frB =
                                          readonlyCache.<a class="code" href="classbdlt_1_1CalendarCache.html#adec8fe93f53cefa267746328a24d0bae">lookupCalendar</a>(<span class="stringliteral">&quot;FR&quot;</span>);

                            assert( frA.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>() == frB.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
</pre></div><br/>
<br/>
 Then, we invalidate the "US" calendar in the cache and immediately fetch it again. The call to <code>invalidate</code> removed the "US" calendar from the cache, so it had to be reloaded into the cache to satisfy the request: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> numInvalidated = cache.invalidate(<span class="stringliteral">&quot;US&quot;</span>);
                            assert(1 == numInvalidated);

  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;const bdlt::Calendar&gt;</a> usB = cache.getCalendar(<span class="stringliteral">&quot;US&quot;</span>);

                            assert( usB.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>() != usA.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
                            assert( usB.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
                            assert( usB-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7,  4)));
                            assert(!usB-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7, 14)));
</pre></div><br/>
<br/>
 Next, all calendars in the cache are invalidated, then reloaded: <br/>
<br/>
<div class="fragment"><pre class="fragment">  numInvalidated = cache.invalidateAll();
                            assert(2 == numInvalidated);

  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;const bdlt::Calendar&gt;</a> usC = cache.getCalendar(<span class="stringliteral">&quot;US&quot;</span>);

                            assert( usC.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>() != usA.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
                            assert( usC.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>() != usB.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
                            assert( usC.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
                            assert( usC-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7,  4)));
                            assert(!usC-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7, 14)));

  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;const bdlt::Calendar&gt;</a> frC = cache.getCalendar(<span class="stringliteral">&quot;FR&quot;</span>);

                            assert( frC.get() != frA.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
                            assert( frC.get() != frB.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
                            assert( frC.get());
                            assert(!frC-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7,  4)));
                            assert( frC-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7, 14)));
</pre></div><br/>
<br/>
 Now, verify that references to calendars that were invalidated in the cache are still valid for clients that obtained references to them before they were made invalid: <br/>
<br/>
<div class="fragment"><pre class="fragment">                            assert( usA-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7,  4)));
                            assert(!usA-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7, 14)));

                            assert( usB-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7,  4)));
                            assert(!usB-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7, 14)));

                            assert(!frA-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7,  4)));
                            assert( frA-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7, 14)));

                            assert(!frB-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7,  4)));
                            assert( frB-&gt;isHoliday(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2011, 7, 14)));
</pre></div><br/>
<br/>
 When <code>usA</code>, <code>usB</code>, <code>frA</code>, and <code>frB</code> go out of scope, the resources used by the calendars to which they refer are automatically reclaimed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, using the <code>lookupCalendar</code> accessor, we attempt to retrieve a calendar that has not yet been loaded into the cache, but that we <em>know</em> to be supported by the calendar loader. Since the <code>lookupCalendar</code> accessor does not load calendars into the cache as a side-effect, the request fails: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;const bdlt::Calendar&gt;</a> de =
                                          readonlyCache.<a class="code" href="classbdlt_1_1CalendarCache.html#adec8fe93f53cefa267746328a24d0bae">lookupCalendar</a>(<span class="stringliteral">&quot;DE&quot;</span>);

                            assert(!de.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_a_calendar_cache_with_a_timeout"></a> <a class="anchor" id="usage.example_2~3A_a_calendar_cache_with_a_timeout"></a> <a class="anchor" id="description.usage.example_2~3A_a_calendar_cache_with_a_timeout"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: A Calendar Cache with a Timeout: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This second example shows the affects on a <code><a class="el" href="classbdlt_1_1CalendarCache.html">bdlt::CalendarCache</a></code> object that is constructed to have a timeout value. Note that the following snippets of code assume a platform-independent <code>sleepSeconds</code> method that sleeps for the specified number of seconds. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create a calendar loader and a calendar cache. The cache is constructed to have a timeout of 3 seconds. Of course, such a short timeout is inappropriate for production use, but it is necessary for illustrating the affects of a timeout in this example. As in example 1 (above), we again let the cache use the default allocator: <br/>
<br/>
<div class="fragment"><pre class="fragment">  MyCalendarLoader           loader;
  <a class="code" href="classbdlt_1_1CalendarCache.html">bdlt::CalendarCache</a>        cache(&amp;loader, <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(3));
  <span class="keyword">const</span> <a class="code" href="classbdlt_1_1CalendarCache.html">bdlt::CalendarCache</a>&amp; readonlyCache = cache;
</pre></div><br/>
<br/>
 Next, we retrieve the calendar identified by "DE" from the cache: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;const bdlt::Calendar&gt;</a> deA = cache.getCalendar(<span class="stringliteral">&quot;DE&quot;</span>);

                            assert( deA.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
</pre></div><br/>
<br/>
 Next, we sleep for 2 seconds before retrieving the "FR" calendar: <br/>
<br/>
<div class="fragment"><pre class="fragment">  sleepSeconds(2);

  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;const bdlt::Calendar&gt;</a> frA = cache.getCalendar(<span class="stringliteral">&quot;FR&quot;</span>);

                            assert( frA.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
</pre></div><br/>
<br/>
 Next, we sleep for 2 more seconds before attempting to retrieve the "DE" calendar again, this time using the <code>lookupCalendar</code> accessor. Since the cumulative sleep time exceeds the timeout value established for the cache when it was constructed, the "DE" calendar has expired; hence, it has been removed from the cache: <br/>
<br/>
<div class="fragment"><pre class="fragment">  sleepSeconds(2);

  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;const bdlt::Calendar&gt;</a> deB =
                                          readonlyCache.<a class="code" href="classbdlt_1_1CalendarCache.html#adec8fe93f53cefa267746328a24d0bae">lookupCalendar</a>(<span class="stringliteral">&quot;DE&quot;</span>);

                            assert(!deB.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
</pre></div><br/>
<br/>
 Next, we verify that the "FR" calendar is still available in the cache: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;const bdlt::Calendar&gt;</a> frB =
                                          readonlyCache.<a class="code" href="classbdlt_1_1CalendarCache.html#adec8fe93f53cefa267746328a24d0bae">lookupCalendar</a>(<span class="stringliteral">&quot;FR&quot;</span>);

                            assert( frA.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>() == frB.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
</pre></div><br/>
<br/>
 Finally, we sleep for an additional 2 seconds and verify that the "FR" calendar has also expired: <br/>
<br/>
<div class="fragment"><pre class="fragment">  sleepSeconds(2);

  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;const bdlt::Calendar&gt;</a> frC =
                                          readonlyCache.<a class="code" href="classbdlt_1_1CalendarCache.html#adec8fe93f53cefa267746328a24d0bae">lookupCalendar</a>(<span class="stringliteral">&quot;FR&quot;</span>);

                            assert(!frC.<a class="code" href="classbsl_1_1shared__ptr.html#ae8abc020af5cf9058959a0963978ba07">get</a>());
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:49 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
