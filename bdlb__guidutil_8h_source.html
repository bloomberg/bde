<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bdlb_guidutil.h                                                    -*-C++-*-
#ifndef INCLUDED_BDLB_GUIDUTIL
#define INCLUDED_BDLB_GUIDUTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide functions that produce Universally Unique Identifiers.
//
//@CLASSES:
//  bdlb::GuidUtil: namespace for methods for creating UUIDs.
//
//@SEE ALSO: bdlb::Guid
//
//@DESCRIPTION: This component provides a struct, &#39;bdlb::GuidUtil&#39;, that
// serves as a namespace for utility functions that create and work with
// Globally Unique Identifiers (GUIDs).
//
///Grammar for GUIDs Used in &#39;GuidFromString&#39;
// ------------------------------------------
// This conversion performed by &#39;GuidFromString&#39; is intended to be used for
// GUIDs generated by external sources that have a variety of formats.
//
///GUID String Format
// ------------------
//..
// &lt;SPEC&gt;             ::=  &lt;BRACED GUID&gt;     |   &lt;GUID&gt;
//
// &lt;BRACED GUID&gt;      ::=  &#39;[&#39; &lt;GUID&gt; &#39;]&#39;    |   &#39;[ &#39; &lt;GUID&gt; &#39; ]&#39;
//                         &#39;{&#39; &lt;GUID&gt; &#39;}&#39;    |   &#39;{ &#39; &lt;GUID&gt; &#39; }&#39;
//
// &lt;GUID&gt;             ::=  &lt;FORMATED GUID&gt;   |   &lt;UNFORMATTED GUID&gt;
//
// &lt;FORMATED GUID&gt;    ::=  &lt;X&gt;{4} &#39;-&#39; &lt;X&gt;{2} &#39;-&#39; &lt;X&gt;{2} &#39;-&#39; &lt;X&gt;{2} &#39;-&#39; &lt;X&gt;{6}
//
// &lt;UNFORMATTED GUID&gt; ::=  &lt;X&gt;{16}
//
// &lt;X&gt;                ::=  [0123456789ABCDEFabcdef]{2}
//
// EXAMPLES:
// ---------
// { 87654321-AAAA-BBBB-CCCC-012345654321 }
// 00010203-0405-0607-0809-101112131415
// [00112233445566778899aAbBcCdDeEfF]
//..
//
///Usage
///-----
// Suppose we are building a system for managing records for employees in a
// large international firm.  These records have no natural field which can be
// used as a unique ID, so a GUID must be created for each employee.
//
// First let us define a value-type for employees.
//..
//  class MyEmployee {
//      // This class provides a value-semantic type to represent an employee
//      // record.  These records are for internal use only.
//..
// For the sake of brevity, we provide a limited amount of data in each record.
// We additionally show a very limited scope of functionality.
//..
//      // DATA
//      bsl::string  d_name;    // name of the employee
//      double       d_salary;  // salary in some common currency
//      bdlb::Guid d_guid;    // a GUID for the employee
//
//    public:
//      // CREATORS
//      MyEmployee(const string&amp; name, double salary);
//          // Create an object with the specified &#39;name&#39; and specified
//          //&#39;salary&#39;, generating a new GUID to represent the employee.
//
//      // ...
//
//      // ACCESORS
//      const bdlb::Guid&amp; Guid() const;
//          // Return the &#39;guid&#39; of this object.
//
//      const bsl::string&amp; name() const;
//          // Return the &#39;name&#39; of this object.
//
//      double salary() const;
//          // Return the &#39;salary&#39; of this object.
//      // ...
//  };
//..
// Next, we create free functions &#39;operator&lt;&#39; and &#39;operator==&#39; to allow
// comparison of &#39;MyEmployee&#39; objects.  We take advantage of the monotonically
// increasing nature of sequential GUIDs to implement these methods.
//..
//
//  bool operator== (const MyEmployee&amp; lhs, const MyEmployee&amp; rhs);
//      // Return &#39;true&#39; if the specified &#39;lhs&#39; object has the same value as
//      // the specified &#39;rhs&#39; object, and &#39;false&#39; otherwise.  Note that two
//      // &#39;MyEmployee&#39; objects have the same value if they have the same
//      // guid.
//
//  bool operator&lt; (const MyEmployee&amp; lhs, const MyEmployee&amp; rhs);
//      // Return &#39;true&#39; if the value of the specified &#39;lhs&#39; MyEmployee object
//      // is less than the value of the specified &#39;rhs&#39; MyEmployee object,
//      // and &#39;false&#39; otherwise.  A MyEmployee object is less than another if
//      // the guid is less than the other.
// ...
//
//  // CREATORS
//  MyEmployee::MyEmployee(const string&amp; name, double salary)
//  : d_name(name)
//  , d_salary(salary)
//  {
//      bdlb::GuidUtil::generate(&amp;d_guid);
//  }
//
//  // ACCESORS
//  const bdlb::Guid&amp; MyEmployee::Guid() const
//  {
//      return d_guid;
//  }
//
//  const bsl::string&amp; MyEmployee::name() const
//  {
//      return d_name;
//  }
//
//  double MyEmployee::salary() const
//  {
//      return d_salary;
//  }
//
//  // FREE FUNCTIONS
//  bool operator==(const MyEmployee&amp; lhs, const MyEmployee&amp; rhs)
//  {
//      return lhs.Guid() == rhs.Guid();
//  }
//
//  bool operator&lt;(const MyEmployee&amp; lhs, const MyEmployee&amp; rhs)
//  {
//       return lhs.Guid() &lt; rhs.Guid();
//  }
//..
// Next, we create some employees:
//..
//      MyEmployee e1(&quot;Foo Bar&quot;    , 1011970);
//      MyEmployee e2(&quot;John Doe&quot;   , 12345);
//      MyEmployee e3(&quot;Joe Six-pack&quot;, 1);
//..
// Finally, we verify that the generated GUIDs are unique.
//..
//      assert(e1 &lt; e2 || e2 &lt; e1);
//      assert(e2 &lt; e3 || e3 &lt; e2);
//      assert(e1 &lt; e3 || e3 &lt; e1);
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLB_GUID
#include &lt;bdlb_guid.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDDEF
#include &lt;bsl_cstddef.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

namespace BloombergLP {
namespace bdlb {

                              // ===============
                              // struct GuidUtil
                              // ===============

struct GuidUtil {
    // This &#39;struct&#39; provides a namespace for functions that create Universally
    // Unique Identifiers per RFC 4122 (http://www.ietf.org/rfc/rfc4122.txt).

    // CLASS METHODS
    static void generate(Guid *result, bsl::size_t numGuids = 1);
        // Generate a sequence of GUIDs meeting the RFC 4122 version 4
        // specification, and load the resulting GUIDs into the array referred
        // to by the specified &#39;result&#39;.  Optionally specify &#39;numGuids&#39;,
        // indicating the number of GUIDs to load into the &#39;result&#39; array.  If
        // &#39;numGuids&#39; is not supplied, a default of 1 is used.  An RFC 4122
        // version 4 GUID consists of 122 randomly generated bits, two
        // &#39;variant&#39; bits set to &#39;10&#39; and four &#39;version&#39; bits set to &#39;0100&#39;.
        // The behavior is undefined unless &#39;result&#39; refers to a contiguous
        // sequence of at least &#39;numGuids&#39; Guid objects.

    static void generate(unsigned char *result, bsl::size_t numGuids = 1);
        // Generate a sequence of GUIDs meeting the RFC 4122 version 4
        // specification, and load the bytes of the resulting GUIDs into the
        // array referred to by the specified &#39;result&#39;.  Optionally specify
        // &#39;numGuids&#39;, indicating the number of GUIDs to load into the &#39;result&#39;
        // array.  If &#39;numGuids&#39; is not supplied, a default of 1 is used.  An
        // RFC 4122 version 4 GUID consists of 122 randomly generated bits, two
        // &#39;variant&#39; bits set to &#39;10&#39; and four &#39;version&#39; bits set to &#39;0100&#39;.
        // The behavior is undefined unless &#39;result&#39; refers to a contiguous
        // sequence of at least &#39;16 * numGuids&#39; bytes.

    static Guid generate();
        // Generate and return a single GUID meeting the RFC 4122 version 4
        // specification, consisting of 122 randomly generated bits, two
        // &#39;variant&#39; bits set to &#39;10&#39; and four &#39;version&#39; bits set to &#39;0100&#39;.

    static int guidFromString(Guid *result, bslstl::StringRef guidString);
        // Parse the specified &#39;guidString&#39; (in {GUID String Format}) and load
        // its value into the specified &#39;result&#39;.  Return 0 if &#39;result&#39;
        // successfully loaded, and non-zero otherwise.

    static Guid guidFromString(bslstl::StringRef guidString);
        // Parse the specified &#39;guidString&#39; (in {GUID String Format}) and
        // return the converted GUID, or a default-constructed Guid if the
        // string is improperly formatted.

    static void guidToString(bsl::string *result, const Guid&amp; guid);
        // Serialize the specified &#39;guid&#39; into the specified &#39;result&#39;.  The
        // &#39;result&#39; string will be in a format suitable for &#39;guidFromString&#39;.

    static bsl::string guidToString(const Guid&amp; guid);
        // Convert the specified &#39;guid&#39; into a string suitable for
        // &#39;guidFromString&#39;, and return the string.

    static int getVersion(const bdlb::Guid&amp; guid);
        // Return the version of the specified &#39;guid&#39; object.  The behavior is
        // undefined unless the contents of the &#39;guid&#39; object are compliant
        // with RFC 4122.

    static bsls::Types::Uint64 getMostSignificantBits(const Guid&amp; guid);
        // Return the most significant 8 bytes of the specified &#39;guid&#39;.

    static bsls::Types::Uint64 getLeastSignificantBits(const Guid&amp; guid);
        // Return the least significant 8 bytes of the specified &#39;guid&#39;.
};

// ============================================================================
//                      INLINE DEFINITIONS
// ============================================================================

                              // ---------------
                              // struct GuidUtil
                              // ---------------
// CLASS METHODS
inline
int GuidUtil::getVersion(const Guid&amp; guid)
{
    return (guid[6] &amp; 0xF0) &gt;&gt; 4;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
