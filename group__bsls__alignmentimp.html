<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bsls_alignmentimp Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bsls_alignmentimp<br/>
<small>
[<a class="el" href="group__bsls.html">Package bsls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide implementation meta-functions for alignment computation.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Computing Alignment for a Type</a> </li>
<li>
<a href="#3.2">Computing a Type Requiring an Alignment</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: <code>AlignmentImpCalc</code> Template</a> </li>
<li>
<a href="#3.3.2">Example 2: Types Supporting <code>AlignmentToType</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide implementation meta-functions for alignment computation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbsls_1_1AlignmentImpCalc.html">bsls::AlignmentImpCalc</a> </td><td><code>TYPE</code> parameter to alignment <code>VALUE</code> map  </td></tr>
<tr>
<td><a class="el" href="structbsls_1_1AlignmentImpMatch.html">bsls::AlignmentImpMatch</a> </td><td>namespace for overloaded <code>match</code> functions  </td></tr>
<tr>
<td><a class="el" href="structbsls_1_1AlignmentImpPriorityToType.html">bsls::AlignmentImpPriorityToType</a> </td><td><code>PRIORITY</code> param to primitive type map  </td></tr>
<tr>
<td><a class="el" href="structbsls_1_1AlignmentImpTag.html">bsls::AlignmentImpTag</a> </td><td>unique type of size <code>SIZE</code> (parameter)  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bsls__alignmentfromtype.html" title="Provide a meta-function that maps a TYPE to its alignment.">Component bsls_alignmentfromtype</a>, <a class="el" href="group__bsls__alignmenttotype.html" title="Provide a meta-function mapping an ALIGNMENT to a primitive type.">Component bsls_alignmenttotype</a>, <a class="el" href="group__bsls__alignmentutil.html" title="Provide constants, types, and operations related to alignment.">Component bsls_alignmentutil</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a suite of template meta-functions that can be used to compute (at compile-time) various platform-dependent alignment information. The clients of this component are expected to be <code>bsls</code> components such as <code>bsls_alignmentfromtype</code>, <code>bsls_alignmenttotype</code>, and <code>bsls_alignmentutil</code>. Other client code should use one of these <code>bsls</code> components instead of using this component directly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="computing_alignment_for_a_type"></a> <a class="anchor" id="description.computing_alignment_for_a_type"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Computing Alignment for a Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The compiler alignment for a given type, <code>T</code>, can be computed by creating a structure containing a single <code>char</code> member followed by a <code>T</code> member: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>X {
      <span class="keywordtype">char</span> d_c;
      T    d_t;
  };
</pre></div><br/>
<br/>
 The compiler lays this structure out in memory as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  +---+---+-------+
  |d_c| P |  d_t  |
  +---+---+-------+
</pre></div><br/>
<br/>
 where <code>P</code> is padding added by the compiler to ensure that <code>d_t</code> is properly aligned. The alignment for <code>T</code> is the number of bytes from the start of the structure to the beginning of <code>d_t</code>, which is also the total size of the structure minus the size of <code>d_t</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbsls_1_1AlignmentImpCalc.html">bsls::AlignmentImpCalc&lt;T&gt;::VALUE</a> == <span class="keyword">sizeof</span>(X) - <span class="keyword">sizeof</span>(T);
</pre></div><br/>
<br/>
 Since <code>sizeof</code> yields a compile-time constant, the alignment can be computed at compile time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="computing_a_type_requiring_an_alignment"></a> <a class="anchor" id="description.computing_a_type_requiring_an_alignment"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Computing a Type Requiring an Alignment: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A considerably more difficult compile-time computation supported by this component is that of determining a fundamental type with the same alignment requirements of a given type <code>T</code>. This involves computing the alignment for <code>T</code>, as above, and then performing an alignment-to-type lookup, all at compile time. The general principles of this computation follow. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We would like to create a template class that is specialized for each fundamental type's alignment. Unfortunately, multiple types will have the same alignment and the compiler would issue a diagnostic if the same specialization was defined more than once. To disambiguate, we create a "priority" class for each fundamental type that arbitrarily ranks that type relative to all of the other fundamental types. Each priority class is derived from the next-lower priority class. A set of overloaded functions are created such that, given two fundamental types with the same alignment, overload resolution will pick the one with the highest priority (i.e., the most-derived priority type). The <code>sizeof</code> operator and several template specializations are used to determine the compiler's choice of overloaded <code>match</code> function. The return value is mapped to a priority, which is, in turn, mapped to an appropriate primitive type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates the intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: AlignmentImpCalc Template: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose that we want to write a program that needs to calculate the alignment requirements of both user-defined types and built-in types. Further suppose that the program will run on a platform where the alignment requirement of <code>int</code> is 4 bytes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a <code>struct</code>, <code>MyStruct</code>, for which want to determine the alignment requirement: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>MyStruct {
      <span class="keywordtype">char</span>  d_c;
      <span class="keywordtype">int</span>   d_i;
      <span class="keywordtype">short</span> d_s;
  };
</pre></div><br/>
<br/>
 Note that <code>int</code> is the most alignment-demanding type within <code>MyStruct</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Now, we use <code>AlignmentImpCalc</code> to calculate the alignments of two types, <code>short</code> and the <code>MyStruct</code> we just defined: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> {
      SHORT_ALIGNMENT     = <a class="code" href="structbsls_1_1AlignmentImpCalc.html">bsls::AlignmentImpCalc&lt;short   &gt;::VALUE</a>,
      MY_STRUCT_ALIGNMENT = <a class="code" href="structbsls_1_1AlignmentImpCalc.html">bsls::AlignmentImpCalc&lt;MyStruct&gt;::VALUE</a> };
</pre></div><br/>
<br/>
 Finally, we observe the values of our alignments, we observe that the size of the 2 objects is a multiple of each object's alignment (which is true for all C++ types), and we observe that the size of <code>MyStruct</code> is greater than its alignment. <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(2 == SHORT_ALIGNMENT);
  assert(4 == MY_STRUCT_ALIGNMENT);

  assert(0 == <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>   ) % SHORT_ALIGNMENT);
  assert(0 == <span class="keyword">sizeof</span>(MyStruct) % MY_STRUCT_ALIGNMENT);

  assert(<span class="keyword">sizeof</span>(MyStruct) &gt; MY_STRUCT_ALIGNMENT);
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Types Supporting AlignmentToType: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we to be able to determine a fundamental or pointer type that has both its size and alignment requirement equal to the alignment requirement of a specified template parameter type. We can use the <code>AlignmentImpTag</code> <code>struct</code> template, the overloads of <code>AlignmentImpMatch::match</code> class method, the <code>AiignmentImp_Priority</code> template class, and the <code>AlignmentImpPrioriityToType</code> template class to do this calculation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a class template, <code>ConvertAlignmentToType</code>, that provides a <code>Type</code> alias to a fundamental or pointer type that has both its alignment requirement and size equal to the compile-time constant <code>ALIGNMENT</code> <code>int</code> parameter of the template. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> ALIGNMENT&gt;
  <span class="keyword">struct </span>ConvertAlignmentToType {
      <span class="comment">// This &#39;struct&#39; provides a &#39;typedef&#39;, &#39;Type&#39;, that aliases a primitive</span>
      <span class="comment">// type having the specified &#39;ALIGNMENT&#39; requirement and size.</span>

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE TYPES</span>
      <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structbsls_1_1AlignmentImp__Priority.html">bsls::AlignmentImpMatch::MaxPriority</a> MaxPriority;
          <span class="comment">// &#39;MaxPriority&#39; is a typedef to the &#39;AlignmentImp_Priority&#39;</span>
          <span class="comment">// template class having the highest permissible priority value.</span>

      <span class="keyword">typedef</span>          <a class="code" href="structbsls_1_1AlignmentImpTag.html">bsls::AlignmentImpTag&lt;ALIGNMENT&gt;</a>     Tag;
          <span class="comment">// &#39;Tag&#39; provides a typedef to the &#39;AlignmentImpTag&#39; class</span>
          <span class="comment">// configured with this &#39;struct&#39;s &#39;ALIGNMENT&#39; parameter.</span>

      <span class="keyword">enum</span> {
          <span class="comment">// Compute the priority of the primitive type corresponding to the</span>
          <span class="comment">// specified &#39;ALIGNMENT&#39;.  Many &#39;match&#39; functions are declared, and</span>
          <span class="comment">// at least one whose alignment and size fields are identical and</span>
          <span class="comment">// equal to &#39;ALIGNMENT&#39;.  Of those who match, the first match will</span>
          <span class="comment">// be the one with the highest priority &#39;AlignmentImp_Priority&#39;</span>
          <span class="comment">// arg.</span>

          PRIORITY = <span class="keyword">sizeof</span>(<a class="code" href="structbsls_1_1AlignmentImpMatch.html#a5f19800350a3639ab24ae6eaa58620c6">bsls::AlignmentImpMatch::match</a>(Tag(),
                                                           Tag(),
                                                           MaxPriority()))
      };

    <span class="keyword">public</span>:
      <span class="comment">// TYPES</span>
      <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structbsls_1_1AlignmentImpPriorityToType.html">bsls::AlignmentImpPriorityToType&lt;PRIORITY&gt;::Type</a> Type;
          <span class="comment">// Convert the &#39;PRIORITY&#39; value we calculated back to a type that</span>
          <span class="comment">// has the value &#39;ALIGNMENT&#39; for both its alignment and it&#39;s size.</span>
  };
</pre></div><br/>
<br/>
 Then, we define two user defined types on which we will use <code>ConvertAlignmentToType</code> on: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>MyStructA {
      <span class="keywordtype">short</span>  d_s;
      <span class="keywordtype">double</span> d_d;
      <span class="keywordtype">int</span>    d_i;
  };

  <span class="keyword">struct </span>MyStructB {
      <span class="keywordtype">double</span> d_d[20];
  };
</pre></div><br/>
<br/>
 Here, we calculate alignments for our 3 types with <code>AlignmentImpCalc</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">int</span> INT_ALIGNMENT = <a class="code" href="structbsls_1_1AlignmentImpCalc.html">bsls::AlignmentImpCalc&lt;int      &gt;::VALUE</a>;
  <span class="keyword">const</span> <span class="keywordtype">int</span> A_ALIGNMENT   = <a class="code" href="structbsls_1_1AlignmentImpCalc.html">bsls::AlignmentImpCalc&lt;MyStructA&gt;::VALUE</a>;
  <span class="keyword">const</span> <span class="keywordtype">int</span> B_ALIGNMENT   = <a class="code" href="structbsls_1_1AlignmentImpCalc.html">bsls::AlignmentImpCalc&lt;MyStructB&gt;::VALUE</a>;
</pre></div><br/>
<br/>
 Now, for each alignment requirement we just calculated, we utilize <code>ConvertAlignmentToType</code> to determine the fundamental or pointer type having both size and alignment requirement equal to the calculated alignment requirement: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> ConvertAlignmentToType&lt;INT_ALIGNMENT&gt;::Type IntAlignType;
  <span class="keyword">typedef</span> ConvertAlignmentToType&lt;A_ALIGNMENT  &gt;::Type ThisAlignType;
  <span class="keyword">typedef</span> ConvertAlignmentToType&lt;B_ALIGNMENT  &gt;::Type ThatAlignType;
</pre></div><br/>
<br/>
 Finally, we observe that the alignments of the <code>*AlignType</code>s are the same as the alignments of the types from which they are derived, and that all the type determined by <code>ConvertAlignmentToType</code> have sizes equal to their alignment requirements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(INT_ALIGNMENT == <a class="code" href="structbsls_1_1AlignmentImpCalc.html">bsls::AlignmentImpCalc&lt;IntAlignType &gt;::VALUE</a>);
  assert(A_ALIGNMENT   == <a class="code" href="structbsls_1_1AlignmentImpCalc.html">bsls::AlignmentImpCalc&lt;ThisAlignType&gt;::VALUE</a>);
  assert(B_ALIGNMENT   == <a class="code" href="structbsls_1_1AlignmentImpCalc.html">bsls::AlignmentImpCalc&lt;ThatAlignType&gt;::VALUE</a>);

  assert(INT_ALIGNMENT == <span class="keyword">sizeof</span>(IntAlignType));
  assert(A_ALIGNMENT   == <span class="keyword">sizeof</span>(ThisAlignType));
  assert(B_ALIGNMENT   == <span class="keyword">sizeof</span>(ThatAlignType));
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:42 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
