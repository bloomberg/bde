<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslalg_bidirectionallinklistutil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Component bslalg_bidirectionallinklistutil<br/>
<small>
[<a class="el" href="group__bslalg.html">Package bslalg</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide utilities to maintain bidirectional list data structures.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBloombergLP_1_1bslalg_1_1BidirectionalLinkListUtil.html">BloombergLP::bslalg::BidirectionalLinkListUtil</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslalg__bidirectionallinklistutil.html#gab774df61024c46ab5a3dfd8e1825377d">BloombergLP::bslalg::BidirectionalLinkListUtil::insertLinkAfterTarget</a> (BidirectionalLink *newNode, BidirectionalLink *target)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslalg__bidirectionallinklistutil.html#gaa7610e8bcc6ee1c7db73035d111a28b5">BloombergLP::bslalg::BidirectionalLinkListUtil::isWellFormed</a> (BidirectionalLink *head, BidirectionalLink *tail)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslalg__bidirectionallinklistutil.html#ga62764f46ad27a4ef2cc6389bffeaff25">BloombergLP::bslalg::BidirectionalLinkListUtil::spliceListBeforeTarget</a> (BidirectionalLink *first, BidirectionalLink *last, BidirectionalLink *target)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslalg__bidirectionallinklistutil.html#ga55c04daf72aa20fa514e261813e6a85b">BloombergLP::bslalg::BidirectionalLinkListUtil::unlink</a> (BidirectionalLink *node)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Creating and Using a List Template Class</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide utilities to maintain bidirectional list data structures. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structBloombergLP_1_1bslalg_1_1BidirectionalLinkListUtil.html">bslalg::BidirectionalLinkListUtil</a> </td><td>utilities to maintain linked lists  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslalg__bidirectionallink.html" title="Provide a basic link type for building doubly-linked lists.">Component bslalg_bidirectionallink</a>, <a class="el" href="group__bslalg__hashtableimputil.html" title="Provide algorithms for implementing a hash table.">Component bslalg_hashtableimputil</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a namespace, <code><a class="el" href="structBloombergLP_1_1bslalg_1_1BidirectionalLinkListUtil.html">bslalg::BidirectionalLinkListUtil</a></code>, containing utility functions for operating on doubly linked lists with nodes of type <code><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a></code>. The operations assume that the linked lists are either 0 terminated (on both ends) or terminate with sentinel (valid) nodes. The main operations include insertion and removal of a node from a list of nodes, and the <em>splicing</em> of ranges from one list into another one. Splicing is the operation of moving a sub-list, or range, of elements from one linked list and into a second list, at a specified position. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_creating_and_using_a_list_template_class"></a> <a class="anchor" id="usage.example_1~3A_creating_and_using_a_list_template_class"></a> <a class="anchor" id="description.usage.example_1~3A_creating_and_using_a_list_template_class"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating and Using a List Template Class: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, since <code>Link</code> neither has a constructor nor is a POD (which would make aggregate initialization possible), we create a function <code>makeLink</code> to assemble a link from two pointers: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Link makeLink(Link *prev, Link *next)
  {
      Link result;
      result.setPreviousLink(prev);
      result.setNextLink(    next);

      <span class="keywordflow">return</span> result;
  }
</pre></div><br/>
<br/>
 Then, we create a function that will, passed two links that are endpoints of a linked list from the specified <code>first</code> to <code>last</code> though the <code>nextLink</code> pointers, count the number of nodes in the list including both endpoints. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> length(Link *first, Link *last)
  {
      <span class="keywordtype">int</span> result = 0;
      Link *p = first;
      <span class="keywordflow">while</span> (p &amp;&amp; ++result &amp;&amp; last != p) {
          p = p-&gt;nextLink();
      }

      <span class="keywordflow">return</span> result;
  }
</pre></div><br/>
<br/>
 Next, in our <code>main</code>, we declare a <code>typedef</code> for the component name and a a constant <code>invalid</code> garbage pointer we use when we want data to be garbage. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> BidirectionalLinkListUtil Util;
  Link * <span class="keyword">const</span> invalid = (Link *) 0XBADDEED5;
</pre></div><br/>
<br/>
 Then, we create a linked list of links and use <code>isWellFormed</code> to verify that it is well formed, and call the <code>length</code> method we just created to verify its length. <br/>
<br/>
<div class="fragment"><pre class="fragment">  Link usageData[] = {
      makeLink(0,             &amp;usageData[1]),
      makeLink(&amp;usageData[0], &amp;usageData[2]),
      makeLink(&amp;usageData[1], &amp;usageData[3]),
      makeLink(&amp;usageData[2], 0            )  };

  assert(Util::isWellFormed(      &amp;usageData[0], &amp;usageData[3]));
  assert(4 == length(&amp;usageData[0], &amp;usageData[3]));
</pre></div><br/>
<br/>
 Next, we create two new links <code>front</code> and <code>back</code>, and initialize them with garbage: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Link front = makeLink(invalid, invalid);
  Link back  = makeLink(invalid, invalid);
</pre></div><br/>
<br/>
 Then, we use our component's <code>insertLinkBeforeTarget</code> and <code>insertLinkAfterTarget</code> to concatenate <code>front</code> to the front of the list and <code>back</code> to its rear: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Util::insertLinkBeforeTarget(&amp;front, &amp;usageData[0]);
  Util::insertLinkAfterTarget( &amp;back,  &amp;usageData[3]);
</pre></div><br/>
<br/>
 Next, We examine the new list and verify we now have a well-formed list, 2 longer than the old list: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == front.previousLink());
  assert(0 == back .nextLink());
  assert(Util::isWellFormed(          &amp;front, &amp;back));
  assert(6 == length(&amp;front, &amp;back));
</pre></div><br/>
<br/>
 Then, we use our component's <code>unlink</code> method to remove two nodes from our list. Note that the state of the removed nodes is undefined: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Util::unlink(&amp;usageData[1]);
  Util::unlink(&amp;usageData[3]);
</pre></div><br/>
<br/>
 Next, we verify that the new list is well formed and 2 elements shorter than it was before we removed those two nodes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(Util::isWellFormed(&amp;front, &amp;back));
  assert(4 == length(&amp;front, &amp;back));
</pre></div><br/>
<br/>
 Then, we weave the two discarded nodes into a new, second list of two nodes, and use <code>isWellFormed</code> and <code>length</code> to verify it is as we expect: <br/>
<br/>
<div class="fragment"><pre class="fragment">  usageData[1] = makeLink(0, &amp;usageData[3]);
  usageData[3] = makeLink(&amp;usageData[1], 0);
  assert(Util::isWellFormed(&amp;usageData[1], &amp;usageData[3]));
  assert(2 ==        length(&amp;usageData[1], &amp;usageData[3]));
</pre></div><br/>
<br/>
 Next, we use our component's <code>spliceListBeforeTarget</code> method to remove the middle nodes from the longer list and append them to the end of shorter list. Note that the splicing function not only adds the sequence to the new list, it also splices the list the sequence is removed from so that both are well-formed lists: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Util::spliceListBeforeTarget(&amp;usageData[0],
                               &amp;usageData[2],
                               &amp;usageData[3]);
</pre></div><br/>
<br/>
 Then, we use <code>isWellFormed</code> and <code>length</code> to verify the state of our two lists: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(Util::isWellFormed(&amp;usageData[1], &amp;usageData[3]));
  assert(4 ==        length(&amp;usageData[1], &amp;usageData[3]));

  assert(Util::isWellFormed(&amp;front, &amp;back));
  assert(2 ==        length(&amp;front, &amp;back));
</pre></div><br/>
<br/>
 Next, we call <code>spliceListBeforeTarget</code> again to join our two lists into one: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Util::spliceListBeforeTarget(&amp;usageData[1],
                               &amp;usageData[3],
                               &amp;back);
</pre></div><br/>
<br/>
 Now, we use <code>isWellFormed</code> and <code>length</code> to verify the state of our one remaining list: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(Util::isWellFormed(&amp;front, &amp;back));
  assert(6 ==        length(&amp;front, &amp;back));
  assert(0 == front.previousLink());
  assert(0 == back .nextLink());
</pre></div><br/>
<br/>
 Finally, we traverse our list in both directions, examining each node to verify all the links and that the sequence is as expected: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Link *p = &amp;front;
  assert(0 == p-&gt;previousLink());
  p = p-&gt;nextLink();
  assert(&amp;usageData[1] == p);
  p = p-&gt;nextLink();
  assert(&amp;usageData[0] == p);
  p = p-&gt;nextLink();
  assert(&amp;usageData[2] == p);
  p = p-&gt;nextLink();
  assert(&amp;usageData[3] == p);
  p = p-&gt;nextLink();
  assert(&amp;back         == p);
  assert(0 == p-&gt;nextLink());

  p = p-&gt;previousLink();
  assert(&amp;usageData[3] == p);
  p = p-&gt;previousLink();
  assert(&amp;usageData[2] == p);
  p = p-&gt;previousLink();
  assert(&amp;usageData[0] == p);
  p = p-&gt;previousLink();
  assert(&amp;usageData[1] == p);
  p = p-&gt;previousLink();
  assert(&amp;front        == p);
  assert(0 == p-&gt;previousLink());
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gab774df61024c46ab5a3dfd8e1825377d"></a><!-- doxytag: member="BloombergLP::bslalg::BidirectionalLinkListUtil::insertLinkAfterTarget" ref="gab774df61024c46ab5a3dfd8e1825377d" args="(BidirectionalLink *newNode, BidirectionalLink *target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void BloombergLP::bslalg::BidirectionalLinkListUtil::insertLinkAfterTarget </td>
          <td>(</td>
          <td class="paramtype">BidirectionalLink *&nbsp;</td>
          <td class="paramname"> <em>newNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalLink *&nbsp;</td>
          <td class="paramname"> <em>target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>newNode</code> after the specified <code>target</code> node in the linked list that contains <code>target</code>. If the node following <code>target</code> is 0, then set the <code>nextLink</code> attribute of <code>newNode</code> to 0. After successful execution of this function the values of the <code>previousLink</code> and <code>nextLink</code> attributes of all the links in the list appropriately reflect the operation. The behavior is undefined unless <code>0 != newNode</code> and <code>0 != target</code>. The behavior is also undefined unless <code>0 == target-&gt;nextLink()</code> is true or <code>isWellFormed(target, target-&gt;nextLink())</code> are true. </p>

</div>
</div>
<a class="anchor" id="gaa7610e8bcc6ee1c7db73035d111a28b5"></a><!-- doxytag: member="BloombergLP::bslalg::BidirectionalLinkListUtil::isWellFormed" ref="gaa7610e8bcc6ee1c7db73035d111a28b5" args="(BidirectionalLink *head, BidirectionalLink *tail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool BloombergLP::bslalg::BidirectionalLinkListUtil::isWellFormed </td>
          <td>(</td>
          <td class="paramtype">BidirectionalLink *&nbsp;</td>
          <td class="paramname"> <em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalLink *&nbsp;</td>
          <td class="paramname"> <em>tail</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the bidirectional list starting from the specified <code>head</code>, and ending with the specified <code>tail</code> is well formed. A bidirectional list is well formed if <code>tail == head</code> (0 values are allowed) or all of the following conditions are met (note that <code>head</code> is renamed to <code>h</code> and <code>tail</code> to <code>t</code> for brevity):</p>
<ol>
<li>
<code>h</code> and <code>t</code> are valid addresses.  </li>
<li>
<code>h-&gt;nextLink()-&gt;previousLink() == h</code> is true.  </li>
<li>
<code>!h-&gt;previousLink() || h-&gt;previousLink()-&gt;nextLink() == h</code> is true.  </li>
<li>
<code>t-&gt;previousLink()-&gt;nextLink() == t</code> is true.  </li>
<li>
<code>!t-&gt;nextLink() || t-&gt;nextLink()-&gt;previousLink() == t</code> is true.  </li>
<li>
For each <code>link</code> in the list different than <code>h</code> and <code>t</code> both <code>link-&gt;nextLink()-&gt;previousLink() == link</code> and <code>link-&gt;previousLink()-&gt;nextLink() == link</code> are true.  </li>
</ol>
<p>The behavior is undefined unless <code>tail</code> can be reached from <code>head</code> following the chain of <code>nextLink</code> attributes of all the nodes in the open range <code>[head, tail)</code>. </p>

</div>
</div>
<a class="anchor" id="ga62764f46ad27a4ef2cc6389bffeaff25"></a><!-- doxytag: member="BloombergLP::bslalg::BidirectionalLinkListUtil::spliceListBeforeTarget" ref="ga62764f46ad27a4ef2cc6389bffeaff25" args="(BidirectionalLink *first, BidirectionalLink *last, BidirectionalLink *target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void BloombergLP::bslalg::BidirectionalLinkListUtil::spliceListBeforeTarget </td>
          <td>(</td>
          <td class="paramtype">BidirectionalLink *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalLink *&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalLink *&nbsp;</td>
          <td class="paramname"> <em>target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unlink and move (splice) the elements of a doubly-linked list included in the closed range <code>[first, last]</code> out of their original list and into another doubly-linked list before the specified <code>target</code> node. If <code>target</code> is 0, then the the elements are extracted and form a new list such that <code>0 == first-&gt;previousLink()</code> and <code>0 == last-&gt;nextLink()</code> . After successful execution of this function the values of the <code>previousLink</code> and <code>nextLink</code> attributes of all the links in the origin and destination lists appropriately reflect the operation. The behavior is undefined unless both <code>first</code> and <code>last</code> are non-zero members of the same linked list; <code>first</code> precedes <code>last</code> in the list, or <code>first == last</code>; <code>target</code> is not a node contained in the closed range <code>[first, last]</code>; and <code>isWellFormed(first, last)</code> is true. </p>

</div>
</div>
<a class="anchor" id="ga55c04daf72aa20fa514e261813e6a85b"></a><!-- doxytag: member="BloombergLP::bslalg::BidirectionalLinkListUtil::unlink" ref="ga55c04daf72aa20fa514e261813e6a85b" args="(BidirectionalLink *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void BloombergLP::bslalg::BidirectionalLinkListUtil::unlink </td>
          <td>(</td>
          <td class="paramtype">BidirectionalLink *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unlink the specified <code>node</code> from the linked list of which it is a member. After successful execution of this function the values of the <code>previousLink</code> and <code>nextLink</code> attributes of all the links in the origin and destination lists appropriately reflect the operation Note that this method does <em>not</em> change the value for the <code>nextLink</code> and <code>previousLink</code> attributes of <code>node</code>. The behavior is undefined unless <code>!node-&gt;previousLink()</code>, <code>!node-&gt;nextLink()</code>, or <code>isWellFormed(node-&gt;previousLink(), node-&gt;nextLink())</code> are true. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:51 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
