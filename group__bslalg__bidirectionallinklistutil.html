<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslalg_bidirectionallinklistutil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Component bslalg_bidirectionallinklistutil<br/>
<small>
[<a class="el" href="group__bslalg.html">Package bslalg</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide utilities to maintain bidirectional list data structures.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
</table>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Creating and Using a List Template Class</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide utilities to maintain bidirectional list data structures. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>bslalg::BidirectionalLinkListUtil </td><td>utilities to maintain linked lists  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslalg__bidirectionallink.html" title="Provide a basic link type for building doubly-linked lists.">Component bslalg_bidirectionallink</a>, <a class="el" href="group__bslalg__hashtableimputil.html" title="Provide algorithms for implementing a hash table.">Component bslalg_hashtableimputil</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a namespace, <code>bslalg::BidirectionalLinkListUtil</code>, containing utility functions for operating on doubly linked lists with nodes of type <code><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a></code>. The operations assume that the linked lists are either 0 terminated (on both ends) or terminate with sentinel (valid) nodes. The main operations include insertion and removal of a node from a list of nodes, and the <em>splicing</em> of ranges from one list into another one. Splicing is the operation of moving a sub-list, or range, of elements from one linked list and into a second list, at a specified position. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_creating_and_using_a_list_template_class"></a> <a class="anchor" id="usage.example_1~3A_creating_and_using_a_list_template_class"></a> <a class="anchor" id="description.usage.example_1~3A_creating_and_using_a_list_template_class"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating and Using a List Template Class: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, since <code>Link</code> neither has a constructor nor is a POD (which would make aggregate initialization possible), we create a function <code>makeLink</code> to assemble a link from two pointers: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Link makeLink(Link *prev, Link *next)
  {
      Link result;
      result.setPreviousLink(prev);
      result.setNextLink(    next);

      <span class="keywordflow">return</span> result;
  }
</pre></div><br/>
<br/>
 Then, we create a function that will, passed two links that are endpoints of a linked list from the specified <code>first</code> to <code>last</code> though the <code>nextLink</code> pointers, count the number of nodes in the list including both endpoints. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> length(Link *first, Link *last)
  {
      <span class="keywordtype">int</span> result = 0;
      Link *p = first;
      <span class="keywordflow">while</span> (p &amp;&amp; ++result &amp;&amp; last != p) {
          p = p-&gt;nextLink();
      }

      <span class="keywordflow">return</span> result;
  }
</pre></div><br/>
<br/>
 Next, in our <code>main</code>, we declare a <code>typedef</code> for the component name and a a constant <code>invalid</code> garbage pointer we use when we want data to be garbage. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> BidirectionalLinkListUtil Util;
  Link * <span class="keyword">const</span> invalid = (Link *) 0XBADDEED5;
</pre></div><br/>
<br/>
 Then, we create a linked list of links and use <code>isWellFormed</code> to verify that it is well formed, and call the <code>length</code> method we just created to verify its length. <br/>
<br/>
<div class="fragment"><pre class="fragment">  Link usageData[] = {
      makeLink(0,             &amp;usageData[1]),
      makeLink(&amp;usageData[0], &amp;usageData[2]),
      makeLink(&amp;usageData[1], &amp;usageData[3]),
      makeLink(&amp;usageData[2], 0            )  };

  assert(Util::isWellFormed(      &amp;usageData[0], &amp;usageData[3]));
  assert(4 == length(&amp;usageData[0], &amp;usageData[3]));
</pre></div><br/>
<br/>
 Next, we create two new links <code>front</code> and <code>back</code>, and initialize them with garbage: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Link front = makeLink(invalid, invalid);
  Link back  = makeLink(invalid, invalid);
</pre></div><br/>
<br/>
 Then, we use our component's <code>insertLinkBeforeTarget</code> and <code>insertLinkAfterTarget</code> to concatenate <code>front</code> to the front of the list and <code>back</code> to its rear: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Util::insertLinkBeforeTarget(&amp;front, &amp;usageData[0]);
  Util::insertLinkAfterTarget( &amp;back,  &amp;usageData[3]);
</pre></div><br/>
<br/>
 Next, We examine the new list and verify we now have a well-formed list, 2 longer than the old list: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == front.previousLink());
  assert(0 == back .nextLink());
  assert(Util::isWellFormed(          &amp;front, &amp;back));
  assert(6 == length(&amp;front, &amp;back));
</pre></div><br/>
<br/>
 Then, we use our component's <code>unlink</code> method to remove two nodes from our list. Note that the state of the removed nodes is undefined: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Util::unlink(&amp;usageData[1]);
  Util::unlink(&amp;usageData[3]);
</pre></div><br/>
<br/>
 Next, we verify that the new list is well formed and 2 elements shorter than it was before we removed those two nodes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(Util::isWellFormed(&amp;front, &amp;back));
  assert(4 == length(&amp;front, &amp;back));
</pre></div><br/>
<br/>
 Then, we weave the two discarded nodes into a new, second list of two nodes, and use <code>isWellFormed</code> and <code>length</code> to verify it is as we expect: <br/>
<br/>
<div class="fragment"><pre class="fragment">  usageData[1] = makeLink(0, &amp;usageData[3]);
  usageData[3] = makeLink(&amp;usageData[1], 0);
  assert(Util::isWellFormed(&amp;usageData[1], &amp;usageData[3]));
  assert(2 ==        length(&amp;usageData[1], &amp;usageData[3]));
</pre></div><br/>
<br/>
 Next, we use our component's <code>spliceListBeforeTarget</code> method to remove the middle nodes from the longer list and append them to the end of shorter list. Note that the splicing function not only adds the sequence to the new list, it also splices the list the sequence is removed from so that both are well-formed lists: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Util::spliceListBeforeTarget(&amp;usageData[0],
                               &amp;usageData[2],
                               &amp;usageData[3]);
</pre></div><br/>
<br/>
 Then, we use <code>isWellFormed</code> and <code>length</code> to verify the state of our two lists: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(Util::isWellFormed(&amp;usageData[1], &amp;usageData[3]));
  assert(4 ==        length(&amp;usageData[1], &amp;usageData[3]));

  assert(Util::isWellFormed(&amp;front, &amp;back));
  assert(2 ==        length(&amp;front, &amp;back));
</pre></div><br/>
<br/>
 Next, we call <code>spliceListBeforeTarget</code> again to join our two lists into one: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Util::spliceListBeforeTarget(&amp;usageData[1],
                               &amp;usageData[3],
                               &amp;back);
</pre></div><br/>
<br/>
 Now, we use <code>isWellFormed</code> and <code>length</code> to verify the state of our one remaining list: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(Util::isWellFormed(&amp;front, &amp;back));
  assert(6 ==        length(&amp;front, &amp;back));
  assert(0 == front.previousLink());
  assert(0 == back .nextLink());
</pre></div><br/>
<br/>
 Finally, we traverse our list in both directions, examining each node to verify all the links and that the sequence is as expected: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Link *p = &amp;front;
  assert(0 == p-&gt;previousLink());
  p = p-&gt;nextLink();
  assert(&amp;usageData[1] == p);
  p = p-&gt;nextLink();
  assert(&amp;usageData[0] == p);
  p = p-&gt;nextLink();
  assert(&amp;usageData[2] == p);
  p = p-&gt;nextLink();
  assert(&amp;usageData[3] == p);
  p = p-&gt;nextLink();
  assert(&amp;back         == p);
  assert(0 == p-&gt;nextLink());

  p = p-&gt;previousLink();
  assert(&amp;usageData[3] == p);
  p = p-&gt;previousLink();
  assert(&amp;usageData[2] == p);
  p = p-&gt;previousLink();
  assert(&amp;usageData[0] == p);
  p = p-&gt;previousLink();
  assert(&amp;usageData[1] == p);
  p = p-&gt;previousLink();
  assert(&amp;front        == p);
  assert(0 == p-&gt;previousLink());
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:20 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
