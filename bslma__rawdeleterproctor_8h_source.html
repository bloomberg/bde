<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslma_rawdeleterproctor.h                                          -*-C++-*-
#ifndef INCLUDED_BSLMA_RAWDELETERPROCTOR
#define INCLUDED_BSLMA_RAWDELETERPROCTOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a proctor to conditionally manage an object.
//
//@CLASSES:
//  bslma::RawDeleterProctor: proctor to conditionally manage an object
//
//@SEE_ALSO: bslma_rawdeleterguard, bslma_autorawdeleter
//
//@DESCRIPTION: This component provides a proctor class template to
// conditionally manage an (otherwise-unmanaged) object of parameterized &#39;TYPE&#39;
// supplied at construction.  If not explicitly released, the managed object is
// deleted automatically when the proctor object goes out of scope by first
// calling the (managed) object&#39;s destructor, and then freeing the memory using
// the parameterized &#39;ALLOCATOR&#39; (allocator or pool) also supplied at
// construction.  Note that after a proctor object releases its managed object,
// the same proctor can be reused to conditionally manage another object
// (allocated from the same allocator or pool that was supplied at
// construction) by invoking the &#39;reset&#39; method.
//
///&quot;Raw&quot; Warning
///-------------
// Note that this component should be used only if we are sure that the
// supplied pointer is !not! of a type that is a secondary base class -- i.e.,
// the (managed) object&#39;s address is (numerically) the same as when it was
// originally dispensed by &#39;ALLOCATOR&#39;.
//
///Requirement
///-----------
// The parameterized &#39;ALLOCATOR&#39; type of the &#39;bslma::RawDeleterProctor&#39; class
// template must provide a (possibly &#39;virtual&#39;) method:
//..
//  void deallocate(void *address);
//..
// to deallocate memory at the specified &#39;address&#39; (originally supplied by the
// &#39;ALLOCATOR&#39; object).
//
///Usage
///-----
// &#39;bslma::RawDeleterProctor&#39; is normally used to achieve *exception* *safety*
// in an *exception* *neutral* way by managing objects that are created
// temporarily on the heap, but not yet committed to a container object&#39;s
// management.  This (somewhat contrived) example illustrates the use of a
// &#39;bslma::RawDeleterProctor&#39; to manage a dynamically-allocated object,
// deleting the object automatically should an exception occur.
//
// Suppose we have a simple linked list class that manages objects of
// parameterized &#39;TYPE&#39;, but which are (for the purpose of this example)
// allocated separately from the links that hold them (thereby requiring two
// separate allocations for each &#39;append&#39; operation):
//..
//  // my_list.h
//  // ...
//
//  template &lt;class TYPE&gt;
//  class my_List {
//      // This class is a container that uses a linked list data structure to
//      // manage objects of parameterized &#39;TYPE&#39;.
//
//      // PRIVATE TYPES
//      struct Link {
//          TYPE *d_object_p;  // object held by the link
//          Link *d_next_p;    // next link
//      };
//
//      // DATA
//      Link             *d_head_p;       // head of list
//      Link             *d_tail_p;       // tail of list
//      int               d_length;       // number of objects
//      bslma::Allocator *d_allocator_p;  // allocator (held, not owned)
//
//    public:
//      // CREATORS
//      my_List(bslma::Allocator *basicAllocator = 0);
//          // Create a &#39;my_List&#39; object having an initial length of 0.
//          // Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If
//          // &#39;basicAllocator&#39; is 0, the currently installed default allocator
//          // is used.
//
//      // ...
//
//      ~my_List();
//          // Destroy this &#39;my_List&#39; object and all elements currently stored.
//
//      // MANIPULATORS
//      // ...
//
//      void append(const TYPE&amp; object);
//          // Append (a copy of) the specified &#39;object&#39; of parameterized
//          // &#39;TYPE&#39; to (the end of) this list.
//
//      // ...
//  };
//..
// Note that the rest of the &#39;my_List&#39; interface (above) and implementation
// (below) are omitted as the portion shown is sufficient to demonstrate the
// use of &#39;bslma::RawDeleterProctor&#39;.
//..
//  // CREATORS
//  template &lt;class TYPE&gt;
//  inline
//  my_List&lt;TYPE&gt;::my_List(bslma::Allocator *basicAllocator)
//  : d_head_p(0)
//  , d_tail_p(0)
//  , d_length(0)
//  , d_allocator_p(bslma::Default::allocator(basicAllocator))
//  {
//  }
//
//  template &lt;class TYPE&gt;
//  my_List&lt;TYPE&gt;::~my_List()
//  {
//      while (d_head_p) {
//          Link *tmp = d_head_p;
//          d_head_p  = d_head_p-&gt;d_next_p;
//          d_allocator_p-&gt;deleteObject(tmp-&gt;d_object_p);
//          d_allocator_p-&gt;deallocate(tmp);
//      }
//  }
//
//  // MANIPULATORS
//  template &lt;class TYPE&gt;
//  void my_List&lt;TYPE&gt;::append(const TYPE&amp; object)
//  {
//      TYPE *tmp = (TYPE *)new(*d_allocator_p) TYPE(object, d_allocator_p);
//                                                          // possibly throw
//
//      //************************************************************
//      // Note the use of the raw deleter proctor on &#39;tmp&#39; (below). *
//      //************************************************************
//
//      bslma::RawDeleterProctor&lt;TYPE, bslma::Allocator&gt; proctor(tmp,
//                                                             d_allocator_p);
//
//      if (!d_head_p) {
//          d_head_p           = new(*d_allocator_p) Link;  // possibly throw
//          d_tail_p           = d_head_p;
//      }
//      else {
//          d_tail_p-&gt;d_next_p = new(*d_allocator_p) Link;  // possibly throw
//          d_tail_p           = d_tail_p-&gt;d_next_p;
//      }
//      d_tail_p-&gt;d_object_p   = tmp;
//      d_tail_p-&gt;d_next_p     = 0;
//
//      //*********************************************************
//      // Note that the raw deleter proctor is released (below). *
//      //*********************************************************
//
//      proctor.release();
//  }
//..
// The &#39;append&#39; method defined above potentially throws in three places.  If
// the memory allocator held in &#39;d_allocator_p&#39; were to throw while attempting
// to create the object of parameterized &#39;TYPE&#39;, no memory would be leaked.
// But without subsequent use of the &#39;bslma::RawDeleterProctor&#39;, if the
// allocator subsequently throws while creating the link, all memory (and any
// other resources) acquired as a result of copying the (not-yet-managed)
// object would be leaked.  Using the &#39;bslma::RawDeleterProctor&#39; prevents the
// leaks by deleting the proctored object automatically should the proctor go
// out of scope before the &#39;release&#39; method of the proctor is called (such as
// when the function exits prematurely due to an exception).
//
// Note that the &#39;append&#39; method assumes the copy constructor of &#39;TYPE&#39; takes
// an allocator as a second argument.  In production code, a constructor proxy
// that checks the traits of &#39;TYPE&#39; (to determine whether &#39;TYPE&#39; uses
// &#39;bslma::Allocator&#39;) should be used (see &#39;bslalg_constructorproxy&#39;).

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DELETERHELPER
#include &lt;bslma_deleterhelper.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#include &lt;bsls_performancehint.h&gt;
#endif

namespace BloombergLP {

namespace bslma {

                        // =======================
                        // class RawDeleterProctor
                        // =======================

template &lt;class TYPE, class ALLOCATOR&gt;
class RawDeleterProctor {
    // This class implements a proctor that, unless its &#39;release&#39; method has
    // previously been invoked, automatically deletes a managed object upon
    // destruction by first invoking the object&#39;s destructor, and then invoking
    // the &#39;deallocate&#39; method of an allocator (or pool) of parameterized
    // &#39;ALLOCATOR&#39; type supplied to it at construction.  The managed object of
    // parameterized &#39;TYPE&#39; must have been created using memory provided by
    // this allocator (or pool), which must remain valid throughout the
    // lifetime of the proctor object.

    // DATA
    TYPE      *d_object_p;     // managed object
    ALLOCATOR *d_allocator_p;  // allocator or pool (held, not owned)

    // NOT IMPLEMENTED
    RawDeleterProctor(const RawDeleterProctor&amp;);
    RawDeleterProctor&amp; operator=(const RawDeleterProctor&amp;);

  public:
    // CREATORS
    RawDeleterProctor(TYPE *object, ALLOCATOR *allocator);
        // Create a raw deleter proctor that conditionally manages the
        // specified &#39;object&#39; (if non-zero), and that uses the specified
        // &#39;allocator&#39; to delete the object managed by this proctor (if not
        // released -- see &#39;release&#39;) upon destruction.  The behavior is
        // undefined unless &#39;allocator&#39; is non-zero and supplied the memory for
        // &#39;object&#39; (if non-zero).  Note that &#39;allocator&#39; must remain valid
        // throughout the lifetime of this proctor.

    ~RawDeleterProctor();
        // Destroy this raw deleter proctor, and delete the object it manages
        // (if any) by first invoking the destructor of the (managed) object,
        // and then invoking the &#39;deallocate&#39; method of the allocator (or pool)
        // that was supplied at the construction of this proctor.  If no object
        // is currently being managed, this method has no effect.

    // MANIPULATORS
    void release();
        // Release from management the object currently managed by this
        // proctor.  If no object is currently being managed, this method has
        // no effect.

    void reset(TYPE *object);
        // Set the specified &#39;object&#39; as the object to be managed by this
        // proctor.  The behavior is undefined unless &#39;object&#39; is non-zero and
        // was allocated from the allocator (or pool) supplied at construction.
        // Note that this method releases any previously-managed object from
        // management (without deleting it), and so may be invoked with or
        // without having called &#39;release&#39; when reusing this object.
};

// ============================================================================
//                       TEMPLATE FUNCTION DEFINITIONS
// ============================================================================

                        // -----------------------
                        // class RawDeleterProctor
                        // -----------------------

// CREATORS
template &lt;class TYPE, class ALLOCATOR&gt;
inline
RawDeleterProctor&lt;TYPE, ALLOCATOR&gt;::
RawDeleterProctor(TYPE *object, ALLOCATOR *allocator)
: d_object_p(object)
, d_allocator_p(allocator)
{
    BSLS_ASSERT_SAFE(allocator);
}

template &lt;class TYPE, class ALLOCATOR&gt;
inline
RawDeleterProctor&lt;TYPE, ALLOCATOR&gt;::~RawDeleterProctor()
{
    BSLS_ASSERT_SAFE(d_allocator_p);

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(0 != d_object_p)) {
        DeleterHelper::deleteObjectRaw(d_object_p, d_allocator_p);
    }
}

// MANIPULATORS
template &lt;class TYPE, class ALLOCATOR&gt;
inline
void RawDeleterProctor&lt;TYPE, ALLOCATOR&gt;::release()
{
    d_object_p = 0;
}

template &lt;class TYPE, class ALLOCATOR&gt;
inline
void RawDeleterProctor&lt;TYPE, ALLOCATOR&gt;::reset(TYPE *object)
{
    BSLS_ASSERT_SAFE(object);

    d_object_p = object;
}

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
