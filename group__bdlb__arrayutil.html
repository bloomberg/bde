<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlb_arrayutil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlb_arrayutil<br/>
<small>
[<a class="el" href="group__bdlb.html">Package bdlb</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide utilities to determine properties of fixed-sized arrays.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html">bdlb</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Macros</a> </li>
<li>
<a href="#4">Description</a> <ul>
<li>
<a href="#4.1">Usage</a> <ul>
<li>
<a href="#4.1.1">Example 1: Basic Syntax</a> </li>
<li>
<a href="#4.1.2">Example 2: Use with Database Interfaces</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide utilities to determine properties of fixed-sized arrays. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbdlb_1_1ArrayUtil.html">bdlb::ArrayUtil</a> </td><td>namespace for array access function templates.  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="macros"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>BDLB_ARRAYUTIL_SIZE </td><td>get a constant expression with an array's length.  </td></tr>
<tr>
<td>BDLB_ARRAYUTIL_LENGTH </td><td>get a constant expression with an array's length.  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="4"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a utility <code>struct</code>, <code><a class="el" href="structbdlb_1_1ArrayUtil.html">bdlb::ArrayUtil</a></code>, that serves as a namespace for a collection of function templates providing access to the length and iterators of statically sized built-in arrays. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The basic idea is that the compiler knows the length of statically sized arrays and the corresponding information can be exposed using simple function templates. The use of these function templates is easier and safer than the alternatives like use of <code>sizeof</code> (turning the array into a pointer doesn't cause the use of <code>sizeof</code> to fail at compile-time but it yields a wrong result) or manually specifying the length of an array. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="4.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_basic_syntax"></a> <a class="anchor" id="usage.example_1~3A_basic_syntax"></a> <a class="anchor" id="description.usage.example_1~3A_basic_syntax"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="4.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Syntax: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>When creating a sequence of values it is often easy to write the sequence as an initialized array and use this array to initialize a container. Since the array's length may be changed as the program is maintained, the code using the array should automatically determine the array's length or automatically determine iterators to the beginning and the end of the array. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, to initialize a <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;int&gt;</code> with the first few prime numbers stored in an array the following code uses the <code>begin</code> and <code>end</code> methods of <code><a class="el" href="structbdlb_1_1ArrayUtil.html">bdlb::ArrayUtil</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> usePrimes(<span class="keywordtype">bool</span> verbose)
  {
      <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; <span class="stringliteral">&quot;&#39;usePrimes&#39;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>
                                &lt;&lt; <span class="stringliteral">&quot;===========&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

      <span class="keyword">const</span> <span class="keywordtype">int</span>        primes[] = { 2, 3, 5, 7, 11, 13, 17 };
      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;int&gt;</a> values(<a class="code" href="structbdlb_1_1ArrayUtil.html#a6f761d6241c7ec85c6b294bdfa28d83c">bdlb::ArrayUtil::begin</a>(primes),
                              <a class="code" href="structbdlb_1_1ArrayUtil.html#ae63afcd116aafa4f52e5807b964a34ed">bdlb::ArrayUtil::end</a>(primes));

      assert(values.size() == <a class="code" href="structbdlb_1_1ArrayUtil.html#a1fa3fd689809b5fa595fe41969994c93">bdlb::ArrayUtil::size</a>(primes));
</pre></div><br/>
<br/>
 Notice that, after constructing <code>values</code> with the content of the array <code>primes</code> the assertion verifies that the correct number of values is stored in <code>values</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When the length is needed as a constant expression, e.g., to use it for the length of another array, the macro <code><a class="el" href="bdlb__arrayutil_8h.html#ab5bf3196a2bcc2317d5f7d3598c00784">BDLB_ARRAYUTIL_LENGTH(array)</a></code> can be used: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">int</span> reversePrimes[<a class="code" href="bdlb__arrayutil_8h.html#a2d6fe4ad868fdcdd40ee040169f62932">BDLB_ARRAYUTIL_SIZE</a>(primes)];

      bsl::copy(values.rbegin(),
                values.rend(),
                <a class="code" href="structbdlb_1_1ArrayUtil.html#a6f761d6241c7ec85c6b294bdfa28d83c">bdlb::ArrayUtil::begin</a>(reversePrimes));

      assert(bsl::mismatch(<a class="code" href="structbdlb_1_1ArrayUtil.html#a2044d9dd69c0e7e992c5af43e9413151">bdlb::ArrayUtil::rbegin</a>(primes),
                           <a class="code" href="structbdlb_1_1ArrayUtil.html#a6d13efcf6c21944914e78a7ae3ca17dd">bdlb::ArrayUtil::rend</a>(primes),
                           <a class="code" href="structbdlb_1_1ArrayUtil.html#a6f761d6241c7ec85c6b294bdfa28d83c">bdlb::ArrayUtil::begin</a>(reversePrimes)).second
             == <a class="code" href="structbdlb_1_1ArrayUtil.html#ae63afcd116aafa4f52e5807b964a34ed">bdlb::ArrayUtil::end</a>(reversePrimes));
  }
</pre></div><br/>
<br/>
 After defining the array <code>reversePrimes</code> with the same length as <code>primes</code> the elements of <code>values</code> are copied in reverse order into this array. The assertion verifies that <code>reversePrimes</code> contains the values from <code>primes</code> but in reverse order: <code>bsl::mismatch</code> is used with a reverse sequence of <code>primes</code> by using the <code>rbegin</code> and <code>rend</code> methods for <code>primes</code> and normal sequence using the <code>begin</code> and <code>end</code> methods for <code>reversePrimes</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_use_with_database_interfaces"></a> <a class="anchor" id="usage.example_2~3A_use_with_database_interfaces"></a> <a class="anchor" id="description.usage.example_2~3A_use_with_database_interfaces"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="4.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Use with Database Interfaces: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The functions <code>begin</code>, <code>end</code>, and <code>size</code> provided by this component are similar to functions provided by containers. The main difference is that they reside in a utility component rather than being member functions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A typical use case for the <code>size</code> function is a function expecting a pointer to a sequence of keys (e.g., columns in a database) and the number of the keys in the sequence: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> query(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>       *result,
             <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> *columns,
             <span class="keywordtype">int</span>                numberOfColumns)
  {

      <span class="comment">// Query the database....</span>

  }

  <span class="keywordtype">void</span> loadData(<a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a> *data)
  {
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> columns[] = { <span class="stringliteral">&quot;column1&quot;</span>, <span class="stringliteral">&quot;column2&quot;</span>, <span class="stringliteral">&quot;column3&quot;</span> };
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>       result[<a class="code" href="bdlb__arrayutil_8h.html#a2d6fe4ad868fdcdd40ee040169f62932">BDLB_ARRAYUTIL_SIZE</a>(columns)];

      query(result, columns, <a class="code" href="structbdlb_1_1ArrayUtil.html#a1fa3fd689809b5fa595fe41969994c93">bdlb::ArrayUtil::size</a>(columns));
      data-&gt;<a class="code" href="group__bslstl__vector.html#ga81fed82a60da7d7c72724f95bfa7ac7f">assign</a>(<a class="code" href="structbdlb_1_1ArrayUtil.html#a6f761d6241c7ec85c6b294bdfa28d83c">bdlb::ArrayUtil::begin</a>(result),
                   <a class="code" href="structbdlb_1_1ArrayUtil.html#ae63afcd116aafa4f52e5807b964a34ed">bdlb::ArrayUtil::end</a>(result));
  }
</pre></div><br/>
<br/>
 The <code>loadData</code> function shows how to use the different function templates. The array <code>columns</code> doesn't have a length specified. It is determined from the number of elements it is initialized with. In this case it is easy to see that there are three elements but in real situations the number of elements can be non-trivial to get right. Also, changing the number of elements would make it necessary to apply the corresponding change in multiple places. Thus, the length is determined using <code><a class="el" href="structbdlb_1_1ArrayUtil.html">bdlb::ArrayUtil</a></code>: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
The length of <code>result</code> should match the length of <code>columns</code>. When specifying the length of an array a constant expression is necessary. In C++ 2011 the function <code><a class="el" href="structbdlb_1_1ArrayUtil.html#a1fa3fd689809b5fa595fe41969994c93">bdlb::ArrayUtil::size</a></code> could return a constant expression but compilers not, yet, implementing the standard a trick must be used (using <code>sizeof</code> with a reference to suitably sized array of <code>char</code>). This trick is packaged into the macro <code><a class="el" href="bdlb__arrayutil_8h.html#a2d6fe4ad868fdcdd40ee040169f62932">BDLB_ARRAYUTIL_SIZE()</a></code>.  </li>
<li>
When the length is needed in a context where a <code>const</code> expression is not required, e.g., when calling <code>query</code>, the `bdlbArrayUtil::size' function can be used with the array.  </li>
<li>
The <code><a class="el" href="structbdlb_1_1ArrayUtil.html#a6f761d6241c7ec85c6b294bdfa28d83c">bdlb::ArrayUtil::begin</a></code> and <code><a class="el" href="structbdlb_1_1ArrayUtil.html#ae63afcd116aafa4f52e5807b964a34ed">bdlb::ArrayUtil::end</a></code> functions are used to obtain <code>begin</code> and <code>end</code> iterators used with the vector's <code>assign</code> function to put the <code>result</code> obtained from the call to <code>query</code> into the <code>vector</code> pointed to by <code>data</code>.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Similar needs for an array of a sequence of values frequently arise when using one of the database interfaces. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Another common use case are test cases where the content of a computed sequence must be compared with an expected result: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> checkData(<span class="keyword">const</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a>&amp; data)
  {
      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> expect[] = {
                                       <span class="comment">// ...</span>
                                   };
      assert(data.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>() == <a class="code" href="structbdlb_1_1ArrayUtil.html#a1fa3fd689809b5fa595fe41969994c93">bdlb::ArrayUtil::size</a>(expect));
      assert(<a class="code" href="structbdlb_1_1ArrayUtil.html#ae63afcd116aafa4f52e5807b964a34ed">bdlb::ArrayUtil::end</a>(expect)
          == bsl::mismatch(<a class="code" href="structbdlb_1_1ArrayUtil.html#a6f761d6241c7ec85c6b294bdfa28d83c">bdlb::ArrayUtil::begin</a>(expect),
                           <a class="code" href="structbdlb_1_1ArrayUtil.html#ae63afcd116aafa4f52e5807b964a34ed">bdlb::ArrayUtil::end</a>(expect),
                           data.<a class="code" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a>()).first);
  }
</pre></div><br/>
<br/>
 In the code below the actual result in <code>data</code> is compared to the values in the array <code>expect</code>: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
We make sure that the lengths of <code>data</code> and <code>expect</code> are identical using <code><a class="el" href="structbdlb_1_1ArrayUtil.html#a1fa3fd689809b5fa595fe41969994c93">bdlb::ArrayUtil::size</a></code>.  </li>
<li>
The sequences are compared using the <code>mismatch</code> algorithm: To get the begin and of the <code>expect</code> array <code><a class="el" href="structbdlb_1_1ArrayUtil.html#a6f761d6241c7ec85c6b294bdfa28d83c">bdlb::ArrayUtil::begin</a></code> and <code><a class="el" href="structbdlb_1_1ArrayUtil.html#ae63afcd116aafa4f52e5807b964a34ed">bdlb::ArrayUtil::end</a></code>, respectively, are used.  </li>
</ol>
<br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> getAndCheckData(<span class="keywordtype">bool</span> verbose)
  {
      <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; <span class="stringliteral">&quot;&#39;getAndCheckData&#39;&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>
                                &lt;&lt; <span class="stringliteral">&quot;=================&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a> data;
      loadData(&amp;data);
      checkData(data);
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:33 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
