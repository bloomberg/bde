<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bdlma_multipoolallocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_multipoolallocator<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a memory-pooling allocator of heterogeneous block sizes.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Configuration at Construction</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Using a <code>bdlma::MultipoolAllocator</code></a> </li>
<li>
<a href="#3.2.2">Example 2: Performance of a <code>bdlma::MultipoolAllocator</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a memory-pooling allocator of heterogeneous block sizes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a> </td><td>allocator managing varying-size memory pools  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlma__pool.html" title="Provide efficient allocation of memory blocks of uniform size.">Component bdlma_pool</a>, <a class="el" href="group__bdlma__multipool.html" title="Provide a memory manager to manage pools of varying block sizes.">Component bdlma_multipool</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a general-purpose, managed allocator, <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code>, that implements the <code><a class="el" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a></code> protocol and provides an allocator that maintains a configurable number of <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code> objects, each dispensing maximally-aligned memory blocks of a unique size. The <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code> objects are placed in an array, starting at index 0, with each successive pool managing memory blocks of a size twice that of the previous pool. Each multipool allocation (deallocation) request allocates memory from (returns memory to) the internal pool managing memory blocks of the smallest size not less than the requested size, or else from a separately managed list of memory blocks, if no internal pool managing memory blocks of sufficient size exists. Both the <code>release</code> method and the destructor of a <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code> release all memory currently allocated via the object. <br/>
<br/>
<div class="fragment"><pre class="fragment">   ,-------------------------.
  ( <a class="code" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a> )
   `-------------------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">                |         ctor/dtor</span>
<span class="stringliteral">                |         maxPooledBlockSize</span>
<span class="stringliteral">                |         numPools</span>
<span class="stringliteral">                |         reserveCapacity</span>
<span class="stringliteral">                V</span>
<span class="stringliteral">    ,-----------------------.</span>
<span class="stringliteral">   ( bdlma::ManagedAllocator )</span>
<span class="stringliteral">    `-----------------------&#39;</span>
                |         release
                V
       ,----------------.
      ( <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> )
       `----------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">                          allocate</span>
<span class="stringliteral">                          deallocate</span>
</pre></div><br/>
<br/>
 The main difference between a <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code> and a <code><a class="el" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a></code> is that, very often, a <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code> is managed through a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> pointer. Hence, every call to the <code>allocate</code> method invokes a virtual function call, which is slower than invoking the non-virtual <code>allocate</code> method on a <code><a class="el" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a></code>. However, since <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code> is widely used across BDE interfaces, <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code> is more general purpose than <code><a class="el" href="classbdlma_1_1Multipool.html">bdlma::Multipool</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="configuration_at_construction"></a> <a class="anchor" id="description.configuration_at_construction"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Configuration at Construction: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>When creating a <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code>, clients can optionally configure: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
NUMBER OF POOLS -- the number of internal pools (the block size managed by the first pool is eight bytes, with each successive pool managing blocks of a size twice that of the previous pool).  </li>
<li>
<p class="startli">GROWTH STRATEGY -- geometrically growing chunk size starting from 1 (in terms of the number of memory blocks per chunk), or fixed chunk size, specified as either:</p>
<ul>
<li>
the unique growth strategy for all pools, or  </li>
<li>
(if the number of pools is specified) an array of growth strategies corresponding to each individual pool.  </li>
</ul>
<div class="hanging"> </div></li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> If the growth strategy is not specified, geometric growth is used for all</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> pools. </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<p>MAX BLOCKS PER CHUNK -- the maximum number of memory blocks within a chunk, specified as either:</p>
<ul>
<li>
the unique maximum-blocks-per-chunk value for all of the pools, or  </li>
<li>
an array of maximum-blocks-per-chunk values corresponding to each individual pool. </li>
</ul>
<div class="hanging"> <dl class="user"><dt><b></b></dt><dd>If the maximum blocks per chunk is not specified, an</dd></dl>
<dl class="user"><dt><b></b></dt><dd>implementation-defined default value is used. Note that the maximum</dd></dl>
<dl class="user"><dt><b></b></dt><dd>blocks per chunk can be configured only if the number of pools is also</dd></dl>
<dl class="user"><dt><b></b></dt><dd>configured. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p>BASIC ALLOCATOR -- the allocator used to supply memory (to replenish an internal pool, or directly if the maximum block size is exceeded). If not specified, the currently installed default allocator is used (see <code>bslma_default</code>).   </p>
<dl class="user"><dt><b></b></dt><dd>A default-constructed multipool allocator has a relatively small, implementation-defined number of pools, <code>N</code>, with respective block sizes ranging from <code>2^3 = 8</code> to <code>2^(N+2)</code>. By default, the initial chunk size, (i.e., the number of blocks of a given size allocated at once to replenish a pool's memory) is 1, and each pool's chunk size grows geometrically until it reaches an implementation-defined maximum, at which it is capped. Finally, unless otherwise specified, all memory comes from the allocator that was the currently installed default allocator at the time the <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code> was created. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Using the various pooling options described above, we can configure the number of pools maintained, whether replenishment should be adaptive (i.e., geometric starting with 1) or fixed at a maximum chunk size, what that maximum chunk size should be (which need not be an integral power of 2), and the underlying allocator used to supply memory. Note that both GROWTH STRATEGY and MAX BLOCKS PER CHUNK can be specified separately either as a single value applying to all of the maintained pools, or as an array of values, with the elements applying to each individually maintained pool. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_a_bdlma~3A~3Amultipoolallocator"></a> <a class="anchor" id="usage.example_1~3A_using_a_bdlma~3A~3Amultipoolallocator"></a> <a class="anchor" id="description.usage.example_1~3A_using_a_bdlma~3A~3Amultipoolallocator"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using a bdlma::MultipoolAllocator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code> can be used to supply memory to node-based data structures such as <code><a class="el" href="classbsl_1_1set.html">bsl::set</a></code>, <code><a class="el" href="classbsl_1_1list.html">bsl::list</a></code>, and <code><a class="el" href="classbsl_1_1map.html">bsl::map</a></code>. Suppose we are implementing a container of named graphs, where a graph is defined by a set of edges and a set of nodes. The various fixed-sized nodes and edges can be efficiently allocated by a <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, the edge class, <code>my_Edge</code>, is defined as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Node;

  <span class="keyword">class </span>my_Edge {
      <span class="comment">// This class represents an edge within a graph.  Both ends of an</span>
      <span class="comment">// edge must be connected to nodes.</span>

      <span class="comment">// DATA</span>
      my_Node *d_first;   <span class="comment">// first node</span>
      my_Node *d_second;  <span class="comment">// second node</span>

      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_Edge(my_Node *first, my_Node *second);
          <span class="comment">// Create an edge that connects to the specified &#39;first&#39; and</span>
          <span class="comment">// &#39;second&#39; nodes.</span>

      <span class="comment">// ...</span>
  };

  <span class="comment">// CREATORS</span>
  my_Edge::my_Edge(my_Node *first, my_Node *second)
  : d_first(first)
  , d_second(second)
  {
  }
</pre></div><br/>
<br/>
 Then, the node class, <code>my_Node</code>, is defined as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Node {
      <span class="comment">// This class represents a node within a graph.  A node can be</span>
      <span class="comment">// connected to any number of edges.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1set.html">bsl::set&lt;my_Edge *&gt;</a> d_edges;  <span class="comment">// set of edges this node connects to</span>

      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// TRAITS</span>
      <a class="code" href="bslmf__nestedtraitdeclaration_8h.html#a6d33ff2982d65052e0c33136bf4d74e7">BSLMF_NESTED_TRAIT_DECLARATION</a>(my_Node, <a class="code" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>);

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my_Node(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a node not connected to any other nodes.  Optionally</span>
          <span class="comment">// specify a &#39;basicAllocator&#39; used to supply memory.  If</span>
          <span class="comment">// &#39;basicAllocator&#39; is 0, the currently installed default allocator</span>
          <span class="comment">// is used.</span>

      <span class="comment">// ...</span>
  };

  <span class="comment">// CREATORS</span>
  my_Node::my_Node(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_edges(basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 Then, we define the graph class, <code>my_Graph</code>, as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_Graph {
      <span class="comment">// This class represents a graph having sets of nodes and edges.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1set.html">bsl::set&lt;my_Edge&gt;</a> d_edges;  <span class="comment">// set of edges in this graph</span>
      <a class="code" href="classbsl_1_1set.html">bsl::set&lt;my_Node&gt;</a> d_nodes;  <span class="comment">// set of nodes in this graph</span>

      <span class="comment">// ...</span>

    <span class="keyword">public</span>:
      <span class="comment">// TRAITS</span>
      <a class="code" href="bslmf__nestedtraitdeclaration_8h.html#a6d33ff2982d65052e0c33136bf4d74e7">BSLMF_NESTED_TRAIT_DECLARATION</a>(my_Graph, <a class="code" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>);

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my_Graph(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an empty graph.  Optionally specify a &#39;basicAllocator&#39;</span>
          <span class="comment">// used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently</span>
          <span class="comment">// installed default allocator is used.</span>

      <span class="comment">// ...</span>
  };

  my_Graph::my_Graph(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_edges(basicAllocator)
  , d_nodes(basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 Next, the container for the collection of named graphs, <code>my_NamedGraphContainer</code>, is defined as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_NamedGraphContainer {
      <span class="comment">// This class stores a map that indexes graph names to graph objects.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1map.html">bsl::map&lt;bsl::string, my_Graph&gt;</a> d_graphMap;  <span class="comment">// map from graph name to</span>
                                                   <span class="comment">// graph</span>

    <span class="keyword">public</span>:
      <span class="comment">// TRAITS</span>
      <a class="code" href="bslmf__nestedtraitdeclaration_8h.html#a6d33ff2982d65052e0c33136bf4d74e7">BSLMF_NESTED_TRAIT_DECLARATION</a>(my_NamedGraphContainer,
                                     <a class="code" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>);

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my_NamedGraphContainer(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an empty named graph container.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      <span class="comment">// ...</span>
  };

  <span class="comment">// CREATORS</span>
  my_NamedGraphContainer::my_NamedGraphContainer(
                                            <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_graphMap(basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 Finally, in <code>main</code>, we can create a <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code> and pass it to our <code>my_NamedGraphContainer</code>. Since we know that the maximum block size needed is 32 (<code>sizeof(my_Graph)</code>), we can calculate the number of pools needed by using the formula given in the "Configuration at Construction" section: <br/>
<br/>
<div class="fragment"><pre class="fragment">  largestPoolSize == 2 ^ (N + 2)
</pre></div><br/>
<br/>
 When solved for the above equation, the smallest <code>N</code> that satisfies this relationship is 3: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main()
  {
      <span class="keyword">enum</span> { NUM_POOLS = 3 };

      <a class="code" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a> multipoolAllocator(NUM_POOLS);

      my_NamedGraphContainer container(&amp;multipoolAllocator);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_performance_of_a_bdlma~3A~3Amultipoolallocator"></a> <a class="anchor" id="usage.example_2~3A_performance_of_a_bdlma~3A~3Amultipoolallocator"></a> <a class="anchor" id="description.usage.example_2~3A_performance_of_a_bdlma~3A~3Amultipoolallocator"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Performance of a bdlma::MultipoolAllocator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code> can greatly improve efficiency when it is used to supply memory to node-based data structures that frequently both insert and remove nodes, while growing to significant size before being destroyed. The following experiment will illustrate the benefits of using a <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code> under this scenario by comparing the following 3 different allocator uses: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
Using the <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code>.  </li>
<li>
Using a <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code> as a substitute for the <code><a class="el" href="classbslma_1_1NewDeleteAllocator.html">bslma::NewDeleteAllocator</a></code>.  </li>
<li>
Exploiting the managed aspect of <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code> by avoiding invocation of the destructor of the data structure, since the destruction of the allocator will automatically reclaim all memory.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create a test data structure that contains three <code><a class="el" href="classbsl_1_1list.html">bsl::list</a></code>s. Each list holds a different type of object, where each type has a different size. For simplicity, we create these different object types as different instantiations of a template class, parameterized on the object size: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> OBJECT_SIZE&gt;
  <span class="keyword">class </span>my_TestObject {

      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> d_data[OBJECT_SIZE];
  };
</pre></div><br/>
<br/>
 Again, for simplicity, the sizes of these objects are chosen to be 20, 40, and 80, instead of being parameterized as part of the test data structure: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_TestDataStructure {

      <span class="comment">// PRIVATE TYPES</span>
      <span class="keyword">typedef</span> my_TestObject&lt;20&gt; Obj1;
      <span class="keyword">typedef</span> my_TestObject&lt;40&gt; Obj2;
      <span class="keyword">typedef</span> my_TestObject&lt;80&gt; Obj3;

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1list.html">bsl::list&lt;Obj1&gt;</a> d_list1;
      <a class="code" href="classbsl_1_1list.html">bsl::list&lt;Obj2&gt;</a> d_list2;
      <a class="code" href="classbsl_1_1list.html">bsl::list&lt;Obj3&gt;</a> d_list3;
</pre></div><br/>
<br/>
 The test will consist of the following steps: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
Push back into <code>d_list1</code>, then <code>d_list2</code>, then <code>d_list3</code>.  </li>
<li>
Repeat #1.  </li>
<li>
Pop front from <code>d_list1</code>, then <code>d_list2</code>, then <code>d_list3</code>.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The above 3 steps will be repeated <code>n</code> times, where <code>n</code> is a parameter specified by the user. This process will both grow the list and incorporate a large number of node removals. Note that nodes are removed from the front of the list to simulate a particular real-world usage, where nodes removed are rarely those recently added (this also removes the possibility of noise from potential optimizations with relinquishing memory blocks that are most recently allocated). <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_TestDataStructure(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> pop();

      <span class="keywordtype">void</span> push();
  };

  <span class="comment">// CREATORS</span>
  my_TestDataStructure::my_TestDataStructure(
                                            <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_list1(basicAllocator)
  , d_list2(basicAllocator)
  , d_list3(basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 The <code>push</code> method will push into the 3 <code><a class="el" href="classbsl_1_1list.html">bsl::list</a></code> objects managed by <code>my_TestDataStructure</code> sequentially. Similarly, the <code>pop</code> method will pop from the lists sequentially: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">void</span> my_TestDataStructure::push()
  {
      <span class="comment">// Push to the back of the 3 lists.</span>

      d_list1.push_back(Obj1());
      d_list2.push_back(Obj2());
      d_list3.push_back(Obj3());
  }

  <span class="keywordtype">void</span> my_TestDataStructure::pop()
  {
      <span class="comment">// Pop from the front of the 3 lists.</span>

      d_list1.pop_front();
      d_list2.pop_front();
      d_list3.pop_front();
  }
</pre></div><br/>
<br/>
 The above <code>push</code> and <code>pop</code> methods will allow us to evaluate the cost to add and remove nodes using different allocators. To evaluate the cost of destruction (and hence deallocation of all allocated memory in the list objects), we supply a <code>static</code> <code>test</code> method within a <code>my_TestUtil</code> class to create the test mechanism, run the test, and destroy the test mechanism. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>test</code> method accepts a <code>testLengthFactor</code> argument specified by the user to control the length of the test. The effect of <code>testLengthFactor</code> is shown below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  testLengthFactor            test size           n      iterations
  ----------------     ----------------     --------     ----------
        4                  10^4 = 10000           1          10000
                                                 10           1000
                                                100            100
                                               1000             10
                                              10000              1

        5                 10^5 = 100000           1         100000
                                                 10          10000
                                                100           1000
                                               1000            100
                                              10000             10
                                             100000              1

        6                10^6 = 1000000           1        1000000
                                                 10         100000
                                                100          10000
                                               1000           1000
                                              10000            100
                                             100000             10
                                            1000000              1

   <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 For each row of the specified <code>testLengthFactor</code>, a <code>my_TestDataStructure</code> will be created "iterations" times, and each time the lists within the data structure will grow by invoking <code>push</code> twice and <code>pop</code> once. Note that "n" measures the effect of insertion and removal of nodes, while "iterations" measures the effect of construction and destruction of entire lists of nodes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>test</code> method also accepts a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code> to be used as the allocator used to construct the test mechanism and its internal lists: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_TestUtil {

    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span>
      <span class="keywordtype">void</span> test(<span class="keywordtype">int</span> testLengthFactor, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
      {
          <span class="keywordtype">int</span> n          = 1;
          <span class="keywordtype">int</span> iterations = 1;

          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; testLengthFactor; ++i) {
              iterations *= 10;
          }

          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt;= testLengthFactor; ++i) {
              <a class="code" href="classbsls_1_1Stopwatch.html">bsls::Stopwatch</a> timer;
              timer.<a class="code" href="classbsls_1_1Stopwatch.html#a5cd3418895715a184ca946af1228f3bb">start</a>();

              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; iterations; ++j) {
                  my_TestDataStructure tds(basicAllocator);

                  <span class="comment">// Testing cost of insertion and deletion.</span>

                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; n; ++k) {
                      tds.push();
                      tds.push();
                      tds.pop();
                  }

                  <span class="comment">// Testing cost of destruction.</span>
              }

              timer.<a class="code" href="classbsls_1_1Stopwatch.html#a5410bbcb86ce3c3f31cf41dfe4bf95d7">stop</a>();

              printf(<span class="stringliteral">&quot;%d\t%d\t%d\t%1.6f\n&quot;</span>, testLengthFactor,
                                            n,
                                            iterations,
                                            timer.<a class="code" href="classbsls_1_1Stopwatch.html#ac288613266a9c668b1101e9d7e9982ce">elapsedTime</a>());

              n          *= 10;
              iterations /= 10;
          }
      }
</pre></div><br/>
<br/>
 Next, to fully test the benefit of being able to relinquish all allocated memory at once, we use the <code>testManaged</code> method, which accepts only managed allocators. Instead of creating the test mechanism on the stack, the test mechanism will be created on the heap. After running the test, the <code>release</code> method of the allocator will reclaim all outstanding allocations at once, eliminating the need to run the destructor of the test mechanism: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">static</span>
      <span class="keywordtype">void</span> testManaged(<span class="keywordtype">int</span>                      testLengthFactor,
                       <a class="code" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a> *managedAllocator)
      {
          <span class="keywordtype">int</span> n          = 1;
          <span class="keywordtype">int</span> iterations = 1;

          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; testLengthFactor; ++i) {
              iterations *= 10;
          }

          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt;= testLengthFactor; ++i) {
              <a class="code" href="classbsls_1_1Stopwatch.html">bsls::Stopwatch</a> timer;
              timer.<a class="code" href="classbsls_1_1Stopwatch.html#a5cd3418895715a184ca946af1228f3bb">start</a>();

              <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; iterations; ++j) {
                  my_TestDataStructure *tmPtr = <span class="keyword">new</span>(*managedAllocator)
                                      my_TestDataStructure(managedAllocator);

                  <span class="comment">// Testing cost of insertion and deletion.</span>

                  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; n; ++k) {
                      tmPtr-&gt;push();
                      tmPtr-&gt;push();
                      tmPtr-&gt;pop();
                  }

                  <span class="comment">// Testing cost of destruction.</span>

                  managedAllocator-&gt;<a class="code" href="classbdlma_1_1ManagedAllocator.html#ad86110a47aaf5e53356c86b5fd240bfb">release</a>();
              }

              timer.<a class="code" href="classbsls_1_1Stopwatch.html#a5410bbcb86ce3c3f31cf41dfe4bf95d7">stop</a>();

              printf(<span class="stringliteral">&quot;%d\t%d\t%d\t%1.6f\n&quot;</span>, testLengthFactor,
                                            n,
                                            iterations,
                                            timer.<a class="code" href="classbsls_1_1Stopwatch.html#ac288613266a9c668b1101e9d7e9982ce">elapsedTime</a>());

              n          *= 10;
              iterations /= 10;
          }
      }
  };
</pre></div><br/>
<br/>
 Finally, in main, we run the test with the different allocators and different allocator configurations based on command line arguments: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
  {
      <span class="keywordtype">int</span> testLengthFactor = 5;
      <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_POOLS  = 10;

      <span class="keywordflow">if</span> (argc &gt; 2) {
          testLengthFactor = bsl::atoi(argv[2]);
      }

      <span class="keywordtype">char</span> growth = <span class="charliteral">&#39;g&#39;</span>;
      <span class="keywordflow">if</span> (argc &gt; 3) {
          growth = argv[3][0];
          <span class="keywordflow">if</span> (growth != <span class="charliteral">&#39;g&#39;</span> &amp;&amp; growth != <span class="charliteral">&#39;c&#39;</span>) {
              printf(<span class="stringliteral">&quot;[g]eometric or [c]onstant growth must be used\n&quot;</span>);
              <span class="keywordflow">return</span> -1;
          }
      }

      <span class="keywordtype">int</span> maxChunkSize = 32;
      <span class="keywordflow">if</span> (argc &gt; 4) {
          maxChunkSize = bsl::atoi(argv[4]);
          <span class="keywordflow">if</span> (maxChunkSize &lt;= 0) {
              printf(<span class="stringliteral">&quot;maxChunkSize must be &gt;= 1&quot;</span>);
          }
      }

      <a class="code" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> strategy = growth == <span class="charliteral">&#39;g&#39;</span>
                                          ? <a class="code" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31ab281353c734dd95f29f51fc29cde21a0">bsls::BlockGrowth::BSLS_GEOMETRIC</a>
                                          : bsls::BlockGrowth::BSLS_CONSTANT;

      printf(<span class="stringliteral">&quot;\nNew Delete Allocator:\n\n&quot;</span>);
      {
          <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *nda = <a class="code" href="classbslma_1_1NewDeleteAllocator.html#a969932d0e1d15fbb2f4b6f7f03d5579e">bslma::NewDeleteAllocator::allocator</a>(0);
          my_TestUtil::test(testLengthFactor, nda);
      }

      printf(<span class="stringliteral">&quot;\nMultipool Allocator with [%c], [%d]:\n\n&quot;</span>, growth,
                                                               maxChunkSize);
      {
          <a class="code" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a> ma(NUM_POOLS, strategy, maxChunkSize);
          my_TestUtil::test(testLengthFactor, &amp;ma);
      }

      printf(<span class="stringliteral">&quot;\nMultipool Allocator Managed with [%c], [%d]:\n\n&quot;</span>, growth,
                                                               maxChunkSize);
      {
          <a class="code" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a> ma(NUM_POOLS, strategy, maxChunkSize);
          my_TestUtil::testManaged(testLengthFactor, &amp;ma);
      }

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 An excerpt of the results of the test running on IBM under optimized mode, using default constructed <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code> parameters, is shown below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  New Delete Allocator:

  6       1       1000000 3.006253
  6       10      100000  2.369734
  6       100     10000   2.598567
  6       1000    1000    2.604546
  6       10000   100     2.760319
  6       100000  10      3.085765
  6       1000000 1       4.465030

  Multipool Allocator with [g], [32]:

  6       1       1000000 0.766064
  6       10      100000  0.408509
  6       100     10000   0.357019
  6       1000    1000    0.436448
  6       10000   100     0.643206
  6       100000  10      0.932662
  6       1000000 1       0.938906

  Multipool Allocator Managed with [g], [32]:

  6       1       1000000 1.958663
  6       10      100000  0.463185
  6       100     10000   0.371201
  6       1000    1000    0.357816
  6       10000   100     0.368082
  6       100000  10      0.388422
  6       1000000 1       0.529167
</pre></div><br/>
<br/>
 It is clear that using a <code><a class="el" href="classbdlma_1_1MultipoolAllocator.html">bdlma::MultipoolAllocator</a></code> results in an improvement in memory allocation by a factor of about 4. Furthermore, if the managed aspect of the multipool allocator is exploited, the cost of destruction rapidly decreases in relative terms as the list grows larger (increasing <code>n</code>). </dd></dl>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:19 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
