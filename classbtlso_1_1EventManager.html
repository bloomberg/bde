<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlso::EventManager</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlso.html">btlso</a>      </li>
      <li><a class="el" href="classbtlso_1_1EventManager.html">btlso::EventManager</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlso::EventManager Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlso::EventManager" -->
<p><code>#include &lt;<a class="el" href="btlso__eventmanager_8h_source.html">btlso_eventmanager.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlso::EventManager:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlso_1_1EventManager.png" usemap="#btlso::EventManager_map" alt=""/>
  <map id="btlso::EventManager_map" name="btlso::EventManager_map">
<area href="classbtlso_1_1DefaultEventManager.html" alt="btlso::DefaultEventManager&lt; POLLING_MECHANISM &gt;" shape="rect" coords="0,56,328,80"/>
<area href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html" alt="btlso::DefaultEventManager&lt; Platform::SELECT &gt;" shape="rect" coords="338,56,666,80"/>
</map>
</div>

<p><a href="classbtlso_1_1EventManager-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void()&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">Callback</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1EventManager.html#a57def95251de25b83b860c4d13c1ecf3">~EventManager</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1EventManager.html#a344d0ca3d7091da8a9b7ef87bc9fcad5">dispatch</a> (int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1EventManager.html#aba9cfe3a5491533928d4027e34adfea0">dispatch</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1EventManager.html#a2f9f42a2cc3013cf6ac43553c30f8a46">registerSocketEvent</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;handle, const <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a> event, const <a class="el" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">EventManager::Callback</a> &amp;callback)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1EventManager.html#a0cd6f85fb3b4dc4e3066446d5da5c91c">deregisterSocketEvent</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;handle, <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a> event)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1EventManager.html#a6f59c75d70601525f59c517c9d904bbd">deregisterSocket</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;handle)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1EventManager.html#a2bf336c8772631b783f26aead6be54d0">deregisterAll</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1EventManager.html#a9068ee5a3ca8e2e7ae82c59d36ce2430">hasLimitedSocketCapacity</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1EventManager.html#a85a32fb55734dfecdf9b93da6603a3d7">isRegistered</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;handle, const <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a> event) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1EventManager.html#a6baa2ad4ccdcf4e56d29c9f331d834d3">numEvents</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1EventManager.html#ada27c30df3888758f4b9a02e7306d2b0">numSocketEvents</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;handle) const =0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class defines a protocol for a socket-event multiplexer. The callback are registered permanently (i.e., invoked repeatedly as events occur until explicitly deregistered). The invocation is done in the user thread at user's discretion. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a9223eeeac7abf312a41bd5ea42bccbe7"></a><!-- doxytag: member="btlso::EventManager::Callback" ref="a9223eeeac7abf312a41bd5ea42bccbe7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void()&gt; <a class="el" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">btlso::EventManager::Callback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Alias for the type used as the registered callback for this event manager. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a57def95251de25b83b860c4d13c1ecf3"></a><!-- doxytag: member="btlso::EventManager::~EventManager" ref="a57def95251de25b83b860c4d13c1ecf3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual btlso::EventManager::~EventManager </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this event manager. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a344d0ca3d7091da8a9b7ef87bc9fcad5"></a><!-- doxytag: member="btlso::EventManager::dispatch" ref="a344d0ca3d7091da8a9b7ef87bc9fcad5" args="(int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlso::EventManager::dispatch </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each socket event pending on this event manager, invoke the corresponding callback registered with this event manager. If no event is pending, wait until either (1) at least one event occurs (in which case the corresponding callback(s) is invoked) or (2) provided that the optionally-specified <code>flags</code> contains <code>bteso_Flag::k_ASYNC_INTERRUPT</code>, an underlying system call is interrupted by a signal. Return the number of dispatched callbacks on success, and a negative value otherwise; -1 is reserved to indicate that an underlying system call was interrupted. When such an interruption occurs this method will return -1 if <code>flags</code> contains <code>bteso_Flag::k_ASYNC_INTERRUPT</code> and otherwise will automatically restart (i.e., reissue the identical system call). Note that the order of invocation, relative to the order of registration, is unspecified and that -1 is never returned if <code>flags</code> does not contain <code>bteso_Flag::k_ASYNC_INTERRUPT</code>. Also note that the behavior of this method may be undefined if the number of registered sockets is 0. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1DefaultEventManager.html#acaf054b50e57d740f3368cd67c6928f5">btlso::DefaultEventManager&lt; POLLING_MECHANISM &gt;</a>, and <a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#ab57eb248ac7b209561502bc3016a79e9">btlso::DefaultEventManager&lt; Platform::SELECT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aba9cfe3a5491533928d4027e34adfea0"></a><!-- doxytag: member="btlso::EventManager::dispatch" ref="aba9cfe3a5491533928d4027e34adfea0" args="(const bsls::TimeInterval &amp;timeout, int flags=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlso::EventManager::dispatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each socket event pending on this event manager, invoke the corresponding callback registered with this event manager. If no event is pending, wait until either (1) at least one event occurs (in which case the corresponding callback(s) is invoked), (2) the specified relative <code>timeout</code> interval is exceeded, or (3) provided that the specified <code>flags</code> contains <code>bteso_Flag::k_ASYNC_INTERRUPT</code>, an underlying system call is interrupted by a signal. Return the number of dispatched callbacks on success, 0 on timeout, and a negative value otherwise; -1 is reserved to indicate that an underlying system call was interrupted. When such an interruption occurs this method will return -1 if <code>flags</code> contains <code>bteso_Flag::k_ASYNC_INTERRUPT</code> and otherwise will automatically restart (i.e., reissue the identical system call). Note that the order of invocation, relative to the order of registration, is unspecified and that -1 is never returned if <code>flags</code> does not contain <code>bteso_Flag::k_ASYNC_INTERRUPT</code>. Also note that the behavior of this method may be undefined if the number of registered sockets is 0. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1DefaultEventManager.html#aca8db9d4a4cd54a0e100530191ecb786">btlso::DefaultEventManager&lt; POLLING_MECHANISM &gt;</a>, and <a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#ad4f693a68f743931fd7c80969d978467">btlso::DefaultEventManager&lt; Platform::SELECT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2f9f42a2cc3013cf6ac43553c30f8a46"></a><!-- doxytag: member="btlso::EventManager::registerSocketEvent" ref="a2f9f42a2cc3013cf6ac43553c30f8a46" args="(const SocketHandle::Handle &amp;handle, const EventType::Type event, const EventManager::Callback &amp;callback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlso::EventManager::registerSocketEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a>&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">EventManager::Callback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register with this event manager the occurrence of the specified <code>event</code> on the specified socket <code>handle</code> such that the specified <code>callback</code> functor is invoked when <code>event</code> occurs. Return 0 on success and a non-zero value otherwise. Socket event registrations stay in effect until they are subsequently deregistered; the callback is invoked each time the specified <code>event</code> is seen. Typically, <code><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">EventType::e_READ</a></code> and <code><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">EventType::e_WRITE</a></code> are the only events that can be registered simultaneously for a socket. Simultaneously registering for incompatible events for the same socket <code>handle</code> may result in undefined behavior. If a registration attempt is made for an event that is already registered, the callback associated with this event will be overwritten with the new one. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1DefaultEventManager.html#a291fa13bc20c8abf1608926e8dfd909e">btlso::DefaultEventManager&lt; POLLING_MECHANISM &gt;</a>, and <a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#a62e8abc11e37159951f8d8dae7be0915">btlso::DefaultEventManager&lt; Platform::SELECT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0cd6f85fb3b4dc4e3066446d5da5c91c"></a><!-- doxytag: member="btlso::EventManager::deregisterSocketEvent" ref="a0cd6f85fb3b4dc4e3066446d5da5c91c" args="(const SocketHandle::Handle &amp;handle, EventType::Type event)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlso::EventManager::deregisterSocketEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a>&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister from this event manager the callback associated with the specified <code>event</code> on the specified <code>handle</code> so that said callback will not be invoked should <code>event</code> occur. The behavior is undefined unless there is a callback registered for <code>event</code> on the socket <code>handle</code>. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1DefaultEventManager.html#a795ca31a728356cde6a05ff374bc5ec6">btlso::DefaultEventManager&lt; POLLING_MECHANISM &gt;</a>, and <a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#aa29d73a4ef58ec6d05a920bd830382f5">btlso::DefaultEventManager&lt; Platform::SELECT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6f59c75d70601525f59c517c9d904bbd"></a><!-- doxytag: member="btlso::EventManager::deregisterSocket" ref="a6f59c75d70601525f59c517c9d904bbd" args="(const SocketHandle::Handle &amp;handle)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlso::EventManager::deregisterSocket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister from this event manager all events associated with the specified socket <code>handle</code>. Return the number of deregistered callbacks. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1DefaultEventManager.html#a9a1342ce4e9292893a55827d6d525fd5">btlso::DefaultEventManager&lt; POLLING_MECHANISM &gt;</a>, and <a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#a2255042ed53b2faf614fa69f5b354943">btlso::DefaultEventManager&lt; Platform::SELECT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2bf336c8772631b783f26aead6be54d0"></a><!-- doxytag: member="btlso::EventManager::deregisterAll" ref="a2bf336c8772631b783f26aead6be54d0" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlso::EventManager::deregisterAll </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister from this event manager all events on every socket handle. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1DefaultEventManager.html#af738d5ebb045cbe28b97210c872a71bb">btlso::DefaultEventManager&lt; POLLING_MECHANISM &gt;</a>, and <a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#a3168310d44d3a68dd33afbad29b8dc94">btlso::DefaultEventManager&lt; Platform::SELECT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9068ee5a3ca8e2e7ae82c59d36ce2430"></a><!-- doxytag: member="btlso::EventManager::hasLimitedSocketCapacity" ref="a9068ee5a3ca8e2e7ae82c59d36ce2430" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool btlso::EventManager::hasLimitedSocketCapacity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this event manager has a limited socket capacity, and <code>false</code> otherwise. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1DefaultEventManager.html#a1dbce8a55e19f82b9493ddacf7382564">btlso::DefaultEventManager&lt; POLLING_MECHANISM &gt;</a>, and <a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#aa4f0317da57b1a6888864f0454237960">btlso::DefaultEventManager&lt; Platform::SELECT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a85a32fb55734dfecdf9b93da6603a3d7"></a><!-- doxytag: member="btlso::EventManager::isRegistered" ref="a85a32fb55734dfecdf9b93da6603a3d7" args="(const SocketHandle::Handle &amp;handle, const EventType::Type event) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlso::EventManager::isRegistered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a>&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if the specified <code>event</code> is registered with this event manager for the specified socket <code>handle</code> and 0 otherwise. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1DefaultEventManager.html#a0ef93e0a9d20aa66ac08d2498d81b3cd">btlso::DefaultEventManager&lt; POLLING_MECHANISM &gt;</a>, and <a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#aa44d64bb976401956d85adbaa5c91c4f">btlso::DefaultEventManager&lt; Platform::SELECT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6baa2ad4ccdcf4e56d29c9f331d834d3"></a><!-- doxytag: member="btlso::EventManager::numEvents" ref="a6baa2ad4ccdcf4e56d29c9f331d834d3" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlso::EventManager::numEvents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the total number of all socket events currently registered with this event manager. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1DefaultEventManager.html#ac7fe3fb6614010d4cf688d3506391384">btlso::DefaultEventManager&lt; POLLING_MECHANISM &gt;</a>, and <a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#ac9d858cbc760218a8943a076a0d2d14a">btlso::DefaultEventManager&lt; Platform::SELECT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ada27c30df3888758f4b9a02e7306d2b0"></a><!-- doxytag: member="btlso::EventManager::numSocketEvents" ref="ada27c30df3888758f4b9a02e7306d2b0" args="(const SocketHandle::Handle &amp;handle) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlso::EventManager::numSocketEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of socket events currently registered with this event manager for the specified <code>handle</code>. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1DefaultEventManager.html#a11e2664079dd9dd6d55c8501a6636932">btlso::DefaultEventManager&lt; POLLING_MECHANISM &gt;</a>, and <a class="el" href="classbtlso_1_1DefaultEventManager_3_01Platform_1_1SELECT_01_4.html#ae09329182ac390c08d109e657a66830f">btlso::DefaultEventManager&lt; Platform::SELECT &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlso__eventmanager_8h_source.html">btlso_eventmanager.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:15 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
