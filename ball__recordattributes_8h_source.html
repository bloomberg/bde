<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// ball_recordattributes.h                                            -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALL_RECORDATTRIBUTES
#define INCLUDED_BALL_RECORDATTRIBUTES

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a container for a fixed set of fields suitable for logging.
//
//@CLASSES:
//     ball::RecordAttributes: container for a fixed set of log fields
//
//@SEE_ALSO: ball_record
//
//@DESCRIPTION: This component defines a container for aggregating a fixed set
// of fields intrinsically appropriate for logging.  Using
// &#39;ball::RecordAttributes&#39;, a logger can transmit log message text together
// with relevant auxiliary information (e.g., timestamp, filename, line number,
// etc.) as a single instance, rather than passing around individual attributes
// separately.
//
// The attributes held by &#39;ball::RecordAttributes&#39; are given in the following
// table:
//..
//     Attribute        Type               Description               Default
//     ----------   -------------   ------------------------------   -------
//     timestamp    bdlt::Datetime   creation date and time           (*Note*)
//     processID    int             process id of creator              0
//     threadID     Uint64          thread id of creator               0
//     fileName     string          file where created  (__FILE__)     &quot;&quot;
//     lineNumber   int             line number in file (__LINE__)     0
//     category     string          category of logged record          &quot;&quot;
//     severity     int             severity of logged record          0
//     message      string          log message text                   &quot;&quot;
//..
// *Note*: The default value given to the timestamp attribute is implementation
// defined.  (See the &#39;bdet_datetime&#39; component-level documentation for more
// information.)
//
// For each attribute, there is a method to access its value and a method to
// change its value.  E.g., for the timestamp attribute, there is the
// &#39;timestamp&#39; accessor and the &#39;setTimestamp&#39; manipulator.  The class
// also provides the ability to stream an object (whose class must support
// the &#39;operator&lt;&lt;&#39;) into the message attribute using &#39;messageStreamBuf&#39;
// method (see the usage example-2).  The default values listed in the
// table above are the values given to the respective attributes by
// the default constructor of &#39;ball::RecordAttributes&#39;.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Syntax
///- - - - - - - - -
// The &#39;ball::RecordAttributes&#39; class holds sufficient information on which to
// base a rudimentary logging, tracing, or reporting facility.  The following
// code fragments illustrate the essentials of working with these attributes.
//
// Assume that our example is part of a financial application using categories
// and message severities as follows:
//..
//      const char *Category[] = { &quot;Bonds&quot;, &quot;Equities&quot;, &quot;Futures&quot; };
//      enum { INFO, WARN, BUY, SELL };
//..
// First define a &#39;ball::RecordAttributes&#39; object with each attribute
// initialized to its default value:
//..
//      ball::RecordAttributes attributes;
//..
// Next set each of the attributes to some meaningful value:
//..
//      bdlt::Datetime now;
//      bdlt::EpochUtil::convertFromTimeT(&amp;now, time(0));
//      attributes.setTimestamp(now);                // current time
//      attributes.setProcessID(getpid());
//      attributes.setThreadID((bsls::Types::Uint64) pthread_self());
//      attributes.setFileName(__FILE__);
//      attributes.setLineNumber(__LINE__);
//      attributes.setCategory(Category[2]);         // &quot;Futures&quot;
//      attributes.setSeverity(WARN);
//      attributes.setMessage(&quot;sugar up (locust infestations on the rise)&quot;);
//..
// The message in this example briefly informs that something interesting may
// be happening with respect to sugar futures.  In general, the message
// attribute can contain an arbitrary amount of information.
//
// Now that the sample &#39;ball::RecordAttributes&#39; object has been populated with
// the desired information, it can be passed to a function, stored in a
// database, cached in a container of &#39;ball::RecordAttributes&#39; objects, etc.
// For the purposes of this illustration, we&#39;ll simply format and stream
// selected attributes to a specified &#39;ostream&#39; using the following function:
//..
//      void printMessage(ostream&amp;                     stream,
//                        const ball::RecordAttributes&amp; attributes)
//      {
//          using namespace std;
//          stream &lt;&lt; &quot;\tTimestamp: &quot; &lt;&lt; attributes.timestamp() &lt;&lt; endl;
//          stream &lt;&lt; &quot;\tCategory:  &quot; &lt;&lt; attributes.category()  &lt;&lt; endl;
//          stream &lt;&lt; &quot;\tMessage:   &quot; &lt;&lt; attributes.message()   &lt;&lt; endl;
//          stream &lt;&lt; endl;
//      }
//..
// The following call:
//..
//      printMessage(bsl::cout, attributes);
//..
// prints these attributes to &#39;stdout&#39;:
//..
//              Timestamp: 19JAN2004_23:07:38.000
//              Category:  Futures
//              Message:   sugar up (locust infestations on the rise)
//..
//
///Example 2: Streaming Data Into a Message Attribute
/// - - - - - - - - - - - - - - - - - - - - - - - - -
// Following example demonstrates how an object of a class supporting &#39;ostream&#39;
// operation (&#39;operator&lt;&lt;&#39;) can be streamed into the message
// attribute.  Suppose we want to stream objects of following class.
//..
//    class Information
//    {
//      private:
//        bsl::string d_heading;
//        bsl::string d_contents;
//
//      public:
//        Information(const char *heading, const char *contents);
//        const bsl::string&amp; heading() const;
//        const bsl::string&amp; contents() const;
//    };
//..
// The component containing the &#39;Information&#39; must provide &#39;operator&lt;&lt;&#39;.
// Here is a possible implementation.
//..
//    bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream,
//                             const Information&amp; information)
//    {
//        stream &lt;&lt; information.heading() &lt;&lt; endl;
//        stream &lt;&lt; &#39;\t&#39;;
//        stream &lt;&lt; information.contents() &lt;&lt; endl;
//        return stream;
//    }
//..
// The following function streams an &#39;Information&#39; object into the message
// attribute of a &#39;ball::RecordAttributes&#39; object.
//..
//    void streamInformationIntoMessageAttribute(
//                                          ball::RecordAttributes&amp; attributes,
//                                          const Information&amp;     information)
//    {
//        // First clear the message attributes.
//        attributes.clearMessage();
//
//        // Create an &#39;ostream&#39; from message stream buffer.
//        bsl::ostream os(&amp;attributes.messageStreamBuf());
//
//        // Now stream the information object into the created ostream,
//        // This will set the message attribute of &#39;attributes&#39; to the
//        // streamed contents.
//        os &lt;&lt; information;
//    }
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLSB_MEMOUTSTREAMBUF
#include &lt;bdlsb_memoutstreambuf.h&gt;
#endif

#ifndef INCLUDED_BDLT_DATETIME
#include &lt;bdlt_datetime.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifdef BSLS_PLATFORM_OS_WINDOWS

#ifndef INCLUDED_BSL_OSTREAM
#include &lt;bsl_ostream.h&gt;
#endif

#else

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

namespace BloombergLP {

namespace ball {
                        // ===========================
                        // class RecordAttributes
                        // ===========================

class RecordAttributes {
    // This class provides a container for a fixed set of attributes
    // appropriate for logging.  For each attribute in this class (e.g.,
    // &#39;category&#39;), there is an accessor for obtaining the attribute&#39;s value
    // (the &#39;category&#39; accessor) and a manipulator for changing the attribute&#39;s
    // value (the &#39;setCategory&#39; manipulator).
    //
    // Additionally, this class supports a complete set of *value* *semantic*
    // operations, including copy construction, assignment and equality
    // comparison, and &#39;ostream&#39; printing.  A precise operational definition of
    // when two instances have the same value can be found in the description
    // of &#39;operator==&#39; for the class.  This class is *exception* *neutral* with
    // no guarantee of rollback: If an exception is thrown during the
    // invocation of a method on a pre-existing instance, the object is left in
    // a valid state, but its value is undefined.  In no event is memory
    // leaked.  Finally, *aliasing* (e.g., using all or part of an object as
    // both source and destination) is supported in all cases.

    // PRIVATE TYPES
    typedef bsls::Types::Uint64 Uint64;

    // DATA
    bdlt::Datetime    d_timestamp;    // creation date and time
    int              d_processID;    // process id of creator
    Uint64           d_threadID;     // thread id of creator
    bsl::string      d_fileName;     // name of file where created (__FILE__)
    int              d_lineNumber;   // line number of said file   (__LINE__)
    bsl::string      d_category;     // category of log record
    int              d_severity;     // severity of log record

    bdlsb::MemOutStreamBuf
                     d_messageStreamBuf;
                                     // stream buffer associated with the
                                     // message attribute

    // FRIENDS
    friend bool operator==(const RecordAttributes&amp;,
                           const RecordAttributes&amp;);

  public:
    // CREATORS
    RecordAttributes(bslma::Allocator *basicAllocator = 0);
        // Create a record attributes object with all attributes having default
        // values.  Optionally specify a &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.

    RecordAttributes(const bdlt::Datetime&amp;  timestamp,
                          int                   processID,
                          bsls::Types::Uint64   threadID,
                          const char           *fileName,
                          int                   lineNumber,
                          const char           *category,
                          int                   severity,
                          const char           *message,
                          bslma::Allocator     *basicAllocator = 0);
        // Create a record attributes object having the specified &#39;timestamp&#39;,
        // &#39;processID&#39;, &#39;threadID&#39;, &#39;fileName&#39;, &#39;lineNumber&#39;, &#39;category&#39;,
        // &#39;severity&#39; and &#39;message&#39; values, respectively.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.  The behavior is
        // undefined if any &#39;const char *&#39; argument is null.

    RecordAttributes(const RecordAttributes&amp;  original,
                          bslma::Allocator             *basicAllocator = 0);
        // Create a record attributes object having the value of the specified
        // &#39;original&#39; record attributes object.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    ~RecordAttributes();
        // Destroy this record attributes object.

    // MANIPULATORS
    RecordAttributes&amp; operator=(const RecordAttributes&amp; rhs);
        // Assign to this record attributes object the value of the specified
        // &#39;rhs&#39; record attributes object.

    void clearMessage();
        // Set the message attribute of this record attributes object to
        // empty string.

    bdlsb::MemOutStreamBuf&amp; messageStreamBuf();
        // Return a reference to the modifiable stream buffer associated with
        // the message attribute of this record attributes object.

    void setCategory(const char *category);
        // Set the category attribute of this record attributes object to the
        // specified (non-null) &#39;category&#39;.

    void setFileName(const char *fileName);
        // Set the filename attribute of this record attributes object to the
        // specified (non-null) &#39;fileName&#39;.

    void setLineNumber(int lineNumber);
        // Set the line number attribute of this record attributes object to
        // the specified &#39;lineNumber&#39;.

    void setMessage(const char *message);
        // Set the message attribute of this record attributes object to the
        // specified (non-null) &#39;message&#39;.

    void setProcessID(int processID);
        // Set the processID attribute of this record attributes object to the
        // specified &#39;processID&#39;.

    void setSeverity(int severity);
        // Set the severity attribute of this record attributes object to the
        // specified &#39;severity&#39;.

    void setThreadID(bsls::Types::Uint64 threadID);
        // Set the threadID attribute of this record attributes object to the
        // specified &#39;threadID&#39;.

    void setTimestamp(const bdlt::Datetime&amp; timestamp);
        // Set the timestamp attribute of this record attributes object to the
        // specified &#39;timestamp&#39;.

    // ACCESSORS
    const char *category() const;
        // Return the category attribute of this record attributes object.

    const char *fileName() const;
        // Return the filename attribute of this record attributes object.

    int lineNumber() const;
        // Return the line number attribute of this record attributes object.

    const char *message() const;
        // Return the message attribute of this record attributes object.

    bslstl::StringRef messageRef() const;
        // Return a string reference providing non-modifiable access to the
        // message attribute of this record attributes object.  Note that the
        // returned string reference is not null-terminated, and may contain
        // null (&#39;\0&#39;) characters.

    int processID() const;
        // Return the processID attribute of this record attributes object.

    int severity() const;
        // Return the severity attribute of this record attributes object.

    bsls::Types::Uint64 threadID() const;
        // Return the threadID attribute of this record attributes object.

    const bdlt::Datetime&amp; timestamp() const;
        // Return the timestamp attribute of this record attributes object.

    const bdlsb::MemOutStreamBuf&amp; messageStreamBuf() const;
        // Return a reference to the non-modifiable stream buffer associated
        // with the message attribute of this record attributes object.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.

};

// FREE OPERATORS
bool operator==(const RecordAttributes&amp; lhs,
                const RecordAttributes&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; record attributes objects
    // have the same value, and &#39;false&#39; otherwise.  Two record attributes
    // objects have the same value if each respective pair of attributes have
    // the same value.

inline
bool operator!=(const RecordAttributes&amp; lhs,
               const RecordAttributes&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; record attributes objects
    // do not have the same value, and &#39;false&#39; otherwise.  Two record
    // attributes objects do not have the same value if one or more respective
    // attributes differ in value.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                stream,
                         const RecordAttributes&amp; attributes);
    // Format the members of the specified &#39;attributes&#39; to the specified
    // output &#39;stream&#39; and return a reference to the modifiable &#39;stream&#39;.

// ============================================================================
//                          INLINE FUNCTION DEFINITIONS
// ============================================================================

                        // ---------------------------
                        // class RecordAttributes
                        // ---------------------------

// CREATORS
inline
RecordAttributes::~RecordAttributes()
{
}

// MANIPULATORS
inline
void RecordAttributes::clearMessage()
{
    d_messageStreamBuf.pubseekpos(0);
}

inline
bdlsb::MemOutStreamBuf&amp; RecordAttributes::messageStreamBuf()
{
    return d_messageStreamBuf;
}

inline
void RecordAttributes::setCategory(const char *category)
{
    d_category = category;
}

inline
void RecordAttributes::setFileName(const char *fileName)
{
    d_fileName = fileName;
}

inline
void RecordAttributes::setLineNumber(int lineNumber)
{
    d_lineNumber = lineNumber;
}

inline
void RecordAttributes::setProcessID(int processID)
{
    d_processID = processID;
}

inline
void RecordAttributes::setSeverity(int severity)
{
    d_severity = severity;
}

inline
void RecordAttributes::setThreadID(bsls::Types::Uint64 threadID)
{
    d_threadID = threadID;
}

inline
void RecordAttributes::setTimestamp(const bdlt::Datetime&amp; timestamp)
{
    d_timestamp = timestamp;
}

// ACCESSORS
inline
const char *RecordAttributes::category() const
{
    return d_category.c_str();
}

inline
const char *RecordAttributes::fileName() const
{
    return d_fileName.c_str();
}

inline
int RecordAttributes::lineNumber() const
{
    return d_lineNumber;
}

inline
int RecordAttributes::processID() const
{
    return d_processID;
}

inline
int RecordAttributes::severity() const
{
    return d_severity;
}

inline
bsls::Types::Uint64 RecordAttributes::threadID() const
{
    return d_threadID;
}

inline
const bdlsb::MemOutStreamBuf&amp; RecordAttributes::messageStreamBuf() const
{
    return d_messageStreamBuf;
}

inline
const bdlt::Datetime&amp; RecordAttributes::timestamp() const
{
    return d_timestamp;
}

}  // close package namespace

// FREE OPERATORS
inline
bool ball::operator!=(const RecordAttributes&amp; lhs,
                const RecordAttributes&amp; rhs)
{
    return !(lhs == rhs);
}

inline
bsl::ostream&amp; ball::operator&lt;&lt;(bsl::ostream&amp;                stream,
                         const RecordAttributes&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
