<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlcc::SkipList</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlcc.html">bdlcc</a>      </li>
      <li><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList&lt; KEY, DATA &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>bdlcc::SkipList&lt; KEY, DATA &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlcc::SkipList" -->
<p><code>#include &lt;<a class="el" href="bdlcc__skiplist_8h_source.html">bdlcc_skiplist.h</a>&gt;</code></p>

<p><a href="classbdlcc_1_1SkipList-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classbdlcc_1_1SkipList.html#ad386e650609905a2e4d606a4b90724fcaa62153c3cbc88afb880c28b0649bc5b5">e_SUCCESS</a> =  0, 
<a class="el" href="classbdlcc_1_1SkipList.html#ad386e650609905a2e4d606a4b90724fca55b203fc6c97a838820e5589ee412d06">e_NOT_FOUND</a> =  1, 
<a class="el" href="classbdlcc_1_1SkipList.html#ad386e650609905a2e4d606a4b90724fcac946cd107f483ab70ca6083f95608111">e_DUPLICATE</a> =  2, 
<a class="el" href="classbdlcc_1_1SkipList.html#ad386e650609905a2e4d606a4b90724fca15cdff36beb062f4d6103dd73af168bb">e_INVALID</a> =  3
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbdlcc_1_1SkipListPair.html">SkipListPair</a>&lt; KEY, DATA &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#aa79714f305888f85672a09f8ca56b63b">Pair</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbdlcc_1_1SkipListPairHandle.html">SkipListPairHandle</a><br class="typebreak"/>
&lt; KEY, DATA &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a8976e7001a189e6df8e6b3942d740fe6">PairHandle</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#afba033b1eddc30e94d10967ee307ae7b">BSLALG_DECLARE_NESTED_TRAITS</a> (<a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a>, <a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a7cdc5d8d56a7075cd400adf55c06a3a5">SkipList</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a404d616973b2675c29c47d96b92c216a">SkipList</a> (const <a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a> &amp;original, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a0c1ea7ead4668be44e8eab6f625e2e1d">~SkipList</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a4d817e4f149c6f83d39c34f840e34dda">operator=</a> (const <a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a0f6e319bc0ffcc764f92b32a9fb134bd">releaseReferenceRaw</a> (const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *reference)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a9e95849bc81b988463b10366d48296e5">add</a> (const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#aa613f26513e539742b76c64616e7ccaf">add</a> (<a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#ace4446c987482b7c454dc31551d11380">addAtLevelRaw</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **result, int level, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#af197c5e7e49b045bc2a0d79b60373826">addAtLevelUniqueRaw</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **result, int level, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#ac4c824e3d81e595ff6b93ee8872e9bda">addRaw</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a2f77a57da9bd76e31f81f7786dcee4d8">addUnique</a> (const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#aa584dffd527be49907049c8f9ba81f74">addUnique</a> (<a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a307f2cb6df36eae25b07d991c5ce79c8">addUniqueRaw</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a3dafb162414304d565594bdf2b50e440">addR</a> (const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a4eaa32935049d02394bba51436fdcc65">addR</a> (<a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a5d08d0d5948e545440b190281b0b847b">addAtLevelRawR</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **result, int level, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#ab902892ccd2657834da91a26f730a620">addAtLevelUniqueRawR</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **result, int level, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#aa62ead85919a43c20fc36c5eb0724d2a">addRawR</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a4cef4792bfba518eacaca9971a69a8e5">addUniqueR</a> (const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a8cf3ba951c25a6e951b698b030dcd588">addUniqueR</a> (<a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a8a3b475f2f297a121e241b532b202ba7">addUniqueRawR</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a7305af1c8d9683980a60a3a35d0a7d44">popFront</a> (<a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *item=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a7e07e1bb535262ffa735dc37af7b7526">popFrontRaw</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a10cac5ec27477fd3819351f2a767b26e">remove</a> (const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *reference)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#aaa496982e9da8db56ce05cb5d22d122d">removeAll</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> &gt; *removed=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a4fc49ffbf5b7a0844dc0e1d4e3cce378">removeAllRaw</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> * &gt; *removed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a83063b41f0261dc6a5bff917d6ec107e">update</a> (const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *reference, const KEY &amp;newKey, bool *newFrontFlag=0, bool allowDuplicates=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#adbe65ff8828aa5bc2b6fe7b2000889bb">updateR</a> (const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *reference, const KEY &amp;newKey, bool *newFrontFlag=0, bool allowDuplicates=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a6a03b2778b75430535f19f0105c92c24">addPairReferenceRaw</a> (const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *reference) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a38c568eafa185a4e34074470f28c5538">back</a> (<a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *back) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a5504cf71fdc59b6c1e8a2b45d5a13948">backRaw</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **back) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a4ddd5bef8222a9379d5de41151256dfa">exists</a> (const KEY &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a3a3955052b4cc0967b2c5a72462815d2">find</a> (<a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *item, const KEY &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a35129ad15322fc4f3091d2bc547ec3a6">findRaw</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **item, const KEY &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a27eb46d75af7dfc51e6730759bc8e12e">findR</a> (<a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *item, const KEY &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#ab46625325f3fe3bee2ef4a108b2343b1">findRRaw</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **item, const KEY &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a70accea79576f390739af971a2995ad6">front</a> (<a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *front) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#aee03582fb1090295ac21e35300f772ae">frontRaw</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **front) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a6f3069d1bc86eda173f520129c6ca0b2">isEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a488aaaa5d022e4a1a3fe9aa5a51b112c">length</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a734fc4f8da703bb96bdc457355cca42d">next</a> (<a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *next, const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *reference) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#ab141fcb51f85ca65b6da99b088aaac28">nextRaw</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **next, const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *reference) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a51b8ac6909052bb53404d8b01e5fbc1d">previous</a> (<a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *prevPair, const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *reference) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a6dfefb33edb388085566e67108b36185">previousRaw</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **prevPair, const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *reference) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a01596bde229a1ecabafe060a692e26cc">print</a> (bsl::ostream &amp;stream, int level=0, int spacesPerLevel=4) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a2a2669a2210aa69f98c5d39449b2879c">skipBackward</a> (<a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *item) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#adb5a11eb09087379535e8fa86c2f4642">skipBackwardRaw</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **item) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a01ed21fb14a87f00f5f9a3e7d69b49c6">skipForward</a> (<a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *item) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#ae5d541365a67ff062cca30e630ad30a1">skipForwardRaw</a> (<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **item) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#ac63188222e0e0c15e65d2d36012d08d1">level</a> (const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *reference)</td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#aa4a8bb4823b607fa053a6bcf2f1a7b4f">SkipListPair&lt; KEY, DATA &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#a320efcbdcdb6cc07c572e68868366230">SkipListPairHandle&lt; KEY, DATA &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#aee593da4b0fed4d556887bf85f052128">operator==</a> (const <a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a>&lt; KEY, DATA &gt; &amp;lhs, const <a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a>&lt; KEY, DATA &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SkipList.html#aead97c4929e680cf2ee16798e5c4e653">operator!=</a> (const <a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a>&lt; KEY, DATA &gt; &amp;lhs, const <a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a>&lt; KEY, DATA &gt; &amp;rhs)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class KEY, class DATA&gt;<br/>
 class bdlcc::SkipList&lt; KEY, DATA &gt;</h3>

<p>This class provides a generic thread-safe Skip List (an ordered associative container). It supports an almost complete set of <em>value</em> <em>semantic</em> operations, including copy construction, assignment, equality comparison, and <code>ostream</code> printing (but not <code>bdex</code> serialization). </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="aa79714f305888f85672a09f8ca56b63b"></a><!-- doxytag: member="bdlcc::SkipList::Pair" ref="aa79714f305888f85672a09f8ca56b63b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbdlcc_1_1SkipListPair.html">SkipListPair</a>&lt;KEY, DATA&gt; <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::<a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8976e7001a189e6df8e6b3942d740fe6"></a><!-- doxytag: member="bdlcc::SkipList::PairHandle" ref="a8976e7001a189e6df8e6b3942d740fe6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbdlcc_1_1SkipListPairHandle.html">SkipListPairHandle</a>&lt;KEY, DATA&gt; <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::<a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ad386e650609905a2e4d606a4b90724fc"></a><!-- doxytag: member="bdlcc::SkipList::@150" ref="ad386e650609905a2e4d606a4b90724fc" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad386e650609905a2e4d606a4b90724fcaa62153c3cbc88afb880c28b0649bc5b5"></a><!-- doxytag: member="e_SUCCESS" ref="ad386e650609905a2e4d606a4b90724fcaa62153c3cbc88afb880c28b0649bc5b5" args="" -->e_SUCCESS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad386e650609905a2e4d606a4b90724fca55b203fc6c97a838820e5589ee412d06"></a><!-- doxytag: member="e_NOT_FOUND" ref="ad386e650609905a2e4d606a4b90724fca55b203fc6c97a838820e5589ee412d06" args="" -->e_NOT_FOUND</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad386e650609905a2e4d606a4b90724fcac946cd107f483ab70ca6083f95608111"></a><!-- doxytag: member="e_DUPLICATE" ref="ad386e650609905a2e4d606a4b90724fcac946cd107f483ab70ca6083f95608111" args="" -->e_DUPLICATE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad386e650609905a2e4d606a4b90724fca15cdff36beb062f4d6103dd73af168bb"></a><!-- doxytag: member="e_INVALID" ref="ad386e650609905a2e4d606a4b90724fca15cdff36beb062f4d6103dd73af168bb" args="" -->e_INVALID</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7cdc5d8d56a7075cd400adf55c06a3a5"></a><!-- doxytag: member="bdlcc::SkipList::SkipList" ref="a7cdc5d8d56a7075cd400adf55c06a3a5" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::<a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new Skip List. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a404d616973b2675c29c47d96b92c216a"></a><!-- doxytag: member="bdlcc::SkipList::SkipList" ref="a404d616973b2675c29c47d96b92c216a" args="(const SkipList &amp;original, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::<a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a>&lt; KEY, DATA &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new Skip List initialized to the value of the specified <code>original</code> list. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a0c1ea7ead4668be44e8eab6f625e2e1d"></a><!-- doxytag: member="bdlcc::SkipList::~SkipList" ref="a0c1ea7ead4668be44e8eab6f625e2e1d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::~<a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this Skip List. The behavior is undefined if references are outstanding to any pairs in the list. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="afba033b1eddc30e94d10967ee307ae7b"></a><!-- doxytag: member="bdlcc::SkipList::BSLALG_DECLARE_NESTED_TRAITS" ref="afba033b1eddc30e94d10967ee307ae7b" args="(SkipList, bslalg::TypeTraitUsesBslmaAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::BSLALG_DECLARE_NESTED_TRAITS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a>&lt; KEY, DATA &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac63188222e0e0c15e65d2d36012d08d1"></a><!-- doxytag: member="bdlcc::SkipList::level" ref="ac63188222e0e0c15e65d2d36012d08d1" args="(const Pair *reference)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::level </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *&nbsp;</td>
          <td class="paramname"> <em>reference</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the level of the pair identified by the specified <code>reference</code>. This method is provided for testing. </p>

</div>
</div>
<a class="anchor" id="a4d817e4f149c6f83d39c34f840e34dda"></a><!-- doxytag: member="bdlcc::SkipList::operator=" ref="a4d817e4f149c6f83d39c34f840e34dda" args="(const SkipList &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a>&amp; <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a>&lt; KEY, DATA &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this Skip List the value of the specified <code>rhs</code> list and return a reference to the modifiable list. </p>

</div>
</div>
<a class="anchor" id="a0f6e319bc0ffcc764f92b32a9fb134bd"></a><!-- doxytag: member="bdlcc::SkipList::releaseReferenceRaw" ref="a0f6e319bc0ffcc764f92b32a9fb134bd" args="(const Pair *reference)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::releaseReferenceRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *&nbsp;</td>
          <td class="paramname"> <em>reference</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the specified <code>reference</code>. After calling this method, the value of <code>reference</code> must not be used or released again. </p>

</div>
</div>
<a class="anchor" id="a9e95849bc81b988463b10366d48296e5"></a><!-- doxytag: member="bdlcc::SkipList::add" ref="a9e95849bc81b988463b10366d48296e5" args="(const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list. Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. </p>

</div>
</div>
<a class="anchor" id="aa613f26513e539742b76c64616e7ccaf"></a><!-- doxytag: member="bdlcc::SkipList::add" ref="aa613f26513e539742b76c64616e7ccaf" args="(PairHandle *result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list, and load into the specified <code>result</code> a reference to the pair in the list. Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. </p>

</div>
</div>
<a class="anchor" id="ace4446c987482b7c454dc31551d11380"></a><!-- doxytag: member="bdlcc::SkipList::addAtLevelRaw" ref="ace4446c987482b7c454dc31551d11380" args="(Pair **result, int level, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::addAtLevelRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list at the specified <code>level</code>, and load into the specified <code>result</code> a reference to the pair in the list. The <code>result</code> reference must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. The behavior is undefined if <code>level</code> is greater than the implementation-defined maximum level of this class, or if <code>level</code> is negative. Note that this method is provided for testing purposes. </p>

</div>
</div>
<a class="anchor" id="af197c5e7e49b045bc2a0d79b60373826"></a><!-- doxytag: member="bdlcc::SkipList::addAtLevelUniqueRaw" ref="af197c5e7e49b045bc2a0d79b60373826" args="(Pair **result, int level, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::addAtLevelUniqueRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list at the specified <code>level</code>, and load into the specified <code>result</code> a reference to the pair in the list. The <code>result</code> reference must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. The behavior is undefined if <code>level</code> is greater than the implementation-defined maximum level of this class, or if <code>level</code> is negative. Return 0 on success, and a non-zero value (with no effect on the list) if <code>key</code> is already in the list. Note that this method is provided for testing purposes. </p>

</div>
</div>
<a class="anchor" id="ac4c824e3d81e595ff6b93ee8872e9bda"></a><!-- doxytag: member="bdlcc::SkipList::addRaw" ref="ac4c824e3d81e595ff6b93ee8872e9bda" args="(Pair **result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::addRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list, and load into the specified <code>result</code> a reference to the pair in the list. The <code>result</code> reference must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. </p>

</div>
</div>
<a class="anchor" id="a2f77a57da9bd76e31f81f7786dcee4d8"></a><!-- doxytag: member="bdlcc::SkipList::addUnique" ref="a2f77a57da9bd76e31f81f7786dcee4d8" args="(const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::addUnique </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list. Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. Return 0 on success, and a non-zero value (with no effect on the list) if <code>key</code> is already in the list. </p>

</div>
</div>
<a class="anchor" id="aa584dffd527be49907049c8f9ba81f74"></a><!-- doxytag: member="bdlcc::SkipList::addUnique" ref="aa584dffd527be49907049c8f9ba81f74" args="(PairHandle *result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::addUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list, and load into the specified <code>result</code> a reference to the pair in the list. Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. Return 0 on success, and a non-zero value (with no effect on the list) if <code>key</code> is already in the list. </p>

</div>
</div>
<a class="anchor" id="a307f2cb6df36eae25b07d991c5ce79c8"></a><!-- doxytag: member="bdlcc::SkipList::addUniqueRaw" ref="a307f2cb6df36eae25b07d991c5ce79c8" args="(Pair **result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::addUniqueRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list, and load into the specified <code>result</code> a reference to the pair in the list. The <code>result</code> reference must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. Return 0 on success, and a non-zero value (with no effect on the list) if <code>key</code> is already in the list. </p>

</div>
</div>
<a class="anchor" id="a3dafb162414304d565594bdf2b50e440"></a><!-- doxytag: member="bdlcc::SkipList::addR" ref="a3dafb162414304d565594bdf2b50e440" args="(const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::addR </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list. Search for the correct position for <code>key</code> from the back of the list (in descending order by key value). Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. </p>

</div>
</div>
<a class="anchor" id="a4eaa32935049d02394bba51436fdcc65"></a><!-- doxytag: member="bdlcc::SkipList::addR" ref="a4eaa32935049d02394bba51436fdcc65" args="(PairHandle *result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::addR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list, and load into the specified <code>result</code> a reference to the pair in the list. Search for the correct position for <code>key</code> from the back of the list (in descending order by key value). Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. </p>

</div>
</div>
<a class="anchor" id="a5d08d0d5948e545440b190281b0b847b"></a><!-- doxytag: member="bdlcc::SkipList::addAtLevelRawR" ref="a5d08d0d5948e545440b190281b0b847b" args="(Pair **result, int level, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::addAtLevelRawR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list at the specified <code>level</code>, and load into the specified <code>result</code> a reference to the pair in the list. Search for the correct position for <code>key</code> from the back of the list (in descending order by key value). The <code>result</code> reference must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. The behavior is undefined if <code>level</code> is greater than the implementation-defined maximum level of this class, or if <code>level</code> is negative. Note that this method is provided for testing purposes. </p>

</div>
</div>
<a class="anchor" id="ab902892ccd2657834da91a26f730a620"></a><!-- doxytag: member="bdlcc::SkipList::addAtLevelUniqueRawR" ref="ab902892ccd2657834da91a26f730a620" args="(Pair **result, int level, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::addAtLevelUniqueRawR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list at the specified <code>level</code>, and load into the specified <code>result</code> a reference to the pair in the list. Search for the correct position for <code>key</code> from the back of the list (in descending order by key value). The <code>result</code> reference must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. The behavior is undefined if <code>level</code> is greater than the implementation-defined maximum level of this class, or if <code>level</code> is negative. Return 0 on success, and a non-zero value (with no effect on the list) if <code>key</code> is already in the list. Note that this method is provided for testing purposes. </p>

</div>
</div>
<a class="anchor" id="aa62ead85919a43c20fc36c5eb0724d2a"></a><!-- doxytag: member="bdlcc::SkipList::addRawR" ref="aa62ead85919a43c20fc36c5eb0724d2a" args="(Pair **result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::addRawR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list, and load into the specified <code>result</code> a reference to the pair in the list. Search for the correct position for <code>key</code> from the back of the list (in descending order by key value). The <code>result</code> reference must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. </p>

</div>
</div>
<a class="anchor" id="a4cef4792bfba518eacaca9971a69a8e5"></a><!-- doxytag: member="bdlcc::SkipList::addUniqueR" ref="a4cef4792bfba518eacaca9971a69a8e5" args="(const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::addUniqueR </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list. Search for the correct position for <code>key</code> from the back of the list (in descending order by key value). Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. Return 0 on success, and a non-zero value (with no effect on the list) if <code>key</code> is already in the list. </p>

</div>
</div>
<a class="anchor" id="a8cf3ba951c25a6e951b698b030dcd588"></a><!-- doxytag: member="bdlcc::SkipList::addUniqueR" ref="a8cf3ba951c25a6e951b698b030dcd588" args="(PairHandle *result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::addUniqueR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list, and load into the specified <code>result</code> a reference to the pair in the list. Search for the correct position for <code>key</code> from the back of the list (in descending order by key value). Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. Return 0 on success, and a non-zero value (with no effect on the list) if <code>key</code> is already in the list. </p>

</div>
</div>
<a class="anchor" id="a8a3b475f2f297a121e241b532b202ba7"></a><!-- doxytag: member="bdlcc::SkipList::addUniqueRawR" ref="a8a3b475f2f297a121e241b532b202ba7" args="(Pair **result, const KEY &amp;key, const DATA &amp;data, bool *newFrontFlag=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::addUniqueRawR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DATA &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>key</code> / <code>data</code> pair to this list, and load into the specified <code>result</code> a reference to the pair in the list. Search for the correct position for <code>key</code> from the back of the list (in descending order by key value). The <code>result</code> reference must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Load into the the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the pair is at the front of the list, and a <code>false</code> value otherwise. Return 0 on success, and a non-zero value (with no effect on the list) if <code>key</code> is already in the list. </p>

</div>
</div>
<a class="anchor" id="a7305af1c8d9683980a60a3a35d0a7d44"></a><!-- doxytag: member="bdlcc::SkipList::popFront" ref="a7305af1c8d9683980a60a3a35d0a7d44" args="(PairHandle *item=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::popFront </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>item</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the first item from the list and load a reference to it into the optionally specified <code>item</code>. Return 0 on success, and a non-zero value if the list is empty. </p>

</div>
</div>
<a class="anchor" id="a7e07e1bb535262ffa735dc37af7b7526"></a><!-- doxytag: member="bdlcc::SkipList::popFrontRaw" ref="a7e07e1bb535262ffa735dc37af7b7526" args="(Pair **item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::popFrontRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the first item from the list and load a reference to it into the specified <code>item</code>. This reference must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Return 0 on success, and a non-zero value if the list is empty. </p>

</div>
</div>
<a class="anchor" id="a10cac5ec27477fd3819351f2a767b26e"></a><!-- doxytag: member="bdlcc::SkipList::remove" ref="a10cac5ec27477fd3819351f2a767b26e" args="(const Pair *reference)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *&nbsp;</td>
          <td class="paramname"> <em>reference</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the item identified by the specified <code>reference</code> from the list. Return 0 on success, and a non-zero value if the pair has already been removed from the list. </p>

</div>
</div>
<a class="anchor" id="aaa496982e9da8db56ce05cb5d22d122d"></a><!-- doxytag: member="bdlcc::SkipList::removeAll" ref="aaa496982e9da8db56ce05cb5d22d122d" args="(bsl::vector&lt; PairHandle &gt; *removed=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::removeAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>removed</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all items from this list. Load into the optionally specified <code>removed</code> vector handles which can be used to refer to the removed items. Note that the items in <code>removed</code> will be in ascending order by key value. Note also that all references in <code>removed</code> must be released (i.e., destroyed) before this skip list is destroyed. Return the number of items that were removed from this list. </p>

</div>
</div>
<a class="anchor" id="a4fc49ffbf5b7a0844dc0e1d4e3cce378"></a><!-- doxytag: member="bdlcc::SkipList::removeAllRaw" ref="a4fc49ffbf5b7a0844dc0e1d4e3cce378" args="(bsl::vector&lt; Pair * &gt; *removed)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::removeAllRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> * &gt; *&nbsp;</td>
          <td class="paramname"> <em>removed</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all items from this list. Load into the specified <code>removed</code> vector pointers which can be used to refer to the removed items. <em>Each</em> such pointer must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Note that the pairs in <code>removed</code> will be in ascending order by key value. Note also that all references must be released before this skip list is destroyed. Return the number of items that were removed from this list. </p>

</div>
</div>
<a class="anchor" id="a83063b41f0261dc6a5bff917d6ec107e"></a><!-- doxytag: member="bdlcc::SkipList::update" ref="a83063b41f0261dc6a5bff917d6ec107e" args="(const Pair *reference, const KEY &amp;newKey, bool *newFrontFlag=0, bool allowDuplicates=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *&nbsp;</td>
          <td class="paramname"> <em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>newKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allowDuplicates</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign the specified <code>newKey</code> value to the pair identified by the specified <code>reference</code>, moving the pair within the list as necessary. Load into the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the new location of the pair is the front of the list. Return 0 on success, <code>e_NOT_FOUND</code> if the pair referred to by <code>reference</code> is no longer in the list, or <code>e_DUPLICATE</code> if the optionally specified <code>allowDuplicates</code> is <code>false</code> and <code>newKey</code> already appears in the list. </p>

</div>
</div>
<a class="anchor" id="adbe65ff8828aa5bc2b6fe7b2000889bb"></a><!-- doxytag: member="bdlcc::SkipList::updateR" ref="adbe65ff8828aa5bc2b6fe7b2000889bb" args="(const Pair *reference, const KEY &amp;newKey, bool *newFrontFlag=0, bool allowDuplicates=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::updateR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *&nbsp;</td>
          <td class="paramname"> <em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>newKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>newFrontFlag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allowDuplicates</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign the specified <code>newKey</code> value to the pair identified by the specified <code>reference</code>, moving the pair within the list as necessary. Search for the new position from the back of the list (in descending order by key value). Load into the optionally specified <code>newFrontFlag</code> a <code>true</code> value if the new location of the pair is the front of the list. Return 0 on success, <code>e_NOT_FOUND</code> if the pair referred to by <code>reference</code> is no longer in the list, or <code>e_DUPLICATE</code> if the optionally specified <code>allowDuplicates</code> is <code>false</code> and <code>newKey</code> already appears in the list. </p>

</div>
</div>
<a class="anchor" id="a6a03b2778b75430535f19f0105c92c24"></a><!-- doxytag: member="bdlcc::SkipList::addPairReferenceRaw" ref="a6a03b2778b75430535f19f0105c92c24" args="(const Pair *reference) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a>* <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::addPairReferenceRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *&nbsp;</td>
          <td class="paramname"> <em>reference</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increment the reference count for the list element referred to by the specified <code>reference</code>. There must be a corresponding call to <code>releaseReferenceRaw</code> when the reference is no longer needed. The behavior is undefined <code>item</code> has already been released. Return <code>reference</code>. </p>

</div>
</div>
<a class="anchor" id="a38c568eafa185a4e34074470f28c5538"></a><!-- doxytag: member="bdlcc::SkipList::back" ref="a38c568eafa185a4e34074470f28c5538" args="(PairHandle *back) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>back</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>back</code> a reference to the last item in the list. Return 0 on success, and a non-zero value (with no effect on <code>back</code>) if the list is empty. </p>

</div>
</div>
<a class="anchor" id="a5504cf71fdc59b6c1e8a2b45d5a13948"></a><!-- doxytag: member="bdlcc::SkipList::backRaw" ref="a5504cf71fdc59b6c1e8a2b45d5a13948" args="(Pair **back) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::backRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>back</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>back</code> a reference to the last item in the list. The <code>back</code> reference must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Return 0 on success, and a non-zero value if the list is empty. Note that if the list is empty, the value of <code>*back</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a4ddd5bef8222a9379d5de41151256dfa"></a><!-- doxytag: member="bdlcc::SkipList::exists" ref="a4ddd5bef8222a9379d5de41151256dfa" args="(const KEY &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::exists </td>
          <td>(</td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if there is a pair in the list with the specified <code>key</code>, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a3a3955052b4cc0967b2c5a72462815d2"></a><!-- doxytag: member="bdlcc::SkipList::find" ref="a3a3955052b4cc0967b2c5a72462815d2" args="(PairHandle *item, const KEY &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>item</code> a reference to the element in the list with the specified <code>key</code>. If there are multiple elements with the <code>key</code>, it is not defined which one will be returned. Return 0 on success, and a non-zero value if no such item could be found. </p>

</div>
</div>
<a class="anchor" id="a35129ad15322fc4f3091d2bc547ec3a6"></a><!-- doxytag: member="bdlcc::SkipList::findRaw" ref="a35129ad15322fc4f3091d2bc547ec3a6" args="(Pair **item, const KEY &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::findRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>item</code> a reference to the element in the list with the specified <code>key</code>. If there are multiple elements with the <code>key</code>, it is not defined which one will be returned. The <code>item</code> reference must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Return 0 on success, and a non-zero value if no such item could be found. </p>

</div>
</div>
<a class="anchor" id="a27eb46d75af7dfc51e6730759bc8e12e"></a><!-- doxytag: member="bdlcc::SkipList::findR" ref="a27eb46d75af7dfc51e6730759bc8e12e" args="(PairHandle *item, const KEY &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::findR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>item</code> a reference to the element in the list with the specified <code>key</code> found by searching the list in descending order. If there are multiple elements with the <code>key</code>, it is not defined which one will be returned. Return 0 on success, and a non-zero value if no such item could be found. </p>

</div>
</div>
<a class="anchor" id="ab46625325f3fe3bee2ef4a108b2343b1"></a><!-- doxytag: member="bdlcc::SkipList::findRRaw" ref="ab46625325f3fe3bee2ef4a108b2343b1" args="(Pair **item, const KEY &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::findRRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>item</code> a reference to the element in the list with the specified <code>key</code> found by searching the list in descending order. If there are multiple elements with the <code>key</code>, it is not defined which one will be returned. The <code>item</code> reference must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Return 0 on success, and a non-zero value if no such item could be found. </p>

</div>
</div>
<a class="anchor" id="a70accea79576f390739af971a2995ad6"></a><!-- doxytag: member="bdlcc::SkipList::front" ref="a70accea79576f390739af971a2995ad6" args="(PairHandle *front) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>front</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>front</code> a reference to the first item in the list. Return 0 on success, and a non-zero value (with no effect on <code>front</code>) if the list is empty. </p>

</div>
</div>
<a class="anchor" id="aee03582fb1090295ac21e35300f772ae"></a><!-- doxytag: member="bdlcc::SkipList::frontRaw" ref="aee03582fb1090295ac21e35300f772ae" args="(Pair **front) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::frontRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>front</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>front</code> a reference to the first item in the list. The <code>front</code> reference must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Return 0 on success, and a non-zero value if the list is empty. </p>

</div>
</div>
<a class="anchor" id="a6f3069d1bc86eda173f520129c6ca0b2"></a><!-- doxytag: member="bdlcc::SkipList::isEmpty" ref="a6f3069d1bc86eda173f520129c6ca0b2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this list is empty, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a488aaaa5d022e4a1a3fe9aa5a51b112c"></a><!-- doxytag: member="bdlcc::SkipList::length" ref="a488aaaa5d022e4a1a3fe9aa5a51b112c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of items in this list. </p>

</div>
</div>
<a class="anchor" id="a734fc4f8da703bb96bdc457355cca42d"></a><!-- doxytag: member="bdlcc::SkipList::next" ref="a734fc4f8da703bb96bdc457355cca42d" args="(PairHandle *next, const Pair *reference) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *&nbsp;</td>
          <td class="paramname"> <em>reference</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>next</code> a reference to the item that appears in the list after the item identified by the specified <code>reference</code>. Return 0 on success, or a non-zero value if <code>reference</code> refers to the back of the list. </p>

</div>
</div>
<a class="anchor" id="ab141fcb51f85ca65b6da99b088aaac28"></a><!-- doxytag: member="bdlcc::SkipList::nextRaw" ref="ab141fcb51f85ca65b6da99b088aaac28" args="(Pair **next, const Pair *reference) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::nextRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *&nbsp;</td>
          <td class="paramname"> <em>reference</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>next</code> a reference to the item that appears in the list after the item identified by the specified <code>reference</code>. The <code>next</code> reference must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Return 0 on success, or a non-zero value if <code>reference</code> refers to the back of the list. </p>

</div>
</div>
<a class="anchor" id="a51b8ac6909052bb53404d8b01e5fbc1d"></a><!-- doxytag: member="bdlcc::SkipList::previous" ref="a51b8ac6909052bb53404d8b01e5fbc1d" args="(PairHandle *prevPair, const Pair *reference) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::previous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>prevPair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *&nbsp;</td>
          <td class="paramname"> <em>reference</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>prevPair</code> a reference to the pair that appears in the list before the pair identified by the specified <code>reference</code>. Return 0 on success, or a non-zero value if <code>reference</code> refers to the front of the list. </p>

</div>
</div>
<a class="anchor" id="a6dfefb33edb388085566e67108b36185"></a><!-- doxytag: member="bdlcc::SkipList::previousRaw" ref="a6dfefb33edb388085566e67108b36185" args="(Pair **prevPair, const Pair *reference) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::previousRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>prevPair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> *&nbsp;</td>
          <td class="paramname"> <em>reference</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>prevPair</code> a reference to the pair that appears in the list before the pair identified by the specified <code>reference</code>. The <code>prevPair</code> reference must be released (using <code>releaseReferenceRaw</code>) when it is no longer needed. Return 0 on success, or a non-zero value if <code>reference</code> refers to the front of the list. </p>

</div>
</div>
<a class="anchor" id="a01596bde229a1ecabafe060a692e26cc"></a><!-- doxytag: member="bdlcc::SkipList::print" ref="a01596bde229a1ecabafe060a692e26cc" args="(bsl::ostream &amp;stream, int level=0, int spacesPerLevel=4) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::print </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>spacesPerLevel</em> = <code>4</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Format this list object to the specified output <code>stream</code> at the (absolute value of) the optionally specified indentation <code>level</code> and return a reference to <code>stream</code>. If <code>level</code> is specified, optionally specify <code>spacesPerLevel</code>, the number of spaces per indentation level for this and all of its nested objects. If <code>level</code> is negative, suppress indentation of the first line. If <code>spacesPerLevel</code> is negative, suppress all indentation AND format the entire output on one line. If <code>stream</code> is not valid on entry, this operation has no effect. </p>

</div>
</div>
<a class="anchor" id="a2a2669a2210aa69f98c5d39449b2879c"></a><!-- doxytag: member="bdlcc::SkipList::skipBackward" ref="a2a2669a2210aa69f98c5d39449b2879c" args="(PairHandle *item) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::skipBackward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adb5a11eb09087379535e8fa86c2f4642"></a><!-- doxytag: member="bdlcc::SkipList::skipBackwardRaw" ref="adb5a11eb09087379535e8fa86c2f4642" args="(Pair **item) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::skipBackwardRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the item identified by the specified <code>item</code> is not at the front of the list, load a reference to the previous item in the list into <code>item</code>; otherwise reset the value of <code>item</code>. Return 0 on success, and <code>e_NOT_FOUND</code> (with no effect on the value of <code>item</code>) if <code>item</code> is no longer in the list. </p>

</div>
</div>
<a class="anchor" id="a01ed21fb14a87f00f5f9a3e7d69b49c6"></a><!-- doxytag: member="bdlcc::SkipList::skipForward" ref="a01ed21fb14a87f00f5f9a3e7d69b49c6" args="(PairHandle *item) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::skipForward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">PairHandle</a> *&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae5d541365a67ff062cca30e630ad30a1"></a><!-- doxytag: member="bdlcc::SkipList::skipForwardRaw" ref="ae5d541365a67ff062cca30e630ad30a1" args="(Pair **item) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a>&lt; KEY, DATA &gt;::skipForwardRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1SkipListPair.html">Pair</a> **&nbsp;</td>
          <td class="paramname"> <em>item</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the item identified by the specified <code>item</code> is not at the end of the list, load a reference to the next item in the list into <code>item</code>; otherwise reset the value of <code>item</code>. Return 0 on success, and <code>e_NOT_FOUND</code> (with no effect on the value of <code>item</code>) if <code>item</code> is no longer in the list. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="aa4a8bb4823b607fa053a6bcf2f1a7b4f"></a><!-- doxytag: member="bdlcc::SkipList::SkipListPair&lt; KEY, DATA &gt;" ref="aa4a8bb4823b607fa053a6bcf2f1a7b4f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classbdlcc_1_1SkipListPair.html">SkipListPair</a>&lt; KEY, DATA &gt;<code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a320efcbdcdb6cc07c572e68868366230"></a><!-- doxytag: member="bdlcc::SkipList::SkipListPairHandle&lt; KEY, DATA &gt;" ref="a320efcbdcdb6cc07c572e68868366230" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classbdlcc_1_1SkipListPairHandle.html">SkipListPairHandle</a>&lt; KEY, DATA &gt;<code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aee593da4b0fed4d556887bf85f052128"></a><!-- doxytag: member="bdlcc::SkipList::operator==" ref="aee593da4b0fed4d556887bf85f052128" args="(const SkipList&lt; KEY, DATA &gt; &amp;lhs, const SkipList&lt; KEY, DATA &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a>&lt; KEY, DATA &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a>&lt; KEY, DATA &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> list has the same value as the specified <code>rhs</code> list, and <code>false</code> otherwise. Two lists A and B have the same value if they have the same number of elements, and if for all i in the range [0, numberOfElements), the i'th pair from the front of A has the same key and data values as the i'th pair from the front of B. Note that if there are duplicate key values in a list, the order of iteration over those pairs may be different than for another list which was constructed from the same sequence of values (and thus the lists may not compare equal). </p>

</div>
</div>
<a class="anchor" id="aead97c4929e680cf2ee16798e5c4e653"></a><!-- doxytag: member="bdlcc::SkipList::operator!=" ref="aead97c4929e680cf2ee16798e5c4e653" args="(const SkipList&lt; KEY, DATA &gt; &amp;lhs, const SkipList&lt; KEY, DATA &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class DATA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a>&lt; KEY, DATA &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlcc_1_1SkipList.html">SkipList</a>&lt; KEY, DATA &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> list list has a different value from the specified <code>rhs</code> list, and <code>false</code> otherwise. Two lists A and B have different values if they have a different of elements, or if there exists an i in the range [0, numberOfElements) such that the i'th pair from the front of A differs in key or data values from i'th pair from the front of B. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlcc__skiplist_8h_source.html">bdlcc_skiplist.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:21 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
