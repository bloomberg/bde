<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslstl_map Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_map<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL-compliant map class.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1map.html">bsl::map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>bsl::map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::DataWrapper</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1map_1_1value__compare.html">bsl::map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_compare</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef KEY&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga54e207aa9da1808a2e8c0df25dc7a2e6">bsl::map::key_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga8bade700892b7d26b0bcde4ef272ad05">bsl::map::mapped_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; const KEY, <br class="typebreak"/>
VALUE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga6dd80954d18b23a8aa09fa4025bd4faa">bsl::map::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef COMPARATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gafeac493d7046f0ac8123fa00e2089755">bsl::map::key_compare</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga7a50f0010c2b516533c9684cb9fef1f4">bsl::map::allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga056add01e6c2ccd6c703fda5c1258dcc">bsl::map::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga53c513ed018b7663942bbdcd11d39f34">bsl::map::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorTraits::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gac9ce5b375cdf890e215a86e91a786bd4">bsl::map::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorTraits::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gadc9aed19ba7685ee42fdcc4579354915">bsl::map::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorTraits::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gad86bcc81098a3df3cac75022ba6cf38d">bsl::map::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorTraits::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga6992dc59554a061e714a85e2b0b140fb">bsl::map::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
BloombergLP::bslstl::TreeIterator<br class="typebreak"/>
&lt; value_type, Node, <br class="typebreak"/>
difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gad1cccdfd3f0d24d6a6bf880d4b3280aa">bsl::map::iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
BloombergLP::bslstl::TreeIterator<br class="typebreak"/>
&lt; const value_type, Node, <br class="typebreak"/>
difference_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga22687147e65a99cca9f75f6b044171eb">bsl::map::const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga7865b0af06c253a2dafdea698d41aad1">bsl::map::reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gac502bfbb10e80e3051623e315c86fec8">bsl::map::const_reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gaf9aa1ac64eadea406f70017915d5879d">bsl::map::value_compare::result_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef value_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga96570ecedd3c687888c3c59904c77bd9">bsl::map::value_compare::first_argument_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef value_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga22481d614929a3d6cdf87c3d95f546a2">bsl::map::value_compare::second_argument_type</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gaa40fa7be9fe79cd6fe67253cc6ec9069">bsl::map::DataWrapper::DataWrapper</a> (const COMPARATOR &amp;comparator, const ALLOCATOR &amp;basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga049678dd29b295266bc000c0a782e124">bsl::map::value_compare::value_compare</a> (COMPARATOR comparator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gae876a33146ec50969a035a7365c74240">bsl::map::value_compare::operator()</a> (const value_type &amp;x, const value_type &amp;y) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga11a257f6cc29472acc64f276b39cc8a4">bsl::map::map</a> (const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga5acf3f5f6f5a4e3d71daaa8b90eb7d4e">bsl::map::map</a> (const ALLOCATOR &amp;basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gaee1698d3e611a01e013196afc64a2802">bsl::map::map</a> (const map &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga00829bf8cac088c92b8b85cb085b3d60">bsl::map::map</a> (const map &amp;original, const ALLOCATOR &amp;basicAllocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga3b99abc138fbc1392fbcf42a1d04d1c2">bsl::map::map</a> (INPUT_ITERATOR first, INPUT_ITERATOR last, const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga3d0d0291dce90f9fd957c7030de297de">bsl::map::~map</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">map &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga347c3f4f0f549181609be75523018ef6">bsl::map::operator=</a> (const map &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VALUE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga034f267d512916849217b7c4c3ed09e2">bsl::map::operator[]</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VALUE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga3075b5954f239ca8bc031b9ee0cd1f59">bsl::map::at</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga001a280ed8a43774968446e80309d985">bsl::map::begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga1c9f04a4a747e466cc3956bd5231f76f">bsl::map::end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gaa91fb4d7783a5b0c13e5bd5baf9a336f">bsl::map::rbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga43caf47abb3bbd43e3b502587807a9fe">bsl::map::rend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; iterator, bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga6633a8e4e8b978198b7d16dfcf12ddd5">bsl::map::insert</a> (const value_type &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga385d66e4fa4e25be9880cfd6770c3754">bsl::map::insert</a> (const_iterator hint, const value_type &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga2d6f9040194fa640c79fddc5767e4a30">bsl::map::insert</a> (INPUT_ITERATOR first, INPUT_ITERATOR last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga03c5e5e9b7712d6c562a0838aefbbbdf">bsl::map::erase</a> (const_iterator position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga7c0f2f085f92b4f4c36b59f6eb0010d0">bsl::map::erase</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga2a12aade60486b8c4534aa7474139f33">bsl::map::erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gaad7e4085c884b52bed3acb00a8525079">bsl::map::swap</a> (map &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga9c089a7f066cc2797df42a21f3223e98">bsl::map::clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga792987c836aafada4193f56c1cf3ff81">bsl::map::find</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga4ef2aea47c3bcdcdf6cd16c01d524f35">bsl::map::lower_bound</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga2d000943501e3eecd7476ce5b9cb93b8">bsl::map::upper_bound</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; iterator, iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga52415cb62cd73c1b8f3446947c27884a">bsl::map::equal_range</a> (const key_type &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gaa9117f707c261236dac558678ec0b5ef">bsl::map::get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga4410e67575e1a31dccaf752b1850137d">bsl::map::begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga05ae01b2c529e13d8645bcda60003d24">bsl::map::end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga40ecec118238908e6968f0075fb89df9">bsl::map::rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga529096e61d521da547b99e0614d50c28">bsl::map::rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gac148f23f22376a36d9877127527f4c2a">bsl::map::cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga26d2bb52dd9486a4a9b7964f9578cf73">bsl::map::cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga8c5eda4921dc7231878a2414e2fbf4e2">bsl::map::crbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga4731cbc6488be5f944d306a16a6222fc">bsl::map::crend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga2bf63292a017688534c489cdb40bff89">bsl::map::empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga3c4a25fb3777e6f32f0b3b78d4c02532">bsl::map::size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gab74c127c7ce93937ecafc57bd731fe7c">bsl::map::max_size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const VALUE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gaf046a1b107819c7aa5bb8cdde23bfcc1">bsl::map::at</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">key_compare&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga0fb1bc809afa2a0551dfa8b648f0eec4">bsl::map::key_comp</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">value_compare&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga8be99f1fbcbdd9508600148821c90256">bsl::map::value_comp</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga5d48e23acb0e721fe7fdbec8a85fcd14">bsl::map::find</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga8587fdee615e9bb1c5563a1de18a968c">bsl::map::count</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga84b42f488111a5ca28befa656e89c2a9">bsl::map::lower_bound</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga1544266ea6dfeb59fcfc7c176b6c0126">bsl::map::upper_bound</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; const_iterator, <br class="typebreak"/>
const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga81504336ad10b0ebfefe5af9b42f6ece">bsl::map::equal_range</a> (const key_type &amp;key) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga22facc5669cef057868333b50b07be3c">bsl::operator==</a> (const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga50c4f19d172d7814a397ca2aedd4b74f">bsl::operator!=</a> (const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga13fe89539cf5b17b8cd39c1ef71eade9">bsl::operator&lt;</a> (const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga7d03b6985f6885cdf2fbe566bd7468bb">bsl::operator&gt;</a> (const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gaf0de3e7790300393e630816813ec1c9a">bsl::operator&lt;=</a> (const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#gafd6033641c01e3b3fb8b955f75676901">bsl::operator&gt;=</a> (const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga8ffecdad6636be8054c6ff5d8c772cb2">bsl::swap</a> (map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;a, map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">COMPARATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__map.html#ga58a4c27cba98257727a8d447989376ed">bsl::map::value_compare::comp</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Requirements on <code>KEY</code> and <code>VALUE</code></a> </li>
<li>
<a href="#3.2">Memory Allocation</a> <ul>
<li>
<a href="#3.2.1"><code>bslma</code>-Style Allocators</a> </li>
</ul>
</li>
<li>
<a href="#3.3">Operations</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: Creating a Trade Matching System</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL-compliant map class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1map.html">bsl::map</a> </td><td>STL-compliant map template  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslstl__multimap.html" title="Provide an STL-compliant multimap class.">Component bslstl_multimap</a>, <a class="el" href="group__bslstl__set.html" title="Provide an STL-compliant set class.">Component bslstl_set</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a single class template <code><a class="el" href="classbsl_1_1map.html">bsl::map</a></code>, implementing the standard container holding an ordered sequence of key-value pairs (having unique keys), and presenting a mapping from the keys (of a template parameter type, <code>KEY</code>) to their associated values (of another template parameter type, <code>VALUE</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An instantiation of <code>map</code> is an allocator-aware, value-semantic type whose salient attributes are its size (number of key-value pairs) and the ordered sequence of key-value pairs the map contains. If <code>map</code> is instantiated with either a key type or mapped-value type that is not itself value-semantic, then it will not retain all of its value-semantic qualities. In particular, if a either the key or value type cannot be tested for equality, then a <code>map</code> containing that type cannot be tested for equality. It is even possible to instantiate <code>map</code> with a key or mapped-value type that does not have a copy-constructor, in which case the <code>map</code> will not be copyable. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A map meets the requirements of an associative container with bidirectional iterators in the C++ standard [23.2.4]. The <code>map</code> implemented here adheres to the C++11 standard, except that it does not have interfaces that take rvalue references, <code>initializer_lists</code>, <code>emplace</code>, or operations taking a variadic number of template parameters. Note that excluded C++11 features are those that require (or are greatly simplified by) C++11 compiler support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_on_key_and_value"></a> <a class="anchor" id="description.requirements_on_key_and_value"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Requirements on KEY and VALUE: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code>map</code> is a fully <a href="group__bsldoc__glossary.html#value-semantic_type" class="glossary">Value-Semantic Type</a> (see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>) only if the supplied <code>KEY</code> and <code>VALUE</code> template parameters are themselves fully value-semantic. It is possible to instantiate a <code>map</code> with <code>KEY</code> and <code>VALUE</code> parameter arguments that do not provide a full set of value-semantic operations, but then some methods of the container may not be instantiable. The following terminology, adopted from the C++11 standard, is used in the function documentation of <code>map</code> to describe a function's requirements for the <code>KEY</code> and <code>VALUE</code> template parameters. These terms are also defined in section [17.6.3.1] of the C++11 standard. Note that, in the context of a <code>map</code> instantiation, the requirements apply specifically to the map's entry type, <code>value_type</code>, which is an alias for <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;KEY, VALUE&gt;</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="default-constructible"></a> <a class="anchor" id="requirements_on_key_and_value.default-constructible"></a> <a class="anchor" id="description.requirements_on_key_and_value.default-constructible"></a> <em>default-constructible</em>: The type provides a default constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="copy-constructible"></a> <a class="anchor" id="requirements_on_key_and_value.copy-constructible"></a> <a class="anchor" id="description.requirements_on_key_and_value.copy-constructible"></a> <em>copy-constructible</em>: The type provides a copy constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="equality-comparable"></a> <a class="anchor" id="requirements_on_key_and_value.equality-comparable"></a> <a class="anchor" id="description.requirements_on_key_and_value.equality-comparable"></a> <em>equality-comparable</em>: The type provides an equality-comparison operator that defines an equivalence relationship and is both reflexive and transitive.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="less-than-comparable"></a> <a class="anchor" id="requirements_on_key_and_value.less-than-comparable"></a> <a class="anchor" id="description.requirements_on_key_and_value.less-than-comparable"></a> <em>less-than-comparable</em>: The type provides a less-than operator, which defines a strict weak ordering relation on values of the type.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_allocation"></a> <a class="anchor" id="description.memory_allocation"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The type supplied as a map's <code>ALLOCATOR</code> template parameter determines how that map will allocate memory. The <code>map</code> template supports allocators meeting the requirements of the C++11 standard [17.6.3.5]. In addition, it supports scoped-allocators derived from the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> memory allocation protocol. Clients intending to use <code>bslma</code> style allocators should use the template's default <code>ALLOCATOR</code> type: The default type for the <code>ALLOCATOR</code> template parameter, <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, provides a C++11 standard-compatible adapter for a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma-style_allocators"></a> <a class="anchor" id="memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="description.memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>bslma-Style Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the (template parameter) type <code>ALLOCATOR</code> of an <code>map</code> instantiation' is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, then objects of that map type will conform to the standard behavior of a <code>bslma</code>-allocator-enabled type. Such a map accepts an optional <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> argument at construction. If the address of a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object is explicitly supplied at construction, it is used to supply memory for the map throughout its lifetime; otherwise, the map will use the default allocator installed at the time of the map's construction (see <code>bslma_default</code>). In addition to directly allocating memory from the indicated <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, a map supplies that allocator's address to the constructors of contained objects of the (template parameter) type <code>KEY</code> and <code>VALUE</code>, if respectively, the types define the <code><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a></code> trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="operations"></a> <a class="anchor" id="description.operations"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section describes the run-time complexity of operations on instances of <code>map</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Legend
  ------
  <span class="charliteral">&#39;K&#39;</span>             - (<span class="keyword">template</span> parameter) type <span class="stringliteral">&#39;KEY&#39;</span> of the map
  <span class="charliteral">&#39;V&#39;</span>             - (<span class="keyword">template</span> parameter) type &#39;VALUE&#39; of the map
  &#39;a&#39;, &#39;b&#39;        - two distinct objects of type &#39;map&lt;K, <a class="code" href="bdlf__bind__test_8h.html#ad98bc55172072c2c874bcdfbace3ad22">V</a>&gt;&#39;
  &#39;n&#39;, &#39;m&#39;        - number of elements in &#39;a&#39; and &#39;b&#39; respectively
  &#39;value_type&#39;    - map&lt;K, <a class="code" href="bdlf__bind__test_8h.html#ad98bc55172072c2c874bcdfbace3ad22">V</a>&gt;::value_type
  &#39;c&#39;             - comparator providing an ordering for objects of type &#39;K&#39;
  &#39;al             - an STL-style memory allocator
  &#39;i1&#39;, &#39;i2&#39;      - two iterators defining a sequence of &#39;value_type&#39; objects
  &#39;k&#39;             - an <span class="keywordtype">object</span> of type &#39;K&#39;
  &#39;v&#39;             - an <span class="keywordtype">object</span> of type &#39;<a class="code" href="bdlf__bind__test_8h.html#ad98bc55172072c2c874bcdfbace3ad22">V</a>&#39;
  &#39;p1&#39;, &#39;p2&#39;      - two iterators belonging to &#39;a&#39;
  distance(i1,i2) - the number of elements in the range [i1, i2)

  +----------------------------------------------------+--------------------+
  | Operation                                          | Complexity         |
  +====================================================+====================+
  | map&lt;K, <a class="code" href="bdlf__bind__test_8h.html#ad98bc55172072c2c874bcdfbace3ad22">V</a>&gt; a;    (default construction)             | O[1]               |
  | map&lt;K, <a class="code" href="bdlf__bind__test_8h.html#ad98bc55172072c2c874bcdfbace3ad22">V</a>&gt; a(al);                                   |                    |
  | map&lt;K, <a class="code" href="bdlf__bind__test_8h.html#ad98bc55172072c2c874bcdfbace3ad22">V</a>&gt; a(c, al);                                |                    |
  +----------------------------------------------------+--------------------+
  | map&lt;K, <a class="code" href="bdlf__bind__test_8h.html#ad98bc55172072c2c874bcdfbace3ad22">V</a>&gt; a(b); (copy construction)                | O[n]               |
  | map&lt;K, <a class="code" href="bdlf__bind__test_8h.html#ad98bc55172072c2c874bcdfbace3ad22">V</a>&gt; a(b, al);                                |                    |
  +----------------------------------------------------+--------------------+
  | map&lt;K, <a class="code" href="bdlf__bind__test_8h.html#ad98bc55172072c2c874bcdfbace3ad22">V</a>&gt; a(i1, i2);                               | O[N] if [i1, i2)   |
  | map&lt;K, <a class="code" href="bdlf__bind__test_8h.html#ad98bc55172072c2c874bcdfbace3ad22">V</a>&gt; a(i1, i2, al);                           | is sorted with     |
  | map&lt;K, <a class="code" href="bdlf__bind__test_8h.html#ad98bc55172072c2c874bcdfbace3ad22">V</a>&gt; a(i1, i2, c, al);                        | &#39;a.value_comp()&#39;,  |
  |                                                    | O[N * log(N)]      |
  |                                                    | otherwise, where N |
  |                                                    | is distance(i1,i2) |
  +----------------------------------------------------+--------------------+
  | a.~map&lt;K, <a class="code" href="bdlf__bind__test_8h.html#ad98bc55172072c2c874bcdfbace3ad22">V</a>&gt;(); (destruction)                      | O[n]               |
  +----------------------------------------------------+--------------------+
  | a = b;          (assignment)                       | O[n]               |
  +----------------------------------------------------+--------------------+
  | a.begin(), a.end(), a.cbegin(), a.cend(),          | O[1]               |
  | a.rbegin(), a.rend(), a.crbegin(), a.crend()       |                    |
  +----------------------------------------------------+--------------------+
  | a == b, a != b                                     | O[n]               |
  +----------------------------------------------------+--------------------+
  | a &lt; b, a &lt;= b, a &gt; b, a &gt;= b                       | O[n]               |
  +----------------------------------------------------+--------------------+
  | a.<a class="code" href="group__bslstl__deque.html#ga4ffc73dd2ce1f86230d22d2284773f1d">swap</a>(b), <a class="code" href="group__bslstl__deque.html#ga4ffc73dd2ce1f86230d22d2284773f1d">swap</a>(a,b)                               | O[1] if &#39;a&#39; and    |
  |                                                    | &#39;b&#39; use the same   |
  |                                                    | allocator,         |
  |                                                    | O[n + m] otherwise |
  +----------------------------------------------------+--------------------+
  | a.size()                                           | O[1]               |
  +----------------------------------------------------+--------------------+
  | a.max_size()                                       | O[1]               |
  +----------------------------------------------------+--------------------+
  | a.empty()                                          | O[1]               |
  +----------------------------------------------------+--------------------+
  | get_allocator()                                    | O[1]               |
  +----------------------------------------------------+--------------------+
  | a[k]                                               | O[log(n)]          |
  +----------------------------------------------------+--------------------+
  | a.at(k)                                            | O[log(n)]          |
  +----------------------------------------------------+--------------------+
  | a.insert(value_type(k, v))                         | O[log(n)]          |
  +----------------------------------------------------+--------------------+
  | a.insert(p1, value_type(k, v))                     | amortized constant |
  |                                                    | if the value is    |
  |                                                    | inserted right     |
  |                                                    | before p1,         |
  |                                                    | O[log(n)]          |
  |                                                    | otherwise          |
  +----------------------------------------------------+--------------------+
  | a.insert(i1, i2)                                   | O[log(N) *         |
  |                                                    |   distance(i1,i2)] |
  |                                                    |                    |
  |                                                    | where N is         |
  |                                                    | n + distance(i1,i2)|
  +----------------------------------------------------+--------------------+
  | a.erase(p1)                                        | amortized constant |
  +----------------------------------------------------+--------------------+
  | a.erase(k)                                         | O[log(n) +         |
  |                                                    | a.count(k)]        |
  +----------------------------------------------------+--------------------+
  | a.erase(p1, p2)                                    | O[log(n) +         |
  |                                                    | distance(p1, p2)]  |
  +----------------------------------------------------+--------------------+
  | a.erase(p1, p2)                                    | O[log(n) +         |
  |                                                    | distance(p1, p2)]  |
  +----------------------------------------------------+--------------------+
  | a.clear()                                          | O[n]               |
  +----------------------------------------------------+--------------------+
  | a.key_comp()                                       | O[1]               |
  +----------------------------------------------------+--------------------+
  | a.value_comp()                                     | O[1]               |
  +----------------------------------------------------+--------------------+
  | a.find(k)                                          | O[log(n)]          |
  +----------------------------------------------------+--------------------+
  | a.count(k)                                         | O[log(n) +         |
  |                                                    | a.count(k)]        |
  +----------------------------------------------------+--------------------+
  | a.lower_bound(k)                                   | O[log(n)]          |
  +----------------------------------------------------+--------------------+
  | a.upper_bound(k)                                   | O[log(n)]          |
  +----------------------------------------------------+--------------------+
  | a.equal_range(k)                                   | O[log(n)]          |
  +----------------------------------------------------+--------------------+
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_creating_a_trade_matching_system"></a> <a class="anchor" id="usage.example_1~3A_creating_a_trade_matching_system"></a> <a class="anchor" id="description.usage.example_1~3A_creating_a_trade_matching_system"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating a Trade Matching System: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we will utilize <code><a class="el" href="classbsl_1_1map.html">bsl::map</a></code> to define and implement a class, <code>TradeMatcher</code>, that provides a simple trade matching system for a single stock. The manipulators of <code>TradeMatcher</code> will allow clients to place buy orders and sell orders, and the accessors of <code>TradeMatcher</code> will allow clients to retrieve active orders and past executions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define the public interface for <code>TradeMatcher</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>TradeMatcher {
      <span class="comment">// This class provides a mechanism that characterizes a simple trade</span>
      <span class="comment">// matching system for one stock.  An object of this class allows</span>
      <span class="comment">// clients to place orders and view the active orders.</span>
</pre></div><br/>
<br/>
 Here, we create two type aliases, <code>SellOrdersMap</code> and <code>BuyOrdersMap</code>, for two <code><a class="el" href="classbsl_1_1map.html">bsl::map</a></code> instantiations that maps the price of an order (type <code>double</code>) to the quantity of the order (type <code>int</code>). <code>SellOrdersMap</code> uses the default <code>bsl::less</code> comparator to store the sequence of sell orders in ascending price order. <code>BuyOrderMap</code> uses the <code>bsl::greater</code> comparator to store the sequence of buy orders in descending price order. Also note that we use the default <code>ALLOCATOR</code> template parameter for both aliases as we intend to provide memory with <code>bslma</code> style allocators: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// PRIVATE TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1map.html">bsl::map&lt;double, int&gt;</a> SellOrdersMap;
          <span class="comment">// This &#39;typedef&#39; is an alias for a mapping between the price and</span>
          <span class="comment">// quantity of an order in ascending price order.</span>

      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1map.html">bsl::map&lt;double, int, std::greater&lt;double&gt;</a> &gt; BuyOrdersMap;
          <span class="comment">// This &#39;typedef&#39; is an alias for a mapping between the price and</span>
          <span class="comment">// quantity of an order in descending price order.</span>

      <span class="comment">// DATA</span>
      SellOrdersMap   d_sellOrders;  <span class="comment">// current sell orders</span>
      BuyOrdersMap    d_buyOrders;   <span class="comment">// current buy orders</span>

    <span class="keyword">private</span>:
      <span class="comment">// This class does not support copy construction or copy assignment.</span>
      TradeMatcher&amp; operator=(<span class="keyword">const</span> TradeMatcher&amp;);
      TradeMatcher(<span class="keyword">const</span> TradeMatcher&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// PUBLIC TYPES</span>
      <span class="keyword">typedef</span> SellOrdersMap::const_iterator SellOrdersConstIterator;
          <span class="comment">// This &#39;typedef&#39; provides an alias for the type of an iterator</span>
          <span class="comment">// providing non-modifiable access to sell orders in a</span>
          <span class="comment">// &#39;TradeMatcher&#39;.</span>

      <span class="keyword">typedef</span> BuyOrdersMap::const_iterator BuyOrdersConstIterator;
          <span class="comment">// This &#39;typedef&#39; provides an alias for the type of an iterator</span>
          <span class="comment">// providing non-modifiable access to buy orders in a</span>
          <span class="comment">// &#39;TradeMatcher&#39;.</span>

      <span class="comment">// CREATORS</span>
      TradeMatcher(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create an empty &#39;TradeMatcher&#39; object.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> placeBuyOrder(<span class="keywordtype">double</span> price, <span class="keywordtype">int</span> numShares);
          <span class="comment">// Place an order to buy the specified &#39;numShares&#39; at the specified</span>
          <span class="comment">// &#39;price&#39;.  The placed buy order will (possibly partially) execute</span>
          <span class="comment">// when active sale orders exist in the system at or below &#39;price&#39;.</span>
          <span class="comment">// The behavior is undefined unless &#39;0 &lt; price&#39; and &#39;0 &lt;</span>
          <span class="comment">// numShares&#39;.</span>

      <span class="keywordtype">void</span> placeSellOrder(<span class="keywordtype">double</span> price, <span class="keywordtype">int</span> numShares);
          <span class="comment">// Place an order to sell the specified &#39;numShares&#39; at the</span>
          <span class="comment">// specified &#39;price&#39;.  The placed sell order will (possibly</span>
          <span class="comment">// partially) execute when active buy orders exist in the system at</span>
          <span class="comment">// or above &#39;price&#39;.  The behavior is undefined unless &#39;0 &lt; price&#39;</span>
          <span class="comment">// and &#39;0 &lt; numShares&#39;.</span>

      <span class="comment">// ACCESSORS</span>
      SellOrdersConstIterator beginSellOrders() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the active</span>
          <span class="comment">// sell order at the lowest price in the ordered sequence (from low</span>
          <span class="comment">// price to high price) of sell orders maintained by this object.</span>

      SellOrdersConstIterator endSellOrders() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the</span>
          <span class="comment">// past-the-end sell order in the ordered sequence (from low price</span>
          <span class="comment">// to high price) of sell orders maintained by this object.</span>

      BuyOrdersConstIterator beginBuyOrders() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the active</span>
          <span class="comment">// buy order at the highest price in the ordered sequence (from</span>
          <span class="comment">// high price to low price) of buy orders maintained by this</span>
          <span class="comment">// object.</span>

      BuyOrdersConstIterator endBuyOrders() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the</span>
          <span class="comment">// past-the-end buy order in the ordered sequence (from high price</span>
          <span class="comment">// to low price) of buy orders maintained by this object.</span>
  };
</pre></div><br/>
<br/>
 Now, we define the implementations methods of the <code>TradeMatcher</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  TradeMatcher::TradeMatcher(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_sellOrders(basicAllocator)
  , d_buyOrders(basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 Notice that, on construction, we pass the contained <code><a class="el" href="classbsl_1_1map.html">bsl::map</a></code> objects the <code>bsl::Allocator</code> supplied at construction'. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">void</span> TradeMatcher::placeBuyOrder(<span class="keywordtype">double</span> price, <span class="keywordtype">int</span> numShares)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt; price);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt; numShares);

      <span class="comment">// Buy shares from sellers from the one with the lowest price up to but</span>
      <span class="comment">// not including the first seller with a price greater than the</span>
      <span class="comment">// specified &#39;price&#39;.</span>

      SellOrdersMap::iterator itr = d_sellOrders.begin();

      <span class="keywordflow">while</span> (numShares &amp;&amp; itr != d_sellOrders.upper_bound(price))
      {
          <span class="keywordflow">if</span> (itr-&gt;second &gt; numShares) {
              itr-&gt;second -= numShares;
              numShares = 0;
              <span class="keywordflow">break</span>;
          }

          itr = d_sellOrders.erase(itr);
          numShares -= itr-&gt;second;
      }

      <span class="keywordflow">if</span> (numShares &gt; 0) {
          d_buyOrders[price] += numShares;
      }
  }

  <span class="keywordtype">void</span> TradeMatcher::placeSellOrder(<span class="keywordtype">double</span> price, <span class="keywordtype">int</span> numShares)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt; price);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt; numShares);

      <span class="comment">// Sell shares to buyers from the one with the highest price up to but</span>
      <span class="comment">// not including the first buyer with a price smaller than the</span>
      <span class="comment">// specified &#39;price&#39;.</span>

      BuyOrdersMap::iterator itr = d_buyOrders.begin();

      <span class="keywordflow">while</span> (numShares &amp;&amp; itr != d_buyOrders.upper_bound(price))
      {
          <span class="keywordflow">if</span> (itr-&gt;second &gt; numShares) {
              itr-&gt;second -= numShares;
              numShares = 0;
              <span class="keywordflow">break</span>;
          }

          itr = d_buyOrders.erase(itr);
          numShares -= itr-&gt;second;
      }

      <span class="keywordflow">if</span> (numShares &gt; 0) {
          d_sellOrders[price] += numShares;
      }
  }

  <span class="comment">// ACCESSORS</span>
  TradeMatcher::SellOrdersConstIterator TradeMatcher::beginSellOrders()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_sellOrders.begin();
  }

  TradeMatcher::SellOrdersConstIterator TradeMatcher::endSellOrders()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_sellOrders.end();
  }

  TradeMatcher::BuyOrdersConstIterator TradeMatcher::beginBuyOrders()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_buyOrders.begin();
  }

  TradeMatcher::BuyOrdersConstIterator TradeMatcher::endBuyOrders()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_buyOrders.end();
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga54e207aa9da1808a2e8c0df25dc7a2e6"></a><!-- doxytag: member="bsl::map::key_type" ref="ga54e207aa9da1808a2e8c0df25dc7a2e6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef KEY <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::key_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8bade700892b7d26b0bcde4ef272ad05"></a><!-- doxytag: member="bsl::map::mapped_type" ref="ga8bade700892b7d26b0bcde4ef272ad05" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::mapped_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6dd80954d18b23a8aa09fa4025bd4faa"></a><!-- doxytag: member="bsl::map::value_type" ref="ga6dd80954d18b23a8aa09fa4025bd4faa" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;const KEY, VALUE&gt; <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gafeac493d7046f0ac8123fa00e2089755"></a><!-- doxytag: member="bsl::map::key_compare" ref="gafeac493d7046f0ac8123fa00e2089755" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef COMPARATOR <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::key_compare<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7a50f0010c2b516533c9684cb9fef1f4"></a><!-- doxytag: member="bsl::map::allocator_type" ref="ga7a50f0010c2b516533c9684cb9fef1f4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::allocator_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga056add01e6c2ccd6c703fda5c1258dcc"></a><!-- doxytag: member="bsl::map::reference" ref="ga056add01e6c2ccd6c703fda5c1258dcc" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_type&amp; <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga53c513ed018b7663942bbdcd11d39f34"></a><!-- doxytag: member="bsl::map::const_reference" ref="ga53c513ed018b7663942bbdcd11d39f34" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const value_type&amp; <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac9ce5b375cdf890e215a86e91a786bd4"></a><!-- doxytag: member="bsl::map::size_type" ref="gac9ce5b375cdf890e215a86e91a786bd4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::size_type <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadc9aed19ba7685ee42fdcc4579354915"></a><!-- doxytag: member="bsl::map::difference_type" ref="gadc9aed19ba7685ee42fdcc4579354915" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::difference_type <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad86bcc81098a3df3cac75022ba6cf38d"></a><!-- doxytag: member="bsl::map::pointer" ref="gad86bcc81098a3df3cac75022ba6cf38d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::pointer <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6992dc59554a061e714a85e2b0b140fb"></a><!-- doxytag: member="bsl::map::const_pointer" ref="ga6992dc59554a061e714a85e2b0b140fb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::const_pointer <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad1cccdfd3f0d24d6a6bf880d4b3280aa"></a><!-- doxytag: member="bsl::map::iterator" ref="gad1cccdfd3f0d24d6a6bf880d4b3280aa" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef BloombergLP::bslstl::TreeIterator&lt; value_type, Node, difference_type&gt; <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga22687147e65a99cca9f75f6b044171eb"></a><!-- doxytag: member="bsl::map::const_iterator" ref="ga22687147e65a99cca9f75f6b044171eb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef BloombergLP::bslstl::TreeIterator&lt; const value_type, Node, difference_type&gt; <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::const_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7865b0af06c253a2dafdea698d41aad1"></a><!-- doxytag: member="bsl::map::reverse_iterator" ref="ga7865b0af06c253a2dafdea698d41aad1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;iterator&gt; <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac502bfbb10e80e3051623e315c86fec8"></a><!-- doxytag: member="bsl::map::const_reverse_iterator" ref="gac502bfbb10e80e3051623e315c86fec8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;const_iterator&gt; <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::const_reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf9aa1ac64eadea406f70017915d5879d"></a><!-- doxytag: member="bsl::map::value_compare::result_type" ref="gaf9aa1ac64eadea406f70017915d5879d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bool <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_compare::result_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga96570ecedd3c687888c3c59904c77bd9"></a><!-- doxytag: member="bsl::map::value_compare::first_argument_type" ref="ga96570ecedd3c687888c3c59904c77bd9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_type <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_compare::first_argument_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga22481d614929a3d6cdf87c3d95f546a2"></a><!-- doxytag: member="bsl::map::value_compare::second_argument_type" ref="ga22481d614929a3d6cdf87c3d95f546a2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_type <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_compare::second_argument_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa40fa7be9fe79cd6fe67253cc6ec9069"></a><!-- doxytag: member="bsl::map::DataWrapper::DataWrapper" ref="gaa40fa7be9fe79cd6fe67253cc6ec9069" args="(const COMPARATOR &amp;comparator, const ALLOCATOR &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::DataWrapper::DataWrapper </td>
          <td>(</td>
          <td class="paramtype">const COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code>DataWrapper</code> object with the specified <code>comparator</code> and <code>basicAllocator</code>. </p>

</div>
</div>
<a class="anchor" id="ga049678dd29b295266bc000c0a782e124"></a><!-- doxytag: member="bsl::map::value_compare::value_compare" ref="ga049678dd29b295266bc000c0a782e124" args="(COMPARATOR comparator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_compare::value_compare </td>
          <td>(</td>
          <td class="paramtype">COMPARATOR&nbsp;</td>
          <td class="paramname"> <em>comparator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IMPLICIT: Create a <code><a class="el" href="classbsl_1_1map_1_1value__compare.html">value_compare</a></code> object that will delegate to the specified <code>comparator</code> for comparisons. </p>

</div>
</div>
<a class="anchor" id="gae876a33146ec50969a035a7365c74240"></a><!-- doxytag: member="bsl::map::value_compare::operator()" ref="gae876a33146ec50969a035a7365c74240" args="(const value_type &amp;x, const value_type &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_compare::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1pair.html">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1pair.html">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>x</code> object is ordered before the specified <code>y</code> object, as determined by the comparator supplied at construction. </p>

</div>
</div>
<a class="anchor" id="ga11a257f6cc29472acc64f276b39cc8a4"></a><!-- doxytag: member="bsl::map::map" ref="ga11a257f6cc29472acc64f276b39cc8a4" args="(const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::map </td>
          <td>(</td>
          <td class="paramtype">const COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em> = <code>COMPARATOR()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicAllocator</em>&nbsp;</td><td>Construct an empty map. Optionally specify a <code>comparator</code> used to order key-value pairs contained in this object. If <code>comparator</code> is not supplied, a default-constructed object of the (template parameter) type <code>COMPARATOR</code> is used. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>ALLOCATOR</code> is used. If the <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code>, if supplied, shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>basicAllocator</code> is not supplied, the currently installed default allocator is used to supply memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5acf3f5f6f5a4e3d71daaa8b90eb7d4e"></a><!-- doxytag: member="bsl::map::map" ref="ga5acf3f5f6f5a4e3d71daaa8b90eb7d4e" args="(const ALLOCATOR &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::map </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an empty map that will use the specified <code>basicAllocator</code> to supply memory. Use a default-constructed object of the (template parameter) type <code>COMPARATOR</code> to order the key-value pairs contained in this map. If the (template parameter) type <code>ALLOCATOR</code> is of <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. </p>

</div>
</div>
<a class="anchor" id="gaee1698d3e611a01e013196afc64a2802"></a><!-- doxytag: member="bsl::map::map" ref="gaee1698d3e611a01e013196afc64a2802" args="(const map &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a map having the same value as the specified <code>original</code>. Use a copy of <code>original.key_comp()</code> to order the key-value pairs contained in this map. Use the allocator returned by 'bslallocator_traits&lt;ALLOCATOR&gt;:: select_on_container_copy_construction(original.allocator())' to allocate memory. If the (template parameter) type <code>ALLOCATOR</code> is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), the currently installed default allocator is used to supply memory. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__map.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__map.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga00829bf8cac088c92b8b85cb085b3d60"></a><!-- doxytag: member="bsl::map::map" ref="ga00829bf8cac088c92b8b85cb085b3d60" args="(const map &amp;original, const ALLOCATOR &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a map having the same value as that of the specified <code>original</code> that will use the specified <code>basicAllocator</code> to supply memory. Use a copy of <code>original.key_comp()</code> to order the key-value pairs contained in this map. If the (template parameter) type <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> types both be <a href="group__bslstl__map.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__map.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga3b99abc138fbc1392fbcf42a1d04d1c2"></a><!-- doxytag: member="bsl::map::map" ref="ga3b99abc138fbc1392fbcf42a1d04d1c2" args="(INPUT_ITERATOR first, INPUT_ITERATOR last, const COMPARATOR &amp;comparator=COMPARATOR(), const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::map </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em> = <code>COMPARATOR()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a map, and insert each <code>value_type</code> object in the sequence starting at the specified <code>first</code> element, and ending immediately before the specified <code>last</code> element, ignoring those pairs having a key that appears earlier in the sequence. Optionally specify a <code>comparator</code> used to order key-value pairs contained in this object. If <code>comparator</code> is not supplied, a default-constructed object of the (template parameter) type <code>COMPARATOR</code> is used. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not supplied, a default-constructed object of the (template parameter) type <code>ALLOCATOR</code> is used. If the type <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>basicAllocator</code>, if supplied, shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the type <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>basicAllocator</code> is not supplied, the currently installed default allocator is used to supply memory. If the sequence <code>first</code> and <code>last</code> is ordered according to the identified <code>comparator</code>, then this operation has <code>O[N]</code> complexity, where <code>N</code> is the number of elements between <code>first</code> and <code>last</code>, otherwise this operation has <code>O[N * log(N)]</code> complexity. The (template parameter) type <code>INPUT_ITERATOR</code> shall meet the requirements of an input iterator defined in the C++11 standard [24.2.3] providing access to values of a type convertible to <code>value_type</code>. The behavior is undefined unless <code>first</code> and <code>last</code> refer to a sequence of valid values where <code>first</code> is at a position at or before <code>last</code>. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__map.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__map.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga3d0d0291dce90f9fd957c7030de297de"></a><!-- doxytag: member="bsl::map::~map" ref="ga3d0d0291dce90f9fd957c7030de297de" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::~map </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<a class="anchor" id="ga347c3f4f0f549181609be75523018ef6"></a><!-- doxytag: member="bsl::map::operator=" ref="ga347c3f4f0f549181609be75523018ef6" args="(const map &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">map&amp; <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value and comparator of the specified <code>rhs</code> object, propagate to this object the allocator of <code>rhs</code> if the <code>ALLOCATOR</code> type has trait <code>propagate_on_container_copy_assignment</code>, and return a reference providing modifiable access to this object. Note that this method requires that the (template parameter types) <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__map.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__map.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga034f267d512916849217b7c4c3ed09e2"></a><!-- doxytag: member="bsl::map::operator[]" ref="ga034f267d512916849217b7c4c3ed09e2" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VALUE&amp; <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__map.html#ga54e207aa9da1808a2e8c0df25dc7a2e6">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the mapped-value associated with the specified <code>key</code>; if this <code>map</code> does not already contain a <code>value_type</code> object with <code>key</code>, first insert a new <code>value_type</code> object having <code>key</code> and a default-constructed <code>VALUE</code> object, and return a reference to the mapped value. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__map.html#requirements_on_key_and_value.default-constructible" class="glossary">default-constructible</a> (see <a href="group__bslstl__map.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga3075b5954f239ca8bc031b9ee0cd1f59"></a><!-- doxytag: member="bsl::map::at" ref="ga3075b5954f239ca8bc031b9ee0cd1f59" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VALUE&amp; <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__map.html#ga54e207aa9da1808a2e8c0df25dc7a2e6">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the mapped-value associated with the specified <code>key</code>, if such an entry exists; otherwise throw an <code>std::out_of_range</code> exception. Note that this method is not exception-neutral. </p>

</div>
</div>
<a class="anchor" id="ga001a280ed8a43774968446e80309d985"></a><!-- doxytag: member="bsl::map::begin" ref="ga001a280ed8a43774968446e80309d985" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this map, or the <code>end</code> iterator if this map is empty. </p>

</div>
</div>
<a class="anchor" id="ga1c9f04a4a747e466cc3956bd5231f76f"></a><!-- doxytag: member="bsl::map::end" ref="ga1c9f04a4a747e466cc3956bd5231f76f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the past-the-end element in the ordered sequence of <code>value_type</code> objects maintained by this map. </p>

</div>
</div>
<a class="anchor" id="gaa91fb4d7783a5b0c13e5bd5baf9a336f"></a><!-- doxytag: member="bsl::map::rbegin" ref="gaa91fb4d7783a5b0c13e5bd5baf9a336f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing modifiable access to the last <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this map, or <code>rend</code> if this map is empty. </p>

</div>
</div>
<a class="anchor" id="ga43caf47abb3bbd43e3b502587807a9fe"></a><!-- doxytag: member="bsl::map::rend" ref="ga43caf47abb3bbd43e3b502587807a9fe" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing modifiable access to the prior-to-the-beginning element in the ordered sequence of <code>value_type</code> objects maintained by this map. </p>

</div>
</div>
<a class="anchor" id="ga6633a8e4e8b978198b7d16dfcf12ddd5"></a><!-- doxytag: member="bsl::map::insert" ref="ga6633a8e4e8b978198b7d16dfcf12ddd5" args="(const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;iterator, bool&gt; <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1pair.html">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this map if the key (the <code>first</code> element) of the <code>value</code> does not already exist in this map; otherwise, if a <code>value_type</code> object having the same key as <code>value</code> already exists in this map, this method has no effect. Return a pair whose <code>first</code> member is an iterator referring to the (possibly newly inserted) <code>value_type</code> object in this map whose key is the same as that of <code>value</code>, and whose <code>second</code> member is <code>true</code> if a new value was inserted, and <code>false</code> if the value was already present. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> types both be <a href="group__bslstl__map.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__map.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga385d66e4fa4e25be9880cfd6770c3754"></a><!-- doxytag: member="bsl::map::insert" ref="ga385d66e4fa4e25be9880cfd6770c3754" args="(const_iterator hint, const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__map.html#ga22687147e65a99cca9f75f6b044171eb">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1pair.html">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>value</code> into this map (in amortized constant time if the specified <code>hint</code> is a valid immediate successor to the key of <code>value</code>), if the key (the <code>first</code> element) of the <code>value</code> does not already exist in this map; otherwise, if a <code>value_type</code> object having the same key as <code>value</code> already exists in this map, this method has no effect. Return an iterator referring to the (possibly newly inserted) <code>value_type</code> object in this map whose key is the same as that of <code>value</code>. If <code>hint</code> is not a valid immediate successor to the key of <code>value</code>, this operation has <code>O[log(N)]</code> complexity, where <code>N</code> is the size of this map. The behavior is undefined unless <code>hint</code> is a valid iterator into this map. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__map.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__map.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga2d6f9040194fa640c79fddc5767e4a30"></a><!-- doxytag: member="bsl::map::insert" ref="ga2d6f9040194fa640c79fddc5767e4a30" args="(INPUT_ITERATOR first, INPUT_ITERATOR last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert into this map the value of each <code>value_type</code> object in the range starting at the specified <code>first</code> iterator and ending immediately before the specified <code>last</code> iterator, whose key is not already contained in this map. The (template parameter) type <code>INPUT_ITERATOR</code> shall meet the requirements of an input iterator defined in the C++11 standard [24.2.3] providing access to values of a type convertible to <code>value_type</code>. The behavior is undefined unless <code>first</code> and <code>last</code> refer to a sequence of valid values where <code>first</code> is at a position at or before <code>last</code>. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__map.html#requirements_on_key_and_value.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__map.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga03c5e5e9b7712d6c562a0838aefbbbdf"></a><!-- doxytag: member="bsl::map::erase" ref="ga03c5e5e9b7712d6c562a0838aefbbbdf" args="(const_iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__map.html#ga22687147e65a99cca9f75f6b044171eb">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this map the <code>value_type</code> object at the specified <code>position</code>, and return an iterator referring to the element immediately following the removed element, or to the past-the-end position if the removed element was the last element in the sequence of elements maintained by this map. The behavior is undefined unless <code>position</code> refers to a <code>value_type</code> object in this map. </p>

</div>
</div>
<a class="anchor" id="ga7c0f2f085f92b4f4c36b59f6eb0010d0"></a><!-- doxytag: member="bsl::map::erase" ref="ga7c0f2f085f92b4f4c36b59f6eb0010d0" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__map.html#ga54e207aa9da1808a2e8c0df25dc7a2e6">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remote from this map the <code>value_type</code> object having the specified <code>key</code>, if it exists, and return 1; otherwise, if there is no <code>value_type</code> object having <code>key</code>, return 0 with no other effect. </p>

</div>
</div>
<a class="anchor" id="ga2a12aade60486b8c4534aa7474139f33"></a><!-- doxytag: member="bsl::map::erase" ref="ga2a12aade60486b8c4534aa7474139f33" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__map.html#ga22687147e65a99cca9f75f6b044171eb">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__map.html#ga22687147e65a99cca9f75f6b044171eb">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this map the <code>value_type</code> objects starting at the specified <code>first</code> position up to, but including the specified <code>last</code> position, and return <code>last</code>. The behavior is undefined unless <code>first</code> and <code>last</code> either refer to elements in this map or are the <code>end</code> iterator, and the <code>first</code> position is at or before the <code>last</code> position in the ordered sequence provided by this container. </p>

</div>
</div>
<a class="anchor" id="gaad7e4085c884b52bed3acb00a8525079"></a><!-- doxytag: member="bsl::map::swap" ref="gaad7e4085c884b52bed3acb00a8525079" args="(map &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1map.html">map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this object as well as its comparator with those of the specified <code>other</code> object. Additionally, if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code>, then exchange the allocator of this object with that of the <code>other</code> object, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee and guarantees <code>O[1]</code> complexity. The behavior is undefined unless either this object was created with the same allocator as <code>other</code> or <code>propagate_on_container_swap</code> is <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="ga9c089a7f066cc2797df42a21f3223e98"></a><!-- doxytag: member="bsl::map::clear" ref="ga9c089a7f066cc2797df42a21f3223e98" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all entries from this map. Note that the map is empty after this call, but allocated memory may be retained for future use. </p>

</div>
</div>
<a class="anchor" id="ga792987c836aafada4193f56c1cf3ff81"></a><!-- doxytag: member="bsl::map::find" ref="ga792987c836aafada4193f56c1cf3ff81" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__map.html#ga54e207aa9da1808a2e8c0df25dc7a2e6">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the <code>value_type</code> object in this map having the specified <code>key</code>, if such an entry exists, and the past-the-end (<code>end</code>) iterator otherwise. </p>

</div>
</div>
<a class="anchor" id="ga4ef2aea47c3bcdcdf6cd16c01d524f35"></a><!-- doxytag: member="bsl::map::lower_bound" ref="ga4ef2aea47c3bcdcdf6cd16c01d524f35" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__map.html#ga54e207aa9da1808a2e8c0df25dc7a2e6">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this map whose key is greater-than or equal-to the specified <code>key</code>, and the past-the-end iterator if this map does not contain a <code>value_type</code> object whose key is greater-than or equal-to <code>key</code>. Note that this function returns the <em>first</em> position before which a <code>value_type</code> object having <code>key</code> could be inserted into the ordered sequence maintained by this map, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="ga2d000943501e3eecd7476ce5b9cb93b8"></a><!-- doxytag: member="bsl::map::upper_bound" ref="ga2d000943501e3eecd7476ce5b9cb93b8" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__map.html#ga54e207aa9da1808a2e8c0df25dc7a2e6">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this map whose key is greater than the specified <code>key</code>, and the past-the-end iterator if this map does not contain a <code>value_type</code> object whose key is greater-than <code>key</code>. Note that this function returns the <em>last</em> position before which a <code>value_type</code> object having <code>key</code> could be inserted into the ordered sequence maintained by this map, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="ga52415cb62cd73c1b8f3446947c27884a"></a><!-- doxytag: member="bsl::map::equal_range" ref="ga52415cb62cd73c1b8f3446947c27884a" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;iterator,iterator&gt; <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__map.html#ga54e207aa9da1808a2e8c0df25dc7a2e6">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pair of iterators providing modifiable access to the sequence of <code>value_type</code> objects in this map having the specified <code>key</code>, where the the first iterator is positioned at the start of the sequence, and the second is positioned one past the end of the sequence. The first returned iterator will be <code>lower_bound(key)</code>; the second returned iterator will be <code>upper_bound(key)</code>; and, if this map contains no <code>value_type</code> objects having <code>key</code>, then the two returned iterators will have the same value. Note that since a map maintains unique keys, the range will contain at most one element. </p>

</div>
</div>
<a class="anchor" id="gaa9117f707c261236dac558678ec0b5ef"></a><!-- doxytag: member="bsl::map::get_allocator" ref="gaa9117f707c261236dac558678ec0b5ef" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return (a copy of) the allocator used for memory allocation by this map. </p>

</div>
</div>
<a class="anchor" id="ga4410e67575e1a31dccaf752b1850137d"></a><!-- doxytag: member="bsl::map::begin" ref="ga4410e67575e1a31dccaf752b1850137d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this map, or the <code>end</code> iterator if this map is empty. </p>

</div>
</div>
<a class="anchor" id="ga05ae01b2c529e13d8645bcda60003d24"></a><!-- doxytag: member="bsl::map::end" ref="ga05ae01b2c529e13d8645bcda60003d24" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the past-the-end element in the ordered sequence of <code>value_type</code> objects maintained by this map. </p>

</div>
</div>
<a class="anchor" id="ga40ecec118238908e6968f0075fb89df9"></a><!-- doxytag: member="bsl::map::rbegin" ref="ga40ecec118238908e6968f0075fb89df9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the last <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this map, or <code>rend</code> if this map is empty. </p>

</div>
</div>
<a class="anchor" id="ga529096e61d521da547b99e0614d50c28"></a><!-- doxytag: member="bsl::map::rend" ref="ga529096e61d521da547b99e0614d50c28" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the prior-to-the-beginning element in the ordered sequence of <code>value_type</code> objects maintained by this map. </p>

</div>
</div>
<a class="anchor" id="gac148f23f22376a36d9877127527f4c2a"></a><!-- doxytag: member="bsl::map::cbegin" ref="gac148f23f22376a36d9877127527f4c2a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this map, or the <code>cend</code> iterator if this map is empty. </p>

</div>
</div>
<a class="anchor" id="ga26d2bb52dd9486a4a9b7964f9578cf73"></a><!-- doxytag: member="bsl::map::cend" ref="ga26d2bb52dd9486a4a9b7964f9578cf73" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the past-the-end element in the ordered sequence of <code>value_type</code> objects maintained by this map. </p>

</div>
</div>
<a class="anchor" id="ga8c5eda4921dc7231878a2414e2fbf4e2"></a><!-- doxytag: member="bsl::map::crbegin" ref="ga8c5eda4921dc7231878a2414e2fbf4e2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the last <code>value_type</code> object in the ordered sequence of <code>value_type</code> objects maintained by this map, or <code>crend</code> if this set is empty. </p>

</div>
</div>
<a class="anchor" id="ga4731cbc6488be5f944d306a16a6222fc"></a><!-- doxytag: member="bsl::map::crend" ref="ga4731cbc6488be5f944d306a16a6222fc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator providing non-modifiable access to the prior-to-the-beginning element in the ordered sequence of <code>value_type</code> objects maintained by this map. </p>

</div>
</div>
<a class="anchor" id="ga2bf63292a017688534c489cdb40bff89"></a><!-- doxytag: member="bsl::map::empty" ref="ga2bf63292a017688534c489cdb40bff89" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this map contains no elements, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ga3c4a25fb3777e6f32f0b3b78d4c02532"></a><!-- doxytag: member="bsl::map::size" ref="ga3c4a25fb3777e6f32f0b3b78d4c02532" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements in this map. </p>

</div>
</div>
<a class="anchor" id="gab74c127c7ce93937ecafc57bd731fe7c"></a><!-- doxytag: member="bsl::map::max_size" ref="gab74c127c7ce93937ecafc57bd731fe7c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a theoretical upper bound on the largest number of elements that this map could possibly hold. Note that there is no guarantee that the map can successfully grow to the returned size, or even close to that size without running out of resources. </p>

</div>
</div>
<a class="anchor" id="gaf046a1b107819c7aa5bb8cdde23bfcc1"></a><!-- doxytag: member="bsl::map::at" ref="gaf046a1b107819c7aa5bb8cdde23bfcc1" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VALUE&amp; <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__map.html#ga54e207aa9da1808a2e8c0df25dc7a2e6">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the mapped-value associated with the specified <code>key</code>, if such an entry exists; otherwise throw an <code>std::out_of_range</code> exception. Note that this method is not exception-neutral. </p>

</div>
</div>
<a class="anchor" id="ga0fb1bc809afa2a0551dfa8b648f0eec4"></a><!-- doxytag: member="bsl::map::key_comp" ref="ga0fb1bc809afa2a0551dfa8b648f0eec4" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">key_compare <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::key_comp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the key-comparison functor (or function pointer) used by this map; if a comparator was supplied at construction, return its value, otherwise return a default constructed <code>key_compare</code> object. Note that this comparator compares objects of type <code>KEY</code>, which is the key part of the <code>value_type</code> objects contained in this map. </p>

</div>
</div>
<a class="anchor" id="ga8be99f1fbcbdd9508600148821c90256"></a><!-- doxytag: member="bsl::map::value_comp" ref="ga8be99f1fbcbdd9508600148821c90256" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_compare <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a functor for comparing two <code>value_type</code> objects by comparing their respective keys using <code>key_comp()</code>. Note that this comparator compares objects of type <code>value_type</code> (i.e., <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;KEY, VALUE&gt;</code>). </p>

</div>
</div>
<a class="anchor" id="ga5d48e23acb0e721fe7fdbec8a85fcd14"></a><!-- doxytag: member="bsl::map::find" ref="ga5d48e23acb0e721fe7fdbec8a85fcd14" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__map.html#ga54e207aa9da1808a2e8c0df25dc7a2e6">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the <code>value_type</code> object in this map having the specified <code>key</code>, if such an entry exists, and the past-the-end (<code>end</code>) iterator otherwise. </p>

</div>
</div>
<a class="anchor" id="ga8587fdee615e9bb1c5563a1de18a968c"></a><!-- doxytag: member="bsl::map::count" ref="ga8587fdee615e9bb1c5563a1de18a968c" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__map.html#ga54e207aa9da1808a2e8c0df25dc7a2e6">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of <code>value_type</code> objects within this map having the specified <code>key</code>. Note that since a map maintains unique keys, the returned value will be either 0 or 1. </p>

</div>
</div>
<a class="anchor" id="ga84b42f488111a5ca28befa656e89c2a9"></a><!-- doxytag: member="bsl::map::lower_bound" ref="ga84b42f488111a5ca28befa656e89c2a9" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__map.html#ga54e207aa9da1808a2e8c0df25dc7a2e6">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this map whose key is greater-than or equal-to the specified <code>key</code>, and the past-the-end iterator if this map does not contain a <code>value_type</code> object whose key is greater-than or equal-to <code>key</code>. Note that this function returns the <em>first</em> position before which a <code>value_type</code> object having <code>key</code> could be inserted into the ordered sequence maintained by this map, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="ga1544266ea6dfeb59fcfc7c176b6c0126"></a><!-- doxytag: member="bsl::map::upper_bound" ref="ga1544266ea6dfeb59fcfc7c176b6c0126" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__map.html#ga54e207aa9da1808a2e8c0df25dc7a2e6">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator providing non-modifiable access to the first (i.e., ordered least) <code>value_type</code> object in this map whose key is greater than the specified <code>key</code>, and the past-the-end iterator if this map does not contain a <code>value_type</code> object whose key is greater-than <code>key</code>. Note that this function returns the <em>last</em> position before which a <code>value_type</code> object having <code>key</code> could be inserted into the ordered sequence maintained by this map, while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="ga81504336ad10b0ebfefe5af9b42f6ece"></a><!-- doxytag: member="bsl::map::equal_range" ref="ga81504336ad10b0ebfefe5af9b42f6ece" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;const_iterator,const_iterator&gt; <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__map.html#ga54e207aa9da1808a2e8c0df25dc7a2e6">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pair of iterators providing non-modifiable access to the sequence of <code>value_type</code> objects in this map having the specified <code>key</code>, where the the first iterator is positioned at the start of the sequence and the second iterator is positioned one past the end of the sequence. The first returned iterator will be <code>lower_bound(key)</code>, the second returned iterator will be <code>upper_bound(key)</code>, and if this map contains no <code>value_type</code> objects having <code>key</code>, then the two returned iterators will have the same value. Note that since a map maintains unique keys, the range will contain at most one element. </p>

</div>
</div>
<a class="anchor" id="ga22facc5669cef057868333b50b07be3c"></a><!-- doxytag: member="bsl::operator==" ref="ga22facc5669cef057868333b50b07be3c" args="(const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code>map</code> objects have the same value if they have the same number of key-value pairs, and each key-value pair that is contained in one of the objects is also contained in the other object. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__map.html#requirements_on_key_and_value.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__map.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga50c4f19d172d7814a397ca2aedd4b74f"></a><!-- doxytag: member="bsl::operator!=" ref="ga50c4f19d172d7814a397ca2aedd4b74f" args="(const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code>map</code> objects do not have the same value if they do not have the same number of key-value pairs, or some key-value pair that is contained in one of the objects is not also contained in the other object. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__map.html#requirements_on_key_and_value.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__map.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga13fe89539cf5b17b8cd39c1ef71eade9"></a><!-- doxytag: member="bsl::operator&lt;" ref="ga13fe89539cf5b17b8cd39c1ef71eade9" args="(const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is less than the specified <code>rhs</code> value, and <code>false</code> otherwise. A map, <code>lhs</code>, has a value that is less than that of <code>rhs</code>, if, for the first non-equal corresponding key-value pairs in their respective sequences, the <code>lhs</code> key-value pair is less than the <code>rhs</code> pair, or, if the keys of all of their corresponding key-value pairs compare equal, <code>lhs</code> has fewer key-value pairs than <code>rhs</code>. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__map.html#requirements_on_key_and_value.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__map.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga7d03b6985f6885cdf2fbe566bd7468bb"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga7d03b6985f6885cdf2fbe566bd7468bb" args="(const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is greater than the specified <code>rhs</code> value, and <code>false</code> otherwise. A map, <code>lhs</code>, has a value that is greater than that of <code>rhs</code>, if, for the first non-equal corresponding key-value pairs in their respective sequences, the <code>lhs</code> key-value pair is greater than the <code>rhs</code> pair, or, if the keys of all of their corresponding key-value pairs compare equal, <code>lhs</code> has more key-value pairs than <code>rhs</code>. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__map.html#requirements_on_key_and_value.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__map.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaf0de3e7790300393e630816813ec1c9a"></a><!-- doxytag: member="bsl::operator&lt;=" ref="gaf0de3e7790300393e630816813ec1c9a" args="(const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is less-than or equal-to the specified <code>rhs</code> value, and <code>false</code> otherwise. A map, <code>lhs</code>, has a value that is less-than or equal-to that of <code>rhs</code>, if, for the first non-equal corresponding key-value pairs in their respective sequences, the <code>lhs</code> key-value pair is less than the <code>rhs</code> pair, or, if the keys of all of their corresponding key-value pairs compare equal, <code>lhs</code> has less-than or equal number of key-value pairs as <code>rhs</code>. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__map.html#requirements_on_key_and_value.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__map.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gafd6033641c01e3b3fb8b955f75676901"></a><!-- doxytag: member="bsl::operator&gt;=" ref="gafd6033641c01e3b3fb8b955f75676901" args="(const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;lhs, const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> value is greater-than or equal-to the specified <code>rhs</code> value, and <code>false</code> otherwise. A map, <code>lhs</code>, has a value that is greater-than or equal-to that of <code>rhs</code>, if, for the first non-equal corresponding key-value pairs in their respective sequences, the <code>lhs</code> key-value pair is greater than the <code>rhs</code> pair, or, if the keys of all of their corresponding key-value pairs compare equal, <code>lhs</code> has greater-than or equal number of key-value pairs as <code>rhs</code>. Note that this method requires that the (template parameter) types <code>KEY</code> and <code>VALUE</code> both be <a href="group__bslstl__map.html#requirements_on_key_and_value.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__map.html#requirements_on_key_and_value" class="el">Requirements on <code>KEY</code> and <code>VALUE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga8ffecdad6636be8054c6ff5d8c772cb2"></a><!-- doxytag: member="bsl::swap" ref="ga8ffecdad6636be8054c6ff5d8c772cb2" args="(map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;a, map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE , class COMPARATOR , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap both the value and the comparator of the specified <code>a</code> object with the value and comparator of the specified <code>b</code> object. Additionally, if <code>bslstl::AllocatorTraits&lt;ALLOCATOR&gt;propagate_on_container_swap</code> is <code>true</code>, then exchange the allocator of <code>a</code> with that of <code>b</code>, and do not modify either allocator otherwise. This method provides the no-throw exception-safety guarantee and guarantees <code>O[1]</code> complexity. The behavior is undefined unless either this object was created with the same allocator as <code>other</code> or <code>propagate_on_container_swap</code> is <code>true</code>. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga58a4c27cba98257727a8d447989376ed"></a><!-- doxytag: member="bsl::map::value_compare::comp" ref="ga58a4c27cba98257727a8d447989376ed" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY, class VALUE, class COMPARATOR = std::less&lt;KEY&gt;, class ALLOCATOR = allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">COMPARATOR <a class="el" href="classbsl_1_1map.html">bsl::map</a>&lt; KEY, VALUE, COMPARATOR, ALLOCATOR &gt;::value_compare::comp<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>we would not have elected to make this data </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:05 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
