<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlpcre_regex.h                                                    -*-C++-*-
#ifndef INCLUDED_BDLPCRE_REGEX
#define INCLUDED_BDLPCRE_REGEX

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$ $CSID$&quot;)

//@PURPOSE: Provide a mechanism for regular expression pattern matching.
//
//@CLASSES:
//  bdlpcre::RegEx: mechanism for compiling and matching regular expressions
//
//@SEE_ALSO: http://www.pcre.org/
//
//@DESCRIPTION: This component provides a mechanism, &#39;bdlpcre::RegEx&#39;, for
// compiling (or &quot;preparing&quot;) regular expressions, and subsequently matching
// subject strings against a prepared expression.  The regular expressions
// supported by this component correspond approximately with Perl 5.10.  See
// the appendix entitled &quot;Perl Compatibility&quot; below for more information.
//
// Upon construction, a &#39;bdlpcre::RegEx&#39; object is initially not associated
// with a regular expression.  A regular expression pattern is compiled for use
// by the object using the &#39;prepare&#39; method.  Subject strings may then be
// matched against the prepared pattern using the set of overloaded &#39;match&#39;
// methods.
//
// The component provides the following groups of &#39;match&#39; overloads:
//: 1 The first group of &#39;match&#39; overloads simply returns 0 if a given subject
//:   string matches the prepared regular expression, and returns a non-zero
//:   value otherwise.
//:
//: 2 The second group of &#39;match&#39; overloads returns the substring of the
//:   subject that was matched, ether as a &#39;bslstl::StringRef&#39;, or as a
//:   &#39;bsl::pair&lt;size_t, size_t&gt;&#39; holding the (offset, length) pair.
//:
//: 3 The third group of &#39;match&#39; overloads returns a vector of either
//:   &#39;bslstl::StringRef&#39; or &#39;bsl::pair&lt;size_t, size_t&gt;&#39; holding the matched
//:   substrings.  The first element of the vector indicate the substring of
//:   the subject that matched the entire pattern.  Subsequent elements
//:   indicate the substrings of the subject that matched respective
//:   sub-patterns.
//
///&quot;Prepared&quot; State
///----------------
// A &#39;bdlpcre::RegEx&#39; object must first be prepared with a valid regular
// expression before attempting to match subject strings.  We say that an
// instance of &#39;bdlpcre::RegEx&#39; is in the &quot;prepared&quot; state if the object holds
// a valid regular expression, in which case calls to the overloaded &#39;match&#39;
// methods of that instance are valid.  Otherwise, the object is in the
// &quot;unprepared&quot; state.  Upon construction, an &#39;bdlpcre::RegEx&#39; object is in the
// &quot;unprepared&quot; state.  A successful call to the &#39;prepare&#39; method puts the
// object into the &quot;prepared&quot; state.  The &#39;clear&#39; method, as well as an
// unsuccessful call to &#39;prepare&#39;, puts the object into the &quot;unprepared&quot; state.
// The &#39;isPrepared&#39; accessor may be used to determine whether an object is
// prepared.
//
///Prepare-Time Flags
///------------------
// A set of flags may be optionally supplied to the &#39;prepare&#39; method to affect
// specific pattern matching behavior.  The flags recognized by &#39;prepare&#39; are
// defined in an enumeration declared within the &#39;bdlpcre::RegEx&#39;.  The
// following describes these flags and their effects.
//
///Case-Insensitive Matching
///- - - - - - - - - - - - -
// If &#39;RegEx::k_FLAG_CASELESS&#39; is included in the flags supplied to &#39;prepare&#39;,
// then letters in the regular expression pattern supplied to &#39;prepare&#39; match
// both lower- and upper-case letters in subject strings subsequently supplied
// to &#39;match&#39;.  This is equivalent to Perl&#39;s &#39;/i&#39; option, and can be turned off
// within a pattern by a &#39;(?i)&#39; option setting.
//
///Multi-Line Matching
///- - - - - - - - - -
// By default, a subject string supplied to &#39;match&#39; is treated as consisting of
// a single line of characters (even if it actually contains &#39;\n&#39; characters).
// The start-of-line meta-character &#39;^&#39; matches only at the beginning of the
// string, and the end-of-line meta-character &#39;$&#39; matches only at the end of
// the string (or before a terminating &#39;\n&#39;, if present).  This matches the
// behavior of Perl.
//
// If &#39;RegEx::k_FLAG_MULTILINE&#39; is included in the flags supplied to &#39;prepare&#39;,
// then start-of-line and end-of-line meta-characters match immediately
// following or immediately before any &#39;\n&#39; characters in subject strings
// supplied to &#39;match&#39;, respectively (as well as at the very start and end of
// subject strings).  This is equivalent to Perl&#39;s &#39;/m&#39; option, and can be
// turned off within a pattern by a &#39;(?m)&#39; option setting.  If there are no
// &#39;\n&#39; characters in the subject string, or if there are no occurrences of &#39;^&#39;
// or &#39;$&#39; in the prepared pattern, then including &#39;k_FLAG_MULTILINE&#39; has no
// effect.
//
///UTF-8 Support
///- - - - - - -
// If &#39;RegEx::k_FLAG_UTF8&#39; is included in the flags supplied to &#39;prepare&#39;, then
// the regular expression pattern supplied to &#39;prepare&#39;, as well as the subject
// strings subsequently supplied to &#39;match&#39;, are interpreted as strings of
// UTF-8 characters instead of strings of ASCII characters.  The behavior of
// &#39;match&#39; methods is undefined if &#39;pattern()&#39; was prepared with &#39;k_FLAG_UTF8&#39;,
// but &#39;subject&#39; is not a valid UTF-8 string.
//
///Dot Matches All
///- - - - - - - -
// If &#39;RegEx::k_FLAG_DOTMATCHESALL&#39; is included in the flags supplied to
// &#39;prepare&#39;, then a dot metacharacter in the pattern matches a character of
// any value, including one that indicates a newline.  However, it only ever
// matches one character, even if newlines are encoded as &#39;\r\n&#39;.  If
// &#39;k_FLAG_DOTMATCHESALL&#39; is not used to prepare a regular expression, a dot
// metacharacter will *not* match a newline; hence, patterns expected to match
// across lines will fail to do so.  This flag is equivalent to Perl&#39;s &#39;/s&#39;
// option, and can be changed within a pattern by a &#39;(?s)&#39; option setting.  A
// negative class such as &#39;[^a]&#39; always matches newline characters, independent
// of the setting of this option.
//
///Usage
///-----
// The following snippets of code illustrate using this component to extract
// the text of the &quot;Subject:&quot; field from an Internet e-mail message (RFC822).
// The following &#39;parseSubject&#39; function accepts an RFC822-compliant message of
// a specified length and returns the text of the message&#39;s subject in the
// &#39;result&#39; &quot;out&quot; parameter:
//..
//  int parseSubject(bsl::string *result,
//                   const char  *message,
//                   bsl::size_t  messageLength)
//      // Parse the specified &#39;message&#39; of the specified &#39;messageLength&#39; for
//      // the &quot;Subject:&quot; field of &#39;message&#39;.  Return 0 on success and load the
//      // specified &#39;result&#39; with the text of the subject of &#39;message&#39;; return
//      // a non-zero value otherwise with no effect on &#39;result&#39;.
//  {
//..
// The following is the regular expression that will be used to find the
// subject text of &#39;message&#39;.  The &quot;?P&lt;subjectText&gt;&quot; syntax, borrowed from
// Python, allows us later to refer to a particular matched sub-pattern (i.e.,
// the text between the &#39;:&#39; and the &#39;\r&#39; in the &quot;Subject:&quot; field of the header)
// by the name &quot;subjectText&quot;:
//..
//      const char PATTERN[] = &quot;^subject:(?P&lt;subjectText&gt;[^\r]*)&quot;;
//..
// First we compile the &#39;PATTERN&#39;, using the &#39;prepare&#39; method, in order to
// match subject strings against it.  In the event that &#39;prepare&#39; fails, the
// first two arguments will be loaded with diagnostic information (an
// informational string and an index into the pattern at which the error
// occurred, respectively).  Two flags, &#39;RegEx::k_FLAG_CASELESS&#39; and
// &#39;RegEx::k_FLAG_MULTILINE&#39;, are used in preparing the pattern since Internet
// message headers contain case-insensitive content as well as &#39;\n&#39; characters.
// The &#39;prepare&#39; method returns 0 on success, and a non-zero value otherwise:
//..
//      RegEx       regEx;
//      bsl::string errorMessage;
//      size_t      errorOffset;
//
//      int returnValue = regEx.prepare(&amp;errorMessage,
//                                      &amp;errorOffset,
//                                      PATTERN,
//                                      RegEx::k_FLAG_CASELESS |
//                                      RegEx::k_FLAG_MULTILINE);
//      assert(0 == returnValue);
//..
// Next we call &#39;match&#39; supplying &#39;message&#39; and its length.  The &#39;matchVector&#39;
// will be populated with (offset, length) pairs describing substrings in
// &#39;message&#39; that match the prepared &#39;PATTERN&#39;.  All variants of the overloaded
// &#39;match&#39; method return 0 if a match is found, and return a non-zero value
// otherwise:
//..
//      bsl::vector&lt;bsl::pair&lt;size_t, size_t&gt; &gt; matchVector;
//      returnValue = regEx.match(&amp;matchVector, message, messageLength);
//
//      if (0 != returnValue) {
//          return returnValue;  // no match
//      }
//..
// Then we pass &quot;subjectText&quot; to the &#39;subpatternIndex&#39; method to obtain the
// index into &#39;matchVector&#39; that describes how to locate the subject text
// within &#39;message&#39;.  The text is then extracted from &#39;message&#39; and assigned to
// the &#39;result&#39; &quot;out&quot; parameter:
//..
//      const bsl::pair&lt;size_t, size_t&gt; capturedSubject =
//                           matchVector[regEx.subpatternIndex(&quot;subjectText&quot;)];
//
//      *result = bsl::string(&amp;message[capturedSubject.first],
//                            capturedSubject.second);
//
//      return 0;
//  }
//..
// The following array contains the sample Internet e-mail message from which
// we will extract the subject:
//..
//  const char RFC822_MESSAGE[] =
//      &quot;Received: ; Fri, 23 Apr 2004 14:30:00 -0400\r\n&quot;
//      &quot;Message-ID: &lt;12345@mailgate.bloomberg.net&gt;\r\n&quot;
//      &quot;Date: Fri, 23 Apr 2004 14:30:00 -0400\r\n&quot;
//      &quot;From: &lt;someone@bloomberg.net&gt;\r\n&quot;
//      &quot;To: &lt;someone_else@bloomberg.net&gt;\r\n&quot;
//      &quot;Subject: This is the subject text\r\n&quot;
//      &quot;MIME-Version: 1.0\r\n&quot;
//      &quot;Content-Type: text/plain\r\n&quot;
//      &quot;\r\n&quot;
//      &quot;This is the message body.\r\n&quot;
//      &quot;.\r\n&quot;;
//..
// Finally, we call &#39;parseSubject&#39; to extract the subject from
// &#39;RFC822_MESSAGE&#39;.  The assertions verify that the subject of the message is
// correctly extracted and assigned to the local &#39;subject&#39; variable:
//..
//  int main()
//  {
//      bsl::string subject;
//      const int   returnValue = parseSubject(&amp;subject,
//                                             RFC822_MESSAGE,
//                                             sizeof(RFC822_MESSAGE) - 1);
//      assert(0 == returnValue);
//      assert(&quot; This is the subject text&quot; == subject);
//  }
//..
//
///Appendix: Perl Compatibility
/// - - - - - - - - - - - - - -
// This section describes the differences in the ways that PCRE2 and Perl
// handle regular expressions.  The differences described here are with respect
// to Perl versions 5.10 and above.
//
// 1) PCRE2 has only a subset of Perl&#39;s Unicode support.
//
// 2) PCRE2 allows repeat quantifiers only on parenthesized assertions, but
// they do not mean what you might think.  For example, &#39;(?!a){3}&#39; does not
// assert that the next three characters are not &quot;a&quot;.  It just asserts that the
// next character is not &quot;a&quot; three times (in principle: PCRE2 optimizes this to
// run the assertion just once).  Perl allows repeat quantifiers on other
// assertions such as &#39;\b&#39;, but these do not seem to have any use.
//
// 3) Capturing subpatterns that occur inside negative lookahead assertions are
// counted, but their entries in the offsets vector are never set.  Perl
// sometimes (but not always) sets its numerical variables from inside negative
// assertions.
//
// 4) The following Perl escape sequences are not supported: &#39;\l&#39;, &#39;\u&#39;, &#39;\L&#39;,
// &#39;\U&#39;, and &#39;\N&#39; when followed by a character name or Unicode value.  (&#39;\N&#39; on
// its own, matching a non-newline character, is supported.)  In fact these are
// implemented by Perl&#39;s general string-handling and are not part of its
// pattern matching engine.  If any of these are encountered by PCRE2, an error
// is generated by default.
//
// 5) The Perl escape sequences &#39;\p&#39;, &#39;\P&#39;, and &#39;\X&#39; are supported only if
// PCRE2 is built with Unicode support.  The properties that can be tested with
// &#39;\p&#39; and &#39;\P&#39; are limited to the general category properties such as &#39;Lu&#39;
// and &#39;Nd,&#39; script names such as Greek or Han, and the derived properties
// &#39;Any&#39; and &#39;L&amp;&#39;.  PCRE2 does support the Cs (surrogate) property, which Perl
// does not; the Perl documentation says &quot;Because Perl hides the need for the
// user to understand the internal representation of Unicode characters, there
// is no need to implement the somewhat messy concept of surrogates.&quot;
//
// 6) PCRE2 does support the &#39;\Q...\E&#39; escape for quoting substrings.
// Characters in between are treated as literals.  This is slightly different
// from Perl in that &#39;$&#39; and &#39;@&#39; are also handled as literals inside the
// quotes.  In Perl, they cause variable interpolation (but of course PCRE2
// does not have variables).  Note the following examples:
//..
// Pattern            PCRE2 matches  Perl matches
// ----------------   -------------  ------------------------------------
// \Qabc$xyz\E        abc$xyz        abc followed by the contents of $xyz
// \Qabc\$xyz\E       abc\$xyz       abc\$xyz
// \Qabc\E\$\Qxyz\E   abc$xyz        abc$xyz
//..
// The &#39;\Q...\E&#39; sequence is recognized both inside and outside character
// classes.
//
// 7) PCRE2 does not support the &#39;(?{code})&#39; and &#39;(??{code})&#39; constructions.
// However, there is support for recursive patterns.  This is not available in
// Perl 5.8, but it is in Perl 5.10.
//
// 8) Subroutine calls (whether recursive or not) are treated as atomic groups.
// Atomic recursion is like Python, but unlike Perl.  Captured values that are
// set outside a subroutine call can be referenced from inside in PCRE2, but
// not in Perl.
//
// 9) If any of the backtracking control verbs are used in a subpattern that is
// called as a subroutine (whether or not recursively), their effect is
// confined to that subpattern; it does not extend to the surrounding pattern.
// This is not always the case in Perl.  In particular, if &#39;(*THEN)&#39; is present
// in a group that is called as a subroutine, its action is limited to that
// group, even if the group does not contain any &#39;|&#39; characters.  Note that
// such subpatterns are processed as anchored at the point where they are
// tested.
//
// 10) If a pattern contains more than one backtracking control verb, the first
// one that is backtracked onto acts.  For example, in the pattern
// &#39;A(*COMMIT)B(*PRUNE)C&#39; a failure in &#39;B&#39; triggers &#39;(*COMMIT)&#39;, but a failure
// in &#39;C&#39; triggers &#39;(*PRUNE)&#39;.  Perl&#39;s behaviour is more complex; in many cases
// it is the same as PCRE2, but there are examples where it differs.
//
// 11) Most backtracking verbs in assertions have their normal actions.  They
// are not confined to the assertion.
//
// 12) There are some differences that are concerned with the settings of
// captured strings when part of a pattern is repeated.  For example, matching
// &#39;&quot;aba&quot;&#39; against the pattern &#39;/^(a(b)?)+$/&#39; in Perl leaves &#39;$2&#39; unset, but in
// PCRE2 it is set to &#39;&quot;b&quot;&#39;.
//
// 13) PCRE2&#39;s handling of duplicate subpattern numbers and duplicate
// subpattern names is not as general as Perl&#39;s.  This is a consequence of the
// fact the PCRE2 works internally just with numbers, using an external table
// to translate between numbers and names.  In particular, a pattern such as
// &#39;(?|(?&lt;a&gt;A)|(?&lt;b)B)&#39;, where the two capturing parentheses have the same
// number but different names, is not supported, and causes an error at compile
// time.  If it were allowed, it would not be possible to distinguish which
// parentheses matched, because both names map to capturing subpattern number
// 1.  To avoid this confusing situation, an error is given at compile time.
//
// 14) Perl recognizes comments in some places that PCRE2 does not, for
// example, between the &#39;(&#39; and &#39;?&#39; at the start of a subpattern.  If the &#39;/x&#39;
// modifier is set, Perl allows white space between &#39;(&#39; and &#39;?&#39; (though current
// Perls warn that this is deprecated) but PCRE2 never does, even if the
// &#39;PCRE2_EXTENDED&#39; option is set.
//
// 15) Perl, when in warning mode, gives warnings for character classes such as
// &#39;[A-\d]&#39; or &#39;[a-[:digit:]]&#39;. It then treats the hyphens as literals.  PCRE2
// has no warning features, so it gives an error in these cases because they
// are almost certainly user mistakes.
//
// 16) In PCRE2, the upper/lower case character properties &#39;Lu&#39; and &#39;Ll&#39; are
// not affected when case-independent matching is specified.  For example,
// &#39;\p{Lu}&#39; always matches an upper case letter.
//
// 17) PCRE2 provides some extensions to the Perl regular expression
// facilities.  This list is with respect to Perl 5.10:
//
// (a) Although lookbehind assertions in PCRE2 must match fixed length strings,
// each alternative branch of a lookbehind assertion can match a different
// length of string.  Perl requires them all to have the same length.
//
// (b) If &#39;PCRE2_DOLLAR_ENDONLY&#39; is set and &#39;PCRE2_MULTILINE&#39; is not set, the
// &#39;$&#39; meta-character matches only at the very end of the string.
//
// (c) A backslash followed by a letter with no special meaning is faulted.
// (Perl can be made to issue a warning.)
//
// (d) If &#39;PCRE2_UNGREEDY&#39; is set, the greediness of the repetition quantifiers
// is inverted, that is, by default they are not greedy, but if followed by a
// question mark they are.
//
// (e) &#39;PCRE2_ANCHORED&#39; can be used at matching time to force a pattern to be
// tried only at the first matching position in the subject string.
//
// (f) The &#39;PCRE2_NOTBOL&#39;, &#39;PCRE2_NOTEOL&#39;, &#39;PCRE2_NOTEMPTY&#39;,
// &#39;PCRE2_NOTEMPTY_ATSTART&#39;, and &#39;PCRE2_NO_AUTO_CAPTURE&#39; options have no Perl
// equivalents.
//
// (g) The &#39;\R&#39; escape sequence can be restricted to match only &#39;CR,&#39; &#39;LF,&#39; or
// &#39;CRLF&#39; by the &#39;PCRE2_BSR_ANYCRLF&#39; option.
//
// (h) The callout facility is PCRE2-specific.
//
// (i) The partial matching facility is PCRE2-specific.
//
// (j) The alternative matching function (&#39;pcre2_dfa_match()&#39; matches in a
// different way and is not Perl-compatible.
//
// (k) PCRE2 recognizes some special sequences such as &#39;(*CR)&#39; at the start of
// a pattern that set overall options that cannot be changed within the
// pattern.
//
///Additional Copyright Notice
///- - - - - - - - - - - - - -
//..
// Copyright (c) 1997-2015 University of Cambridge
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    * Redistributions of source code must retain the above copyright notice,
//      this list of conditions and the following disclaimer.
//
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
//    * Neither the name of the University of Cambridge nor the names of any
//      contributors may be used to endorse or promote products derived from
//      this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDDEF
#include &lt;bsl_cstddef.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

#ifndef INCLUDED_BSL_UTILITY
#include &lt;bsl_utility.h&gt;        // &#39;bsl::pair&#39;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMICOPERATIONS
#include &lt;bsls_atomicoperations.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_STRINGREF
#include &lt;bslstl_stringref.h&gt;
#endif

#ifndef _PCRE2_H
#define PCRE2_CODE_UNIT_WIDTH 8
#define PCRE2_STATIC
#include &lt;pcre2.h&gt;
#endif

namespace BloombergLP {

namespace bdlpcre {

                             // ===========
                             // class RegEx
                             // ===========

class RegEx {
    // This class provides a mechanism for compiling and matching regular
    // expressions.  A regular expression approximately compatible with Perl
    // 5.10 is compiled with the &#39;prepare&#39; method.  Subsequently, strings are
    // matched against the compiled (prepared) pattern using the overloaded
    // &#39;match&#39; methods.  Note that the underlying implementation uses the
    // open-source Perl Compatible Regular Expressions (PCRE2) library that was
    // developed at the University of Cambridge (&#39;http://www.pcre.org/&#39;).

    // CLASS DATA
    static
    bsls::AtomicOperations::AtomicTypes::Int s_depthLimit;  // process-wide
                                                            // default maximum
                                                            // evaluation
                                                            // recursion depth

    // PRIVATE DATA
    int                    d_flags;            // prepare/match flags

    bsl::string            d_pattern;          // regular expression pattern

    pcre2_general_context *d_pcre2Context_p;   // PCRE2 general context

    pcre2_compile_context *d_compileContext_p; // PCRE2 compile context

    pcre2_match_context   *d_matchContext_p;   // PCRE2 match context

    pcre2_code            *d_patternCode_p;    // PCRE2 compiled pattern

    pcre2_match_data      *d_matchData_p;      // PCRE2 match data for pattern

    int                    d_depthLimit;       // evaluation recursion depth

    bslma::Allocator      *d_allocator_p;      // allocator to supply memory

  private:
    // NOT IMPLEMENTED
    RegEx(const RegEx&amp;);
    RegEx&amp; operator=(const RegEx&amp;);

    // PRIVATE ACCESSORS
    int privateMatch(const char *subject,
                     size_t      subjectLength,
                     size_t      subjectOffset) const;
        // Match the specified &#39;subject&#39;, having the specified &#39;subjectLength&#39;,
        // against the pattern held by this regular-expression object
        // (&#39;pattern()&#39;).  Begin matching at the specified &#39;subjectOffset&#39; in
        // &#39;subject&#39;.  Load &#39;d_matchData_p&#39; with the results of the match.
        // Return 0 on success, 1 if the depth limit was exceeded, and another
        // non-zero value otherwise.  The behavior is undefined unless
        // &#39;isPrepared() == true&#39;, &#39;0 &lt;= subjectLength&#39;, &#39;0 &lt;= subjectOffset&#39;,
        // and &#39;subjectOffset &lt;= subjectLength&#39;.  The behavior is also
        // undefined if &#39;pattern()&#39; was prepared with &#39;k_FLAG_UTF8&#39;, but
        // &#39;subject&#39; is not valid UTF-8.  Note that &#39;subject&#39; need not be
        // null-terminated and may contain embedded null characters.  Also note
        // that &#39;subject&#39; may be null if &#39;0 == subjectLength&#39; (denoting the
        // empty string).

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(RegEx, bslma::UsesBslmaAllocator);

    // PUBLIC TYPES
    enum {
        k_FLAG_CASELESS      = PCRE2_CASELESS,  // case-insensitive matching

        k_FLAG_DOTMATCHESALL = PCRE2_DOTALL,    // dot metacharacter matches
                                                // all chars (including
                                                // newlines)

        k_FLAG_MULTILINE     = PCRE2_MULTILINE, // multi-line matching

        k_FLAG_UTF8          = PCRE2_UTF        // UTF-8 support
    };
        // This enumeration defines the flags that may be supplied to the
        // &#39;prepare&#39; method to effect specific pattern matching behavior.

    // CLASS METHODS
    static int defaultDepthLimit();
        // Returns the process-wide default evaluation recursion depth limit.

    static int setDefaultDepthLimit(int depthLimit);
        // Set the process-wide default evaluation recursion depth limit to the
        // specified &#39;depthLimit&#39;.  Returns the previous depth limit.

    // CREATORS
    RegEx(bslma::Allocator *basicAllocator = 0);                    // IMPLICIT
        // Create a regular-expression object in the &quot;unprepared&quot; state.
        // Optionally specify a &#39;basicAllocator&#39; used to supply memory.  The
        // alignment strategy of the allocator must be &quot;maximum&quot; or &quot;natural&quot;.
        // If &#39;basicAllocator&#39; is 0, the currently installed default allocator
        // is used.

    ~RegEx();
        // Destroy this regular-expression object.

    // MANIPULATORS
    void clear();
        // Free resources used by this regular-expression object and put this
        // object into the &quot;unprepared&quot; state.  This method has no effect if
        // this object is already in the &quot;unprepared&quot; state.

    int prepare(bsl::string *errorMessage,
                size_t      *errorOffset,
                const char  *pattern,
                int          flags = 0);
        // Prepare this regular-expression object with the specified &#39;pattern&#39;
        // and the optionally specified &#39;flags&#39;.  On success, put this object
        // into the &quot;prepared&quot; state and return 0, with no effect on the
        // specified &#39;errorMessage&#39; and &#39;errorOffset&#39;.  Otherwise, (1) put this
        // object into the &quot;unprepared&quot; state, (2) load &#39;errorMessage&#39; (if
        // non-null) with a string describing the error detected, (3) load
        // &#39;errorOffset&#39; (if non-null) with the offset in &#39;pattern&#39; at which
        // the error was detected, and (4) return a non-zero value.  The
        // behavior is undefined unless &#39;flags&#39; is the bit-wise inclusive-or of
        // 0 or more of the following values:
        //..
        //  k_FLAG_CASELESS
        //  k_FLAG_DOTMATCHESALL
        //  k_FLAG_MULTILINE
        //  k_FLAG_UTF8
        //..

    int setDepthLimit(int depthLimit);
        // Set the evaluation recursion depth limit for this regular-expression
        // object to the specified &#39;depthLimit&#39;.  Return the previous depth
        // limit.

    // ACCESSORS
    int depthLimit() const;
        // Returns the evaluation recursion depth limit for this
        // regular-expression object.

    int flags() const;
        // Return the flags that were supplied to the most recent successful
        // call to the &#39;prepare&#39; method of this regular-expression object.  The
        // behavior is undefined unless &#39;isPrepared() == true&#39;.  Note that the
        // returned value will be the bit-wise inclusive-or of 0 or more of the
        // following values:
        //..
        //  k_FLAG_CASELESS
        //  k_FLAG_DOTMATCHESALL
        //  k_FLAG_MULTILINE
        //  k_FLAG_UTF8
        //..

    bool isPrepared() const;
        // Return &#39;true&#39; if this regular-expression object is in the &quot;prepared&quot;
        // state, and &#39;false&#39; otherwise.

    int match(const char *subject,
              size_t      subjectLength,
              size_t      subjectOffset = 0) const;
        // Match the specified &#39;subject&#39;, having the specified &#39;subjectLength&#39;,
        // against the pattern held by this regular-expression object
        // (&#39;pattern()&#39;).  Begin matching at the optionally specified
        // &#39;subjectOffset&#39; in &#39;subject&#39;.  If &#39;subjectOffset&#39; is not specified,
        // then begin matching from the start of &#39;subject&#39;.  Return 0 on
        // success, 1 if the depth limit was exceeded, and another non-zero
        // value otherwise.  The behavior is undefined unless
        // &#39;isPrepared() == true&#39;, &#39;0 &lt;= subjectLength&#39;, &#39;0 &lt;= subjectOffset&#39;,
        // and &#39;subjectOffset &lt;= subjectLength&#39;.  The behavior is also
        // undefined if &#39;pattern()&#39; was prepared with &#39;k_FLAG_UTF8&#39;, but
        // &#39;subject&#39; is not valid UTF-8.  Note that &#39;subject&#39; need not be
        // null-terminated and may contain embedded null characters.  Also note
        // that &#39;subject&#39; may be null if &#39;0 == subjectLength&#39; (denoting the
        // empty string).

    int match(bsl::pair&lt;size_t, size_t&gt; *result,
              const char                *subject,
              size_t                     subjectLength,
              size_t                     subjectOffset = 0) const;
    int match(bslstl::StringRef *result,
              const char        *subject,
              size_t             subjectLength,
              size_t             subjectOffset = 0) const;
        // Match the specified &#39;subject&#39;, having the specified &#39;subjectLength&#39;,
        // against the pattern held by this regular-expression object
        // (&#39;pattern()&#39;).  Begin matching at the optionally specified
        // &#39;subjectOffset&#39; in &#39;subject&#39;.  If &#39;subjectOffset&#39; is not specified,
        // then begin matching from the start of &#39;subject&#39;.  On success, load
        // the specified &#39;result&#39; with respectively the &#39;(offset, length)&#39; pair
        // or &#39;bslstl::StringRef&#39; indicating the leftmost match of &#39;pattern()&#39;,
        // and return 0.  Otherwise, return a non-zero value with no effect on
        // &#39;result&#39;.  The return value is 1 if the failure is caused by
        // exceeding the depth limit.  The behavior is undefined unless
        // &#39;isPrepared() == true&#39;, &#39;0 &lt;= subjectLength&#39;, &#39;0 &lt;= subjectOffset&#39;,
        // and &#39;subjectOffset &lt;= subjectLength&#39;.  The behavior is also
        // undefined if &#39;pattern()&#39; was prepared with &#39;k_FLAG_UTF8&#39;, but
        // &#39;subject&#39; is not valid UTF-8.  Note that &#39;subject&#39; need not be
        // null-terminated and may contain embedded null characters.  Also note
        // that &#39;subject&#39; may be null if &#39;0 == subjectLength&#39; (denoting the
        // empty string).

    int match(bsl::vector&lt;bsl::pair&lt;size_t, size_t&gt; &gt; *result,
              const char                              *subject,
              size_t                                   subjectLength,
              size_t                                   subjectOffset = 0)
                                                                         const;
    int match(bsl::vector&lt;bslstl::StringRef&gt; *result,
              const char                     *subject,
              size_t                          subjectLength,
              size_t                          subjectOffset = 0) const;
        // Match the specified &#39;subject&#39;, having the specified &#39;subjectLength&#39;,
        // against the pattern held by this regular-expression object
        // (&#39;pattern()&#39;).  Begin matching at the optionally specified
        // &#39;subjectOffset&#39; in &#39;subject&#39;.  If &#39;subjectOffset&#39; is not specified,
        // then begin matching from the start of &#39;subject&#39;.  On success, (1)
        // load the first element of the specified &#39;result&#39; with respectively
        // &#39;(offset, length)&#39; pair or &#39;bslstl::StringRef&#39; indicating the
        // leftmost match of &#39;pattern()&#39;, (2) load elements of &#39;result&#39; in the
        // range &#39;[ 1 .. numSubpatterns() ]&#39; with the pairs
        // (&#39;bslstl::StringRef&#39;) indicating the respective matches of
        // sub-patterns (unmatched sub-patterns have their respective &#39;result&#39;
        // elements loaded with &#39;(-1, 0)&#39; pair (empty &#39;StringRef&#39;);
        // sub-patterns matching multiple times have their respective &#39;result&#39;
        // elements loaded with the pairs indicating the rightmost match), and
        // (3) return 0.  Otherwise, return a non-zero value with no effect on
        // &#39;result&#39;.  The return value is 1 if the failure is caused by
        // exceeding the depth limit.  The behavior is undefined unless
        // &#39;isPrepared() == true&#39;, &#39;0 &lt;= subjectLength&#39;, &#39;0 &lt;= subjectOffset&#39;,
        // and &#39;subjectOffset &lt;= subjectLength&#39;.  The behavior is also
        // undefined if &#39;pattern()&#39; was prepared with &#39;k_FLAG_UTF8&#39;, but
        // &#39;subject&#39; is not valid UTF-8.  Note that &#39;subject&#39; need not be
        // null-terminated and may contain embedded null characters.  Also note
        // that &#39;subject&#39; may be null if &#39;0 == subjectLength&#39; (denoting the
        // empty string).  Also note that after a successful call, &#39;result&#39;
        // will contain exactly &#39;numSubpatterns() + 1&#39; elements.

    int numSubpatterns() const;
        // Return the number of sub-patterns in the pattern held by this
        // regular-expression object (&#39;pattern()&#39;).  The behavior is undefined
        // unless &#39;isPrepared() == true&#39;.

    const bsl::string&amp; pattern() const;
        // Return a reference to the non-modifiable pattern held by this
        // regular-expression object.  The behavior is undefined unless
        // &#39;isPrepared() == true&#39;.

    int subpatternIndex(const char *name) const;
        // Return the 1-based index of the sub-pattern having the specified
        // &#39;name&#39; in the pattern held by this regular-expression object
        // (&#39;pattern()&#39;); return -1 if &#39;pattern()&#39; does not contain a
        // sub-pattern identified by &#39;name&#39;.  The behavior is undefined unless
        // &#39;isPrepared() == true&#39;.  Note that the returned value is intended to
        // be used as an index into the &#39;bsl::vector&lt;bsl::pair&lt;int, int&gt; &gt;&#39;
        // returned by &#39;match&#39;.
};

// ============================================================================
//                              INLINE DEFINITIONS
// ============================================================================

                             // -----------
                             // class RegEx
                             // -----------

// CLASS METHODS
inline
int RegEx::defaultDepthLimit()
{
    return bsls::AtomicOperations::getIntRelaxed(&amp;s_depthLimit);
}

inline
int RegEx::setDefaultDepthLimit(int depthLimit)
{
    int previous = defaultDepthLimit();

    bsls::AtomicOperations::setIntRelaxed(&amp;s_depthLimit, depthLimit);

    return previous;
}

// CREATORS
inline
RegEx::~RegEx()
{
    clear();
    pcre2_match_context_free(d_matchContext_p);
    pcre2_compile_context_free(d_compileContext_p);
    pcre2_general_context_free(d_pcre2Context_p);
}

// MANIPULATORS
inline
int RegEx::setDepthLimit(int depthLimit)
{
    int previous = d_depthLimit;

    d_depthLimit = depthLimit;

    pcre2_set_match_limit(d_matchContext_p, d_depthLimit);

    return previous;
}

// ACCESSORS
inline
int RegEx::depthLimit() const
{
    return d_depthLimit;
}

inline
int RegEx::flags() const
{
    return d_flags;
}

inline
bool RegEx::isPrepared() const
{
    return (0 != d_patternCode_p &amp;&amp; 0 != d_matchData_p);
}

inline
const bsl::string&amp; RegEx::pattern() const
{
    return d_pattern;
}

}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2016 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
