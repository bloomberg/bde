<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: Struct bslalg::RbTreeUtil</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslalg.html">bslalg</a>      </li>
      <li><a class="el" href="structbslalg_1_1RbTreeUtil.html">bslalg::RbTreeUtil</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslalg::RbTreeUtil Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslalg::RbTreeUtil" -->
<p><code>#include &lt;<a class="el" href="bslalg__rbtreeutil_8h_source.html">bslalg_rbtreeutil.h</a>&gt;</code></p>

<p><a href="structbslalg_1_1RbTreeUtil-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#aba1f60f12d2e7985280568215bdc5b6f">leftmost</a> (const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *subtree)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#ad76aad69f016c8aa9634ddc72e682482">leftmost</a> (<a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *subtree)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a8dd94368c4acc530ddd6146aab5ef6fa">rightmost</a> (const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *subtree)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a5d2046341e7a91511bfefef1a7051dbd">rightmost</a> (<a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *subtree)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#ae5917e6b03470ba43d0c46f16abccd30">next</a> (const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a070d1435012d4553d0dc3173c992ecbb">next</a> (<a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a7a521c5d54639ef0bebca31a482906fa">previous</a> (const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#afa56ad58cbf7c992401bf3afc4a5e338">previous</a> (<a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *node)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a206cfdf81a5139230086f52d49bb76f1">find</a> (const <a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a36c5682f19b6c5cb5c003e949e7b7675">find</a> (<a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a735f4d0a0c64590078f39b78929f71d3">lowerBound</a> (const <a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#ac467f86a93c9b7b519f972489bee82cc">lowerBound</a> (<a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#abf487873c2b9e07de80445deb0311461">upperBound</a> (const <a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a91fccf8c76c69d7855a03c0209842f06">upperBound</a> (<a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FACTORY &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a9382adc1df5bc87bef8672edae3e041e">copyTree</a> (<a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *result, const <a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;original, FACTORY *nodeFactory)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FACTORY &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a1efeea62bb9ec2d910a11dda9be2899f">deleteTree</a> (<a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *tree, FACTORY *nodeFactory)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a667342046eb97f11fe086176d61f725a">findInsertLocation</a> (bool *insertAsLeftChildFlag, <a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#aa1b9e396c68d03d9c1b9c56c624e4b78">findInsertLocation</a> (bool *insertAsLeftChildFlag, <a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value, <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *hint)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a683d7303273b04b534cb1a08885162cb">findUniqueInsertLocation</a> (int *comparisonResult, <a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a930f7d00204280c41228e830b4ebdadb">findUniqueInsertLocation</a> (int *comparisonResult, <a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value, <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *hint)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NODE_COMPARATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a6095075cb573d7c11ef9a2374e062c6f">insert</a> (<a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *tree, const NODE_COMPARATOR &amp;comparator, <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *newNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a557ddee496e6452a64357773c197bff8">insertAt</a> (<a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *tree, <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *parentNode, bool leftChildFlag, <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *newNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a2bc7a8202d49085d78bddb803aeb8147">remove</a> (<a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *tree, <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a419ffde0d6f906253e55587a98bc71a6">swap</a> (<a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *a, <a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#abb14e9a02becb8566223ce4195d55773">isLeftChild</a> (const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#af4ccf892e63851ff9721161786758b13">isRightChild</a> (const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a3376917aed5c87b05450d5fc2e049db1">rotateLeft</a> (<a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#afffce85b7bbb98aaef3c753bc12a04a4">rotateRight</a> (<a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a95a70b5384e8efc9a35eba2ab0a6edda">printTreeStructure</a> (FILE *file, const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *subtree, void(*printNodeValueCallback)(FILE *, const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *), int level=0, int spacesPerLevel=4)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NODE_COMPARATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a14f08263f5285e220da1a6044dfaacd1">validateRbTree</a> (const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *rootNode, const NODE_COMPARATOR &amp;comparator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NODE_COMPARATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a80fbabf5b180a21cc33a89ccd128e715">validateRbTree</a> (const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> **errorNode, const char **errorDescription, const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *rootNode, const NODE_COMPARATOR &amp;comparator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NODE_COMPARATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1RbTreeUtil.html#a85268bf68412f0607073eb9eaf45e5d7">isWellFormed</a> (const <a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;tree, const NODE_COMPARATOR &amp;comparator)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This <code>struct</code> provides a namespace for a suite of utility functions that operate on elements of type <code><a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a></code>.</p>
<p>Each method of this class, other than <code>copyTree</code>, provides the <em>no-throw</em> exception guarantee if the the client-supplied comparator provides the no-throw guarantee, and provides the <em>strong</em> guarantee otherwise (see <code>bsldoc_glossary</code>). <code>copyTree</code> provides the <em>strong</em> guarantee. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aba1f60f12d2e7985280568215bdc5b6f"></a><!-- doxytag: member="bslalg::RbTreeUtil::leftmost" ref="aba1f60f12d2e7985280568215bdc5b6f" args="(const RbTreeNode *subtree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::leftmost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>subtree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad76aad69f016c8aa9634ddc72e682482"></a><!-- doxytag: member="bslalg::RbTreeUtil::leftmost" ref="ad76aad69f016c8aa9634ddc72e682482" args="(RbTreeNode *subtree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::leftmost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>subtree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the leftmost node in the specified <code>subtree</code>, and <code>subtree</code> if <code>subtree</code> has no left child. The behavior is undefined unless <code>0 != subtree</code>, and <code>subtree</code> refers to a valid binary tree. Note that the value held by the returned node will not compare greater than that of any other node in <code>subtree</code> (as determined by the comparator used to organize the red-black subtree data). </p>

</div>
</div>
<a class="anchor" id="a8dd94368c4acc530ddd6146aab5ef6fa"></a><!-- doxytag: member="bslalg::RbTreeUtil::rightmost" ref="a8dd94368c4acc530ddd6146aab5ef6fa" args="(const RbTreeNode *subtree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::rightmost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>subtree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d2046341e7a91511bfefef1a7051dbd"></a><!-- doxytag: member="bslalg::RbTreeUtil::rightmost" ref="a5d2046341e7a91511bfefef1a7051dbd" args="(RbTreeNode *subtree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::rightmost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>subtree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the rightmost node in the specified <code>subtree</code>, and <code>subtree</code> if <code>subtree</code> has no right child. The behavior is undefined unless <code>0 != subtree</code> and <code>subtree</code> refers to a valid binary tree. Note that the value held by the returned node will not compare less than that of any other node in <code>subtree</code> (as determined by the comparator used to organize the red-black subtree data). </p>

</div>
</div>
<a class="anchor" id="ae5917e6b03470ba43d0c46f16abccd30"></a><!-- doxytag: member="bslalg::RbTreeUtil::next" ref="ae5917e6b03470ba43d0c46f16abccd30" args="(const RbTreeNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a070d1435012d4553d0dc3173c992ecbb"></a><!-- doxytag: member="bslalg::RbTreeUtil::next" ref="a070d1435012d4553d0dc3173c992ecbb" args="(RbTreeNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the node that follows the specified <code>node</code> in an in-order traversal of the binary tree to which <code>node</code> belongs, or the tree's sentinel node if <code>node</code> is the rightmost node in the tree. The behavior is undefined unless <code>node</code> is a member of a valid binary tree, and is not a sentinel node. Note that if the tree does not contain duplicate values, then the returned node will have the smallest value greater than that of <code>node</code>. </p>

</div>
</div>
<a class="anchor" id="a7a521c5d54639ef0bebca31a482906fa"></a><!-- doxytag: member="bslalg::RbTreeUtil::previous" ref="a7a521c5d54639ef0bebca31a482906fa" args="(const RbTreeNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::previous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afa56ad58cbf7c992401bf3afc4a5e338"></a><!-- doxytag: member="bslalg::RbTreeUtil::previous" ref="afa56ad58cbf7c992401bf3afc4a5e338" args="(RbTreeNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::previous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the node that precedes the specified <code>node</code> in an in-order traversal of the binary tree to which <code>node</code> belongs, or the tree's rightmost node if <code>node</code> is the sentinel node of the tree. The behavior is undefined unless or <code>node</code> is a non-leftmost member of a valid binary tree or is a sentinel <code>node</code>. Note that if the tree does not contain duplicate values, then the returned node will have the largest value less than that of <code>node</code>. </p>

</div>
</div>
<a class="anchor" id="a206cfdf81a5139230086f52d49bb76f1"></a><!-- doxytag: member="bslalg::RbTreeUtil::find" ref="a206cfdf81a5139230086f52d49bb76f1" args="(const RbTreeAnchor &amp;tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_VALUE_COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a36c5682f19b6c5cb5c003e949e7b7675"></a><!-- doxytag: member="bslalg::RbTreeUtil::find" ref="a36c5682f19b6c5cb5c003e949e7b7675" args="(RbTreeAnchor &amp;tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_VALUE_COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the leftmost node holding the specified <code>value</code> in the specified <code>tree</code> (organized according to the specified <code>comparator) if found, and return 'tree.sentinel()</code> otherwise. <code>COMPARATOR</code> shall be a functor providing two methods that can be called as if they had the following signatures: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> RbTreeNode&amp;, <span class="keyword">const</span> VALUE&amp;) <span class="keyword">const</span>;
          <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> VALUE&amp;, <span class="keyword">const</span> RbTreeNode&amp;) <span class="keyword">const</span>;
</pre></div><p><br/>
<br/>
 The behavior is undefined unless <code>comparator</code> provides a strict weak ordering on objects of type <code>VALUE</code>, and <code>tree</code> is well-formed (see <code>isWellFormed</code>). </p>

</div>
</div>
<a class="anchor" id="a735f4d0a0c64590078f39b78929f71d3"></a><!-- doxytag: member="bslalg::RbTreeUtil::lowerBound" ref="a735f4d0a0c64590078f39b78929f71d3" args="(const RbTreeAnchor &amp;tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::lowerBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_VALUE_COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac467f86a93c9b7b519f972489bee82cc"></a><!-- doxytag: member="bslalg::RbTreeUtil::lowerBound" ref="ac467f86a93c9b7b519f972489bee82cc" args="(RbTreeAnchor &amp;tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::lowerBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_VALUE_COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the leftmost node holding the smallest value greater-than or equal-to <code>value</code> in the specified <code>tree</code> (organized according to the specified 'comparator) if found, and return <code>tree.sentinel()</code> if <code>value</code> is greater-than the rightmost node in <code>tree</code>. <code>COMPARATOR</code> shall be a functor providing two methods that can be called as if they had the following signatures: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> RbTreeNode&amp;, <span class="keyword">const</span> VALUE&amp;) <span class="keyword">const</span>;
          <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> VALUE&amp;, <span class="keyword">const</span> RbTreeNode&amp;) <span class="keyword">const</span>;
</pre></div><p><br/>
<br/>
 The behavior is undefined unless <code>comparator</code> provides a strict weak ordering on objects of type <code>VALUE</code>, and <code>tree</code> is well-formed (<code>isWellFormed</code>). Note that this function returns the <em>first</em> position before which <code>value</code> could be inserted into <code>tree</code> while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="abf487873c2b9e07de80445deb0311461"></a><!-- doxytag: member="bslalg::RbTreeUtil::upperBound" ref="abf487873c2b9e07de80445deb0311461" args="(const RbTreeAnchor &amp;tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::upperBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_VALUE_COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a91fccf8c76c69d7855a03c0209842f06"></a><!-- doxytag: member="bslalg::RbTreeUtil::upperBound" ref="a91fccf8c76c69d7855a03c0209842f06" args="(RbTreeAnchor &amp;tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::upperBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_VALUE_COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the leftmost node holding the smallest value greater-than <code>value</code> in the specified <code>tree</code> (organized according to the specified 'comparator) if found, and return <code>tree.sentinel()</code> if <code>value</code> is greater-than or equal-to the rightmost node in <code>tree</code>. <code>COMPARATOR</code> shall be a functor providing two methods that can be called as if they had the following signatures: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> RbTreeNode&amp;, <span class="keyword">const</span> VALUE&amp;) <span class="keyword">const</span>;
          <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> VALUE&amp;, <span class="keyword">const</span> RbTreeNode&amp;) <span class="keyword">const</span>;
</pre></div><p><br/>
<br/>
 The behavior is undefined unless <code>comparator</code> provides a strict weak ordering on objects of type <code>VALUE</code>, and <code>tree</code> is well-formed (<code>isWellFormed</code>). Note that this function returns the <em>last</em> position before which <code>value</code> could be inserted into <code>tree</code> while preserving its ordering. </p>

</div>
</div>
<a class="anchor" id="a9382adc1df5bc87bef8672edae3e041e"></a><!-- doxytag: member="bslalg::RbTreeUtil::copyTree" ref="a9382adc1df5bc87bef8672edae3e041e" args="(RbTreeAnchor *result, const RbTreeAnchor &amp;original, FACTORY *nodeFactory)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FACTORY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::RbTreeUtil::copyTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FACTORY *&nbsp;</td>
          <td class="paramname"> <em>nodeFactory</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>result</code>, a collection of newly created nodes having the same red-black tree structure as that of the specified <code>original</code> tree, where each node in the returned tree is created by invoking <code>nodeFactory-&gt;createNode</code> on the corresponding <code>original</code> node; if an exception occurs, use <code>nodeFactory-&gt;deleteNode</code> to destroy any newly created nodes, and propagate the exception to the caller (i.e., this operation provides the <em>strong</em> exception guarantee). <code>FACTORY</code> shall be a class providing two methods that can be called as if they had the following signatures: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          RbTreeNode *createNode(<span class="keyword">const</span> RbTreeNode&amp;);
          <span class="keywordtype">void</span> deleteNode(RbTreeNode *);
</pre></div><p><br/>
<br/>
 The behavior is undefined unless <code>result</code> is an empty tree, <code>original</code> is a well-formed (see <code>isWellFormed</code>), and <code>nodeFactory-&gt;deleteNode</code> does not throw. </p>

</div>
</div>
<a class="anchor" id="a1efeea62bb9ec2d910a11dda9be2899f"></a><!-- doxytag: member="bslalg::RbTreeUtil::deleteTree" ref="a1efeea62bb9ec2d910a11dda9be2899f" args="(RbTreeAnchor *tree, FACTORY *nodeFactory)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FACTORY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::RbTreeUtil::deleteTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FACTORY *&nbsp;</td>
          <td class="paramname"> <em>nodeFactory</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call <code>nodeFactory-&gt;deleteNode</code> on each node in <code>tree</code> and reset <code>tree</code> to an empty state. <code>FACTORY</code> shall be a class providing a method that can be called as if it has the following signature: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keywordtype">void</span> deleteNode(RbTreeNode *);
</pre></div><p><br/>
<br/>
 The behavior is undefined unless <code>tree</code> is a valid binary tree, and <code>nodeFactory-&gt;deleteNode</code> does not throw. </p>

</div>
</div>
<a class="anchor" id="a667342046eb97f11fe086176d61f725a"></a><!-- doxytag: member="bslalg::RbTreeUtil::findInsertLocation" ref="a667342046eb97f11fe086176d61f725a" args="(bool *insertAsLeftChildFlag, RbTreeAnchor *tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::findInsertLocation </td>
          <td>(</td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>insertAsLeftChildFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_VALUE_COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1b9e396c68d03d9c1b9c56c624e4b78"></a><!-- doxytag: member="bslalg::RbTreeUtil::findInsertLocation" ref="aa1b9e396c68d03d9c1b9c56c624e4b78" args="(bool *insertAsLeftChildFlag, RbTreeAnchor *tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value, RbTreeNode *hint)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::findInsertLocation </td>
          <td>(</td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>insertAsLeftChildFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_VALUE_COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>hint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the node that would be the parent a node holding the specified <code>value</code>, if it were to be inserted into the specified <code>tree</code> (organized according to the specified <code>comparator</code>), and load, into the specified <code>insertAsLeftChildFlag</code>, <code>true</code> if <code>value</code> would be held as the returned node's left child, and <code>false</code> if <code>value</code> would be held in its right child, unless <code>tree</code> is empty, in which case return <code>tree-&gt;sentinel()</code> and load <code>true</code> into <code>insertAsLeftChildFlag</code>. Optionally specify a <code>hint</code>, suggesting a node in <code>tree</code> that might be the immediate successor of a node holding <code>value</code> if it were to be inserted into <code>tree</code>. If the supplied <code>hint</code> is the successor, this operation will take amortized constant time; otherwise, it will take O(log(N)) operations, where N is the number of nodes in the tree. If a node holding <code>value</code> is inserted as suggested by this method, the resulting tree will be an ordered binary tree, but may require rebalancing (and re-coloring) to again be a valid red-black tree. <code>COMPARATOR</code> shall be a functor providing two methods that can be called as if they have the following signatures: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> RbTreeNode&amp;, <span class="keyword">const</span> VALUE&amp;) <span class="keyword">const</span>;
          <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> VALUE&amp;, <span class="keyword">const</span> RbTreeNode&amp;) <span class="keyword">const</span>;
</pre></div><p><br/>
<br/>
 The behavior is undefined unless <code>comparator</code> provides a strict weak ordering on objects of type <code>VALUE</code>, <code>tree</code> is well-formed (see <code>isWellFormed</code>), and <code>hint</code>, if supplied, is a node in <code>tree</code>. Note that this operation is intended to be used in conjunction with the <code>insertAt</code> method. </p>

</div>
</div>
<a class="anchor" id="a683d7303273b04b534cb1a08885162cb"></a><!-- doxytag: member="bslalg::RbTreeUtil::findUniqueInsertLocation" ref="a683d7303273b04b534cb1a08885162cb" args="(int *comparisonResult, RbTreeAnchor *tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::findUniqueInsertLocation </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>comparisonResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_VALUE_COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a930f7d00204280c41228e830b4ebdadb"></a><!-- doxytag: member="bslalg::RbTreeUtil::findUniqueInsertLocation" ref="a930f7d00204280c41228e830b4ebdadb" args="(int *comparisonResult, RbTreeAnchor *tree, NODE_VALUE_COMPARATOR &amp;comparator, const VALUE &amp;value, RbTreeNode *hint)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE_VALUE_COMPARATOR , class VALUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a>* bslalg::RbTreeUtil::findUniqueInsertLocation </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>comparisonResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NODE_VALUE_COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>hint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the node holding the specified <code>value</code> in the specified <code>tree</code> (organized according to the specified <code>comparator</code>) if found, and the address of the node that would be the parent for <code>value</code> otherwise; load, into the specified <code>comparisonResult</code>, 0 if <code>value</code> is found, a negative number if <code>value</code> would be held in its left child, and a positive number if <code>value</code> would be held in its right child, unless <code>tree</code> is empty, in which case load a negative number into <code>comparisonResult</code> and return <code>tree-&gt;sentinel()</code>. Optionally specify a <code>hint</code>, suggesting a node in <code>tree</code> that might be the immediate successor of a node holding <code>value</code> if it were to be inserted into <code>tree</code>. If the supplied <code>hint</code> is the successor, this operation will take amortized constant time; otherwise, it will take O(log(N)) operations, where N is the number of nodes in the tree. If a node holding <code>value</code> is inserted as suggested by this method, the resulting tree will be an ordered binary tree, but may require rebalancing (and re-coloring) to again be a valid red-black tree. <code>COMPARATOR</code> shall be a functor providing two methods that can be called as if they have the following signatures: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> RbTreeNode&amp;, <span class="keyword">const</span> VALUE&amp;) <span class="keyword">const</span>;
          <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> VALUE&amp;, <span class="keyword">const</span> RbTreeNode&amp;) <span class="keyword">const</span>;
</pre></div><p><br/>
<br/>
 The behavior is undefined unless <code>comparator</code> provides a strict weak ordering on objects of type <code>VALUE</code>, <code>tree</code> is well-formed (see <code>isWellFormed</code>), and <code>hint</code>, if supplied, is a node in <code>tree</code>. Note that this operation is intended to be used in conjunction with the <code>insertAt</code> method. </p>

</div>
</div>
<a class="anchor" id="a6095075cb573d7c11ef9a2374e062c6f"></a><!-- doxytag: member="bslalg::RbTreeUtil::insert" ref="a6095075cb573d7c11ef9a2374e062c6f" args="(RbTreeAnchor *tree, const NODE_COMPARATOR &amp;comparator, RbTreeNode *newNode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE_COMPARATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::RbTreeUtil::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NODE_COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>newNode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>newNode</code> into the specified <code>tree</code>, organized according to the specified <code>comparator</code>. The resulting tree will be well-formed (see <code>isWellFormed</code>). <code>NODE_COMPARATOR</code> shall be a functor providing a method that can be called as if it had the following signatures: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> RbTreeNode&amp;, <span class="keyword">const</span> RbTreeNode&amp;) <span class="keyword">const</span>;
</pre></div><p><br/>
<br/>
 The behavior is undefined unless <code>comparator</code> provides a strict weak ordering on objects of type <code>VALUE</code>, and <code>tree</code> is well-formed (see <code>isWellFormed</code>). </p>

</div>
</div>
<a class="anchor" id="a557ddee496e6452a64357773c197bff8"></a><!-- doxytag: member="bslalg::RbTreeUtil::insertAt" ref="a557ddee496e6452a64357773c197bff8" args="(RbTreeAnchor *tree, RbTreeNode *parentNode, bool leftChildFlag, RbTreeNode *newNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::RbTreeUtil::insertAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>parentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>leftChildFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>newNode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>newNode</code> into the specified <code>tree</code> as either the left or right child of the specified <code>parentNode</code>, as indicated by the specified <code>leftChildFlag</code>, and then rebalance the tree so that it is a valid red-black tree (see <code>validateRbTree</code>). The behavior is undefined unless <code>tree</code> is well-formed (see <code>isWellFormed</code>), and, if <code>tree</code> is empty, <code>parentNode</code> is <code>tree-&gt;sentinel()</code> and <code>leftChildFlag</code> is <code>true</code>, or, if <code>tree</code> is not empty, <code>parentNode</code> is a node in <code>tree</code> whose left or right child (as indicated by <code>leftChildFlag</code>) is 0 where if <code>newNode</code> were attached as that child (without rebalancing) <code>tree</code> would still form an ordered binary tree (though not necessarily a valid red-black tree). Note that this operation is intended to be used in conjunction with the <code>findInsertLocation</code> or <code>findUniqueInsertLocation</code> methods. </p>

</div>
</div>
<a class="anchor" id="a2bc7a8202d49085d78bddb803aeb8147"></a><!-- doxytag: member="bslalg::RbTreeUtil::remove" ref="a2bc7a8202d49085d78bddb803aeb8147" args="(RbTreeAnchor *tree, RbTreeNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::RbTreeUtil::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the specified <code>node</code> from the specified <code>tree</code>, and then rebalance <code>tree</code> so that it again forms a valid red-black tree (see <code>validateRbTree</code>). The behavior is undefined unless <code>tree</code> is well-formed (see <code>isWellFormed</code>). </p>

</div>
</div>
<a class="anchor" id="a419ffde0d6f906253e55587a98bc71a6"></a><!-- doxytag: member="bslalg::RbTreeUtil::swap" ref="a419ffde0d6f906253e55587a98bc71a6" args="(RbTreeAnchor *a, RbTreeAnchor *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::RbTreeUtil::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the nodes in the specified <code>a</code> tree with the nodes in the specified <code>b</code> tree. This method provides the no-throw exception-safety guarantee. The behavior is undefined unless <code>a</code> and <code>b</code> are well-formed (see <code>isWellFormed</code>). </p>

</div>
</div>
<a class="anchor" id="abb14e9a02becb8566223ce4195d55773"></a><!-- doxytag: member="bslalg::RbTreeUtil::isLeftChild" ref="abb14e9a02becb8566223ce4195d55773" args="(const RbTreeNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::RbTreeUtil::isLeftChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>node</code> is the left child of its parent, and <code>false</code> otherwise. The behavior is undefined unless <code>0 != node-&gt;parent()</code>. </p>

</div>
</div>
<a class="anchor" id="af4ccf892e63851ff9721161786758b13"></a><!-- doxytag: member="bslalg::RbTreeUtil::isRightChild" ref="af4ccf892e63851ff9721161786758b13" args="(const RbTreeNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::RbTreeUtil::isRightChild </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>node</code> is the left child of its parent, and <code>false</code> otherwise. The behavior is undefined unless <code>0 != node-&gt;parent()</code>. </p>

</div>
</div>
<a class="anchor" id="a3376917aed5c87b05450d5fc2e049db1"></a><!-- doxytag: member="bslalg::RbTreeUtil::rotateLeft" ref="a3376917aed5c87b05450d5fc2e049db1" args="(RbTreeNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::RbTreeUtil::rotateLeft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform counter-clockwise rotation on the specified <code>node</code>: Rotate the node's right child (the pivot) to be the node's parent, and attach the pivot's left child as the node's right child. <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">             (node)              (pivot)
             /    \              /     \.
            a   (pivot)  ---&gt;  (node)   c
                 /   \         /    \.
                b     c       a      b
</pre></div><p><br/>
<br/>
 The behavior is undefined unless <code>node-&gt;rightChild()</code> is not 0, <code>node-&gt;parent()</code> is not 0, and node's parent refers to <code>node</code> as one of its children. Note that this operation maintains the ordering of the subtree rooted at <code>node</code>. Also note this operation will successfully rotate the root node of an unbalanced, but otherwise well-formed, tree referred to by a <code><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a></code> object (see <code>isWellFormed</code>) because the parent of the root node is the tree's sentinel node (i.e., not 0), which refers to the root node as its left child, and an <code><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a></code> object returns the left child of the sentinel node as the root of the tree. </p>

</div>
</div>
<a class="anchor" id="afffce85b7bbb98aaef3c753bc12a04a4"></a><!-- doxytag: member="bslalg::RbTreeUtil::rotateRight" ref="afffce85b7bbb98aaef3c753bc12a04a4" args="(RbTreeNode *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::RbTreeUtil::rotateRight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform clockwise rotation on the specified <code>node</code>: Rotate the node's left child (the pivot) to be the node's parent, and attach the pivot's right child as the node's left child. <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">               (node)            (pivot)
               /    \            /     \.
           (pivot)   c   ---&gt;   a     (node)
            /  \                      /    \.
           a    b                    b      c
</pre></div><p><br/>
<br/>
 The behavior is undefined unless <code>node-&gt;leftChild()</code> is not 0, <code>node-&gt;parent()</code> is not 0, and node's parent refers to <code>node</code> as one of its children. Note that this operation maintains the ordering of the subtree rooted at <code>node</code>. Also note this operation will successfully rotate the root node of an unbalanced, but otherwise well-formed, tree referred to by a <code><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a></code> object (see <code>isWellFormed</code>) because the parent of the root node is the tree's sentinel node (i.e., not 0), which refers to the root node as its left child, and an <code><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a></code> object returns the left child of the sentinel node as the root of the tree. </p>

</div>
</div>
<a class="anchor" id="a95a70b5384e8efc9a35eba2ab0a6edda"></a><!-- doxytag: member="bslalg::RbTreeUtil::printTreeStructure" ref="a95a70b5384e8efc9a35eba2ab0a6edda" args="(FILE *file, const RbTreeNode *subtree, void(*printNodeValueCallback)(FILE *, const RbTreeNode *), int level=0, int spacesPerLevel=4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::RbTreeUtil::printTreeStructure </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>subtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(FILE *, const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *)&nbsp;</td>
          <td class="paramname"> <em>printNodeValueCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>spacesPerLevel</em> = <code>4</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a description of the structure of the specified <code>subtree</code> to the specified output <code>file</code> in a human-readable format, using the specified <code>printValueCallback</code> to render the value of each node. Optionally specify an initial indentation <code>level</code>, whose absolute value is incremented recursively for nested objects. If <code>level</code> is specified, optionally specify <code>spacesPerLevel</code>, whose absolute value indicates the number of spaces per indentation level for this and all of its nested objects. If <code>level</code> is negative, suppress indentation of the first line. If <code>spacesPerLevel</code> is negative, format the entire output on one line, suppressing all but the initial indentation (as governed by <code>level</code>). The behavior is undefined unless <code>node</code> is 0, or the root of a valid binary tree. Note that the implementation of this function is recursive and expensive to perform, it is intended for debugging purposes only. Also note that the format is not fully specified, and can change without notice. </p>

</div>
</div>
<a class="anchor" id="a14f08263f5285e220da1a6044dfaacd1"></a><!-- doxytag: member="bslalg::RbTreeUtil::validateRbTree" ref="a14f08263f5285e220da1a6044dfaacd1" args="(const RbTreeNode *rootNode, const NODE_COMPARATOR &amp;comparator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE_COMPARATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int bslalg::RbTreeUtil::validateRbTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>rootNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NODE_COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a80fbabf5b180a21cc33a89ccd128e715"></a><!-- doxytag: member="bslalg::RbTreeUtil::validateRbTree" ref="a80fbabf5b180a21cc33a89ccd128e715" args="(const RbTreeNode **errorNode, const char **errorDescription, const RbTreeNode *rootNode, const NODE_COMPARATOR &amp;comparator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE_COMPARATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int bslalg::RbTreeUtil::validateRbTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> **&nbsp;</td>
          <td class="paramname"> <em>errorNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>errorDescription</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeNode.html">RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>rootNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NODE_COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the (common) number of black nodes on each path from the specified <code>rootNode</code> to a leaf in the tree, 0 if <code>rootNode</code> is 0, and a negative number if <code>rootNode</code> does not refer to a valid red-black binary search tree, ordered according to the specified <code>comparator</code>. Optionally specify <code>errorNode</code> and <code>errorDescription</code> in which to load the address of a node violating a red-black tree constraint and a description of that violation, respectively. The behavior is undefined unless <code>rootNode</code> is 0, or refers to a valid binary tree.</p>
<p>Each node of a red-black tree is colored either red or black; null nodes are considered black. Four requirements must be satisfied for <code>rootNode</code> to refer to a valid red-black binary search tree:</p>
<ol>
<li>
For each node in the tree, no descendents to the left of that node would order after that node (according to the <code>comparator</code>), and no descendents to the right of that node would order before it.  </li>
<li>
For each node in the tree, each non-null child of that node refers to that node as its parent.  </li>
<li>
If a node in the tree is colored red, all its children are colored black or are null (which is considered black).  </li>
<li>
For each node in the tree, every path from that node to a leaf contains the same number of black nodes, where null children are considered black leaf nodes.  </li>
</ol>
<p>The behavior is undefined unless <code>rootNode</code> is 0, or refers to a valid binary tree. Note that the implementation of this function is recursive and has linear complexity with respect to the the number of nodes in <code>tree</code>, it is intended for debugging purposes only. </p>

</div>
</div>
<a class="anchor" id="a85268bf68412f0607073eb9eaf45e5d7"></a><!-- doxytag: member="bslalg::RbTreeUtil::isWellFormed" ref="a85268bf68412f0607073eb9eaf45e5d7" args="(const RbTreeAnchor &amp;tree, const NODE_COMPARATOR &amp;comparator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NODE_COMPARATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::RbTreeUtil::isWellFormed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NODE_COMPARATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>comparator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>tree</code> is well-formed and refers to a valid red-black tree, and <code>false</code> otherwise. For a <code><a class="el" href="classbslalg_1_1RbTreeAnchor.html">RbTreeAnchor</a></code> to be considered well-formed <em>all</em> of the following must be true:</p>
<ol>
<li>
<code>tree.rootNode()</code> must refer to a valid red-black tree, whose nodes are organized according to <code>comparator</code> (see <code>validateRbTree</code>).  </li>
<li>
<code>tree.firstNode()</code> must refer to <code>tree.sentinel()</code> if <code>tree.rootNode()</code> is 0, and leftmost(tree.rootNode())' otherwise.  </li>
<li>
<code>tree.nodeCount()</code> must be the count of nodes in <code>tree</code> (not including the sentinel node).  </li>
<li>
<code>tree.sentinel()-&gt;leftchild()</code> is <code>tree.rootNode()</code>, and (if <code>tree.rootNode()</code> is not 0) <code>tree.rootNode()-&gt;parent()</code> is <code>tree.sentinel()</code>.  </li>
<li>
<code>tree.rootNode()</code> is 0 or <code>tree.rootNode().isBlack()</code> is <code>true</code>  </li>
</ol>
<p>The behavior is undefined unless <code>tree.rootNode()</code> is 0 or refers to a valid binary tree. Note that the implementation of this function is recursive and has linear complexity with respect to the number of nodes in <code>tree</code>, it is intended for debugging purposes only. Note also that the final condition, that the root node be either 0 or colored black, is not a canonical requirement of a red-black tree but an additional invariant enforced by the methods of <code><a class="el" href="structbslalg_1_1RbTreeUtil.html">RbTreeUtil</a></code> to simplify the implementations. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="bslalg__rbtreeutil_8h_source.html">bslalg_rbtreeutil.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:52 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
