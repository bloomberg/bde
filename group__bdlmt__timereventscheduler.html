<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlmt_timereventscheduler Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlmt_timereventscheduler<br/>
<small>
[<a class="el" href="group__bdlmt.html">Package bdlmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a thread-safe recurring and non-recurring event scheduler.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlmt.html">bdlmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
&nbsp; <ul>
<li>
<a href="#3.0.1">Comparison to <code>bdlmt::EventScheduler</code></a> </li>
</ul>
</li>
<li>
<a href="#3.1">Order of Execution of Events</a> </li>
<li>
<a href="#3.2">The Dispatcher Thread and the Dispatcher Functor</a> </li>
<li>
<a href="#3.3">Thread Safety</a> </li>
<li>
<a href="#3.4">Supported Clock-Types</a> </li>
<li>
<a href="#3.5">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a thread-safe recurring and non-recurring event scheduler. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlmt_1_1TimerEventScheduler.html">bdlmt::TimerEventScheduler</a> </td><td>thread-safe event scheduler  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlmt__eventscheduler.html" title="Provide a thread-safe recurring and one-time event scheduler.">Component bdlmt_eventscheduler</a>, <a class="el" href="group__bdlcc__timequeue.html" title="Provide an efficient queue for time events.">Component bdlcc_timequeue</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a thread-safe event scheduler, <code><a class="el" href="classbdlmt_1_1TimerEventScheduler.html">bdlmt::TimerEventScheduler</a></code>. It provides methods to schedule and cancel recurring and non-recurring events. (A recurring event is also referred to as a clock). The callbacks are processed by a separate thread (called the dispatcher thread). By default the callbacks are executed in the dispatcher thread, but this behavior can be altered by providing a dispatcher functor at the creation time (see the section "The dispatcher thread and the
 dispatcher functor"). Use this component for implementing timeouts, deferred executions, calendars and reminders, and recurring tasks, among other time-bound behaviors. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="comparison_to_bdlmt~3A~3Aeventscheduler"></a> <a class="anchor" id=".comparison_to_bdlmt~3A~3Aeventscheduler"></a> <a class="anchor" id="description..comparison_to_bdlmt~3A~3Aeventscheduler"></a> <a class="anchor" id="comparison_to_bdlmt"></a> <a class="anchor" id=".comparison_to_bdlmt"></a> <a class="anchor" id="description..comparison_to_bdlmt"></a> <a class="anchor" id="3.0.1"></a> </dd></dl>
<dl class="user"><dt><b>Comparison to bdlmt::EventScheduler: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This class has been made mostly obsolete by the newer <code>bdlmt_eventscheduler</code>, which addresses two main disadvantages of this component: 1) <code>bdlmt_timereventscheduler</code> can only manage a finite number of events -- this limit is in the millions, but <code>bdlmt_eventscheduler</code> has no such limit; and 2) accessing the queue of a <code><a class="el" href="classbdlmt_1_1TimerEventScheduler.html">bdlmt::TimerEventScheduler</a></code> is inefficient when there is a large number of managed events (since adding or removing an event involves a linear search); <code>bdlmt_eventscheduler</code> has a more sophisticated queue which can be accessed in constant or worst-case log(n) time. The advantage this component provides over <code>bdlmt_eventscheduler</code> is that it provides light-weight handles to events in the queue, while <code>bdlmt_eventscheduler</code> provides more heavy-weight reference-counted handles that must be released. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="order_of_execution_of_events"></a> <a class="anchor" id="description.order_of_execution_of_events"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Order of Execution of Events: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is intended that recurring and non-recurring events are processed as close as possible to their respective time values. Delays and unfairness in thread contention can sometimes delay execution, but this component guarantees that (1) events are processed in increasing time order, and (2) are never processed sooner than their corresponding time (but could be processed arbitrarily long afterward, if the dispatcher thread has not been able to gain control in the meantime, due to thread contention or to a long event). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that it is possible to schedule events in a scheduler that has not been started yet. When starting a scheduler, scheduled events whose times have already passed will be dispatched as soon as possible after the start time, still in order of their corresponding time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The only exception to those guarantees are when an event <code>e1</code> at time <code>T</code> say, is already pending while another event <code>e2</code> is scheduled at a time &lt;= <code>T</code>. Then the dispatcher will complete the execution of <code>e1</code> before dispatching <code>e2</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="the_dispatcher_thread_and_the_dispatcher_functor"></a> <a class="anchor" id="description.the_dispatcher_thread_and_the_dispatcher_functor"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>The Dispatcher Thread and the Dispatcher Functor: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Between calls to <code>start</code> and <code>stop</code>, the scheduler creates a separate thread (called the <em>dispatcher thread</em>) to process all the callbacks. The dispatcher thread executes the callbacks by passing them to the dispatcher functor (optionally specified at creation time). The default dispatcher functor simply invokes the passed callback, effectively executing it in the dispatcher thread. Users can alter this behavior by defining their own dispatcher functor (for example in order to use a thread pool or a separate thread to run the callbacks). In that case, the user-supplied functor will still be run in the dispatcher thread, different from the scheduler thread. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlmt_1_1TimerEventScheduler.html">bdlmt::TimerEventScheduler</a></code> class is both <em>fully thread-safe</em> (i.e., all non-creator methods can correctly execute concurrently), and is <em>thread-enabled</em> (i.e., the classes does not function correctly in a non-multi-threading environment). See <code>bsldoc_glossary</code> for complete definitions of <em>fully thread-safe</em> and <em>thread-enabled</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="supported_clock-types"></a> <a class="anchor" id="description.supported_clock-types"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Supported Clock-Types: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The component <code><a class="el" href="structbsls_1_1SystemClockType.html">bsls::SystemClockType</a></code> supplies the enumeration indicating the system clock on which times supplied to other methods should be based. If the clock type indicated at construction is <code><a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56ba4b4f6a6781cc76138225ba163ed717a8">bsls::SystemClockType::e_REALTIME</a></code>, time should be expressed as an absolute offset since 00:00:00 UTC, January 1, 1970 (which matches the epoch used in <code>bdlt::CurrentTime::now(bsls::SystemClockType::e_REALTIME)</code>. If the clock type indicated at construction is <code><a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56ba28811e3a40d5ac56aeed9bd363c12201">bsls::SystemClockType::e_MONOTONIC</a></code>, time should be expressed as an absolute offset since the epoch of this clock (which matches the epoch used in <code>bdlt::CurrentTime::now(bsls::SystemClockType::e_MONOTONIC)</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example shows how to use a <code><a class="el" href="classbdlmt_1_1TimerEventScheduler.html">bdlmt::TimerEventScheduler</a></code> to implement a timeout mechanism in a server. <code>my_Session</code> maintains several connections. It closes a connection if the data for it does not arrive before a timeout (specified at the server creation time). </dd></dl>
<dl class="user"><dt><b></b></dt><dd><br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keyword">class </span>my_Session{
        <span class="comment">// This class encapsulates the data and state associated with a</span>
        <span class="comment">// connection and provides a method &#39;processData&#39; to process the</span>
        <span class="comment">// incoming data for the connection.</span>
      <span class="keyword">public</span>:
        <span class="keywordtype">int</span> processData(<span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> length);
            <span class="comment">// Process the specified &#39;data&#39; of the specified &#39;length&#39;.</span>
    };

    <span class="keyword">class </span>my_Server {
     <span class="comment">// This class implements a server maintaining several connections.</span>
     <span class="comment">// A connection is closed if the data for it does not arrive</span>
     <span class="comment">// before a timeout (specified at the server creation time).</span>

     <span class="keyword">struct </span>Connection {
         <a class="code" href="classbdlmt_1_1TimerEventScheduler.html#a04b1746361f1ab08e3b03c373e6d05de">bdlmt::TimerEventScheduler::Handle</a> d_timerId; <span class="comment">// handle for timeout</span>
                                                     <span class="comment">// event</span>

         my_Session *d_session_p;                    <span class="comment">// session for this</span>
                                                     <span class="comment">// connection</span>
     };

     <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;Connection*&gt;</a>     d_connections; <span class="comment">// maintained connections</span>
     <a class="code" href="classbdlmt_1_1TimerEventScheduler.html">bdlmt::TimerEventScheduler</a>     d_scheduler;   <span class="comment">// timeout event scheduler</span>
     <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>            d_ioTimeout;   <span class="comment">// time out</span>

     <span class="keywordtype">void</span> newConnection(Connection *connection);
         <span class="comment">// Add the specified &#39;connection&#39; to this server and schedule</span>
         <span class="comment">// the timeout event that closes this connection if the data</span>
         <span class="comment">// for this connection does not arrive before the timeout.</span>

     <span class="keywordtype">void</span> closeConnection(Connection *connection);
         <span class="comment">// Close the specified &#39;connection&#39; and remove it from this server.</span>

     <span class="keywordtype">void</span> dataAvailable(Connection *connection, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> length);
         <span class="comment">// Return if the specified &#39;connection&#39; has already timed-out.</span>
         <span class="comment">// If not, cancel the existing timeout event for the &#39;connection&#39;,</span>
         <span class="comment">// process the specified &#39;data&#39; of the specified &#39;length&#39; and</span>
         <span class="comment">// schedule a new timeout event that closes the &#39;connection&#39; if</span>
         <span class="comment">// the data does not arrive before the timeout.</span>

   <span class="keyword">public</span>:
     my_Server(<span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp;  ioTimeout,
               <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>          *allocator = 0);
         <span class="comment">// Construct a &#39;my_Server&#39; object with a timeout value of</span>
         <span class="comment">// &#39;ioTimeout&#39; seconds.  Optionally specify a &#39;allocator&#39; used to</span>
         <span class="comment">// supply memory.  If &#39;allocator&#39; is 0, the currently installed</span>
         <span class="comment">// default allocator is used.</span>

     ~my_Server();
         <span class="comment">// Perform the required clean-up and destroy this object.</span>
 };

 my_Server::my_Server(<span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp;  ioTimeout,
                      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>          *allocator)
 : d_connections(allocator)
 , d_scheduler(allocator)
 , d_ioTimeout(ioTimeout)
 {
      <span class="comment">// logic to start monitoring the arriving connections or data</span>

      d_scheduler.start();
 }

 my_Server::~my_Server()
 {
     <span class="comment">// logic to clean up</span>

     d_scheduler.stop();
 }

 <span class="keywordtype">void</span> my_Server::newConnection(my_Server::Connection *connection)
 {
     <span class="comment">// logic to add &#39;connection&#39; to the &#39;d_connections&#39;</span>

     <span class="comment">// setup the timeout for data arrival</span>
     connection-&gt;d_timerId = d_scheduler.scheduleEvent(
        <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + d_ioTimeout,
        <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;my_Server::closeConnection, <span class="keyword">this</span>, connection));
 }

 <span class="keywordtype">void</span> my_Server::closeConnection(my_Server::Connection *connection)
 {
     <span class="comment">// logic to close the &#39;connection&#39; and remove it from &#39;d_ioTimeout&#39;</span>
 }

 <span class="keywordtype">void</span> my_Server::dataAvailable(my_Server::Connection *connection,
                               <span class="keywordtype">void</span>                  *data,
                               <span class="keywordtype">int</span>                   length)
 {
     <span class="comment">// If connection has already timed out and closed, simply return.</span>
     <span class="keywordflow">if</span> (d_scheduler.cancelEvent(connection-&gt;d_timerId)) {
         <span class="keywordflow">return</span>;                                                <span class="comment">// RETURN</span>
     }

     <span class="comment">// process the data</span>
     connection-&gt;d_session_p-&gt;processData(data, length);

     <span class="comment">// setup the timeout for data arrival</span>
     connection-&gt;d_timerId = d_scheduler.scheduleEvent(
        <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + d_ioTimeout,
        <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;my_Server::closeConnection, <span class="keyword">this</span>, connection));
 }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:46 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
