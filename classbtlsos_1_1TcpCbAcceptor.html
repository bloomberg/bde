<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlsos::TcpCbAcceptor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlsos.html">btlsos</a>      </li>
      <li><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html">btlsos::TcpCbAcceptor</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlsos::TcpCbAcceptor Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlsos::TcpCbAcceptor" --><!-- doxytag: inherits="btlsc::CbChannelAllocator" -->
<p><code>#include &lt;<a class="el" href="btlsos__tcpcbacceptor_8h_source.html">btlsos_tcpcbacceptor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlsos::TcpCbAcceptor:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlsos_1_1TcpCbAcceptor.png" usemap="#btlsos::TcpCbAcceptor_map" alt=""/>
  <map id="btlsos::TcpCbAcceptor_map" name="btlsos::TcpCbAcceptor_map">
<area href="classbtlsc_1_1CbChannelAllocator.html" alt="btlsc::CbChannelAllocator" shape="rect" coords="0,0,158,24"/>
</map>
</div>

<p><a href="classbtlsos_1_1TcpCbAcceptor-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(CbChannel <br class="typebreak"/>
*, int)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannelAllocator.html#ac71d98fed88edacb076215c7e66142eb">Callback</a> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(TimedCbChannel <br class="typebreak"/>
*, int)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannelAllocator.html#acd87f760d0ab81f21fd9a9db99505a49">TimedCallback</a> )</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html#acc5fdd486b481e64215b458482847fee">TcpCbAcceptor</a> (<a class="el" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *factory, <a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *manager, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html#a51d7f1343ce806b7b5f0d566813a6749">TcpCbAcceptor</a> (<a class="el" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *factory, <a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *manager, int numElements, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html#aadc857abe031f67abaf0f6ae1c2533bc">~TcpCbAcceptor</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html#a9974680c43d807a9d2e02b02e1e9e8a6">allocate</a> (const <a class="el" href="classbtlsc_1_1CbChannelAllocator.html#ac71d98fed88edacb076215c7e66142eb">Callback</a> &amp;callback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html#af261f58989e1067dcb3a8e0090497807">allocateTimed</a> (const <a class="el" href="classbtlsc_1_1CbChannelAllocator.html#acd87f760d0ab81f21fd9a9db99505a49">TimedCallback</a> &amp;timedCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html#a64720cadd3bfd51a1565872c5f576908">cancelAll</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html#aedc606656cffccb6fe919f17d25ac973">close</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html#a57a2883e746d45ea91251738cd3ade49">deallocate</a> (<a class="el" href="classbtlsc_1_1CbChannel.html">btlsc::CbChannel</a> *channel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html#a06bc5d1e726ee6688389d96f45e103cf">invalidate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html#a8e82d55a31c858b30d4b9eb784c7a58f">open</a> (const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;endpoint, int queueSize, int reuseAddress=1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html#a56bae86561b1ac7f311685446cd6fe8a">setOption</a> (int level, int option, int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html#a90f5ba026cf54073f0c5e7a6e4e0315c">address</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html#a56b2183f5b1f3cef30a0f5aa2d7af7b8">getOption</a> (int *result, int level, int option) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html#a4c5fb08c9ec2bb6150c65c8e11870c60">isInvalid</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbAcceptor.html#a89e87c74ab0d214fdd12663c64ad4338">numChannels</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements a <code>btesc</code>-style callback-based channel allocator for a single server-side (i.e., listening) TCP/IPv4 socket. The allocation requests' callbacks are queued and invoked as appropriate. The status supplied to the callback is negative for failure and positive for a (restartable) interruption on an underlying system call. A status value of -1 indicates an allocation attempt on an uninitialized acceptor (i.e., no listening socket is established), and a status value of -2 indicates failure due to the listening socket being closed. The acceptor provides a "delayed open" (where a listening socket is established at some point after construction), and allows the listening socket to be closed (and opened again) with no effect on the state of any other channel currently managed by this acceptor. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ac71d98fed88edacb076215c7e66142eb"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::Callback" ref="ac71d98fed88edacb076215c7e66142eb" args=")" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(CbChannel *, int) <a class="el" href="classbtlsc_1_1CbChannelAllocator.html#ac71d98fed88edacb076215c7e66142eb">btlsc::CbChannelAllocator::Callback</a>)<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a result of an <code>allocate</code> request, <code>Callback</code> is an alias for a callback function object (functor) that returns <code>void</code> and takes as arguments the (possibly null) address of a callback "channel" and an integer "status" indicating either an interruption (positive) or an error (negative). Note that "status" is meaningful only if "channel" is 0. </p>

</div>
</div>
<a class="anchor" id="acd87f760d0ab81f21fd9a9db99505a49"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::TimedCallback" ref="acd87f760d0ab81f21fd9a9db99505a49" args=")" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(TimedCbChannel *, int) <a class="el" href="classbtlsc_1_1CbChannelAllocator.html#acd87f760d0ab81f21fd9a9db99505a49">btlsc::CbChannelAllocator::TimedCallback</a>)<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a result of an <code>allocateTimed</code> request, <code>TimedCallback</code> is an alias for a callback function object (functor) that returns <code>void</code> and takes as arguments the (possibly null) address of a timed callback "channel" and an integer "status" indicating either an interruption (positive) or an error (negative). Note that "status" is meaningful only if "channel" is 0. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acc5fdd486b481e64215b458482847fee"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::TcpCbAcceptor" ref="acc5fdd486b481e64215b458482847fee" args="(btlso::StreamSocketFactory&lt; btlso::IPv4Address &gt; *factory, btlso::TimerEventManager *manager, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlsos::TcpCbAcceptor::TcpCbAcceptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *&nbsp;</td>
          <td class="paramname"> <em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a callback acceptor that uses the specified <code>factory</code> (to create stream sockets) and the specified <code>manager</code> (to monitor for incoming connections). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined if either <code>factory</code> or <code>manager</code> is 0. Note that the acceptor is created in a valid state (as reported by the <code>isInvalid</code> method) and subsequent allocation requests will be enqueued successfully, but that such allocations will fail with a status of -1 until the listening socket is created (using <code>open</code>). </p>

</div>
</div>
<a class="anchor" id="a51d7f1343ce806b7b5f0d566813a6749"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::TcpCbAcceptor" ref="a51d7f1343ce806b7b5f0d566813a6749" args="(btlso::StreamSocketFactory&lt; btlso::IPv4Address &gt; *factory, btlso::TimerEventManager *manager, int numElements, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlsos::TcpCbAcceptor::TcpCbAcceptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *&nbsp;</td>
          <td class="paramname"> <em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a callback acceptor, with enough internal capacity to accommodate up to the specified <code>numElements</code> channels without reallocation, that uses the specified <code>factory</code> to create stream sockets and the specified <code>manager</code> to monitor for incoming connections. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. <code>delete</code> are used. The behavior is undefined if either <code>factory</code> or <code>manager</code> is 0 and unless <code>0 &lt; numElements</code>. Note that the acceptor is created in a valid state (as reported by the <code>isInvalid</code> method) and that subsequent allocation requests will be enqueued successfully, but the allocations will fail with a status of -1 until the listening socket is created (using <code>open</code>). </p>

</div>
</div>
<a class="anchor" id="aadc857abe031f67abaf0f6ae1c2533bc"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::~TcpCbAcceptor" ref="aadc857abe031f67abaf0f6ae1c2533bc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlsos::TcpCbAcceptor::~TcpCbAcceptor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invalidate this allocator, close the listening socket, invoke all pending callbacks, destroy all managed channels, and destroy this allocator. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9974680c43d807a9d2e02b02e1e9e8a6"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::allocate" ref="a9974680c43d807a9d2e02b02e1e9e8a6" args="(const Callback &amp;callback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsos::TcpCbAcceptor::allocate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannelAllocator.html#ac71d98fed88edacb076215c7e66142eb">Callback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to allocate a callback channel; execute the specified <code>callback</code> functor after the allocation operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt the allocation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>callback</code> will not be invoked).</p>
<p>When invoked, <code>callback</code> is passed the (possibly null) address of a callback channel and an integer "status". If that address is not 0, the allocation succeeded and status has no meaning; a non-null channel address will remain valid until deallocated explicitly (see <code>deallocate</code>). If the address is 0, a positive status indicates an interruption due to an asynchronous event; subsequent allocation attempts may succeed. A status of -1 implies that the allocation operation was "canceled" (synchronously) by the caller (see <code>cancelAll</code>) and, often, may be retried successfully. A status less than -1 indicates a more persistent error, but not necessarily a permanent one; the allocator itself may still be valid (see <code>isInvalid</code>). The behavior is undefined unless <code>callback</code> is valid. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannelAllocator.html#a3b6e7ea7294160d15f2aab767da0b19e">btlsc::CbChannelAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="af261f58989e1067dcb3a8e0090497807"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::allocateTimed" ref="af261f58989e1067dcb3a8e0090497807" args="(const TimedCallback &amp;timedCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbAcceptor::allocateTimed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannelAllocator.html#acd87f760d0ab81f21fd9a9db99505a49">TimedCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timedCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to allocate a timed callback channel; execute the specified <code>timedCallback</code> functor after the allocation operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous
         events" are permitted to interrupt the allocation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>timedCallback</code> will not be invoked).</p>
<p>When invoked, <code>timedCallback</code> is passed the (possibly null) address of a timed callback channel and an integer "status". If that address is not 0, the allocation succeeded and status has no meaning; a non-null channel address will remain valid until deallocated explicitly (see <code>deallocate</code>). If the address is 0, a positive status indicates an interruption due to an asynchronous event; subsequent allocation attempts may succeed. A status of -1 implies that the allocation operation was "canceled" (synchronously) by the caller (see <code>cancelAll</code>) and, often, may be retried successfully. A status less than -1 indicates a more persistent error, but not necessarily a permanent one; the allocator itself may still be valid (see <code>isInvalid</code>). The behavior is undefined unless <code>callback</code> is valid. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannelAllocator.html#a706c0b12d566bc6e93b693524f75628b">btlsc::CbChannelAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="a64720cadd3bfd51a1565872c5f576908"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::cancelAll" ref="a64720cadd3bfd51a1565872c5f576908" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlsos::TcpCbAcceptor::cancelAll </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Immediately cancel all pending operations on this allocator, invoking each registered allocation callback in turn. Each callback will be invoked with a null channel and a status of -1. This method may be invoked successfully on an invalid allocator; however, calling the method does not invalidate the allocator. Note that calling <code>cancelAll</code> from a callback that has itself been canceled simply extends the set of canceled operations to include any new ones initiated since the previous <code>cancelAll</code> was invoked. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannelAllocator.html#a7f7ec2df791afd7cae246afc73a7c021">btlsc::CbChannelAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="aedc606656cffccb6fe919f17d25ac973"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::close" ref="aedc606656cffccb6fe919f17d25ac973" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbAcceptor::close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the listening socket and invoke all enqueued callbacks with a status of -2. Return 0 on success, and a non-zero value otherwise. A listening socket yields a non-zero server address (see <code>address</code>). The behavior is undefined unless the listening socket is successfully established. Note that closing a listening port has no effect on any other channel managed by this allocator. </p>

</div>
</div>
<a class="anchor" id="a57a2883e746d45ea91251738cd3ade49"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::deallocate" ref="a57a2883e746d45ea91251738cd3ade49" args="(btlsc::CbChannel *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlsos::TcpCbAcceptor::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlsc_1_1CbChannel.html">btlsc::CbChannel</a> *&nbsp;</td>
          <td class="paramname"> <em>channel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Terminate all operations on the specified <code>channel</code>, invoke each pending callback with the appropriate status, and reclaim all afforded channel services. The behavior is undefined unless <code>channel</code> is currently allocated from this allocator, (i.e., was previously obtained from this instance and has not subsequently been deallocated). Note that this method can never block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannelAllocator.html#a65b8cf31fa39a9cd765d5b14536f1b3e">btlsc::CbChannelAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="a06bc5d1e726ee6688389d96f45e103cf"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::invalidate" ref="a06bc5d1e726ee6688389d96f45e103cf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlsos::TcpCbAcceptor::invalidate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Place this allocator in a permanently invalid state. No subsequent allocations will succeed. Note that invalidating this allocator has no effect on the state of any channel managed by it nor on the listening socket, which, if established, must be closed explicitly (using the <code>close</code> method). </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannelAllocator.html#a5c68b4c617800ff9fc4e9fa8e8d881c0">btlsc::CbChannelAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="a8e82d55a31c858b30d4b9eb784c7a58f"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::open" ref="a8e82d55a31c858b30d4b9eb784c7a58f" args="(const btlso::IPv4Address &amp;endpoint, int queueSize, int reuseAddress=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbAcceptor::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>queueSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reuseAddress</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Establish a listening socket having the specified <code>queueSize</code> maximum number of pending connections on the specified <code>endpoint</code>. Optionally specify a <code>reuseAddress</code> value to be used for setting <code>REUSEADDRESS</code> option. If <code>reuseAddress</code> is not specified, 1 (i.e., if the REUSEADDRESS option is enabled) is used. Return 0 on success, and a non-zero value otherwise. The behavior is undefined unless <code>0 &lt; queueSize</code> and the listening socket is closed. </p>

</div>
</div>
<a class="anchor" id="a56bae86561b1ac7f311685446cd6fe8a"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::setOption" ref="a56bae86561b1ac7f311685446cd6fe8a" args="(int level, int option, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbAcceptor::setOption </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified socket <code>option</code> having the specified <code>level</code> on the listening socket to the specified <code>value</code>. Return 0 on success and a non-zero value otherwise. (The list of commonly supported options is available in <code>btlso_socketoptutil</code>.) The behavior is undefined unless the listening socket is established. Note that all sockets allocated from this acceptor will inherit the options' values set on the listening socket. </p>

</div>
</div>
<a class="anchor" id="a90f5ba026cf54073f0c5e7a6e4e0315c"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::address" ref="a90f5ba026cf54073f0c5e7a6e4e0315c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a>&amp; btlsos::TcpCbAcceptor::address </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the (fully qualified) address of the listening socket, or an invalid address <code>(ANY_ADDRESS, ANY_PORT)</code> if the server is not established (see <code>btlso_ipv4address</code>). </p>

</div>
</div>
<a class="anchor" id="a56b2183f5b1f3cef30a0f5aa2d7af7b8"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::getOption" ref="a56b2183f5b1f3cef30a0f5aa2d7af7b8" args="(int *result, int level, int option) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbAcceptor::getOption </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the current value of the specified <code>option</code> of the specified <code>level</code> set on the listening socket. Return 0 on success and a non-zero value otherwise. The list of commonly supported options (and levels) is enumerated in <code>btlso_socketoptutil</code>. The behavior is undefined if <code>result</code> is 0 and unless the listening socket has been established. </p>

</div>
</div>
<a class="anchor" id="a4c5fb08c9ec2bb6150c65c8e11870c60"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::isInvalid" ref="a4c5fb08c9ec2bb6150c65c8e11870c60" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlsos::TcpCbAcceptor::isInvalid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if this channel allocator is <em>permanently</em> invalid (i.e., no subsequent allocation requests will succeed). </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannelAllocator.html#af1470913f03f57b1a88a3a91c1992b13">btlsc::CbChannelAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="a89e87c74ab0d214fdd12663c64ad4338"></a><!-- doxytag: member="btlsos::TcpCbAcceptor::numChannels" ref="a89e87c74ab0d214fdd12663c64ad4338" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbAcceptor::numChannels </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of channels currently allocated from this acceptor. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlsos__tcpcbacceptor_8h_source.html">btlsos_tcpcbacceptor.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:16 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
