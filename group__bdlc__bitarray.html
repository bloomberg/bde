<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlc_bitarray Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlc_bitarray<br/>
<small>
[<a class="el" href="group__bdlc.html">Package bdlc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a space-efficient, sequential container of boolean values.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html">bdlc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Bit-Array-Specific Functionality</a> </li>
<li>
<a href="#3.2">Performance and Exception-Safety Guarantees</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Creating a <code>NullableVector</code> Class</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a space-efficient, sequential container of boolean values. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlc_1_1BitArray.html">bdlc::BitArray</a> </td><td>vector-like, sequential container of boolean values  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements an efficient value-semantic, sequential container of boolean values (i.e., 0 or 1) of type <code>bool</code>. A <code>BitArray</code> may be thought of as an arbitrary-precision <code>unsigned int</code>. This metaphor is used to motivate the rich set of "bitwise" operations on <code>BitArray</code> objects provided by this component, as well as the notion of "zero extension" of a (shorter) bit array during binary operations on bit arrays having lengths that are not the same. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bit-array-specific_functionality"></a> <a class="anchor" id="description.bit-array-specific_functionality"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Bit-Array-Specific Functionality: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition to many typical vector-like container methods, this component supports "boolean" functionality unique to <code>BitArray</code>. However, unlike other standard container types such as <code><a class="el" href="classbsl_1_1bitset.html">bsl::bitset</a></code>, there is no <code>operator[](bsl::size_t index)</code> that returns a reference to a (modifiable) boolean element at the specified index position. This difference is due to the densely-packed internal representation of bits within bit arrays: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdlc_1_1BitArray.html">bdlc::BitArray</a> mA(128);
  assert(0 == mA[13]);             <span class="comment">// Ok</span>
  mA[13] = <span class="stringliteral">&#39;false&#39;</span>;                <span class="comment">// Error -- &#39;mA[13]&#39; is not an lvalue.</span>
  mA.assign(13, 1);                <span class="comment">// Ok</span>

  <span class="keyword">const</span> <a class="code" href="classbdlc_1_1BitArray.html">bdlc::BitArray</a>&amp; <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> = mA;    <span class="comment">// Ok</span>
  assert(1 == A[13]);              <span class="comment">// Ok</span>
  <span class="keyword">const</span> <span class="keywordtype">bool</span> *bp  = &amp;A[13]         <span class="comment">// Error -- &#39;A[13]&#39; is not an lvalue.</span>
  <span class="keyword">const</span> <span class="keywordtype">bool</span>  bit = A[13];         <span class="comment">// Ok</span>
</pre></div><br/>
<br/>
 Also note that there is no <code>data</code> method returning a contiguous sequence of <code>bool</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally note that, wherever an argument of non-boolean type -- e.g., the literal <code>5</code> (of type <code>int</code>) -- is used in a <code>BitArray</code> method to specify a boolean (bit) value, every non-zero value is automatically converted (via a standard conversion) to a <code>bool</code> value <code>true</code>, before the method of the <code>BitArray</code> is invoked: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdlc_1_1BitArray.html">bdlc::BitArray</a> a(10);
  assert(0 == a[5]);
  a.assign(5, 24);            <span class="comment">// Ok -- non-boolean value converted to &#39;true&#39;.</span>
  assert(1 == a[5]);
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="performance_and_exception-safety_guarantees"></a> <a class="anchor" id="description.performance_and_exception-safety_guarantees"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Performance and Exception-Safety Guarantees: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The asymptotic worst-case performance of representative operations is characterized using big-O notation, <code>O[f(N,M)]</code>, where <code>N</code> and <code>M</code> refer to the number of respective bits (i.e., <code>length</code>) of arrays <code>X</code> and <code>Y</code>, respectively. Here, <em>Amortized</em> <em>Case</em> complexity, denoted by <code>A[f(N)]</code>, is defined as the average of <code>N</code> successive invocations, as <code>N</code> gets very large. <br/>
<br/>
<div class="fragment"><pre class="fragment">                                        Average   Exception-Safety
  Operation                Worst Case    Case        Guarantee
  ---------                ----------   -------   ----------------
  DEFAULT CTOR             O[1]                   No-Throw
  COPY CTOR(Y)             O[M]                   Exception Safe

  X.DTOR()                 O[1]                   No-Throw

  X.OP=(Y)                 O[M]                   Basic &lt;*&gt;
  X.insert(index, value)   O[N]                   Basic &lt;*&gt;

  X.reserveCapacity(M)     O[N]                   Strong &lt;*&gt;
  X.append(value)          O[N]         A[1]      Strong &lt;*&gt;

  X.<a class="code" href="namespacebdlat__ValueTypeFunctions.html#a8878d14342c51302d88f1c2e8d242a5e">assign</a>(index, value)   O[1]                   No-Throw
  X.assign1(value)         O[1]                   No-Throw
  X.assign0(value)         O[1]                   No-Throw

  X.remove(index)          O[N]                   No-Throw
  X.assignAll0()           O[N]                   No-Throw
  X.assignAll1()           O[N]                   No-Throw

  X.length()               O[1]                   No-Throw
  X.OP[](index)            O[1]                   No-Throw

  X.isAny1                 O[N]                   No-Throw
  X.isAny0                 O[N]                   No-Throw

  other &#39;const&#39; methods    O[1] .. O[N]           No-Throw

  OP==(X, Y)               O[min(N, M)]           No-Throw
  OP!=(X, Y)               O[min(N, M)]           No-Throw

                &lt;*&gt; No-Throw guarantee when capacity is sufficient.
</pre></div><br/>
<br/>
 Note that <em>all</em> of the non-creator methods of <code>BitArray</code> provide the <em>No-Throw</em> guarantee whenever sufficient capacity is already available. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates the intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_creating_a_nullablevector_class"></a> <a class="anchor" id="usage.example_1~3A_creating_a_nullablevector_class"></a> <a class="anchor" id="description.usage.example_1~3A_creating_a_nullablevector_class"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating a NullableVector Class: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An efficient implementation of an arbitrary precision bit sequence container has myriad applications. For example, a <code><a class="el" href="classbdlc_1_1BitArray.html">bdlc::BitArray</a></code> can be used effectively as a parallel array of flags indicating some special property, such as <code>isNull</code>, <code>isBusinessDay</code>, etc.; its use is especially indicated when (1) the number of elements of the primary array can grow large, and (2) the individual elements do not have the capacity or capability to store the information directly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As a simple example, we'll implement a (heavily elided) value-semantic template class, <code>NullableVector&lt;TYPE&gt;</code>, that behaves like a <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;TYPE&gt;</code> but additionally allows storing a nullness flag to signify that the corresponding element was not specified. Elements added to a <code>NullableVector</code> are null by default, although there are manipulator functions that allow appending a non-null element. Each null element stores the default value for <code>TYPE</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that this class has a minimal interface (suitable for illustration purpose only) that allows users to either append a (non-null) <code>TYPE</code> value or a null value. A real <code>NullableVector</code> class would support a complete set of <em>value</em> <em>semantic</em> operations, including copy construction, assignment, equality comparison, <code>ostream</code> printing, and BDEX serialization. Also note that, for simplicity, exception-neutrality is ignored (some methods are clearly not exception-neutral). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define the interface of <code>NullableVector</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>NullableVector {
      <span class="comment">// This class implements a sequential container of elements of the</span>
      <span class="comment">// template parameter &#39;TYPE&#39;.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;TYPE&gt;</a>  d_values;       <span class="comment">// data elements</span>
      <a class="code" href="classbdlc_1_1BitArray.html">bdlc::BitArray</a>     d_nullFlags;    <span class="comment">// &#39;true&#39; indicates i&#39;th element is</span>
                                         <span class="comment">// null</span>

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      NullableVector(<span class="keyword">const</span> NullableVector&amp;);
      NullableVector&amp; operator=(<span class="keyword">const</span> NullableVector&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// TRAITS</span>
      <a class="code" href="bslmf__nestedtraitdeclaration_8h.html#a6d33ff2982d65052e0c33136bf4d74e7">BSLMF_NESTED_TRAIT_DECLARATION</a>(NullableVector,
                                     <a class="code" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span>
      NullableVector(bsl::size_t       initialLength,
                     <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Construct a vector having the specified &#39;initialLength&#39; null</span>
          <span class="comment">// elements.  Optionally specify a &#39;basicAllocator&#39; used to supply</span>
          <span class="comment">// memory.  If &#39;basicAllocator&#39; is 0, the currently supplied</span>
          <span class="comment">// default allocator is used.</span>

      <span class="comment">// ...</span>

      ~NullableVector();
          <span class="comment">// Destroy this vector.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> appendNullElement();
          <span class="comment">// Append a null element to this vector.  Note that the appended</span>
          <span class="comment">// element will have the same value as a default constructed &#39;TYPE&#39;</span>
          <span class="comment">// object.</span>

      <span class="keywordtype">void</span> appendElement(<span class="keyword">const</span> TYPE&amp; value);
          <span class="comment">// Append an element having the specified &#39;value&#39; to the end of</span>
          <span class="comment">// this vector.</span>

      <span class="keywordtype">void</span> makeNonNull(bsl::size_t index);
          <span class="comment">// Make the element at the specified &#39;index&#39; in this vector</span>
          <span class="comment">// non-null.  The behavior is undefined unless &#39;index &lt; length()&#39;.</span>

      <span class="keywordtype">void</span> makeNull(bsl::size_t index);
          <span class="comment">// Make the element at the specified &#39;index&#39; in this vector null.</span>
          <span class="comment">// The behavior is undefined unless &#39;index &lt; length()&#39;.  Note that</span>
          <span class="comment">// the new value of the element will be the default constructed</span>
          <span class="comment">// value for &#39;TYPE&#39;.</span>

      TYPE&amp; modifiableElement(bsl::size_t index);
          <span class="comment">// Return a reference providing modifiable access to the (valid)</span>
          <span class="comment">// element at the specified &#39;index&#39; in this vector.  The behavior</span>
          <span class="comment">// is undefined unless &#39;index &lt; length()&#39;.  Note that if the</span>
          <span class="comment">// element at &#39;index&#39; is null then the nullness flag is reset and</span>
          <span class="comment">// the returned value is the default constructed value for &#39;TYPE&#39;.</span>

      <span class="keywordtype">void</span> removeElement(bsl::size_t index);
          <span class="comment">// Remove the element at the specified &#39;index&#39; in this vector.  The</span>
          <span class="comment">// behavior is undefined unless &#39;index &lt; length()&#39;.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> TYPE&amp; constElement(bsl::size_t index) <span class="keyword">const</span>;
          <span class="comment">// Return a reference providing non-modifiable access to the</span>
          <span class="comment">// element at the specified &#39;index&#39; in this vector.  The behavior</span>
          <span class="comment">// is undefined unless &#39;index &lt; length()&#39;.  Note that if the</span>
          <span class="comment">// element at &#39;index&#39; is null then the nullness flag is not reset</span>
          <span class="comment">// and the returned value is the default constructed value for</span>
          <span class="comment">// &#39;TYPE&#39;.</span>

      <span class="keywordtype">bool</span> isAnyElementNonNull() <span class="keyword">const</span>;
          <span class="comment">// Return &#39;true&#39; if any element in this vector is non-null, and</span>
          <span class="comment">// &#39;false&#39; otherwise.</span>

      <span class="keywordtype">bool</span> isAnyElementNull() <span class="keyword">const</span>;
          <span class="comment">// Return &#39;true&#39; if any element in this vector is null, and &#39;false&#39;</span>
          <span class="comment">// otherwise.</span>

      <span class="keywordtype">bool</span> isElementNull(bsl::size_t index) <span class="keyword">const</span>;
          <span class="comment">// Return &#39;true&#39; if the element at the specified &#39;index&#39; in this</span>
          <span class="comment">// vector is null, and &#39;false&#39; otherwise.  The behavior is</span>
          <span class="comment">// undefined unless &#39;index &lt; length()&#39;.</span>

      bsl::size_t length() <span class="keyword">const</span>;
          <span class="comment">// Return the number of elements in this vector.</span>

      bsl::size_t numNullElements() <span class="keyword">const</span>;
          <span class="comment">// Return the number of null elements in this vector.</span>
  };
</pre></div><br/>
<br/>
 Then, we implement, in turn, each of the methods declared above: <br/>
<br/>
<div class="fragment"><pre class="fragment">                   <span class="comment">// --------------------</span>
                   <span class="comment">// class NullableVector</span>
                   <span class="comment">// --------------------</span>

  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  NullableVector&lt;TYPE&gt;::NullableVector(bsl::size_t       initialLength,
                                       <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_values(initialLength, TYPE(), basicAllocator)
  , d_nullFlags(initialLength, true, basicAllocator)
  {
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  NullableVector&lt;TYPE&gt;::~NullableVector()
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(d_values.size() == d_nullFlags.length());
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> NullableVector&lt;TYPE&gt;::appendElement(<span class="keyword">const</span> TYPE&amp; value)
  {
      d_values.push_back(value);
      d_nullFlags.append(<span class="keyword">false</span>);
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> NullableVector&lt;TYPE&gt;::appendNullElement()
  {
      d_values.push_back(TYPE());
      d_nullFlags.append(<span class="keyword">true</span>);
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> NullableVector&lt;TYPE&gt;::makeNonNull(bsl::size_t index)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(index &lt; length());

      d_nullFlags.assign(index, <span class="keyword">false</span>);
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> NullableVector&lt;TYPE&gt;::makeNull(bsl::size_t index)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(index &lt; length());

      d_values[index] = TYPE();
      d_nullFlags.assign(index, <span class="keyword">true</span>);
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  TYPE&amp; NullableVector&lt;TYPE&gt;::modifiableElement(bsl::size_t index)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(index &lt; length());

      d_nullFlags.assign(index, <span class="keyword">false</span>);
      <span class="keywordflow">return</span> d_values[index];
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> NullableVector&lt;TYPE&gt;::removeElement(bsl::size_t index)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(index &lt; length());

      d_values.erase(d_values.begin() + index);
      d_nullFlags.remove(index);
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keyword">const</span> TYPE&amp; NullableVector&lt;TYPE&gt;::constElement(bsl::size_t index)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(index &lt; length());

      <span class="keywordflow">return</span> d_values[index];
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> NullableVector&lt;TYPE&gt;::isAnyElementNonNull()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_nullFlags.isAny0();
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> NullableVector&lt;TYPE&gt;::isAnyElementNull()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_nullFlags.isAny1();
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> NullableVector&lt;TYPE&gt;::isElementNull(bsl::size_t index)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(index &lt; length());

      <span class="keywordflow">return</span> d_nullFlags[index];
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  bsl::size_t NullableVector&lt;TYPE&gt;::length()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_values.size();
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  bsl::size_t NullableVector&lt;TYPE&gt;::numNullElements()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_nullFlags.num1();
  }
</pre></div><br/>
<br/>
 Next, we create an empty <code>NullableVector</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  NullableVector&lt;int&gt;        array(0);
  <span class="keyword">const</span> NullableVector&lt;int&gt;&amp; ARRAY       = array;
  <span class="keyword">const</span> <span class="keywordtype">int</span>                  DEFAULT_INT = 0;

  assert(0       == ARRAY.length());
  assert(0       == ARRAY.numNullElements());
  assert(<span class="keyword">false</span>   == ARRAY.isAnyElementNonNull());
  assert(<span class="keyword">false</span>   == ARRAY.isAnyElementNull());
</pre></div><br/>
<br/>
 Then, we append a non-null element to it: <br/>
<br/>
<div class="fragment"><pre class="fragment">  array.appendElement(5);
  assert(1       == ARRAY.length());
  assert(5       == ARRAY.constElement(0));
  assert(<span class="keyword">false</span>   == ARRAY.isElementNull(0));
  assert(0       == ARRAY.numNullElements());
  assert(<span class="keyword">true</span>    == ARRAY.isAnyElementNonNull());
  assert(<span class="keyword">false</span>   == ARRAY.isAnyElementNull());
</pre></div><br/>
<br/>
 Next, we append a null element: <br/>
<br/>
<div class="fragment"><pre class="fragment">  array.appendNullElement();
  assert(2           == ARRAY.length());
  assert(5           == ARRAY.constElement(0));
  assert(DEFAULT_INT == ARRAY.constElement(1));
  assert(<span class="keyword">false</span>       == ARRAY.isElementNull(0));
  assert(<span class="keyword">true</span>        == ARRAY.isElementNull(1));
  assert(1           == ARRAY.numNullElements());
  assert(<span class="keyword">true</span>        == ARRAY.isAnyElementNonNull());
  assert(<span class="keyword">true</span>        == ARRAY.isAnyElementNull());
</pre></div><br/>
<br/>
 Then, we make the null element non-null: <br/>
<br/>
<div class="fragment"><pre class="fragment">  array.makeNonNull(1);
  assert(2           == ARRAY.length());
  assert(5           == ARRAY.constElement(0));
  assert(DEFAULT_INT == ARRAY.constElement(1));
  assert(<span class="keyword">false</span>       == ARRAY.isElementNull(0));
  assert(<span class="keyword">false</span>       == ARRAY.isElementNull(1));
  assert(0           == ARRAY.numNullElements());
  assert(<span class="keyword">true</span>        == ARRAY.isAnyElementNonNull());
  assert(<span class="keyword">false</span>       == ARRAY.isAnyElementNull());
</pre></div><br/>
<br/>
 Next, we make the first element null: <br/>
<br/>
<div class="fragment"><pre class="fragment">  array.makeNull(0);
  assert(2           == ARRAY.length());
  assert(DEFAULT_INT == ARRAY.constElement(0));
  assert(DEFAULT_INT == ARRAY.constElement(1));
  assert(<span class="keyword">true</span>        == ARRAY.isElementNull(0));
  assert(<span class="keyword">false</span>       == ARRAY.isElementNull(1));
  assert(1           == ARRAY.numNullElements());
  assert(<span class="keyword">true</span>        == ARRAY.isAnyElementNonNull());
  assert(<span class="keyword">true</span>        == ARRAY.isAnyElementNull());
</pre></div><br/>
<br/>
 Now, we remove the front element: <br/>
<br/>
<div class="fragment"><pre class="fragment">  array.removeElement(0);
  assert(1           == ARRAY.length());
  assert(DEFAULT_INT == ARRAY.constElement(0));
  assert(<span class="keyword">false</span>       == ARRAY.isElementNull(0));
  assert(0           == ARRAY.numNullElements());
  assert(<span class="keyword">true</span>        == ARRAY.isAnyElementNonNull());
  assert(<span class="keyword">false</span>       == ARRAY.isAnyElementNull());
</pre></div><br/>
<br/>
 Finally, we remove the last remaining element and observe that the object is empty again: <br/>
<br/>
<div class="fragment"><pre class="fragment">  array.removeElement(0);
  assert(0       == ARRAY.length());
  assert(0       == ARRAY.numNullElements());
  assert(<span class="keyword">false</span>   == ARRAY.isAnyElementNonNull());
  assert(<span class="keyword">false</span>   == ARRAY.isAnyElementNull());
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:35 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
