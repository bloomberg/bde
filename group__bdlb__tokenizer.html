<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlb_tokenizer Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlb_tokenizer<br/>
<small>
[<a class="el" href="group__bdlb.html">Package bdlb</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide access to user-described tokens via string references.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html">bdlb</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Soft versus Hard Delimiters</a> </li>
<li>
<a href="#3.2">The Input String to be Tokenized</a> </li>
<li>
<a href="#3.3">Iterating using a <code>TokenizerIterator</code> object (ACCESS TO TOKENS ONLY)</a> </li>
<li>
<a href="#3.4">Iterating using a <code>Tokenizer</code> object (ACCESS TO TOKENS AND DELIMITERS)</a> </li>
<li>
<a href="#3.5">Token and Delimiter Lifetimes</a> </li>
<li>
<a href="#3.6">Comprehensive Detailed Parsing Specification</a> </li>
<li>
<a href="#3.7">Usage</a> <ul>
<li>
<a href="#3.7.1">Example 1: Iterating Over Tokens Using Just <em>Soft</em> Delimiters</a> </li>
<li>
<a href="#3.7.2">Example 2: Iterating Over Tokens Using Just <em>Hard</em> Delimiters</a> </li>
<li>
<a href="#3.7.3">Example 3: Iterating Over Tokens Using Both <em>Hard</em> and <em>Soft</em> Delimiters</a> </li>
<li>
<a href="#3.7.4">Example 4: Using the <code>Tokenizer</code> to Access Delimiters As Well As Tokens</a> </li>
<li>
<a href="#3.7.5">Example 5: Parsing Layers of Different Tokens Using Nested <code>for</code> Loops</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide access to user-described tokens via string references. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlb_1_1Tokenizer.html">bdlb::Tokenizer</a> </td><td>lexer for tokens defined via hard and/or soft delimiters  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1TokenizerIterator.html">bdlb::TokenizerIterator</a> </td><td>input iterator for delimited tokens in a string  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslstl__stringref.html" title="Provide a reference to a const string.">Component bslstl_stringref</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a mechanism, <code><a class="el" href="classbdlb_1_1Tokenizer.html">bdlb::Tokenizer</a></code>, that provides non-destructive sequential (read-only) access to tokens in a given input string as characterized by two disjoint sets of user-specified delimiter characters, each of which is supplied at construction via either a <code>const <a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a>&amp;</code> or (for efficiency, when only the leading characters of the input string may need to be parsed) a <code>const char *</code>. Note that each character (including <code>\0</code>) that is not explicitly designated as a delimiter character is assumed to be <em>token</em> character. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="soft_versus_hard_delimiters"></a> <a class="anchor" id="description.soft_versus_hard_delimiters"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Soft versus Hard Delimiters: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The tokenizer recognizes two distinct kinds of delimiter characters, <em>soft</em> and <em>hard</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <em>soft</em> <em>delimiter</em> is a maximal (non-empty) sequence of soft-delimiter characters. Soft delimiters, typically whitespace characters, are used to separate (rather than terminate) tokens, and thus never result in an empty token. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <em>hard</em> <em>delimiter</em> is a maximal (non-empty) sequence of delimiter characters consisting of exactly one hard-delimiter character. Hard delimiters, typically printable punctuation characters such (<code>/</code>) or colon (<code>:</code> ), are used to terminate (rather than just separate) tokens, and thus a hard delimiter that is not preceded by a token character results in an empty token. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Soft delimiters are used in applications where multiple consecutive delimiter characters are to be treated as just a single delimiter. For example, if we want the input string "Sticks  and stones" to parse into a sequence of three non-empty tokens ["Sticks", "and", "stones"], rather than the five-token sequence ["Sticks", "", "", "and", "stones"], we would make the space (<code>'&nbsp;'</code>) a soft-delimiter character. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Hard delimiters are used in applications where consecutive delimiter characters are to be treated as separate delimiters, giving rise to the possibility of empty tokens. Making the slash (<code>/</code>) in the standard date format a hard delimiter for the input string "15//9" yields the three-token sequence ["15", "", "9"], rather than the two-token one ["15", "9"] had it been made soft. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>All members within each respective character set are considered equivalent with respect to tokenization. For example, making <code>/</code> and <code>:</code> <em>soft</em> <em>delimiter</em> characters on the questionably formatted date "2015/:10:/31" would yield the token sequence ["2015", "10", "31"], whereas making <code>/</code> and <code>:</code> <em>hard</em> <em>delimiter</em> characters would result in the token sequence ["2015", "", "10", "", "31"]. Making either of these two delimiter characters hard and the other soft would, in this example, yield the former (shorter) sequence of tokens. The details of how soft and hard delimiters interact is illustrated in more detail in the following section (but also see, later on, the section on "Comprehensive Detailed Parsing
 Specification"). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="the_input_string_to_be_tokenized"></a> <a class="anchor" id="description.the_input_string_to_be_tokenized"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>The Input String to be Tokenized: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Each input string consists of an optional leading sequence of soft-delimiter characters called the <em>leader</em>, followed by an alternating sequence of tokens and delimiters (the final delimiter being optional): <br/>
<br/>
<div class="fragment"><pre class="fragment">  Input String:
  +--------+---------+-------------+---...---+---------+-------------+
  | leader | token_1 | delimiter_1 |         | token_N | delimiter_N |
  +--------+---------+-------------+---...---+---------+-------------+
  (optional)                                              (optional)
</pre></div><br/>
<br/>
 The tokenization of a string can also be expressed as pseudo-Posix regular expression notation: <br/>
<br/>
<div class="fragment"><pre class="fragment">   delimiter = [[:soft:]]+ | [[:soft:]]* [[:hard:]] [[:soft:]]*
   token     = [^[:soft:][:hard:]]*
   <span class="keywordtype">string</span>    = [[:soft:]]* (token delimiter)* token?
</pre></div><br/>
<br/>
 Parsing is from left to right and is <em>greedy</em> -- i.e., the longest sequence satisfying the regular expression is the one that matches. For example, let <code>s</code> represent the start of a soft delimiter, <code>d</code> the start of a hard delimiter, <code>^" the start of a token, and '~&lt;/code&gt; the continuation of that same
 delimiter or token.  Using &lt;code&gt;.&lt;/code&gt; as a soft delimiter and "/" as a hard one, the string <br/>
<br/>
<div class="fragment"><pre class="fragment">         s~   h~  h~~  h~     s~   hh  s  h~h    h~~~        Delimiters

        <span class="stringliteral">&quot;..One/.if./.by./land,..two//if.by/./sea!./..&quot;</span>

           ^~~  ^~   ^~  ^~~~   ^~~ ^^~ ^~  ^^~~             Tokens
                                    |       |
                                 (empty)  (empty)
</pre></div><br/>
<br/>
 yields the tokenization <br/>
<br/>
<div class="fragment"><pre class="fragment">     [One]  [<span class="keywordflow">if</span>]   [by]  [land,]  [two] [] [<span class="keywordflow">if</span>] [by]  [] [sea]       Tokens

  (..)   (/.)  (./.)  (./)     (..)   (/)(/)  (.)  (/.)(/)   (./..)  Delims
</pre></div><br/>
<br/>
 Notice that in pair of hard delimiters "/./" before the token "sea", the soft token character between the two hard ones binds to the earlier delimiter. </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> <a class="anchor" id="iterating_using_a_tokenizeriterator_object_(access_to_tokens_only)"></a> <a class="anchor" id="description.iterating_using_a_tokenizeriterator_object_(access_to_tokens_only)"></a> <a class="anchor" id="3.3"></a> </code></dd></dl>
<dl class="user"><dt><b>Iterating using a TokenizerIterator object (ACCESS TO TOKENS ONLY): </b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> This component provides two separate mechanisms by which a user may iterate over a sequence of tokens. The first mechanism is as a <em>token</em> <em>range</em>, exposed by the <code>TokenizerIterator</code> objects returned by the <code>begin</code> and <code>end</code> methods on a <code>Tokenizer</code> object. A <code>TokenizerIterator</code> supports the concept of a standard <em>input</em> <em>iterator</em>, returning each successive token as a <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>, making it suitable for generic use -- e.g., in a range-based <code>for</code> loop: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> parse_1(bsl::ostream&amp; output, <span class="keyword">const</span> <span class="keywordtype">char</span> *input)
      <span class="comment">// Print, to the specified &#39;output&#39; stream, each whitespace-delimited</span>
      <span class="comment">// token in the specified &#39;input; string on a separate line following</span>
      <span class="comment">// a vertical bar (&#39;|&#39;) and a hard space (&#39; &#39;).</span>
  {
      <span class="keyword">const</span> <span class="keywordtype">char</span> softDelimiters[] = <span class="stringliteral">&quot; \t\n&quot;</span>;  <span class="comment">// whitespace</span>

      <span class="keywordflow">for</span> (<a class="code" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> token : bdlb_Tokenizer(input, softDelimiters) {
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;| &quot;</span> &lt;&lt; token &lt;&lt; bsl::endl;
      }
  }
</pre></div><br/>
<br/>
 The <code>parse_1</code> function above produces each (non-whitespace) token in the supplied input string on a separate line. So, were <code>parse_1</code> to be given a reference to <code>bsl::cout</code> and the input string <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="stringliteral">&quot; Times  like \tthese\n  try \n \t men&#39;s\t \tsouls.\n&quot;</span>
</pre></div><br/>
<br/>
 we would expect <br/>
<br/>
<div class="fragment"><pre class="fragment">  | Times
  | like
  | these
  | <span class="keywordflow">try</span>
  | men<span class="stringliteral">&#39;s</span>
<span class="stringliteral">  | souls.</span>
</pre></div><br/>
<br/>
 to be displayed on <code>bsl::cout</code>. Note that there is no way to access the delimiters from a <code>TokenizerIterator</code> directly, for that we will need to use the <code>tokenizer</code> as a non-standard "iterator" directly. </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> <a class="anchor" id="iterating_using_a_tokenizer_object_(access_to_tokens_and_delimiters)"></a> <a class="anchor" id="description.iterating_using_a_tokenizer_object_(access_to_tokens_and_delimiters)"></a> <a class="anchor" id="3.4"></a> </code></dd></dl>
<dl class="user"><dt><b>Iterating using a Tokenizer object (ACCESS TO TOKENS AND DELIMITERS): </b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> The second mechanism, not intended for generic use, provides direct access to the previous and current (trailing) delimiters as well as the current token: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> parse_2(bsl::outstream, <span class="keyword">const</span> <span class="keywordtype">char</span> *input)
      <span class="comment">// Print, to the specified &#39;output&#39; stream the leader of the specified</span>
      <span class="comment">// &#39;input&#39;, on a singly line, followed by subsequent current token and</span>
      <span class="comment">// (trailing) delimiter pairs on successive lines, each line beginning</span>
      <span class="comment">// with a vertical bar (&#39;|&#39;) followed by a tab (&#39;\t&#39;) character.</span>
  {
      <span class="keyword">const</span> <span class="keywordtype">char</span> softDelimiters[] = <span class="stringliteral">&quot; &quot;</span>;
      <span class="keyword">const</span> <span class="keywordtype">char</span> hardDelimiters[] = <span class="stringliteral">&quot;:/&quot;</span>

      bdlb_Tokenizer it(input, softDelimiters, hardDelimiters);
      bsl::cout &lt;&lt; <span class="stringliteral">&quot;| &quot;</span> &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; it.previousDelimiter() &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; bsl::endl;

      <span class="keywordflow">for</span> (; it; ++it) {
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;|\t&quot;</span>
                    &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; it.token() &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span>
                    &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>
                    &lt;&lt; <span class="charliteral">&#39;&quot;&#39;</span> &lt;&lt; it.delimiter() <span class="charliteral">&#39;&quot;&#39;</span>
                    &lt;&lt; bsl::endl;
      }
</pre></div><br/>
<br/>
 The parse_2 function above produces the <em>leader</em> on the first line, followed by each <em>token</em> along with its current (trailing) delimiter on successive lines. So, were <code>parse_2</code> to be given a reference to <code>bsl::cout</code> and the input string <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="stringliteral">&quot; I&#39;ve :been: a : :bad:/ boy! / &quot;</span>
</pre></div><br/>
<br/>
 we would expect <br/>
<br/>
<div class="fragment"><pre class="fragment">  |       <span class="stringliteral">&quot; &quot;</span>
  |       <span class="stringliteral">&quot;I&#39;ve&quot;</span>  <span class="stringliteral">&quot; :&quot;</span>
  |       <span class="stringliteral">&quot;been&quot;</span>  <span class="stringliteral">&quot;: &quot;</span>
  |       <span class="stringliteral">&quot;a :&quot;</span>   <span class="stringliteral">&quot; : &quot;</span>
  |       <span class="stringliteral">&quot;&quot;</span>      <span class="stringliteral">&quot;:&quot;</span>
  |       <span class="stringliteral">&quot;bad&quot;</span>   <span class="stringliteral">&quot;:&quot;</span>
  |       <span class="stringliteral">&quot;&quot;</span>      <span class="stringliteral">&quot;/ &quot;</span>
  |       <span class="stringliteral">&quot;boy!&quot;</span>  <span class="stringliteral">&quot; / &quot;</span>
</pre></div><br/>
<br/>
 to be displayed on <code>bsl::cout</code>. </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> <a class="anchor" id="token_and_delimiter_lifetimes"></a> <a class="anchor" id="description.token_and_delimiter_lifetimes"></a> <a class="anchor" id="3.5"></a> </code></dd></dl>
<dl class="user"><dt><b>Token and Delimiter Lifetimes: </b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> All tokens and delimiters are returned efficiently by value as <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> objects, which naturally remain valid so long as the underlying input string remains unchanged -- irrespective of the validity of the <code>tokenizer</code> or any of its dispensed token iterators. Note, however, that all such token iterators are invalidated if the parent tokenizer object is destroyed or reset. Note also the previous delimiter field remains accessible from a <code>tokenizer</code> object even after it has reached the end of its input. Also note that the <em>leader</em> is accessible, using the <code>previousDelimiter</code>, method prior to advancing the interation state of state of the <code>Tokenizer</code>. </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> <a class="anchor" id="comprehensive_detailed_parsing_specification"></a> <a class="anchor" id="description.comprehensive_detailed_parsing_specification"></a> <a class="anchor" id="3.6"></a> </code></dd></dl>
<dl class="user"><dt><b>Comprehensive Detailed Parsing Specification: </b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> This section provides a comprehensive (length-ordered) enumeration of how the <code><a class="el" href="classbdlb_1_1Tokenizer.html">bdlb::Tokenizer</a></code> performs, according to its three (non-null) character types: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="charliteral">&#39;.&#39;</span> = any *soft* delimiter character
  <span class="charliteral">&#39;#&#39;</span> = any *hard* delimiter character
  <span class="charliteral">&#39;T&#39;</span> = any token character
</pre></div><br/>
<br/>
 Here's how iteration progresses for various input strings. Note that input strings having consecutive characters of the same category that naturally coalesce (i.e., behave as if they were a single character of that category) -- namely soft-delimiter or token characters -- are labeled with <code>(%)</code>. For example, consider the input ".." at the top of the [length 2] section below. The table indicates, with a (%) in the first column, that the input acts the same as if it were a single (soft-delimiter) character (i.e., "."). There is only one line in this row of the table because, upon construction, the iterator is immediately invalid (as indicated by the right-most column). Now consider the "##" entry near the bottom of [length 2]. These (hard-delimiter) tokens do not coalesce. What's more, the iterator on construction is valid and produces a empty leader and empty first token. after advancing the tokenizer, the second line of that row shows the current state of iteration with the previous delimiter being a <code>#</code> as well as the current one. The current token is again shown as empty. After advancing the tokenizer again, we now see that the iterater is invalid, yet the previous delimiter (still accessible) is a <code>#</code>). <br/>
<br/>
<div class="fragment"><pre class="fragment">  (%) = repeat   Previous   Current   Current   Iterator
  Input String   Delimiter   Token   Delimiter   Status
  ============   =========  =======  =========  ========  [length 0]
  <span class="stringliteral">&quot;&quot;</span>             <span class="stringliteral">&quot;&quot;</span>         na       na         invalid

  ============   =========  =======  =========  ========  [length 1]
  <span class="stringliteral">&quot;.&quot;</span>            <span class="stringliteral">&quot;.&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;#&quot;</span>            <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;T&quot;</span>            <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;&quot;</span>         valid
                 <span class="stringliteral">&quot;&quot;</span>         na       na         invalid

  ============   =========  =======  =========  ========  [length 2]
  <span class="stringliteral">&quot;..&quot;</span>     (%)   <span class="stringliteral">&quot;..&quot;</span>       na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;.#&quot;</span>           <span class="stringliteral">&quot;.&quot;</span>        <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;.T&quot;</span>           <span class="stringliteral">&quot;.&quot;</span>        <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;&quot;</span>         valid
                 <span class="stringliteral">&quot;&quot;</span>         na       na         invalid

  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;#.&quot;</span>           <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;##&quot;</span>           <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;#T&quot;</span>           <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;&quot;</span>         valid
                 <span class="stringliteral">&quot;&quot;</span>         na       na         invalid

  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;T.&quot;</span>           <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;.&quot;</span>        valid
                 <span class="stringliteral">&quot;.&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;T#&quot;</span>           <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;TT&quot;</span>     (%)   <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;TT&quot;</span>     <span class="stringliteral">&quot;&quot;</span>         valid
                 <span class="stringliteral">&quot;&quot;</span>         na       na         invalid

  ============   =========  =======  =========  ========  [length 3]
  <span class="stringliteral">&quot;...&quot;</span>    (%)   <span class="stringliteral">&quot;...&quot;</span>      na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;..#&quot;</span>    (%)   <span class="stringliteral">&quot;..&quot;</span>       <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                   <span class="stringliteral">&quot;#&quot;</span>      na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;..T&quot;</span>    (%)   <span class="stringliteral">&quot;..&quot;</span>       <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;&quot;</span>         valid
                 <span class="stringliteral">&quot;..&quot;</span>       na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;.#.&quot;</span>          <span class="stringliteral">&quot;.&quot;</span>        <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#.&quot;</span>       valid
                 <span class="stringliteral">&quot;#.&quot;</span>       na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;.##&quot;</span>          <span class="stringliteral">&quot;.&quot;</span>        <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;.#T&quot;</span>          <span class="stringliteral">&quot;.&quot;</span>        <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;&quot;</span>         valid
                 <span class="stringliteral">&quot;&quot;</span>         na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;.T.&quot;</span>          <span class="stringliteral">&quot;.&quot;</span>        <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;.&quot;</span>        valid
                 <span class="stringliteral">&quot;.&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;.T#&quot;</span>          <span class="stringliteral">&quot;.&quot;</span>        <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;.TT&quot;</span>    (%)   <span class="stringliteral">&quot;.&quot;</span>        <span class="stringliteral">&quot;TT&quot;</span>     <span class="stringliteral">&quot;&quot;</span>         valid
                 <span class="stringliteral">&quot;&quot;</span>         na       na         invalid

  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;#..&quot;</span>    (%)   <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#..&quot;</span>      invalid
                 <span class="stringliteral">&quot;#..&quot;</span>      na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;#.#&quot;</span>          <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#.&quot;</span>       valid
                 <span class="stringliteral">&quot;#.&quot;</span>       <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;#.T&quot;</span>          <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#.&quot;</span>       valid
                 <span class="stringliteral">&quot;#.&quot;</span>       <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;&quot;</span>         valid
                 <span class="stringliteral">&quot;&quot;</span>         na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;##.&quot;</span>          <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#.&quot;</span>       valid
                 <span class="stringliteral">&quot;#.&quot;</span>       na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;###&quot;</span>          <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;##T&quot;</span>          <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;&quot;</span>         valid
                 <span class="stringliteral">&quot;&quot;</span>         na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;#T.&quot;</span>          <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;.&quot;</span>        valid
                 <span class="stringliteral">&quot;.&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;#T#&quot;</span>          <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;#TT&quot;</span>    (%)   <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;TT&quot;</span>     <span class="stringliteral">&quot;&quot;</span>         valid
                 <span class="stringliteral">&quot;&quot;</span>         na       na         invalid

  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;T..&quot;</span>    (%)   <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;..&quot;</span>       valid
                 <span class="stringliteral">&quot;..&quot;</span>       na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;T.#&quot;</span>          <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;.#&quot;</span>       valid
                 <span class="stringliteral">&quot;.#&quot;</span>       na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;T.T&quot;</span>          <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;.&quot;</span>        valid
                 <span class="stringliteral">&quot;.&quot;</span>        <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;&quot;</span>         valid
                 <span class="stringliteral">&quot;&quot;</span>         na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;T#.&quot;</span>          <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;#.&quot;</span>       valid
                 <span class="stringliteral">&quot;#.&quot;</span>       na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;T##&quot;</span>          <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;&quot;</span>       <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;T#T&quot;</span>          <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;T&quot;</span>      <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;&quot;</span>         na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;TT.&quot;</span>    (%)   <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;TT&quot;</span>     <span class="stringliteral">&quot;.&quot;</span>        valid
                 <span class="stringliteral">&quot;.&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;TT#&quot;</span>    (%)   <span class="stringliteral">&quot;&quot;</span>         <span class="stringliteral">&quot;TT&quot;</span>     <span class="stringliteral">&quot;#&quot;</span>        valid
                 <span class="stringliteral">&quot;#&quot;</span>        na       na         invalid
  ------------   ---------  -------  ---------  --------
  <span class="stringliteral">&quot;TTT&quot;</span>    (%)   <span class="stringliteral">&quot;#&quot;</span>        <span class="stringliteral">&quot;TTT&quot;</span>    <span class="stringliteral">&quot;&quot;</span>         valid
                 <span class="stringliteral">&quot;&quot;</span>         na       na         invalid
  ------------   ---------  -------  ---------  --------
</pre></div><br/>
<br/>
 </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> <a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.7"></a> </code></dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> This section illustrates intended use of this component. </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> <a class="anchor" id="example_1~3A_iterating_over_tokens_using_just_soft_delimiters"></a> <a class="anchor" id="usage.example_1~3A_iterating_over_tokens_using_just_soft_delimiters"></a> <a class="anchor" id="description.usage.example_1~3A_iterating_over_tokens_using_just_soft_delimiters"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.7.1"></a> </code></dd></dl>
<dl class="user"><dt><b>Example 1: Iterating Over Tokens Using Just Soft Delimiters: </b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> <a class="anchor" id="example_2~3A_iterating_over_tokens_using_just_hard_delimiters"></a> <a class="anchor" id="usage.example_2~3A_iterating_over_tokens_using_just_hard_delimiters"></a> <a class="anchor" id="description.usage.example_2~3A_iterating_over_tokens_using_just_hard_delimiters"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.7.2"></a> </code></dd></dl>
<dl class="user"><dt><b>Example 2: Iterating Over Tokens Using Just Hard Delimiters: </b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> <a class="anchor" id="example_3~3A_iterating_over_tokens_using_both_hard_and_soft_delimiters"></a> <a class="anchor" id="usage.example_3~3A_iterating_over_tokens_using_both_hard_and_soft_delimiters"></a> <a class="anchor" id="description.usage.example_3~3A_iterating_over_tokens_using_both_hard_and_soft_delimiters"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.7.3"></a> </code></dd></dl>
<dl class="user"><dt><b>Example 3: Iterating Over Tokens Using Both Hard and Soft Delimiters: </b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> <a class="anchor" id="example_4~3A_using_the_tokenizer_to_access_delimiters_as_well_as_tokens"></a> <a class="anchor" id="usage.example_4~3A_using_the_tokenizer_to_access_delimiters_as_well_as_tokens"></a> <a class="anchor" id="description.usage.example_4~3A_using_the_tokenizer_to_access_delimiters_as_well_as_tokens"></a> <a class="anchor" id="example_4"></a> <a class="anchor" id="usage.example_4"></a> <a class="anchor" id="description.usage.example_4"></a> <a class="anchor" id="3.7.4"></a> </code></dd></dl>
<dl class="user"><dt><b>Example 4: Using the Tokenizer to Access Delimiters As Well As Tokens: </b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> <a class="anchor" id="example_5~3A_parsing_layers_of_different_tokens_using_nested_for_loops"></a> <a class="anchor" id="usage.example_5~3A_parsing_layers_of_different_tokens_using_nested_for_loops"></a> <a class="anchor" id="description.usage.example_5~3A_parsing_layers_of_different_tokens_using_nested_for_loops"></a> <a class="anchor" id="example_5"></a> <a class="anchor" id="usage.example_5"></a> <a class="anchor" id="description.usage.example_5"></a> <a class="anchor" id="3.7.5"></a> </code></dd></dl>
<dl class="user"><dt><b>Example 5: Parsing Layers of Different Tokens Using Nested for Loops: </b></dt><dd><code> </code></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code> </code></dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:38 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
