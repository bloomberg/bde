<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlma_pool Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_pool<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide efficient allocation of memory blocks of uniform size.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlma__pool.html#gaf82242bc279340d94669aec2e2c3f6ff">operator new</a> (bsl::size_t size, BloombergLP::bdlma::Pool &amp;pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlma__pool.html#ga24aa4dd02a2dcb1b66c626c55e7b5fb3">operator delete</a> (void *address, BloombergLP::bdlma::Pool &amp;pool)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Configuration at Construction</a> </li>
<li>
<a href="#3.2">Overloaded Global Operator <code>new</code></a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Using a <code>bdlma::Pool</code> for Efficient Memory Allocation</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide efficient allocation of memory blocks of uniform size. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a> </td><td>memory manager that allocates memory blocks of uniform size  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements a memory pool, <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code>, that allocates and manages maximally-aligned memory blocks of some uniform size specified at construction. A <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code> object maintains an internal linked list of free memory blocks, and dispenses one block for each <code>allocate</code> method invocation. When a memory block is deallocated, it is returned to the free list for potential reuse. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Whenever the linked list of free memory blocks is depleted, the <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code> replenishes the list by first allocating a large, contiguous "chunk" of memory, then splitting the chunk into multiple memory blocks. A chunk and its constituent memory blocks can be depicted visually: <br/>
<br/>
<div class="fragment"><pre class="fragment">     +-----+--- memory blocks of uniform size
     |     |
   ----- ----- ------------
  |     |     |     ...    |
   =====^=====^============

   \___________ __________/
               V
           a <span class="stringliteral">&quot;chunk&quot;</span>
</pre></div><br/>
<br/>
 Note that the size of the allocated chunk is determined by both the growth strategy and maximum blocks per chunk, either of which can be optionally specified at construction (see the "Configuration at Construction" section). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="configuration_at_construction"></a> <a class="anchor" id="description.configuration_at_construction"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Configuration at Construction: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>When creating a <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code>, clients must specify the specific block size managed and dispensed by the pool. Furthermore, clients can optionally configure: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
GROWTH STRATEGY -- geometrically growing chunk size starting from 1 (in terms of the number of memory blocks per chunk), or fixed chunk size. If the growth strategy is not specified, geometric growth is used.  </li>
<li>
MAX BLOCKS PER CHUNK -- the maximum number of memory blocks within a chunk. If the maximum blocks per chunk is not specified, an implementation-defined default value is used.  </li>
<li>
BASIC ALLOCATOR -- the allocator used to supply memory to replenish the internal pool. If not specified, the currently installed default allocator is used (see <code>bslma_default</code>).  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, if geometric growth is used and the maximum blocks per chunk is specified as 30, the chunk size grows geometrically, starting from 1, until the specified maximum blocks per chunk, as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  1, 2, 4, 8, 16, 30, 30, 30 ...
</pre></div><br/>
<br/>
 If constant growth is used, the chunk size is always the specified maximum blocks per chunk (or an implementation-defined value if the maximum blocks per chunk is not specified), for example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  30, 30, 30 ...
</pre></div><br/>
<br/>
 A default-constructed pool has an initial chunk size of 1 (i.e., the number of memory blocks of a given size allocated at once to replenish a pool's memory), and the pool's chunk size grows geometrically until it reaches an implementation-defined maximum, at which it is capped. Finally, unless otherwise specified, all memory comes from the allocator that was the currently installed default allocator at the time the <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code> was created. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="overloaded_global_operator_new"></a> <a class="anchor" id="description.overloaded_global_operator_new"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Overloaded Global Operator new: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component overloads the global <code>operator new</code> to allow convenient syntax for the construction of objects using a <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code>. The <code>new</code> operator supplied in this component takes a <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code> argument indicating the source of the memory. Consider the following use of standard placement <code>new</code> syntax (supplied by <code>bsl_new.h</code>) along with a <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code> to allocate an object of type <code>T</code>. Note that the size of <code>T</code> must be the same or smaller than the <code>blockSize</code> with which the pool is constructed: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> f(<a class="code" href="classbdlma_1_1Pool.html">bdlma::Pool</a> *pool)
  {
      assert(pool-&gt;<a class="code" href="classbdlma_1_1Pool.html#ac1cf97afc00a5f86742900bfa19bcc1a">blockSize</a>() &gt;= <span class="keyword">sizeof</span>(T));

      T *t = <span class="keyword">new</span> (pool-&gt;<a class="code" href="classbdlma_1_1Pool.html#af8ec09fd2baf0d59ebf139e8c670577f">allocate</a>()) T(...);

      <span class="comment">// ...</span>
  }
</pre></div><br/>
<br/>
 This usage style is not exception-safe. If the constructor of <code>T</code> throws an exception, <code>pool-&gt;deallocate</code> is never called. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Supplying an overloaded global <code>operator new</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  ::operator <span class="keyword">new</span>(bsl::size_t size, BloombergLP::bdlma::Pool&amp; pool);
</pre></div><br/>
<br/>
 allows for the following cleaner usage, which does not require the size calculation and guarantees that <code>pool-&gt;deallocate</code> <em>is</em> called in the case of an exception: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> f(<a class="code" href="classbdlma_1_1Pool.html">bdlma::Pool</a> *pool)
  {
      assert(pool-&gt;<a class="code" href="classbdlma_1_1Pool.html#ac1cf97afc00a5f86742900bfa19bcc1a">blockSize</a>() &gt;= <span class="keyword">sizeof</span>(T));

      T *t = <span class="keyword">new</span> (*pool) T(...);

      <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 Also note that the analogous version of operator <code>delete</code> should <em>not</em> be called directly. Instead, this component provides a static template member function <code>deleteObject</code>, parameterized on <code>TYPE</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      pool-&gt;<a class="code" href="classbdlma_1_1Pool.html#a53efea2b4b022fafed196208bd467e46">deleteObject</a>(t);
  }
</pre></div><br/>
<br/>
 The above <code>deleteObject</code> call is equivalent to performing the following: <br/>
<br/>
<div class="fragment"><pre class="fragment">  t-&gt;~TYPE();
  pool-&gt;<a class="code" href="classbdlma_1_1Pool.html#a57e819ddd50e9d26267a36ed2ae2b31a">deallocate</a>(t);
</pre></div><br/>
<br/>
 An overloaded operator <code>delete</code> is supplied solely to allow the compiler to arrange for it to be called in case of an exception. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_a_bdlma~3A~3Apool_for_efficient_memory_allocation"></a> <a class="anchor" id="usage.example_1~3A_using_a_bdlma~3A~3Apool_for_efficient_memory_allocation"></a> <a class="anchor" id="description.usage.example_1~3A_using_a_bdlma~3A~3Apool_for_efficient_memory_allocation"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using a bdlma::Pool for Efficient Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code> can be used by node-based containers (such as lists, trees, and hash tables that hold multiple elements of uniform size) for efficient memory allocation of new elements. The following container template class, <code>my_PooledArray</code>, stores values of (template parameter) <code>TYPE</code> "out-of-place" as nodes in a <code>vector</code> of pointers. Since the size of each node is fixed and known <em>a priori</em>, the class uses a <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code> to allocate memory for the nodes to improve memory allocation efficiency. Note that for simplicity, we assume that <code>TYPE</code> does not require an allocator, and that calls to the destructor of <code>TYPE</code> can be elided. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define the interface of our <code>my_PooledArray</code> template class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_poolarray.h</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>my_PooledArray {
      <span class="comment">// This class implements a container that stores values of (template</span>
      <span class="comment">// parameter) &#39;TYPE&#39; out-of-place.  It is assumed that &#39;TYPE&#39; does not</span>
      <span class="comment">// require an allocator, and that calls to the destructor of &#39;TYPE&#39; can</span>
      <span class="comment">// be elided.</span>

      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;TYPE *&gt;</a> d_array_p;  <span class="comment">// array of pooled elements</span>
      <a class="code" href="classbdlma_1_1Pool.html">bdlma::Pool</a>         d_pool;     <span class="comment">// memory manager for array elements</span>

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      my_PooledArray(<span class="keyword">const</span> my_PooledArray&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my_PooledArray(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a pooled array that stores the &#39;TYPE&#39; element values</span>
          <span class="comment">// &quot;out-of-place&quot;.  Optionally specify a &#39;basicAllocator&#39; used to</span>
          <span class="comment">// supply memory.  If &#39;basicAllocator&#39; is 0, the currently</span>
          <span class="comment">// installed default allocator is used.</span>

      ~my_PooledArray();
          <span class="comment">// Destroy this array and all elements held by it.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> append(<span class="keyword">const</span> TYPE&amp; value);
          <span class="comment">// Append the specified &#39;value&#39; to this array.</span>

      <span class="keywordtype">void</span> removeAll();
          <span class="comment">// Remove all elements from this array.</span>

      <span class="comment">// ACCESSORS</span>
      bsl::size_t length() <span class="keyword">const</span>;
          <span class="comment">// Return the number of elements in this array.</span>

      <span class="keyword">const</span> TYPE&amp; operator[](<span class="keywordtype">int</span> index) <span class="keyword">const</span>;
          <span class="comment">// Return a reference providing non-modifiable access to the value</span>
          <span class="comment">// at the specified &#39;index&#39; in this array.  The behavior is</span>
          <span class="comment">// undefined unless &#39;0 &lt;= index &lt; length()&#39;.</span>
  };
</pre></div><br/>
<br/>
 Next, we provide the implementation of the <code>my_PooledArray</code> methods that are defined <code>inline</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that in the <code>removeAll</code> method, all elements are deallocated by simply invoking the pool's <code>release</code> method. This technique implies significant performance gain when the array contains many elements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_PooledArray&lt;TYPE&gt;::removeAll()
  {
      d_array_p.clear();
      d_pool.<a class="code" href="classbdlma_1_1Pool.html#afd51c71be6e7ab898b79e8a0b61090b0">release</a>();
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  bsl::size_t my_PooledArray&lt;TYPE&gt;::length()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_array_p.size();
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  <span class="keyword">const</span> TYPE&amp; my_PooledArray&lt;TYPE&gt;::operator[](<span class="keywordtype">int</span> index)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      assert(0     &lt;= index);
      assert(index &lt;  static_cast&lt;int&gt;(length()));

      <span class="keywordflow">return</span> *d_array_p[index];
  }
</pre></div><br/>
<br/>
 Next, we provide the implementation of the <code>my_PooledArray</code> methods that are defined in the <code>.cpp</code> file. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the growth strategy and maximum chunk size of the pool defaults to those provided by <code><a class="el" href="classbdlma_1_1Pool.html">bdlma::Pool</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_poolarray.cpp</span>

  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  my_PooledArray&lt;TYPE&gt;::my_PooledArray(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_array_p(basicAllocator)
  , d_pool(sizeof(TYPE), basicAllocator)
  {
  }
</pre></div><br/>
<br/>
 Since all memory is managed by <code>d_pool</code>, we do not have to explicitly invoke <code>deleteObject</code> to reclaim outstanding memory. The destructor of the pool will automatically deallocate all array elements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  my_PooledArray&lt;TYPE&gt;::~my_PooledArray()
  {
      <span class="comment">// Elements are automatically deallocated when &#39;d_pool&#39; is destroyed.</span>
  }
</pre></div><br/>
<br/>
 Finally, note that the overloaded "placement" <code>new</code> is used to allocate new nodes in the <code>append</code> method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> my_PooledArray&lt;TYPE&gt;::append(<span class="keyword">const</span> TYPE&amp; value)
  {
      TYPE *tmp = <span class="keyword">new</span> (d_pool) TYPE(value);
      d_array_p.push_back(tmp);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaf82242bc279340d94669aec2e2c3f6ff"></a><!-- doxytag: member="bdlma_pool.h::operator new" ref="gaf82242bc279340d94669aec2e2c3f6ff" args="(bsl::size_t size, BloombergLP::bdlma::Pool &amp;pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* operator new </td>
          <td>(</td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bdlma::Pool &amp;&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a block of memory of the specified <code>size</code> (in bytes) allocated from the specified <code>pool</code>. The behavior is undefined unless <code>size</code> is the same or smaller than the <code>blockSize</code> with which <code>pool</code> was constructed. Note that an object may allocate additional memory internally, requiring the allocator to be passed in as a constructor argument: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      my_Type *newMyType(<a class="code" href="classbdlma_1_1Pool.html">bdlma::Pool</a> *pool, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
      {
          <span class="keywordflow">return</span> <span class="keyword">new</span> (*pool) my_Type(..., basicAllocator);
      }
</pre></div><p><br/>
<br/>
 Also note that the analogous version of <code>operator delete</code> should not be called directly. Instead, this component provides a static template member function, <code>deleteObject</code>, parameterized by <code>TYPE</code>: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">void</span> deleteMyType(my_Type *t, <a class="code" href="classbdlma_1_1Pool.html">bdlma::Pool</a> *pool)
      {
          pool-&gt;<a class="code" href="classbdlma_1_1Pool.html#a53efea2b4b022fafed196208bd467e46">deleteObject</a>(t);
      }
</pre></div><p><br/>
<br/>
 <code>deleteObject</code> performs the following: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      t-&gt;~my_Type();
      pool-&gt;<a class="code" href="classbdlma_1_1Pool.html#a57e819ddd50e9d26267a36ed2ae2b31a">deallocate</a>(t);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="ga24aa4dd02a2dcb1b66c626c55e7b5fb3"></a><!-- doxytag: member="bdlma_pool.h::operator delete" ref="ga24aa4dd02a2dcb1b66c626c55e7b5fb3" args="(void *address, BloombergLP::bdlma::Pool &amp;pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bdlma::Pool &amp;&nbsp;</td>
          <td class="paramname"> <em>pool</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use the specified <code>pool</code> to deallocate the memory at the specified <code>address</code>. The behavior is undefined unless <code>address</code> is non-zero, was allocated using <code>pool</code>, and has not already been deallocated. Note that this operator is supplied solely to allow the compiler to arrange for it to be called in the case of an exception. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:46 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
