<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Class bdlma::BufferedSequentialAllocator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlma.html">bdlma</a>      </li>
      <li><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlma::BufferedSequentialAllocator Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlma::BufferedSequentialAllocator" --><!-- doxytag: inherits="bdlma::ManagedAllocator" -->
<p><code>#include &lt;<a class="el" href="bdlma__bufferedsequentialallocator_8h_source.html">bdlma_bufferedsequentialallocator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bdlma::BufferedSequentialAllocator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbdlma_1_1BufferedSequentialAllocator.png" usemap="#bdlma::BufferedSequentialAllocator_map" alt=""/>
  <map id="bdlma::BufferedSequentialAllocator_map" name="bdlma::BufferedSequentialAllocator_map">
<area href="classbdlma_1_1ManagedAllocator.html" alt="bdlma::ManagedAllocator" shape="rect" coords="0,56,253,80"/>
<area href="classbslma_1_1Allocator.html" alt="bslma::Allocator" shape="rect" coords="0,0,253,24"/>
<area href="classbdlma_1_1LocalSequentialAllocator.html" alt="bdlma::LocalSequentialAllocator&lt; t_SIZE &gt;" shape="rect" coords="0,168,253,192"/>
</map>
</div>

<p><a href="classbdlma_1_1BufferedSequentialAllocator-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html#a9b37c3db71fa14d87f501c01d66f1279">BufferedSequentialAllocator</a> (char *buffer, int size, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html#ade0dcffe01f5ed6f685816e07da22262">BufferedSequentialAllocator</a> (char *buffer, int size, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html#a60aec4651afe3d45aad1446b9bee006f">BufferedSequentialAllocator</a> (char *buffer, int size, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html#a0488d04149f457ac5f272b4e4d7d19e9">BufferedSequentialAllocator</a> (char *buffer, int size, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html#ad1789ab79c0636d9c47ff2aa0bf0a5a8">BufferedSequentialAllocator</a> (char *buffer, int size, int maxBufferSize, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html#a5cd78258579742f4d0774e4549aa13e8">BufferedSequentialAllocator</a> (char *buffer, int size, int maxBufferSize, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html#a1049a84eaade7254a02062cdfb278d8c">BufferedSequentialAllocator</a> (char *buffer, int size, int maxBufferSize, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html#ab052d01bbfc5d8fda30c9e17374de2e1">BufferedSequentialAllocator</a> (char *buffer, int size, int maxBufferSize, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html#ab6afea4e434b40d8ae21285ff87fafe5">~BufferedSequentialAllocator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html#a1e3f353cc3248132d18c8b7e5cef9376">allocate</a> (<a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a> size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html#a23ce15c3ede673b6c1da54850c6899b0">deallocate</a> (void *address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html#a4669495cf776abdaee087303e07df7bb">release</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a0e51fc2d107684523cc66bf65293dc37">deleteObject</a> (const TYPE *object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#abeccfe6cfd8205faf528a8e12f97aebe">deleteObjectRaw</a> (const TYPE *object)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements the <code><a class="el" href="classbdlma_1_1ManagedAllocator.html">ManagedAllocator</a></code> protocol to provide a fast allocator that dispenses heterogeneous blocks of memory (of varying, user-specified sizes) from an external buffer whose address and size (in bytes) are supplied at construction. If an allocation request exceeds the remaining free memory space in the external buffer, memory will be supplied by an (optional) allocator also supplied at construction; if no allocator is supplied, the currently installed default allocator is used. This class is <em>exception</em> <em>neutral</em>: If memory cannot be allocated, the behavior is defined by the (optional) allocator supplied at construction. Note that in no case will the buffered sequential allocator attempt to deallocate the external buffer. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a07cd3ddf3fba145a0469a4e867047287"></a><!-- doxytag: member="bdlma::BufferedSequentialAllocator::size_type" ref="a07cd3ddf3fba145a0469a4e867047287" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a> <a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">bslma::Allocator::size_type</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9b37c3db71fa14d87f501c01d66f1279"></a><!-- doxytag: member="bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator" ref="a9b37c3db71fa14d87f501c01d66f1279" args="(char *buffer, int size, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ade0dcffe01f5ed6f685816e07da22262"></a><!-- doxytag: member="bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator" ref="ade0dcffe01f5ed6f685816e07da22262" args="(char *buffer, int size, bsls::BlockGrowth::Strategy growthStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a60aec4651afe3d45aad1446b9bee006f"></a><!-- doxytag: member="bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator" ref="a60aec4651afe3d45aad1446b9bee006f" args="(char *buffer, int size, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0488d04149f457ac5f272b4e4d7d19e9"></a><!-- doxytag: member="bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator" ref="a0488d04149f457ac5f272b4e4d7d19e9" args="(char *buffer, int size, bsls::BlockGrowth::Strategy growthStrategy, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a buffered sequential allocator for allocating memory blocks from the specified external <code>buffer</code> having the specified <code>size</code> (in bytes). Optionally specify a <code>growthStrategy</code> used to control buffer growth. If a <code>growthStrategy</code> is not specified, geometric growth is used. Optionally specify an <code>alignmentStrategy</code> used to align allocated memory blocks. If an <code>alignmentStrategy</code> is not specified, natural alignment is used. Optionally specify a <code>basicAllocator</code> used to supply memory should the capacity of <code>buffer</code> be exhausted. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 &lt; size</code>, and <code>buffer</code> has at least <code>size</code> bytes. Note that, due to alignment effects, it is possible that not all <code>size</code> bytes of memory in <code>buffer</code> can be used for allocation. Also note that no limit is imposed on the size of the internal buffers when geometric growth is used. Also note that when constant growth is used, the size of the internal buffers will always be the same as <code>size</code>. </p>

</div>
</div>
<a class="anchor" id="ad1789ab79c0636d9c47ff2aa0bf0a5a8"></a><!-- doxytag: member="bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator" ref="ad1789ab79c0636d9c47ff2aa0bf0a5a8" args="(char *buffer, int size, int maxBufferSize, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5cd78258579742f4d0774e4549aa13e8"></a><!-- doxytag: member="bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator" ref="a5cd78258579742f4d0774e4549aa13e8" args="(char *buffer, int size, int maxBufferSize, bsls::BlockGrowth::Strategy growthStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1049a84eaade7254a02062cdfb278d8c"></a><!-- doxytag: member="bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator" ref="a1049a84eaade7254a02062cdfb278d8c" args="(char *buffer, int size, int maxBufferSize, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab052d01bbfc5d8fda30c9e17374de2e1"></a><!-- doxytag: member="bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator" ref="ab052d01bbfc5d8fda30c9e17374de2e1" args="(char *buffer, int size, int maxBufferSize, bsls::BlockGrowth::Strategy growthStrategy, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferedSequentialAllocator::BufferedSequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a buffered sequential allocator for allocating memory blocks from the specified external <code>buffer</code> having the specified <code>size</code> (in bytes), or from an internal buffer (after the external <code>buffer</code> is exhausted) where the buffer growth is limited to the specified <code>maxBufferSize</code> (in bytes). Optionally specify a <code>growthStrategy</code> used to control buffer growth. If a <code>growthStrategy</code> is not specified, geometric growth is used. Optionally specify an <code>alignmentStrategy</code> used to align allocated memory blocks. If an <code>alignmentStrategy</code> is not specified, natural alignment is used. Optionally specify a <code>basicAllocator</code> used to supply memory should the capacity of <code>buffer</code> be exhausted. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 &lt; size</code>, <code>size &lt;= maxBufferSize</code>, and <code>buffer</code> has at least <code>size</code> bytes. Note that, due to alignment effects, it is possible that not all <code>size</code> bytes of memory in <code>buffer</code> can be used for allocation. Also note that when constant growth is used, the size of the internal buffers will always be the same as <code>size</code>. </p>

</div>
</div>
<a class="anchor" id="ab6afea4e434b40d8ae21285ff87fafe5"></a><!-- doxytag: member="bdlma::BufferedSequentialAllocator::~BufferedSequentialAllocator" ref="ab6afea4e434b40d8ae21285ff87fafe5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bdlma::BufferedSequentialAllocator::~BufferedSequentialAllocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this buffered sequential allocator. All memory allocated from this allocator is released. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1e3f353cc3248132d18c8b7e5cef9376"></a><!-- doxytag: member="bdlma::BufferedSequentialAllocator::allocate" ref="a1e3f353cc3248132d18c8b7e5cef9376" args="(size_type size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* bdlma::BufferedSequentialAllocator::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a contiguous block of memory of the specified <code>size</code> (in bytes) according to the alignment strategy specified at construction. If <code>size</code> is 0, no memory is allocated and 0 is returned. If the allocation request exceeds the remaining free memory space in the external buffer supplied at construction, use memory obtained from the allocator supplied at construction. </p>

<p>Implements <a class="el" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">bslma::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a23ce15c3ede673b6c1da54850c6899b0"></a><!-- doxytag: member="bdlma::BufferedSequentialAllocator::deallocate" ref="a23ce15c3ede673b6c1da54850c6899b0" args="(void *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bdlma::BufferedSequentialAllocator::deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method has no effect on the memory block at the specified <code>address</code> as all memory allocated by this allocator is managed. The behavior is undefined unless <code>address</code> is 0, or was allocated by this allocator and has not already been deallocated. </p>

<p>Implements <a class="el" href="classbslma_1_1Allocator.html#a5ff7b0468394849d6824be024f272968">bslma::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a4669495cf776abdaee087303e07df7bb"></a><!-- doxytag: member="bdlma::BufferedSequentialAllocator::release" ref="a4669495cf776abdaee087303e07df7bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bdlma::BufferedSequentialAllocator::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release all memory currently allocated through this allocator. This method deallocates all memory (if any) allocated with the allocator provided at construction, and makes the memory from the entire external buffer supplied at construction available for subsequent allocations, but has no effect on the contents of the buffer. Note that this allocator is reset to its initial state by this method. </p>

<p>Implements <a class="el" href="classbdlma_1_1ManagedAllocator.html#ad86110a47aaf5e53356c86b5fd240bfb">bdlma::ManagedAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="a0e51fc2d107684523cc66bf65293dc37"></a><!-- doxytag: member="bdlma::BufferedSequentialAllocator::deleteObject" ref="a0e51fc2d107684523cc66bf65293dc37" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslma::Allocator::deleteObject </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> based on its dynamic type and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is a null pointer. The behavior is undefined unless <code>object</code>, when cast appropriately to <code>void *</code>, was allocated using this allocator and has not already been deallocated. Note that <code>dynamic_cast&lt;void *&gt;(object)</code> is applied if <code>TYPE</code> is polymorphic, and <code>static_cast&lt;void *&gt;(object)</code> is applied otherwise. </p>

</div>
</div>
<a class="anchor" id="abeccfe6cfd8205faf528a8e12f97aebe"></a><!-- doxytag: member="bdlma::BufferedSequentialAllocator::deleteObjectRaw" ref="abeccfe6cfd8205faf528a8e12f97aebe" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslma::Allocator::deleteObjectRaw </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is a null pointer. The behavior is undefined unless <code>object</code> was allocated using this allocator, is <b>not</b> a secondary base class pointer -- i.e., the address is (numerically) the same as when it was originally dispensed by this allocator, and has not already been deallocated. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlma__bufferedsequentialallocator_8h_source.html">bdlma_bufferedsequentialallocator.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:26 for BDE Release 2.23.1 Open-Source by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
