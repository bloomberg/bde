<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlmt_multiqueuethreadpool Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlmt_multiqueuethreadpool<br/>
<small>
[<a class="el" href="group__bdlmt.html">Package bdlmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a pool of queues, each processed serially by a thread pool.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslmt.html">bslmt</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlmt.html">bdlmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: A Word Search Application</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a pool of queues, each processed serially by a thread pool. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html">bdlmt::MultiQueueThreadPool</a> </td><td>multi-threaded, serial processing of queues  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlmt__threadpool.html" title="Provide portable implementation for a dynamic pool of threads.">Component bdlmt_threadpool</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a dynamic, configurable pool of queues, each of which is processed by a thread in a thread pool, such that elements on a given queue are processed serially, regardless of which thread is processing the queue at a given time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html">bdlmt::MultiQueueThreadPool</a></code> allows clients to create and delete queues, and to enqueue "jobs" (represented as client-specified functors) to specific queues. Queue processing is implemented on top of a <code><a class="el" href="classbdlmt_1_1ThreadPool.html">bdlmt::ThreadPool</a></code> by enqueuing a per-queue functor to the thread pool. Each functor dequeues the next item from its associated queue, processes it, and re-enqueues itself to the thread pool. Since there is only one representative functor per queue, each queue is guaranteed to be processed serially by the thread pool. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition to the ability to create and delete queues, clients are able to tune the underlying thread pool in accordance with the <code><a class="el" href="classbdlmt_1_1ThreadPool.html">bdlmt::ThreadPool</a></code> documentation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html">bdlmt::MultiQueueThreadPool</a></code> class is <em>thread-aware</em>, but not *fully thread-safe*. The function-level documentation identifies methods (i.e., the <code>reset</code> method) that cannot be safely used by multiple threads. This class is also <em>thread-enabled</em> (i.e., the class does not function correctly in a non-multi-threading environment). See <code>bsldoc_glossary</code> for complete definitions of <em>thread-aware</em>, <em>fully thread-safe</em>, and <em>thread-enabled</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>NOTICE: This usage example relies on absolute paths that may not exist. The example should be rephrased to work on an array of strings instead of a file, or perhaps re-written entirely. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_a_word_search_application"></a> <a class="anchor" id="usage.example_1~3A_a_word_search_application"></a> <a class="anchor" id="description.usage.example_1~3A_a_word_search_application"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: A Word Search Application: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example illustrates the use of a <code><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html">bdlmt::MultiQueueThreadPool</a></code> in a word search application called <code>fastSearch</code>. <code>fastSearch</code> searches a list of files for a list of words, and returns the set of files which contain all of the specified words. <code><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html">bdlmt::MultiQueueThreadPool</a></code> is used to provide concurrent processing of files, and to simplify the collection of results by serializing access to result sets which are maintained for each word. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we present a class used to manage a word, and the set of files which contain that word: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_SearchProfile {
      <span class="comment">// This class defines a search profile consisting of a word</span>
      <span class="comment">// and a set of files (given by name) that contain the word.</span>
      <span class="comment">// Here, &quot;word&quot; is defined as any string of characters.</span>

      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>           d_word;     <span class="comment">// word to search for</span>
      <a class="code" href="classbsl_1_1set.html">bsl::set&lt;bsl::string&gt;</a> d_fileSet;  <span class="comment">// set of matching files</span>

    <span class="keyword">private</span>:
      <span class="comment">// not implemented</span>
      my_SearchProfile(<span class="keyword">const</span> my_SearchProfile&amp;);
      my_SearchProfile&amp; operator=(<span class="keyword">const</span> my_SearchProfile&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_SearchProfile(<span class="keyword">const</span> <span class="keywordtype">char</span>       *word,
                       <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;my_SearchProfile&#39; with the specified &#39;word&#39;.</span>
          <span class="comment">// Optionally specify a &#39;basicAllocator&#39; used to supply memory.</span>
          <span class="comment">// If &#39;basicAllocator&#39; is 0, the default memory allocator is used.</span>

      ~my_SearchProfile();
          <span class="comment">// Destroy this search profile.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> insert(<span class="keyword">const</span> <span class="keywordtype">char</span> *file);
          <span class="comment">// Insert the specified &#39;file&#39; into the file set maintained</span>
          <span class="comment">// by this search profile.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">bool</span> isMatch(<span class="keyword">const</span> <span class="keywordtype">char</span> *file) <span class="keyword">const</span>;
          <span class="comment">// Return &#39;true&#39; if the specified &#39;file&#39; matches this search</span>
          <span class="comment">// profile.</span>

      <span class="keyword">const</span> <a class="code" href="classbsl_1_1set.html">bsl::set&lt;bsl::string&gt;</a>&amp; fileSet() <span class="keyword">const</span>;
          <span class="comment">// Return a reference to the non-modifiable file set maintained</span>
          <span class="comment">// by this search profile.</span>

      <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; word() <span class="keyword">const</span>;
          <span class="comment">// Return a reference to the non-modifiable word maintained</span>
          <span class="comment">// by this search profile.</span>
  };
</pre></div><br/>
<br/>
 And the implementation: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CONSTRUCTORS</span>
  my_SearchProfile::my_SearchProfile(
          <span class="keyword">const</span> <span class="keywordtype">char</span>       *word,
          <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_word(basicAllocator)
  , d_fileSet(bsl::less&lt;bsl::string&gt;(), basicAllocator)
  {
      assert(word);

      d_word.assign(word);
  }

  my_SearchProfile::~my_SearchProfile()
  {
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_SearchProfile::insert(<span class="keyword">const</span> <span class="keywordtype">char</span> *file)
  {
      assert(file);

      d_fileSet.insert(file);
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keywordtype">bool</span> my_SearchProfile::isMatch(<span class="keyword">const</span> <span class="keywordtype">char</span> *file)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      assert(file);

      <span class="keywordtype">bool</span>          found = <span class="keyword">false</span>;
      bsl::ifstream ifs(file);
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>   line;
      <span class="keywordflow">while</span> (<a class="code" href="group__bslstl__string.html#ga541ba270c84fdb45c5df71a668aa5d9d">bsl::getline</a>(ifs, line)) {
          <span class="keywordflow">if</span> (<a class="code" href="group__bslstl__string.html#gaf79bc85dc723320ef0f88c6c86946d3c">bsl::string::npos</a> != line.<a class="code" href="group__bslstl__string.html#gaeb4b6eb2f6f3bab5b95b77bf468e22e5">find</a>(d_word)) {
              found = <span class="keyword">true</span>;
              <span class="keywordflow">break</span>;
          }
      }
      ifs.close();
      <span class="keywordflow">return</span> found;
  }

  <span class="keyword">inline</span>
  <span class="keyword">const</span> <a class="code" href="classbsl_1_1set.html">bsl::set&lt;bsl::string&gt;</a>&amp; my_SearchProfile::fileSet()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_fileSet;
  }

  <span class="keyword">inline</span>
  <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; my_SearchProfile::word()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_word;
  }
</pre></div><br/>
<br/>
 Next, we define a helper function to perform a search of a word in a particular file. The function is parameterized by a search profile and a file name. If the specified file name matches the profile, it is inserted into the profile's file list. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> my_SearchCb(my_SearchProfile* profile, <span class="keyword">const</span> <span class="keywordtype">char</span> *file)
  {
      <span class="comment">// Insert the specified &#39;file&#39; to the file set of the specified</span>
      <span class="comment">// search &#39;profile&#39; if &#39;file&#39; matches the &#39;profile&#39;.</span>

      assert(profile);
      assert(file);

      <span class="keywordflow">if</span> (profile-&gt;isMatch(file)) {
          profile-&gt;insert(file);
      }
  }
</pre></div><br/>
<br/>
 Lastly, we present the front end to the search application: <code>fastSearch</code>. <code>fastSearch</code> is parameterized by a list of words to search for, a list of files to search in, and a set which is populated with the search results. <code>fastSearch</code> instantiates a <code><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html">bdlmt::MultiQueueThreadPool</a></code>, and creates a queue for each word. It then associates each queue with a search profile based on a word in the word list. Then, it enqueues a job to each queue for each file in the file list that tries to match the file to each search profile. Lastly, <code>fastSearch</code> collects the results, which is the set intersection of each file set maintained by the individual search profiles. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> fastSearch(<span class="keyword">const</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a>&amp;  wordList,
                  <span class="keyword">const</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a>&amp;  fileList,
                  <a class="code" href="classbsl_1_1set.html">bsl::set&lt;bsl::string&gt;</a>&amp;           resultSet,
                  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>                *basicAllocator = 0)
  {
      <span class="comment">// Return the set of files, specified by &#39;fileList&#39;, containing</span>
      <span class="comment">// every word in the specified &#39;wordList&#39;, in the specified</span>
      <span class="comment">// &#39;resultSet&#39;.</span>

      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a> ListType;
          <span class="comment">// This type is defined for notational convenience when iterating</span>
          <span class="comment">// over &#39;wordList&#39; or &#39;fileList&#39;.</span>

      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1pair.html">bsl::pair&lt;int, my_SearchProfile*&gt;</a> RegistryValue;
          <span class="comment">// This type is defined for notational convenience.  The first</span>
          <span class="comment">// parameter specifies a queue ID.  The second parameter specifies</span>
          <span class="comment">// an associated search profile.</span>

      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1map.html">bsl::map&lt;bsl::string, RegistryValue&gt;</a> RegistryType;
          <span class="comment">// This type is defined for notational convenience.  The first</span>
          <span class="comment">// parameter specifies a word.  The second parameter specifies a</span>
          <span class="comment">// tuple containing a queue ID, and an associated search profile</span>
          <span class="comment">// containing the specified word.</span>

      <span class="keyword">enum</span> {
          <span class="comment">// thread pool configuration</span>
          MIN_THREADS = 4,
          MAX_THREADS = 20,
          MAX_IDLE    = 100  <span class="comment">// use a very short idle time since new jobs</span>
                             <span class="comment">// arrive only at startup</span>
      };
      <a class="code" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a>           defaultAttrs;
      <a class="code" href="classbdlmt_1_1MultiQueueThreadPool.html">bdlmt::MultiQueueThreadPool</a> pool(defaultAttrs,
                                     MIN_THREADS, MAX_THREADS, MAX_IDLE,
                                     basicAllocator);
      RegistryType profileRegistry(bsl::less&lt;bsl::string&gt;(), basicAllocator);

      <span class="comment">// Start the pool, enabling queue creation and processing.</span>
      pool.start();

      <span class="comment">// Create a queue and a search profile associated with each word in</span>
      <span class="comment">// &#39;wordList&#39;.</span>

      <span class="keywordflow">for</span> (ListType::const_iterator it = wordList.<a class="code" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a>();
           it != wordList.<a class="code" href="group__bslstl__vector.html#ga7eb9edf13eb71d39489477702fa09671">end</a>(); ++it)
      {
          <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator =
                                   <a class="code" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a>(basicAllocator);

          <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; word = *it;
          <span class="keywordtype">int</span>                <span class="keywordtype">id</span> = pool.createQueue();
          LOOP_ASSERT(word, 0 != <span class="keywordtype">id</span>);
          my_SearchProfile *profile = <span class="keyword">new</span> (*allocator)
                                               my_SearchProfile(word.<a class="code" href="group__bslstl__string.html#gacef38ff51dcfc556fa13dda42a2665df">c_str</a>(),
                                                                allocator);

          <a class="code" href="classbslma_1_1RawDeleterProctor.html">bslma::RawDeleterProctor&lt;my_SearchProfile, bslma::Allocator&gt;</a>
                                                 deleter(profile, allocator);

          profileRegistry[word] = bsl::make_pair(<span class="keywordtype">id</span>, profile);
          deleter.release();
      }

      <span class="comment">// Enqueue a job which tries to match each file in &#39;fileList&#39; with each</span>
      <span class="comment">// search profile.</span>

      <span class="keywordflow">for</span> (ListType::const_iterator it = fileList.<a class="code" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a>();
           it != fileList.<a class="code" href="group__bslstl__vector.html#ga7eb9edf13eb71d39489477702fa09671">end</a>(); ++it)
      {
          <span class="keywordflow">for</span> (ListType::const_iterator jt = wordList.<a class="code" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a>();
               jt != wordList.<a class="code" href="group__bslstl__vector.html#ga7eb9edf13eb71d39489477702fa09671">end</a>(); ++jt)
          {
              <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;        file = *it;
              <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;        word = *jt;
              RegistryValue&amp;            rv   = profileRegistry[word];
              bsl::function&lt;void()&gt; job  =
                 <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;my_SearchCb, rv.second, file.<a class="code" href="group__bslstl__string.html#gacef38ff51dcfc556fa13dda42a2665df">c_str</a>());
              <span class="keywordtype">int</span> rc = pool.enqueueJob(rv.first, job);
              LOOP_ASSERT(word, 0 == rc);
          }
      }

      <span class="comment">// Stop the pool, and wait while enqueued jobs are processed.</span>
      pool.stop();

      <span class="comment">// Construct the &#39;resultSet&#39; as the intersection of file sets</span>
      <span class="comment">// collected in each search profile.</span>

      resultSet.<a class="code" href="group__bslstl__set.html#gac4147796e5d1fdda60e5646c4c114913">insert</a>(fileList.<a class="code" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a>(), fileList.<a class="code" href="group__bslstl__vector.html#ga7eb9edf13eb71d39489477702fa09671">end</a>());
      <span class="keywordflow">for</span> (RegistryType::iterator it = profileRegistry.begin();
           it != profileRegistry.end(); ++it)
      {
          my_SearchProfile *profile = it-&gt;second.second;
          <span class="keyword">const</span> <a class="code" href="classbsl_1_1set.html">bsl::set&lt;bsl::string&gt;</a>&amp; fileSet = profile-&gt;fileSet();
          <a class="code" href="classbsl_1_1set.html">bsl::set&lt;bsl::string&gt;</a> tmpSet;
          bsl::set_intersection(fileSet.<a class="code" href="group__bslstl__set.html#ga59d32154f54376aa7cdb4c086e211a85">begin</a>(),   fileSet.<a class="code" href="group__bslstl__set.html#gab180d3123dea011341881e0b40c3d3e5">end</a>(),
                                resultSet.<a class="code" href="group__bslstl__set.html#ga59d32154f54376aa7cdb4c086e211a85">begin</a>(), resultSet.<a class="code" href="group__bslstl__set.html#gab180d3123dea011341881e0b40c3d3e5">end</a>(),
                                bsl::inserter(tmpSet, tmpSet.<a class="code" href="group__bslstl__set.html#ga59d32154f54376aa7cdb4c086e211a85">begin</a>()));
          resultSet = tmpSet;
          <a class="code" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a>(basicAllocator)-&gt;deleteObjectRaw(
                                                                    profile);
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:46 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
