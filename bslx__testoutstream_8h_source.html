<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslx_testoutstream.h                                               -*-C++-*-
#ifndef INCLUDED_BSLX_TESTOUTSTREAM
#define INCLUDED_BSLX_TESTOUTSTREAM

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Enable externalization of fundamental types with identification.
//
//@CLASSES:
//  bslx::TestOutStream: byte-array-based output stream for fundamental types
//
//@SEE_ALSO: bslx_testinstream, bslx_byteoutstream
//
//@DESCRIPTION: This component implements a byte-array-based output stream
// class, &#39;bslx::TestOutStream&#39;, that provides platform-independent output
// methods (&quot;externalization&quot;) on values, and arrays of values, of fundamental
// types, and on &#39;bsl::string&#39;.  This component also externalizes information
// to the stream that can be used by the reader of the stream to verify, for
// these types, that the type of data requested from the input stream matches
// what was written by this output stream.  This component is meant for testing
// only.
//
// This component is intended to be used in conjunction with the
// &#39;bslx_testinstream&#39; &quot;unexternalization&quot; component.  Each output method of
// &#39;bslx::TestOutStream&#39; writes a value or a homogeneous array of values to an
// internally managed buffer.  The values are formatted to be readable by the
// corresponding &#39;bslx::TestInStream&#39; method.  In general, the user cannot rely
// on any other mechanism to read data written by &#39;bslx::TestOutStream&#39; unless
// that mechanism explicitly states its ability to do so.
//
// The supported types and required content are listed in the &#39;bslx&#39;
// package-level documentation under &quot;Supported Types&quot;.
//
// Note that the values are stored in big-endian format (i.e., network byte
// order).
//
// Note that output streams can be *invalidated* explicitly and queried for
// *validity*.  Writing to an initially invalid stream has no effect.  Whenever
// an output operation fails, the stream should be invalidated explicitly.
//
///Versioning
///----------
// BDEX provides two concepts that support versioning the BDEX serialization
// format of a type: &#39;version&#39; and &#39;versionSelector&#39;.  A &#39;version&#39; is a 1-based
// integer indicating one of the supported formats (e.g., format 1, format 2,
// etc.).  A &#39;versionSelector&#39; is a value that is mapped to a &#39;version&#39; for a
// type by the type&#39;s implementation of &#39;maxSupportedBdexVersion&#39;.
//
// Selecting a value for a &#39;versionSelector&#39; is required at two different
// points: (1) when implementing a new &#39;version&#39; format within the
// &#39;bdexStreamIn&#39; and &#39;bdexStreamOut&#39; methods of a type, and (2) when
// implementing code that constructs a BDEX &#39;OutStream&#39;.  In both cases, the
// value should be a *compile*-time-selected value.
//
// When a new &#39;version&#39; format is implemented within the &#39;bdexStreamIn&#39; and
// &#39;bdexStreamOut&#39; methods of a type, a new mapping in
// &#39;maxSupportedBdexVersion&#39; should be created to expose this new &#39;version&#39;
// with a &#39;versionSelector&#39;.  A simple - and the recommended - approach is to
// use a value having the pattern &quot;YYYYMMDD&quot;, where &quot;YYYYMMDD&quot; corresponds to
// the &quot;go-live&quot; date of the corresponding &#39;version&#39; format.
//
// When constructing an &#39;OutStream&#39;, a simple approach is to use the current
// date as a *compile*-time constant value.  In combination with the
// recommended selection of &#39;versionSelector&#39; values for
// &#39;maxSupportedBdexVersion&#39;, this will result in consistent and predictable
// behavior while externalizing types.  Note that this recommendation is chosen
// for its simplicity: to ensure the largest possible audience for an
// externalized representation, clients can select the minimum date value that
// will result in the desired version of all types externalized with
// &#39;operator&lt;&lt;&#39; being selected.
//
// See the &#39;bslx&#39; package-level documentation for more detailed information
// about versioning.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Basic Externalization
/// - - - - - - - - - - - - - - - -
// A &#39;bslx::TestOutStream&#39; can be used to externalize values in a
// platform-neutral way.  Writing out fundamental C++ types and &#39;bsl::string&#39;
// requires no additional work on the part of the client; the client can simply
// use the stream directly.  The following code serializes a few representative
// values using a &#39;bslx::TestOutStream&#39;, compares the contents of this stream
// to the expected value, and then writes the contents of this stream&#39;s buffer
// to &#39;stdout&#39;.
//
// First, we create a &#39;bslx::TestOutStream&#39; with an arbitrary value for its
// &#39;versionSelector&#39; and externalize some values:
//..
//  bslx::TestOutStream outStream(20131127);
//  outStream.putInt32(1);
//  outStream.putInt32(2);
//  outStream.putInt8(&#39;c&#39;);
//  outStream.putString(bsl::string(&quot;hello&quot;));
//..
// Then, we compare the contents of the stream to the expected value:
//..
//  const char  *theChars = outStream.data();
//  bsl::size_t  length   = outStream.length();
//  assert(24 == length);
//  assert( 0 == bsl::memcmp(theChars,
//                           &quot;\xE6\x00\x00\x00\x01\xE6\x00\x00\x00\x02\xE0&quot;
//                                      &quot;c\xE0\x05\xE1\x00\x00\x00\x05&quot;&quot;hello&quot;,
//                           length));
//..
// Finally, we print the stream&#39;s contents to &#39;bsl::cout&#39;.
//..
//  for (bsl::size_t i = 0; i &lt; length; ++i) {
//      if(bsl::isalnum(static_cast&lt;unsigned char&gt;(theChars[i]))) {
//          bsl::cout &lt;&lt; &quot;nextByte (char): &quot; &lt;&lt; theChars[i] &lt;&lt; bsl::endl;
//      }
//      else {
//          bsl::cout &lt;&lt; &quot;nextByte (int): &quot;
//                    &lt;&lt; static_cast&lt;int&gt;(theChars[i])
//                    &lt;&lt; bsl::endl;
//      }
//  }
//..
// Executing the above code results in the following output:
//..
//  nextByte (int): -26
//  nextByte (int): 0
//  nextByte (int): 0
//  nextByte (int): 0
//  nextByte (int): 1
//  nextByte (int): -26
//  nextByte (int): 0
//  nextByte (int): 0
//  nextByte (int): 0
//  nextByte (int): 2
//  nextByte (int): -32
//  nextByte (char): c
//  nextByte (int): -32
//  nextByte (int): 5
//  nextByte (int): -31
//  nextByte (char): h
//  nextByte (char): e
//  nextByte (char): l
//  nextByte (char): l
//  nextByte (char): o
//..
// Note the negative numeric values indicate the &quot;type&quot; of the data that
// follows (see &#39;bslx_typecode&#39;).
//
// See the &#39;bslx_testinstream&#39; component usage example for a more practical
// example of using this test output stream.

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLX_BYTEOUTSTREAM
#include &lt;bslx_byteoutstream.h&gt;
#endif

#ifndef INCLUDED_BSLX_OUTSTREAMFUNCTIONS
#include &lt;bslx_outstreamfunctions.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDDEF
#include &lt;bsl_cstddef.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

namespace BloombergLP {

namespace bslma { class Allocator; }

namespace bslx {

                         // ===================
                         // class TestOutStream
                         // ===================

class TestOutStream {
    // This class implements output methods to externalize fundamental types
    // and their associated type identification data.  It stores the
    // accumulated result in network byte order.  See the &#39;bslx&#39; package-level
    // documentation for the definition of the BDEX &#39;OutStream&#39; protocol.

    // DATA
    ByteOutStream d_imp;                  // byte out stream implementation

    bool          d_makeNextInvalidFlag;  // if &#39;true&#39;, next &quot;put&quot; operation
                                          // outputs the invalid data indicator
                                          // and resets this flag to &#39;false&#39;

    // FRIENDS
    friend bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;, const TestOutStream&amp;);

    // NOT IMPLEMENTED
    TestOutStream(const TestOutStream&amp;);
    TestOutStream&amp; operator=(const TestOutStream&amp;);

  public:
    // CREATORS
    explicit TestOutStream(int               versionSelector,
                           bslma::Allocator *basicAllocator = 0);
        // Create an empty output byte stream that will use the specified
        // (*compile*-time-defined) &#39;versionSelector&#39; as needed (see
        // {Versioning}).  Optionally specify a &#39;basicAllocator&#39; used to supply
        // memory.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.  Note that the &#39;versionSelector&#39; is expected to
        // be formatted as &quot;YYYYMMDD&quot;, a date representation.

    TestOutStream(int               versionSelector,
                  bsl::size_t       initialCapacity,
                  bslma::Allocator *basicAllocator = 0);
        // Create an empty output byte stream having an initial buffer capacity
        // of at least the specified &#39;initialCapacity&#39; (in bytes) and that will
        // use the specified (*compile*-time-defined) &#39;versionSelector&#39; as
        // needed (see {Versioning}).  Optionally specify a &#39;basicAllocator&#39;
        // used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently
        // installed default allocator is used.  Note that the
        // &#39;versionSelector&#39; is expected to be formatted as &quot;YYYYMMDD&quot;, a date
        // representation.

    ~TestOutStream();
        // Destroy this object.

    // MANIPULATORS
    void invalidate();
        // Put this output stream in an invalid state.  This function has no
        // effect if this stream is already invalid.

    void makeNextInvalid();
        // Make the next output operation externalize the invalid data
        // indicator, as opposed to the actual type indicator, to this output
        // stream; the data associated with the next output operation is still
        // externalized.  Note that the invalid data indicator can be detected
        // by a corresponding &#39;TestInStream&#39; object.

    TestOutStream&amp; putLength(int length);
        // If the specified &#39;length&#39; is less than 128, write to this stream the
        // one-byte type indicator for a one-byte integer and the one-byte
        // integer comprised of the least-significant one byte of the &#39;length&#39;;
        // otherwise, write to this stream the one-byte type indicator for a
        // four-byte integer and the four-byte, two&#39;s complement integer (in
        // network byte order) comprised of the least-significant four bytes of
        // the &#39;length&#39; (in host byte order) with the most-significant bit set.
        // Return a reference to this stream.  If this stream is initially
        // invalid, this operation has no effect.  If the next output operation
        // has been set to be marked invalid (see &#39;makeNextInvalid&#39;), reset
        // this marking and emit the invalid indicator instead of the type
        // indicator.  The behavior is undefined unless &#39;0 &lt;= length&#39;.

    TestOutStream&amp; putVersion(int version);
        // Write to this stream the one-byte type indicator for a one-byte
        // unsigned integer and the one-byte, two&#39;s complement unsigned integer
        // comprised of the least-significant one byte of the specified
        // &#39;version&#39;, and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.

    void reserveCapacity(bsl::size_t newCapacity);
        // Set the internal buffer size of this stream to be at least the
        // specified &#39;newCapacity&#39; (in bytes).

    void reset();
        // Remove all content in this stream and validate this stream if it is
        // currently invalid.

                      // *** scalar integer values ***

    TestOutStream&amp; putInt64(bsls::Types::Int64 value);
        // Write to this stream the one-byte type indicator for an eight-byte
        // integer and the eight-byte, two&#39;s complement integer (in network
        // byte order) comprised of the least-significant eight bytes of the
        // specified &#39;value&#39; (in host byte order), and return a reference to
        // this stream.  If this stream is initially invalid, this operation
        // has no effect.  If the next output operation has been set to be
        // marked invalid (see &#39;makeNextInvalid&#39;), reset this marking and emit
        // the invalid indicator instead of the type indicator.

    TestOutStream&amp; putUint64(bsls::Types::Uint64 value);
        // Write to this stream the one-byte type indicator for an eight-byte
        // unsigned integer and the eight-byte, two&#39;s complement unsigned
        // integer (in network byte order) comprised of the least-significant
        // eight bytes of the specified &#39;value&#39; (in host byte order), and
        // return a reference to this stream.  If this stream is initially
        // invalid, this operation has no effect.  If the next output operation
        // has been set to be marked invalid (see &#39;makeNextInvalid&#39;), reset
        // this marking and emit the invalid indicator instead of the type
        // indicator.

    TestOutStream&amp; putInt56(bsls::Types::Int64 value);
        // Write to this stream the one-byte type indicator for a seven-byte
        // integer and the seven-byte, two&#39;s complement integer (in network
        // byte order) comprised of the least-significant seven bytes of the
        // specified &#39;value&#39; (in host byte order), and return a reference to
        // this stream.  If this stream is initially invalid, this operation
        // has no effect.  If the next output operation has been set to be
        // marked invalid (see &#39;makeNextInvalid&#39;), reset this marking and emit
        // the invalid indicator instead of the type indicator.

    TestOutStream&amp; putUint56(bsls::Types::Uint64 value);
        // Write to this stream the one-byte type indicator for a seven-byte
        // unsigned integer and the seven-byte, two&#39;s complement unsigned
        // integer (in network byte order) comprised of the least-significant
        // seven bytes of the specified &#39;value&#39; (in host byte order), and
        // return a reference to this stream.  If this stream is initially
        // invalid, this operation has no effect.  If the next output operation
        // has been set to be marked invalid (see &#39;makeNextInvalid&#39;), reset
        // this marking and emit the invalid indicator instead of the type
        // indicator.

    TestOutStream&amp; putInt48(bsls::Types::Int64 value);
        // Write to this stream the one-byte type indicator for a six-byte
        // integer and the six-byte, two&#39;s complement integer (in network byte
        // order) comprised of the least-significant six bytes of the specified
        // &#39;value&#39; (in host byte order), and return a reference to this stream.
        // If this stream is initially invalid, this operation has no effect.
        // If the next output operation has been set to be marked invalid (see
        // &#39;makeNextInvalid&#39;), reset this marking and emit the invalid
        // indicator instead of the type indicator.

    TestOutStream&amp; putUint48(bsls::Types::Uint64 value);
        // Write to this stream the one-byte type indicator for a six-byte
        // unsigned integer and the six-byte, two&#39;s complement unsigned integer
        // (in network byte order) comprised of the least-significant six bytes
        // of the specified &#39;value&#39; (in host byte order), and return a
        // reference to this stream.  If this stream is initially invalid, this
        // operation has no effect.  If the next output operation has been set
        // to be marked invalid (see &#39;makeNextInvalid&#39;), reset this marking and
        // emit the invalid indicator instead of the type indicator.

    TestOutStream&amp; putInt40(bsls::Types::Int64 value);
        // Write to this stream the one-byte type indicator for a five-byte
        // integer and the five-byte, two&#39;s complement integer (in network byte
        // order) comprised of the least-significant five bytes of the
        // specified &#39;value&#39; (in host byte order), and return a reference to
        // this stream.  If this stream is initially invalid, this operation
        // has no effect.  If the next output operation has been set to be
        // marked invalid (see &#39;makeNextInvalid&#39;), reset this marking and emit
        // the invalid indicator instead of the type indicator.

    TestOutStream&amp; putUint40(bsls::Types::Uint64 value);
        // Write to this stream the one-byte type indicator for a five-byte
        // unsigned integer and the five-byte, two&#39;s complement unsigned
        // integer (in network byte order) comprised of the least-significant
        // five bytes of the specified &#39;value&#39; (in host byte order), and return
        // a reference to this stream.  If this stream is initially invalid,
        // this operation has no effect.  If the next output operation has been
        // set to be marked invalid (see &#39;makeNextInvalid&#39;), reset this marking
        // and emit the invalid indicator instead of the type indicator.

    TestOutStream&amp; putInt32(int value);
        // Write to this stream the one-byte type indicator for a four-byte
        // integer and the four-byte, two&#39;s complement integer (in network byte
        // order) comprised of the least-significant four bytes of the
        // specified &#39;value&#39; (in host byte order), and return a reference to
        // this stream.  If this stream is initially invalid, this operation
        // has no effect.  If the next output operation has been set to be
        // marked invalid (see &#39;makeNextInvalid&#39;), reset this marking and emit
        // the invalid indicator instead of the type indicator.

    TestOutStream&amp; putUint32(unsigned int value);
        // Write to this stream the one-byte type indicator for a four-byte
        // unsigned integer and the four-byte, two&#39;s complement unsigned
        // integer (in network byte order) comprised of the least-significant
        // four bytes of the specified &#39;value&#39; (in host byte order), and return
        // a reference to this stream.  If this stream is initially invalid,
        // this operation has no effect.  If the next output operation has been
        // set to be marked invalid (see &#39;makeNextInvalid&#39;), reset this marking
        // and emit the invalid indicator instead of the type indicator.

    TestOutStream&amp; putInt24(int value);
        // Write to this stream the one-byte type indicator for a three-byte
        // integer and the three-byte, two&#39;s complement integer (in network
        // byte order) comprised of the least-significant three bytes of the
        // specified &#39;value&#39; (in host byte order), and return a reference to
        // this stream.  If this stream is initially invalid, this operation
        // has no effect.  If the next output operation has been set to be
        // marked invalid (see &#39;makeNextInvalid&#39;), reset this marking and emit
        // the invalid indicator instead of the type indicator.

    TestOutStream&amp; putUint24(unsigned int value);
        // Write to this stream the one-byte type indicator for a three-byte
        // unsigned integer and the three-byte, two&#39;s complement unsigned
        // integer (in network byte order) comprised of the least-significant
        // three bytes of the specified &#39;value&#39; (in host byte order), and
        // return a reference to this stream.  If this stream is initially
        // invalid, this operation has no effect.  If the next output operation
        // has been set to be marked invalid (see &#39;makeNextInvalid&#39;), reset
        // this marking and emit the invalid indicator instead of the type
        // indicator.

    TestOutStream&amp; putInt16(int value);
        // Write to this stream the one-byte type indicator for a two-byte
        // integer and the two-byte, two&#39;s complement integer (in network byte
        // order) comprised of the least-significant two bytes of the specified
        // &#39;value&#39; (in host byte order), and return a reference to this stream.
        // If this stream is initially invalid, this operation has no effect.
        // If the next output operation has been set to be marked invalid (see
        // &#39;makeNextInvalid&#39;), reset this marking and emit the invalid
        // indicator instead of the type indicator.

    TestOutStream&amp; putUint16(unsigned int value);
        // Write to this stream the one-byte type indicator for a two-byte
        // unsigned integer and the two-byte, two&#39;s complement unsigned integer
        // (in network byte order) comprised of the least-significant two bytes
        // of the specified &#39;value&#39; (in host byte order), and return a
        // reference to this stream.  If this stream is initially invalid, this
        // operation has no effect.  If the next output operation has been set
        // to be marked invalid (see &#39;makeNextInvalid&#39;), reset this marking and
        // emit the invalid indicator instead of the type indicator.

    TestOutStream&amp; putInt8(int value);
        // Write to this stream the one-byte type indicator for a one-byte
        // integer and the one-byte, two&#39;s complement integer comprised of the
        // least-significant one byte of the specified &#39;value&#39;, and return a
        // reference to this stream.  If this stream is initially invalid, this
        // operation has no effect.  If the next output operation has been set
        // to be marked invalid (see &#39;makeNextInvalid&#39;), reset this marking and
        // emit the invalid indicator instead of the type indicator.

    TestOutStream&amp; putUint8(unsigned int value);
        // Write to this stream the one-byte type indicator for a one-byte
        // unsigned integer and the one-byte, two&#39;s complement unsigned integer
        // comprised of the least-significant one byte of the specified
        // &#39;value&#39;, and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.

                      // *** scalar floating-point values ***

    TestOutStream&amp; putFloat64(double value);
        // Write to this stream the one-byte type indicator for an eight-byte
        // double-precision floating-point number and the eight-byte IEEE
        // double-precision floating-point number (in network byte order)
        // comprised of the most-significant eight bytes of the specified
        // &#39;value&#39; (in host byte order), and return a reference to this stream.
        // If this stream is initially invalid, this operation has no effect.
        // If the next output operation has been set to be marked invalid (see
        // &#39;makeNextInvalid&#39;), reset this marking and emit the invalid
        // indicator instead of the type indicator.  Note that for
        // non-conforming platforms, this operation may be lossy.

    TestOutStream&amp; putFloat32(float value);
        // Write to this stream the one-byte type indicator for a four-byte
        // single-precision floating-point number and the four-byte IEEE
        // single-precision floating-point number (in network byte order)
        // comprised of the most-significant four bytes of the specified
        // &#39;value&#39; (in host byte order), and return a reference to this stream.
        // If this stream is initially invalid, this operation has no effect.
        // If the next output operation has been set to be marked invalid (see
        // &#39;makeNextInvalid&#39;), reset this marking and emit the invalid
        // indicator instead of the type indicator.  Note that for
        // non-conforming platforms, this operation may be lossy.

                      // *** string values ***

    TestOutStream&amp; putString(const bsl::string&amp; value);
        // Write to this stream the one-byte type indicator for a length (see
        // &#39;putLength&#39;), the length of the specified &#39;value&#39; (see &#39;putLength&#39;),
        // the one-byte type indicator for an array of one-byte unsigned
        // integers, and an array of one-byte, two&#39;s complement unsigned
        // integers comprised of the least-significant one byte of each
        // character in the &#39;value&#39;, and return a reference to this stream.  If
        // this stream is initially invalid, this operation has no effect.  If
        // the next output operation has been set to be marked invalid (see
        // &#39;makeNextInvalid&#39;), reset this marking and emit the invalid
        // indicator instead of the type indicator.

                      // *** arrays of integer values ***

    TestOutStream&amp; putArrayInt64(const bsls::Types::Int64 *values,
                                 int                       numValues);
        // Write to this stream the one-byte type indicator for an eight-byte
        // integer, the four-byte, two&#39;s complement integer (in network byte
        // order) comprised of the least-significant four bytes of the
        // specified &#39;numValues&#39; (in host byte order), and the consecutive
        // eight-byte, two&#39;s complement integers (in network byte order)
        // comprised of the least-significant eight bytes of each of the
        // &#39;numValues&#39; leading entries in the specified &#39;values&#39; (in host byte
        // order), and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.  The behavior is undefined unless &#39;0 &lt;= numValues&#39;
        // and &#39;values&#39; has sufficient contents.

    TestOutStream&amp; putArrayUint64(const bsls::Types::Uint64 *values,
                                  int                        numValues);
        // Write to this stream the one-byte type indicator for an eight-byte
        // unsigned integer, the four-byte, two&#39;s complement integer (in
        // network byte order) comprised of the least-significant four bytes of
        // the specified &#39;numValues&#39; (in host byte order), and the consecutive
        // eight-byte, two&#39;s complement unsigned integers (in network byte
        // order) comprised of the least-significant eight bytes of each of the
        // &#39;numValues&#39; leading entries in the specified &#39;values&#39; (in host byte
        // order), and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.  The behavior is undefined unless &#39;0 &lt;= numValues&#39;
        // and &#39;values&#39; has sufficient contents.

    TestOutStream&amp; putArrayInt56(const bsls::Types::Int64 *values,
                                 int                       numValues);
        // Write to this stream the one-byte type indicator for a seven-byte
        // integer, the four-byte, two&#39;s complement integer (in network byte
        // order) comprised of the least-significant four bytes of the
        // specified &#39;numValues&#39; (in host byte order), and the consecutive
        // seven-byte, two&#39;s complement integers (in network byte order)
        // comprised of the least-significant seven bytes of each of the
        // &#39;numValues&#39; leading entries in the specified &#39;values&#39; (in host byte
        // order), and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.  The behavior is undefined unless &#39;0 &lt;= numValues&#39;
        // and &#39;values&#39; has sufficient contents.

    TestOutStream&amp; putArrayUint56(const bsls::Types::Uint64 *values,
                                  int                        numValues);
        // Write to this stream the one-byte type indicator for a seven-byte
        // unsigned integer, the four-byte, two&#39;s complement integer (in
        // network byte order) comprised of the least-significant four bytes of
        // the specified &#39;numValues&#39; (in host byte order), and the consecutive
        // seven-byte, two&#39;s complement unsigned integers (in network byte
        // order) comprised of the least-significant seven bytes of each of the
        // &#39;numValues&#39; leading entries in the specified &#39;values&#39; (in host byte
        // order), and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.  The behavior is undefined unless &#39;0 &lt;= numValues&#39;
        // and &#39;values&#39; has sufficient contents.

    TestOutStream&amp; putArrayInt48(const bsls::Types::Int64 *values,
                                 int                       numValues);
        // Write to this stream the one-byte type indicator for a six-byte
        // integer, the four-byte, two&#39;s complement integer (in network byte
        // order) comprised of the least-significant four bytes of the
        // specified &#39;numValues&#39; (in host byte order), and the consecutive
        // six-byte, two&#39;s complement integers (in network byte order)
        // comprised of the least-significant six bytes of each of the
        // &#39;numValues&#39; leading entries in the specified &#39;values&#39; (in host byte
        // order), and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.  The behavior is undefined unless &#39;0 &lt;= numValues&#39;
        // and &#39;values&#39; has sufficient contents.

    TestOutStream&amp; putArrayUint48(const bsls::Types::Uint64 *values,
                                  int                        numValues);
        // Write to this stream the one-byte type indicator for a six-byte
        // unsigned integer, the four-byte, two&#39;s complement integer (in
        // network byte order) comprised of the least-significant four bytes of
        // the specified &#39;numValues&#39; (in host byte order), and the consecutive
        // six-byte, two&#39;s complement unsigned integers (in network byte order)
        // comprised of the least-significant six bytes of each of the
        // &#39;numValues&#39; leading entries in the specified &#39;values&#39; (in host byte
        // order), and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.  The behavior is undefined unless &#39;0 &lt;= numValues&#39;
        // and &#39;values&#39; has sufficient contents.

    TestOutStream&amp; putArrayInt40(const bsls::Types::Int64 *values,
                                 int                       numValues);
        // Write to this stream the one-byte type indicator for a five-byte
        // integer, the four-byte, two&#39;s complement integer (in network byte
        // order) comprised of the least-significant four bytes of the
        // specified &#39;numValues&#39; (in host byte order), and the consecutive
        // five-byte, two&#39;s complement integers (in network byte order)
        // comprised of the least-significant five bytes of each of the
        // &#39;numValues&#39; leading entries in the specified &#39;values&#39; (in host byte
        // order), and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.  The behavior is undefined unless &#39;0 &lt;= numValues&#39;
        // and &#39;values&#39; has sufficient contents.

    TestOutStream&amp; putArrayUint40(const bsls::Types::Uint64 *values,
                                  int                        numValues);
        // Write to this stream the one-byte type indicator for a five-byte
        // unsigned integer, the four-byte, two&#39;s complement integer (in
        // network byte order) comprised of the least-significant four bytes of
        // the specified &#39;numValues&#39; (in host byte order), and the consecutive
        // five-byte, two&#39;s complement unsigned integers (in network byte
        // order) comprised of the least-significant five bytes of each of the
        // &#39;numValues&#39; leading entries in the specified &#39;values&#39; (in host byte
        // order), and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.  The behavior is undefined unless &#39;0 &lt;= numValues&#39;
        // and &#39;values&#39; has sufficient contents.

    TestOutStream&amp; putArrayInt32(const int *values, int numValues);
        // Write to this stream the one-byte type indicator for a four-byte
        // integer, the four-byte, two&#39;s complement integer (in network byte
        // order) comprised of the least-significant four bytes of the
        // specified &#39;numValues&#39; (in host byte order), and the consecutive
        // four-byte, two&#39;s complement integers (in network byte order)
        // comprised of the least-significant four bytes of each of the
        // &#39;numValues&#39; leading entries in the specified &#39;values&#39; (in host byte
        // order), and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.  The behavior is undefined unless &#39;0 &lt;= numValues&#39;
        // and &#39;values&#39; has sufficient contents.

    TestOutStream&amp; putArrayUint32(const unsigned int *values, int numValues);
        // Write to this stream the one-byte type indicator for a four-byte
        // unsigned integer, the four-byte, two&#39;s complement integer (in
        // network byte order) comprised of the least-significant four bytes of
        // the specified &#39;numValues&#39; (in host byte order), and the consecutive
        // four-byte, two&#39;s complement unsigned integers (in network byte
        // order) comprised of the least-significant four bytes of each of the
        // &#39;numValues&#39; leading entries in the specified &#39;values&#39; (in host byte
        // order), and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.  The behavior is undefined unless &#39;0 &lt;= numValues&#39;
        // and &#39;values&#39; has sufficient contents.

    TestOutStream&amp; putArrayInt24(const int *values, int numValues);
        // Write to this stream the one-byte type indicator for a three-byte
        // integer, the four-byte, two&#39;s complement integer (in network byte
        // order) comprised of the least-significant four bytes of the
        // specified &#39;numValues&#39; (in host byte order), and the consecutive
        // three-byte, two&#39;s complement integers (in network byte order)
        // comprised of the least-significant three bytes of each of the
        // &#39;numValues&#39; leading entries in the specified &#39;values&#39; (in host byte
        // order), and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.  The behavior is undefined unless &#39;0 &lt;= numValues&#39;
        // and &#39;values&#39; has sufficient contents.

    TestOutStream&amp; putArrayUint24(const unsigned int *values, int numValues);
        // Write to this stream the one-byte type indicator for a three-byte
        // unsigned integer, the four-byte, two&#39;s complement integer (in
        // network byte order) comprised of the least-significant four bytes of
        // the specified &#39;numValues&#39; (in host byte order), and the consecutive
        // three-byte, two&#39;s complement unsigned integers (in network byte
        // order) comprised of the least-significant three bytes of each of the
        // &#39;numValues&#39; leading entries in the specified &#39;values&#39; (in host byte
        // order), and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.  The behavior is undefined unless &#39;0 &lt;= numValues&#39;
        // and &#39;values&#39; has sufficient contents.

    TestOutStream&amp; putArrayInt16(const short *values, int numValues);
        // Write to this stream the one-byte type indicator for a two-byte
        // integer, the four-byte, two&#39;s complement integer (in network byte
        // order) comprised of the least-significant four bytes of the
        // specified &#39;numValues&#39; (in host byte order), and the consecutive
        // two-byte, two&#39;s complement integers (in network byte order)
        // comprised of the least-significant two bytes of each of the
        // &#39;numValues&#39; leading entries in the specified &#39;values&#39; (in host byte
        // order), and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.  The behavior is undefined unless &#39;0 &lt;= numValues&#39;
        // and &#39;values&#39; has sufficient contents.

    TestOutStream&amp; putArrayUint16(const unsigned short *values, int numValues);
        // Write to this stream the one-byte type indicator for a two-byte
        // unsigned integer, the four-byte, two&#39;s complement integer (in
        // network byte order) comprised of the least-significant four bytes of
        // the specified &#39;numValues&#39; (in host byte order), and the consecutive
        // two-byte, two&#39;s complement unsigned integers (in network byte order)
        // comprised of the least-significant two bytes of each of the
        // &#39;numValues&#39; leading entries in the specified &#39;values&#39; (in host byte
        // order), and return a reference to this stream.  If this stream is
        // initially invalid, this operation has no effect.  If the next output
        // operation has been set to be marked invalid (see &#39;makeNextInvalid&#39;),
        // reset this marking and emit the invalid indicator instead of the
        // type indicator.  The behavior is undefined unless &#39;0 &lt;= numValues&#39;
        // and &#39;values&#39; has sufficient contents.

    TestOutStream&amp; putArrayInt8(const char        *values, int numValues);
    TestOutStream&amp; putArrayInt8(const signed char *values, int numValues);
        // Write to this stream the one-byte type indicator for a one-byte
        // integer, the four-byte, two&#39;s complement integer (in network byte
        // order) comprised of the least-significant four bytes of the
        // specified &#39;numValues&#39; (in host byte order), and the consecutive
        // one-byte, two&#39;s complement integers comprised of the
        // least-significant one byte of each of the &#39;numValues&#39; leading
        // entries in the specified &#39;values&#39;, and return a reference to this
        // stream.  If this stream is initially invalid, this operation has no
        // effect.  If the next output operation has been set to be marked
        // invalid (see &#39;makeNextInvalid&#39;), reset this marking and emit the
        // invalid indicator instead of the type indicator.  The behavior is
        // undefined unless &#39;0 &lt;= numValues&#39; and &#39;values&#39; has sufficient
        // contents.

    TestOutStream&amp; putArrayUint8(const char          *values, int numValues);
    TestOutStream&amp; putArrayUint8(const unsigned char *values, int numValues);
        // Write to this stream the one-byte type indicator for a one-byte
        // unsigned integer, the four-byte, two&#39;s complement integer (in
        // network byte order) comprised of the least-significant four bytes of
        // the specified &#39;numValues&#39; (in host byte order), and the consecutive
        // one-byte, two&#39;s complement unsigned integers comprised of the
        // least-significant one byte of each of the &#39;numValues&#39; leading
        // entries in the specified &#39;values&#39;, and return a reference to this
        // stream.  If this stream is initially invalid, this operation has no
        // effect.  If the next output operation has been set to be marked
        // invalid (see &#39;makeNextInvalid&#39;), reset this marking and emit the
        // invalid indicator instead of the type indicator.  The behavior is
        // undefined unless &#39;0 &lt;= numValues&#39; and &#39;values&#39; has sufficient
        // contents.

                      // *** arrays of floating-point values ***

    TestOutStream&amp; putArrayFloat64(const double *values, int numValues);
        // Write to this stream the one-byte type indicator for an eight-byte
        // double-precision floating-point number, the four-byte, two&#39;s
        // complement integer (in network byte order) comprised of the
        // least-significant four bytes of the specified &#39;numValues&#39; (in host
        // byte order), and the consecutive eight-byte IEEE double-precision
        // floating-point numbers (in network byte order) comprised of the
        // most-significant eight bytes of each of the &#39;numValues&#39; leading
        // entries in the specified &#39;values&#39; (in host byte order), and return a
        // reference to this stream.  If this stream is initially invalid, this
        // operation has no effect.  If the next output operation has been set
        // to be marked invalid (see &#39;makeNextInvalid&#39;), reset this marking and
        // emit the invalid indicator instead of the type indicator.  The
        // behavior is undefined unless &#39;0 &lt;= numValues&#39; and &#39;values&#39; has
        // sufficient contents.  Note that for non-conforming platforms, this
        // operation may be lossy.

    TestOutStream&amp; putArrayFloat32(const float *values, int numValues);
        // Write to this stream the one-byte type indicator for a four-byte
        // single-precision floating-point number, the four-byte, two&#39;s
        // complement integer (in network byte order) comprised of the
        // least-significant four bytes of the specified &#39;numValues&#39; (in host
        // byte order), and the consecutive four-byte IEEE single-precision
        // floating-point numbers (in network byte order) comprised of the
        // most-significant four bytes of each of the &#39;numValues&#39; leading
        // entries in the specified &#39;values&#39; (in host byte order), and return a
        // reference to this stream.  If this stream is initially invalid, this
        // operation has no effect.  If the next output operation has been set
        // to be marked invalid (see &#39;makeNextInvalid&#39;), reset this marking and
        // emit the invalid indicator instead of the type indicator.  The
        // behavior is undefined unless &#39;0 &lt;= numValues&#39; and &#39;values&#39; has
        // sufficient contents.  Note that for non-conforming platforms, this
        // operation may be lossy.

    // ACCESSORS
    operator const void *() const;
        // Return a non-zero value if this stream is valid, and 0 otherwise.
        // An invalid stream is a stream for which an output operation was
        // detected to have failed or &#39;invalidate&#39; was called.

    int bdexVersionSelector() const;
        // Return the &#39;versionSelector&#39; to be used with &#39;operator&lt;&lt;&#39; for BDEX
        // streaming as per the &#39;bslx&#39; package-level documentation.

    const char *data() const;
        // Return the address of the contiguous, non-modifiable internal memory
        // buffer of this stream.  The address will remain valid as long as
        // this array is not destroyed or modified (i.e., the current capacity
        // is not exceeded).  The behavior of accessing elements outside the
        // range &#39;[ data() .. data() + (length() - 1) ]&#39; is undefined.

    bool isValid() const;
        // Return &#39;true&#39; if this stream is valid, and &#39;false&#39; otherwise.  An
        // invalid stream is a stream for which an output operation was
        // detected to have failed or &#39;invalidate&#39; was called.

    bsl::size_t length() const;
        // Return the number of bytes in this stream.
};

// FREE OPERATORS
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;        stream,
                         const TestOutStream&amp; object);
    // Write the specified &#39;object&#39; to the specified output &#39;stream&#39; in some
    // reasonable (multi-line) format, and return a reference to &#39;stream&#39;.

template &lt;class TYPE&gt;
TestOutStream&amp; operator&lt;&lt;(TestOutStream&amp; stream, const TYPE&amp; value);
    // Write the specified &#39;value&#39; to the specified output &#39;stream&#39; following
    // the requirements of the BDEX protocol (see the &#39;bslx&#39; package-level
    // documentation), and return a reference to &#39;stream&#39;.  The behavior is
    // undefined unless &#39;TYPE&#39; is BDEX-compliant.

// ============================================================================
//                           INLINE DEFINITIONS
// ============================================================================

                         // -------------------
                         // class TestOutStream
                         // -------------------

// MANIPULATORS
inline
void TestOutStream::invalidate()
{
    d_imp.invalidate();
}

inline
void TestOutStream::makeNextInvalid()
{
    d_makeNextInvalidFlag = true;
}

inline
void TestOutStream::reserveCapacity(bsl::size_t newCapacity)
{
    d_imp.reserveCapacity(newCapacity);
}

inline
void TestOutStream::reset()
{
    d_imp.reset();
}

                      // *** string values ***

inline
TestOutStream&amp; TestOutStream::putString(const bsl::string&amp; value)
{
    putLength(static_cast&lt;int&gt;(value.length()));
    return putArrayUint8(value.data(), static_cast&lt;int&gt;(value.length()));
}

// ACCESSORS
inline
TestOutStream::operator const void *() const
{
    return d_imp;
}

inline
int TestOutStream::bdexVersionSelector() const
{
    return d_imp.bdexVersionSelector();
}

inline
const char *TestOutStream::data() const
{
    return d_imp.data();
}

inline
bool TestOutStream::isValid() const
{
    return d_imp.isValid();
}

inline
bsl::size_t TestOutStream::length() const
{
    return d_imp.length();
}

// FREE OPERATORS
template &lt;class TYPE&gt;
inline
TestOutStream&amp; operator&lt;&lt;(TestOutStream&amp; stream, const TYPE&amp; value)
{
    return OutStreamFunctions::bdexStreamOut(stream, value);
}

}  // close package namespace
}  // close enterprise namespace

// TRAITS
namespace BloombergLP {
namespace bslma {

template &lt;&gt;
struct UsesBslmaAllocator&lt;bslx::TestOutStream&gt; : bsl::true_type {};

}  // close namespace bslma
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
