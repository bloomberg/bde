<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlsos::TcpChannel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlsos.html">btlsos</a>      </li>
      <li><a class="el" href="classbtlsos_1_1TcpChannel.html">btlsos::TcpChannel</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlsos::TcpChannel Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlsos::TcpChannel" --><!-- doxytag: inherits="btlsc::Channel" -->
<p><code>#include &lt;<a class="el" href="btlsos__tcpchannel_8h_source.html">btlsos_tcpchannel.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlsos::TcpChannel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlsos_1_1TcpChannel.png" usemap="#btlsos::TcpChannel_map" alt=""/>
  <map id="btlsos::TcpChannel_map" name="btlsos::TcpChannel_map">
<area href="classbtlsc_1_1Channel.html" alt="btlsc::Channel" shape="rect" coords="0,0,118,24"/>
</map>
</div>

<p><a href="classbtlsos_1_1TcpChannel-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a3df2ebfc039b26e7ebfade1626036f84">TcpChannel</a> (<a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *socket, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a264d5201603206e2dccfbf250e9e1685">~TcpChannel</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#af14f64a0aac038e0b360f8175f6cd473">read</a> (char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a8c111f955cb826006df63da7f28e98dd">read</a> (int *augStatus, char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#abfa86357fa769a0bddcba1928f64fe12">readv</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a3fb80978899981b358d2520b99ff4bb1">readv</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#af1a8e0b4de4317b7f3422da87e4c1581">readRaw</a> (char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#ad46f00904abce4dab21b57a5d876586d">readRaw</a> (int *augStatus, char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a8bd88f1ca5622c67613641aa50142ee4">readvRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a90bb4042fe70f09465d844602a6344d4">readvRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a8575f05723c30047d5845ceb91fa7f09">bufferedRead</a> (const char **buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a1dc3bc3538b0f599e984dfd5cea462d4">bufferedRead</a> (int *augStatus, const char **buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a797db168d475a9a427b6fe53e744426e">bufferedReadRaw</a> (const char **buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#af1af8f79728ddfcead83ff141af79c68">bufferedReadRaw</a> (int *augStatus, const char **buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a7f68287fd842e2fe1703afe3ccac198b">write</a> (const char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a08d2c91daf451dba35b7c98602a2b392">write</a> (int *augStatus, const char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a4e100baaacce372a6d370642f5aafb41">writeRaw</a> (const char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a8a20396397f9635f5c420a8461660dfc">writeRaw</a> (int *augStatus, const char *buffer, int numBytes, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#af5a278f2f9ad9dca29b51eafc82bd667">writev</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a3d955e8f0bc471c8a6b2a05def918484">writev</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#aefbb4691997305b8a7fac158d510bfe2">writev</a> (int *augStatus, const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#adfdc50bb0d1e113d342e47c1df1dd8df">writev</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a4f261f1b1ba076e749f9fb04c530eb8a">writevRaw</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#ad108037eb53ae5ee971000a37e28946f">writevRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a294611a7f942a05b8ca707bb25817a47">writevRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a5449aae7e38fa42c12de97870f15e80f">writevRaw</a> (int *augStatus, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a29eb1f57cd9a60d4c0d64ab75e9f4394">invalidate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a416bcbaf9a7825f0ef71ddc57093ed76">getLocalAddress</a> (<a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *result)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#adf578835ae78c44bcb592002fb16158d">getOption</a> (int *result, int level, int option)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a925a1de913bcd1bec91392d5bcf5ffdb">getPeerAddress</a> (<a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *result)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#a9c8962b4afdfad1f7d070b8f5b96f19c">setOption</a> (int level, int option, int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#ab6d29ea1b7ea3800cf3542ceb5e12645">isInvalid</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a><br class="typebreak"/>
&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpChannel.html#aeabf207dd0f37d12249a39d28db1a736">socket</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements <code><a class="el" href="classbtlsc_1_1Channel.html">btlsc::Channel</a></code> protocol over TCP/IP sockets. It operates on top of the stream-socket interface, which is provided at construction. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3df2ebfc039b26e7ebfade1626036f84"></a><!-- doxytag: member="btlsos::TcpChannel::TcpChannel" ref="a3df2ebfc039b26e7ebfade1626036f84" args="(btlso::StreamSocket&lt; btlso::IPv4Address &gt; *socket, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlsos::TcpChannel::TcpChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a channel attached to the specified stream-oriented <code>socket</code>. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>socket</code> is not 0. </p>

</div>
</div>
<a class="anchor" id="a264d5201603206e2dccfbf250e9e1685"></a><!-- doxytag: member="btlsos::TcpChannel::~TcpChannel" ref="a264d5201603206e2dccfbf250e9e1685" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlsos::TcpChannel::~TcpChannel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this channel and release the underlying socket. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af14f64a0aac038e0b360f8175f6cd473"></a><!-- doxytag: member="btlsos::TcpChannel::read" ref="af14f64a0aac038e0b360f8175f6cd473" args="(char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::read </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a7d1d3187198316fffcc8d08b7e8786a3">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a8c111f955cb826006df63da7f28e98dd"></a><!-- doxytag: member="btlsos::TcpChannel::read" ref="a8c111f955cb826006df63da7f28e98dd" args="(int *augStatus, char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::read </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into the specified <code>buffer</code> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code>btlsc::Channel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a644cd29a99f7be2fd646d574a3a4e9d8">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="abfa86357fa769a0bddcba1928f64fe12"></a><!-- doxytag: member="btlsos::TcpChannel::readv" ref="abfa86357fa769a0bddcba1928f64fe12" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::readv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a2b26b82cfc6a061e214731bb8c1485ff">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a3fb80978899981b358d2520b99ff4bb1"></a><!-- doxytag: member="btlsos::TcpChannel::readv" ref="a3fb80978899981b358d2520b99ff4bb1" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::readv </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code>, the respective numbers of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> buffer. If the optionally specified <code>flags</code> incorporates <code>btlsc::Channel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a partial result. Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffers</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffers</code> have sufficient capacity to hold the requested data and 0 &lt; <code>numBuffers</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a2606f75082b4dc81a79e8ac6a9abdb7f">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="af1a8e0b4de4317b7f3422da87e4c1581"></a><!-- doxytag: member="btlsos::TcpChannel::readRaw" ref="af1a8e0b4de4317b7f3422da87e4c1581" args="(char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::readRaw </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a0f1f507ecd97fcdf09cfea3e6db6f8a4">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="ad46f00904abce4dab21b57a5d876586d"></a><!-- doxytag: member="btlsos::TcpChannel::readRaw" ref="ad46f00904abce4dab21b57a5d876586d" args="(int *augStatus, char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::readRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into the specified <code>buffer</code> <em>at</em> <em>most</em> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code>btlsc::Channel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and <code>0 &lt; numBytes</code>. Note that if the specified <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a16812cf3507d1f1c02dfccc3e28890a0">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a8bd88f1ca5622c67613641aa50142ee4"></a><!-- doxytag: member="btlsos::TcpChannel::readvRaw" ref="a8bd88f1ca5622c67613641aa50142ee4" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::readvRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#af67ae242a8d90cd3e1f7a646021b8b6a">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a90bb4042fe70f09465d844602a6344d4"></a><!-- doxytag: member="btlsos::TcpChannel::readvRaw" ref="a90bb4042fe70f09465d844602a6344d4" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::readvRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> <em>at</em> <em>most</em> the respective numbers of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> buffer. If the optionally specified <code>flags</code> incorporates <code>btlsc::Channel::ASYNC_INTERRUPT</code>, "asynchronous
         events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffers</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffers</code> have sufficient capacity to hold the requested data and 0 &lt; numBytes. Note that if the specified <code>timeout</code> value has already passed, the "read" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#af30686c7fad7e62c4367ba62646d5e05">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a8575f05723c30047d5845ceb91fa7f09"></a><!-- doxytag: member="btlsos::TcpChannel::bufferedRead" ref="a8575f05723c30047d5845ceb91fa7f09" args="(const char **buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::bufferedRead </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a25814ffdbbe699bf33af793c701f233f">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a1dc3bc3538b0f599e984dfd5cea462d4"></a><!-- doxytag: member="btlsos::TcpChannel::bufferedRead" ref="a1dc3bc3538b0f599e984dfd5cea462d4" args="(int *augStatus, const char **buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::bufferedRead </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this channel into a channel-supplied buffer, identified via the specified <code>buffer</code>, the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code>btlsc::Channel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. Any positive return value guarantees that <code>buffer</code> will remain valid until this channel is modified. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried with some reasonable hope of success -- buffered data from a partial result remains available until consumed by subsequent read operations. A negative "status", however, indicates a permanent error (leaving <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a8cd68049ca8edc3e80d5f36ade6aac2f">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a797db168d475a9a427b6fe53e744426e"></a><!-- doxytag: member="btlsos::TcpChannel::bufferedReadRaw" ref="a797db168d475a9a427b6fe53e744426e" args="(const char **buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::bufferedReadRaw </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a3c565a7f18a2515c6d00459db5ce7374">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="af1af8f79728ddfcead83ff141af79c68"></a><!-- doxytag: member="btlsos::TcpChannel::bufferedReadRaw" ref="af1af8f79728ddfcead83ff141af79c68" args="(int *augStatus, const char **buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::bufferedReadRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> read from this channel into a channel-supplied buffer, identified via the specified <code>buffer</code>, <em>at</em> <em>most</em> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code>btlsc::Channel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly read into <code>buffer</code> (indicating a partial result) otherwise. Any positive return value guarantees that <code>buffer</code> will remain valid until this channel is modified. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation, or a negative value if the atomic OS-level operation transmitted at least one but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried with some reasonable hope of success -- buffered data from a partial result remains available until consumed by subsequent read operations. A negative "status", however, indicates a permanent error (leaving <code>buffer</code> unset); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#addbe8479c8251f6eade148029fddd2de">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a7f68287fd842e2fe1703afe3ccac198b"></a><!-- doxytag: member="btlsos::TcpChannel::write" ref="a7f68287fd842e2fe1703afe3ccac198b" args="(const char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::write </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a707d767695090653fcf137f77e934caa">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a08d2c91daf451dba35b7c98602a2b392"></a><!-- doxytag: member="btlsos::TcpChannel::write" ref="a08d2c91daf451dba35b7c98602a2b392" args="(int *augStatus, const char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::write </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this channel from the specified <code>buffer</code> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code>btlsc::Channel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a3f49d7e1fdaba60d733ffe95649a7549">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a4e100baaacce372a6d370642f5aafb41"></a><!-- doxytag: member="btlsos::TcpChannel::writeRaw" ref="a4e100baaacce372a6d370642f5aafb41" args="(const char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::writeRaw </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a0642d2cf21c570446af7f63b748b382d">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a8a20396397f9635f5c420a8461660dfc"></a><!-- doxytag: member="btlsos::TcpChannel::writeRaw" ref="a8a20396397f9635f5c420a8461660dfc" args="(int *augStatus, const char *buffer, int numBytes, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::writeRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> write to this channel from the specified <code>buffer</code> <em>at</em> <em>most</em> the specified <code>numBytes</code>. If the optionally specified <code>flags</code> incorporates <code>btlsc::Channel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code>. Note that if the specified <code>timeout</code> value has already passed, the "write" operation will still be attempted, but the attempt will not block. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#afce89ca4cbe8df392ea0fc2b7cb18134">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="af5a278f2f9ad9dca29b51eafc82bd667"></a><!-- doxytag: member="btlsos::TcpChannel::writev" ref="af5a278f2f9ad9dca29b51eafc82bd667" args="(const btls::Ovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::writev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#af3be1ce9b3d03861d143b45b97132f5a">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a3d955e8f0bc471c8a6b2a05def918484"></a><!-- doxytag: member="btlsos::TcpChannel::writev" ref="a3d955e8f0bc471c8a6b2a05def918484" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::writev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a09eba049efd10344351ff5b4622f7e0e">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="aefbb4691997305b8a7fac158d510bfe2"></a><!-- doxytag: member="btlsos::TcpChannel::writev" ref="aefbb4691997305b8a7fac158d510bfe2" args="(int *augStatus, const btls::Ovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::writev </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a3206ad8bcf977c74579538b493b25d1b">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="adfdc50bb0d1e113d342e47c1df1dd8df"></a><!-- doxytag: member="btlsos::TcpChannel::writev" ref="adfdc50bb0d1e113d342e47c1df1dd8df" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::writev </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this channel from the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> the respective numbers of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> (or <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code>) buffer. If the optionally specified <code>flags</code> incorporates <code>btlsc::Channel::ASYNC_INTERRUPT</code>, "asynchronous
         events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a partial result. Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffers</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value, indicating that an asynchronous event caused the interruption; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless 0 &lt; numBytes. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a0e798cdf27aa1971e22a15039c44db8d">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a4f261f1b1ba076e749f9fb04c530eb8a"></a><!-- doxytag: member="btlsos::TcpChannel::writevRaw" ref="a4f261f1b1ba076e749f9fb04c530eb8a" args="(const btls::Ovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#abf4d5f6379e59ce8b026a78a1567c95f">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="ad108037eb53ae5ee971000a37e28946f"></a><!-- doxytag: member="btlsos::TcpChannel::writevRaw" ref="ad108037eb53ae5ee971000a37e28946f" args="(const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a44ce53caa3bab5c448a35634e3918ffa">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a294611a7f942a05b8ca707bb25817a47"></a><!-- doxytag: member="btlsos::TcpChannel::writevRaw" ref="a294611a7f942a05b8ca707bb25817a47" args="(int *augStatus, const btls::Ovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a993810b91aa73a1ce659aa9a3cd59d93">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a5449aae7e38fa42c12de97870f15e80f"></a><!-- doxytag: member="btlsos::TcpChannel::writevRaw" ref="a5449aae7e38fa42c12de97870f15e80f" args="(int *augStatus, const btls::Iovec *buffers, int numBuffers, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>augStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Atomically</em> write to this channel, from the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code>, <em>at</em> <em>most</em> the respective numbers of bytes as specified in each corresponding <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> (or <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code>) buffer. If the optionally specified <code>flags</code> incorporates <code>btlsc::Channel::ASYNC_INTERRUPT</code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Optionally specify (as a <em>leading</em> argument) <code>augStatus</code> to receive status specific to a "partial result". Return <code>numBytes</code> on success, a negative value on error, and the number of bytes newly written from <code>buffer</code> (indicating a partial result) otherwise. On a partial result, load <code>augStatus</code>, if supplied, with a positive value if an asynchronous event interrupted this operation and a negative value if the atomic OS-level operation transmitted at least one byte, but less than <code>numBytes</code>; otherwise, <code>augStatus</code> is unmodified. A partial result typically does not invalidate this channel; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless 0 &lt; numBytes. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a0223adc9241f6d19264a7e38b2f61677">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a29eb1f57cd9a60d4c0d64ab75e9f4394"></a><!-- doxytag: member="btlsos::TcpChannel::invalidate" ref="a29eb1f57cd9a60d4c0d64ab75e9f4394" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlsos::TcpChannel::invalidate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make this channel invalid; no subsequent operations can be completed successfully. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#adc7cc9dfc2e802578f09dd2c0418523c">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="a416bcbaf9a7825f0ef71ddc57093ed76"></a><!-- doxytag: member="btlsos::TcpChannel::getLocalAddress" ref="a416bcbaf9a7825f0ef71ddc57093ed76" args="(btlso::IPv4Address *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::getLocalAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the complete IP address associated with the local (i.e., this process) end-point of this channel. Return 0 on success and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="adf578835ae78c44bcb592002fb16158d"></a><!-- doxytag: member="btlsos::TcpChannel::getOption" ref="adf578835ae78c44bcb592002fb16158d" args="(int *result, int level, int option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::getOption </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the current value of the specified <code>option</code> of the specified <code>level</code> set on the underlying socket. Return 0 on success and a non-zero value otherwise. The list of commonly-supported options (and levels) is enumerated in <code>btlso_socketoptutil</code>. </p>

</div>
</div>
<a class="anchor" id="a925a1de913bcd1bec91392d5bcf5ffdb"></a><!-- doxytag: member="btlsos::TcpChannel::getPeerAddress" ref="a925a1de913bcd1bec91392d5bcf5ffdb" args="(btlso::IPv4Address *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::getPeerAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the complete IP address associated with the remote (i.e., peer process) end-point of this channel. Return 0 on success and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="a9c8962b4afdfad1f7d070b8f5b96f19c"></a><!-- doxytag: member="btlsos::TcpChannel::setOption" ref="a9c8962b4afdfad1f7d070b8f5b96f19c" args="(int level, int option, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::setOption </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified socket <code>option</code> of the specified <code>level</code> on the underlying socket to the specified <code>value</code>. Return 0 on success and a non-zero value otherwise. (The list of commonly-supported options is available in <code>btlso_socketoptutil</code>.) </p>

</div>
</div>
<a class="anchor" id="ab6d29ea1b7ea3800cf3542ceb5e12645"></a><!-- doxytag: member="btlsos::TcpChannel::isInvalid" ref="ab6d29ea1b7ea3800cf3542ceb5e12645" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpChannel::isInvalid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if <em>any</em> transmission error has occurred or if the channel has been explicitly invalidated (via <code>invalidate</code>) and 0 otherwise. Once a channel is invalid, no operations can be completed successfully. Note also that 0 return value does NOT guarantee that a subsequent I/O operation would not fail. </p>

<p>Implements <a class="el" href="classbtlsc_1_1Channel.html#a115e9e4d1c7e221d8b8ed7f6fe0a63d9">btlsc::Channel</a>.</p>

</div>
</div>
<a class="anchor" id="aeabf207dd0f37d12249a39d28db1a736"></a><!-- doxytag: member="btlsos::TcpChannel::socket" ref="aeabf207dd0f37d12249a39d28db1a736" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt;<a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a>&gt;* btlsos::TcpChannel::socket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the stream-socket used by this channel. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlsos__tcpchannel_8h_source.html">btlsos_tcpchannel.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:17 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
