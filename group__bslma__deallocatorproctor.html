<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslma_deallocatorproctor Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslma_deallocatorproctor<br/>
<small>
[<a class="el" href="group__bslma.html">Package bslma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a proctor to conditionally manage a block memory.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Requirement</a> </li>
<li>
<a href="#3.2">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a proctor to conditionally manage a block memory. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor</a> </td><td>proctor to conditionally manage a memory  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__deallocatorguard.html" title="Provide a guard to unconditionally manage a block of memory.">Component bslma_deallocatorguard</a>, <a class="el" href="group__bslma__autodeallocator.html" title="Provide a range proctor to managed a block of memory.">Component bslma_autodeallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a proctor class template to conditionally manage a block of (otherwise-unmanaged) memory. If not explicitly released, the managed memory is deallocated automatically when the proctor object goes out of scope by freeing the memory using the parameterized <code>ALLOCATOR</code> (allocator or pool) supplied at construction. Note that after a proctor object releases its managed memory, the same proctor can be reused to conditionally manage another block of memory (allocated from the same allocator or pool that was supplied at construction) by invoking the <code>reset</code> method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirement"></a> <a class="anchor" id="description.requirement"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Requirement: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The parameterized <code>ALLOCATOR</code> type of the <code><a class="el" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor</a></code> class must provide a (possibly <code>virtual</code>) method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *address);
</pre></div><br/>
<br/>
 to deallocate memory at the specified <code>address</code> (originally supplied by the <code>ALLOCATOR</code> object). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor</a></code> is normally used to achieve <em>exception</em> <em>safety</em> in an <em>exception</em> <em>neutral</em> way by managing memory in a sequence of continuous memory allocations. Since each memory allocation may potentially throw an exception, an object of this proctor class can be used to (temporarily) manage newly allocated memory while attempting to allocate additional memory. Should an exception occur in subsequent memory allocation, the proctor's destructor deallocates its managed memory, preventing a memory leak. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example illustrate a typical use of <code><a class="el" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor</a></code>. Suppose we have an array class that stores an "in-place" representation of objects of parameterized <code>TYPE</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_array.h</span>
  <span class="comment">// ...</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>my_Array {
      <span class="comment">// This class implements an &quot;in-place&quot; array of objects of</span>
      <span class="comment">// parameterized &#39;TYPE&#39; stored contiguously in memory.</span>

      <span class="comment">// DATA</span>
      TYPE             *d_array_p;      <span class="comment">// dynamically allocated array</span>
      <span class="keywordtype">int</span>               d_length;       <span class="comment">// logical length of this array</span>
      <span class="keywordtype">int</span>               d_size;         <span class="comment">// physical capacity of this array</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;  <span class="comment">// allocator (held, not owned)</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_Array(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;my_Array&#39; object.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

      <span class="comment">// ...</span>

      ~my_Array();
          <span class="comment">// Destroy this &#39;my_Array&#39; object and all elements currently</span>
          <span class="comment">// stored.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="comment">// ...</span>

      <span class="keywordtype">void</span> append(<span class="keyword">const</span> TYPE&amp; <span class="keywordtype">object</span>);
          <span class="comment">// Append (a copy of) the specified &#39;object&#39; of parameterized</span>
          <span class="comment">// &#39;TYPE&#39; to (the end of) this array.</span>

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Note that the rest of the <code>my_Array</code> interface (above) and implementation (below) is elided as the portion shown is sufficient to demonstrate the use of <code><a class="el" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor</a></code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  my_Array&lt;TYPE&gt;::my_Array(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_length(0)
  , d_size(1)
  , d_allocator_p(bslma::Default::allocator(basicAllocator))
  {
      d_array_p = (TYPE *)d_allocator_p-&gt;allocate(<span class="keyword">sizeof</span>(TYPE));
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  my_Array&lt;TYPE&gt;::~my_Array()
  {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d_length; ++i) {
          d_array_p[i].~TYPE();
      }
      d_allocator_p-&gt;deallocate(d_array_p);
  }
</pre></div><br/>
<br/>
 In order to implement the <code>append</code> function, we first have to introduce an <code>my_AutoDestructor</code> <code>class</code>, which automatically destroy a sequence of managed objects upon destruction. See <code><a class="el" href="classbslma_1_1AutoDestructor.html">bslma::AutoDestructor</a></code> for a similar component with full documentation: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_autodestructor.h</span>
  <span class="comment">// ...</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>my_AutoDestructor {
      <span class="comment">// This class implements a range proctor that, unless its &#39;release&#39;</span>
      <span class="comment">// method has previously been invoked, automatically invokes the</span>
      <span class="comment">// destructor of each of sequence of objects it manages.</span>

      <span class="comment">// DATA</span>
      TYPE * d_origin_p;
      <span class="keywordtype">int</span>    d_length;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_AutoDestructor(TYPE *origin, <span class="keywordtype">int</span> length)
          <span class="comment">// Create an &#39;my_AutoDestructor&#39; to manage a contiguous sequence of</span>
          <span class="comment">// objects.</span>
      : d_origin_p(origin)
      , d_length(length)
      {
      }

      ~my_AutoDestructor()
          <span class="comment">// Destroy this &#39;my_AutoDestructor&#39; and, unless its &#39;release&#39;</span>
          <span class="comment">// method has previously been invoked, destroy the sequence of</span>
          <span class="comment">// objects it manages by invoking the destructor of each of the</span>
          <span class="comment">// (managed) objects.</span>
      {
          <span class="keywordflow">if</span> (d_length) {
              <span class="keywordflow">for</span> (; d_length &gt; 0; --d_length, ++d_origin_p) {
                  d_origin_p-&gt;~TYPE();
              }
          }
      }

      <span class="comment">// MANIPULATORS</span>
      my_AutoDestructor&lt;TYPE&gt;&amp; <a class="code" href="namespacebslstl.html#a00890c2044ab22c5074a3d85283319d0">operator++</a>()
          <span class="comment">// Increase by one the length of the sequence of objects managed by</span>
          <span class="comment">// this range proctor.</span>
      {
          ++d_length;
          <span class="keywordflow">return</span> *<span class="keyword">this</span>;
      }

      <span class="keywordtype">void</span> release()
          <span class="comment">// Release from management the sequence of objects currently</span>
          <span class="comment">// managed by this range proctor.</span>
      {
          d_length = 0;
      }
  };
</pre></div><br/>
<br/>
 We can now continue with our implementation of the <code>my_Array</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_array.h</span>
  <span class="comment">// ...</span>

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> my_Array&lt;TYPE&gt;::append(<span class="keyword">const</span> TYPE &amp;<span class="keywordtype">object</span>)
  {
      <span class="keywordflow">if</span> (d_length == d_size) {
          TYPE *newArray = (TYPE *)d_allocator_p-&gt;allocate(
                               d_size * 2 * <span class="keyword">sizeof</span>(TYPE));  <span class="comment">// possibly throw</span>

          <span class="comment">//*****************************************************************</span>
          <span class="comment">// Note the use of the deallocator proctor on &#39;newArray&#39; (below). *</span>
          <span class="comment">//*****************************************************************</span>

          <a class="code" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor&lt;bslma::Allocator&gt;</a> proctor(newArray,
                                                              d_allocator_p);

          <span class="comment">// Note use of &#39;my_AutoDestructor&#39; here to protect the copy</span>
          <span class="comment">// construction of &#39;TYPE&#39; objects.</span>
          my_AutoDestructor&lt;TYPE&gt; destructor(newArray, 0);

          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d_length; ++i) {
              <span class="keyword">new</span>(&amp;newArray[i]) TYPE(d_array_p[i], d_allocator_p);
                                                           <span class="comment">// possibly throw</span>
              d_array_p[i].~TYPE();
              ++destructor;
          }

          destructor.release();

          <span class="comment">//*********************************************************</span>
          <span class="comment">// Note that the deallocator proctor is released (below). *</span>
          <span class="comment">//*********************************************************</span>

          proctor.release();

          d_allocator_p-&gt;deallocate(d_array_p);
          d_array_p = newArray;
          d_size   *= 2;
      }

      <span class="keyword">new</span>(&amp;d_array_p[d_length]) TYPE(<span class="keywordtype">object</span>, d_allocator_p);
      ++d_length;
  }
</pre></div><br/>
<br/>
 Both the use of <code><a class="el" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor</a></code> and <code>my_AutoDestructor</code> are necessary to implement exception safety. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>append</code> method defined above potentially throws in two places. If the memory allocator held in <code>d_allocator_p</code> where to throw while attempting to allocate the new array of parameterized <code>TYPE</code>, no memory would be leaked. But without subsequent use of the <code><a class="el" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor</a></code>, if the allocator subsequently throws while copy constructing the objects from the old array to the new array, the newly allocated memory block would be leaked. Using the <code><a class="el" href="classbslma_1_1DeallocatorProctor.html">bslma::DeallocatorProctor</a></code> prevents the leak by deallocating the proctored memory automatically should the proctor go out of scope before the <code>release</code> method of the proctor is called (such as when the function exits prematurely due to an exception). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Similarly, any resources acquired as a result of copy constructing the objects from the old array to the new array would be leaked if the constructor of <code>TYPE</code> throws. Using the <code>my_AutoDestructor</code> prevents the leak by invoking the destructor of the proctored (and newly created) objects in the new array should the <code>my_AutoDestructor</code> goes out of scope before the <code>release</code> method of the proctor is called. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the <code>append</code> method assumes the copy constructor of <code>TYPE</code> takes an allocator as a second argument. In production code, a constructor proxy that checks the traits of <code>TYPE</code> (to see whether <code>TYPE</code> uses <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>) should be used (see <code><a class="el" href="classbslalg_1_1ConstructorProxy.html">bslalg::ConstructorProxy</a></code>). </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:41 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
