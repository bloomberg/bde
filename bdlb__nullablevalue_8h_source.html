<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlb_nullablevalue.h                                               -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLB_NULLABLEVALUE
#define INCLUDED_BDLB_NULLABLEVALUE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a template for nullable (in-place) objects.
//
//@CLASSES:
//  bdlb::NullableValue: template for nullable (in-place) objects
//
//
//@SEE_ALSO: bdlb_nullableallocatedvalue
//
//@DESCRIPTION: This component provides a template class,
// &#39;bdlb::NullableValue&lt;TYPE&gt;&#39;, that can be used to augment an arbitrary
// value-semantic &#39;TYPE&#39;, such as &#39;int&#39; or &#39;bsl::string&#39;, so that it also
// supports the notion of a &quot;null&quot; value.  That is, the set of values
// representable by the template parameter &#39;TYPE&#39; is extended to include null.
// If the underlying &#39;TYPE&#39; is fully value-semantic, then so will the augmented
// type &#39;bdlb::NullableValue&lt;TYPE&gt;&#39;.  Two homogeneous nullable objects have the
// same value if their underlying &#39;TYPE&#39; values are the same, or both are null.
//
// Note that the object of template parameter &#39;TYPE&#39; that is managed by a
// &#39;bdlb::NullableValue&lt;TYPE&gt;&#39; object is created *in*-*place*.  Consequently,
// the template parameter &#39;TYPE&#39; must be a complete type when the class is
// instantiated.  In contrast, &#39;bdlb::NullableAllocatedValue&lt;TYPE&gt;&#39; (see
// &#39;bdlb_nullableallocatedvalue&#39;) does not require that &#39;TYPE&#39; be complete when
// that class is instantiated, with the trade-off that the managed &#39;TYPE&#39;
// object is always allocated out-of-place in that case.
//
// In addition to the standard homogeneous, value-semantic, operations such as
// copy construction, copy assignment, equality comparison, and BDEX streaming,
// &#39;bdlb::NullableValue&#39; also supports conversion between augmented types for
// which the underlying types are convertible, i.e., for heterogeneous copy
// construction, copy assignment, and equality comparison (e.g., between &#39;int&#39;
// and &#39;double&#39;); attempts at conversion between incompatible types, such as
// &#39;int&#39; and &#39;bsl::string&#39;, will fail to compile.  Note that these operational
// semantics are similar to those found in &#39;bsl::shared_ptr&#39;.
//
///Usage
///-----
// The following snippets of code illustrate use of this component:
//
// First, create a nullable &#39;int&#39; object:
//..
//  bdlb::NullableValue&lt;int&gt; nullableInt;
//  assert( nullableInt.isNull());
//..
// Next, give the &#39;int&#39; object the value 123 (making it non-null):
//..
//  nullableInt.makeValue(123);
//  assert(!nullableInt.isNull());
//  assert(123 == nullableInt.value());
//..
// Finally, reset the object to its default constructed state (i.e., null):
//..
//  nullableInt.reset();
//  assert( nullableInt.isNull());
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLB_PRINTMETHODS
#include &lt;bdlb_printmethods.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SWAPUTIL
#include &lt;bslalg_swaputil.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include &lt;bslalg_typetraits.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMF_IF
#include &lt;bslmf_if.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_COMPILERFEATURES
#include &lt;bsls_compilerfeatures.h&gt;
#endif

#ifndef INCLUDED_BSLS_OBJECTBUFFER
#include &lt;bsls_objectbuffer.h&gt;
#endif

#ifndef INCLUDED_BSLX_INSTREAMFUNCTIONS
#include &lt;bslx_instreamfunctions.h&gt;
#endif

#ifndef INCLUDED_BSLX_OUTSTREAMFUNCTIONS
#include &lt;bslx_outstreamfunctions.h&gt;
#endif

#ifndef INCLUDED_BSLX_VERSIONFUNCTIONS
#include &lt;bslx_versionfunctions.h&gt;
#endif

#ifndef INCLUDED_BSL_ALGORITHM
#include &lt;bsl_algorithm.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSL_NEW
#include &lt;bsl_new.h&gt;
#endif

#ifndef INCLUDED_BSL_UTILITY
#include &lt;bsl_utility.h&gt;    // for &#39;bsl::forward&#39;
#endif

namespace BloombergLP {
namespace bdlb {

template &lt;class TYPE&gt;
class NullableValue_WithAllocator;

template &lt;class TYPE&gt;
class NullableValue_WithoutAllocator;

                      // =========================
                      // class NullableValue&lt;TYPE&gt;
                      // =========================

template &lt;class TYPE&gt;
class NullableValue {
    // This template class extends the set of values of its value-semantic
    // &#39;TYPE&#39; parameter to include the notion of a &quot;null&quot; value.  If &#39;TYPE&#39; is
    // fully value-semantic, then the augmented type &#39;Nullable&lt;TYPE&gt;&#39; will be
    // as well.  In addition to supporting all homogeneous value-semantic
    // operations, conversions between comparable underlying value types is
    // also supported.  Two nullable objects with different underlying types
    // compare equal if their underlying types are comparable and either (1)
    // both objects are null or (2) the non-null values compare equal.
    // Attempts to copy construct, copy assign, or compare incompatible values
    // types will fail to compile.  The &#39;NullableValue&#39; template cannot be
    // instantiated on an incomplete type or on a type that overloads
    // &#39;operator&amp;&#39;.

    // PRIVATE TYPES
    typedef typename
    bslmf::If&lt;bslma::UsesBslmaAllocator&lt;TYPE&gt;::value,
              NullableValue_WithAllocator&lt;TYPE&gt;,
              NullableValue_WithoutAllocator&lt;TYPE&gt; &gt;::Type Imp;

    // DATA
    Imp d_imp;  // managed nullable &#39;TYPE&#39; object

  public:
    // TYPES
    typedef TYPE ValueType;
        // &#39;ValueType&#39; is an alias for the underlying &#39;TYPE&#39; upon which this
        // template class is instantiated, and represents the type of the
        // managed object.

    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION_IF(NullableValue,
                                      bslma::UsesBslmaAllocator,
                                      bslma::UsesBslmaAllocator&lt;TYPE&gt;::value);
    BSLMF_NESTED_TRAIT_DECLARATION_IF(NullableValue,
                                      bsl::is_trivially_copyable,
                                      bsl::is_trivially_copyable&lt;TYPE&gt;::value);
    BSLMF_NESTED_TRAIT_DECLARATION_IF(NullableValue,
                                      bslmf::IsBitwiseMoveable,
                                      bslmf::IsBitwiseMoveable&lt;TYPE&gt;::value);
    BSLMF_NESTED_TRAIT_DECLARATION(NullableValue, bdlb::HasPrintMethod);
        // &#39;UsesBslmaAllocator&#39;, &#39;IsBitwiseCopyable&#39;, and &#39;IsBitwiseMoveable&#39;
        // are true for &#39;NullableValue&#39; only if the corresponding trait is true
        // for &#39;TYPE&#39;.  &#39;HasPrintMethod&#39; is always true for &#39;NullableValue&#39;.

    // CREATORS
    NullableValue();
        // Create a nullable object having the null value.  If &#39;TYPE&#39; takes an
        // optional allocator at construction, use the currently installed
        // default allocator to supply memory.

    explicit NullableValue(bslma::Allocator *basicAllocator);
        // Create a nullable object that has the null value and that uses the
        // specified &#39;basicAllocator&#39; to supply memory.  Note that this method
        // will fail to compile if &#39;TYPE&#39; does not take an optional allocator
        // at construction.

    NullableValue(const NullableValue&amp; original);
        // Create a nullable object having the value of the specified
        // &#39;original&#39; object.  If &#39;TYPE&#39; takes an optional allocator at
        // construction, use the currently installed default allocator to
        // supply memory.

    NullableValue(const NullableValue&amp;  original,
                  bslma::Allocator     *basicAllocator);
        // Create a nullable object that has the value of the specified
        // &#39;original&#39; object and that uses the specified &#39;basicAllocator&#39; to
        // supply memory.  Note that this method will fail to compile if &#39;TYPE&#39;
        // does not take an optional allocator at construction.

    NullableValue(const TYPE&amp; value);                         // IMPLICIT
        // Create a nullable object having the specified &#39;value&#39;.  If &#39;TYPE&#39;
        // takes an optional allocator at construction, use the currently
        // installed default allocator to supply memory.

    NullableValue(const TYPE&amp; value, bslma::Allocator *basicAllocator);
        // Create a nullable object that has the specified &#39;value&#39; and that
        // uses the specified &#39;basicAllocator&#39; to supply memory.  Note that
        // this method will fail to compile if &#39;TYPE&#39; does not take an optional
        // allocator at construction.

    template &lt;class BDE_OTHER_TYPE&gt;
    explicit NullableValue(const NullableValue&lt;BDE_OTHER_TYPE&gt;&amp; original);
        // Create a nullable object having the null value if the specified
        // &#39;original&#39; object is null, and the value of &#39;original.value()&#39; (of
        // &#39;BDE_OTHER_TYPE&#39;) converted to &#39;TYPE&#39; otherwise.  If &#39;TYPE&#39; takes an
        // optional allocator at construction, use the currently installed
        // default allocator to supply memory.  Note that this method will fail
        // to compile if &#39;TYPE and &#39;BDE_OTHER_TYPE&#39; are not compatible.

    template &lt;class BDE_OTHER_TYPE&gt;
    NullableValue(const NullableValue&lt;BDE_OTHER_TYPE&gt;&amp;  original,
                  bslma::Allocator                     *basicAllocator);
        // Create a nullable object that has the null value if the specified
        // &#39;original&#39; object is null, and the value of &#39;original.value()&#39; (of
        // &#39;BDE_OTHER_TYPE&#39;) converted to &#39;TYPE&#39; otherwise; use the specified
        // &#39;basicAllocator&#39; to supply memory.  Note that this method will fail
        // to compile if &#39;TYPE&#39; does not take an optional allocator at
        // construction, or if &#39;TYPE and &#39;BDE_OTHER_TYPE&#39; are not compatible.

    // ~NullableValue();
        // Destroy this object.  Note that this destructor is generated by the
        // compiler.

    // MANIPULATORS
    NullableValue&lt;TYPE&gt;&amp; operator=(const NullableValue&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39;, and return a
        // reference providing modifiable access to this object.

    template &lt;class BDE_OTHER_TYPE&gt;
    NullableValue&lt;TYPE&gt;&amp; operator=(const NullableValue&lt;BDE_OTHER_TYPE&gt;&amp; rhs);
        // Assign to this object the null value if the specified &#39;rhs&#39; object
        // is null, and the value of &#39;rhs.value()&#39; (of &#39;BDE_OTHER_TYPE&#39;)
        // converted to &#39;TYPE&#39; otherwise.  Return a reference providing
        // modifiable access to this object.  Note that this method will fail
        // to compile if &#39;TYPE and &#39;BDE_OTHER_TYPE&#39; are not compatible.

    NullableValue&lt;TYPE&gt;&amp; operator=(const TYPE&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39;, and return a
        // reference providing modifiable access to this object.

    template &lt;class BDE_OTHER_TYPE&gt;
    NullableValue&lt;TYPE&gt;&amp; operator=(const BDE_OTHER_TYPE&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object (of
        // &#39;BDE_OTHER_TYPE&#39;) converted to &#39;TYPE&#39;, and return a reference
        // providing modifiable access to this object.  Note that this method
        // will fail to compile if &#39;TYPE and &#39;BDE_OTHER_TYPE&#39; are not
        // compatible.

    void swap(NullableValue&amp; other);
        // Efficiently exchange the value of this object with the value of the
        // specified &#39;other&#39; object.  This method provides the no-throw
        // exception-safety guarantee if the template parameter &#39;TYPE&#39; provides
        // that guarantee and the result of the &#39;isNull&#39; method for the two
        // objects being swapped is the same.  The behavior is undefined unless
        // this object was created with the same allocator, if any, as &#39;other&#39;.

    TYPE&amp; makeValue(const TYPE&amp; value);
        // Assign to this object the specified &#39;value&#39;, and return a reference
        // providing modifiable access to the underlying &#39;TYPE&#39; object.

    template &lt;class BDE_OTHER_TYPE&gt;
    TYPE&amp; makeValue(const BDE_OTHER_TYPE&amp; value);
        // Assign to this object the specified &#39;value&#39; (of &#39;BDE_OTHER_TYPE&#39;)
        // converted to &#39;TYPE&#39;, and return a reference providing modifiable
        // access to the underlying &#39;TYPE&#39; object.  Note that this method will
        // fail to compile if &#39;TYPE and &#39;BDE_OTHER_TYPE&#39; are not compatible.

    TYPE&amp; makeValue();
        // Assign to this object the default value for &#39;TYPE&#39;, and return a
        // reference providing modifiable access to the underlying &#39;TYPE&#39;
        // object.

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES // $var-args=5
    template &lt;class... ARGS&gt;
    TYPE&amp; makeValueInplace(ARGS&amp;&amp;... args);
        // Assign to this nullable object the value of the (template parameter)
        // &#39;TYPE&#39; created in place using the specified &#39;args&#39;.  Return a
        // reference providing modifiable access to the created (value) object.
        // The object is also accessible via the &#39;value&#39; method.  If this
        // nullable object already contains an object (&#39;false == isNull()&#39;),
        // that object is destroyed before the new object is created.  If
        // &#39;TYPE&#39; has the trait &#39;bslma::UsesBslmaAllocator&#39; (&#39;TYPE&#39; is
        // allocator-enabled) the allocator specified at the construction of
        // this nullable object is used to supply memory to the value object.
        // Attempts to explicitly specify via &#39;args&#39; another allocator to
        // supply memory to the created (value) object are disallowed by the
        // compiler.  Note that if the constructor of &#39;TYPE&#39; throws an
        // exception this object is left in the null state.
#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Generator command line: sim_cpp11_features.pl --var-args=5 --output bdlb_nullablevalue.h
    TYPE&amp; makeValueInplace();

    template &lt;class ARGS_1&gt;
    TYPE&amp; makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1);

    template &lt;class ARGS_1,
              class ARGS_2&gt;
    TYPE&amp; makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2);

    template &lt;class ARGS_1,
              class ARGS_2,
              class ARGS_3&gt;
    TYPE&amp; makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3);

    template &lt;class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4&gt;
    TYPE&amp; makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4);

    template &lt;class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4,
              class ARGS_5&gt;
    TYPE&amp; makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
                           BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5);

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template &lt;class... ARGS&gt;
    TYPE&amp; makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);
// }}} END GENERATED CODE
#endif

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated, but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    void reset();
        // Reset this object to the default constructed state (i.e., to have
        // the null value).

    TYPE&amp; value();
        // Return a reference providing modifiable access to the underlying
        // &#39;TYPE&#39; object.  The behavior is undefined unless this object is
        // non-null.

    // ACCESSORS
    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write the value of this object, using the specified &#39;version&#39;
        // format, to the specified output &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation has no
        // effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is invalidated, but
        // otherwise unmodified.  Note that &#39;version&#39; is not written to
        // &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    bool isNull() const;
        // Return &#39;true&#39; if this object is null, and &#39;false&#39; otherwise.

    int maxSupportedBdexVersion(int versionSelector) const;
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that it is highly recommended that &#39;versionSelector&#39;
        // be formatted as &quot;YYYYMMDD&quot;, a date representation.  Also note that
        // &#39;versionSelector&#39; should be a *compile*-time-chosen value that
        // selects a format version supported by both externalizer and
        // unexternalizer.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.


    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level          = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the (absolute
        // value of) the optionally specified indentation &#39;level&#39; and return a
        // reference to &#39;stream&#39;.  If &#39;level&#39; is specified, optionally specify
        // &#39;spacesPerLevel&#39;, the number of spaces per indentation level for
        // this and all of its nested objects.  If &#39;level&#39; is negative,
        // suppress indentation of the first line.  If &#39;spacesPerLevel&#39; is
        // negative, format the entire output on one line, suppressing all but
        // the initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is
        // not valid on entry, this operation has no effect.

    const TYPE&amp; value() const;
        // Return a reference providing non-modifiable access to the underlying
        // &#39;TYPE&#39; object.  The behavior is undefined unless this object is
        // non-null.

    TYPE valueOr(const TYPE&amp; value) const;
        // Return the value of the underlying &#39;TYPE&#39; object if this object is
        // non-null, and the specified &#39;value&#39; otherwise.  Note that this
        // method returns *by* *value*, so may be inefficient in some contexts.

    const TYPE *valueOr(const TYPE *value) const;
        // Return an address providing non-modifiable access to the underlying
        // &#39;TYPE&#39; object if this object is non-null, and the specified &#39;value&#39;
        // otherwise.

    const TYPE *valueOrNull() const;
        // Return an address providing non-modifiable access to the underlying
        // &#39;TYPE&#39; object if this object is non-null, and 0 otherwise.
};

// FREE OPERATORS
template &lt;class LHS_TYPE, class RHS_TYPE&gt;
bool operator==(const NullableValue&lt;LHS_TYPE&gt;&amp; lhs,
                const NullableValue&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; nullable objects have the
    // same value, and &#39;false&#39; otherwise.  Two nullable objects have the same
    // value if both are null, or if both are non-null and the values of their
    // underlying objects compare equal.  Note that this function will fail to
    // compile if &#39;LHS_TYPE&#39; and &#39;RHS_TYPE&#39; are not compatible.

template &lt;class LHS_TYPE, class RHS_TYPE&gt;
bool operator!=(const NullableValue&lt;LHS_TYPE&gt;&amp; lhs,
                const NullableValue&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; nullable objects do not
    // have the same value, and &#39;false&#39; otherwise.  Two nullable objects do not
    // have the same value if one is null and the other is non-null, or if both
    // are non-null and the values of their underlying objects do not compare
    // equal.  Note that this function will fail to compile if &#39;LHS_TYPE&#39; and
    // &#39;RHS_TYPE&#39; are not compatible.

template &lt;class TYPE&gt;
bool operator==(const NullableValue&lt;TYPE&gt;&amp; lhs,
                const TYPE&amp;                rhs);
template &lt;class TYPE&gt;
bool operator==(const TYPE&amp;                lhs,
                const NullableValue&lt;TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  A nullable object and a value of the
    // underlying &#39;TYPE&#39; have the same value if the nullable object is non-null
    // and its underlying value compares equal to the other value.

template &lt;class TYPE&gt;
bool operator!=(const NullableValue&lt;TYPE&gt;&amp; lhs,
                const TYPE&amp;                rhs);
template &lt;class TYPE&gt;
bool operator!=(const TYPE&amp;                lhs,
                const NullableValue&lt;TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same value, and &#39;false&#39; otherwise.  A nullable object and a value of the
    // underlying &#39;TYPE&#39; do not have the same value if either the nullable
    // object is null, or its underlying value does not compare equal to the
    // other value.

template &lt;class TYPE&gt;
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;              stream,
                         const NullableValue&lt;TYPE&gt;&amp; object);
    // Write the value of the specified &#39;object&#39; to the specified output
    // &#39;stream&#39; in a single-line format, and return a reference to &#39;stream&#39;.
    // If &#39;stream&#39; is not valid on entry, this operation has no effect.  Note
    // that this human-readable format is not fully specified, can change
    // without notice, and is logically equivalent to:
    //..
    //  print(stream, 0, -1);
    //..

// FREE FUNCTIONS
template &lt;class TYPE&gt;
void swap(NullableValue&lt;TYPE&gt;&amp; a, NullableValue&lt;TYPE&gt;&amp; b);
    // Efficiently exchange the values of the specified &#39;a&#39; and &#39;b&#39; objects.
    // This method provides the no-throw exception-safety guarantee if the
    // template parameter &#39;TYPE&#39; provides that guarantee and the result of the
    // &#39;isNull&#39; method for &#39;a&#39; and &#39;b&#39; is the same.  The behavior is undefined
    // unless both objects were created with the same allocator, if any.

               // =======================================
               // class NullableValue_WithAllocator&lt;TYPE&gt;
               // =======================================

template &lt;class TYPE&gt;
class NullableValue_WithAllocator {
    // This template class provides the implementation of &#39;NullableValue&#39; for
    // types that require an allocator.

    // DATA
    bsls::ObjectBuffer&lt;TYPE&gt;  d_buffer;       // in-place &#39;TYPE&#39; object

    bool                      d_isNull;       // &#39;true&#39; if null, otherwise
                                              // &#39;false&#39;

    bslma::Allocator         *d_allocator_p;  // held, not owned

  private:
    // FRIENDS
    friend class NullableValue&lt;TYPE&gt;;

  public:
    // CREATORS
    explicit NullableValue_WithAllocator(bslma::Allocator *basicAllocator = 0);
        // Create a nullable object having the null value.  Optionally specify
        // a &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    NullableValue_WithAllocator(
                       const NullableValue_WithAllocator&amp;  original,
                       bslma::Allocator                   *basicAllocator = 0);
        // Create a nullable object having the value of the specified
        // &#39;original&#39; object.  Optionally specify a &#39;basicAllocator&#39; used to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    ~NullableValue_WithAllocator();
        // Destroy this object.

    // MANIPULATORS
    NullableValue_WithAllocator&amp; operator=(
                                       const NullableValue_WithAllocator&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39;, and return a
        // reference providing modifiable access to this object.

    void swap(NullableValue_WithAllocator&amp; other);
        // Efficiently exchange the value of this object with the value of the
        // specified &#39;other&#39; object.  This method provides the no-throw
        // exception-safety guarantee if the template parameter &#39;TYPE&#39; provides
        // that guarantee and the result of the &#39;isNull&#39; method for the two
        // objects being swapped is the same.  The behavior is undefined unless
        // this object was created with the same allocator as &#39;other&#39;.

    void makeValue(const TYPE&amp; value);
        // Assign to this object the specified &#39;value&#39;.

    template &lt;class BDE_OTHER_TYPE&gt;
    void makeValue(const BDE_OTHER_TYPE&amp; value);
        // Assign to this object the specified &#39;value&#39; (of &#39;BDE_OTHER_TYPE&#39;)
        // converted to &#39;TYPE&#39;.  Note that this method will fail to compile if
        // &#39;TYPE and &#39;BDE_OTHER_TYPE&#39; are not compatible.

    void makeValue();
        // Assign to this object the default value for &#39;TYPE&#39;.

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
    template &lt;class... ARGS&gt;
    void makeValueInplace(ARGS&amp;&amp;... args);
        // Assign to this nullable object the value of the (template parameter)
        // &#39;TYPE&#39; (which has the &#39;bslma::UsesBslmaAllocator&#39; trait) created in
        // place using the specified &#39;args&#39;.  The object is also accessible via
        // the &#39;value&#39; method.  If this nullable object already contains a
        // object (&#39;false == isNull())&#39;, that object is destroyed before the
        // new object is created.  The allocator specified at the construction
        // of this nullable object is used to supply memory to the value
        // object.  Attempts to explicitly specify via &#39;args&#39; another allocator
        // to supply memory to the created (value) object are disallowed by the
        // compiler.  Note that if the constructor of &#39;TYPE&#39; throws an
        // exception this object is left in the null state.
#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Generator command line: sim_cpp11_features.pl --var-args=5 --output bdlb_nullablevalue.h
    void makeValueInplace();

    template &lt;class ARGS_1&gt;
    void makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1);

    template &lt;class ARGS_1,
              class ARGS_2&gt;
    void makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2);

    template &lt;class ARGS_1,
              class ARGS_2,
              class ARGS_3&gt;
    void makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3);

    template &lt;class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4&gt;
    void makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4);

    template &lt;class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4,
              class ARGS_5&gt;
    void makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5);

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template &lt;class... ARGS&gt;
    void makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);
// }}} END GENERATED CODE
#endif

    void reset();
        // Reset this object to the default constructed state (i.e., to have
        // the null value).

    TYPE&amp; value();
        // Return a reference providing modifiable access to the underlying
        // &#39;TYPE&#39; object.  The behavior is undefined unless this object is
        // non-null.

    // ACCESSORS
    bool isNull() const;
        // Return &#39;true&#39; if this object is null, and &#39;false&#39; otherwise.

    const TYPE&amp; value() const;
        // Return a reference providing non-modifiable access to the underlying
        // &#39;TYPE&#39; object.  The behavior is undefined unless this object is
        // non-null.
};

              // ==========================================
              // class NullableValue_WithoutAllocator&lt;TYPE&gt;
              // ==========================================

template &lt;class TYPE&gt;
class NullableValue_WithoutAllocator {
    // This template class provides the implementation of &#39;NullableValue&#39; for
    // types that do *not* require an allocator.

    // DATA
    bsls::ObjectBuffer&lt;TYPE&gt; d_buffer;  // in-place &#39;TYPE&#39; object
    bool                     d_isNull;  // &#39;true&#39; if null, otherwise &#39;false&#39;

  private:
    // FRIENDS
    friend class NullableValue&lt;TYPE&gt;;

  public:
    // CREATORS
    NullableValue_WithoutAllocator();
        // Create a nullable object having the null value.

    NullableValue_WithoutAllocator(
                               const NullableValue_WithoutAllocator&amp; original);
        // Create a nullable object having the value of the specified
        // &#39;original&#39; object.

    ~NullableValue_WithoutAllocator();
        // Destroy this object.

    // MANIPULATORS
    NullableValue_WithoutAllocator&amp; operator=(
                                    const NullableValue_WithoutAllocator&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39;, and return a
        // reference providing modifiable access to this object.

    void swap(NullableValue_WithoutAllocator&amp; other);
        // Efficiently exchange the value of this object with the value of the
        // specified &#39;other&#39; object.  This method provides the no-throw
        // exception-safety guarantee if the template parameter &#39;TYPE&#39; provides
        // that guarantee and the result of the &#39;isNull&#39; method for the two
        // objects being swapped is the same.

    void makeValue(const TYPE&amp; value);
        // Assign to this object the specified &#39;value&#39;.

    template &lt;class BDE_OTHER_TYPE&gt;
    void makeValue(const BDE_OTHER_TYPE&amp; value);
        // Assign to this object the specified &#39;value&#39; (of &#39;BDE_OTHER_TYPE&#39;)
        // converted to &#39;TYPE&#39;.  Note that this method will fail to compile if
        // &#39;TYPE and &#39;BDE_OTHER_TYPE&#39; are not compatible.

    void makeValue();
        // Assign to this object the default value for &#39;TYPE&#39;.

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
    template &lt;class... ARGS&gt;
    void makeValueInplace(ARGS&amp;&amp;... args);
        // Assign to this nullable object the value of the (template parameter)
        // &#39;TYPE&#39; (which does not have the &#39;bslma::UsesBslmaAllocator&#39; trait)
        // created in place using the specified &#39;args&#39;.  (The object is also
        // accessible via the &#39;value&#39; method).  If this nullable object already
        // contains an object (&#39;false == isNull())&#39;, that object is destroyed
        // before the new object is created.  Note that if the constructor of
        // &#39;TYPE&#39; throws an exception this object is left in the null state.
#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Generator command line: sim_cpp11_features.pl --var-args=5 --output bdlb_nullablevalue.h
    void makeValueInplace();

    template &lt;class ARGS_1&gt;
    void makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1);

    template &lt;class ARGS_1,
              class ARGS_2&gt;
    void makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2);

    template &lt;class ARGS_1,
              class ARGS_2,
              class ARGS_3&gt;
    void makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3);

    template &lt;class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4&gt;
    void makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4);

    template &lt;class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4,
              class ARGS_5&gt;
    void makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
                          BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5);

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
    template &lt;class... ARGS&gt;
    void makeValueInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);
// }}} END GENERATED CODE
#endif

    void reset();
        // Reset this object to the default constructed state (i.e., to have
        // the null value).

    TYPE&amp; value();
        // Return a reference providing modifiable access to the underlying
        // &#39;TYPE&#39; object.  The behavior is undefined unless this object is
        // non-null.

    // ACCESSORS
    bool isNull() const;
        // Return &#39;true&#39; if this object is null, and &#39;false&#39; otherwise.

    const TYPE&amp; value() const;
        // Return a reference providing non-modifiable access to the underlying
        // &#39;TYPE&#39; object.  The behavior is undefined unless this object is
        // non-null.
};

// ============================================================================
//                           INLINE DEFINITIONS
// ============================================================================

                      // -------------------------
                      // class NullableValue&lt;TYPE&gt;
                      // -------------------------

// CREATORS
template &lt;class TYPE&gt;
inline
NullableValue&lt;TYPE&gt;::NullableValue()
{
}

template &lt;class TYPE&gt;
inline
NullableValue&lt;TYPE&gt;::NullableValue(bslma::Allocator *basicAllocator)
: d_imp(basicAllocator)
{
}

template &lt;class TYPE&gt;
inline
NullableValue&lt;TYPE&gt;::NullableValue(const NullableValue&amp; original)
: d_imp(original.d_imp)
{
}

template &lt;class TYPE&gt;
inline
NullableValue&lt;TYPE&gt;::NullableValue(const NullableValue&amp;  original,
                                   bslma::Allocator     *basicAllocator)
: d_imp(original.d_imp, basicAllocator)
{
}

template &lt;class TYPE&gt;
inline
NullableValue&lt;TYPE&gt;::NullableValue(const TYPE&amp; value)
{
    d_imp.makeValue(value);
}

template &lt;class TYPE&gt;
inline
NullableValue&lt;TYPE&gt;::NullableValue(const TYPE&amp;       value,
                                   bslma::Allocator *basicAllocator)
: d_imp(basicAllocator)
{
    d_imp.makeValue(value);
}

template &lt;class TYPE&gt;
template &lt;class BDE_OTHER_TYPE&gt;
inline
NullableValue&lt;TYPE&gt;::NullableValue(
                                 const NullableValue&lt;BDE_OTHER_TYPE&gt;&amp; original)
{
    if (!original.isNull()) {
        d_imp.makeValue(original.value());
    }
}

template &lt;class TYPE&gt;
template &lt;class BDE_OTHER_TYPE&gt;
inline
NullableValue&lt;TYPE&gt;::NullableValue(
                          const NullableValue&lt;BDE_OTHER_TYPE&gt;&amp;  original,
                          bslma::Allocator                     *basicAllocator)
: d_imp(basicAllocator)
{
    if (!original.isNull()) {
        d_imp.makeValue(original.value());
    }
}

// MANIPULATORS
template &lt;class TYPE&gt;
inline
NullableValue&lt;TYPE&gt;&amp; NullableValue&lt;TYPE&gt;::operator=(const NullableValue&amp; rhs)
{
    d_imp = rhs.d_imp;

    return *this;
}

template &lt;class TYPE&gt;
template &lt;class BDE_OTHER_TYPE&gt;
NullableValue&lt;TYPE&gt;&amp; NullableValue&lt;TYPE&gt;::operator=(
                                      const NullableValue&lt;BDE_OTHER_TYPE&gt;&amp; rhs)
{
    if (rhs.isNull()) {
        d_imp.reset();
    }
    else {
        d_imp.makeValue(rhs.value());
    }
    return *this;
}

template &lt;class TYPE&gt;
inline
NullableValue&lt;TYPE&gt;&amp; NullableValue&lt;TYPE&gt;::operator=(const TYPE&amp; rhs)
{
    d_imp.makeValue(rhs);

    return *this;
}

template &lt;class TYPE&gt;
template &lt;class BDE_OTHER_TYPE&gt;
inline
NullableValue&lt;TYPE&gt;&amp; NullableValue&lt;TYPE&gt;::operator=(const BDE_OTHER_TYPE&amp; rhs)
{
    d_imp.makeValue(rhs);

    return *this;
}

template &lt;class TYPE&gt;
inline
void NullableValue&lt;TYPE&gt;::swap(NullableValue&lt;TYPE&gt;&amp; other)
{
    d_imp.swap(other.d_imp);
}

template &lt;class TYPE&gt;
inline
TYPE&amp; NullableValue&lt;TYPE&gt;::makeValue(const TYPE&amp; value)
{
    d_imp.makeValue(value);

    return d_imp.value();
}

template &lt;class TYPE&gt;
template &lt;class BDE_OTHER_TYPE&gt;
inline
TYPE&amp; NullableValue&lt;TYPE&gt;::makeValue(const BDE_OTHER_TYPE&amp; value)
{
    d_imp.makeValue(value);

    return d_imp.value();
}

template &lt;class TYPE&gt;
inline
TYPE&amp; NullableValue&lt;TYPE&gt;::makeValue()
{
    d_imp.makeValue();

    return d_imp.value();
}

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
template &lt;typename TYPE&gt;
template &lt;class... ARGS&gt;
inline
TYPE&amp; NullableValue&lt;TYPE&gt;::makeValueInplace(ARGS&amp;&amp;... args)
{
    d_imp.makeValueInplace(bsl::forward&lt;ARGS&gt;(args)...);
    return d_imp.value();
}
#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Generator command line: sim_cpp11_features.pl --var-args=5 --output bdlb_nullablevalue.h
template &lt;typename TYPE&gt;
inline
TYPE&amp; NullableValue&lt;TYPE&gt;::makeValueInplace(
                               )
{
    d_imp.makeValueInplace();
    return d_imp.value();
}

template &lt;typename TYPE&gt;
template &lt;class ARGS_1&gt;
inline
TYPE&amp; NullableValue&lt;TYPE&gt;::makeValueInplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1)
{
    d_imp.makeValueInplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1));
    return d_imp.value();
}

template &lt;typename TYPE&gt;
template &lt;class ARGS_1,
          class ARGS_2&gt;
inline
TYPE&amp; NullableValue&lt;TYPE&gt;::makeValueInplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2)
{
    d_imp.makeValueInplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                           BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2));
    return d_imp.value();
}

template &lt;typename TYPE&gt;
template &lt;class ARGS_1,
          class ARGS_2,
          class ARGS_3&gt;
inline
TYPE&amp; NullableValue&lt;TYPE&gt;::makeValueInplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3)
{
    d_imp.makeValueInplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                           BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2),
                           BSLS_COMPILERFEATURES_FORWARD(ARGS_3, args_3));
    return d_imp.value();
}

template &lt;typename TYPE&gt;
template &lt;class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4&gt;
inline
TYPE&amp; NullableValue&lt;TYPE&gt;::makeValueInplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4)
{
    d_imp.makeValueInplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                           BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2),
                           BSLS_COMPILERFEATURES_FORWARD(ARGS_3, args_3),
                           BSLS_COMPILERFEATURES_FORWARD(ARGS_4, args_4));
    return d_imp.value();
}

template &lt;typename TYPE&gt;
template &lt;class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5&gt;
inline
TYPE&amp; NullableValue&lt;TYPE&gt;::makeValueInplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5)
{
    d_imp.makeValueInplace(BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                           BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2),
                           BSLS_COMPILERFEATURES_FORWARD(ARGS_3, args_3),
                           BSLS_COMPILERFEATURES_FORWARD(ARGS_4, args_4),
                           BSLS_COMPILERFEATURES_FORWARD(ARGS_5, args_5));
    return d_imp.value();
}

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template &lt;typename TYPE&gt;
template &lt;class... ARGS&gt;
inline
TYPE&amp; NullableValue&lt;TYPE&gt;::makeValueInplace(
                               BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    d_imp.makeValueInplace(BSLS_COMPILERFEATURES_FORWARD(ARGS, args)...);
    return d_imp.value();
}
// }}} END GENERATED CODE
#endif

template &lt;class TYPE&gt;
template &lt;class STREAM&gt;
STREAM&amp; NullableValue&lt;TYPE&gt;::bdexStreamIn(STREAM&amp; stream, int version)
{
    using bslx::InStreamFunctions::bdexStreamIn;

    char isNull;

    stream.getInt8(isNull);

    if (stream) {
        if (!isNull) {
            d_imp.makeValue();

            bdexStreamIn(stream, d_imp.value(), version);
        }
        else {
            d_imp.reset();
        }
    }

    return stream;
}

template &lt;class TYPE&gt;
inline
void NullableValue&lt;TYPE&gt;::reset()
{
    d_imp.reset();
}

template &lt;class TYPE&gt;
inline
TYPE&amp; NullableValue&lt;TYPE&gt;::value()
{
    return d_imp.value();
}

// ACCESSORS
template &lt;class TYPE&gt;
template &lt;class STREAM&gt;
STREAM&amp; NullableValue&lt;TYPE&gt;::bdexStreamOut(STREAM&amp; stream, int version) const
{
    using bslx::OutStreamFunctions::bdexStreamOut;

    const bool isNull = d_imp.isNull();

    stream.putInt8(isNull ? 1 : 0);

    if (!isNull) {
        bdexStreamOut(stream, d_imp.value(), version);
    }

    return stream;
}

template &lt;class TYPE&gt;
inline
bool NullableValue&lt;TYPE&gt;::isNull() const
{
    return d_imp.isNull();
}

template &lt;class TYPE&gt;
inline
int NullableValue&lt;TYPE&gt;::maxSupportedBdexVersion(int versionSelector) const
{
    using bslx::VersionFunctions::maxSupportedBdexVersion;

    // We need to call the &#39;bslx::VersionFunctions&#39; helper function, because we
    // cannot guarantee that &#39;TYPE&#39; implements &#39;maxSupportedBdexVersion&#39; as a
    // class method.

    return maxSupportedBdexVersion(reinterpret_cast&lt;TYPE *&gt;(0),
                                   versionSelector);
}


template &lt;class TYPE&gt;
bsl::ostream&amp; NullableValue&lt;TYPE&gt;::print(bsl::ostream&amp; stream,
                                         int           level,
                                         int           spacesPerLevel) const
{
    if (d_imp.isNull()) {
        return bdlb::PrintMethods::print(stream,
                                         &quot;NULL&quot;,
                                         level,
                                         spacesPerLevel);             // RETURN
    }

    return bdlb::PrintMethods::print(stream,
                                     d_imp.value(),
                                     level,
                                     spacesPerLevel);
}

template &lt;class TYPE&gt;
inline
const TYPE&amp; NullableValue&lt;TYPE&gt;::value() const
{
    return d_imp.value();
}

template &lt;class TYPE&gt;
inline
const TYPE *NullableValue&lt;TYPE&gt;::valueOrNull() const
{
    return d_imp.isNull() ? 0 : &amp;d_imp.value();
}

template &lt;class TYPE&gt;
inline
TYPE NullableValue&lt;TYPE&gt;::valueOr(const TYPE&amp; value) const
{
    return d_imp.isNull() ? value : d_imp.value();
}

template &lt;class TYPE&gt;
inline
const TYPE *NullableValue&lt;TYPE&gt;::valueOr(const TYPE *value) const
{
    return d_imp.isNull() ? value : &amp;d_imp.value();
}

}  // close package namespace

// FREE OPERATORS
template &lt;class LHS_TYPE, class RHS_TYPE&gt;
inline
bool bdlb::operator==(const NullableValue&lt;LHS_TYPE&gt;&amp; lhs,
                      const NullableValue&lt;RHS_TYPE&gt;&amp; rhs)
{
    if (!lhs.isNull() &amp;&amp; !rhs.isNull()) {
        return lhs.value() == rhs.value();                            // RETURN
    }

    return lhs.isNull() == rhs.isNull();
}

template &lt;class TYPE&gt;
inline
bool bdlb::operator==(const NullableValue&lt;TYPE&gt;&amp; lhs,
                      const TYPE&amp;                rhs)
{
    return !lhs.isNull() &amp;&amp; lhs.value() == rhs;
}

template &lt;class TYPE&gt;
inline
bool bdlb::operator==(const TYPE&amp;                lhs,
                      const NullableValue&lt;TYPE&gt;&amp; rhs)
{
    return !rhs.isNull() &amp;&amp; rhs.value() == lhs;
}

template &lt;class LHS_TYPE, class RHS_TYPE&gt;
inline
bool bdlb::operator!=(const NullableValue&lt;LHS_TYPE&gt;&amp; lhs,
                      const NullableValue&lt;RHS_TYPE&gt;&amp; rhs)
{
    if (!lhs.isNull() &amp;&amp; !rhs.isNull()) {
        return lhs.value() != rhs.value();                            // RETURN
    }

    return lhs.isNull() != rhs.isNull();
}

template &lt;class TYPE&gt;
inline
bool bdlb::operator!=(const NullableValue&lt;TYPE&gt;&amp; lhs,
                      const TYPE&amp;                rhs)
{
    return lhs.isNull() || lhs.value() != rhs;
}

template &lt;class TYPE&gt;
inline
bool bdlb::operator!=(const TYPE&amp;                lhs,
                      const NullableValue&lt;TYPE&gt;&amp; rhs)
{
    return rhs.isNull() || rhs.value() != lhs;
}

template &lt;class TYPE&gt;
inline
bsl::ostream&amp; bdlb::operator&lt;&lt;(bsl::ostream&amp;              stream,
                               const NullableValue&lt;TYPE&gt;&amp; object)
{
    return object.print(stream, 0, -1);
}

// FREE FUNCTIONS
template &lt;class TYPE&gt;
inline
void bdlb::swap(NullableValue&lt;TYPE&gt;&amp; a, NullableValue&lt;TYPE&gt;&amp; b)
{
    a.swap(b);
}

namespace bdlb {

               // ---------------------------------------
               // class NullableValue_WithAllocator&lt;TYPE&gt;
               // ---------------------------------------

// CREATORS
template &lt;class TYPE&gt;
inline
NullableValue_WithAllocator&lt;TYPE&gt;::NullableValue_WithAllocator(
                                              bslma::Allocator *basicAllocator)
: d_isNull(true)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

template &lt;class TYPE&gt;
inline
NullableValue_WithAllocator&lt;TYPE&gt;::NullableValue_WithAllocator(
                            const NullableValue_WithAllocator&amp;  original,
                            bslma::Allocator                   *basicAllocator)
: d_isNull(true)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
    if (!original.isNull()) {
        makeValue(original.value());
    }
}

template &lt;class TYPE&gt;
inline
NullableValue_WithAllocator&lt;TYPE&gt;::~NullableValue_WithAllocator()
{
    reset();
}

// MANIPULATORS
template &lt;class TYPE&gt;
NullableValue_WithAllocator&lt;TYPE&gt;&amp;
NullableValue_WithAllocator&lt;TYPE&gt;::operator=(
                                        const NullableValue_WithAllocator&amp; rhs)
{
    if (!rhs.isNull()) {
        makeValue(rhs.value());
    }
    else {
        reset();
    }

    return *this;
}

template &lt;class TYPE&gt;
void NullableValue_WithAllocator&lt;TYPE&gt;::swap(
                                            NullableValue_WithAllocator&amp; other)
{
    // &#39;swap&#39; is undefined for non-equal allocators.

    BSLS_ASSERT(d_allocator_p == other.d_allocator_p);

    // same &#39;isNull&#39; flags

    if (isNull() &amp;&amp; other.isNull()) {
        return;                                                       // RETURN
    }

    if (!isNull() &amp;&amp; !other.isNull()) {
        // swap underlying values

        bslalg::SwapUtil::swap(&amp;this-&gt;value(), &amp;other.value());
        return;                                                       // RETURN
    }

    // different &#39;isNull&#39; flags

    NullableValue_WithAllocator *nullObj;
    NullableValue_WithAllocator *nonNullObj;

    if (isNull()) {
        nullObj    = this;
        nonNullObj = &amp;other;
    }
    else {
        nullObj    = &amp;other;
        nonNullObj = this;
    }

    // Copy-construct and reset.

    nullObj-&gt;makeValue(nonNullObj-&gt;value());  // This can throw, so &#39;swap&#39; is
                                              // only strongly exception-safe.
    nonNullObj-&gt;reset();
}

template &lt;class TYPE&gt;
void NullableValue_WithAllocator&lt;TYPE&gt;::makeValue(const TYPE&amp; value)
{
    if (d_isNull) {
        new (d_buffer.buffer()) TYPE(value, d_allocator_p);
        d_isNull = false;
    }
    else {
        d_buffer.object() = value;
    }
}

template &lt;class TYPE&gt;
template &lt;class BDE_OTHER_TYPE&gt;
void NullableValue_WithAllocator&lt;TYPE&gt;::makeValue(const BDE_OTHER_TYPE&amp; value)
{
    if (d_isNull) {
        new (d_buffer.buffer()) TYPE(value, d_allocator_p);
        d_isNull = false;
    }
    else {
        d_buffer.object() = value;
    }
}

template &lt;class TYPE&gt;
inline
void NullableValue_WithAllocator&lt;TYPE&gt;::makeValue()
{
    reset();

    new (d_buffer.buffer()) TYPE(d_allocator_p);
    d_isNull = false;

    // Note that this alternative implementation provides stronger
    // exception-safety, but it breaks some client code that uses
    // &#39;NullableValue&#39; with a non-value-semantic &#39;TYPE&#39;.
    //..
    //  if (d_isNull) {
    //      new (d_buffer.buffer()) TYPE(d_allocator_p);
    //      d_isNull = false;
    //  }
    //  else {
    //      d_buffer.object() = TYPE(d_allocator_p);
    //  }
    //..
}

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
template &lt;typename TYPE&gt;
template &lt;class... ARGS&gt;
inline
void NullableValue_WithAllocator&lt;TYPE&gt;::makeValueInplace(ARGS&amp;&amp;... args)
{
    reset();
    new (d_buffer.buffer()) TYPE(bsl::forward&lt;ARGS&gt;(args)..., d_allocator_p);
    d_isNull = false;
}
#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Generator command line: sim_cpp11_features.pl --var-args=5 --output bdlb_nullablevalue.h
template &lt;typename TYPE&gt;
inline
void NullableValue_WithAllocator&lt;TYPE&gt;::makeValueInplace(
                               )
{
    reset();
    new (d_buffer.buffer()) TYPE(d_allocator_p);
    d_isNull = false;
}

template &lt;typename TYPE&gt;
template &lt;class ARGS_1&gt;
inline
void NullableValue_WithAllocator&lt;TYPE&gt;::makeValueInplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1)
{
    reset();
    new (d_buffer.buffer()) TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS_1,
                                 args_1), d_allocator_p);
    d_isNull = false;
}

template &lt;typename TYPE&gt;
template &lt;class ARGS_1,
          class ARGS_2&gt;
inline
void NullableValue_WithAllocator&lt;TYPE&gt;::makeValueInplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2)
{
    reset();
    new (d_buffer.buffer()) TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS_1,
                                 args_1),
                                 BSLS_COMPILERFEATURES_FORWARD(ARGS_2,
                                 args_2), d_allocator_p);
    d_isNull = false;
}

template &lt;typename TYPE&gt;
template &lt;class ARGS_1,
          class ARGS_2,
          class ARGS_3&gt;
inline
void NullableValue_WithAllocator&lt;TYPE&gt;::makeValueInplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3)
{
    reset();
    new (d_buffer.buffer()) TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS_1,
                                 args_1),
                                 BSLS_COMPILERFEATURES_FORWARD(ARGS_2,
                                 args_2),
                                 BSLS_COMPILERFEATURES_FORWARD(ARGS_3,
                                 args_3), d_allocator_p);
    d_isNull = false;
}

template &lt;typename TYPE&gt;
template &lt;class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4&gt;
inline
void NullableValue_WithAllocator&lt;TYPE&gt;::makeValueInplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4)
{
    reset();
    new (d_buffer.buffer()) TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS_1,
                                 args_1),
                                 BSLS_COMPILERFEATURES_FORWARD(ARGS_2,
                                 args_2),
                                 BSLS_COMPILERFEATURES_FORWARD(ARGS_3,
                                 args_3),
                                 BSLS_COMPILERFEATURES_FORWARD(ARGS_4,
                                 args_4), d_allocator_p);
    d_isNull = false;
}

template &lt;typename TYPE&gt;
template &lt;class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5&gt;
inline
void NullableValue_WithAllocator&lt;TYPE&gt;::makeValueInplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5)
{
    reset();
    new (d_buffer.buffer()) TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS_1,
                                 args_1),
                                 BSLS_COMPILERFEATURES_FORWARD(ARGS_2,
                                 args_2),
                                 BSLS_COMPILERFEATURES_FORWARD(ARGS_3,
                                 args_3),
                                 BSLS_COMPILERFEATURES_FORWARD(ARGS_4,
                                 args_4),
                                 BSLS_COMPILERFEATURES_FORWARD(ARGS_5,
                                 args_5), d_allocator_p);
    d_isNull = false;
}

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template &lt;typename TYPE&gt;
template &lt;class... ARGS&gt;
inline
void NullableValue_WithAllocator&lt;TYPE&gt;::makeValueInplace(
                               BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    reset();
    new (d_buffer.buffer()) TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS,
                                 args)..., d_allocator_p);
    d_isNull = false;
}
// }}} END GENERATED CODE
#endif

template &lt;class TYPE&gt;
inline
void NullableValue_WithAllocator&lt;TYPE&gt;::reset()
{
    if (!d_isNull) {
        d_buffer.object().~TYPE();
        d_isNull = true;
    }
}

template &lt;class TYPE&gt;
inline
TYPE&amp; NullableValue_WithAllocator&lt;TYPE&gt;::value()
{
    BSLS_ASSERT_SAFE(!d_isNull);

    return d_buffer.object();
}

// ACCESSORS
template &lt;class TYPE&gt;
inline
bool NullableValue_WithAllocator&lt;TYPE&gt;::isNull() const
{
    return d_isNull;
}

template &lt;class TYPE&gt;
inline
const TYPE&amp; NullableValue_WithAllocator&lt;TYPE&gt;::value() const
{
    BSLS_ASSERT_SAFE(!d_isNull);

    return d_buffer.object();
}

              // ------------------------------------------
              // class NullableValue_WithoutAllocator&lt;TYPE&gt;
              // ------------------------------------------

// CREATORS
template &lt;class TYPE&gt;
inline
NullableValue_WithoutAllocator&lt;TYPE&gt;::NullableValue_WithoutAllocator()
: d_isNull(true)
{
}

template &lt;class TYPE&gt;
inline
NullableValue_WithoutAllocator&lt;TYPE&gt;::
NullableValue_WithoutAllocator(const NullableValue_WithoutAllocator&amp; original)
: d_isNull(true)
{
    if (!original.isNull()) {
        makeValue(original.value());
    }
}

template &lt;class TYPE&gt;
inline
NullableValue_WithoutAllocator&lt;TYPE&gt;::~NullableValue_WithoutAllocator()
{
    reset();
}

// MANIPULATORS
template &lt;class TYPE&gt;
NullableValue_WithoutAllocator&lt;TYPE&gt;&amp;
NullableValue_WithoutAllocator&lt;TYPE&gt;::operator=(
                                     const NullableValue_WithoutAllocator&amp; rhs)
{
    if (!rhs.isNull()) {
        makeValue(rhs.value());
    }
    else {
        reset();
    }

    return *this;
}

template &lt;class TYPE&gt;
void NullableValue_WithoutAllocator&lt;TYPE&gt;::swap(
                                         NullableValue_WithoutAllocator&amp; other)
{
    // same &#39;isNull&#39; flags

    if (isNull() &amp;&amp; other.isNull()) {
        return;                                                       // RETURN
    }

    if (!isNull() &amp;&amp; !other.isNull()) {
        // swap underlying values

        bslalg::SwapUtil::swap(&amp;this-&gt;value(), &amp;other.value());
        return;                                                       // RETURN
    }

    // different &#39;isNull&#39; flags

    NullableValue_WithoutAllocator *nullObj;
    NullableValue_WithoutAllocator *nonNullObj;

    if (isNull()) {
        nullObj    = this;
        nonNullObj = &amp;other;
    }
    else {
        nullObj    = &amp;other;
        nonNullObj = this;
    }

    // Copy-construct and reset.

    nullObj-&gt;makeValue(nonNullObj-&gt;value());  // This can throw, so &#39;swap&#39; is
                                              // only strongly exception-safe.
    nonNullObj-&gt;reset();
}

template &lt;class TYPE&gt;
void NullableValue_WithoutAllocator&lt;TYPE&gt;::makeValue(const TYPE&amp; value)
{
    if (d_isNull) {
        new (d_buffer.buffer()) TYPE(value);
        d_isNull = false;
    }
    else {
        d_buffer.object() = value;
    }
}

template &lt;class TYPE&gt;
template &lt;class BDE_OTHER_TYPE&gt;
void NullableValue_WithoutAllocator&lt;TYPE&gt;::makeValue(
                                                   const BDE_OTHER_TYPE&amp; value)
{
    if (d_isNull) {
        new (d_buffer.buffer()) TYPE(value);
        d_isNull = false;
    }
    else {
        d_buffer.object() = value;
    }
}

template &lt;class TYPE&gt;
inline
void NullableValue_WithoutAllocator&lt;TYPE&gt;::makeValue()
{
    reset();

    new (d_buffer.buffer()) TYPE();
    d_isNull = false;

    // Note that this alternative implementation provides stronger
    // exception-safety, but it breaks some client code that uses
    // &#39;NullableValue&#39; with a non-value-semantic &#39;TYPE&#39;.
    //..
    //  if (d_isNull) {
    //      new (d_buffer.buffer()) TYPE();
    //      d_isNull = false;
    //  }
    //  else {
    //      d_buffer.object() = TYPE();
    //  }
    //..
}

#if !BSLS_COMPILERFEATURES_SIMULATE_CPP11_FEATURES
template &lt;typename TYPE&gt;
template &lt;class... ARGS&gt;
inline
void NullableValue_WithoutAllocator&lt;TYPE&gt;::makeValueInplace(ARGS&amp;&amp;... args)
{
    reset();
    new (d_buffer.buffer()) TYPE(bsl::forward&lt;ARGS&gt;(args)...);
    d_isNull = false;
}
#elif BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// The following section is automatically generated.  **DO NOT EDIT**
// Generator command line: sim_cpp11_features.pl --var-args=5 --output bdlb_nullablevalue.h
template &lt;typename TYPE&gt;
inline
void NullableValue_WithoutAllocator&lt;TYPE&gt;::makeValueInplace(
                               )
{
    reset();
    new (d_buffer.buffer()) TYPE();
    d_isNull = false;
}

template &lt;typename TYPE&gt;
template &lt;class ARGS_1&gt;
inline
void NullableValue_WithoutAllocator&lt;TYPE&gt;::makeValueInplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1)
{
    reset();
    new (d_buffer.buffer()) TYPE(
                                BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1));
    d_isNull = false;
}

template &lt;typename TYPE&gt;
template &lt;class ARGS_1,
          class ARGS_2&gt;
inline
void NullableValue_WithoutAllocator&lt;TYPE&gt;::makeValueInplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2)
{
    reset();
    new (d_buffer.buffer()) TYPE(
                                BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                                BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2));
    d_isNull = false;
}

template &lt;typename TYPE&gt;
template &lt;class ARGS_1,
          class ARGS_2,
          class ARGS_3&gt;
inline
void NullableValue_WithoutAllocator&lt;TYPE&gt;::makeValueInplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3)
{
    reset();
    new (d_buffer.buffer()) TYPE(
                                BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                                BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2),
                                BSLS_COMPILERFEATURES_FORWARD(ARGS_3, args_3));
    d_isNull = false;
}

template &lt;typename TYPE&gt;
template &lt;class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4&gt;
inline
void NullableValue_WithoutAllocator&lt;TYPE&gt;::makeValueInplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4)
{
    reset();
    new (d_buffer.buffer()) TYPE(
                                BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                                BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2),
                                BSLS_COMPILERFEATURES_FORWARD(ARGS_3, args_3),
                                BSLS_COMPILERFEATURES_FORWARD(ARGS_4, args_4));
    d_isNull = false;
}

template &lt;typename TYPE&gt;
template &lt;class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5&gt;
inline
void NullableValue_WithoutAllocator&lt;TYPE&gt;::makeValueInplace(
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
                              BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5)
{
    reset();
    new (d_buffer.buffer()) TYPE(
                                BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                                BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2),
                                BSLS_COMPILERFEATURES_FORWARD(ARGS_3, args_3),
                                BSLS_COMPILERFEATURES_FORWARD(ARGS_4, args_4),
                                BSLS_COMPILERFEATURES_FORWARD(ARGS_5, args_5));
    d_isNull = false;
}

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template &lt;typename TYPE&gt;
template &lt;class... ARGS&gt;
inline
void NullableValue_WithoutAllocator&lt;TYPE&gt;::makeValueInplace(
                               BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    reset();
    new (d_buffer.buffer()) TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS, args)...);
    d_isNull = false;
}
// }}} END GENERATED CODE
#endif

template &lt;class TYPE&gt;
inline
void NullableValue_WithoutAllocator&lt;TYPE&gt;::reset()
{
    if (!d_isNull) {
        d_buffer.object().~TYPE();
        d_isNull = true;
    }
}

template &lt;class TYPE&gt;
inline
TYPE&amp; NullableValue_WithoutAllocator&lt;TYPE&gt;::value()
{
    BSLS_ASSERT_SAFE(!d_isNull);

    return d_buffer.object();
}

// ACCESSORS
template &lt;class TYPE&gt;
inline
bool NullableValue_WithoutAllocator&lt;TYPE&gt;::isNull() const
{
    return d_isNull;
}

template &lt;class TYPE&gt;
inline
const TYPE&amp; NullableValue_WithoutAllocator&lt;TYPE&gt;::value() const
{
    BSLS_ASSERT_SAFE(!d_isNull);

    return d_buffer.object();
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
