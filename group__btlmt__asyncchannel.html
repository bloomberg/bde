<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlmt_asyncchannel Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlmt_asyncchannel<br/>
<small>
[<a class="el" href="group__btlmt.html">Package btlmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a protocol for asynchronous IO operations.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlb.html">btlb</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlmt.html">btlmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Implementing a Concrete Channel Type</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a protocol for asynchronous IO operations </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlmt_1_1AsyncChannel.html">btlmt::AsyncChannel</a> </td><td><em>pure</em> protocol for asynchronous IO operations  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlmt__channelpoolchannel.html" title="Provide a concrete implementation of btlmt::AsyncChannel">Component btlmt_channelpoolchannel</a>, <a class="el" href="group__btlmt__sessionpool.html" title="Provide thread-enabled session-based IPv4 communication.">Component btlmt_sessionpool</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a pure protocol, <code><a class="el" href="classbtlmt_1_1AsyncChannel.html">btlmt::AsyncChannel</a></code>, for asynchronous read and write operations over TCP/IP communication channel. Concrete implementations of this protocol are intended to be used with <code>btlmt_sessionpool</code> and will rarely be used stand-alone. A concrete implementation of this protocol is provided in <code>btlmt_channelpoolchannel</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_implementing_a_concrete_channel_type"></a> <a class="anchor" id="usage.example_1~3A_implementing_a_concrete_channel_type"></a> <a class="anchor" id="description.usage.example_1~3A_implementing_a_concrete_channel_type"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Implementing a Concrete Channel Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This <code>class</code>, <code><a class="el" href="classbtlmt_1_1AsyncChannel.html">btlmt::AsyncChannel</a></code>, provides a pure protocol for a network connection type that once connected to the peer allows asynchronous reads and writes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this usage example we will implement a derived implementation of <code><a class="el" href="classbtlmt_1_1AsyncChannel.html">btlmt::AsyncChannel</a></code>, <code>my_AsyncChannel</code>. An object of this type is constructed with a <code><a class="el" href="classbtlmt_1_1ChannelPool.html">btlmt::ChannelPool</a></code> object and provided a channel id that represents this connection in that channel pool object. For the brevity of this example, we will elide some portions of the class implementation including error checking for connection closure and synchronizing access to a <code>my_AsyncChannel</code> across multiple threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we provide the class definition: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_AsyncChannel : <span class="keyword">public</span> btlmt::AsyncChannel {
      <span class="comment">// This &#39;class&#39; provides a concrete implementation of</span>
      <span class="comment">// &#39;btlmt::AsyncChannel&#39;.</span>
</pre></div><br/>
<br/>
 Next, we specify an <code>Entry</code> type that stores the data corresponding to a read callback: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// TYPES</span>
      <span class="keyword">struct </span>Entry {
          <span class="comment">// This &#39;struct&#39; provides a type storing the attributes of a read</span>
          <span class="comment">// callback.</span>

          BlobBasedReadCallback d_readCallback;    <span class="comment">// read callback</span>

          <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>    d_timeOut;         <span class="comment">// optional read timeout</span>

          <span class="keywordtype">int</span>                   d_numBytesNeeded;  <span class="comment">// number of bytes needed</span>
                                                   <span class="comment">// before to invoke the</span>
                                                   <span class="comment">// read callback</span>
      };

      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;Entry&gt;</a> ReadQueue;
</pre></div><br/>
<br/>
 Then, we specify the data for this type. This type stores a <code><a class="el" href="classbtlmt_1_1ChannelPool.html">btlmt::ChannelPool</a></code>, the channelId in that channel pool used to represent this connection, and a vector storing all the read callbacks: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span>                 d_channelId;
      <a class="code" href="classbtlmt_1_1ChannelPool.html">btlmt::ChannelPool</a> *d_channelPool_p;
      ReadQueue           d_entries;
</pre></div><br/>
<br/>
 Next, we specify the interface of this class: <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_AsyncChannel(<span class="keywordtype">int</span>                 channelId,
                      <a class="code" href="classbtlmt_1_1ChannelPool.html">btlmt::ChannelPool</a> *channelPool,
                      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *basicAllocator = 0);
          <span class="comment">// Create a &#39;my_AsyncChannel&#39; concrete implementation reading from</span>
          <span class="comment">// and writing to the channel referenced by the specified</span>
          <span class="comment">// &#39;channelId&#39; in the specified &#39;channelPool&#39;.  Optionally specify</span>
          <span class="comment">// a &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39;</span>
          <span class="comment">// is 0, the currently installed default allocator is used.</span>

      <span class="keyword">virtual</span> ~my_AsyncChannel();
          <span class="comment">// Destroy this channel.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keyword">virtual</span> <span class="keywordtype">int</span> read(<span class="keywordtype">int</span>                          numBytes,
                       <span class="keyword">const</span> BlobBasedReadCallback&amp; readCallback);
          <span class="comment">// Initiate an asynchronous read operation on this channel, or</span>
          <span class="comment">// append this request to the currently pending requests if an</span>
          <span class="comment">// asynchronous read operation was already initiated.  When at</span>
          <span class="comment">// least the specified &#39;numBytes&#39; of data are available after all</span>
          <span class="comment">// previous requests have been processed, if any, the specified</span>
          <span class="comment">// &#39;readCallback&#39; will be invoked (with</span>
          <span class="comment">// &#39;btlmt::AsyncChannel::e_SUCCESS&#39;).  Return 0 on success, and a</span>
          <span class="comment">// non-zero value otherwise.  On error, the return value *may*</span>
          <span class="comment">// equal to one of the enumerators in &#39;ChannelStatus::Enum&#39;.</span>

      <span class="keyword">virtual</span> <span class="keywordtype">int</span> timedRead(<span class="keywordtype">int</span>                          numBytes,
                            <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp;    timeOut,
                            <span class="keyword">const</span> BlobBasedReadCallback&amp; readCallback);
          <span class="comment">// Initiate an asynchronous timed read operation on this channel,</span>
          <span class="comment">// or append this request to the currently pending requests if an</span>
          <span class="comment">// asynchronous read operation was already initiated, with an</span>
          <span class="comment">// associated specified absolute &#39;timeOut&#39;.  When at least the</span>
          <span class="comment">// specified &#39;numBytes&#39; of data are available after all previous</span>
          <span class="comment">// requests have been processed, if any, or when the &#39;timeOut&#39; is</span>
          <span class="comment">// reached, the specified &#39;readCallback&#39; will be invoked (with</span>
          <span class="comment">// either &#39;btlmt::AsyncChannel::e_SUCCESS&#39; or</span>
          <span class="comment">// &#39;btlmt::AsyncChannel::e_TIMEOUT&#39;, respectively).  Return 0 on</span>
          <span class="comment">// success, and a non-zero value otherwise.  On error, the return</span>
          <span class="comment">// value *may* equal to one of the enumerators in</span>
          <span class="comment">// &#39;ChannelStatus::Enum&#39;.</span>

      <span class="keyword">virtual</span> <span class="keywordtype">int</span> write(<span class="keyword">const</span> <a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a>&amp; blob,
                        <span class="keywordtype">int</span>               highWaterMark = INT_MAX);
          <span class="comment">// Enqueue the specified &#39;blob&#39; message to be written to this</span>
          <span class="comment">// channel.  Optionally provide &#39;highWaterMark&#39; to specify the</span>
          <span class="comment">// maximum data size that can be enqueued.  If &#39;highWaterMark&#39; is</span>
          <span class="comment">// not specified then &#39;INT_MAX&#39; is used.  Return 0 on success, and</span>
          <span class="comment">// a non-zero value otherwise.  On error, the return value *may*</span>
          <span class="comment">// equal to one of the enumerators in &#39;ChannelStatus::Enum&#39;.  Note</span>
          <span class="comment">// that success does not imply that the data has been written or</span>
          <span class="comment">// will be successfully written to the underlying stream used by</span>
          <span class="comment">// this channel.  Also note that in addition to &#39;highWatermark&#39;</span>
          <span class="comment">// the enqueued portion must also be less than a high watermark</span>
          <span class="comment">// value supplied at the construction of this channel for the</span>
          <span class="comment">// write to succeed.</span>

      <span class="keyword">virtual</span> <span class="keywordtype">int</span> setSocketOption(<span class="keywordtype">int</span> option, <span class="keywordtype">int</span> level, <span class="keywordtype">int</span> value);
          <span class="comment">// Set the specified &#39;option&#39; (of the specified &#39;level&#39;) socket</span>
          <span class="comment">// option on this channel to the specified &#39;value&#39;.  Return 0 on</span>
          <span class="comment">// success and a non-zero value otherwise.  (See</span>
          <span class="comment">// &#39;btlso_socketoptutil&#39; for the list of commonly supported</span>
          <span class="comment">// options.)</span>

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> cancelRead();
          <span class="comment">// Cancel all pending &#39;read&#39; or &#39;timedRead&#39; requests, and invoke</span>
          <span class="comment">// their read callbacks with a &#39;btlmt::AsyncChannel::e_CANCELED&#39;</span>
          <span class="comment">// status.  Note that if the channel is active, the read callbacks</span>
          <span class="comment">// are invoked in the thread in which the channel&#39;s data callbacks</span>
          <span class="comment">// are invoked, else they are invoked in the thread calling</span>
          <span class="comment">// &#39;cancelRead&#39;.</span>

      <span class="keyword">virtual</span> <span class="keywordtype">void</span> close();
          <span class="comment">// Shutdown this channel, and cancel all pending requests.  Note</span>
          <span class="comment">// that this call will result in the shutdown of the channel pool</span>
          <span class="comment">// channel associated with the channel, and will not invoke the</span>
          <span class="comment">// pending read requests.</span>
</pre></div><br/>
<br/>
 Then, we define a method, <code>blobBasedReadCb</code>, that can be invoked by a higher level component after reading data from the channel pool held by this object on the channel id represented by this object. Note that the <code>read</code> and <code>timedRead</code> methods of this type are asynchronous and they do not directly result in any data being read from the network. Instead, this type relies on a higher class (like <code><a class="el" href="classbtlmt_1_1SessionPool.html">btlmt::SessionPool</a></code>) for the data reads: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">void</span> blobBasedReadCb(<span class="keywordtype">int</span> *numNeeded, <a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a> *msg);
          <span class="comment">// This method is invoked in response to a blob based channel pool</span>
          <span class="comment">// data callback on the channel id associated with this channel,</span>
          <span class="comment">// and invokes the pending read requests until either more data is</span>
          <span class="comment">// needed or this channel is closed.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">virtual</span> <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> localAddress() <span class="keyword">const</span>;
          <span class="comment">// Return the address of the &quot;local&quot; end of the channel.</span>

      <span class="keyword">virtual</span> <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> peerAddress() <span class="keyword">const</span>;
          <span class="comment">// Return the address of the &quot;remote&quot; end of the channel.</span>
  };
</pre></div><br/>
<br/>
 Then, we provide the function implementations: <br/>
<br/>
<div class="fragment"><pre class="fragment">  my_AsyncChannel::my_AsyncChannel(<span class="keywordtype">int</span>                 channelId,
                                   <a class="code" href="classbtlmt_1_1ChannelPool.html">btlmt::ChannelPool</a> *channelPool,
                                   <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>   *basicAllocator)
  : d_channelId(channelId)
  , d_channelPool_p(channelPool)
  , d_entries(basicAllocator)
  {
  }

  my_AsyncChannel::~my_AsyncChannel()
  {
      <span class="comment">// Cancel future callbacks, but do not invoke them if this channel is</span>
      <span class="comment">// closed.</span>

      cancelRead();
      d_channelPool_p-&gt;shutdown(d_channelId);
  }

  <span class="keywordtype">int</span> my_AsyncChannel::read(<span class="keywordtype">int</span>                          numBytes,
                            <span class="keyword">const</span> BlobBasedReadCallback&amp; readCallback)
  {
      <span class="keywordflow">return</span> timedRead(numBytes, <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(), readCallback);
  }

  <span class="keywordtype">int</span> my_AsyncChannel::timedRead(<span class="keywordtype">int</span>                          numBytes,
                                 <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp;    timeOut,
                                 <span class="keyword">const</span> BlobBasedReadCallback&amp; readCallback)
  {
      Entry entry;
      entry.d_numBytesNeeded = numBytes;
      entry.d_timeOut        = timeOut;
      entry.d_readCallback   = readCallback;

      <span class="keywordflow">if</span> (<a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(0) != timeOut) {
          <span class="comment">// Register a callback to be invoked when timeout expires (elided</span>
          <span class="comment">// for brevity).</span>

          <span class="comment">// . . .</span>
      }
      d_entries.push_back(entry);
  }

  <span class="keywordtype">int</span> my_AsyncChannel::write(<span class="keyword">const</span> <a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a>&amp; blob,
                             <span class="keywordtype">int</span>               highWaterMark)
  {
      <span class="keywordflow">return</span> d_channelPool_p-&gt;write(d_channelId, blob, highWaterMark);
  }

  <span class="keywordtype">int</span> my_AsyncChannel::setSocketOption(<span class="keywordtype">int</span> option, <span class="keywordtype">int</span> level, <span class="keywordtype">int</span> value)
  {
      <span class="keywordflow">return</span> d_channelPool_p-&gt;setSocketOption(option,
                                              level,
                                              value,
                                              d_channelId);
  }

  <span class="keywordtype">void</span> my_AsyncChannel::cancelRead()
  {
      ReadQueue::iterator iter = d_entries.begin();
      ReadQueue::iterator end  = d_entries.end();

      <span class="keywordtype">int</span>        dummy = 0;
      <a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a> dummyBlob;
      <span class="keywordflow">for</span> (iter = d_entries.begin(); iter != end; ++iter) {
          BlobBasedReadCallback callback = iter-&gt;d_readCallback;

          callback(<a class="code" href="classbtlmt_1_1AsyncChannel.html#ad108cc12b44c814135812903da49551fae89cb167dc0c7381d150577a6cfd96f4">btlmt::AsyncChannel::e_CANCELED</a>,
                   &amp;dummy,
                   &amp;dummyBlob,
                   d_channelId);
      }

      d_entries.erase(iter, end);
  }

  <span class="keywordtype">void</span> my_AsyncChannel::close()
  {
      d_channelPool_p-&gt;shutdown(d_channelId);

      ReadQueue::iterator iter = d_entries.begin();
      ReadQueue::iterator end  = d_entries.end();

      <span class="keywordflow">for</span> (iter = d_entries.begin(); iter != end; ++iter) {
          <span class="keywordflow">if</span> (<a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(0) != iter-&gt;d_timeOut) {
              <span class="comment">// Deregister timeout.  Not shown here.</span>

              <span class="comment">// . . .</span>
          }
      }

      d_entries.erase(iter, end);
  }

  <span class="keywordtype">void</span> my_AsyncChannel::blobBasedReadCb(<span class="keywordtype">int</span> *numNeeded, <a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a> *msg)
  {
      *numNeeded            = 1;
      <span class="keywordtype">int</span> numBytesAvailable = msg-&gt;<a class="code" href="classbtlb_1_1Blob.html#af1369c876ea54a9996e2b4d557123a7d">length</a>();

      <span class="keywordflow">while</span> (d_entries.size()
          &amp;&amp; d_entries.front().d_numBytesNeeded &lt;= numBytesAvailable) {

          Entry&amp; entry = d_entries.front();

          <span class="keywordtype">int</span> numConsumed = 0;
          <span class="keywordtype">int</span> nNeeded     = 0;

          <span class="keyword">const</span> BlobBasedReadCallback&amp; callback = entry.d_readCallback;
          numBytesAvailable = msg-&gt;<a class="code" href="classbtlb_1_1Blob.html#af1369c876ea54a9996e2b4d557123a7d">length</a>();

          {
              callback(e_SUCCESS, &amp;nNeeded, msg, d_channelId);
              numConsumed = numBytesAvailable - msg-&gt;<a class="code" href="classbtlb_1_1Blob.html#af1369c876ea54a9996e2b4d557123a7d">length</a>();
          }

          assert(0 &lt;= nNeeded);
          assert(0 &lt;= numConsumed);

          numBytesAvailable -= numConsumed;

          <span class="keywordflow">if</span> (nNeeded) {
              entry.d_numBytesNeeded = nNeeded;
              <span class="keywordflow">if</span> (nNeeded &lt;= numBytesAvailable) {
                  <span class="keywordflow">continue</span>;
              }

              *numNeeded = nNeeded - numBytesAvailable;
          }
          <span class="keywordflow">else</span> {
              d_entries.erase(d_entries.begin());
              <span class="keywordflow">if</span> (!d_entries.size()) {
                  d_channelPool_p-&gt;disableRead(d_channelId);
              }
          }
      }
  }

  <span class="comment">// ACCESSORS</span>
  <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> my_AsyncChannel::localAddress()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> address;
      d_channelPool_p-&gt;getLocalAddress(&amp;address, d_channelId);
      <span class="keywordflow">return</span> address;
  }

  <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> my_AsyncChannel::peerAddress()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <a class="code" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> address;
      d_channelPool_p-&gt;getPeerAddress(&amp;address, d_channelId);
      <span class="keywordflow">return</span> address;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:13 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
