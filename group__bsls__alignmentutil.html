<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bsls_alignmentutil Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bsls_alignmentutil<br/>
<small>
[<a class="el" href="group__bsls.html">Package bsls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide constants, types, and operations related to alignment.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Assumptions</a> </li>
<li>
<a href="#3.2">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide constants, types, and operations related to alignment. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbsls_1_1AlignmentUtil.html">bsls::AlignmentUtil</a> </td><td>namespace for alignment functions, types, and constants  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bslma_bufferimputil </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a <code>struct</code>, <code><a class="el" href="structbsls_1_1AlignmentUtil.html">bsls::AlignmentUtil</a></code>, which serves as a namespace for compile-time constants, types, and operations associated with alignment on the current platform. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>BSLS_MAX_ALIGNMENT</code> enumerator provides the minimal value that satisfies the alignment requirements for all types on the current platform. Additionally, the <code>MaxAlignedType</code> <code>typedef</code> specifies a primitive type that requires an alignment of <code>BSLS_MAX_ALIGNMENT</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>calculateAlignmentFromSize</code> function calculates a usable (but not necessarily minimal) alignment for any object with a memory footprint of the specified <code>size</code> (in bytes). The <code>calculateAlignmentOffset</code> function calculates the offset from a specified <code>address</code> where an object having a specified <code>alignment</code> requirement can be constructed safely. The <code>is2ByteAligned</code>, <code>is4ByteAligned</code>, and <code>is8ByteAligned</code> functions each return <code>true</code> if a specified <code>address</code> is, respectively, 2-, 4-, or 8-byte aligned. Finally, <code>roundUpToMaximalAlignment</code> returns the smallest whole multiple of <code>BSLS_MAX_ALIGNMENT</code> greater than or equal to its argument. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="assumptions"></a> <a class="anchor" id="description.assumptions"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Assumptions: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The functionality in this component makes several assumptions: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
The alignment for any given type is an integral power of 2.  </li>
<li>
The required alignment for a type <code>T</code> evenly divides <code>sizeof(T)</code>, which implies that the required alignment for <code>T</code> is never larger than <code>sizeof(T)</code>.  </li>
<li>
The required alignment for a <code>struct</code>, <code>class</code>, or <code>union</code> is the same as the required alignment of its most restrictive non-static data member (including the implicit virtual table pointer in polymorphic classes and internal pointers in virtually-derived classes).  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A sequential memory allocator is used to return a sequence of memory blocks of varying requested sizes from a larger chunk of contiguous memory. Each block returned must also have an alignment that is sufficient for any conceivable object of that size. To achieve a fully factored implementation, we might choose to provide a low-level helper function <code>naturallyAlign</code> that, given the <code>address</code> of the next available byte in the larger chunk along with the requested block <code>size</code> (in bytes), returns the first appropriately (or <em>naturally</em>) aligned address for the requested block at or after <code>address</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> *naturallyAlign(<span class="keywordtype">void</span> **currentAddress, <span class="keywordtype">int</span> size);
      <span class="comment">// Return the closest memory address at or after the specified</span>
      <span class="comment">// &#39;*currentAddress&#39; that is sufficiently aligned to accommodate any</span>
      <span class="comment">// object of the specified &#39;size&#39;, and update &#39;*currentAddress&#39; to</span>
      <span class="comment">// refer to the first available byte after the allocated object.  The</span>
      <span class="comment">// behavior is undefined unless &#39;1 &lt;= size&#39;.</span>
</pre></div><br/>
<br/>
 We can implement the <code>naturallyAlign</code> helper function easily using the methods defined in this class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> *naturallyAlign(<span class="keywordtype">void</span> **currentAddress, std::size_t size)
  {
      <span class="keywordtype">int</span>   alignment = <a class="code" href="structbsls_1_1AlignmentUtil.html#a22499d10c8827af367d52693472ca491">bsls::AlignmentUtil::calculateAlignmentFromSize</a>(
                                                              size);
      <span class="keywordtype">int</span>   offset    = <a class="code" href="structbsls_1_1AlignmentUtil.html#a59020e97aa03ceafb15389eac50e01eb">bsls::AlignmentUtil::calculateAlignmentOffset</a>(
                                                             *currentAddress,
                                                              alignment);
      <span class="keywordtype">char</span> *result    = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(*currentAddress) + offset;
      *currentAddress = result + size;
      <span class="keywordflow">return</span> result;
  }
</pre></div><br/>
<br/>
 We will then be able to use this <code>naturallyAlign</code> helper function to allocate, from a buffer of contiguous memory, efficiently (but not necessarily optimally) aligned memory for objects of varying sizes based solely on the size of each object (i.e., determined by its natural, not actual, alignment). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To illustrate the functionality provided in this component, we begin by assuming that we have some user-defined type, <code>MyType</code>, comprising several data members: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyType {          <span class="comment">// size 24; actual alignment 8; natural alignment 8</span>
      <span class="keywordtype">int</span>     d_int;
      <span class="keywordtype">double</span>  d_double;   <span class="comment">// Assume 8-byte alignment.</span>
      <span class="keywordtype">char</span>   *d_charPtr;  <span class="comment">// Assume size &lt;= 8 bytes.</span>
  };
</pre></div><br/>
<br/>
 We then define a function, <code>f</code>, which starts off by creating a maximally aligned <code>buffer</code> on the program stack: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> f()
  {
      <span class="keyword">const</span> <span class="keywordtype">int</span> BUFFER_SIZE = 1024;
      <span class="keyword">union </span>{
          <a class="code" href="structbsls_1_1AlignmentUtil.html#a8e9ba3fe648c80e5b29ae2d0920b61c8">bsls::AlignmentUtil::MaxAlignedType</a> d_dummy;  <span class="comment">// force max. align.</span>
          <span class="keywordtype">char</span>                                d_buffer[BUFFER_SIZE];
      } buffer;
</pre></div><br/>
<br/>
 Next we use the <code><a class="el" href="structbsls_1_1AlignmentUtil.html">bsls::AlignmentUtil</a></code> functions directly to confirm that <code>buffer</code> is sufficiently aligned to accommodate a <code>MaxAlignedType</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> alignment = <a class="code" href="structbsls_1_1AlignmentFromType.html">bsls::AlignmentFromType</a>&lt;
                              <a class="code" href="structbsls_1_1AlignmentUtil.html#a8e9ba3fe648c80e5b29ae2d0920b61c8">bsls::AlignmentUtil::MaxAlignedType</a>&gt;::VALUE;
  <span class="keywordtype">int</span> offset    = <a class="code" href="structbsls_1_1AlignmentUtil.html#a59020e97aa03ceafb15389eac50e01eb">bsls::AlignmentUtil::calculateAlignmentOffset</a>(
                                                         buffer.d_buffer,
                                                         alignment);
  assert(0 == offset);  <span class="comment">// sufficient alignment</span>
</pre></div><br/>
<br/>
 Below we perform various memory allocations using our <code>naturallyAlign</code> helper function: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> *p         = <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span> *<span class="keyword">&gt;</span>(buffer.d_buffer);

  <span class="keywordtype">void</span> *charPtr   = naturallyAlign(&amp;p, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));

  <span class="keywordtype">void</span> *shortPtr5 = naturallyAlign(&amp;p, 5 * <span class="keyword">sizeof</span>(<span class="keywordtype">short</span>));
</pre></div><br/>
<br/>
 Note that the address held in <code>shortPtr</code> is numerically divisible by the alignment of a <code>short</code> on the current platform: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == ((static_cast&lt;char *&gt;(shortPtr5) - buffer.d_buffer) %
                                  <a class="code" href="structbsls_1_1AlignmentFromType.html">bsls::AlignmentFromType&lt;short&gt;::VALUE</a>));

  assert(<a class="code" href="structbsls_1_1AlignmentUtil.html#a9afd79d5cffa84757dd7009c630827ae">bsls::AlignmentUtil::is2ByteAligned</a>(shortPtr5));
</pre></div><br/>
<br/>
 Next we use <code>naturallyAlign</code> to allocate a block of appropriate size and sufficient alignment to store a <code>MyType</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> *objPtr = naturallyAlign(&amp;p, <span class="keyword">sizeof</span>(MyType));
</pre></div><br/>
<br/>
 Note that the alignment of the address held in <code>objPtr</code> is numerically divisible by the actual alignment requirement: <br/>
<br/>
<div class="fragment"><pre class="fragment">      assert(0 == <a class="code" href="structbsls_1_1AlignmentUtil.html#a59020e97aa03ceafb15389eac50e01eb">bsls::AlignmentUtil::calculateAlignmentOffset</a>(
                                    objPtr,
                                    <a class="code" href="structbsls_1_1AlignmentFromType.html">bsls::AlignmentFromType&lt;MyType&gt;::VALUE</a>));
  }
</pre></div><br/>
<br/>
 Assuming <code>buffer</code> has sufficient capacity, and the alignments for <code>char</code>, <code>short</code>, and <code>MyType</code> are, respectively, 1, 2, and 8, we would expect this layout within <code>buffer.d_buffer</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  charPtr shortPtr5                                               objPtr
  |       |                                                       |
  V       V                                                       V
  .---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.-
  |ccc|   |sssssss:sssssss:sssssss:sssssss:sssssss|   :   :   :   |oooooo...
  ^---^---^---^---^---^---^---^---^---^---^---^---^---^---^---^---^---^---^-
  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18
</pre></div><br/>
<br/>
 Note that on an atypical 32-bit platform where a <code>double</code> is 4-byte aligned, the actual alignment of <code>MyType</code> would be 4, but its natural alignment would still be 8 because its size would be 16; it is highly unlikely that <code>MyType</code> would have an actual (and therefore natural) alignment of 4 on a 64-bit platform when using default compiler settings. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:42 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
