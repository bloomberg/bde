<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlsc_channel Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlsc_channel<br/>
<small>
[<a class="el" href="group__btlsc.html">Package btlsc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a protocol for synchronous stream-based communication.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlsc.html">btlsc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Protocol Hierarchy</a> </li>
<li>
<a href="#3.2">Synchronous Stream-Based Transport</a> </li>
<li>
<a href="#3.3">Buffered Transport</a> </li>
<li>
<a href="#3.4">Partial Results</a> <ul>
<li>
<a href="#3.4.1">Asynchronous Events</a> </li>
<li>
<a href="#3.4.2">Raw Transmissions</a> </li>
<li>
<a href="#3.4.3"><code>augStatus</code></a> </li>
</ul>
</li>
<li>
<a href="#3.5">Scatter/Gather (<code>readv</code>/<code>writev</code>)</a> </li>
<li>
<a href="#3.6">Synopsis</a> </li>
<li>
<a href="#3.7">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a protocol for synchronous stream-based communication. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlsc_1_1Channel.html">btlsc::Channel</a> </td><td>a synchronous stream-based channel protocol  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlsc__timedchannel.html" title="Provide a protocol for stream-based communication with a timeout.">Component btlsc_timedchannel</a>, <a class="el" href="group__btlsc__cbchannel.html" title="Provide a protocol for stream-based data communication.">Component btlsc_cbchannel</a>, <a class="el" href="group__btlsc__channelallocator.html" title="Provide protocol for blocking stream-based channel allocators.">Component btlsc_channelallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a class, <code><a class="el" href="classbtlsc_1_1Channel.html">btlsc::Channel</a></code>, that defines an abstract interface for an end-point of a bi-directional synchronous (i.e., blocking) stream-based communication channel. The <code><a class="el" href="classbtlsc_1_1Channel.html">btlsc::Channel</a></code> protocol supports efficient "buffered" transport and the syntax to enable efficient vector I/O operations (i.e., Unix-style scatter/gather <code>readv</code> and <code>writev</code>). Various forms of "partial transmission" authorizations (i.e., "raw" OS-level atomic operations and interruptions due to an "asynchronous
 event") are also supported as appropriate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="protocol_hierarchy"></a> <a class="anchor" id="description.protocol_hierarchy"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Protocol Hierarchy: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbtlsc_1_1Channel.html">btlsc::Channel</a></code> forms the base of an interface hierarchy; other interfaces may be defined by direct public inheritance: <br/>
<br/>
<div class="fragment"><pre class="fragment">                           ,--------------.
                          ( <a class="code" href="classbtlsc_1_1Channel.html">btlsc::Channel</a> )
                           `--------------<span class="stringliteral">&#39;</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="synchronous_stream-based_transport"></a> <a class="anchor" id="description.synchronous_stream-based_transport"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Synchronous Stream-Based Transport: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This interface establishes methods for synchronous stream-based transport. Each read or write method will block until one of three possible outcomes is reached: (1) "success" -- the specified number of bytes was transmitted, (2) "partial result" -- the operation was interrupted (e.g., via an asynchronous event), or (3) "error" -- an implementation-dependent error occurred. In all cases, a "status" value is returned; an optional leading (<code>int *</code>) <code>augStatus</code> argument may be provided to enable the caller to distinguish among various reasons for a partial result (see below). The user may retry a partial-result operation (with method arguments suitably adjusted), with a reasonable expectation of success. Finally, concrete synchronous stream-based channels do a "best effort" in sending and receiving the specified data, but need not guarantee successful transmission. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="buffered_transport"></a> <a class="anchor" id="description.buffered_transport"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Buffered Transport: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Non-vector read operations support a "buffered" variant that may be more efficient in some situations. For such operations, the prefix "buffered" appears before the basic operation name in the full method name (e.g., <code>bufferedRead</code>). Note that, for blocking channels, there is no need for buffered write operations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In buffered operations, the caller does not provide a buffer, but rather receives direct (non-modifiable) access to the implementation's buffer. In the event of a partial read (see below), the data remains buffered and subsequent reads will behave as if the buffered operation had never occurred. Once a buffered read operation succeeds (i.e., receives the requested number of bytes) the buffered contents will remain valid only as long as the channel is not modified. Note that "buffered" and "vector" (<code>readv</code>, see below) are incompatible read options. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="partial_results"></a> <a class="anchor" id="description.partial_results"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Partial Results: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The "simple" results of read and write operations are "success" (with a status equal to the requested number of bytes) and "error" (with a negative status). More complex behavior is also supported, some of which is at the option of the user. Specifically, the caller may authorize the possibility of another outcome via combinations of the following two mechanisms: (1) an interruption due to an asynchronous event and (2) a "raw" operation, i.e., accepting the results of a single low-level (implementation dependent) atomic I/O operation (without retrying). These two mechanisms (discussed in more detail below) may each return with a "partial result", indicated by a non-negative status that is less than the requested number of bytes. Note that asynchronous events, but <em>not</em> raw operations, may result in a return status of zero bytes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="asynchronous_events"></a> <a class="anchor" id="partial_results.asynchronous_events"></a> <a class="anchor" id="description.partial_results.asynchronous_events"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Asynchronous Events: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Methods in this protocol anticipate the possible occurrence of an "asynchronous event" (AE) during execution. A common example of an AE is a Unix signal, but note that a specific Unix signal, if not detected or implemented, <em>may</em> not result in an AE. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This interface cannot fully specify either the nature of or the behavior resulting from an AE, but certain restrictions can be imposed. By default, AEs are either ignored or, if that is not possible, cause an error. At the user's option, however, a concrete implementation can be authorized to return, if such occurrence is detected, a "partial result" upon occurrence of an AE. Such authorizations are made explicitly by incorporating into the optional (trailing) integer <code>flags</code> argument to a method call the <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code> value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="raw_transmissions"></a> <a class="anchor" id="partial_results.raw_transmissions"></a> <a class="anchor" id="description.partial_results.raw_transmissions"></a> <a class="anchor" id="3.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Raw Transmissions: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>All read and unbuffered write methods support a "raw" variant in which the operation is allowed to return with a "partial result" if (1) <em>at</em> <em>least</em> <em>one</em> <em>byte</em> has been transmitted and (2) no additional bytes are <em>immediately</em> transmittable. The "raw" mode is particularly useful to callers waiting for some read activity, who will then follow up with additional read requests after observing the initial transmission. Raw transmissions are authorized by methods whose names end in the suffix <code>Raw</code>. Note that the "raw" mode is not supported for buffered-write operations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="augstatus"></a> <a class="anchor" id="partial_results.augstatus"></a> <a class="anchor" id="description.partial_results.augstatus"></a> <a class="anchor" id="3.4.3"></a> </dd></dl>
<dl class="user"><dt><b>augStatus: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Since there are several possible reasons for a "partial result", the caller may wish to know the specific cause. A second status value, <code>augStatus</code> ("augmented status") may be requested as an optional <em>initial</em> (<code>int *</code>) argument to each transmission function. If specified, <code>augStatus</code> will be set to a positive value if the interruption was due to an "asynchronous
 event" and to a negative value if a "raw" operation could not complete. Note that <code>augStatus</code> will not be modified on success or error, but only on a partial result. Also note that a raw operation cannot terminate normally with less than 1 byte transmitted. Finally, note that an <code>augStatus</code> of zero is not possible for this protocol; the zero value is reserved for protocols supporting timeouts. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="scatter~2Fgather_(readv~2Fwritev)"></a> <a class="anchor" id="description.scatter~2Fgather_(readv~2Fwritev)"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Scatter/Gather (readv/writev): </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This interface supports "vector I/O" -- the simultaneous reading from or writing to multiple buffers -- via Unix-style <code>readv</code> and <code>writev</code> variants of the normal single-buffer methods. Scatter/Gather operations use either the <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> or <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> objects which use a <code>iovec</code> <code>struct</code> on Unix platforms or a <code>WSABUF</code> <code>struct</code> on Windows. In either structure, the total number of bytes to be read or written is determined by the sum of each buffer of the non-negative <code>numBuffers</code>. Note that the <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> variant enables write operations to avoid having to cast away <code>const</code> in order to hold the address of non-modifiable data to be written. The following simple example shows how to create and populate an <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> array in preparation for a <code>writev</code> operation: <br/>
<br/>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">void</span> myWritevAndPrintStatusWhenAvailable(<a class="code" href="classbtlsc_1_1Channel.html">btlsc::Channel</a> *channel)
         <span class="comment">// Write the integer representation of the length of a character</span>
         <span class="comment">// string followed by the (null-terminated) string data itself to</span>
         <span class="comment">// the specified &#39;channel&#39;; upon completion, report the status</span>
         <span class="comment">// of the &quot;write&quot; operation to &#39;cout&#39;.</span>
     {
         <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> MESSAGE = <span class="stringliteral">&quot;Hello World!&quot;</span>;
         <span class="keyword">const</span> <span class="keywordtype">int</span>         HEADER  = strlen(MESSAGE);
         <span class="keyword">enum</span> { NUM_BUFFERS = 2 };

         <a class="code" href="classbtls_1_1Ovec.html">btls::Ovec</a> buffers[NUM_BUFFERS];

         <span class="comment">// Set each buffer&#39;s data and corresponding length.</span>

         buffer[0].setBuffer(&amp;HEADER, <span class="keyword">sizeof</span> HEADER);
         buffer[1].setBuffer(MESSAGE, HEADER);

         <span class="keywordflow">if</span> (channel-&gt;<a class="code" href="classbtlsc_1_1Channel.html#af3be1ce9b3d03861d143b45b97132f5a">writev</a>(buffers, NUM_BUFFERS) &lt; 0) {
             bsl::cout &lt;&lt; <span class="stringliteral">&quot;Buffered write operation failed!&quot;</span> &lt;&lt; bsl::endl;
         }

         <span class="comment">// Notice that the &#39;writev&#39; operation above does not</span>
         <span class="comment">// authorize any partial write operations whatsoever.</span>
     }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="synopsis"></a> <a class="anchor" id="description.synopsis"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Synopsis: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following chart summarizes the set of 20 transmission methods that are available to read and write data from and to a <code><a class="el" href="classbtlsc_1_1Channel.html">btlsc::Channel</a></code>; note that "buffered readv" and all "buffered write (and writev)" operations are nonsensical and, therefore, omitted from the protocol: <br/>
<br/>
<div class="fragment"><pre class="fragment">    Buffered    Re/Wr    Vec    Raw    Method Name
    --------    -----    ---    ---    --------------
                READ                   read
                READ            RAW    readRaw

                READ     VEC           readv
                READ     VEC    RAW    readvRaw

    BUFFERED    READ                   bufferedRead
    BUFFERED    READ            RAW    bufferedReadRaw

                WRITE                  write
                WRITE           RAW    writeRaw

                WRITE    VEC           writev
                WRITE    VEC    RAW    writevRaw
</pre></div><br/>
<br/>
 Each of these methods supports the specification of a flag value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a>
</pre></div><br/>
<br/>
 supplied in an optional trailing integer to enable "asynchronous events" to cause partial results; by default, such events are ignored. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Each of these methods is overloaded to allow the caller to optionally specify the address of an <code>augStatus</code>, which will then be modified in the event of a partial result. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>btlsc</code> style of channel interface is used to transmit sequences of specified size across some concrete channel implementation. In this example we demonstrate how to implement a remote procedure call (RPC) to a factorial function taking an <code>int</code> and returning a <code>double</code>. For simplicity, we will assume that both the <code>int</code> and <code>double</code> formats are binary compatible across client and server platforms: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">double</span> factorial(<span class="keywordtype">int</span> number)
      <span class="comment">// Return the factorial of the specified integral &#39;number&#39; as a value</span>
      <span class="comment">// of type &#39;double&#39;.  The behavior is undefined unless &#39;0 &lt;= number&#39;.</span>
      <span class="comment">// Note that this helper function is provided for the server to</span>
      <span class="comment">// calculate the factorial value.</span>
  {
      <span class="keywordflow">if</span> (0 == number) {
          <span class="keywordflow">return</span> 1;                                                 <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">else</span> {
          <span class="keywordflow">return</span> number * factorial(number - 1);                    <span class="comment">// RETURN</span>
      }
  }

  <span class="keywordtype">int</span> factorialClient(<span class="keywordtype">double</span> *result, <span class="keywordtype">int</span> input, <a class="code" href="classbtlsc_1_1Channel.html">btlsc::Channel</a> *channel)
      <span class="comment">// Load into the specified &#39;result&#39; the factorial of the specified</span>
      <span class="comment">// &#39;input&#39; using the specified &#39;channel&#39; (which is assumed to be</span>
      <span class="comment">// connected to an appropriate factorial service).  Return 0 on</span>
      <span class="comment">// success, and -1, with no effect on &#39;result&#39;, on error.  The</span>
      <span class="comment">// behavior is undefined unless &#39;0 &lt;= input&#39;.</span>
  {
      assert(0 &lt;= input);

      <span class="keyword">enum</span> {
          ERROR_STATUS   = -1,
          SUCCESS_STATUS = 0
      };
      <span class="keywordtype">int</span> numBytes = <span class="keyword">sizeof</span> input;
      <span class="keywordtype">int</span> writeStatus = channel-&gt;<a class="code" href="classbtlsc_1_1Channel.html#a707d767695090653fcf137f77e934caa">write</a>((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;input, numBytes);
      assert(0 != writeStatus);

      <span class="keywordflow">if</span> (writeStatus != numBytes) {
          <span class="keywordflow">return</span> ERROR_STATUS;                                      <span class="comment">// RETURN</span>
      }

      <span class="keywordtype">int</span> readStatus = channel-&gt;<a class="code" href="classbtlsc_1_1Channel.html#a7d1d3187198316fffcc8d08b7e8786a3">read</a>((<span class="keywordtype">char</span> *)result, <span class="keyword">sizeof</span> *result);
      <span class="keywordflow">if</span> (readStatus != <span class="keyword">sizeof</span> *result) {
          <span class="keywordflow">return</span> ERROR_STATUS;                                      <span class="comment">// RETURN</span>
      }

      <span class="keywordflow">return</span> SUCCESS_STATUS;                                        <span class="comment">// RETURN</span>
  }

  <span class="keywordtype">int</span> factorialServer(<a class="code" href="classbtlsc_1_1Channel.html">btlsc::Channel</a> *channel)
      <span class="comment">// Repeatedly read integer sequences from the specified &#39;channel&#39;.</span>
      <span class="comment">// When a read succeeds, interpret the byte sequence as an integer</span>
      <span class="comment">// value in host-byte order.  Return -1 if that value is negative.</span>
      <span class="comment">// Otherwise, calculate the factorial of the (non-negative) integer and</span>
      <span class="comment">// write back the result to &#39;channel&#39; as a sequence of bytes</span>
      <span class="comment">// representing a &#39;double&#39; in the host&#39;s native format.  Return a</span>
      <span class="comment">// negative value if any write operation doesn&#39;t succeed (refer to the</span>
      <span class="comment">// following &#39;enum&#39; values for specific errors).  Note that this</span>
      <span class="comment">// implementation is just to show how a channel could be used; there is</span>
      <span class="comment">// much room to improve.</span>
  {
      <span class="keyword">enum</span> {
          SUCCESS            =  0,
          INVALID_INPUT      = -1,
          ERROR_READ         = -2,
          ERROR_WRITE        = -3,
          ERROR_INTERRUPTED  = -4,
          ERROR_UNCLASSIFIED = -5
      };

      <span class="keywordflow">while</span> (1) {
          <span class="keywordtype">int</span> input, augStatus;
          <span class="keywordtype">int</span> readStatus = channel-&gt;<a class="code" href="classbtlsc_1_1Channel.html#a7d1d3187198316fffcc8d08b7e8786a3">read</a>(&amp;augStatus,
                                         (<span class="keywordtype">char</span> *)&amp;input,
                                         <span class="keyword">sizeof</span> input);
          <span class="keywordflow">if</span> (readStatus &lt; 0) {
              <span class="keywordflow">return</span> ERROR_READ;                                    <span class="comment">// RETURN</span>
          }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (readStatus != <span class="keyword">sizeof</span> input) {
              <span class="keywordflow">if</span> (augStatus &gt; 0) {
                  <span class="keywordflow">return</span> ERROR_INTERRUPTED;                         <span class="comment">// RETURN</span>
              }
              <span class="keywordflow">return</span> ERROR_UNCLASSIFIED;                            <span class="comment">// RETURN</span>
          }

          <span class="keywordflow">if</span> (input &lt; 0) {
              <span class="keywordflow">return</span> INVALID_INPUT;                                 <span class="comment">// RETURN</span>
          }

          <span class="keywordtype">double</span> result = factorial(input);
          augStatus = 0;
          <span class="keywordtype">int</span> writeStatus = channel-&gt;<a class="code" href="classbtlsc_1_1Channel.html#a707d767695090653fcf137f77e934caa">write</a>(&amp;augStatus,
                                           (<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;result,
                                           <span class="keyword">sizeof</span> result);

          <span class="keywordflow">if</span> (writeStatus &lt; 0) {
              <span class="keywordflow">return</span> ERROR_WRITE;                                   <span class="comment">// RETURN</span>
          }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (writeStatus != <span class="keyword">sizeof</span> input){
              <span class="keywordflow">if</span> (augStatus &gt; 0) {
                  <span class="keywordflow">return</span> ERROR_INTERRUPTED;                         <span class="comment">// RETURN</span>
              }
              <span class="keywordflow">return</span> ERROR_UNCLASSIFIED;                            <span class="comment">// RETURN</span>
          }
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:13 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
