<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlcc_fixedqueue Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlcc_fixedqueue<br/>
<small>
[<a class="el" href="group__bdlcc.html">Package bdlcc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a thread-enabled fixed-size queue of values.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlcc.html">bdlcc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Template Requirements</a> </li>
<li>
<a href="#3.2">Exception safety</a> </li>
<li>
<a href="#3.3">Memory Usage</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: A Simple Thread Pool</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a thread-enabled fixed-size queue of values. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlcc_1_1FixedQueue.html">bdlcc::FixedQueue</a> </td><td>thread-enabled fixed-size queue of <code>TYPE</code> values  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a type, <code><a class="el" href="classbdlcc_1_1FixedQueue.html">bdlcc::FixedQueue</a></code>, that provides an efficient, thread-enabled fixed-size queue of values. This class is ideal for synchronization and communication between threads in a producer-consumer model. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The queue provides <code>pushBack</code> and <code>popFront</code> methods for pushing data into the queue and popping it from the queue. In case of overflow (queue full when pushing), or underflow (queue empty when popping), the methods block until data or free space in the queue appears. Non-blocking methods <code>tryPushBack</code> and <code>tryPushFront</code> are also provided, which fail immediately returning a non-zero value in case of overflow or underflow. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The queue may be placed into a "disabled" state using the <code>disable</code> method. When disabled, <code>pushBack</code> and <code>tryPushBack</code> fail immediately (they do not block and any blocked invocations will fail immediately). The queue may be restored to normal operation with the <code>enable</code> method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Unlike <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code>, a fixed queue is not double-ended, there is no timed API like <code>timedPushBack</code> and <code>timedPopFront</code>, and no <code>forcePush</code> methods, as the queue capacity is fixed. Also, this component is not based on <code><a class="el" href="classbdlc_1_1Queue.html">bdlc::Queue</a></code>, so there is no API for direct access to the underlying queue. These limitations are a trade-off for significant gain in performance compared to <code><a class="el" href="classbdlcc_1_1Queue.html">bdlcc::Queue</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="template_requirements"></a> <a class="anchor" id="description.template_requirements"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Template Requirements: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlcc_1_1FixedQueue.html">bdlcc::FixedQueue</a></code> is a template that is parameterized on the type of element contained within the queue. The supplied template argument, <code>TYPE</code>, must provide both a default constructor and a copy constructors as well as an assignment operator. If the default constructor accepts a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a>*</code>, <code>TYPE</code> must declare the uses <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> trait (see <code>bslma_usesbslmaallocator</code>) so that the allocator of the queue is propagated to the elements contained in the queue. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="exception_safety"></a> <a class="anchor" id="description.exception_safety"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Exception safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbdlcc_1_1FixedQueue.html">bdlcc::FixedQueue</a></code> is exception neutral, and all of the methods of <code><a class="el" href="classbdlcc_1_1FixedQueue.html">bdlcc::FixedQueue</a></code> provide the strong exception safety guarantee except for <code>pushBack</code> and <code>tryPushBack</code>, which provide the basic exception guarantee (see <code>bsldoc_glossary</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_usage"></a> <a class="anchor" id="description.memory_usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Memory Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlcc_1_1FixedQueue.html">bdlcc::FixedQueue</a></code> is most efficient when dealing with small objects or fundamental types (as a thread-safe container, its methods pass objects <em>by</em> <em>value</em>). We recommend: <ul>
<li>
Large objects be stored as shared-pointers (or possibly raw pointers).  </li>
<li>
Clients take care in specifying the queue capacity (specified in a number of objects, <em>not</em> a number of bytes).  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the implementation of <code><a class="el" href="classbdlcc_1_1FixedQueue.html">bdlcc::FixedQueue</a></code> currently creates a fixed size array of the contained object type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_a_simple_thread_pool"></a> <a class="anchor" id="usage.example_1~3A_a_simple_thread_pool"></a> <a class="anchor" id="description.usage.example_1~3A_a_simple_thread_pool"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: A Simple Thread Pool: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the following example a <code><a class="el" href="classbdlcc_1_1FixedQueue.html">bdlcc::FixedQueue</a></code> is used to communicate between a single "producer" thread and multiple "consumer" threads. The "producer" will push work requests onto the queue, and each "consumer" will iteratively take a work request from the queue and service the request. This example shows a partial, simplified implementation of the <code><a class="el" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a></code> class. See component <code>bdlmt_fixedthreadpool</code> for more information. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a utility classes that handles a simple "work item": <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>my_WorkData {
      <span class="comment">// Work data...</span>
  };

  <span class="keyword">struct </span>my_WorkRequest {
      <span class="keyword">enum</span> RequestType {
          e_WORK = 1,
          e_STOP = 2
      };

      RequestType d_type;
      my_WorkData d_data;
      <span class="comment">// Work data...</span>
  };
</pre></div><br/>
<br/>
 Next, we provide a simple function to service an individual work item. The details are unimportant for this example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myDoWork(my_WorkData&amp; data)
  {
      <span class="comment">// do some stuff...</span>
      (void)data;
  }
</pre></div><br/>
<br/>
 Then, we define a <code>myConsumer</code> function that will pop elements off the queue and process them. Note that the call to <code>queue-&gt;popFront()</code> will block until there is an element available on the queue. This function will be executed in multiple threads, so that each thread waits in <code>queue-&gt;popFront()</code>, and <code><a class="el" href="classbdlcc_1_1FixedQueue.html">bdlcc::FixedQueue</a></code> guarantees that each thread gets a unique element from the queue: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myConsumer(<a class="code" href="classbdlcc_1_1FixedQueue.html">bdlcc::FixedQueue&lt;my_WorkRequest&gt;</a> *queue)
  {
      <span class="keywordflow">while</span> (1) {
          <span class="comment">// &#39;popFront()&#39; will wait for a &#39;my_WorkRequest&#39; until available.</span>

          my_WorkRequest item = queue-&gt;<a class="code" href="classbdlcc_1_1FixedQueue.html#afafbaf87efa5ed635f7043ddfe228d12">popFront</a>();
          <span class="keywordflow">if</span> (item.d_type == my_WorkRequest::e_STOP) { <span class="keywordflow">break</span>; }
          myDoWork(item.d_data);
      }
  }
</pre></div><br/>
<br/>
 Finally, we define a <code>myProducer</code> function that serves multiple roles: it creates the <code><a class="el" href="classbdlcc_1_1FixedQueue.html">bdlcc::FixedQueue</a></code>, starts the consumer threads, and then produces and enqueues work items. When work requests are exhausted, this function enqueues one <code>e_STOP</code> item for each consumer queue. This <code>e_STOP</code> item indicates to the consumer thread to terminate its thread-handling function. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that, although the producer cannot control which thread <code>pop</code>s a particular work item, it can rely on the knowledge that each consumer thread will read a single <code>e_STOP</code> item and then terminate. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myProducer(<span class="keywordtype">int</span> numThreads)
  {
      <span class="keyword">enum</span> {
          k_MAX_QUEUE_LENGTH = 100,
          k_NUM_WORK_ITEMS   = 1000
      };

      <a class="code" href="classbdlcc_1_1FixedQueue.html">bdlcc::FixedQueue&lt;my_WorkRequest&gt;</a> queue(k_MAX_QUEUE_LENGTH);

      <a class="code" href="classbslmt_1_1ThreadGroup.html">bslmt::ThreadGroup</a> consumerThreads;
      consumerThreads.<a class="code" href="classbslmt_1_1ThreadGroup.html#acee906734abe40e5da1cb126fd63c5f5">addThreads</a>(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;myConsumer, &amp;queue),
                                 numThreads);

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; k_NUM_WORK_ITEMS; ++i) {
          my_WorkRequest item;
          item.d_type = my_WorkRequest::e_WORK;
          item.d_data = my_WorkData(); <span class="comment">// some stuff to do</span>
          queue.<a class="code" href="classbdlcc_1_1FixedQueue.html#a68f8b8c2be39b7c2daa1a7bd739799bc">pushBack</a>(item);
      }

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numThreads; ++i) {
          my_WorkRequest item;
          item.d_type = my_WorkRequest::e_STOP;
          queue.<a class="code" href="classbdlcc_1_1FixedQueue.html#a68f8b8c2be39b7c2daa1a7bd739799bc">pushBack</a>(item);
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:37 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
