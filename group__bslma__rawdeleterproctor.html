<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslma_rawdeleterproctor Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslma_rawdeleterproctor<br/>
<small>
[<a class="el" href="group__bslma.html">Package bslma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a proctor to conditionally manage an object.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">"Raw" Warning</a> </li>
<li>
<a href="#3.2">Requirement</a> </li>
<li>
<a href="#3.3">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a proctor to conditionally manage an object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslma_1_1RawDeleterProctor.html">bslma::RawDeleterProctor</a> </td><td>proctor to conditionally manage an object  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__rawdeleterguard.html" title="Provide a guard to unconditionally manage an object.">Component bslma_rawdeleterguard</a>, <a class="el" href="group__bslma__autorawdeleter.html" title="Provide a range proctor to manage a sequence objects.">Component bslma_autorawdeleter</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a proctor class template to conditionally manage an (otherwise-unmanaged) object of parameterized <code>TYPE</code> supplied at construction. If not explicitly released, the managed object is deleted automatically when the proctor object goes out of scope by first calling the (managed) object's destructor, and then freeing the memory using the parameterized <code>ALLOCATOR</code> (allocator or pool) also supplied at construction. Note that after a proctor object releases its managed object, the same proctor can be reused to conditionally manage another object (allocated from the same allocator or pool that was supplied at construction) by invoking the <code>reset</code> method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="~22raw~22_warning"></a> <a class="anchor" id="description.~22raw~22_warning"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Raw</b></dt><dd>Warning:  </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that this component should be used only if we are sure that the supplied pointer is <b>not</b> of a type that is a secondary base class -- i.e., the (managed) object's address is (numerically) the same as when it was originally dispensed by <code>ALLOCATOR</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirement"></a> <a class="anchor" id="description.requirement"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Requirement: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The parameterized <code>ALLOCATOR</code> type of the <code><a class="el" href="classbslma_1_1RawDeleterProctor.html">bslma::RawDeleterProctor</a></code> class template must provide a (possibly <code>virtual</code>) method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span> *address);
</pre></div><br/>
<br/>
 to deallocate memory at the specified <code>address</code> (originally supplied by the <code>ALLOCATOR</code> object). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbslma_1_1RawDeleterProctor.html">bslma::RawDeleterProctor</a></code> is normally used to achieve <em>exception</em> <em>safety</em> in an <em>exception</em> <em>neutral</em> way by managing objects that are created temporarily on the heap, but not yet committed to a container object's management. This (somewhat contrived) example illustrates the use of a <code><a class="el" href="classbslma_1_1RawDeleterProctor.html">bslma::RawDeleterProctor</a></code> to manage a dynamically-allocated object, deleting the object automatically should an exception occur. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we have a simple linked list class that manages objects of parameterized <code>TYPE</code>, but which are (for the purpose of this example) allocated separately from the links that hold them (thereby requiring two separate allocations for each <code>append</code> operation): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_list.h</span>
  <span class="comment">// ...</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>my_List {
      <span class="comment">// This class is a container that uses a linked list data structure to</span>
      <span class="comment">// manage objects of parameterized &#39;TYPE&#39;.</span>

      <span class="comment">// PRIVATE TYPES</span>
      <span class="keyword">struct </span>Link {
          TYPE *d_object_p;  <span class="comment">// object held by the link</span>
          Link *d_next_p;    <span class="comment">// next link</span>
      };

      <span class="comment">// DATA</span>
      Link             *d_head_p;       <span class="comment">// head of list</span>
      Link             *d_tail_p;       <span class="comment">// tail of list</span>
      <span class="keywordtype">int</span>               d_length;       <span class="comment">// number of objects</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;  <span class="comment">// allocator (held, not owned)</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_List(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;my_List&#39; object having an initial length of 0.</span>
          <span class="comment">// Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If</span>
          <span class="comment">// &#39;basicAllocator&#39; is 0, the currently installed default allocator</span>
          <span class="comment">// is used.</span>

      <span class="comment">// ...</span>

      ~my_List();
          <span class="comment">// Destroy this &#39;my_List&#39; object and all elements currently stored.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="comment">// ...</span>

      <span class="keywordtype">void</span> append(<span class="keyword">const</span> TYPE&amp; <span class="keywordtype">object</span>);
          <span class="comment">// Append (a copy of) the specified &#39;object&#39; of parameterized</span>
          <span class="comment">// &#39;TYPE&#39; to (the end of) this list.</span>

      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Note that the rest of the <code>my_List</code> interface (above) and implementation (below) are omitted as the portion shown is sufficient to demonstrate the use of <code><a class="el" href="classbslma_1_1RawDeleterProctor.html">bslma::RawDeleterProctor</a></code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span>
  my_List&lt;TYPE&gt;::my_List(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_head_p(0)
  , d_tail_p(0)
  , d_length(0)
  , d_allocator_p(bslma::Default::allocator(basicAllocator))
  {
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  my_List&lt;TYPE&gt;::~my_List()
  {
      <span class="keywordflow">while</span> (d_head_p) {
          Link *tmp = d_head_p;
          d_head_p  = d_head_p-&gt;d_next_p;
          d_allocator_p-&gt;deleteObject(tmp-&gt;d_object_p);
          d_allocator_p-&gt;deallocate(tmp);
      }
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> my_List&lt;TYPE&gt;::append(<span class="keyword">const</span> TYPE&amp; <span class="keywordtype">object</span>)
  {
      TYPE *tmp = (TYPE *)<span class="keyword">new</span>(*d_allocator_p) TYPE(<span class="keywordtype">object</span>, d_allocator_p);
                                                          <span class="comment">// possibly throw</span>

      <span class="comment">//************************************************************</span>
      <span class="comment">// Note the use of the raw deleter proctor on &#39;tmp&#39; (below). *</span>
      <span class="comment">//************************************************************</span>

      <a class="code" href="classbslma_1_1RawDeleterProctor.html">bslma::RawDeleterProctor&lt;TYPE, bslma::Allocator&gt;</a> proctor(tmp,
                                                             d_allocator_p);

      <span class="keywordflow">if</span> (!d_head_p) {
          d_head_p           = <span class="keyword">new</span>(*d_allocator_p) Link;  <span class="comment">// possibly throw</span>
          d_tail_p           = d_head_p;
      }
      <span class="keywordflow">else</span> {
          d_tail_p-&gt;d_next_p = <span class="keyword">new</span>(*d_allocator_p) Link;  <span class="comment">// possibly throw</span>
          d_tail_p           = d_tail_p-&gt;d_next_p;
      }
      d_tail_p-&gt;d_object_p   = tmp;
      d_tail_p-&gt;d_next_p     = 0;

      <span class="comment">//*********************************************************</span>
      <span class="comment">// Note that the raw deleter proctor is released (below). *</span>
      <span class="comment">//*********************************************************</span>

      proctor.release();
  }
</pre></div><br/>
<br/>
 The <code>append</code> method defined above potentially throws in three places. If the memory allocator held in <code>d_allocator_p</code> were to throw while attempting to create the object of parameterized <code>TYPE</code>, no memory would be leaked. But without subsequent use of the <code><a class="el" href="classbslma_1_1RawDeleterProctor.html">bslma::RawDeleterProctor</a></code>, if the allocator subsequently throws while creating the link, all memory (and any other resources) acquired as a result of copying the (not-yet-managed) object would be leaked. Using the <code><a class="el" href="classbslma_1_1RawDeleterProctor.html">bslma::RawDeleterProctor</a></code> prevents the leaks by deleting the proctored object automatically should the proctor go out of scope before the <code>release</code> method of the proctor is called (such as when the function exits prematurely due to an exception). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the <code>append</code> method assumes the copy constructor of <code>TYPE</code> takes an allocator as a second argument. In production code, a constructor proxy that checks the traits of <code>TYPE</code> (to determine whether <code>TYPE</code> uses <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>) should be used (see <code>bslalg_constructorproxy</code>). </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:41 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
