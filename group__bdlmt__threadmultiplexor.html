<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlmt_threadmultiplexor Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlmt_threadmultiplexor<br/>
<small>
[<a class="el" href="group__bdlmt.html">Package bdlmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a mechanism for partitioning a collection of threads.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlmt.html">bdlmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Multiple Work Queues</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a mechanism for partitioning a collection of threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlmt_1_1ThreadMultiplexor.html">bdlmt::ThreadMultiplexor</a> </td><td>mechanism to partition multi-threaded processing  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlmt__threadpool.html" title="Provide portable implementation for a dynamic pool of threads.">Component bdlmt_threadpool</a>, <a class="el" href="group__bdlmt__fixedthreadpool.html" title="Provide portable implementation for a fixed-size pool of threads.">Component bdlmt_fixedthreadpool</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a mechanism for partitioning a collection of threads, so that a single collection of threads (e.g., a thread pool) can be used to process various types of user-defined functions ("jobs") while sharing the thread resources equitably between them. A typical example where this type of partitioning is desired is an application that performs both I/O and CPU-intensive processing. The traditional approach is to create two thread pools--one for I/O, and one for processing--and pass control (in the form of a callback) from one thread pool to the other. However, there are several problems with this approach. Firstly, the process incurs the overhead of context switching between threads, which must necessarily occur because there are two different thread pools. Secondly, the process may not be able to adapt well to imbalances between one type of processing versus the other if the number of threads in each thread pool is bounded. In this case, a large number of jobs may be enqueued while some portion of threads allocated to the process go unused. On the other hand, simply sharing a single thread pool without a provision for partitioning the use of threads may result in one type of processing starving the other. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlmt_1_1ThreadMultiplexor.html">bdlmt::ThreadMultiplexor</a></code> provides an API, <code>processJob</code>, to process user-specified jobs. A multiplexor instance is configured with a maximum number of "processors", i.e., the maximum number of threads that may process jobs at any particular time. Additional threads enqueue jobs to a pending job queue, which is processed by the next available processing thread. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Typically, a <code><a class="el" href="classbdlmt_1_1ThreadMultiplexor.html">bdlmt::ThreadMultiplexor</a></code> instance is used in conjunction with a thread pool (e.g., <code><a class="el" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a></code>), where each thread pool thread calls the multiplexor <code>processJob</code> method to perform some work. The multiplexor guarantees that no more that the configured number of threads will process jobs concurrently. This guarantee allows a single thread pool to be used in a variety of situations that require partitioning thread resources. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlmt_1_1ThreadMultiplexor.html">bdlmt::ThreadMultiplexor</a></code> class is both <em>fully thread-safe</em> (i.e., all non-creator methods can correctly execute concurrently), and is <em>thread-enabled</em> (i.e., the class does not function correctly in a non-multi-threading environment). See <code>bsldoc_glossary</code> for complete definitions of <em>fully thread-safe</em> and <em>thread-enabled</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_multiple_work_queues"></a> <a class="anchor" id="usage.example_1~3A_multiple_work_queues"></a> <a class="anchor" id="description.usage.example_1~3A_multiple_work_queues"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Multiple Work Queues: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following usage example illustrates how the <code><a class="el" href="classbdlmt_1_1ThreadMultiplexor.html">bdlmt::ThreadMultiplexor</a></code> can be used to share thread resources between three separate work queues. Assume that there are three classes of jobs: jobs that are important, jobs that are urgent, and jobs that are critical. We would like to execute each class of jobs in a single thread pool, but we want ensure that all types of jobs can be executed at any time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We begin by defining a class that encapsulates the notion of a job queue. Our <code>JobQueue</code> class holds a reference to a <code><a class="el" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a></code>, used to instantiate the job queue, and owns an instance of <code><a class="el" href="classbdlmt_1_1ThreadMultiplexor.html">bdlmt::ThreadMultiplexor</a></code>, used to process jobs. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>JobQueue {
      <span class="comment">// This class defines a generic processor for user-defined functions</span>
      <span class="comment">// (&quot;jobs&quot;).  Jobs specified to the &#39;processJob&#39; method are executed</span>
      <span class="comment">// in the thread pool specified at construction.</span>

    <span class="keyword">public</span>:
      <span class="comment">// PUBLIC TYPES</span>
      <span class="keyword">typedef</span> <a class="code" href="classbdlmt_1_1ThreadMultiplexor.html#acb04915e4c78e6f21f9b676880067236">bdlmt::ThreadMultiplexor::Job</a> Job;
          <span class="comment">// A callback of this type my be specified to the &#39;processJob&#39;</span>
          <span class="comment">// method.</span>

    <span class="keyword">private</span>:
      <span class="comment">// DATA</span>
      <a class="code" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a>   *d_threadPool_p;  <span class="comment">// (held, not owned)</span>
      <a class="code" href="classbdlmt_1_1ThreadMultiplexor.html">bdlmt::ThreadMultiplexor</a>  d_multiplexor;   <span class="comment">// used to partition threads</span>

    <span class="keyword">private</span>:
      <span class="comment">// NOT IMPLEMENTED</span>
      JobQueue(<span class="keyword">const</span> JobQueue&amp;);
      JobQueue&amp; operator=(<span class="keyword">const</span> JobQueue&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      JobQueue(<span class="keywordtype">int</span>                     maxProcessors,
               <a class="code" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a> *threadPool,
               <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>       *basicAllocator = 0);
        <span class="comment">// Create a job queue that executes jobs in the specified</span>
        <span class="comment">// &#39;threadPool&#39; using no more than the specified &#39;maxProcessors&#39;.</span>
        <span class="comment">// Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If</span>
        <span class="comment">// &#39;basicAllocator is 0, the currently installed default allocator</span>
        <span class="comment">// is used.</span>

      ~JobQueue();
          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">int</span> processJob(<span class="keyword">const</span> Job&amp; job);
          <span class="comment">// Process the specified &#39;job&#39; in the thread pool specified at</span>
          <span class="comment">// construction.  Return 0 on success, and a non-zero value</span>
          <span class="comment">// otherwise.</span>
  };
</pre></div><br/>
<br/>
 The maximum number of processors for the multiplexor instance owned by each <code>JobQueue</code> is configured using the following formula, for T = number of threads and M = number of multiplexors &gt; 1: <br/>
<br/>
<div class="fragment"><pre class="fragment">   maxProc = ceil(T / (M-1))-1
</pre></div><br/>
<br/>
 This allows multiple <code>JobQueue</code> instances to share the same threadpool without starving each other when the thread pool has more than one thread. For this usage example, we assume M (number of multiplexors) = 3, and T (number of threads) = 5, so maxProc = 2. It is important to note that every call to <code>processJob</code> enqueues a job to the thread pool, so the length of the thread pool queue determines the maximum number of jobs that can be accepted by the JobQueue. (Multiple JobQueues share the same maximum <em>together</em>, so not all will be able to reach their individual maximum at the same time). <br/>
<br/>
<div class="fragment"><pre class="fragment">   JobQueue::JobQueue(<span class="keywordtype">int</span>                     maxProcessors,
                      <a class="code" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a> *threadPool,
                      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>       *basicAllocator)
   : d_threadPool_p(threadPool)
   , d_multiplexor (maxProcessors,
                    threadPool-&gt;queueCapacity(),
                    basicAllocator)
  {
  }

  JobQueue::~JobQueue()
  {
  }
</pre></div><br/>
<br/>
 The <code>processJob</code> method enqueues a secondary callback into the thread pool that executes the user-specified <code>job</code> through the multiplexor. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> JobQueue::processJob(<span class="keyword">const</span> JobQueue::Job&amp; job)
  {
      <span class="keywordflow">return</span> d_threadPool_p-&gt;tryEnqueueJob(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
                                  &amp;bdlmt::ThreadMultiplexor::processJob&lt;Job&gt;,
                                  &amp;d_multiplexor,
                                  job));
  }
</pre></div><br/>
<br/>
 The following program uses three instances of <code>JobQueue</code> to process important, urgent, and critical jobs using a single collection of threads. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
  {
      <span class="keyword">enum</span> {
          NUM_THREADS   = 5,   <span class="comment">// total number of threads</span>
          NUM_QUEUES    = 3,   <span class="comment">// total number of JobQueue objects</span>
          MAX_QUEUESIZE = 20   <span class="comment">// total number of pending jobs</span>
      };

      <span class="keywordtype">int</span> maxProc = bsl::max(1,
                             ceil(<span class="keywordtype">double</span>(MAX_THREADS) / (NUM_QUEUES-1))-1);

      <a class="code" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a> tp(NUM_THREADS, MAX_QUEUESIZE);
      JobQueue             importantQueue(maxProc, &amp;tp);
      JobQueue             urgentQueue(maxProc, &amp;tp);
      JobQueue             criticalQueue(maxProc, &amp;tp);

      <span class="keywordflow">if</span> (0 != tp.start()) {
         ASSERT(!<span class="stringliteral">&quot;Could not start thread pool!&quot;</span>);
         <span class="keywordflow">return</span> -1;
      }

      JobQueue::Job ijob =
         <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;<a class="code" href="classbsls_1_1AtomicInt.html#af1263cf59fa4a376a5a8a68f6f8ba8ad">bsls::AtomicInt::add</a>, &amp;iCheck, 1);

      JobQueue::Job ujob = <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
         <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;<a class="code" href="classbsls_1_1AtomicInt.html#af1263cf59fa4a376a5a8a68f6f8ba8ad">bsls::AtomicInt::add</a>, &amp;uCheck, 1);

      JobQueue::Job cjob = <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
         <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;<a class="code" href="classbsls_1_1AtomicInt.html#af1263cf59fa4a376a5a8a68f6f8ba8ad">bsls::AtomicInt::add</a>, &amp;cCheck, 1);

      importantQueue.processJob(ijob);
      importantQueue.processJob(ijob);
      importantQueue.processJob(ijob);
      importantQueue.processJob(ijob);
      importantQueue.processJob(ijob);
      importantQueue.processJob(ijob);

      urgentQueue.processJob(ujob);
      urgentQueue.processJob(ujob);
      urgentQueue.processJob(ujob);
      urgentQueue.processJob(ujob);

      criticalQueue.processJob(cjob);
      criticalQueue.processJob(cjob);

      tp.stop();
      ASSERT(6 == iCheck);
      ASSERT(4 == uCheck);
      ASSERT(2 == cCheck);
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:46 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
