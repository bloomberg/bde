<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslma_newdeleteallocator.h                                         -*-C++-*-
#ifndef INCLUDED_BSLMA_NEWDELETEALLOCATOR
#define INCLUDED_BSLMA_NEWDELETEALLOCATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide singleton new/delete adaptor to &#39;bslma::Allocator&#39; protocol.
//
//@CLASSES:
//  bslma::NewDeleteAllocator: support new/delete-style allocation/deallocation
//
//@SEE_ALSO: bslma_default, bslma_testallocator
//
//@DESCRIPTION: This component provides a concrete allocation mechanism,
// &#39;bslma::NewDeleteAllocator&#39;, that implements the &#39;bslma::Allocator&#39; protocol
// to provide direct access to the system-supplied (native) global
// &#39;operator new&#39; and &#39;operator delete&#39; functions via that pure abstract
// interface.
//..
//   ,-------------------------.
//  ( bslma::NewDeleteAllocator )
//   `-------------------------&#39;
//               |         allocator
//               |         singleton
//               |         ctor/dtor
//               V
//       ,----------------.
//      ( bslma::Allocator )
//       `----------------&#39;
//                       allocate
//                       deallocate
//..
// The essential purpose of this component is to facilitate the default use of
// global &#39;new&#39; and &#39;delete&#39; in all components that accept a user-supplied
// allocator derived from &#39;bslma::Allocator&#39; (see &#39;bslma_default&#39;).  Hence, the
// global &#39;operator new&#39; and &#39;operator delete&#39; functions are wrapped within
// concrete methods of a derived &#39;bslma::NewDeleteAllocator&#39; class.  A &#39;static&#39;
// (factory) method of &#39;bslma::NewDeleteAllocator&#39; can be used to obtain a
// unique (singleton) &#39;bslma::NewDeleteAllocator&#39; object for the given process,
// and whose lifetime is guaranteed to exceed any possibility of its use.  Note
// that the standard also requires the global &#39;operator new&#39; to return
// maximally-aligned memory, which is a stricter post condition than the
// natural-alignment requirement imposed by the base-class contract, or than is
// provided by many other concrete implementations.
//
///Thread Safety
///-------------
// This class is fully thread-safe, which means that all non-creator object
// methods can be safely accessed concurrently (from multiple treads).  The
// singleton &#39;bslma::NewDeleteAllocator&#39; can also be safely created/accessed
// concurrently (from multiple threads) via either the &#39;static&#39; &#39;singleton&#39; or
// &#39;allocator&#39; (factory) methods.  Moreover, the underlying (native)
// implementation of &#39;new&#39; and &#39;delete&#39; are required by the C++ standard to
// ensure that concurrent access to either the virtual &#39;allocate&#39; and/or
// &#39;deallocate&#39; are also safe (i.e., will not not result in heap corruption).
// Note that this allocator therefore has stronger thread-safety guarantees
// than is required by the base-class contract or than is provided by many
// other derived concrete allocators.
//
///Usage
///-----
// The most common and proper use of &#39;bslma::NewDeleteAllocator&#39; is both
// *indirect* and *by* *default* (see &#39;bslma_default&#39;).  For example, consider
// (along with its destructor) the default and copy constructors for, say, a
// simple container, such as &#39;my_ShortArray&#39;, each of which take as its final
// optional argument the address of a &#39;bslma::Allocator&#39; protocol:
//..
//  // my_shortarray.h:
//  // ...
//  namespace bslma { class Allocator; }
//
//  class my_ShortArray {
//      short            *d_array_p;     // dynamically-allocated array
//      int               d_capacity;    // physical capacity (in elements)
//      int               d_length;      // logical length (in elements)
//      bslma::Allocator *d_allocator_p; // memory allocator (not owned)
//
//    public:
//      my_ShortArray(bslma::Allocator *basicAllocator = 0);
//          // Create an empty &#39;my_shortArray&#39;.  Optionally specify a
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39;
//          // is 0, the currently installed default allocator is used.
//
//      my_ShortArray(const my_ShortArray&amp;  other,
//                    bslma::Allocator     *basicAllocator = 0);
//          // Create a &#39;bslma::ShortArray&#39; having the same value as the
//          // specified &#39;other&#39; array.  Optionally specify a &#39;basicAllocator&#39;
//          // used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently
//          // installed default allocator is used.
//
//      ~my_ShortArray();
//          // Destroy this object.
//
//     // ...
//  };
//
//  // ...
//..
// In order to satisfy this contract, we will need a globally accessible
// utility (see &#39;bslma_default&#39;), which by default returns the singleton
// &#39;bslma::NewDeleteAllocator&#39;, but which could be configured to return some
// other allocator, say a *test* allocator (see &#39;bslma_testallocator&#39;):
//..
//  // my_default.h:
//  // ...
//  namespace bslma { class Allocator; }
//
//  struct my_Default {
//      // This class maintains a process-wide &#39;bslma::Allocator&#39; object
//      // to be used when an allocator is needed, and not suppled explicitly.
//      // By default, the currently installed default allocator is the unique
//      // &#39;bslma::NewDeleteAllocator&#39; object returned by the &#39;static&#39; method,
//      // &#39;bslma::NewDeleteAllocator::singleton()&#39;.  Note that the default
//      // allocator will exist longer than any possibility of its use.
//
//      static bslma::Allocator *allocator(bslma::Allocator *basicAllocator);
//          // Return the address of the specified modifiable
//          // &#39;basicAllocator&#39; or, if &#39;basicAllocator&#39; is 0, an instance of
//          // the currently installed default &#39;bslma::Allocator&#39; object, which
//          // will exist longer than any possibility of its use.  Note
//          // that this function can safely be called concurrently (from
//          // multiple threads).
//
//      static bslma::Allocator *replace(bslma::Allocator *basicAllocator);
//          // Replace the address of the currently installed allocator with
//          // that of the specified modifiable &#39;basicAllocator&#39; (or if 0,
//          // with the &quot;factory&quot; default, &#39;bslma::NewDeleteAllocator&#39;), and
//          // return the address of the previous allocator.  The behavior is
//          // undefined unless &#39;basicAllocator&#39; will exist longer than any
//          // possibility of its use.  Note that this function is *not* *at*
//          // *all* thread-safe, and should *never* be called when multiple
//          // threads are active.
//  };
//
//  // my_default.cpp:
//  // ...
//
//  #include &lt;my_default.h&gt;
//
//  static bslma::Allocator *s_default_p = 0; // load-time initialized
//
//  bslma::Allocator *my_Default::allocator(bslma::Allocator *basicAllocator)
//  {
//      return bslma::NewDeleteAllocator::allocator(s_default_p);
//  }
//
//  bslma::Allocator *my_Default::replace(bslma::Allocator *basicAllocator)
//  {
//      bslma::Allocator *tmp =
//                           bslma::NewDeleteAllocator::allocator(s_default_p);
//      s_default_p = bslma::NewDeleteAllocator::allocator(basicAllocator);
//      return tmp;
//  }
//..
// Notice that the only part of the &#39;bslma::NewDeleteAllocator&#39; class we used
// directly was its static &#39;allocator&#39; method, which -- in addition to safely
// constructing the singleton &#39;bslma::NewDeleteAllocator&#39; object on first
// access -- also automatically replaces a 0 address value with that of
// singleton &#39;bslma::NewDeleteAllocator&#39; object.  From now on, we will never
// again need to invoke the &#39;bslma_newdeleteallocator&#39; component&#39;s interface
// directly, but instead use it through &#39;my_Default&#39; (see &#39;bslma::Default&#39; for
// what is actually used in practice).
//
// Turning back to our &#39;my_shortarray&#39; example, let&#39;s now implement the two
// constructors using the &#39;bslma_newdeleteallocator&#39; component indirectly via
// the &#39;my_default&#39; component:
//..
//  // my_shortarray.cpp:
//  #include &lt;my_shortarray.h&gt;
//  #include &lt;my_default.h&gt;
//  #include &lt;bsls_assert.h&gt;
//
//  // ...
//
//  enum {
//      INITIAL_CAPACITY = 0, // recommended to avoid unnecessary allocations
//                            // possibly resulting in locking and extra thread
//                            // contention for the &#39;bslma::NewDeleteAllocator&#39;
//
//      GROW_FACTOR = 2       // typical value for geometric growth
//  };
//
//  // ...
//
//  my_ShortArray::my_ShortArray(bslma::Allocator *basicAllocator)
//  : d_capacity(INITIAL_CAPACITY)
//  , d_length(0)
//  , d_allocator_p(my_Default::allocator(basicAllocator))
//  {
//      assert(d_allocator_p);
//      d_array_p = (short *)  // no thread contention if &#39;d_capacity&#39; is 0
//                  d_allocator_p-&gt;allocate(d_capacity * sizeof *d_array_p);
//      assert(0 == d_array_p);
//  }
//
//  my_ShortArray::my_ShortArray(const my_ShortArray&amp;   other,
//                               bslma::Allocator      *basicAllocator)
//  : d_capacity(other.d_capacity)
//  , d_length(other.d_length)
//  , d_allocator_p(my_Default::allocator(basicAllocator))
//  {
//      assert(d_allocator_p);
//      d_array_p = (short *)
//                  d_allocator_p-&gt;allocate(d_capacity * sizeof *d_array_p);
//      assert(!d_capacity == !d_array_p);
//      memcpy(d_array_p, other.d_array_p, d_length * sizeof *d_array_p);
//  }
//
//  my_ShortArray::~my_ShortArray()
//  {
//      d_allocator_p-&gt;deallocate(d_array_p); // no locking if &#39;d_array_p&#39; is 0
//  }
//
// // ...
//..
// When the default constructor is called, the default capacity and length are
// recorded in data members via the initialization list.  The static function
// &#39;allocator&#39; (provided in &#39;my_Default&#39;) is used to assign the value of the
// &#39;basicAllocator&#39; address passed in, or if that is 0, the address of the
// currently installed default allocator, which by default is the singleton
// object of type &#39;bslma::NewDeleteAllocator&#39;, defined in this component.  Note
// that since &#39;INITIAL_CAPACITY&#39; is 0, a default constructed object that is
// created using a &#39;bslma::NewDeleteAllocator&#39; will *not* invoke the
// &#39;operator new&#39; function, which on some platforms may needlessly acquire a
// lock, causing unnecessary overhead (the same potential overhead is avoided
// for &#39;operator delete&#39; whenever a 0 &#39;d_array_p&#39; value is deallocated in the
// destructor) and &#39;d_allocator_p&#39; refers to a &#39;bslma::NewDeleteAllocator&#39;.
// Note also that, for the copy constructor, the currently installed default
// allocator, and not the &#39;other&#39; array&#39;s allocator is used whenever
// &#39;basicAllocator&#39; is 0 or not explicitly supplied.
//
// Finally note that this entire component is *not* intended for direct use by
// typical clients: See &#39;bslma_default&#39; for more information or proper usage.

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

namespace BloombergLP {

namespace bslma {

                        // ========================
                        // class NewDeleteAllocator
                        // ========================

class NewDeleteAllocator : public Allocator {
    // This class defines a concrete mechanism that adapts the system-supplied
    // (native) global &#39;operator new&#39; and &#39;operator delete&#39; to the &#39;Allocator&#39;
    // protocol.  The class method &#39;singleton&#39; returns a process-wide unique
    // object of this class whose lifetime is guaranteed to extend from the
    // first call to &#39;singleton&#39; until the program terminates.  A second class
    // method, &#39;allocator&#39;, allows for conveniently replacing a &quot;null&quot;
    // allocator with this singleton object.  Note that this entire class
    // should generally not be used directly by typical clients (see
    // &#39;bslma_default&#39; for more information).

  private:
    // NOT IMPLEMENTED
    NewDeleteAllocator(const NewDeleteAllocator&amp;);
    NewDeleteAllocator&amp; operator=(const NewDeleteAllocator&amp;);

  public:
    // CLASS METHODS
    static NewDeleteAllocator&amp; singleton();
        // Return a reference to a process-wide unique object of this class.
        // The lifetime of this object is guaranteed to extend from the first
        // call of this method until the program terminates.  Note that this
        // method should generally not be used directly by typical clients (see
        // &#39;bslma_default&#39; for more information).

    static Allocator *allocator(Allocator *basicAllocator);
        // Return the address of the specified modifiable &#39;basicAllocator&#39; or,
        // if &#39;basicAllocator&#39; is 0, the process-wide unique (see &#39;singleton&#39;)
        // object of this class.  Note that the behavior of this function is
        // equivalent to the following expression:
        //..
        //  basicAllocator
        //  ? basicAllocator
        //  : &amp;NewDeleteAllocator::singleton()
        //..
        // Also note that if a &#39;NewDeleteAllocator&#39; object is supplied, it is
        // owned by the class and must NOT be deleted.  Finally note that this
        // method should generally not be called directly by typical clients
        // (see &#39;bslma_default&#39; for more information).

    // CREATORS
    NewDeleteAllocator();
        // Create a (&quot;stateless&quot;) new-delete-allocator object that wraps the
        // global native &#39;operator new&#39; and &#39;operator delete&#39; functions in
        // order to supply memory via the &#39;Allocator&#39; protocol.  Note that all
        // objects of this class share the same underlying resource; hence,
        // this constructor should generally not be invoked directly by
        // clients; instead, consider using the &#39;static&#39; &#39;singleton&#39; or
        // &#39;allocator&#39; (factory) methods, or -- better -- the appropriate ones
        // in &#39;Default&#39; (see &#39;bslma_default&#39; for more information).

    virtual ~NewDeleteAllocator();
        // Destroy this allocator object.  Note that destroying this allocator
        // has no effect on any outstanding allocated memory.

    // MANIPULATORS
    virtual void *allocate(size_type size);
        // Return a newly allocated block of memory of (at least) the specified
        // positive &#39;size&#39; (in bytes).  If &#39;size&#39; is 0, a null pointer is
        // returned with no other effect.  The alignment of the address
        // returned is the maximum alignment for any fundamental, pointer, or
        // enumerated type defined for this platform.  The behavior is
        // undefined unless &#39;0 &lt;= size&#39;.  Note that global &#39;operator new&#39; is
        // *not* called when &#39;size&#39; is 0 (in order to avoid having to acquire a
        // lock, and potential contention in multi-threaded programs).

    virtual void deallocate(void *address);
        // Return the memory block at the specified &#39;address&#39; back to this
        // allocator.  If &#39;address&#39; is 0, this function has no effect.  The
        // behavior is undefined unless &#39;address&#39; was allocated using this
        // allocator object and has not already been deallocated.  Note that
        // global &#39;operator delete&#39; is *not* called when &#39;address&#39; is 0 (in
        // order to avoid having to acquire a lock, and potential contention in
        // multi-threaded programs).
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                        // ------------------------
                        // class NewDeleteAllocator
                        // ------------------------

// CLASS METHODS
inline
Allocator *NewDeleteAllocator::allocator(Allocator *basicAllocator)
{
    return basicAllocator ? basicAllocator : &amp;singleton();
}

// CREATORS
inline
NewDeleteAllocator::NewDeleteAllocator()
{
}

// MANIPULATORS
inline
void NewDeleteAllocator::deallocate(void *address)
{
    // While the C++ standard guarantees that calling delete(0) is safe
    // (3.7.3.2 paragraph 3), some libc implementations take out a lock to deal
    // with the free(0) case, so this check can improve efficiency of threaded
    // programs.

    if (address) {
        ::operator delete(address);
    }
}

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
