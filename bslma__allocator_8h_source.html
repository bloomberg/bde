<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslma_allocator.h                                                  -*-C++-*-
#ifndef INCLUDED_BSLMA_ALLOCATOR
#define INCLUDED_BSLMA_ALLOCATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a pure abstract interface for memory-allocation mechanisms.
//
//@CLASSES:
//  bslma::Allocator: protocol class for memory allocation and deallocation
//
//@SEE_ALSO: bslma_newdeleteallocator, bslma_testallocator
//
//@DESCRIPTION: This component provides the base-level protocol (pure abstract
// interface) class, &#39;bslma_allocator&#39;, that serves as a ubiquitous vocabulary
// type for various memory allocation mechanisms.  The functional capabilities
// documented by this protocol are similar to those afforded by global
// operators &#39;new&#39; and &#39;delete&#39;: sufficiently (but not necessarily maximally)
// aligned memory is guaranteed for any object of a given size.  Clients of
// this abstract base class will typically accept a supplied allocator (often
// at construction) and use its &#39;allocate&#39; and &#39;deallocate&#39; methods instead of
// &#39;new&#39; and &#39;delete&#39; directly.
//
// The use of (abstract) allocators provide at least three distinct advantages
// over direct (hard-coded) calls to global &#39;new&#39; and &#39;delete&#39; (see
// &#39;bslma_newdeleteallocator&#39;):
//
//: 1 The particular choice of allocator can be selected to improve performance
//:   on a per-object basis.  Without allocators, the best we can do in C++ is
//:   to overload the class-specific new and delete.  Class-specific allocators
//:   tend to hoard memory even when most objects of the class have been
//:   deallocated, and often mask memory leaks that would otherwise have been
//:   detected.  See Lakos-96, Section 10.3.4.2, pp 705-711.
//:
//: 2 By providing extra capabilities (beyond &#39;new&#39; and &#39;delete&#39;) in the
//:   derived class (see &#39;bslma_managedallocator&#39;), we can bypass the
//:   individual destructors in a dynamically allocated type and remove all
//:   memory for one or more associated object almost instantly.
//:
//: 3 The &#39;bslma::Allocator&#39; protocol, like any other protocol, isolates
//:   clients from direct coupling with platform level facilities that are not
//:   fully under their control.  By installing a test allocator (see
//:   &#39;bslma_testallocator&#39;), we are able to orchestrate the white-box testing
//:   of internal calls to global operators &#39;new&#39; and &#39;delete&#39; in a
//:   platform-neutral manner.
//
///Thread Safety
///-------------
// Unless otherwise documented, a single allocator object is not safe for
// concurrent access by multiple threads.  Classes derived from
// &#39;bslma::Allocator&#39; that are specifically designed for concurrent access must
// be documented as such.  Unless specifically documented otherwise, separate
// objects of classes derived from &#39;bslma::Allocator&#39; may safely be used in
// separate threads.
//
///Allocators Versus Pools
///-----------------------
// An allocator and a pool are quite different.  For starters,
// &#39;bslma::Allocator&#39; is an abstract class used to obtain &quot;raw&quot; memory of
// arbitrary size.  A pool is a concrete data structure used to organize and
// supply memory according to specific needs (e.g., a consistent size).
// Concrete allocators may use pools in their implementations, and pools will
// aways take a base &#39;bslma::Allocator&#39; protocol in their interface.  You can
// think of an allocator as a stream of memory that flows into a pool of
// memory.  Memory is allocated from the pool until it is dry; only then does
// new memory flow into the pool from the allocator.
//
///Overloaded Global Operators &#39;new&#39; and &#39;delete&#39;
///----------------------------------------------
// This component overloads the global operator &#39;new&#39; to allow convenient
// syntax for the construction of objects using the &#39;bslma::Allocator&#39;
// protocol.  The overloaded &#39;new&#39; operator defined in this component has a
// second parameter, &#39;bslma::Allocator&amp;&#39;, that identifies the concrete
// (derived) allocator that will be used to supply memory.
//
// Consider the following use of standard placement syntax (supplied by
// &#39;#include &lt;new&gt;&#39;) along with a &#39;bslma::Allocator&#39;, used to allocate an
// arbitrary &#39;TYPE&#39;.
//..
//  void someFunction(bslma::Allocator *basicAllocator)
//  {
//      TYPE *obj = new (basicAllocator-&gt;allocate(sizeof(TYPE))) TYPE(...);
//
//      // ...
//..
// This style of usage is inconvenient and error prone; it is also *not*
// exception safe: If the constructor of &#39;TYPE&#39; throws an exception, the
// &#39;basicAllocator-&gt;deallocate&#39; method is never called.
//
// Providing an overloaded global operator &#39;new&#39;, taking a reference to a
// modifiable &#39;bslma::Allocator&#39; as an explicit argument allows for cleaner
// usage and guarantees that the &#39;basicAllocator-&gt;deallocate&#39; method is called
// in case of an exception:
//..
//  void someFunction(bslma::Allocator *basicAllocator)
//  {
//      TYPE *obj = new (*basicAllocator) TYPE(...);
//
//      // ...
//..
// Finally, the analogous version of operator &#39;delete&#39; should not be called
// directly: The overloaded operator &#39;delete&#39; supplied in this component is
// solely for the compiler to invoke in the event an exception is thrown during
// a failed construction.  Instead, the &#39;bslma::Allocator&#39; protocol provides
// &#39;deleteObject&#39; (a template member function parameterized by the type of the
// object being deleted), which is implemented *conceptually* as follows:
//..
//  template &lt;class TYPE&gt;
//  void bslma::Allocator::deleteObject(TYPE *address)
//  {
//      address-&gt;~TYPE();
//      this-&gt;deallocate(address);
//  }
//..
// Note that there is also a &#39;deleteObjectRaw&#39; which is more efficient when it
// is known that the &#39;address&#39; does *not* refer to a secondary base class of
// the object being deleted.
//
///Usage
///-----
// The &#39;bslma::Allocator&#39; protocol provided in this component defines a
// bilateral contract between suppliers and consumers of raw memory.  The
// following subsections illustrate (1) use, and (2) implementation of the
// abstract &#39;bslma::Allocator&#39; base class:
//
///Usage 1: Container Objects
///- - - - - - - - - - - - -
// Allocators are often supplied to objects requiring dynamically-allocated
// memory at construction.  For example, consider the following
// &#39;my_DoubleStack&#39; class, parameterized by a &#39;bslma::Allocator&#39;:
//..
//  // my_doublestack.h
//  // ...
//
//  namespace bslma { class Allocator; } // forward declaration of allocator
//
//  class my_DoubleStack {
//      // DATA
//      double           *d_stack_p;     // dynamically allocated array (d_size
//                                       // elements)
//
//      int               d_size;        // physical capacity of this stack (in
//                                       // elements)
//
//      int               d_length;      // logical index of next available
//                                       // stack element
//
//      bslma::Allocator *d_allocator_p; // holds (but does not own) object
//
//      // FRIENDS
//      friend class my_DoubleStackIter;
//
//    private:
//      // PRIVATE MANIPULATORS
//      void increaseSize(); // Increase the capacity by at least one element.
//
//    public:
//      // CREATORS
//      my_DoubleStack(bslma::Allocator *basicAllocator = 0);
//      my_DoubleStack(const my_DoubleStack&amp;  other,
//                     bslma::Allocator       *basicAllocator = 0);
//      ~my_DoubleStack();
//
//      // MANIPULATORS
//      my_DoubleStack&amp; operator=(const my_DoubleStack&amp; rhs);
//      void push(double value);
//      void pop();
//
//      // ACCESSORS
//      const double&amp; top() const;
//      bool isEmpty() const;
//  };
//
//  // ...
//
//  inline
//  void my_DoubleStack::push(double value)
//  {
//      if (d_length &gt;= d_size) {
//          increaseSize();
//      }
//      d_stack_p[d_length++] = item;
//  }
//
//  // ...
//..
// The stack interface takes an optional &#39;basicAllocator&#39; supplied only at
// construction.  (We avoid use of the name &#39;allocator&#39; so as not to conflict
// with the STL use of the word, which differs slightly.)  If non-zero, the
// stack holds a pointer to this allocator, but does not own it.  If no
// allocator is supplied, the implementation itself must either conditionally
// invoke global &#39;new&#39; and &#39;delete&#39; explicitly whenever memory dynamic memory
// must be managed (BAD IDEA) or (GOOD IDEA) install a default allocator that
// adapts use of these global operators to the &#39;bslma_allocator&#39; interface (see
// &#39;bslma_newdeleteallocator&#39;).
//..
//  // my_doublestack.cpp
//  #include &lt;my_doublestack.h&gt;
//  #include &lt;bslma_allocator.h&gt;
//  #include &lt;bslma_newdeleteallocator.h&gt;  // adapter for &#39;new&#39; and &#39;delete&#39;
//  // ...
//
//  enum { INITIAL_SIZE = 1, GROW_FACTOR = 2 };
//
//  // ...
//
//  // CREATORS
//  my_DoubleStack::my_DoubleStack(bslma::Allocator *basicAllocator)
//  : d_size(INITIAL_SIZE)
//  , d_length(0)
//  , d_allocator_p(bslma::NewDeleteAllocator::allocator(basicAllocator))
//      // The above initialization expression is equivalent to &#39;basicAllocator
//      // ? basicAllocator : &amp;bslma::NewDeleteAllocator::singleton()&#39;.
//  {
//      assert(d_allocator_p);
//      d_stack_p = (double *)
//                  d_allocator_p-&gt;allocate(d_size * sizeof *d_stack_p);
//  }
//
//  my_DoubleStack::~my_DoubleStack()
//  {
//      // CLASS INVARIANTS
//      assert(d_allocator_p);
//      assert(d_stack_p);
//      assert(0 &lt;= d_length);
//      assert(0 &lt;= d_size);
//      assert(d_length &lt;= d_size);
//
//      d_allocator_p-&gt;deallocate(d_stack_p);
//  }
//..
// Even in this simplified implementation, all use of the allocator protocol is
// relegated to the &#39;.cpp&#39; file.  Subsequent use of the allocator is
// demonstrated by the following file-scope static reallocation function:
//..
//  static inline
//  void reallocate(double          **array,
//                  int               newSize,
//                  int               length,
//                  bslma::Allocator  *basicAllocator)
//      // Reallocate memory in the specified &#39;array&#39; to the specified
//      // &#39;newSize&#39; using the specified &#39;basicAllocator&#39;.  The specified
//      // &#39;length&#39; number of leading elements are preserved.  Since the
//      // class invariant requires that the physical capacity of the
//      // container may grow but never shrink, the behavior is undefined
//      // unless &#39;length &lt;= newSize&#39;.
//  {
//      assert(array);
//      assert(1 &lt;= newSize);
//      assert(0 &lt;= length);
//      assert(basicAllocator);
//      assert(length &lt;= newSize);  // enforce class invariant
//
//      double *tmp = *array;       // support exception neutrality
//      *array = (double *) basicAllocator-&gt;allocate(newSize * sizeof **array);
//
//      // COMMIT POINT
//
//      std::memcpy(*array, tmp, length * sizeof **array);
//      basicAllocator-&gt;deallocate(tmp);
//  }
//
//  // PRIVATE MANIPULATORS
//  void my_DoubleStack::increaseSize()
//  {
//      int proposedNewSize = d_size * GROW_FACTOR;  // reallocate can throw
//      assert(proposedNewSize &gt; d_length);
//      reallocate(&amp;d_stack_p, proposedNewSize, d_length, d_allocator_p);
//      d_size = proposedNewSize;                    // we&#39;re committed
//  }
//..
///Usage 2: Derived Concrete Allocators
///- - - - - - - - - - - - - - - - - -
// In order for the &#39;bslma::Allocator&#39; interface to be useful, we must supply a
// concrete allocator that implements it.  In this example we demonstrate how
// to adapt &#39;operator new&#39; and &#39;operator delete&#39; to this protocol base class.
//..
//  // my_newdeleteallocator.h
//  // ...
//
//  class my_NewDeleteAllocator : public bslma::Allocator {
//      // This class is a sample concrete implementation of the
//      // &#39;bslma::Allocator&#39; protocol that provides direct access to the
//      // system-supplied (native) global operators &#39;new&#39; and &#39;delete&#39;.
//
//      // NOT IMPLEMENTED
//      my_NewDeleteAllocator(const bslma::NewDeleteAllocator&amp;);
//      my_NewDeleteAllocator&amp; operator=(const bslma::NewDeleteAllocator&amp;);
//
//    public:
//      // CREATORS
//      my_NewDeleteAllocator();
//          // Create an allocator that wraps the global (native) operators
//          // &#39;new&#39; and &#39;delete&#39; to supply memory.  Note that all objects of
//          // this class share the same underlying resource.
//
//      virtual ~my_NewDeleteAllocator();
//          // Destroy this allocator object.  Note that destroying this
//          // allocator has no effect on any outstanding allocated memory.
//
//      // MANIPULATORS
//      virtual void *allocate(size_type size);
//          // Return a newly allocated block of memory of (at least) the
//          // specified positive &#39;size&#39; (in bytes).  If &#39;size&#39; is 0, a null
//          // pointer is returned with no other effect.  If this allocator
//          // cannot return the requested number of bytes, then it will throw
//          // a &#39;std::bad_alloc&#39; exception in an exception-enabled build, or
//          // else will abort the program in a non-exception build.  The
//          // behavior is undefined unless &#39;0 &lt;= size&#39;.  Note that the
//          // alignment of the address returned is the maximum alignment for
//          // any type defined on this platform.  Also note that global
//          // &#39;operator new&#39; is *not* called when &#39;size&#39; is 0 (in order to
//          // avoid having to acquire a lock, and potential contention in
//          // multi-threaded programs).
//
//      virtual void deallocate(void *address);
//          // Return the memory block at the specified &#39;address&#39; back to this
//          // allocator.  If &#39;address&#39; is 0, this function has no effect.  The
//          // behavior is undefined unless &#39;address&#39; was allocated using this
//          // allocator object and has not already been deallocated.  Note
//          // that global &#39;operator delete&#39; is *not* called when &#39;address&#39; is
//          // 0 (in order to avoid having to acquire a lock, and potential
//          // contention in multi-treaded programs).
//  };
//
//  // CREATORS
//  inline
//  my_NewDeleteAllocator::my_NewDeleteAllocator()
//  {
//  }
//  // ...
//..
// The virtual methods of &#39;my_NewDeleteAllocator&#39; are defined in the component
// &#39;.cpp&#39; file as they would not be inlined when invoked from the base class,
// which would be the typical usage in this case:
//..
//  // my_newdeleteallocator.cpp
//  #include &lt;my_newdeleteallocator.h&gt;
//
//  // CREATORS
//  my_NewDeleteAllocator::~my_NewDeleteAllocator()
//  {
//  }
//
//  // MANIPULATORS
//  void *my_NewDeleteAllocator::allocate(size_type size)
//  {
//      BSLS_ASSERT_SAFE(0 &lt;= size);
//
//      return 0 == size ? 0 : ::operator new(size);
//  }
//
//  void my_NewDeleteAllocator::deallocate(void *address)
//  {
//      // While the C++ standard guarantees that calling delete(0) is safe
//      // (3.7.3.2 paragraph 3), some libc implementations take out a lock to
//      // deal with the free(0) case, so this check can improve efficiency of
//      // threaded programs.
//
//      if (address) {
//          ::operator delete(address);
//      }
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DELETERHELPER
#include &lt;bslma_deleterhelper.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;       // for &#39;std::size_t&#39;, &#39;std::ptrdiff_t&#39;
#define INCLUDED_CSTDDEF
#endif

namespace BloombergLP {

namespace bslma {

                        // ===============
                        // class Allocator
                        // ===============

class Allocator {
    // This protocol class provides a pure abstract interface and contract for
    // clients and suppliers of raw memory.  If the requested memory cannot be
    // returned; the contract requires that an &#39;std::bad_alloc&#39; exception be
    // thrown.  Note that memory is guaranteed to be sufficiently aligned for
    // any object of the requested size on the current platform, which may be
    // less than the maximal alignment guarantee afforded by global
    // &#39;operator new&#39;.

  public:
    // PUBLIC TYPES
    typedef bsls::Types::size_type size_type;  // TBD change to unsigned?
        // Alias for a signed integral type capable of representing the number
        // of bytes in this platform&#39;s virtual address space.

    // CLASS METHODS
    static void throwBadAlloc();  // TBD does this belong here?
        // Throw &#39;std::bad_alloc&#39; if exceptions are enabled or abort the
        // program otherwise.  Derived classes and helper functions will
        // typically call this function when they are unable to satisfy an
        // allocation request.  This function never returns.

    // CREATORS
    virtual ~Allocator();
        // Destroy this allocator.  Note that the behavior of destroying an
        // allocator while memory is allocated from it is not specified.
        // (Unless you *know* that it is valid to do so, don&#39;t!)

    // MANIPULATORS
    virtual void *allocate(size_type size) = 0;
        // Return a newly allocated block of memory of (at least) the specified
        // positive &#39;size&#39; (in bytes).  If &#39;size&#39; is 0, a null pointer is
        // returned with no other effect.  If this allocator cannot return the
        // requested number of bytes, then it will throw a &#39;std::bad_alloc&#39;
        // exception in an exception-enabled build, or else will abort the
        // program in a non-exception build.  The behavior is undefined unless
        // &#39;0 &lt;= size&#39;.  Note that the alignment of the address returned
        // conforms to the platform requirement for any object of the specified
        // &#39;size&#39;.

    virtual void deallocate(void *address) = 0;
        // Return the memory block at the specified &#39;address&#39; back to this
        // allocator.  If &#39;address&#39; is 0, this function has no effect.  The
        // behavior is undefined unless &#39;address&#39; was allocated using this
        // allocator object and has not already been deallocated.

    template &lt;class TYPE&gt;
    void deleteObject(const TYPE *object);
        // Destroy the specified &#39;object&#39; based on its dynamic type and then
        // use this allocator to deallocate its memory footprint.  Do nothing
        // if &#39;object&#39; is a null pointer.  The behavior is undefined unless
        // &#39;object&#39;, when cast appropriately to &#39;void *&#39;, was allocated using
        // this allocator and has not already been deallocated.  Note that
        // &#39;dynamic_cast&lt;void *&gt;(object)&#39; is applied if &#39;TYPE&#39; is polymorphic,
        // and &#39;static_cast&lt;void *&gt;(object)&#39; is applied otherwise.

    template &lt;class TYPE&gt;
    void deleteObjectRaw(const TYPE *object);
        // Destroy the specified &#39;object&#39; and then use this allocator to
        // deallocate its memory footprint.  Do nothing if &#39;object&#39; is a null
        // pointer.  The behavior is undefined unless &#39;object&#39; was allocated
        // using this allocator, is !not! a secondary base class pointer --
        // i.e., the address is (numerically) the same as when it was
        // originally dispensed by this allocator, and has not already been
        // deallocated.
};

}  // close package namespace


}  // close enterprise namespace

// FREE OPERATORS

// Note that the operators &#39;new&#39; and &#39;delete&#39; are declared outside the
// &#39;BloombergLP&#39; namespace so that they do not hide the standard placement
// &#39;new&#39; and &#39;delete&#39; operators (i.e.,
// &#39;void *operator new(std::size_t, void *)&#39; and
// &#39;void operator delete(void *)&#39;).
//
// Note also that only the scalar versions of operators &#39;new&#39; and &#39;delete&#39; are
// provided, because overloading &#39;new&#39; (and &#39;delete&#39;) with their array versions
// would cause dangerous ambiguity.  Consider what would have happened had we
// overloaded the array version of operator &#39;new&#39;:
//..
//  void *operator new[](std::size_t size,
//                       BloombergLP::bslma::Allocator&amp; basicAllocator)
//..
// The user of the allocator class may expect to be able to use array
// &#39;operator new&#39; as follows:
//..
//  new (*basicAllocator) my_Type[...];
//..
// The problem is that this expression returns an array that cannot be safely
// deallocated.  On the one hand, there is no syntax in C++ to invoke an
// overloaded &#39;operator delete&#39; that, other than deallocating memory, would
// invoke the destructor.  On the other hand, the pointer returned by
// &#39;operator new&#39; cannot be passed to the &#39;deallocate&#39; method directly because
// the pointer is different from the one returned by the &#39;allocate&#39; method.
// The compiler offsets the value of this pointer by a header, which is used to
// maintain the number of objects in the array (so that the non-overloaded
// &#39;operator delete&#39; can destroy the right number of objects).

inline
void *operator new(std::size_t                    size,
                   BloombergLP::bslma::Allocator&amp; basicAllocator);
    // Return the memory allocated from the specified &#39;basicAllocator&#39; of at
    // least the specified &#39;size&#39; bytes, or 0 if &#39;size&#39; is 0.  The behavior is
    // undefined unless &#39;0 &lt;= static_cast&lt;bslma::Allocator::size_type&gt;(size)&#39;.
    // Note that an object may allocate additional memory internally, requiring
    // the allocator to be passed in as a constructor argument:
    //..
    //  my_Type *createMyType(bslma::Allocator *basicAllocator)
    //  {
    //      return new (*basicAllocator) my_Type(..., basicAllocator);
    //  }
    //..
    // Note also that the analogous version of operator &#39;delete&#39; should *not*
    // be called directly.  Instead, this component provides a template member
    // function &#39;deleteObject&#39; parameterized by &#39;TYPE&#39; that effectively
    // performs the following operations:
    //..
    //  void deleteMyType(bslma::Allocator *basicAllocator, my_Type *address)
    //  {
    //      address-&gt;~my_Type();
    //      basicAllocator-&gt;deallocate(object);
    //  }
    //..
    // See also &#39;deleteObjectRaw&#39; for better performance when &#39;address&#39; is
    // known not be a secondary base type of the object being deleted.

inline
void operator delete(void                           *address,
                     BloombergLP::bslma::Allocator&amp;  basicAllocator);
    // Use the specified &#39;basicAllocator&#39; to deallocate the memory at the
    // specified &#39;address&#39;.  The behavior is undefined unless &#39;address&#39; was
    // allocated using &#39;basicAllocator&#39; and has not already been deallocated.
    // This operator is supplied solely to allow the compiler to arrange for it
    // to be called in case of an exception.

// NOTE: The following two operators are declared but never defined to force a
// link-time error should any code inadvertently use them.

void *operator new(std::size_t                    size,
                   BloombergLP::bslma::Allocator *basicAllocator);
    // Note that this operator is intentionally not defined.

void operator delete(void                          *address,
                     BloombergLP::bslma::Allocator *basicAllocator);
    // Note that this operator is intentionally not defined.

// ============================================================================
//                      INLINE AND TEMPLATE FUNCTION DEFINITIONS
// ============================================================================

namespace BloombergLP {

namespace bslma {

                        // ---------------
                        // class Allocator
                        // ---------------

// MANIPULATORS
template &lt;class TYPE&gt;
inline
void Allocator::deleteObject(const TYPE *object)
{
    DeleterHelper::deleteObject(object, this);
}

template &lt;class TYPE&gt;
inline
void Allocator::deleteObjectRaw(const TYPE *object)
{
    DeleterHelper::deleteObjectRaw(object, this);
}

}  // close package namespace


}  // close enterprise namespace

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

inline
void *operator new(std::size_t                    size,
                   BloombergLP::bslma::Allocator&amp; basicAllocator)
{
    return basicAllocator.allocate(size);
}

inline
void operator delete(void                           *address,
                     BloombergLP::bslma::Allocator&amp;  basicAllocator)
{
    basicAllocator.deallocate(address);
}

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
