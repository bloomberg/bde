<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// balber_berdecoder.h                                                -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALBER_BERDECODER
#define INCLUDED_BALBER_BERDECODER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a BER decoder class.
//
//@CLASSES:
//  balber::BerDecoder: BER decoder
//
//@SEE_ALSO: balber_berencoder, bdem_bdemdecoder, balxml_decoder
//
//@DESCRIPTION: This component defines a single class, &#39;balber::BerDecoder&#39;,
// that contains a parameterized &#39;decode&#39; function.  The &#39;decode&#39; function
// decodes data read from a specified stream and loads the corresponding object
// to an object of the parameterized type.  The &#39;decode&#39; method is overloaded
// for two types of input streams:
//: o &#39;bsl::streambuf&#39;
//: o &#39;bsl::istream&#39;
//
// This class decodes objects based on the X.690 BER specification and is
// restricted to types supported by the &#39;bdlat&#39; framework.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Decoding an Employee Record
/// - - - - - - - - - - - - - - - - - - -
// Suppose that an &quot;employee record&quot; consists of a sequence of attributes --
// &#39;name&#39;, &#39;age&#39;, and &#39;salary&#39; -- that are of types &#39;bsl::string&#39;, &#39;int&#39;, and
// &#39;float&#39;, respectively.  Furthermore, we have a need to BER encode employee
// records as a sequence of values (for out-of-process consumption).
//
// Assume that we have defined a &#39;usage::EmployeeRecord&#39; class to represent
// employee record values, and assume that we have provided the &#39;bdlat&#39;
// specializations that allow the &#39;balber&#39; codec components to represent class
// values as a sequence of BER primitive values.  See
// {&#39;bdlat_sequencefunctions&#39;|Usage} for details of creating specializations
// for a sequence type.
//
// First, we create an employee record object having typical values:
//..
//  usage::EmployeeRecord bob(&quot;Bob&quot;, 56, 1234.00);
//  assert(&quot;Bob&quot;   == bob.name());
//  assert(  56    == bob.age());
//  assert(1234.00 == bob.salary());
//..
// Next, we create a &#39;balber::Encoder&#39; object and use it to encode our &#39;bob&#39;
// object.  Here, to facilitate the examination of our results, the BER
// encoding data is delivered to a &#39;bslsb::MemOutStreamBuf&#39; object:
//..
//  bdlsb::MemOutStreamBuf osb;
//  balber::BerEncoder     encoder;
//  int                    rc = encoder.encode(&amp;osb, bob);
//  assert( 0 == rc);
//  assert(18 == osb.length());
//..
// Now, we create a &#39;bdlsb::FixedMemInStreamBuf&#39; object to manage our access
// to the data portion of the &#39;bdlsb::MemOutStreamBuf&#39; (where our BER encoding
// resides), decode the values found there, and use them to set the value
// of an &#39;usage::EmployeeRecord&#39; object.
//..
//  balber::BerDecoderOptions  options;
//  balber::BerDecoder         decoder(&amp;options);
//  bdlsb::FixedMemInStreamBuf isb(osb.data(), osb.length());
//  usage::EmployeeRecord      obj;
//
//  rc = decoder.decode(&amp;isb, &amp;obj);
//  assert(0 == rc);
//..
// Finally, we confirm that the object defined by the BER encoding has the
// same value as the original object.
//..
//  assert(bob.name()   == obj.name());
//  assert(bob.age()    == obj.age());
//  assert(bob.salary() == obj.salary());
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BALBER_BERCONSTANTS
#include &lt;balber_berconstants.h&gt;
#endif

#ifndef INCLUDED_BALBER_BERDECODEROPTIONS
#include &lt;balber_berdecoderoptions.h&gt;
#endif

#ifndef INCLUDED_BALBER_BERUNIVERSALTAGNUMBER
#include &lt;balber_beruniversaltagnumber.h&gt;
#endif

#ifndef INCLUDED_BALBER_BERUTIL
#include &lt;balber_berutil.h&gt;
#endif

#ifndef INCLUDED_BDLAT_ARRAYFUNCTIONS
#include &lt;bdlat_arrayfunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_CHOICEFUNCTIONS
#include &lt;bdlat_choicefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_CUSTOMIZEDTYPEFUNCTIONS
#include &lt;bdlat_customizedtypefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_ENUMFUNCTIONS
#include &lt;bdlat_enumfunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_FORMATTINGMODE
#include &lt;bdlat_formattingmode.h&gt;
#endif

#ifndef INCLUDED_BDLAT_NULLABLEVALUEFUNCTIONS
#include &lt;bdlat_nullablevaluefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_SEQUENCEFUNCTIONS
#include &lt;bdlat_sequencefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_TYPECATEGORY
#include &lt;bdlat_typecategory.h&gt;
#endif

#ifndef INCLUDED_BDLAT_VALUETYPEFUNCTIONS
#include &lt;bdlat_valuetypefunctions.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

#ifndef INCLUDED_BDLB_VARIANT
#include &lt;bdlb_variant.h&gt;
#endif

#ifndef INCLUDED_BDLSB_MEMOUTSTREAMBUF
#include &lt;bdlsb_memoutstreambuf.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_OBJECTBUFFER
#include &lt;bsls_objectbuffer.h&gt;
#endif

#ifndef INCLUDED_BSL_ISTREAM
#include &lt;bsl_istream.h&gt;
#endif

#ifndef INCLUDED_BSL_OSTREAM
#include &lt;bsl_ostream.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {
namespace balber {

class BerDecoder_Node;
class BerDecoder_NodeVisitor;
class BerDecoder_UniversalElementVisitor;

                              // ================
                              // class BerDecoder
                              // ================

class BerDecoder {
    // This class contains the parameterized &#39;decode&#39; functions that decode
    // data (in BER format) from an incoming stream into &#39;bdlat&#39; types.

  private:
    // PRIVATE TYPES
    class MemOutStream : public bsl::ostream {
        // This class provides stream for logging using
        // &#39;bdlsb::MemOutStreamBuf&#39; as a streambuf.  The logging stream is
        // created on demand, i.e., during the first attempt to log message.

        bdlsb::MemOutStreamBuf d_sb;

        // NOT IMPLEMENTED
        MemOutStream(const MemOutStream&amp;);             // = delete;
        MemOutStream&amp; operator=(const MemOutStream&amp;);  // = delete;

      public:
        // CREATORS
        MemOutStream(bslma::Allocator *basicAllocator = 0);
            // Create a stream object.  Optionally specify a &#39;basicAllocator&#39;
            // used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently
            // installed default allocator is used.

        virtual ~MemOutStream();
            // Destroy this stream and release memory back to the allocator.
            //
            // Although the compiler should generate this destructor
            // implicitly, xlC 8 breaks when the destructor is called by name
            // unless it is explicitly declared.

        // MANIPULATORS
        void reset();
            // Reset the internal streambuf to the empty state.

        // ACCESSORS
        const char *data() const;
            // Return a pointer to the memory containing the formatted values
            // formatted to this stream.  The data is not null-terminated
            // unless a null character was appended onto this stream.

        int length() const;
            // Return the length of of the formatted data, including null
            // characters appended to the stream, if any.
    };

  public:
    // PUBLIC TYPES
    enum ErrorSeverity {
        e_BER_SUCCESS = 0x00
      , e_BER_ERROR   = 0x02

    };

  private:
    // DATA
    const BerDecoderOptions         *d_options;      // held, not owned
    bslma::Allocator                *d_allocator;    // held, not owned

    bsls::ObjectBuffer&lt;MemOutStream&gt; d_logArea;      // placeholder for
                                                     // &#39;MemOutStream&#39;

    MemOutStream                    *d_logStream;    // if not zero,
                                                     // log stream was created
                                                     // at the moment of first
                                                     // logging and must be
                                                     // destroyed

    ErrorSeverity                    d_severity;     // error severity level
    bsl::streambuf                  *d_streamBuf;    // held, not owned
    int                              d_currentDepth; // current depth

    int                              d_numUnknownElementsSkipped;
                                                     // number of unknown
                                                     // elements skipped

    BerDecoder_Node                 *d_topNode;      // last node

    // NOT IMPLEMENTED
    BerDecoder(const BerDecoder&amp;);             // = delete;
    BerDecoder&amp; operator=(const BerDecoder&amp;);  // = delete;

    // FRIENDS
    friend class BerDecoder_Node;

  private:
    // PRIVATE MANIPULATORS
    ErrorSeverity logError(const char *msg);
        // Log the specified &#39;msg&#39;, upgrade the severity level, and return
        // &#39;e_BER_ERROR&#39;.

    void logErrorImp(const char *msg);
        // Log the specified &#39;msg&#39; and upgrade the severity level.

    ErrorSeverity logMsg(const char *prefix, const char *msg);
        // Log the specified &#39;prefix&#39; and &#39;msg&#39; and return &#39;errorSeverity()&#39;.

    bsl::ostream&amp; logStream();
        // Return the stream used for logging.  If stream has not been created
        // yet, it will be created during this call.

  public:
    // CREATORS
    BerDecoder(const BerDecoderOptions *options = 0,
               bslma::Allocator        *basicAllocator = 0);
        // Construct a decoder object.  Optionally specify decoder &#39;options&#39;.
        // If &#39;options&#39; is 0, &#39;BerDecoderOptions()&#39; is used.  Optionally
        // specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    ~BerDecoder();
        // Destroy this object.  This destruction has no effect on objects
        // pointed-to by the pointers provided at construction.

    // MANIPULATORS
    template &lt;typename TYPE&gt;
    int decode(bsl::streambuf *streamBuf, TYPE *variable);
        // Decode an object of parameterized &#39;TYPE&#39; from the specified
        // &#39;streamBuf&#39; and load the result into the specified &#39;variable&#39;.
        // Return 0 on success, and a non-zero value otherwise.

    template &lt;typename TYPE&gt;
    int decode(bsl::istream&amp; stream, TYPE *variable);
        // Decode an object of parameterized &#39;TYPE&#39; from the specified &#39;stream&#39;
        // and load the result into the specified modifiable &#39;variable&#39;.
        // Return 0 on success, and a non-zero value otherwise.  If the
        // decoding fails &#39;stream&#39; will be invalidated.

    void setNumUnknownElementsSkipped(int value);
        // Set the number of unknown elements skipped by the decoder during the
        // current decoding operation to the specified &#39;value&#39;.  The behavior
        // is undefined unless &#39;0 &lt;= value&#39;.

    // ACCESSORS
    const BerDecoderOptions *decoderOptions() const;
        // Return the address of the BER decoder options.

    bool maxDepthExceeded() const;
       // Return &#39;true&#39; if the maximum depth level is exceeded and &#39;false&#39;
       // otherwise.

    int numUnknownElementsSkipped() const;
        // Return the number of unknown elements that were skipped during the
        // previous decoding operation.  Note that unknown elements are skipped
        // only if &#39;true == options()-&gt;skipUnknownElements()&#39;.

    ErrorSeverity  errorSeverity() const;
        // Return the severity of the most severe log or error message
        // encountered during the last call to the &#39;decode&#39; method.  The
        // severity is reset each time &#39;decode&#39; is called.

    bslstl::StringRef loggedMessages() const;
        // Return a string containing any error or trace messages that were
        // logged during the last call to the &#39;decode&#39; method.  The log is
        // reset each time &#39;decode&#39; is called.
};


                       // =============================
                       // private class BerDecoder_Node
                       // =============================

class BerDecoder_Node {
    // This class provides current context for BER decoding process and
    // represents a node for BER element.  The BER element consists of element
    // tag, length field, body field and optional end of tag.  The class also
    // provides various methods to read the different parts of BER element such
    // as tag header (tag itself and length fields), body for any type of data,
    // and optional tag trailer.

    // DATA
    BerDecoder             *d_decoder;              // decoder,
                                                    // held, not owned
    BerDecoder_Node        *d_parent;               // parent node,
                                                    // held, not owned
    BerConstants::TagClass  d_tagClass;             // tag class
    BerConstants::TagType   d_tagType;              // tag type
    int                     d_tagNumber;            // tag id or number
    int                     d_expectedLength;       // body length
    int                     d_consumedHeaderBytes;  // header bytes read
    int                     d_consumedBodyBytes;    // body bytes read
    int                     d_consumedTailBytes;    // trailer bytes read
    int                     d_formattingMode;       // formatting mode
    const char             *d_fieldName;            // name of the field

    // NOT IMPLEMENTED
    BerDecoder_Node(BerDecoder_Node&amp;);            // = delete;
    BerDecoder_Node&amp; operator=(BerDecoder_Node&amp;); // = delete;

  private:
    // PRIVATE MANIPULATORS
    int decode(bsl::vector&lt;char&gt; *variable, bdlat_TypeCategory::Array);
    template &lt;typename TYPE&gt;
    int decode(TYPE *variable, bdlat_TypeCategory::Array);
    template &lt;typename TYPE&gt;
    int decode(TYPE *variable, bdlat_TypeCategory::Choice);
    template &lt;typename TYPE&gt;
    int decode(TYPE *variable, bdlat_TypeCategory::NullableValue);
    template &lt;typename TYPE&gt;
    int decode(TYPE *variable, bdlat_TypeCategory::CustomizedType);
    template &lt;typename TYPE&gt;
    int decode(TYPE *variable, bdlat_TypeCategory::Enumeration);
    template &lt;typename TYPE&gt;
    int decode(TYPE *variable, bdlat_TypeCategory::Sequence);
    template &lt;typename TYPE&gt;
    int decode(TYPE *variable, bdlat_TypeCategory::Simple);
    template &lt;typename TYPE&gt;
    int decode(TYPE *variable, bdlat_TypeCategory::DynamicType);
        // Family of methods to decode current element into the specified
        // &#39;variable&#39; of category &#39;bdlat_TypeCategory&#39;.  Return zero on
        // success, and a non-zero value otherwise. the tag header is already
        // read at the moment of call and input stream is positioned at the
        // first byte of the body field.

    template &lt;typename TYPE&gt;
    int decodeArray(TYPE *variable);
        // Decode the current element, an array, into specified &#39;variable&#39;.
        // Return zero on success, and a non-zero value otherwise.

    template &lt;typename TYPE&gt;
    int decodeChoice(TYPE *variable);
        // Decode the current element, which is a choice object, into specified
        // &#39;variable&#39;.  Return zero on success, and a non-zero value otherwise.

  public:
    // CREATORS
    BerDecoder_Node(BerDecoder *decoder);

    template &lt;typename TYPE&gt;
    BerDecoder_Node(BerDecoder *decoder, const TYPE *variable);

    ~BerDecoder_Node();

    // MANIPULATORS
    template &lt;typename TYPE&gt;
    int operator()(TYPE *object, bslmf::Nil);

    template &lt;typename TYPE, typename ANY_CATEGORY&gt;
    int operator()(TYPE *object, ANY_CATEGORY category);

    template &lt;typename TYPE&gt;
    int operator()(TYPE *object);

    void print(bsl::ostream&amp;  out,
               int            depth,
               int            spacePerLevel = 0,
               const char    *prefixText = 0) const;
        // Print the content of node to the specified stream &#39;out&#39;.  &#39;depth&#39; is
        // the value &#39;d_decoder-&gt;currentDepth&#39; assumed after node was created.

    void printStack(bsl::ostream&amp; out) const;
        // Print the chain of nodes to the specified &#39;out&#39; stream, starting
        // from this node and iterating to the parent node, then its parent,
        // etc.

    void setFormattingMode(int formattingMode);
        // Set formatting mode specified by &#39;formattingMode&#39;.

    void setFieldName(const char *name);
        // Set object field name associated with this node to the specified
        // &#39;name&#39;.

    int logError(const char *msg);
        // Set the node severity to &#39;e_BER_ERROR&#39;, print the error message
        // specified by &#39;msg&#39; to the decoder&#39;s log, print the stack of nodes to
        // the decoder&#39;s log, and return a non-zero value.

    int readTagHeader();
        // Read the node tag field containing tag class, tag type and tag
        // number, and the node length field.  Return zero on success, and a
        // non-zero value otherwise.

    int readTagTrailer();
        // Read the node end-of-octets field, if such exists, so the stream
        // will be positioned at the start of next node.  Return zero on
        // success and a non-zero value otherwise.

    bool hasMore();
        // Return &#39;true&#39; if current node has more embedded elements and return
        // &#39;false&#39; otherwise.

    int skipField();
        // Skip the field body.  The identifier octet and length have already
        // been extracted.  Return zero on success, and a non-zero value
        // otherwise.  Note that method must be called when input stream is
        // positioned at the first byte of the body field.

    int readVectorChar(bsl::vector&lt;char&gt; *variable);
        // Read the node body content into specified &#39;variable&#39;.  Return zero
        // on success, and a non-zero value otherwise.

    // ACCESSORS
    BerDecoder_Node *parent() const;
        // Return the address of the parent node.

    BerConstants::TagClass tagClass() const;
        // Return the BER tag class for this node.

    BerConstants::TagType tagType() const;
        // Return the BER tag type for this node.

    int tagNumber() const;
        // Return the BER tag number for this node.

    int formattingMode() const;
        // Return formatting mode for this node.

    const char *fieldName() const;
        // Return field name for this node.

    int length() const;
       // Return expected length of the body or -1 when the length is
       // indefinite.

    int startPos() const;
        // Return the position of node tag from the beginning of input stream.
};

                    // ====================================
                    // private class BerDecoder_NodeVisitor
                    // ====================================

class BerDecoder_NodeVisitor {
    // This class is used as a visitor for visiting contained objects during
    // decoding.

    // DATA
    BerDecoder_Node *d_node;  // current node, held, not owned

    // NOT IMPLEMENTED
    BerDecoder_NodeVisitor(const BerDecoder_NodeVisitor&amp;);         // = delete;
    BerDecoder_NodeVisitor&amp; operator=(const BerDecoder_NodeVisitor&amp;);
                                                                   // = delete;

  public:
    // CREATORS
    BerDecoder_NodeVisitor(BerDecoder_Node *node);

    //! ~BerDecoder_NodeVisitor() = default;

    // MANIPULATORS
    template &lt;typename TYPE, typename INFO&gt;
    int operator()(TYPE *variable, const INFO&amp; info);
};

              // ================================================
              // private class BerDecoder_UniversalElementVisitor
              // ================================================

class BerDecoder_UniversalElementVisitor {
    // This &#39;class&#39; is used as a visitor for visiting the top-level element and
    // also array elements during decoding.  This class is required so that the
    // universal tag number of the element can be determined when the element
    // is visited.

    // DATA
    BerDecoder_Node d_node;  // a new node

    // NOT IMPLEMENTED
    BerDecoder_UniversalElementVisitor(
                               const BerDecoder_UniversalElementVisitor&amp;);
                                                                   // = delete;
    BerDecoder_UniversalElementVisitor&amp; operator=(
                               const BerDecoder_UniversalElementVisitor&amp;);
                                                                   // = delete;

  public:
    // CREATORS
    BerDecoder_UniversalElementVisitor(BerDecoder *d_decoder);

    //! ~BerDecoder_UniversalElementVisitor() = default;

    // MANIPULATORS
    template &lt;typename TYPE&gt;
    int operator()(TYPE *variable);
};

                          // =======================
                          // class BerDecoder_Zeroer
                          // =======================

class BerDecoder_Zeroer {
    // This class is a deleter that just zeroes out a given pointer upon
    // destruction, for making code exception-safe.

    // DATA
    const BerDecoderOptions **d_options_p;  // address of pointer to zero
                                            // out upon destruction

  public:
    // CREATORS
    BerDecoder_Zeroer(const BerDecoderOptions **options)
    : d_options_p(options)
    {
    }

    ~BerDecoder_Zeroer()
    {
        *d_options_p = 0;
    }
};

}  // close package namespace

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

                   // --------------------------------------
                   // class balber::BerDecoder::MemOutStream
                   // --------------------------------------

// CREATORS
inline
balber::BerDecoder::MemOutStream::MemOutStream(
                                              bslma::Allocator *basicAllocator)
: bsl::ostream(0)
, d_sb(bslma::Default::allocator(basicAllocator))
{
    rdbuf(&amp;d_sb);
}

// MANIPULATORS
inline
void balber::BerDecoder::MemOutStream::reset()
{
    d_sb.reset();
}

// ACCESSORS
inline
const char *balber::BerDecoder::MemOutStream::data() const
{
    return d_sb.data();
}

inline
int balber::BerDecoder::MemOutStream::length() const
{
    return (int)d_sb.length();
}

namespace balber {
                              // ----------------
                              // class BerDecoder
                              // ----------------

// MANIPULATORS
inline BerDecoder::ErrorSeverity
BerDecoder::logError(const char *msg)
{
    // This is inline just so compilers see it cannot return SUCCESS, thereby
    // improving flow analysis and choking off spurious warnings.

    logErrorImp(msg);
    return e_BER_ERROR;
}

inline
bsl::ostream&amp; BerDecoder::logStream()
{
    if (0 == d_logStream) {
        d_logStream = new(d_logArea.buffer()) MemOutStream(d_allocator);
    }
    return *d_logStream;
}

template &lt;typename TYPE&gt;
inline
int BerDecoder::decode(bsl::istream&amp; stream, TYPE *variable)
{
    if (!stream.good()) {
        return -1;
    }

    if (0 != this-&gt;decode(stream.rdbuf(), variable)) {
        stream.setstate(bsl::ios_base::failbit);
        return -1;
    }

    return 0;
}

template &lt;typename TYPE&gt;
int BerDecoder::decode(bsl::streambuf *streamBuf, TYPE *variable)
{
    BSLS_ASSERT(0 == d_streamBuf);

    d_streamBuf                 = streamBuf;
    d_currentDepth              = 0;
    d_severity                  = e_BER_SUCCESS;
    d_numUnknownElementsSkipped = 0;

    if (d_logStream != 0) {
        d_logStream-&gt;reset();
    }

    d_topNode = 0;

    bdlat_ValueTypeFunctions::reset(variable);

    int rc = d_severity;

    if (! d_options) {
        // Create temporary options object
        BerDecoderOptions                  options; d_options = &amp;options;
        BerDecoder_Zeroer                  zeroer(&amp;d_options);
        BerDecoder_UniversalElementVisitor visitor(this);
        rc = visitor(variable);
    }
    else {
        BerDecoder_UniversalElementVisitor visitor(this);
        rc = visitor(variable);
    }

    d_streamBuf = 0;
    return rc;
}

inline
void BerDecoder::setNumUnknownElementsSkipped(int value)
{
    BSLS_ASSERT_SAFE(0 &lt;= value);

    d_numUnknownElementsSkipped = value;
}

// ACCESSORS
inline
const BerDecoderOptions *BerDecoder::decoderOptions() const
{
    return d_options;
}

inline
BerDecoder::ErrorSeverity BerDecoder::errorSeverity() const
{
    return d_severity;
}

inline
bslstl::StringRef BerDecoder::loggedMessages() const
{
    if (d_logStream) {
        return bslstl::StringRef(d_logStream-&gt;data(), d_logStream-&gt;length());
    }

    return bslstl::StringRef();
}

inline
bool BerDecoder::maxDepthExceeded() const
{
    return d_currentDepth &gt; d_options-&gt;maxDepth();
}

inline
int BerDecoder::numUnknownElementsSkipped() const
{
    return d_numUnknownElementsSkipped;
}

                       // -----------------------------
                       // private class BerDecoder_Node
                       // -----------------------------

// CREATORS
inline
BerDecoder_Node::BerDecoder_Node(BerDecoder *decoder)
: d_decoder            (decoder)
, d_parent             (d_decoder-&gt;d_topNode)
, d_tagClass           (BerConstants::e_UNIVERSAL)
, d_tagType            (BerConstants::e_PRIMITIVE)
, d_tagNumber          (0)
, d_expectedLength     (0)
, d_consumedHeaderBytes(0)
, d_consumedBodyBytes  (0)
, d_consumedTailBytes  (0)
, d_formattingMode     (bdlat_FormattingMode::e_DEFAULT)
, d_fieldName          (0)
{
    ++d_decoder-&gt;d_currentDepth;
    if (d_parent) {
        d_formattingMode = d_parent-&gt;d_formattingMode;
    }
    d_decoder-&gt;d_topNode = this;
}

inline
BerDecoder_Node::~BerDecoder_Node()
{
    if (d_parent) {
        d_parent-&gt;d_consumedBodyBytes += d_consumedHeaderBytes
                                      +  d_consumedBodyBytes
                                      +  d_consumedTailBytes;
    }

    d_decoder-&gt;d_topNode = d_parent;
    --d_decoder-&gt;d_currentDepth;
}

// MANIPULATORS
inline
bool
BerDecoder_Node::hasMore()
{
    BSLS_ASSERT_SAFE(d_tagType == BerConstants::e_CONSTRUCTED);

    if (BerUtil::e_INDEFINITE_LENGTH == d_expectedLength) {
        return 0 != d_decoder-&gt;d_streamBuf-&gt;sgetc();
    }

    return d_expectedLength &gt; d_consumedBodyBytes;
}

// ACCESSORS
inline
BerDecoder_Node*BerDecoder_Node::parent() const
{
    return d_parent;
}

inline
BerConstants::TagClass BerDecoder_Node::tagClass() const
{
    return d_tagClass;
}

inline
BerConstants::TagType BerDecoder_Node::tagType() const
{
    return d_tagType;
}

inline
int BerDecoder_Node::tagNumber() const
{
    return d_tagNumber;
}

inline
int BerDecoder_Node::formattingMode() const
{
    return d_formattingMode;
}

inline
const char *BerDecoder_Node::fieldName() const
{
    return d_fieldName;
}

inline
int BerDecoder_Node::length() const
{
    return d_expectedLength;
}

// MANIPULATORS
inline
void BerDecoder_Node::setFormattingMode(int formattingMode)
{
    d_formattingMode = formattingMode;
}

inline
void BerDecoder_Node::setFieldName(const char *name)
{
    d_fieldName = name;
}

template &lt;typename TYPE&gt;
inline
int BerDecoder_Node::operator()(TYPE *, bslmf::Nil)
{
    BSLS_ASSERT(0 &amp;&amp; &quot;Should never execute this function&quot;);

    return -1;
}

template &lt;typename TYPE, typename ANY_CATEGORY&gt;
inline
int BerDecoder_Node::operator()(TYPE *object, ANY_CATEGORY category)
{
    return this-&gt;decode(object, category);
}

template &lt;typename TYPE&gt;
inline
int BerDecoder_Node::operator()(TYPE *object)
{
    typedef typename bdlat_TypeCategory::Select&lt;TYPE&gt;::Type Tag;
    return this-&gt;decode(object, Tag());
}

// PRIVATE MANIPULATORS
template &lt;typename TYPE&gt;
int
BerDecoder_Node::decode(TYPE *variable, bdlat_TypeCategory::Choice)
{
    // A misunderstanding of X.694 (clause 20.4), an XML choice (not anonymous)
    // element is encoded as a sequence (outer) with 1 element (inner).
    // However, if the element is anonymous (i.e., untagged), then there is no
    // inner tag.  This behavior is kept for backward compatibility.

    if (d_tagType != BerConstants::e_CONSTRUCTED) {
        return logError(&quot;Expected CONSTRUCTED tag type for choice&quot;);
    }

    bool isUntagged = d_formattingMode &amp; bdlat_FormattingMode::e_UNTAGGED;

    int rc = BerDecoder::e_BER_SUCCESS;

    if (!isUntagged) {

        // &#39;typename&#39; will be taken from predecessor node.
        BerDecoder_Node innerNode(d_decoder);
        rc = innerNode.readTagHeader();
        if (rc != BerDecoder::e_BER_SUCCESS) {
            return rc;  // error message is already logged
        }

        if (innerNode.tagClass() != BerConstants::e_CONTEXT_SPECIFIC) {
            return innerNode.logError(
                               &quot;Expected CONTEXT tag class for tagged choice&quot;);
        }

        if (innerNode.tagType() != BerConstants::e_CONSTRUCTED) {
            return innerNode.logError(
                            &quot;Expected CONSTRUCTED tag type for tagged choice&quot;);
        }

        if (innerNode.tagNumber() != 0) {
            return innerNode.logError(
                               &quot;Expected 0 as a tag number for tagged choice&quot;);
        }

        if (innerNode.hasMore()) {
            // if shouldContinue returns false, then there is no selection
            rc  = innerNode.decodeChoice(variable);
            if (rc != BerDecoder::e_BER_SUCCESS) {
                return rc;  // error message is already logged
            }
        }

        rc = innerNode.readTagTrailer();
    }
    else if (this-&gt;hasMore()) {

       // if shouldContinue returns false, then there is no selection
       rc = this-&gt;decodeChoice(variable);
    }

    return rc;
}

template &lt;typename TYPE&gt;
int
BerDecoder_Node::decode(TYPE *variable, bdlat_TypeCategory::NullableValue)
{
    int rc = BerDecoder::e_BER_SUCCESS;

    if (d_formattingMode &amp; bdlat_FormattingMode::e_NILLABLE) {
        // nillable is encoded in BER as a sequence with one optional element

        if (d_tagType != BerConstants::e_CONSTRUCTED) {
            return logError(&quot;Expected CONSTRUCTED tag type for nullable&quot;);
        }

        if (hasMore()) {

            // If &#39;hasMore&#39; returns false, then the nullable value is null.
            BerDecoder_Node innerNode(d_decoder);
            rc = innerNode.readTagHeader();
            if (rc != BerDecoder::e_BER_SUCCESS) {
                return rc;  // error message is already logged
            }

            if (innerNode.tagClass() != BerConstants::e_CONTEXT_SPECIFIC) {
                return innerNode.logError(
                              &quot;Expected CONTEXT tag class for inner nillable&quot;);
            }

            if (innerNode.tagNumber() != 0) {
                return innerNode.logError(
                                &quot;Expected 0 as tag number for inner nillable&quot;);
            }

            bdlat_NullableValueFunctions::makeValue(variable);

            rc = bdlat_NullableValueFunctions::manipulateValue(variable,
                                                               innerNode);
            if (rc != BerDecoder::e_BER_SUCCESS) {
                return rc;  // error message is already logged
            }

            rc = innerNode.readTagTrailer();

        }  // this-&gt;hasMore()
        else {
            bdlat_ValueTypeFunctions::reset(variable);
        }
    }
    else {  // not &#39;bdlat_FormattingMode::e_NILLABLE&#39;
        bdlat_NullableValueFunctions::makeValue(variable);
        rc = bdlat_NullableValueFunctions::manipulateValue(variable, *this);
    }

    return rc;
}

template &lt;typename TYPE&gt;
int
BerDecoder_Node::decode(TYPE *variable, bdlat_TypeCategory::CustomizedType)
{
    typedef typename
    bdlat_CustomizedTypeFunctions::BaseType&lt;TYPE&gt;::Type BaseType;

#ifdef BSLS_PLATFORM_HAS_PRAGMA_GCC_DIAGNOSTIC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored &quot;-Wuninitialized&quot;
#endif

    BaseType base;

    typedef typename bdlat_TypeCategory::Select&lt;BaseType&gt;::Type BaseTag;
    int rc = this-&gt;decode(&amp;base, BaseTag());

    if (rc != BerDecoder::e_BER_SUCCESS) {
        return rc;  // error message is already logged
    }

    if (bdlat_CustomizedTypeFunctions::convertFromBaseType(variable,
                                                           base) != 0) {
        return logError(&quot;Error converting from base type for customized&quot;);
    }

#ifdef BSLS_PLATFORM_HAS_PRAGMA_GCC_DIAGNOSTIC
#pragma GCC diagnostic pop
#endif

    return BerDecoder::e_BER_SUCCESS;
}

template &lt;typename TYPE&gt;
int
BerDecoder_Node::decode(TYPE *variable, bdlat_TypeCategory::Enumeration)
{
    int value = 0;
    int rc    = this-&gt;decode(&amp;value, bdlat_TypeCategory::Simple());

    if (rc != BerDecoder::e_BER_SUCCESS) {
        return rc;  // error message is already logged
    }

    if (0 != bdlat_EnumFunctions::fromInt(variable, value)) {
        return logError(&quot;Error converting enumeration value&quot;);
    }

    return BerDecoder::e_BER_SUCCESS;
}

template &lt;typename TYPE&gt;
inline
int BerDecoder_Node::decode(TYPE *variable, bdlat_TypeCategory::Simple)
{
    if (d_tagType != BerConstants::e_PRIMITIVE) {
        return logError(&quot;Expected PRIMITIVE tag type for simple type&quot;);
    }

    if (BerUtil::getValue(d_decoder-&gt;d_streamBuf,
                          variable,
                          d_expectedLength) != 0) {
        return logError(&quot;Error reading value for simple type&quot;);
    }

    d_consumedBodyBytes = d_expectedLength;

    return BerDecoder::e_BER_SUCCESS;
}

template &lt;typename TYPE&gt;
int
BerDecoder_Node::decode(TYPE *variable, bdlat_TypeCategory::Sequence)
{
    if (d_tagType != BerConstants::e_CONSTRUCTED) {
        return logError(&quot;Expected CONSTRUCTED tag type for sequence&quot;);
    }

    while (this-&gt;hasMore()) {

        BerDecoder_Node innerNode(d_decoder);

        int rc = innerNode.readTagHeader();
        if (rc != BerDecoder::e_BER_SUCCESS) {
            return rc;  // error message is already logged
        }

        if (innerNode.tagClass() != BerConstants::e_CONTEXT_SPECIFIC) {
            return innerNode.logError(
                                 &quot;Expected CONTEXT tag class inside sequence&quot;);
        }

        if (bdlat_SequenceFunctions::hasAttribute(*variable,
                                                  innerNode.tagNumber())) {

            BerDecoder_NodeVisitor visitor(&amp;innerNode);

            rc = bdlat_SequenceFunctions::manipulateAttribute(
                                                        variable,
                                                        visitor,
                                                        innerNode.tagNumber());
        }
        else {
            rc = innerNode.skipField();
            d_decoder-&gt;setNumUnknownElementsSkipped(
                                   d_decoder-&gt;numUnknownElementsSkipped() + 1);
        }

        if (rc != BerDecoder::e_BER_SUCCESS) {
            return rc;  // error message is already logged
        }

        rc = innerNode.readTagTrailer();
        if (rc != BerDecoder::e_BER_SUCCESS) {
            return rc;  // error message is already logged
        }
    }

    return BerDecoder::e_BER_SUCCESS;
}

template &lt;typename TYPE&gt;
inline
int BerDecoder_Node::decode(TYPE *variable, bdlat_TypeCategory::Array)
{
    // Note: &#39;bsl::vector&lt;char&gt;&#39; is handled as a special case in the CPP file.

    return this-&gt;decodeArray(variable);
}

template &lt;typename TYPE&gt;
inline
int BerDecoder_Node::decode(TYPE *variable, bdlat_TypeCategory::DynamicType)
{
    return bdlat_TypeCategoryUtil::manipulateByCategory(variable, *this);
}

template &lt;typename TYPE&gt;
int BerDecoder_Node::decodeChoice(TYPE *variable)
{
    BerDecoder_Node innerNode(d_decoder);

    int rc = innerNode.readTagHeader();
    if (rc != BerDecoder::e_BER_SUCCESS) {
        return rc;  // error message is already logged
    }

    if (innerNode.tagClass() != BerConstants::e_CONTEXT_SPECIFIC) {
        return innerNode.logError(
                             &quot;Expected CONTEXT tag class for internal choice&quot;);
    }

    if (bdlat_ChoiceFunctions::hasSelection(*variable,
                                            innerNode.tagNumber())) {

        if (0 != bdlat_ChoiceFunctions::makeSelection(variable,
                                                      innerNode.tagNumber())) {

            return innerNode.logError(&quot;Unable to make choice selection&quot;);
        }

        BerDecoder_NodeVisitor visitor(&amp;innerNode);

        rc = bdlat_ChoiceFunctions::manipulateSelection(variable, visitor);
    }
    else {
        rc = innerNode.skipField();
        d_decoder-&gt;setNumUnknownElementsSkipped(
                                   d_decoder-&gt;numUnknownElementsSkipped() + 1);
    }

    if (rc != BerDecoder::e_BER_SUCCESS) {
        return rc;  // error message is already logged
    }

    return innerNode.readTagTrailer();
}

template &lt;typename TYPE&gt;
int
BerDecoder_Node::decodeArray(TYPE *variable)
{
    if (d_tagType != BerConstants::e_CONSTRUCTED) {
        return logError(&quot;Expected CONSTRUCTED tag class for array&quot;);
    }

    const int maxSize = d_decoder-&gt;decoderOptions()-&gt;maxSequenceSize();

    int i = static_cast&lt;int&gt;(bdlat_ArrayFunctions::size(*variable));
    while (this-&gt;hasMore()) {
        int j = i + 1;

        if (j &gt; maxSize) {
            return logError(&quot;Array size exceeds the limit&quot;);
        }

        bdlat_ArrayFunctions::resize(variable, j);

        BerDecoder_UniversalElementVisitor visitor(d_decoder);
        int rc = bdlat_ArrayFunctions::manipulateElement(variable, visitor, i);
        if (rc != BerDecoder::e_BER_SUCCESS) {
            return logError(&quot;Error in decoding array element&quot;);
        }
        i = j;
    }

    return BerDecoder::e_BER_SUCCESS;
}

                    // ------------------------------------
                    // private class BerDecoder_NodeVisitor
                    // ------------------------------------

// CREATORS
inline
BerDecoder_NodeVisitor::
BerDecoder_NodeVisitor(BerDecoder_Node *node)
: d_node(node)
{
}

// MANIPULATORS
template &lt;typename TYPE, typename INFO&gt;
inline
int BerDecoder_NodeVisitor::operator()(TYPE *variable, const INFO&amp; info)
{
    d_node-&gt;setFormattingMode(info.formattingMode());
    d_node-&gt;setFieldName(info.name());

    return d_node-&gt;operator()(variable);
}

              // ------------------------------------------------
              // private class BerDecoder_UniversalElementVisitor
              // ------------------------------------------------

// CREATORS
inline
BerDecoder_UniversalElementVisitor::
BerDecoder_UniversalElementVisitor(BerDecoder *decoder)
: d_node(decoder)
{
}

// MANIPULATORS
template &lt;typename TYPE&gt;
int BerDecoder_UniversalElementVisitor::operator()(TYPE *variable)
{
    int                          alternateTag      = -1;
    BerUniversalTagNumber::Value expectedTagNumber =
                         BerUniversalTagNumber::select(*variable,
                                                       d_node.formattingMode(),
                                                       &amp;alternateTag);

    int rc = d_node.readTagHeader();
    if (rc != BerDecoder::e_BER_SUCCESS) {
        return rc;  // error message is already logged
    }

    if (d_node.tagClass() != BerConstants::e_UNIVERSAL) {
        return d_node.logError(&quot;Expected UNIVERSAL tag class&quot;);
    }

    if (d_node.tagNumber() != static_cast&lt;int&gt;(expectedTagNumber)) {
        if (-1 == alternateTag || d_node.tagNumber() != alternateTag) {
            return d_node.logError(&quot;Unexpected tag number&quot;);
        }
    }

    rc = d_node(variable);

    if (rc != BerDecoder::e_BER_SUCCESS) {
        return rc;
    }

    rc = d_node.readTagTrailer();

    return rc;
}

}  // close package namespace
}  // close enterprise namespace
#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
