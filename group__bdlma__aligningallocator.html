<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlma_aligningallocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_aligningallocator<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an allocator-wrapper to allocate with a minimum alignment.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Using <code>bdlma::AligningAllocator</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an allocator-wrapper to allocate with a minimum alignment. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1AligningAllocator.html">bdlma::AligningAllocator</a> </td><td>wrapper to align memory allocation  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a concrete allocator implementation, <code><a class="el" href="classbdlma_1_1AligningAllocator.html">bdlma::AligningAllocator</a></code>, providing the ability to allocate memory with a minimum alignment specified at the construction of the allocator. The following inheritance diagram shows the classes involved and their methods: <br/>
<br/>
<div class="fragment"><pre class="fragment">   ,------------------------.
  ( <a class="code" href="classbdlma_1_1AligningAllocator.html">bdlma::AligningAllocator</a> )
   `------------------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">               |</span>
<span class="stringliteral">               V</span>
<span class="stringliteral">       ,----------------.</span>
<span class="stringliteral">      ( bslma::Allocator )</span>
<span class="stringliteral">       `----------------&#39;</span>
                       allocate
                       deallocate
</pre></div><br/>
<br/>
 The <code>AligningAllocator</code> is supplied an allocator at contruction, and ensures that memory returned by <code>allocate</code> meets a minimum alignment requirement. This may be useful in situations where a user needs to adapt an allocator supplying only natural alignment to software expecting an allocator with a higher alignment guarantee. The allocator supplied to an <code>AligningAllocator</code> at construction is held, not owned. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The allocator supplied to the aligning allocator must employ at least the natural alignment strategy (see bsls_alignment). Specifically, the aligning allocator will fail to align the memory if the allocator passed to it employs the 1-Byte alignment strategy. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_bdlma~3A~3Aaligningallocator"></a> <a class="anchor" id="usage.example_1~3A_using_bdlma~3A~3Aaligningallocator"></a> <a class="anchor" id="description.usage.example_1~3A_using_bdlma~3A~3Aaligningallocator"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using bdlma::AligningAllocator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we are dealing with an externally supplied library function that creates a linked list of null-terminated strings, and we want to use a default-constructed buffered sequential allocator for memory allocation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, the externally supplied library defines the <code>struct</code> describing a node in the linked list: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>Node {
      <span class="comment">// This &#39;struct&#39; describes one node in a linked list containing</span>
      <span class="comment">// strings.</span>

      Node *d_next;
      <span class="keywordtype">char</span>  d_string[1];

      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span>
      bsl::size_t sizeNeededForString(<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span>)
          <span class="comment">// Return the size in bytes needed to store a &#39;Node&#39; containing a</span>
          <span class="comment">// copy of the specified &#39;string&#39;.</span>
      {
          Node node;

          <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(node.d_next) + bsl::strlen(<span class="keywordtype">string</span>) + 1;
      }
  };
</pre></div><br/>
<br/>
 Then, the externally-supplied library defines the function that will create the linked list of nodes from a null-terminated array of pointers to C-strings: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> externalPopulateStringList(Node             **head,
                                  <span class="keyword">const</span> <span class="keywordtype">char</span>       **stringArray,
                                  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>  *allocator)
  {
      *head = 0;
      <span class="keyword">const</span> <span class="keywordtype">char</span> *string;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; 0 != (<span class="keywordtype">string</span> = stringArray[ii]); ++ii) {
          Node *newNode = <span class="keyword">static_cast&lt;</span>Node *<span class="keyword">&gt;</span>(allocator-&gt;<a class="code" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">allocate</a>(
                                         Node::sizeNeededForString(<span class="keywordtype">string</span>)));
          bsl::strcpy(newNode-&gt;d_string, <span class="keywordtype">string</span>);

          newNode-&gt;d_next = *head;
          *head = newNode;
      }
  }
</pre></div><br/>
<br/>
 Next, the externally-supplied buffered sequential allocator that we are to use: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { k_BUFFER_SIZE = 4 * 1024 };
  <span class="keywordtype">char</span>                               buffer4k[k_BUFFER_SIZE];
  <a class="code" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a> bsAlloc(buffer4k, k_BUFFER_SIZE);
</pre></div><br/>
<br/>
 There is a problem here, in that the nodes must be aligned by <code>sizeof(Node *)</code>, but our buffered sequential allocator, like most BDE allocators, has a "natural alignment" strategy (see bsls_alignment), meaning that it infers the required alignment from the size of the allocation requested. This would normally give us properly aligned memory if we were allocating by <code>sizeof(struct)</code>, but our <code>Node</code> objects are variable length, which will mislead the allocator to sometimes align the new segments by less than <code>sizeof(Node *)</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we solve this problem by using an aligning allocator to wrap the buffered sequential allocator, ensuring that the memory will still come from the buffered sequential allocator, but nonetheless be aligned to the alignment requirement of <code>Node</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { k_ALIGNMENT = <a class="code" href="structbsls_1_1AlignmentFromType.html">bsls::AlignmentFromType&lt;Node&gt;::VALUE</a> };
  <a class="code" href="classbdlma_1_1AligningAllocator.html">bdlma::AligningAllocator</a> aligningAllocator(k_ALIGNMENT, &amp;bsAlloc);
</pre></div><br/>
<br/>
 Next, we define a null-terminated array of strings we would like to store in the list: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">char</span> *strings[] = {
      <span class="stringliteral">&quot;A zinger is not a rebuttal.\n&quot;</span>,
      <span class="stringliteral">&quot;Humor is mankind&#39;s greatest blessing.\n&quot;</span>,
      <span class="stringliteral">&quot;As usual, the facts don&#39;t care about our feelings.\n&quot;</span>,
      <span class="stringliteral">&quot;Criticism is the only antidote to error.\n&quot;</span>,
      <span class="stringliteral">&quot;If you can&#39;t annoy somebody, there is little point in writing.\n&quot;</span>,
      <span class="stringliteral">&quot;Maybe all one can do is hope to end up with the right regrets.\n&quot;</span>,
      <span class="stringliteral">&quot;People may hear your words, but they feel your attitude.\n&quot;</span>,
      <span class="stringliteral">&quot;Imagination is a poor substitute for experience.\n&quot;</span>,
      <span class="stringliteral">&quot;We wanted a labor force, but human beings came.\n&quot;</span>,
      <span class="stringliteral">&quot;The reward of a thing well done is to have done it.\n&quot;</span>,
      <span class="stringliteral">&quot;Chance fights ever on the side of the prudent.\n&quot;</span>,
      <span class="stringliteral">&quot;The best time to make friends is before you need them.\n&quot;</span>,
      0  };
</pre></div><br/>
<br/>
 Now, we call the function to put the strings into a linked list, passing it the aligning allocator: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Node *head = 0;
  externalPopulateStringList(&amp;head, strings, &amp;aligningAllocator);
</pre></div><br/>
<br/>
 Finally, we traverse the list and print out the strings, verifying that the nodes are properly aligned: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (<span class="keyword">const</span> Node *node = head; node; node = node-&gt;d_next) {
      assert(0 == (reinterpret_cast&lt;bsl::size_t&gt;(node) &amp; (k_ALIGNMENT - 1)));

      cout &lt;&lt; node-&gt;d_string;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:44 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
