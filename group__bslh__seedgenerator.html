<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslh_seedgenerator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslh_seedgenerator<br/>
<small>
[<a class="el" href="group__bslh.html">Package bslh</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a class to generate arbitrary length seeds for algorithms.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslh.html">bslh</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Requirements on RNG</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example: Seeding Hashing Algorithms Requiring Different Seed Sizes</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a class to generate arbitrary length seeds for algorithms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslh_1_1SeedGenerator.html">bslh::SeedGenerator</a> </td><td>generator for arbitrary length seeds  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a class, <code><a class="el" href="classbslh_1_1SeedGenerator.html">bslh::SeedGenerator</a></code>, which utilizes a user-supplied Random Number Generator (RNG) to generate arbitrary length seeds. The quality of the seeds will only be as good as the quality of the supplied RNG. A cryptographically secure RNG must be supplied in order for <code>SeedGenerator</code> to produce seeds suitable for a cryptographically secure algorithm. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This class satisfies the requirements for a seed generator, defined in <code><a class="el" href="bslh__seededhash_8h.html" title="Provide a struct to run seeded bslh hash algorithms on types.">bslh_seededhash.h</a></code>. More information can be found in the package level documentation for <code>bslh</code> (internal users can also find information here {TEAM BDE:USING MODULAR HASHING&lt;GO&gt;}) </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_on_rng"></a> <a class="anchor" id="description.requirements_on_rng"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Requirements on RNG: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The (template parameter) type <code>RANDOM_NUM_GEN</code> shall be a class that provides a type alias <code>result_type</code> and exposes an <code>operator()</code> that returns a result of type <code>result_type</code>. The value returned by <code>operator()</code> shall be random bits, the quality of which can be defined by <code>RANDOM_NUM_GEN</code>. <code>RANDOM_NUM_GEN</code> shall also be default and copy constructible. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example~3A_seeding_hashing_algorithms_requiring_different_seed_sizes"></a> <a class="anchor" id="usage.example~3A_seeding_hashing_algorithms_requiring_different_seed_sizes"></a> <a class="anchor" id="description.usage.example~3A_seeding_hashing_algorithms_requiring_different_seed_sizes"></a> <a class="anchor" id="example"></a> <a class="anchor" id="usage.example"></a> <a class="anchor" id="description.usage.example"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example: Seeding Hashing Algorithms Requiring Different Seed Sizes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we have a number of hashing algorithms that all require different length seeds. Some require 32 bits, some require 64 bits, some even require 1024 bits. We want to generate all these seeds in the same way, but we do not want to keep manually generating seeds of different sizes for these algorithms. Moreover, we want to be able to use all these algorithms through a general purpose functor. To accomplish this, we give all our algorithm the same interface and supply a seed generator, which can create any size seed that the algorithms require. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we write our first hashing algorithm, which accepts a 32-bit seed and returns a 32-bit unsigned int. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Seeded32BitHashingAlgorithm {
      <span class="comment">// This class is a functor that implements a hashing algorithm seeded</span>
      <span class="comment">// with 32 bits.</span>

    <span class="keyword">public</span>:
      <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> result_type; <span class="comment">// Type of the hash returned</span>
      <span class="keyword">enum</span> { k_SEED_LENGTH = 4 };   <span class="comment">// Seed length in bytes</span>

    <span class="keyword">private</span>:
      <span class="keyword">const</span> <span class="keywordtype">char</span> *d_seed; <span class="comment">// Seed used in the generation of hashes</span>

    <span class="keyword">public</span>:
      <span class="keyword">explicit</span> Seeded32BitHashingAlgorithm(<span class="keyword">const</span> <span class="keywordtype">char</span> *seed);
          <span class="comment">// Construct a &#39;Seeded32BitHashingAlgorithm&#39; that will use the</span>
          <span class="comment">// first 4 bytes of the specified &#39;seed&#39; to seed the algorithm.</span>

      result_type operator()(<span class="keyword">const</span> <span class="keywordtype">char</span> *data, <span class="keywordtype">size_t</span> length);
          <span class="comment">// Return a hash of the specified &#39;length&#39; bytes of &#39;data&#39;.</span>
  };
</pre></div><br/>
<br/>
 Then, we define another hashing algorithm, which accepts a 64-bit seed and returns a 32-bit unsigned int <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Seeded64BitHashingAlgorithm {
      <span class="comment">// This class is a functor that implements a hashing algorithm seeded</span>
      <span class="comment">// with 64 bits.</span>

    <span class="keyword">public</span>:
      <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> result_type; <span class="comment">// Type of the hash returned</span>
      <span class="keyword">enum</span> { k_SEED_LENGTH = 8 };     <span class="comment">// Seed length in bytes</span>

    <span class="keyword">private</span>:
      <span class="keyword">const</span> <span class="keywordtype">char</span> *d_seed; <span class="comment">// Seed used in the generation of hashes</span>

    <span class="keyword">public</span>:
      <span class="keyword">explicit</span> Seeded64BitHashingAlgorithm(<span class="keyword">const</span> <span class="keywordtype">char</span> *seed);
          <span class="comment">// Construct a &#39;Seeded64BitHashingAlgorithm&#39; that will use the</span>
          <span class="comment">// first 8 bytes of the specified &#39;seed&#39; to seed the algorithm.</span>

      result_type operator()(<span class="keyword">const</span> <span class="keywordtype">char</span> *data, <span class="keywordtype">size_t</span> length);
          <span class="comment">// Return a hash of the specified &#39;length&#39; bytes of &#39;data&#39;.</span>
  };
</pre></div><br/>
<br/>
 Next, we define a final hashing algorithm, which accepts a 1024-bit seed and returns a 32-bit unsigned int <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Seeded1024BitHashingAlgorithm {
      <span class="comment">// This class is a functor that implements a hashing algorithm seeded</span>
      <span class="comment">// with 1024 bits.</span>

    <span class="keyword">public</span>:
      <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> result_type; <span class="comment">// Type of the hash returned</span>
      <span class="keyword">enum</span> { k_SEED_LENGTH = 128 };   <span class="comment">// Seed length in bytes</span>

    <span class="keyword">private</span>:
      <span class="keyword">const</span> <span class="keywordtype">char</span> *d_seed; <span class="comment">// Seed used in the generation of hashes</span>

    <span class="keyword">public</span>:
      <span class="keyword">explicit</span> Seeded1024BitHashingAlgorithm(<span class="keyword">const</span> <span class="keywordtype">char</span> *seed);
          <span class="comment">// Construct a &#39;Seeded1024BitHashingAlgorithm&#39; that will use the</span>
          <span class="comment">// first 128 bytes of the specified &#39;seed&#39; to seed the algorithm.</span>

      result_type operator()(<span class="keyword">const</span> <span class="keywordtype">char</span> *data, <span class="keywordtype">size_t</span> length);
          <span class="comment">// Return a hash of the specified &#39;length&#39; bytes of &#39;data&#39;.</span>
  };
</pre></div><br/>
<br/>
 Then, we declare our functor, <code>SeededHash</code>, which will take a seed generator, and be able to run any of our hashing algorithms by generating the correct size seed with the seed generator. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> HASH_ALGORITHM&gt;
  <span class="keyword">class </span>SeededHash {
      <span class="comment">// This class template implements an interface similar to &#39;std::hash&#39;,</span>
      <span class="comment">// which will used the (template parameter) type &#39;SEED_GENERATOR&#39; and</span>
      <span class="comment">// &#39;HASH_ALGORITHM&#39; to compute hashes.</span>

    <span class="keyword">public</span>:
      <span class="keyword">typedef</span> <span class="keyword">typename</span> HASH_ALGORITHM::result_type result_type;
          <span class="comment">// Type of the hash that will be returned.</span>

    <span class="keyword">private</span>:
      <span class="keywordtype">char</span> seed[HASH_ALGORITHM::k_SEED_LENGTH];
          <span class="comment">// Stores the seed that will be used to run the (template</span>
          <span class="comment">// parameter) type &#39;HASH_ALGORITHM&#39;</span>

    <span class="keyword">public</span>:
      <span class="keyword">template</span>&lt;<span class="keyword">class</span> SEED_GENERATOR&gt;
      SeededHash(SEED_GENERATOR seedGenerator);
          <span class="comment">//Create a &#39;SeededHash&#39; and generate a seed using the specified</span>
          <span class="comment">//&#39;seedGenerator&#39;.</span>

      result_type operator()(<span class="keyword">const</span> <span class="keywordtype">char</span> *data, <span class="keywordtype">size_t</span> length) <span class="keyword">const</span>;
          <span class="comment">// Returns a hash generated by the (template parameter) type</span>
          <span class="comment">// &#39;HASH_ALGORITHM&#39; for the specified &#39;length&#39; bytes of &#39;data&#39;.</span>

  };
</pre></div><br/>
<br/>
 Next, we define our constructor where we actually use <code><a class="el" href="classbslh_1_1SeedGenerator.html">bslh::SeedGenerator</a></code>. <code><a class="el" href="classbslh_1_1SeedGenerator.html">bslh::SeedGenerator</a></code> allows us to create arbitrary length seeds to match the requirements of the above declared algorithms. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> HASH_ALGORITHM&gt;
  <span class="keyword">template</span>&lt;<span class="keyword">class</span> SEED_GENERATOR&gt;
  SeededHash&lt;HASH_ALGORITHM&gt;::SeededHash(SEED_GENERATOR seedGenerator) {
      seedGenerator.generateSeed(seed, HASH_ALGORITHM::k_SEED_LENGTH);
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> HASH_ALGORITHM&gt;
  <span class="keyword">typename</span> SeededHash&lt;HASH_ALGORITHM&gt;::result_type
  SeededHash&lt;HASH_ALGORITHM&gt;::operator()(<span class="keyword">const</span> <span class="keywordtype">char</span> *data,
                                         <span class="keywordtype">size_t</span> length)<span class="keyword"> const </span>{
      HASH_ALGORITHM hashAlg(seed);
      <span class="keywordflow">return</span> hashAlg(data, length);
  }
</pre></div><br/>
<br/>
 Now, we generate some data that we want to hash. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">const</span> <span class="keywordtype">char</span> *data[] = { <span class="stringliteral">&quot;asdf&quot;</span>,
                             <span class="stringliteral">&quot;qwer&quot;</span>,
                             <span class="stringliteral">&quot;gskgf&quot;</span>,
                             <span class="stringliteral">&quot;ujkagad&quot;</span>,
                             <span class="stringliteral">&quot;rwwfwe&quot;</span>, };
      <span class="keyword">enum</span> { NUM_STRINGS = <span class="keyword">sizeof</span> data / <span class="keyword">sizeof</span> *data };
</pre></div><br/>
<br/>
 Finally, we can hash the data the same way using all of the different hashing algorithms. The seed generator allows us to abstract away the different requirements each algorithm has on seed size. Each algorithm will produce different output because it has been supplied with a different seed. <br/>
<br/>
<div class="fragment"><pre class="fragment">      MockRNG                                   rng;
      SeedGenerator&lt;MockRNG&gt;                    seedGen(rng);
      SeededHash&lt;Seeded32BitHashingAlgorithm&gt;   hashAlg32BitSeed(seedGen);
      SeededHash&lt;Seeded64BitHashingAlgorithm&gt;   hashAlg64BitSeed(seedGen);
      SeededHash&lt;Seeded1024BitHashingAlgorithm&gt; hashAlg1024BitSeed(seedGen);

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_STRINGS; ++i) {
          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash32BitSeed   = hashAlg32BitSeed(data[i],
                                                            strlen(data[i]));
          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash64BitSeed   = hashAlg64BitSeed(data[i],
                                                            strlen(data[i]));
          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash1024BitSeed = hashAlg1024BitSeed(data[i],
                                                            strlen(data[i]));

          <span class="keywordflow">if</span> (veryVerbose) printf(<span class="stringliteral">&quot;Asserting hashes of %s come out&quot;</span>
                                 <span class="stringliteral">&quot; different\n&quot;</span>, data[i]);
          ASSERT(hash32BitSeed   != hash64BitSeed);
          ASSERT(hash32BitSeed   != hash1024BitSeed);
          ASSERT(hash1024BitSeed != hash64BitSeed);
      }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:50 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
