<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Struct bslalg::HashTableImpUtil</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslalg.html">bslalg</a>      </li>
      <li><a class="el" href="structbslalg_1_1HashTableImpUtil.html">bslalg::HashTableImpUtil</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslalg::HashTableImpUtil Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslalg::HashTableImpUtil" -->
<p><code>#include &lt;<a class="el" href="bslalg__hashtableimputil_8h_source.html">bslalg_hashtableimputil.h</a>&gt;</code></p>

<p><a href="structbslalg_1_1HashTableImpUtil-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1HashTableImpUtil.html#a2469febb5ebcbe22ddde1c6726faa7ef">bucketContainsLink</a> (const <a class="el" href="structbslalg_1_1HashTableBucket.html">HashTableBucket</a> &amp;bucket, <a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *linkAddress)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY_CONFIG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <br class="typebreak"/>
<a class="el" href="structbslalg_1_1HashTableImpUtil__ExtractKeyResult.html">HashTableImpUtil_ExtractKeyResult</a><br class="typebreak"/>
&lt; KEY_CONFIG &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1HashTableImpUtil.html#af5d2082db1c93cc5a32c4aedefb3f331">extractKey</a> (<a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *link)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY_CONFIG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static KEY_CONFIG::ValueType &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1HashTableImpUtil.html#a149b90b74a4912f4efdba60b4811e26b">extractValue</a> (<a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *link)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY_CONFIG , class HASHER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1HashTableImpUtil.html#a018aa22420a48ec790345e2130d203eb">isWellFormed</a> (const <a class="el" href="classbslalg_1_1HashTableAnchor.html">HashTableAnchor</a> &amp;anchor, const HASHER &amp;hasher, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static native_std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1HashTableImpUtil.html#ac2e71898d9b5470069cf9a424fb10c85">computeBucketIndex</a> (native_std::size_t hashCode, native_std::size_t numBuckets)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1HashTableImpUtil.html#af289c0c8a875ea816b8d938b02f268be">insertAtFrontOfBucket</a> (<a class="el" href="classbslalg_1_1HashTableAnchor.html">HashTableAnchor</a> *anchor, <a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *link, native_std::size_t hashCode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1HashTableImpUtil.html#a47e00753d8d188e10041eeeb3fa3e6da">insertAtBackOfBucket</a> (<a class="el" href="classbslalg_1_1HashTableAnchor.html">HashTableAnchor</a> *anchor, <a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *link, native_std::size_t hashCode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1HashTableImpUtil.html#a5a00cf921b5cb9ff4ef0a56b337d339d">insertAtPosition</a> (<a class="el" href="classbslalg_1_1HashTableAnchor.html">HashTableAnchor</a> *anchor, <a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *link, native_std::size_t hashCode, <a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1HashTableImpUtil.html#a31268c89db26b293e452f37fd27d6f1b">remove</a> (<a class="el" href="classbslalg_1_1HashTableAnchor.html">HashTableAnchor</a> *anchor, <a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *link, native_std::size_t hashCode)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY_CONFIG , class KEY_EQUAL &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1HashTableImpUtil.html#a14dfd47dd7ed8d34fcf8d83eb243fcc7">find</a> (const <a class="el" href="classbslalg_1_1HashTableAnchor.html">HashTableAnchor</a> &amp;anchor, typename <a class="el" href="structbslalg_1_1HashTableImpUtil__ExtractKeyResult.html">HashTableImpUtil_ExtractKeyResult</a>&lt; KEY_CONFIG &gt;::Type key, const KEY_EQUAL &amp;equalityFunctor, native_std::size_t hashCode)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KEY_CONFIG , class HASHER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1HashTableImpUtil.html#a335fdd93964409b863e0f4dfae2f77af">rehash</a> (<a class="el" href="classbslalg_1_1HashTableAnchor.html">HashTableAnchor</a> *newAnchor, <a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *elementList, const HASHER &amp;hasher)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This <code>struct</code> provides a namespace for a suite of utility functions for creating and manipulating a hash table. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2469febb5ebcbe22ddde1c6726faa7ef"></a><!-- doxytag: member="bslalg::HashTableImpUtil::bucketContainsLink" ref="a2469febb5ebcbe22ddde1c6726faa7ef" args="(const HashTableBucket &amp;bucket, BidirectionalLink *linkAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::HashTableImpUtil::bucketContainsLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbslalg_1_1HashTableBucket.html">HashTableBucket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bucket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>linkAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>linkAddress</code> is the address of one of the links in the list of elements in the closed range <code>[bucket.first(), bucket.last()]</code>. </p>

</div>
</div>
<a class="anchor" id="af5d2082db1c93cc5a32c4aedefb3f331"></a><!-- doxytag: member="bslalg::HashTableImpUtil::extractKey" ref="af5d2082db1c93cc5a32c4aedefb3f331" args="(BidirectionalLink *link)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbslalg_1_1HashTableImpUtil__ExtractKeyResult.html">HashTableImpUtil_ExtractKeyResult</a>&lt;KEY_CONFIG&gt;::Type bslalg::HashTableImpUtil::extractKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>link</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the key (of type <code>KEY_CONFIG::KeyType</code>) held by the specified <code>link</code>. The behavior is undefined unless <code>link</code> refers to a node of type <code><a class="el" href="classbslalg_1_1BidirectionalNode.html">BidirectionalNode</a>&lt;KEY_CONFIG::ValueType&gt;</code>. <code>KEY_CONFIG</code> shall be a namespace providing the type names <code>KeyType</code> and <code>ValueType</code>, as well as a function that can be called as if it had the following signature: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keyword">const</span> KeyType&amp; <a class="code" href="structbslalg_1_1HashTableImpUtil.html#af5d2082db1c93cc5a32c4aedefb3f331">extractKey</a>(<span class="keyword">const</span> ValueType&amp; obj);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a149b90b74a4912f4efdba60b4811e26b"></a><!-- doxytag: member="bslalg::HashTableImpUtil::extractValue" ref="a149b90b74a4912f4efdba60b4811e26b" args="(BidirectionalLink *link)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static KEY_CONFIG::ValueType&amp; bslalg::HashTableImpUtil::extractValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>link</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the value (of type <code>KEY_CONFIG::ValueType</code>) held by the specified <code>link</code>. The behavior is undefined unless <code>link</code> refers to a node of type <code><a class="el" href="classbslalg_1_1BidirectionalNode.html">BidirectionalNode</a>&lt;KEY_CONFIG::ValueType&gt;</code>. <code>KEY_CONFIG</code> shall be a namespace providing the type name <code>ValueType</code>. </p>

</div>
</div>
<a class="anchor" id="a018aa22420a48ec790345e2130d203eb"></a><!-- doxytag: member="bslalg::HashTableImpUtil::isWellFormed" ref="a018aa22420a48ec790345e2130d203eb" args="(const HashTableAnchor &amp;anchor, const HASHER &amp;hasher, bslma::Allocator *allocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::HashTableImpUtil::isWellFormed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1HashTableAnchor.html">HashTableAnchor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HASHER &amp;&nbsp;</td>
          <td class="paramname"> <em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>anchor</code> is well-formed for the specified <code>hasher</code>. Use the specified <code>allocator</code> for temporary memory, or the default allocator if none is specified. For a <code><a class="el" href="classbslalg_1_1HashTableAnchor.html">HashTableAnchor</a></code> to be considered well-formed for a particular key policy, <code>KEY_CONFIG</code>, and hash functor, <code>hasher</code>, all of the following must be true:</p>
<ol>
<li>
The <code>anchor.listRootAddress()</code> is the address of a well-formed doubly linked list (see <code>bslalg_bidirectionallinklistutil</code>).  </li>
<li>
Links in the doubly linked list having the same adjusted hash value are contiguous, where the adjusted hash value is the value returned by <code>computeBucketIndex</code>, for <code>extractKey&lt;KEY_CONFIG&gt;(link)</code> and <code>anchor.bucketArraySize()</code>.  </li>
<li>
Links in the doubly linked list having the same hash value are contiguous.  </li>
<li>
The first and last links in each bucket (in the bucket array, anchor.bucketArrayAddress()') refer to a the first and last element in the well-formed doubly linked list of all nodes in the list having an adjusted hash value equal to that bucket's array index. If no values in the doubly linked list have an adjusted hash value equal to a bucket's index, then the addresses of the first and last links for that bucket are 0.  </li>
</ol>

</div>
</div>
<a class="anchor" id="ac2e71898d9b5470069cf9a424fb10c85"></a><!-- doxytag: member="bslalg::HashTableImpUtil::computeBucketIndex" ref="ac2e71898d9b5470069cf9a424fb10c85" args="(native_std::size_t hashCode, native_std::size_t numBuckets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static native_std::size_t bslalg::HashTableImpUtil::computeBucketIndex </td>
          <td>(</td>
          <td class="paramtype">native_std::size_t&nbsp;</td>
          <td class="paramname"> <em>hashCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">native_std::size_t&nbsp;</td>
          <td class="paramname"> <em>numBuckets</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the bucket referring to the elements whose adjusted hash codes are the same as the adjusted value of the specified <code>hashCode</code>, where <code>hashCode</code> (and the hash-codes of the elements) are adjusted for the specified <code>numBuckets</code>. The behavior is undefined if <code>numBuckets</code> is 0. </p>

</div>
</div>
<a class="anchor" id="af289c0c8a875ea816b8d938b02f268be"></a><!-- doxytag: member="bslalg::HashTableImpUtil::insertAtFrontOfBucket" ref="af289c0c8a875ea816b8d938b02f268be" args="(HashTableAnchor *anchor, BidirectionalLink *link, native_std::size_t hashCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::HashTableImpUtil::insertAtFrontOfBucket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1HashTableAnchor.html">HashTableAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">native_std::size_t&nbsp;</td>
          <td class="paramname"> <em>hashCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>link</code>, having the specified (non-adjusted) <code>hashCode</code>, into the the specified <code>anchor</code>, at the front of the bucket with index <code>computeBucketIndex(hashCode, anchor-&gt;bucketArraySize())</code>. The behavior is undefined unless <code>anchor</code> is well-formed (see <code>isWellFormed</code>) for some combination of <code>KEY_CONFIG</code> and <code>HASHER</code> such that <code>link</code> refers to a node of type <code><a class="el" href="classbslalg_1_1BidirectionalNode.html">BidirectionalNode</a>&lt;KEY_CONFIG::ValueType&gt;</code> and <code>HASHER(extractKey&lt;KEY_CONFIG&gt;(link))</code> returns <code>hashCode</code>. </p>

</div>
</div>
<a class="anchor" id="a47e00753d8d188e10041eeeb3fa3e6da"></a><!-- doxytag: member="bslalg::HashTableImpUtil::insertAtBackOfBucket" ref="a47e00753d8d188e10041eeeb3fa3e6da" args="(HashTableAnchor *anchor, BidirectionalLink *link, native_std::size_t hashCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::HashTableImpUtil::insertAtBackOfBucket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1HashTableAnchor.html">HashTableAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">native_std::size_t&nbsp;</td>
          <td class="paramname"> <em>hashCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>link</code>, having the specified (non-adjusted) <code>hashCode</code>, into the the specified <code>anchor</code>, into the bucket with index <code>computeBucketIndex(hashCode, anchor-&gt;bucketArraySize())</code>, after the last node in the bucket. The behavior is undefined unless <code>anchor</code> is well-formed (see <code>isWellFormed</code>) for some combination of <code>KEY_CONFIG</code> and <code>HASHER</code> such that <code>link</code> refers to a node of type <code><a class="el" href="classbslalg_1_1BidirectionalNode.html">BidirectionalNode</a>&lt;KEY_CONFIG::ValueType&gt;</code> and <code>HASHER(extractKey&lt;KEY_CONFIG&gt;(link))</code> returns <code>hashCode</code>. </p>

</div>
</div>
<a class="anchor" id="a5a00cf921b5cb9ff4ef0a56b337d339d"></a><!-- doxytag: member="bslalg::HashTableImpUtil::insertAtPosition" ref="a5a00cf921b5cb9ff4ef0a56b337d339d" args="(HashTableAnchor *anchor, BidirectionalLink *link, native_std::size_t hashCode, BidirectionalLink *position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::HashTableImpUtil::insertAtPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1HashTableAnchor.html">HashTableAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">native_std::size_t&nbsp;</td>
          <td class="paramname"> <em>hashCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>position</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>link</code>, having the specified (non-adjusted) <code>hashCode</code>, into the specified <code>anchor</code> immediately before the specified <code>position</code> in the bi-directional linked list of <code>anchor</code>. The behavior is undefined unless position is in the bucket having index <code>computeBucketIndex(hashCode, anchor-&gt;bucketArraySize())</code> and <code>anchor</code> is well-formed (see <code>isWellFormed</code>) for some combination of <code>KEY_CONFIG</code> and <code>HASHER</code> such that <code>link</code> refers to a node of type <code><a class="el" href="classbslalg_1_1BidirectionalNode.html">BidirectionalNode</a>&lt;KEY_CONFIG::ValueType&gt;</code> and <code>HASHER(extractKey&lt;KEY_CONFIG&gt;(link))</code> returns <code>hashCode</code>. </p>

</div>
</div>
<a class="anchor" id="a31268c89db26b293e452f37fd27d6f1b"></a><!-- doxytag: member="bslalg::HashTableImpUtil::remove" ref="a31268c89db26b293e452f37fd27d6f1b" args="(HashTableAnchor *anchor, BidirectionalLink *link, native_std::size_t hashCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::HashTableImpUtil::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1HashTableAnchor.html">HashTableAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">native_std::size_t&nbsp;</td>
          <td class="paramname"> <em>hashCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the specified <code>link</code>, having the specified (non-adjusted) <code>hashCode</code>, from the specified <code>anchor</code>. The behavior is undefined unless <code>anchor</code> is well-formed (see <code>isWellFormed</code>) for some combination of <code>KEY_CONFIG</code> and <code>HASHER</code> such that <code>link</code> refers to a node of type <code><a class="el" href="classbslalg_1_1BidirectionalNode.html">BidirectionalNode</a>&lt;KEY_CONFIG::ValueType&gt;</code> and <code>HASHER(extractKey&lt;KEY_CONFIG&gt;(link))</code> returns <code>hashCode</code>. </p>

</div>
</div>
<a class="anchor" id="a14dfd47dd7ed8d34fcf8d83eb243fcc7"></a><!-- doxytag: member="bslalg::HashTableImpUtil::find" ref="a14dfd47dd7ed8d34fcf8d83eb243fcc7" args="(const HashTableAnchor &amp;anchor, typename HashTableImpUtil_ExtractKeyResult&lt; KEY_CONFIG &gt;::Type key, const KEY_EQUAL &amp;equalityFunctor, native_std::size_t hashCode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class KEY_EQUAL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a>* bslalg::HashTableImpUtil::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1HashTableAnchor.html">HashTableAnchor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>anchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structbslalg_1_1HashTableImpUtil__ExtractKeyResult.html">HashTableImpUtil_ExtractKeyResult</a>&lt; KEY_CONFIG &gt;::Type&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY_EQUAL &amp;&nbsp;</td>
          <td class="paramname"> <em>equalityFunctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">native_std::size_t&nbsp;</td>
          <td class="paramname"> <em>hashCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the first link in the list element of the specified <code>anchor</code>, having a value matching (according to the specified <code>equalityFunctor</code>) the specified <code>key</code> in the bucket that holds elements with the specified <code>hashCode</code> if such a link exists, and return 0 otherwise. The behavior is undefined unless, for the provided <code>KEY_CONFIG</code> and some hash function, <code>HASHER</code>, <code>anchor</code> is well-formed (see <code>isWellFormed</code>) and <code>HASHER(key)</code> returns <code>hashCode</code>. <code>KEY_CONFIG</code> shall be a namespace providing the type names <code>KeyType</code> and <code>ValueType</code>, as well as a function that can be called as if it had the following signature: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keyword">const</span> KeyType&amp; <a class="code" href="structbslalg_1_1HashTableImpUtil.html#af5d2082db1c93cc5a32c4aedefb3f331">extractKey</a>(<span class="keyword">const</span> ValueType&amp; obj);
</pre></div><p><br/>
<br/>
 <code>KEY_EQUAL</code> shall be a functor that can be called as if it had the following signature: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> KEY_CONFIG::KeyType&amp; key1,
                          <span class="keyword">const</span> KEY_CONFIG::KeyType&amp; key2)
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a335fdd93964409b863e0f4dfae2f77af"></a><!-- doxytag: member="bslalg::HashTableImpUtil::rehash" ref="a335fdd93964409b863e0f4dfae2f77af" args="(HashTableAnchor *newAnchor, BidirectionalLink *elementList, const HASHER &amp;hasher)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY_CONFIG , class HASHER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::HashTableImpUtil::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1HashTableAnchor.html">HashTableAnchor</a> *&nbsp;</td>
          <td class="paramname"> <em>newAnchor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>elementList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HASHER &amp;&nbsp;</td>
          <td class="paramname"> <em>hasher</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Populate the specified <code>newHashTable</code> with all the elements in the specified <code>elementList</code>, using the specified <code>hasher</code> to determine the (non-adjusted) hash code for each element. This operation provides the strong exception guarantee unless the supplied <code>hasher</code> throws, in which case it provides no exception safety guarantee. The buckets in the array in <code>newAnchor</code> and the list root address in <code>newAnchor</code> are assumed to be garbage and overwritten. The behavior is undefined unless, <code>newHashTable</code> holds no elements and has one or more (empty) buckets, and <code>elementList</code> is a well-formed bi-directional list (see <code>BidirectionalLinkListUtil::isWellFormed</code>) whose nodes are each of type <code><a class="el" href="classbslalg_1_1BidirectionalNode.html">BidirectionalNode</a>&lt;KEY_CONFIG::ValueType&gt;</code>, the previous address of the first node and the next address of the last node are 0. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="bslalg__hashtableimputil_8h_source.html">bslalg_hashtableimputil.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:33 for BDE Release 2.23.1 Open-Source by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
