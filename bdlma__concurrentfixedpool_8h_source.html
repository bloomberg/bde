<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlma_concurrentfixedpool.h                                        -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLMA_CONCURRENTFIXEDPOOL
#define INCLUDED_BDLMA_CONCURRENTFIXEDPOOL

//@PURPOSE: Provide thread-safe pool of limited # of blocks of uniform size.
//
//@CLASSES:
//  bdlma::ConcurrentFixedPool: thread-safe pool of limited number of blocks
//
//@SEE_ALSO: bdlma_concurrentpool
//
//@DESCRIPTION: This component implements a *fully thread-safe* memory pool
// that allocates and manages a limited number (specified at construction) of
// memory blocks of some uniform size (also specified at construction).  A
// &#39;bdlma::ConcurrentFixedPool&#39; constructed to manage up to &#39;N&#39; blocks also
// provides an association between the address of each block and an index in
// the range &#39;[ 0 .. N - 1 ]&#39;.
//
// Other than this mapping between block and index, and the associated limit on
// the maximum number of blocks that may be simultaneously allocated, this
// component&#39;s semantics are identical to &#39;bdlma::ConcurrentPool&#39;.  In
// particular, this component overloads global operator &#39;new&#39; in the same
// manner, and the behaviors of &#39;release&#39; and &#39;reserveCapacity&#39; are equivalent
// to the corresponding methods in &#39;bdlma::ConcurrentPool&#39;.
//
// Like &#39;bdlma::ConcurrentPool&#39;, this component is intended to be used to
// implement *out-of-place* container classes that hold elements of uniform
// size.
//
///Usage
///-----
// &#39;bdlma::ConcurrentFixedPool&#39; is intended to implement *out-of-place*
// container classes that hold up to a fixed number of elements, all of uniform
// size.  Suppose we wish to implement a simple thread pool.  We want the
// equivalent of a &#39;bsl::deque&lt;bsl::function&lt;void(void)&gt; &gt;&#39;.  However, to
// minimize the time spent performing operations on this deque - which must be
// carried out under a lock - we instead store just pointers in the deque, and
// manage memory efficiently using &#39;bdlma::ConcurrentFixedPool&#39;.
// &#39;bdlma::ConcurrentFixedPool&#39; is fully thread-safe and does not require any
// additional synchronization.
//
// The example below is just for the container portion of our simple thread
// pool.  The implementation of the worker thread, and the requisite
// synchronization, are omitted for clarity.
//..
//  class my_JobQueue {
//
//    public:
//      // PUBLIC TYPES
//      typedef bsl::function&lt;void(void)&gt; Job;
//
//    private:
//      // DATA
//      bslmt::Mutex                d_lock;
//      bsl::deque&lt;Job *&gt;           d_queue;
//      bdlma::ConcurrentFixedPool  d_pool;
//      bslma::Allocator           *d_allocator_p;
//
//      // Not implemented:
//      my_JobQueue(const my_JobQueue&amp;);
//
//    public:
//      // CREATORS
//      my_JobQueue(int maxJobs, bslma::Allocator *basicAllocator = 0);
//      ~my_JobQueue();
//
//      // MANIPULATORS
//      void enqueueJob(const Job&amp; job);
//
//      int tryExecuteJob();
//  };
//
//  my_JobQueue::my_JobQueue(int maxJobs, bslma::Allocator *basicAllocator)
//  : d_queue(basicAllocator)
//  , d_pool(sizeof(Job), maxJobs, basicAllocator)
//  , d_allocator_p(bslma::Default::allocator(basicAllocator))
//  {
//  }
//
//  my_JobQueue::~my_JobQueue()
//  {
//      Job *jobPtr;
//      while (!d_queue.empty()) {
//          jobPtr = d_queue.front();
//          jobPtr-&gt;~Job();
//          d_queue.pop_front();
//      }
//  }
//
//  void my_JobQueue::enqueueJob(const Job&amp; job)
//  {
//      Job *jobPtr = new (d_pool) Job(job, d_allocator_p);
//      d_lock.lock();
//      d_queue.push_back(jobPtr);
//      d_lock.unlock();
//  }
//
//  int my_JobQueue::tryExecuteJob()
//  {
//      d_lock.lock();
//      if (d_queue.empty()) {
//          d_lock.unlock();
//          return -1;                                                // RETURN
//      }
//      Job *jobPtr = d_queue.front();
//      d_queue.pop_front();
//      d_lock.unlock();
//      (*jobPtr)();
//      d_pool.deleteObject(jobPtr);
//      return 0;
//  }
//..
// Note that in the destructor, there is no need to deallocate the individual
// job objects - the destructor of &#39;bdlma::ConcurrentFixedPool&#39; will release
// any remaining allocated memory.  However, it *is* necessary to invoke the
// destructors of all these objects, as the destructor of
// &#39;bdlma::ConcurrentFixedPool&#39; will not do so.

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMT_MUTEX
#include &lt;bslmt_mutex.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMIC
#include &lt;bsls_atomic.h&gt;
#endif

#ifndef INCLUDED_BDLMA_POOL
#include &lt;bdlma_pool.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DELETERHELPER
#include &lt;bslma_deleterhelper.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENTUTIL
#include &lt;bsls_alignmentutil.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDLIB
#include &lt;bsl_cstdlib.h&gt;
#endif

namespace BloombergLP {
namespace bdlma {

                     // ===============================
                     // struct ConcurrentFixedPool_Node
                     // ===============================

struct ConcurrentFixedPool_Node {
    // The component-private &#39;struct&#39; provides a header for blocks that are
    // allocated from &#39;ConcurrentFixedPool&#39; objects.

    // DATA
    unsigned d_next;  // index of next free node when on free list; otherwise,
                      // index of this node itself adjusted with a generation
                      // count
};

                        // =========================
                        // class ConcurrentFixedPool
                        // =========================

class ConcurrentFixedPool {
    // This class implements a memory pool that allocates and manages up to a
    // fixed number of memory blocks of some uniform size, with both the limit
    // on the number of blocks and the block size specified at construction.
    //
    // This class guarantees thread safety when allocating or releasing memory
    // (but see the documentation for the &#39;release&#39; method).

    // PRIVATE TYPES
    typedef ConcurrentFixedPool_Node Node;  // type of memory block &quot;header&quot;

    // DATA
    bsls::AtomicInt      d_freeList;        // head of free list

    const unsigned       d_sizeMask;        // mask corresponding to max size
                                            // of pool; rounded up to power of
                                            // 2

    bsl::vector&lt;Node *&gt;  d_nodes;           // holds nodes currently being
                                            // pooled; enables index &lt;-&gt;
                                            // address mapping

    const int            d_dataOffset;      // offset (in bytes) to memory
                                            // block within a &#39;Node&#39;

    const int            d_nodeSize;        // size of blocks pooled by
                                            // &#39;d_nodePool&#39;

    bslmt::Mutex         d_nodePoolMutex;   // mutex for access to &#39;d_nodePool&#39;

    bdlma::Pool          d_nodePool;        // underlying memory pool

    int                  d_numNodes;        // number of nodes in &#39;d_nodes&#39;
                                            // that are currently being pooled

    const int            d_objectSize;      // size of pooled objects as
                                            // specified at construction

    int                  d_backoffLevel;    // determines amount of spinning
                                            // when under contention

    bslma::Allocator    *d_allocator_p;     // memory allocator (held, not
                                            // owned)

    // NOT IMPLEMENTED
    ConcurrentFixedPool(const ConcurrentFixedPool&amp;);
    ConcurrentFixedPool&amp; operator=(const ConcurrentFixedPool&amp;);

  private:
    // PRIVATE MANIPULATORS
    void *allocateNew();
        // Allocate a memory block of the &#39;objectSize&#39; specified at
        // construction from the underlying pool from which this fixed pool
        // obtains memory.  Return the address of that block or 0 if this pool
        // is exhausted (i.e., &#39;poolSize()&#39; memory blocks have already been
        // allocated from this pool).

  public:
    // CREATORS
    ConcurrentFixedPool(int               objectSize,
                        int               poolSize,
                        bslma::Allocator *basicAllocator = 0);
        // Create a memory pool that returns memory of the specified
        // &#39;objectSize&#39; for each invocation of the &#39;allocate&#39; method.
        // Configure this pool to support allocation of up to the specified
        // &#39;poolSize&#39; number of memory blocks.  The largest supported
        // &#39;poolSize&#39; is 33554431.  Optionally specify a &#39;basicAllocator&#39; used
        // to supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.  The behavior is undefined unless
        // &#39;0 &lt; objectSize&#39;, &#39;0 &lt; poolSize&#39;, and &#39;0x1FFFFFF &gt;= poolSize&#39;.

    ~ConcurrentFixedPool();
        // Destroy this object and release all associated memory.

    // MANIPULATORS
    void *allocate();
        // Allocate a memory block of the &#39;objectSize&#39; specified at
        // construction.  Return the address of that block or 0 if the pool is
        // exhausted (i.e., &#39;poolSize()&#39; memory blocks have already been
        // allocated from this pool).

    void deallocate(void *address);
        // Deallocate the memory block at the specified &#39;address&#39; back to this
        // pool for reuse.

    template&lt;class TYPE&gt;
    void deleteObject(const TYPE *object);
        // Destroy the specified &#39;object&#39; based on its dynamic type and then
        // use this allocator to deallocate its memory footprint.  Do nothing
        // if &#39;object&#39; is 0.  The behavior is undefined unless &#39;object&#39;, when
        // cast appropriately to &#39;void *&#39;, was allocated using this allocator
        // and has not already been deallocated.  Note that
        // &#39;dynamic_cast&lt;void *&gt;(object)&#39; is applied if &#39;TYPE&#39; is polymorphic,
        // and &#39;static_cast&lt;void *&gt;(object)&#39; is applied otherwise.

    template &lt;class TYPE&gt;
    void deleteObjectRaw(const TYPE *object);
        // Destroy the specified &#39;object&#39; based on its static type and then use
        // this allocator to deallocate its memory footprint.  Do nothing if
        // &#39;object&#39; is 0.  The behavior is undefined if &#39;object&#39; is a
        // base-class pointer to a derived type, was not allocated using this
        // allocator, or has already been deallocated.

    void release();
        // Release all memory currently allocated through this object.  Note
        // that this method should only be invoked when it is known that no
        // blocks currently allocated through this pool will be used;
        // therefore, it is not safe to use this method if any other thread may
        // be concurrently allocating memory from this pool.  Also note that
        // &#39;release()&#39; is intended to free all memory without regard to the
        // contents of that memory.  Specifically, &#39;release()&#39; can *not* call
        // object destructors for any allocated objects, since it has no
        // knowledge of their type.  If object destruction is required, use
        // &#39;ConcurrentFixedPool::deleteObject()&#39;.

    int reserveCapacity(int numObjects);
        // Reserve memory from this pool to satisfy memory requests for at
        // least the specified &#39;numObjects&#39; before the pool replenishes.  The
        // behavior is undefined unless &#39;0 &lt;= numObjects&#39;.  Return 0 on success
        // and the number of objects that could not be reserved otherwise.
        // Note that this method fails if the number of memory blocks already
        // allocated plus &#39;numObjects&#39; exceeds &#39;poolSize()&#39;.

    void setBackoffLevel(int backoffLevel);
        // Configure this pool with the specified non-negative &#39;backoffLevel&#39;
        // that controls the amount of spinning that occurs when calls to this
        // pool encounter contention.  Setting &#39;backoffLevel&#39; to 0 disables
        // spinning.  Greater values of &#39;backoffLevel&#39; correspond to greater
        // amounts of spinning.  The behavior is undefined unless
        // &#39;0 &lt;= backoffLevel&#39;.  Note that both contention detection and
        // spinning strategy are implementation defined.

    // ACCESSORS
    int backoffLevel() const;
        // Return the non-negative &#39;backoffLevel&#39; that controls the amount of
        // spinning that occurs when calls to this pool encounter contention.

    int indexFromAddress(void *address) const;
        // Return an index in the range from 0 to the maximum size of this pool
        // that uniquely identifies the memory block at the specified
        // &#39;address&#39;.  The behavior is undefined unless &#39;address&#39; corresponds
        // to a memory block allocated from this pool.

    int objectSize() const;
        // Return the size of the memory blocks allocated from this object.
        // Note that all blocks have the same size.

    void *addressFromIndex(int index) const;
        // Return the address of the memory block identified by the specified
        // &#39;index&#39;.  The behavior is undefined unless the index has been
        // obtained through &#39;indexFromAddress&#39;.

    int poolSize() const;
        // Return the maximum size of this pool.
};

}  // close package namespace
}  // close enterprise namespace

// FREE OPERATORS
inline
void *operator new(bsl::size_t                              size,
                   BloombergLP::bdlma::ConcurrentFixedPool&amp; pool);
    // Allocate memory of the specified &#39;size&#39; bytes from the specified &#39;pool&#39;,
    // and return the address of the allocated memory.  The behavior is
    // undefined unless &#39;size&#39; is the same as the &#39;objectSize&#39; with which
    // &#39;pool&#39; was constructed.  Note that an object may allocate additional
    // memory internally within its constructor, requiring the allocator to be
    // passed in as a constructor argument:
    //..
    //  my_Type *newMyType(bdlma::ConcurrentFixedPool  *pool,
    //                     bslma::Allocator *basicAllocator) {
    //      return new (*pool) my_Type(..., basicAllocator);
    //  }
    //..
    // Note also that the analogous version of operator &#39;delete&#39; should not be
    // called directly.  Instead, this component provides a template member
    // function &#39;bdlma::ConcurrentFixedPool::deleteObject&#39; parameterized by
    // &#39;TYPE&#39; that performs the equivalent of the following:
    //..
    //  void deleteMyType(bdlma::ConcurrentFixedPool *pool, my_Type *t) {
    //      t-&gt;~my_Type();
    //      pool-&gt;deallocate(t);
    //  }
    //..

inline
void operator delete(void                                     *address,
                     BloombergLP::bdlma::ConcurrentFixedPool&amp;  pool);
    // Use the specified &#39;pool&#39; to deallocate the memory at the specified
    // &#39;address&#39;.  The behavior is undefined unless &#39;address&#39; was allocated
    // using &#39;pool&#39; and has not already been deallocated.  This operator is
    // supplied solely to allow the compiler to arrange for it to be called in
    // case of an exception.  Client code should not call it; use
    // &#39;bdlma::ConcurrentFixedPool::deleteObject()&#39; instead.

namespace BloombergLP {
namespace bdlma {

// ============================================================================
//                             INLINE DEFINITIONS
// ============================================================================

                        // -------------------------
                        // class ConcurrentFixedPool
                        // -------------------------

// MANIPULATORS
template&lt;class TYPE&gt;
inline
void ConcurrentFixedPool::deleteObject(const TYPE *object)
{
    bslma::DeleterHelper::deleteObject(object, this);
}

template&lt;class TYPE&gt;
inline
void ConcurrentFixedPool::deleteObjectRaw(const TYPE *object)
{
    bslma::DeleterHelper::deleteObjectRaw(object, this);
}

inline
void ConcurrentFixedPool::setBackoffLevel(int backoffLevel)
{
    d_backoffLevel = backoffLevel;
}

// ACCESSORS
inline
void *ConcurrentFixedPool::addressFromIndex(int index) const
{
    Node * node = const_cast&lt;Node *&gt;(d_nodes[index]);

    BSLS_ASSERT(node);
    return (char *)node + d_dataOffset;
}

inline
int ConcurrentFixedPool::backoffLevel() const
{
    return d_backoffLevel;
}

inline
int ConcurrentFixedPool::indexFromAddress(void *address) const
{
    const Node * const node = (const Node *)(void *)
                                              ((char *)address - d_dataOffset);
    return (node-&gt;d_next &amp; d_sizeMask) - 1;
}

inline
int ConcurrentFixedPool::objectSize() const
{
    return d_objectSize;
}

inline
int ConcurrentFixedPool::poolSize() const
{
    return static_cast&lt;int&gt;(d_nodes.size());
}

}  // close package namespace
}  // close enterprise namespace

inline
void *operator new(bsl::size_t                              size,
                   BloombergLP::bdlma::ConcurrentFixedPool&amp; pool)
{
    using namespace BloombergLP;
    BSLS_ASSERT((int) size &lt;= pool.objectSize()
        &amp;&amp; bsls::AlignmentUtil::calculateAlignmentFromSize((int)size)
        &lt;= bsls::AlignmentUtil::calculateAlignmentFromSize(pool.objectSize()));

    (void)size;  // suppress &quot;unused parameter&quot; warnings
    return pool.allocate();
}

inline
void operator delete(void                                     *address,
                     BloombergLP::bdlma::ConcurrentFixedPool&amp;  pool)
{
    pool.deallocate(address);
}

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
