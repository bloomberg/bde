<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// balber_berdecoderoptions.h                                         -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALBER_BERDECODEROPTIONS
#define INCLUDED_BALBER_BERDECODEROPTIONS

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an attribute class for specifying BER decoding options.
//
//@CLASSES:
//  bdem::balber::BerDecoderOptions: options for decoding objects in BDE format
//
//@DESCRIPTION: Schema of options records for &#39;bdem&#39; codecs

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include &lt;bslalg_typetraits.h&gt;
#endif

#ifndef INCLUDED_BDLAT_ATTRIBUTEINFO
#include &lt;bdlat_attributeinfo.h&gt;
#endif

#ifndef INCLUDED_BDLAT_TYPETRAITS
#include &lt;bdlat_typetraits.h&gt;
#endif

#ifndef INCLUDED_BDLAT_VALUETYPEFUNCTIONS
#include &lt;bdlat_valuetypefunctions.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLX_INSTREAMFUNCTIONS
#include &lt;bslx_instreamfunctions.h&gt;
#endif

#ifndef INCLUDED_BSLX_OUTSTREAMFUNCTIONS
#include &lt;bslx_outstreamfunctions.h&gt;
#endif

#ifndef INCLUDED_BDLB_PRINTMETHODS
#include &lt;bdlb_printmethods.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

namespace BloombergLP {
namespace balber {

                          // =======================
                          // class BerDecoderOptions
                          // =======================

class BerDecoderOptions {
    // BER decoding options

  private:
    int   d_maxDepth;            // maximum recursion depth
    int   d_traceLevel;          // trace (verbosity) level
    int   d_maxSequenceSize;     // maximum sequence size
    bool  d_skipUnknownElements; // if &#39;true&#39;, skip unknown elements

  public:
    // TYPES
    enum {
        k_NUM_ATTRIBUTES = 4  // the number of attributes in this class

    };

    enum {
        e_ATTRIBUTE_INDEX_MAX_DEPTH             = 0
            // index for &quot;MaxDepth&quot; attribute
      , e_ATTRIBUTE_INDEX_SKIP_UNKNOWN_ELEMENTS = 1
            // index for &quot;SkipUnknownElements&quot; attribute
      , e_ATTRIBUTE_INDEX_TRACE_LEVEL           = 2
            // index for &quot;TraceLevel&quot; attribute
      , e_ATTRIBUTE_INDEX_MAX_SEQUENCE_SIZE     = 3
            // index for &quot;MaxSequenceSize&quot; attribute

    };

    enum {
        e_ATTRIBUTE_ID_MAX_DEPTH             = 0
            // id for &#39;MaxDepth&#39; attribute
      , e_ATTRIBUTE_ID_SKIP_UNKNOWN_ELEMENTS = 1
            // id for &#39;SkipUnknownElements&#39; attribute
      , e_ATTRIBUTE_ID_TRACE_LEVEL           = 2
            // id for &#39;TraceLevel&#39; attribute
      , e_ATTRIBUTE_ID_MAX_SEQUENCE_SIZE     = 3
            // id for &#39;MaxSequenceSize&#39; attribute

    };

  public:
    // CONSTANTS
    static const char CLASS_NAME[];
        // the name of this class (i.e., &quot;BerDecoderOptions&quot;)

    static const int DEFAULT_MAX_DEPTH;
        // default value of &#39;MaxDepth&#39; attribute

    static const bool DEFAULT_SKIP_UNKNOWN_ELEMENTS;
        // default value of &#39;SkipUnknownElements&#39; attribute

    static const int DEFAULT_TRACE_LEVEL;
        // default value of &#39;TraceLevel&#39; attribute

    static const int DEFAULT_MAX_SEQUENCE_SIZE;
        // default value of &#39;MaxSequenceSize&#39; attribute

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];
        // attribute information for each attribute

  public:
    // CLASS METHODS
    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that it is highly recommended that &#39;versionSelector&#39;
        // be formatted as &quot;YYYYMMDD&quot;, a date representation.  Also note that
        // &#39;versionSelector&#39; should be a *compile*-time-chosen value that
        // selects a format version supported by both externalizer and
        // unexternalizer.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.


    static const bdlat_AttributeInfo *lookupAttributeInfo(int id);
        // Return attribute information for the attribute indicated by the
        // specified &#39;id&#39; if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo *lookupAttributeInfo(
                                                    const char *name,
                                                    int         nameLength);
        // Return attribute information for the attribute indicated by the
        // specified &#39;name&#39; of the specified &#39;nameLength&#39; if the attribute
        // exists, and 0 otherwise.

    // CREATORS
    BerDecoderOptions();
        // Create an object of type &#39;BerDecoderOptions&#39; having the default
        // value.

    //! BerDecoderOptions(const BerDecoderOptions&amp; original) = default;
        // Create a &#39;BderDecoderOptons&#39; object having the same value as the
        // specified &#39;original&#39;.

    //! ~BerDecoderOptions() = default;
        // Destroy this object.

    // MANIPULATORS
    //! BerDecoderOptions&amp; operator=(const BerDecoderOptions&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated, but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    void reset();
        // Reset this object to the default value (i.e., its value upon default
        // construction).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttributes(MANIPULATOR&amp; manipulator);
        // Invoke the specified &#39;manipulator&#39; sequentially on the address of
        // each (modifiable) attribute of this object, supplying &#39;manipulator&#39;
        // with the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the last
        // invocation of &#39;manipulator&#39; (i.e., the invocation that terminated
        // the sequence).

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp; manipulator, int id);
        // Invoke the specified &#39;manipulator&#39; on the address of the
        // (modifiable) attribute indicated by the specified &#39;id&#39;, supplying
        // &#39;manipulator&#39; with the corresponding attribute information
        // structure.  Return the value returned from the invocation of
        // &#39;manipulator&#39; if &#39;id&#39; identifies an attribute of this class, and -1
        // otherwise.

    template&lt;class MANIPULATOR&gt;
    int manipulateAttribute(MANIPULATOR&amp;  manipulator,
                            const char   *name,
                            int           nameLength);
        // Invoke the specified &#39;manipulator&#39; on the address of the
        // (modifiable) attribute indicated by the specified &#39;name&#39; of the
        // specified &#39;nameLength&#39;, supplying &#39;manipulator&#39; with the
        // corresponding attribute information structure.  Return the value
        // returned from the invocation of &#39;manipulator&#39; if &#39;name&#39; identifies
        // an attribute of this class, and -1 otherwise.

    void setMaxDepth(int value);
        // Set the &#39;MaxDepth&#39; attribute of this object to the specified
        // &#39;value&#39;.

    void setSkipUnknownElements(bool value);
        // Set the &#39;SkipUnknownElements&#39; attribute of this object to the
        // specified &#39;value&#39;.

    void setTraceLevel(int value);
        // Set the &#39;TraceLevel&#39; attribute of this object to the specified
        // &#39;value&#39;.

    void setMaxSequenceSize(int value);
        // Set the &#39;MaxSequenceSize&#39; attribute of this object to the specified
        // &#39;value&#39;.

    // ACCESSORS
    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the
        // optionally specified indentation &#39;level&#39; and return a reference to
        // the modifiable &#39;stream&#39;.  If &#39;level&#39; is specified, optionally
        // specify &#39;spacesPerLevel&#39;, the number of spaces per indentation level
        // for this and all of its nested objects.  Each line is indented by
        // the absolute value of &#39;level * spacesPerLevel&#39;.  If &#39;level&#39; is
        // negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, suppress line breaks and format the
        // entire output on one line.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  Note that a trailing newline is provided
        // in multiline mode only.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write the value of this object, using the specified &#39;version&#39;
        // format, to the specified output &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation has no
        // effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is invalidated, but
        // otherwise unmodified.  Note that &#39;version&#39; is not written to
        // &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    template&lt;class ACCESSOR&gt;
    int accessAttributes(ACCESSOR&amp; accessor) const;
        // Invoke the specified &#39;accessor&#39; sequentially on each
        // (non-modifiable) attribute of this object, supplying &#39;accessor&#39; with
        // the corresponding attribute information structure until such
        // invocation returns a non-zero value.  Return the value from the last
        // invocation of &#39;accessor&#39; (i.e., the invocation that terminated the
        // sequence).

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp; accessor, int id) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute of
        // this object indicated by the specified &#39;id&#39;, supplying &#39;accessor&#39;
        // with the corresponding attribute information structure.  Return the
        // value returned from the invocation of &#39;accessor&#39; if &#39;id&#39; identifies
        // an attribute of this class, and -1 otherwise.

    template&lt;class ACCESSOR&gt;
    int accessAttribute(ACCESSOR&amp;   accessor,
                        const char *name,
                        int         nameLength) const;
        // Invoke the specified &#39;accessor&#39; on the (non-modifiable) attribute of
        // this object indicated by the specified &#39;name&#39; of the specified
        // &#39;nameLength&#39;, supplying &#39;accessor&#39; with the corresponding attribute
        // information structure.  Return the value returned from the
        // invocation of &#39;accessor&#39; if &#39;name&#39; identifies an attribute of this
        // class, and -1 otherwise.

    const int&amp; maxDepth() const;
        // Return a reference to the non-modifiable &quot;MaxDepth&quot; attribute of
        // this object.

    const bool&amp; skipUnknownElements() const;
        // Return a reference to the non-modifiable &quot;SkipUnknownElements&quot;
        // attribute of this object.

    const int&amp; traceLevel() const;
        // Return a reference to the non-modifiable &quot;TraceLevel&quot; attribute of
        // this object.

    const int&amp; maxSequenceSize() const;
        // Return a reference to the non-modifiable &quot;MaxSequenceSize&quot; attribute
        // of this object.
};

// FREE OPERATORS
inline
bool operator==(const BerDecoderOptions&amp; lhs,
                const BerDecoderOptions&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects have
    // the same value, and &#39;false&#39; otherwise.  Two attribute objects have the
    // same value if each respective attribute has the same value.

inline
bool operator!=(const BerDecoderOptions&amp; lhs,
                const BerDecoderOptions&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; attribute objects do not
    // have the same value, and &#39;false&#39; otherwise.  Two attribute objects do
    // not have the same value if one or more respective attributes differ in
    // values.

inline
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;            stream,
                         const BerDecoderOptions&amp; rhs);
    // Format the specified &#39;rhs&#39; to the specified output &#39;stream&#39; and return a
    // reference providing modifiable access to &#39;stream&#39;.

}  // close package namespace


// TRAITS
BDLAT_DECL_SEQUENCE_TRAITS(balber::BerDecoderOptions)

namespace balber {

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

                          // -----------------------
                          // class BerDecoderOptions
                          // -----------------------

// CLASS METHODS
inline
int BerDecoderOptions::maxSupportedBdexVersion(int /* versionSelector */)
{
    return 1;  // versions start at 1
}


// CREATORS
inline
BerDecoderOptions::BerDecoderOptions()
: d_maxDepth(DEFAULT_MAX_DEPTH)
, d_traceLevel(DEFAULT_TRACE_LEVEL)
, d_maxSequenceSize(DEFAULT_MAX_SEQUENCE_SIZE)
, d_skipUnknownElements(DEFAULT_SKIP_UNKNOWN_ELEMENTS)
{
}

// MANIPULATORS
template &lt;class STREAM&gt;
inline
STREAM&amp; BerDecoderOptions::bdexStreamIn(STREAM&amp; stream, int version)
{
    if (stream) {
        switch (version) {  // Switch on the schema version (starting with 1).
          case 1: {
            bslx::InStreamFunctions::bdexStreamIn(stream, d_maxDepth, 1);
            bslx::InStreamFunctions::bdexStreamIn(stream,
                                                  d_skipUnknownElements, 1);
            bslx::InStreamFunctions::bdexStreamIn(stream, d_traceLevel, 1);
            bslx::InStreamFunctions::bdexStreamIn(stream,
                                                  d_maxSequenceSize, 1);
          } break;
          default: {
            stream.invalidate();
          }
        }
    }
    return stream;
}

inline
void BerDecoderOptions::reset()
{
    d_maxDepth            = DEFAULT_MAX_DEPTH;
    d_traceLevel          = DEFAULT_TRACE_LEVEL;
    d_maxSequenceSize     = DEFAULT_MAX_SEQUENCE_SIZE;
    d_skipUnknownElements = DEFAULT_SKIP_UNKNOWN_ELEMENTS;
}

template &lt;class MANIPULATOR&gt;
inline
int BerDecoderOptions::manipulateAttributes(MANIPULATOR&amp; manipulator)
{
    int ret;

    ret = manipulator(&amp;d_maxDepth,
                      ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_MAX_DEPTH]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(
                &amp;d_skipUnknownElements,
                ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_SKIP_UNKNOWN_ELEMENTS]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(&amp;d_traceLevel,
                      ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_TRACE_LEVEL]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = manipulator(
                    &amp;d_maxSequenceSize,
                    ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_MAX_SEQUENCE_SIZE]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class MANIPULATOR&gt;
inline
int BerDecoderOptions::manipulateAttribute(MANIPULATOR&amp; manipulator, int id)
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_MAX_DEPTH: {
        return manipulator(&amp;d_maxDepth,
                           ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_MAX_DEPTH]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_SKIP_UNKNOWN_ELEMENTS: {
        return manipulator(
               &amp;d_skipUnknownElements,
               ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_SKIP_UNKNOWN_ELEMENTS]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_TRACE_LEVEL: {
        return manipulator(
                          &amp;d_traceLevel,
                          ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_TRACE_LEVEL]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_MAX_SEQUENCE_SIZE: {
        return manipulator(
                    &amp;d_maxSequenceSize,
                    ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_MAX_SEQUENCE_SIZE]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;
    }
}

template &lt;class MANIPULATOR&gt;
inline
int BerDecoderOptions::manipulateAttribute(MANIPULATOR&amp;  manipulator,
                                           const char   *name,
                                           int           nameLength)
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (!attributeInfo) {
        return k_NOT_FOUND;                                           // RETURN
    }

    return manipulateAttribute(manipulator, attributeInfo-&gt;d_id);
}

inline
void BerDecoderOptions::setMaxDepth(int value)
{
    d_maxDepth = value;
}

inline
void BerDecoderOptions::setSkipUnknownElements(bool value)
{
    d_skipUnknownElements = value;
}

inline
void BerDecoderOptions::setTraceLevel(int value)
{
    d_traceLevel = value;
}

inline
void BerDecoderOptions::setMaxSequenceSize(int value)
{
    d_maxSequenceSize = value;
}

// ACCESSORS
template &lt;class STREAM&gt;
inline
STREAM&amp; BerDecoderOptions::bdexStreamOut(STREAM&amp; stream,
                                         int     version) const
{
    switch (version) {
      case 1: {
        bslx::OutStreamFunctions::bdexStreamOut(stream, d_maxDepth, 1);
        bslx::OutStreamFunctions::bdexStreamOut(stream,
                                               d_skipUnknownElements, 1);
        bslx::OutStreamFunctions::bdexStreamOut(stream, d_traceLevel, 1);
        bslx::OutStreamFunctions::bdexStreamOut(stream, d_maxSequenceSize, 1);
      } break;
      default: {
        stream.invalidate();
      } break;
    }
    return stream;
}

template &lt;class ACCESSOR&gt;
inline
int BerDecoderOptions::accessAttributes(ACCESSOR&amp; accessor) const
{
    int ret;

    ret = accessor(d_maxDepth,
                   ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_MAX_DEPTH]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(
                d_skipUnknownElements,
                ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_SKIP_UNKNOWN_ELEMENTS]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_traceLevel,
                   ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_TRACE_LEVEL]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    ret = accessor(d_maxSequenceSize,
                   ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_MAX_SEQUENCE_SIZE]);
    if (ret) {
        return ret;                                                   // RETURN
    }

    return ret;
}

template &lt;class ACCESSOR&gt;
inline
int BerDecoderOptions::accessAttribute(ACCESSOR&amp; accessor, int id) const
{
    enum { k_NOT_FOUND = -1 };

    switch (id) {
      case e_ATTRIBUTE_ID_MAX_DEPTH: {
        return accessor(d_maxDepth,
                        ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_MAX_DEPTH]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_SKIP_UNKNOWN_ELEMENTS: {
        return accessor(
                d_skipUnknownElements,
                ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_SKIP_UNKNOWN_ELEMENTS]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_TRACE_LEVEL: {
        return accessor(d_traceLevel,
                        ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_TRACE_LEVEL]);
                                                                      // RETURN
      } break;
      case e_ATTRIBUTE_ID_MAX_SEQUENCE_SIZE: {
        return accessor(
                    d_maxSequenceSize,
                    ATTRIBUTE_INFO_ARRAY[e_ATTRIBUTE_INDEX_MAX_SEQUENCE_SIZE]);
                                                                      // RETURN
      } break;
      default:
        return k_NOT_FOUND;
    }
}

template &lt;class ACCESSOR&gt;
inline
int BerDecoderOptions::accessAttribute(ACCESSOR&amp;   accessor,
                                       const char *name,
                                       int         nameLength) const
{
    enum { k_NOT_FOUND = -1 };

    const bdlat_AttributeInfo *attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (!attributeInfo) {
       return k_NOT_FOUND;                                            // RETURN
    }

    return accessAttribute(accessor, attributeInfo-&gt;d_id);
}

inline
const int&amp; BerDecoderOptions::maxDepth() const
{
    return d_maxDepth;
}

inline
const bool&amp; BerDecoderOptions::skipUnknownElements() const
{
    return d_skipUnknownElements;
}

inline
const int&amp; BerDecoderOptions::traceLevel() const
{
    return d_traceLevel;
}

inline
const int&amp; BerDecoderOptions::maxSequenceSize() const
{
    return d_maxSequenceSize;
}

}  // close package namespace

// FREE FUNCTIONS
inline
bool balber::operator==(const BerDecoderOptions&amp; lhs,
                        const BerDecoderOptions&amp; rhs)
{
    return  lhs.maxDepth()            == rhs.maxDepth()
         &amp;&amp; lhs.skipUnknownElements() == rhs.skipUnknownElements()
         &amp;&amp; lhs.traceLevel()          == rhs.traceLevel()
         &amp;&amp; lhs.maxSequenceSize()     == rhs.maxSequenceSize();
}

inline
bool balber::operator!=(const BerDecoderOptions&amp; lhs,
                        const BerDecoderOptions&amp; rhs)
{
    return  lhs.maxDepth()            != rhs.maxDepth()
         || lhs.skipUnknownElements() != rhs.skipUnknownElements()
         || lhs.traceLevel()          != rhs.traceLevel()
         || lhs.maxSequenceSize()     != rhs.maxSequenceSize();
}

inline
bsl::ostream&amp; balber::operator&lt;&lt;(bsl::ostream&amp;            stream,
                                 const BerDecoderOptions&amp; rhs)
{
    return rhs.print(stream, 0, -1);
}

}  // close enterprise namespace
#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
