<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bdlma_bufferedsequentialallocator.h                                -*-C++-*-
#ifndef INCLUDED_BDLMA_BUFFEREDSEQUENTIALALLOCATOR
#define INCLUDED_BDLMA_BUFFEREDSEQUENTIALALLOCATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an efficient managed allocator using an external buffer.
//
//@CLASSES:
//  bdlma::BufferedSequentialAllocator: allocator using an external buffer
//
//@SEE_ALSO: bdlma_bufferedsequentialpool, bdlma_sequentialallocator
//
//@DESCRIPTION: This component provides a concrete mechanism,
// &#39;bdlma::BufferedSequentialAllocator&#39;, that implements the
// &#39;bdlma::ManagedAllocator&#39; protocol to very efficiently allocate
// heterogeneous memory blocks (of varying, user-specified sizes) from an
// external buffer supplied at construction:
//..
//   ,----------------------------------.
//  ( bdlma::BufferedSequentialAllocator )
//   `----------------------------------&#39;
//                   |        ctor/dtor
//                   |
//                   V
//       ,-----------------------.
//      ( bdlma::ManagedAllocator )
//       `-----------------------&#39;
//                   |        release
//                   V
//          ,----------------.
//         ( bslma::Allocator )
//          `----------------&#39;
//                            allocate
//                            deallocate
//..
// If an allocation request exceeds the remaining free memory space in
// the external buffer, the allocator will fall back to a sequence of
// dynamically-allocated buffers.  Users can optionally specify a growth
// strategy at construction that governs the growth rate of the
// dynamically-allocated buffers.  If no growth strategy is specified at
// construction, geometric growth is used.  Users can also optionally specify
// an alignment strategy at construction that governs the alignment of
// allocated memory blocks.  If no alignment strategy is specified at
// construction, natural alignment is used.  The &#39;release&#39; method releases all
// memory allocated through the allocator, as does the destructor.  Note that,
// even though a &#39;deallocate&#39; method is available, it has no effect:
// Individually allocated memory blocks cannot be separately deallocated.
//
// &#39;bdlma::BufferedSequentialAllocator&#39; is typically used when users have a
// reasonable estimation of the amount of memory needed.  This amount of memory
// would typically be created directly on the program stack, and used as the
// initial external buffer of the allocator for very fast memory allocation.
// While the buffer has sufficient capacity, memory allocations using the pool
// will not trigger *any* dynamic memory allocation, will have optimal locality
// of reference, and will not require deallocation upon destruction.
//
// Once the external buffer is exhausted, subsequent allocation requests
// require dynamic memory allocation, and the performance of the allocator
// degrades.
//
// The main difference between a &#39;bdlma::BufferedSequentialAllocator&#39; and a
// &#39;bdlma::BufferedSequentialPool&#39; is that, very often, the allocator is
// maintained through a &#39;bslma::Allocator&#39; pointer - hence, every call to
// &#39;allocate&#39; is a virtual function call, which is slower than invoking
// &#39;allocate&#39; with the pool directly.  However, the allocator interface is much
// more widely accepted across objects, and hence more general purpose.
//
///Optional &#39;maxBufferSize&#39; Parameter
/// - - - - - - - - - - - - - - - - -
// An optional &#39;maxBufferSize&#39; parameter can be supplied at construction to
// specify the maximum size (in bytes) of the dynamically-allocated buffers for
// geometric growth.  Once the internal buffer grows up to the &#39;maxBufferSize&#39;,
// further requests that exceed this size will be served by a separate memory
// block instead of the internal buffer.  The behavior is undefined unless
// &#39;size &lt;= maxBufferSize&#39;, where &#39;size&#39; is the extent (in bytes) of the
// external buffer supplied at construction.
//
///Warning
///-------
// Note that, even when a buffer having &#39;n&#39; bytes of memory is supplied at
// construction, it does *not* mean that &#39;n&#39; bytes of memory are available
// before dynamic memory allocation is triggered.  This is due to memory
// alignment requirements.  If the buffer supplied is not aligned, the first
// call to the &#39;allocate&#39; method will automatically skip one or more bytes such
// that the memory allocated is properly aligned.  The number of bytes that are
// wasted depends on whether natural alignment, maximum alignment, or 1-byte
// alignment is used (see &#39;bsls_alignment&#39; for more details).
//
///Usage
///-----
///Example 1: Using &#39;bdlma::BufferedSequentialAllocator&#39; with Exact Calculation
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we need to implement a method, &#39;calculate&#39;, that performs
// calculations (where the specifics are not important to illustrate the use of
// this component), which require three vectors of &#39;double&#39; values.
// Furthermore, suppose we know that we need to store at most 100 values for
// each vector:
//..
//  double calculate(const bsl::vector&lt;double&gt;&amp; data)
//  {
//..
// Since the amount of memory needed is known in advance, we can optimize the
// memory allocation by using a &#39;bdlma::BufferedSequentialAllocator&#39; to supply
// memory for the vectors.  We can also prevent the vectors from resizing
// (which triggers more allocations) by reserving for the specific capacity we
// need:
//..
//      enum { SIZE = 3 * 100 * sizeof(double) };
//..
// In the above calculation, we assume that the only memory allocation
// requested by the vector is the allocation for the array that stores the
// &#39;double&#39; values.  Furthermore, we assume that the &#39;reserve&#39; method allocates
// the exact amount of memory for the number of items specified (in this case,
// of type &#39;double&#39;).  Note that both of these assumptions are true for BDE&#39;s
// implementation of &#39;bsl::vector&#39;.
//
// To avoid alignment issues described in the &quot;Warning&quot; section (above), we
// create a &#39;bsls::AlignedBuffer&#39;:
//..
//      bsls::AlignedBuffer&lt;SIZE&gt; bufferStorage;
//
//      bdlma::BufferedSequentialAllocator alloc(bufferStorage.buffer(), SIZE);
//
//      bsl::vector&lt;double&gt; v1(&amp;alloc);     v1.reserve(100);
//      bsl::vector&lt;double&gt; v2(&amp;alloc);     v2.reserve(100);
//      bsl::vector&lt;double&gt; v3(&amp;alloc);     v3.reserve(100);
//
//      // ...
//  }
//..
// By making use of a &#39;bdlma::BufferedSequentialAllocator&#39;, *all* dynamic
// memory allocation is eliminated in the above example.
//
///Example 2: Using &#39;bdlma::BufferedSequentialAllocator&#39; with Fallback
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we are receiving updates for price quotes for a list of securities
// through the following function:
//..
//  void receivePriceQuotes(bsl::map&lt;bsl::string, double&gt; *updateMap);
//      // Load into the specified &#39;updateMap&#39; updates for price quotes for a
//      // list of securities.
//..
// Furthermore, suppose the number of securities we are interested in is
// limited.  We can then use a &#39;bdlma::BufferedSequentialAllocator&#39; to optimize
// memory allocation for the &#39;bsl::map&#39;.  We first create a buffer on the
// stack:
//..
//  enum {
//      NUM_SECURITIES = 100,
//
//      TREE_NODE_SIZE = sizeof(bsl::map&lt;bsl::string, double&gt;::value_type)
//                       + sizeof(void *) * 4,
//
//      AVERAGE_SECURITY_LENGTH = 5,
//
//      TOTAL_SIZE = NUM_SECURITIES *
//                   (TREE_NODE_SIZE + AVERAGE_SECURITY_LENGTH )
//  };
//
//  bsls::AlignedBuffer&lt;TOTAL_SIZE&gt; bufferStorage;
//..
// The calculation of the amount of memory needed is just an estimate, as we
// used the average security size instead of the maximum security size.  We
// also assume that a &#39;bsl::map&#39;s node size is roughly the size of 4 pointers.
//..
//  bdlma::BufferedSequentialAllocator bsa(bufferStorage.buffer(), TOTAL_SIZE);
//  bsl::map&lt;bsl::string, double&gt; updateMap(&amp;bsa);
//
//  receivePriceQuotes(&amp;updateMap);
//..
// With the use of a &#39;bdlma::BufferedSequentialAllocator&#39;, we can be reasonably
// assured that the memory allocation performance is optimized (i.e., minimal
// use of dynamic allocation).

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLMA_BUFFEREDSEQUENTIALPOOL
#include &lt;bdlma_bufferedsequentialpool.h&gt;
#endif

#ifndef INCLUDED_BDLMA_MANAGEDALLOCATOR
#include &lt;bdlma_managedallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENT
#include &lt;bsls_alignment.h&gt;
#endif

#ifndef INCLUDED_BSLS_BLOCKGROWTH
#include &lt;bsls_blockgrowth.h&gt;
#endif

namespace BloombergLP {
namespace bdlma {

                    // =================================
                    // class BufferedSequentialAllocator
                    // =================================

class BufferedSequentialAllocator : public ManagedAllocator {
    // This class implements the &#39;ManagedAllocator&#39; protocol to provide
    // a fast allocator that dispenses heterogeneous blocks of memory (of
    // varying, user-specified sizes) from an external buffer whose address and
    // size (in bytes) are supplied at construction.  If an allocation request
    // exceeds the remaining free memory space in the external buffer, memory
    // will be supplied by an (optional) allocator also supplied at
    // construction; if no allocator is supplied, the currently installed
    // default allocator is used.  This class is *exception* *neutral*: If
    // memory cannot be allocated, the behavior is defined by the (optional)
    // allocator supplied at construction.  Note that in no case will the
    // buffered sequential allocator attempt to deallocate the external buffer.

    // DATA
    BufferedSequentialPool d_pool;  // manager for allocated memory blocks

  private:
    // NOT IMPLEMENTED
    BufferedSequentialAllocator(const BufferedSequentialAllocator&amp;);
    BufferedSequentialAllocator&amp; operator=(const BufferedSequentialAllocator&amp;);

  public:
    // CREATORS
    BufferedSequentialAllocator(
                              char                        *buffer,
                              int                          size,
                              bslma::Allocator            *basicAllocator = 0);
    BufferedSequentialAllocator(
                              char                        *buffer,
                              int                          size,
                              bsls::BlockGrowth::Strategy  growthStrategy,
                              bslma::Allocator            *basicAllocator = 0);
    BufferedSequentialAllocator(
                              char                        *buffer,
                              int                          size,
                              bsls::Alignment::Strategy    alignmentStrategy,
                              bslma::Allocator            *basicAllocator = 0);
    BufferedSequentialAllocator(
                              char                        *buffer,
                              int                          size,
                              bsls::BlockGrowth::Strategy  growthStrategy,
                              bsls::Alignment::Strategy    alignmentStrategy,
                              bslma::Allocator            *basicAllocator = 0);
        // Create a buffered sequential allocator for allocating memory blocks
        // from the specified external &#39;buffer&#39; having the specified &#39;size&#39; (in
        // bytes).  Optionally specify a &#39;growthStrategy&#39; used to control
        // buffer growth.  If a &#39;growthStrategy&#39; is not specified, geometric
        // growth is used.  Optionally specify an &#39;alignmentStrategy&#39; used to
        // align allocated memory blocks.  If an &#39;alignmentStrategy&#39; is not
        // specified, natural alignment is used.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory should the capacity of
        // &#39;buffer&#39; be exhausted.  If &#39;basicAllocator&#39; is 0, the currently
        // installed default allocator is used.  The behavior is undefined
        // unless &#39;0 &lt; size&#39;, and &#39;buffer&#39; has at least &#39;size&#39; bytes.  Note
        // that, due to alignment effects, it is possible that not all &#39;size&#39;
        // bytes of memory in &#39;buffer&#39; can be used for allocation.  Also note
        // that no limit is imposed on the size of the internal buffers when
        // geometric growth is used.  Also note that when constant growth is
        // used, the size of the internal buffers will always be the same as
        // &#39;size&#39;.

    BufferedSequentialAllocator(
                              char                        *buffer,
                              int                          size,
                              int                          maxBufferSize,
                              bslma::Allocator            *basicAllocator = 0);
    BufferedSequentialAllocator(
                              char                        *buffer,
                              int                          size,
                              int                          maxBufferSize,
                              bsls::BlockGrowth::Strategy  growthStrategy,
                              bslma::Allocator            *basicAllocator = 0);
    BufferedSequentialAllocator(
                              char                        *buffer,
                              int                          size,
                              int                          maxBufferSize,
                              bsls::Alignment::Strategy    alignmentStrategy,
                              bslma::Allocator            *basicAllocator = 0);
    BufferedSequentialAllocator(
                              char                        *buffer,
                              int                          size,
                              int                          maxBufferSize,
                              bsls::BlockGrowth::Strategy  growthStrategy,
                              bsls::Alignment::Strategy    alignmentStrategy,
                              bslma::Allocator            *basicAllocator = 0);
        // Create a buffered sequential allocator for allocating memory blocks
        // from the specified external &#39;buffer&#39; having the specified &#39;size&#39; (in
        // bytes), or from an internal buffer (after the external &#39;buffer&#39; is
        // exhausted) where the buffer growth is limited to the specified
        // &#39;maxBufferSize&#39; (in bytes).  Optionally specify a &#39;growthStrategy&#39;
        // used to control buffer growth.  If a &#39;growthStrategy&#39; is not
        // specified, geometric growth is used.  Optionally specify an
        // &#39;alignmentStrategy&#39; used to align allocated memory blocks.  If an
        // &#39;alignmentStrategy&#39; is not specified, natural alignment is used.
        // Optionally specify a &#39;basicAllocator&#39; used to supply memory should
        // the capacity of &#39;buffer&#39; be exhausted.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.  The behavior is
        // undefined unless &#39;0 &lt; size&#39;, &#39;size &lt;= maxBufferSize&#39;, and &#39;buffer&#39;
        // has at least &#39;size&#39; bytes.  Note that, due to alignment effects, it
        // is possible that not all &#39;size&#39; bytes of memory in &#39;buffer&#39; can be
        // used for allocation.  Also note that when constant growth is used,
        // the size of the internal buffers will always be the same as &#39;size&#39;.

    virtual ~BufferedSequentialAllocator();
        // Destroy this buffered sequential allocator.  All memory allocated
        // from this allocator is released.

    // MANIPULATORS
    virtual void *allocate(size_type size);
        // Return the address of a contiguous block of memory of the specified
        // &#39;size&#39; (in bytes) according to the alignment strategy specified at
        // construction.  If &#39;size&#39; is 0, no memory is allocated and 0 is
        // returned.  If the allocation request exceeds the remaining free
        // memory space in the external buffer supplied at construction, use
        // memory obtained from the allocator supplied at construction.

    virtual void deallocate(void *address);
        // This method has no effect on the memory block at the specified
        // &#39;address&#39; as all memory allocated by this allocator is managed.  The
        // behavior is undefined unless &#39;address&#39; is 0, or was allocated by
        // this allocator and has not already been deallocated.

    virtual void release();
        // Release all memory currently allocated through this allocator.  This
        // method deallocates all memory (if any) allocated with the allocator
        // provided at construction, and makes the memory from the entire
        // external buffer supplied at construction available for subsequent
        // allocations, but has no effect on the contents of the buffer.  Note
        // that this allocator is reset to its initial state by this method.
};

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

                    // ---------------------------------
                    // class BufferedSequentialAllocator
                    // ---------------------------------

// CREATORS
inline
BufferedSequentialAllocator::BufferedSequentialAllocator(
                                              char             *buffer,
                                              int               size,
                                              bslma::Allocator *basicAllocator)
: d_pool(buffer, size, basicAllocator)
{
}

inline
BufferedSequentialAllocator::BufferedSequentialAllocator(
                                   char                        *buffer,
                                   int                          size,
                                   bsls::BlockGrowth::Strategy  growthStrategy,
                                   bslma::Allocator            *basicAllocator)
: d_pool(buffer, size, growthStrategy, basicAllocator)
{
}

inline
BufferedSequentialAllocator::BufferedSequentialAllocator(
                                  char                      *buffer,
                                  int                        size,
                                  bsls::Alignment::Strategy  alignmentStrategy,
                                  bslma::Allocator          *basicAllocator)
: d_pool(buffer, size, alignmentStrategy, basicAllocator)
{
}

inline
BufferedSequentialAllocator::BufferedSequentialAllocator(
                                char                        *buffer,
                                int                          size,
                                bsls::BlockGrowth::Strategy  growthStrategy,
                                bsls::Alignment::Strategy    alignmentStrategy,
                                bslma::Allocator            *basicAllocator)
: d_pool(buffer, size, growthStrategy, alignmentStrategy, basicAllocator)
{
}

inline
BufferedSequentialAllocator::BufferedSequentialAllocator(
                                              char             *buffer,
                                              int               size,
                                              int               maxBufferSize,
                                              bslma::Allocator *basicAllocator)
: d_pool(buffer, size, maxBufferSize, basicAllocator)
{
}

inline
BufferedSequentialAllocator::BufferedSequentialAllocator(
                                   char                        *buffer,
                                   int                          size,
                                   int                          maxBufferSize,
                                   bsls::BlockGrowth::Strategy  growthStrategy,
                                   bslma::Allocator            *basicAllocator)
: d_pool(buffer, size, maxBufferSize, growthStrategy, basicAllocator)
{
}

inline
BufferedSequentialAllocator::BufferedSequentialAllocator(
                                  char                      *buffer,
                                  int                        size,
                                  int                        maxBufferSize,
                                  bsls::Alignment::Strategy  alignmentStrategy,
                                  bslma::Allocator          *basicAllocator)
: d_pool(buffer, size, maxBufferSize, alignmentStrategy, basicAllocator)
{
}

inline
BufferedSequentialAllocator::BufferedSequentialAllocator(
                                char                        *buffer,
                                int                          size,
                                int                          maxBufferSize,
                                bsls::BlockGrowth::Strategy  growthStrategy,
                                bsls::Alignment::Strategy    alignmentStrategy,
                                bslma::Allocator            *basicAllocator)
: d_pool(buffer,
         size,
         maxBufferSize,
         growthStrategy,
         alignmentStrategy,
         basicAllocator)
{
}

// MANIPULATORS
inline
void BufferedSequentialAllocator::deallocate(void *)
{
}

inline
void BufferedSequentialAllocator::release()
{
    d_pool.release();
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2012 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
