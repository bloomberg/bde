<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlsb_overflowmemoutstreambuf.h                                    -*-C++-*-
#ifndef INCLUDED_BDLSB_OVERFLOWMEMOUTSTREAMBUF
#define INCLUDED_BDLSB_OVERFLOWMEMOUTSTREAMBUF

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an overflowable output &#39;streambuf&#39; using a client buffer.
//
//@CLASSES:
//  bdlsb::OverflowMemOutStreamBuf: overflowable output &#39;bsl::streambuf&#39;
//
//@SEE_ALSO: bdlsb_overflowmemoutput
//
//@DESCRIPTION: This component implements the output portion of the
// &#39;bsl::basic_streambuf&#39; protocol using a user-supplied initial buffer and a
// dynamically allocated overflow buffer.  As with &#39;bdlsb_fixedmemoutput&#39;,
// users supply the character buffer at construction.  Unlike
// &#39;bdlsb_fixedmemoutput&#39;, they can no longer reinitialize the stream buffer
// with a different character buffer by calling the &#39;pubsetbuf&#39; method;
// instead, if that buffer runs out, the &#39;bdlsb::OverflowMemOutStreamBuf&#39; will
// allocate another buffer (see &quot;Overflow Buffer&quot; below).   The only difference
// between this component and &#39;bdlsb_overflowmemoutput&#39; is that the class
// &#39;bdlsb::OverflowMemOutStreamBuf&#39; is derived from a &#39;bsl::streambuf&#39;.  Method
// names necessarily correspond to those specified by the protocol.  Refer to
// the C++ Standard, Section 27.5.2, for a full specification of the
// &#39;bsl::basic_streambuf&#39; interface.  This component provides none of the
// input-related functionality of &#39;basic_streambuf&#39; (see Streaming
// Architecture, below), nor does it use locales in any way.
//
///Overflow Buffer
///---------------
// This output stream buffer will use the initial buffer (supplied at
// construction) as its output buffer.  If an overflow of the initial buffer
// were to occur, an additional buffer (the overflow buffer) will be allocated.
// If this overflow buffer ever becomes full, it will be automatically grown.
// The overflow buffer grows geometrically (to twice the current overflow
// buffer size) whenever the amount of data written exceeds the amount of space
// available.  On growth, the old overflow buffer is copied over to the newly
// allocated overflow buffer, and then deallocated, thus after any write/seek
// forward one cannot assume that the overflow buffer is still the same memory.
// Data in the overflow buffer beyond the reach of the current write position
// is not guaranteed to be preserved after a growth operation.
//
///Streaming Architecture
///----------------------
// Stream buffers are designed to decouple device handling from content
// formatting, providing the requisite device handling and possible buffering
// services, and leaving the formatting to the client stream.  The standard
// C++ IOStreams library further partitions streaming into input streaming and
// output streaming, separating responsibilities for each at both the stream
// layer and the stream buffer layer.  The BDE streaming library for &#39;bdex&#39;,
// including all of &#39;bdlsb&#39;, follows this model.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
/// Example 1: Basic Use of &#39;bdlsb::OverflowMemOutStreamBuf&#39;
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// This example demonstrates using a &#39;bdlsb::OverflowMemOutStreamBuf&#39; in order
// to test a user defined stream type, &#39;CapitalizingStream&#39;. In this example,
// we&#39;ll define a simple example stream type &#39;CapitalizingStream&#39; that
// capitalizes lower-case ASCII data written to the stream. In order to test
// this &#39;CapitalizingStream&#39; type, we&#39;ll create an instance, and supply it a
// &#39;bdlsb::OverflowMemOutStreamBuf&#39; object as its stream buffer; after we write
// some character data to the &#39;CapitalizingStream&#39; we&#39;ll inspect the buffer of
// the &#39;bdlsb::OverflowMemOutStreamBuf&#39; and verify its contents match our
// expected output. Note that to simplify the example, we do not include the
// functions for streaming non-character data, e.g., numeric values.
//
// First, we define our example stream class, &#39;CapitalizingStream&#39; (which we
// will later test using &#39;bdlsb::OverflowMemOutStreamBuf):
//..
//  class CapitalizingStream {
//      // This class capitalizes lower-case ASCII characters that are output.
//
//      // DATA
//      bsl::streambuf  *d_streamBuffer_p;   // pointer to a stream buffer
//
//      // FRIENDS
//      friend CapitalizingStream&amp; operator&lt;&lt;(CapitalizingStream&amp;  stream,
//                                            const char          *data);
//    public:
//      // CREATORS
//      explicit CapitalizingStream(bsl::streambuf *streamBuffer);
//          // Create a capitalizing stream using the specified &#39;streamBuffer&#39;
//          // as the underlying stream buffer for the stream.
//  };
//
//  // FREE OPERATORS
//  CapitalizingStream&amp; operator&lt;&lt;(CapitalizingStream&amp;  stream,
//                                 const char          *data);
//      // Write the specified &#39;data&#39; in capitalized form to the specified
//      // &#39;stream&#39;.
//
//  CapitalizingStream::CapitalizingStream(bsl::streambuf *streamBuffer)
//  : d_streamBuffer_p(streamBuffer)
//  {
//  }
//..
// As is typical, the streaming operators are made friends of the class.
//
// Note that we cannot directly use &#39;bsl::toupper&#39; to capitalize each
// individual character, because &#39;bsl::toupper&#39; operates on &#39;int&#39; instead of
// &#39;char&#39;.  Instead, we call a function &#39;ucharToUpper&#39; that works in terms of
// &#39;unsigned char&#39;.  some care must be made to avoid undefined and
// implementation-specific behavior during the conversions to and from &#39;int&#39;.
// Therefore we wrap &#39;bsl::toupper&#39; in an interface that works in terms of
// &#39;unsigned char&#39;:
//..
//  static unsigned char ucharToUpper(unsigned char input)
//      // Return the upper-case equivalent to the specified &#39;input&#39; character.
//  {
//      return bsl::toupper(input);
//  }
//..
// Finally, we use the &#39;transform&#39; algorithm to convert lower-case characters
// to upper-case.
//..
//  // FREE OPERATORS
//  CapitalizingStream&amp; operator&lt;&lt;(CapitalizingStream&amp;  stream,
//                                 const char          *data)
//  {
//      bsl::string tmp(data);
//      bsl::transform(tmp.begin(),
//                     tmp.end(),
//                     tmp.begin(),
//                     ucharToUpper);
//      stream.d_streamBuffer_p-&gt;sputn(tmp.data(), tmp.length());
//      return stream;
//  }
//..
// Now, we create an instance of &#39;bdlsb::OverflowMemOutStreamBuf&#39; that will
// serve as underlying stream buffer for our &#39;CapitalingStream&#39;:
//..
//  enum { INITIAL_CAPACITY = 10 };
//  char buffer[INITIAL_CAPACITY];
//
//  bdlsb::OverflowMemOutStreamBuf streamBuffer(buffer, INITIAL_CAPACITY);
//..
// Now, we test our &#39;CapitalingStream&#39; by supplying the created instance of
// &#39;bdlsb::OverflowMemOutStreamBuf&#39; and using it to inspect the output of the
// stream:
//..
//  CapitalizingStream  testStream(&amp;streamBuffer);
//  testStream &lt;&lt; &quot;Hello world.&quot;;
//..
// Finally, we verify that the streamed data has been capitalized and the
// portion of the data that does not fit into initial buffer is placed into
// dynamically allocated overflow buffer:
//..
//  assert(10 == streamBuffer.dataLengthInInitialBuffer());
//  assert(0  == strncmp(&quot;HELLO WORL&quot;,
//                       streamBuffer.initialBuffer(),
//                       streamBuffer.dataLengthInInitialBuffer()));
//  assert(2  == streamBuffer.dataLengthInOverflowBuffer());
//  assert(0  == strncmp(&quot;D.&quot;,
//                       streamBuffer.overflowBuffer(),
//                       streamBuffer.dataLengthInOverflowBuffer()));
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDDEF
#include &lt;bsl_cstddef.h&gt;
#endif

#ifndef INCLUDED_BSL_IOS
#include &lt;bsl_ios.h&gt;
#endif

#ifndef INCLUDED_BSL_STREAMBUF
#include &lt;bsl_streambuf.h&gt;
#endif

namespace BloombergLP {
namespace bdlsb {

                   // =============================
                   // class OverflowMemOutStreamBuf
                   // =============================

class OverflowMemOutStreamBuf : public bsl::streambuf {
    // This class implements the output functionality of the
    // &#39;bsl::basic_streambuf&#39; protocol, using client-supplied memory and
    // client-supplied allocator if additional memory is needed.

    // DATA
    // The order of the data members is determined by our usage pattern for
    // cache efficiency.  Do not reorder them.
    //
    // &#39;d_dataLength&#39; is marked &#39;mutable&#39; because it is used to cache the
    // length of the data written to the stream buffer.  Characters can be
    // written to the buffer via the base class (without calling a manipulator
    // on this class), so this cached value is updated when accessors are
    // called.

    mutable bsl::size_t  d_dataLength;            // total data length

    char                *d_initialBuffer_p;       // user-supplied buffer
                                                  // (held, not owned)

    bsl::size_t          d_initialBufferSize;     // size of initial buffer

    bool                 d_inOverflowBufferFlag;  // true if &#39;pptr&#39; points into
                                                  // the overflow buffer

    char                *d_overflowBuffer_p;      // overflow buffer (owned)

    bsl::size_t          d_overflowBufferSize;    // size of overflow buffer

    bslma::Allocator    *d_allocator_p;           // memory allocator (held,
                                                  // not owned)

    // NOT IMPLEMENTED
    OverflowMemOutStreamBuf(const OverflowMemOutStreamBuf&amp;);
    OverflowMemOutStreamBuf&amp; operator=(const OverflowMemOutStreamBuf&amp;);

  private:
    // PRIVATE MANIPULATORS
    void grow(bsl::size_t numBytes);
        // Replace the overflow buffer with another buffer larger by at least
        // the specified &#39;numBytes&#39;, by growing geometrically by a factor of
        // two, and preserve the bytes that are in use by the overflow buffer,
        // as determined by the &#39;d_dataLength&#39;.  Note that &#39;pptr()&#39; is not
        // updated at this time, and may be pointing to deallocated memory when
        // this returns.  Also note, that because &#39;d_dataLength&#39; is used to
        // determine the amount of data in the buffer, this function should be
        // called after &#39;privateSync&#39;.

    void privateSync() const;
        // Set &#39;d_dataLength&#39; to the amount of data that has been written to
        // this stream buffer, from the beginning of the stream to the current
        // &#39;pptr()&#39; position.  Note that if &#39;pptr()&#39; points into the overflow
        // buffer, this size the initial buffer, plus the portion of the
        // overflow buffer that has been written to.

  protected:
    // PROTECTED VIRTUAL FUNCTIONS

           // *** 27.5.2.4.2 buffer management and positioning ***
    virtual pos_type seekoff(
       off_type                offset,
       bsl::ios_base::seekdir  way,
       bsl::ios_base::openmode which = bsl::ios_base::in | bsl::ios_base::out);
        // Set the position indicator to the relative specified &#39;offset&#39; from
        // the base position indicated by the specified &#39;way&#39; and return the
        // resulting absolute position on success or pos_type(-1) on failure.
        // Optionally specify &#39;which&#39; area of the stream buffer.  The seek
        // operation will fail if &#39;which&#39; does not include the flag
        // &#39;bsl::ios_base::out&#39; or if the resulting absolute position is
        // negative.

    virtual pos_type seekpos(
       pos_type                position,
       bsl::ios_base::openmode which = bsl::ios_base::in | bsl::ios_base::out);
        // Set the position indicator to the specified &#39;position&#39; and return
        // the resulting absolute position on success or pos_type(-1) on
        // failure.  Optionally specify &#39;which&#39; area of the stream buffer.  The
        // &#39;seekpos&#39; operation will fail if &#39;which&#39; does not include the flag
        // &#39;bsl::ios_base::out&#39; or if &#39;position&#39; is negative.

    virtual int sync();
        // Set &#39;d_dataLength&#39; to the amount of data that has been written to
        // this stream buffer, from the beginning of the stream to the current
        // &#39;pptr()&#39; position and return 0.  Note that if &#39;pptr()&#39; points into
        // the overflow buffer, this size the initial buffer, plus the portion
        // of the overflow buffer that has been written to.

    virtual bsl::streamsize xsputn(const char_type *source,
                                   bsl::streamsize  numChars);
        // Write the specified &#39;numChars&#39; characters from the specified
        // &#39;source&#39; to the stream buffer.  Return the number of characters
        // successfully written.  The behavior is undefined unless &#39;(source &amp;&amp;
        // 0 &lt; numChars) || 0 == numChars&#39;.

    virtual int_type overflow(int_type c = bsl::streambuf::traits_type::eof());
        // If c is not &#39;EOF&#39;, adjust the underlying buffer so that the next put
        // position is valid, put the specified &#39;c&#39; at this position, and
        // increment the put position.  Return &#39;c&#39; on success, and
        // &#39;traits_type::not_eof(c)&#39; if &#39;c&#39; is &#39;EOF&#39;.

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(OverflowMemOutStreamBuf,
                                   bslma::UsesBslmaAllocator);

    // CREATORS
    OverflowMemOutStreamBuf(char             *buffer,
                            bsl::size_t       size,
                            bslma::Allocator *basicAllocator = 0);
        // Create an empty stream buffer that uses the specified &#39;buffer&#39; as an
        // initial output buffer of the specified &#39;size&#39; (in bytes).
        // Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently-installed default allocator is
        // used.  The behavior is undefined unless &#39;buffer&#39; points to a valid
        // sequence of positive &#39;size&#39; characters.  Note that this stream
        // buffer does not assume ownership of &#39;buffer&#39;.

    virtual ~OverflowMemOutStreamBuf();
        // Destroy this stream buffer.

    // ACCESSORS
    bsl::size_t dataLength() const;
        // Return the number of bytes written to this stream.  Note that if
        // &#39;pptr()&#39; is currently pointing into the overflow buffer the data
        // length will be greater than the size of the initial buffer.

    bsl::size_t dataLengthInInitialBuffer() const;
        // Return the length of data in the initial buffer, i.e.,
        // &#39;dataLength()&#39; if there is no overflow buffer, or
        // &#39;initialBufferSize()&#39; if there is one.

    bsl::size_t dataLengthInOverflowBuffer() const;
        // Return the length of the data in the overflow buffer, i.e., 0 if
        // there is no overflow buffer, or &#39;dataLength() - initialBufferSize()&#39;
        // if there is one.

    const char *initialBuffer() const;
        // Return a pointer to the non-modifiable buffer supplied at
        // construction.

    bsl::size_t initialBufferSize() const;
        // Return the size of the buffer supplied at construction.

    const char *overflowBuffer() const;
        // Return a pointer to the non-modifiable overflow buffer if there is
        // one, or 0 otherwise.

    bsl::size_t overflowBufferSize() const;
        // Return the size of the overflow buffer, or 0 if there is no overflow
        // buffer.
};

// ============================================================================
//                          INLINE DEFINITIONS
// ============================================================================

                    // -----------------------------
                    // class OverflowMemOutStreamBuf
                    // -----------------------------

// PROTECTED VIRTUAL FUNCTIONS
inline
OverflowMemOutStreamBuf::pos_type
OverflowMemOutStreamBuf::seekpos(pos_type                position,
                                 bsl::ios_base::openmode which)
{
    return seekoff(off_type(position), bsl::ios_base::beg, which);
}

inline
int OverflowMemOutStreamBuf::sync()
{
    privateSync();
    return 0;
}

// CREATORS
inline
OverflowMemOutStreamBuf::~OverflowMemOutStreamBuf()
{
    d_allocator_p-&gt;deallocate(d_overflowBuffer_p);
}

// ACCESSORS
inline
bsl::size_t OverflowMemOutStreamBuf::dataLength() const
{
    privateSync();
    return d_dataLength;
}

inline
bsl::size_t OverflowMemOutStreamBuf::dataLengthInInitialBuffer() const
{
    privateSync();
    return d_inOverflowBufferFlag ? d_initialBufferSize : d_dataLength;
}

inline
bsl::size_t OverflowMemOutStreamBuf::dataLengthInOverflowBuffer() const
{
    privateSync();
    return d_inOverflowBufferFlag ? d_dataLength - d_initialBufferSize : 0;
}

inline
const char *OverflowMemOutStreamBuf::initialBuffer() const
{
    return d_initialBuffer_p;
}

inline
bsl::size_t OverflowMemOutStreamBuf::initialBufferSize() const
{
    return d_initialBufferSize;
}

inline
const char *OverflowMemOutStreamBuf::overflowBuffer() const
{
    return d_overflowBuffer_p;
}

inline
bsl::size_t OverflowMemOutStreamBuf::overflowBufferSize() const
{
    return d_overflowBufferSize;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
