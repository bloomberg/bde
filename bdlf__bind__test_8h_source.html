<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlf_bind_test.h                                                   -*-C++-*-
#ifndef INCLUDED_BDLF_BIND_TEST
#define INCLUDED_BDLF_BIND_TEST

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a test apparatus for bdlf_bind.
//
//@CLASSES:
//             bdlf::Bind_TestUtil: utility class for static test methods
//        bdlf::Bind_TestSlotsBase: base class for tracking arg &amp; alloc objects
//       bdlf::Bind_TestArgNoAlloc: argument type parameterized by index
//      bdlf::Bind_TestTypeNoAlloc: invocable supporting up to 14 arguments
// bdlf::Bind_TestFunctionsNoAlloc: global versions of test type methods
//         bdlf::Bind_TestArgAlloc: argument type parameterized by index
//        bdlf::Bind_TestTypeAlloc: invocable supporting up to 14 arguments
//   bdlf::Bind_TestFunctionsAlloc: global versions of test type methods
//
//@SEE_ALSO: bdlf_bind bdlf_bind_test[0--14]
//
//@DESCRIPTION: This component provides a test apparatus for testing the
// &#39;bdlf_bind&#39; component.  This apparatus would usually be part of the test
// driver of that component, but is factored out in this component since the
// &#39;bdlf_bind&#39; test driver is so large and induces such long compilation times
// that the testing has been delegated to many components
// &#39;bdlf_bind_test[0-14]&#39; whose sole purpose is to share the testing
// &#39;bdlf_bind&#39;.  Thus this component provides all the common apparatus for
// these delegate components.
//
// This apparatus comprises test classes for tracking argument values and
// allocators, using a slot mechanism.  In the case of a test class that does
// *not* take allocators, the slot at any index contains an integer which
// tracks the value of the argument with same index that was passed to the test
// type invocation.  In the case of a test class that *does* take allocators,
// the slot at any index contains the address of the allocator used to allocate
// the value of the argument with same index that was passed to the test type
// invocation.
//
// The two test types provided, &#39;bdlf::Bind_TestTypeNoAlloc&#39; and
// &#39;bdlf::Bind_TestTypeAlloc&#39; support this slot mechanism.  They are invocable
// with up to 14 parameters, either as function objects (using &#39;operator()&#39;),
// via member functions (using the &#39;testFunc[0--14]&#39; methods), or via global
// functions that take a pointer to the object as first argument (provided as
// static methods of the utility classes &#39;bdlf::Bind_TestFunctionsNoAlloc&#39; and
// &#39;bdlf::Bind_TestFunctionsAlloc&#39;), thus supporting all protocols for binding
// an invocable in the &#39;bdlf_bind&#39; component.  Additional classes
// &#39;bdlf::Bind_TestSlots&#39;, &#39;bdlf::Bind_TestArgNoAlloc&#39;, and
// &#39;bdlf::Bind_TestArgAlloc&#39; augment the test apparatus.
//
///Usage
///-----
// The following shows how to use the test apparatus to test the &#39;bdlf::Bind&#39;
// constructors, i.e., to explicitly construct &#39;bdlf::Bind&#39; objects (as opposed
// to using the factory method &#39;bdlf::BindUtil::bind&#39;) and exercise them to
// ascertain that they work as expected.  For more examples of use, see the
// test drivers &#39;bdlf_bind_test[0--14]&#39; themselves.
//
///Testing &#39;bdlf::Bind&#39; *Without* Allocators
///- - - - - - - - - - - - - - - - - - - - -
// In this test code, we bind a &#39;bdlf::Bind_TestTypeNoAlloc&#39; invocable by a
// &#39;bdlf::Bind&#39; object constructed with and without placeholders.
//..
//  void usageExampleNoAlloc(int veryVeryVerbose)
//  {
//      bslma::TestAllocator          allocator0(veryVeryVerbose);
//      bslma::TestAllocator         *Z0 = &amp;allocator0;
//      bslma::DefaultAllocatorGuard  allocGuard(Z0);
//
//      const int                         N1 = -1;
//      const bdlf::Bind_TestArgNoAlloc&lt;1&gt; I1 = 1;
//
//      // 1 argument to function object, without placeholders.
//      {
//          const int NUM_ALLOCS = Z0-&gt;numAllocations();
//
//                bdlf::Bind_TestTypeNoAlloc  mX;
//          const bdlf::Bind_TestTypeNoAlloc&amp; X = mX;
//
//          const bdlf::Bind_TestTypeNoAlloc EXPECTED_X(I1);
//          const bdlf::Bind_TestTypeNoAlloc DEFAULT_X(N1);
//          assert(EXPECTED_X != X);
//          assert(DEFAULT_X  == X);
//
//          // For passing to the constructor of &#39;bdlf::Bind&#39;.
//
//          typedef bdlf::Bind_TestTypeNoAlloc *FUNC;
//          typedef bdlf::Bind_Tuple1&lt;bdlf::Bind_TestArgNoAlloc&lt;1&gt; &gt; ListType;
//          typedef bdlf::Bind&lt;bslmf::Nil, FUNC, ListType&gt; Bind;
//
//                ListType  mL(I1);     // list of arguments
//          const ListType&amp; L = mL;     // non-modifiable list of arguments
//
//                ListType  mM(N1);     // list of arguments
//          const ListType&amp; M = mM;     // non-modifiable list of arguments
//
//          // Testing &#39;bdlf::Bind&#39; objects constructed explicitly.
//
//                Bind  mB1(&amp;mX, L);
//          const Bind&amp; B1 = mB1;
//          assert(EXPECTED_X != X);
//          assert(1 == mB1());
//          assert(EXPECTED_X == X);
//
//                Bind  mB2(&amp;mX, M, Z0);
//          const Bind&amp; B2 = mB2;
//          assert(DEFAULT_X != X);
//          assert(1 == mB2());
//          assert(DEFAULT_X == X);
//
//          Bind mB3(B1);
//          assert(EXPECTED_X != X);
//          assert(1 == mB3());
//          assert(EXPECTED_X == X);
//
//          Bind mB4(B2, Z0);
//          assert(DEFAULT_X != X);
//          assert(1 == mB4());
//          assert(DEFAULT_X == X);
//
//          assert(NUM_ALLOCS == Z0-&gt;numAllocations());
//      }
//
//      // 1 argument to function object, *with* placeholders.
//      {
//          using namespace bdlf::PlaceHolders;
//
//          const int NUM_ALLOCS = Z0-&gt;numAllocations();
//
//                bdlf::Bind_TestTypeNoAlloc  mX;
//          const bdlf::Bind_TestTypeNoAlloc&amp; X = mX;
//
//          const bdlf::Bind_TestTypeNoAlloc EXPECTED_X(I1);
//          const bdlf::Bind_TestTypeNoAlloc DEFAULT_X(N1);
//          assert(EXPECTED_X != X);
//          assert(DEFAULT_X  == X);
//
//          // For passing to the constructor of &#39;bdlf::Bind&#39;.
//
//          typedef bdlf::Bind_TestTypeNoAlloc *FUNC;
//          typedef bdlf::Bind_Tuple1&lt;PH1&gt; ListType;
//          typedef bdlf::Bind&lt;bslmf::Nil, FUNC, ListType&gt; Bind;
//
//                ListType  mL(_1);     // list of arguments
//          const ListType&amp; L = mL;     // non-modifiable list of arguments
//
//                Bind  mB1(&amp;mX, L);
//          const Bind&amp; B1 = mB1;
//          assert(EXPECTED_X != X);
//          assert(1 == mB1(I1));
//          assert(EXPECTED_X == X);
//
//                Bind  mB2(&amp;mX, L, Z0);
//          const Bind&amp; B2 = mB2;
//          assert(DEFAULT_X != X);
//          assert(1 == mB2(N1));
//          assert(DEFAULT_X == X);
//
//          Bind mB3(B1);
//          assert(EXPECTED_X != X);
//          assert(1 == mB3(I1));
//          assert(EXPECTED_X == X);
//
//          Bind mB4(B2, Z0);
//          assert(DEFAULT_X != X);
//          assert(1 == mB4(N1));
//          assert(DEFAULT_X == X);
//
//          assert(NUM_ALLOCS == Z0-&gt;numAllocations());
//      }
//  }
//..
//
///Testing &#39;bdlf_bind&#39; *With* Allocators
///- - - - - - - - - - - - - - - - - - -
// In this test code, we bind a &#39;bdlf::Bind_TestTypeAlloc&#39; invocable using a
// &#39;bdlf::Bind&#39; object constructed with and without placeholders.
//..
//  void usageExampleAlloc(int veryVeryVerbose)
//  {
//      bslma::TestAllocator  allocator0(veryVeryVerbose);
//      bslma::TestAllocator  allocator1(veryVeryVerbose);
//      bslma::TestAllocator  allocator2(veryVeryVerbose);
//
//      bslma::TestAllocator *Z0 = &amp;allocator0;
//      bslma::TestAllocator *Z1 = &amp;allocator1;
//      bslma::TestAllocator *Z2 = &amp;allocator2;
//
//      bslma::DefaultAllocatorGuard allocGuard(Z0);
//
//      const bdlf::Bind_TestArgAlloc&lt;1&gt; NV1 = -1;
//      const bdlf::Bind_TestArgAlloc&lt;1&gt;  V1 =  1;
//
//      // 1 argument to function object, *without* placeholders.
//      {
//                bdlf::Bind_TestTypeAlloc  mX(Z1);
//          const bdlf::Bind_TestTypeAlloc&amp; X = mX;
//
//          const bdlf::Bind_TestTypeAlloc EXPECTED_X(Z1, V1);
//          const bdlf::Bind_TestTypeAlloc DEFAULT_X(Z1, NV1);
//          assert(EXPECTED_X != X);
//          assert(DEFAULT_X  == X);
//
//          typedef bdlf::Bind_TestTypeAlloc *FUNC;
//          typedef bdlf::Bind_Tuple1&lt;bdlf::Bind_TestArgAlloc&lt;1&gt; &gt; ListType;
//          typedef bdlf::Bind&lt;bslmf::Nil, FUNC, ListType&gt; Bind;
//
//          // For passing to the constructor of &#39;bdlf::Bind&#39;.
//
//                ListType  mL(V1);  // list of arguments
//          const ListType&amp; L = mL;  // non-modifiable list of arguments
//
//                ListType  mM(NV1); // list of arguments
//          const ListType&amp; M = mM;  // non-modifiable list of arguments
//
//                Bind  mB1(&amp;mX, L);
//          const Bind&amp; B1 = mB1;
//          assert(EXPECTED_X != X);
//          assert(1 == mB1());
//          assert(EXPECTED_X == X);
//
//                Bind  mB2(&amp;mX, M, Z2);
//          const Bind&amp; B2 = mB2;
//          assert(DEFAULT_X != X);
//          assert(1 == mB2());
//          assert(DEFAULT_X == X);
//
//          Bind mB3(B1);
//          assert(EXPECTED_X != X);
//          assert(1 == mB3());
//          assert(EXPECTED_X == X);
//
//          Bind mB4(B2, Z2);
//          assert(DEFAULT_X != X);
//          assert(1 == mB4());
//          assert(DEFAULT_X == X);
//      }
//
//      // 1 argument to function object, *with* placeholders.
//      {
//          using namespace bdlf::PlaceHolders;
//
//                bdlf::Bind_TestTypeAlloc  mX(Z1);
//          const bdlf::Bind_TestTypeAlloc&amp; X = mX;
//
//          const bdlf::Bind_TestTypeAlloc EXPECTED_X(Z1, V1);
//          const bdlf::Bind_TestTypeAlloc DEFAULT_X(Z1, NV1);
//          assert(EXPECTED_X != X);
//          assert(DEFAULT_X  == X);
//
//          typedef bdlf::Bind_TestTypeAlloc *FUNC;
//          typedef bdlf::Bind_Tuple1&lt;PH1&gt; ListType;
//          typedef bdlf::Bind&lt;bslmf::Nil, FUNC, ListType&gt; Bind;
//
//          // For passing to the constructor of &#39;bdlf::Bind&#39;.
//
//                ListType  mL(_1);  // list of arguments
//          const ListType&amp; L = mL;  // non-modifiable list of arguments
//
//                Bind  mB1(&amp;mX, L);
//          const Bind&amp; B1 = mB1;
//          assert(EXPECTED_X != X);
//          assert(1 == mB1(V1));
//          assert(EXPECTED_X == X);
//
//                Bind  mB2(&amp;mX, L, Z2);
//          const Bind&amp; B2 = mB2;
//          assert(DEFAULT_X != X);
//          assert(1 == mB2(NV1));
//          assert(DEFAULT_X == X);
//
//          Bind mB3(B1);
//          assert(EXPECTED_X != X);
//          assert(1 == mB3(V1));
//          assert(EXPECTED_X == X);
//
//          Bind mB4(B2, Z2);
//          assert(DEFAULT_X != X);
//          assert(1 == mB4(NV1));
//          assert(DEFAULT_X == X);
//      }
//  }
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDIO
#include &lt;bsl_cstdio.h&gt;
#endif

// ============================================================================
//                MACROS FOR MULTIPLE ARGUMENT EXPANSION
// ============================================================================

// Numbered items separated by given separator

#define S1(F,S)             F(1)
#define S2(F,S)  S1(F,S)  S F(2)
#define S3(F,S)  S2(F,S)  S F(3)
#define S4(F,S)  S3(F,S)  S F(4)
#define S5(F,S)  S4(F,S)  S F(5)
#define S6(F,S)  S5(F,S)  S F(6)
#define S7(F,S)  S6(F,S)  S F(7)
#define S8(F,S)  S7(F,S)  S F(8)
#define S9(F,S)  S8(F,S)  S F(9)
#define S10(F,S) S9(F,S)  S F(10)
#define S11(F,S) S10(F,S) S F(11)
#define S12(F,S) S11(F,S) S F(12)
#define S13(F,S) S12(F,S) S F(13)
#define S14(F,S) S13(F,S) S F(14)

// Comma-separated numbered items

#define C1(F)          F(1)
#define C2(F)  C1(F),  F(2)
#define C3(F)  C2(F),  F(3)
#define C4(F)  C3(F),  F(4)
#define C5(F)  C4(F),  F(5)
#define C6(F)  C5(F),  F(6)
#define C7(F)  C6(F),  F(7)
#define C8(F)  C7(F),  F(8)
#define C9(F)  C8(F),  F(9)
#define C10(F) C9(F),  F(10)
#define C11(F) C10(F), F(11)
#define C12(F) C11(F), F(12)
#define C13(F) C12(F), F(13)
#define C14(F) C13(F), F(14)

// Space-separated numbered items

#define L1(F)         F(1)
#define L2(F)  L1(F)  F(2)
#define L3(F)  L2(F)  F(3)
#define L4(F)  L3(F)  F(4)
#define L5(F)  L4(F)  F(5)
#define L6(F)  L5(F)  F(6)
#define L7(F)  L6(F)  F(7)
#define L8(F)  L7(F)  F(8)
#define L9(F)  L8(F)  F(9)
#define L10(F) L9(F)  F(10)
#define L11(F) L10(F) F(11)
#define L12(F) L11(F) F(12)
#define L13(F) L12(F) F(13)
#define L14(F) L13(F) F(14)

#define P(n) Arg##n const&amp; a##n
#define V(n) Arg##n a##n
#define A(n) a##n

namespace BloombergLP {

namespace bdlf {
                      // ===================
                      // class Bind_TestUtil
                      // ===================

struct Bind_TestUtil {
    // Utility class for static functions useful in &#39;bdlf_bind&#39; testing.

    template &lt;class T&gt;
    static bool isBitwiseMoveableType(const T&amp;);
        // Return true if the specified paramter type &#39;T&#39; has the
        // &#39;bslmf::IsBitwiseMovable&#39; trait and false otherwise.
};


                      // ====================
                      // class Bind_TestSlots
                      // ====================

template &lt;class VALUE&gt;
struct Bind_TestSlotsBase {
    // This &#39;struct&#39; defines an array of &#39;VALUE&#39; to keep track (in conjunction
    // with the &#39;Bind_TestTypeNoAlloc&#39; or &#39;Bind_TestTypeAlloc&#39; classes) of
    // which value or allocator is being passed to which argument of the test
    // function by a &#39;bdlf_bind&#39; object.

    // ENUMERATIONS
    enum {
        k_NUM_SLOTS = 15
    };

  private:
    // PRIVATE CLASS DATA
    static VALUE s_slots[k_NUM_SLOTS];

  public:
    // CLASS METHODS
    static VALUE getSlot(int index);
        // Get the value of the slot at the specified &#39;index&#39;.

    static void resetSlots(VALUE value = 0);
        // Reset all the slots in this instance to the optionally specified
        // &#39;value&#39;.

    static void setSlot(VALUE value, int index);
        // Set the slot at the specified &#39;index&#39; to the specified &#39;value&#39;.

    static bool verifySlots(const VALUE *EXPECTED, bool verboseFlag = true);
        // Verify that all the slots in this instance compare equal to those in
        // the specified &#39;EXPECTED&#39; value.  If the optionally specified
        // &#39;verboseFlag&#39; is not set, output diagnostic only in case the slots
        // do not compare equal.
};

                      // ==========================
                      // type Bind_TestSlotsNoAlloc
                      // ==========================

typedef Bind_TestSlotsBase&lt;int&gt; Bind_TestSlotsNoAlloc;
    // When used within the methods of &#39;Bind_TestTypeNoAlloc&#39;, the &#39;VALUE&#39; type
    // will be &#39;int&#39; and will keep track of which arguments have been assigned
    // a value (in case &#39;bdlf_bind&#39; accesses fields that it should not).

                      // =========================
                      // class Bind_TestArgNoAlloc
                      // =========================

template &lt;int ID&gt;
class Bind_TestArgNoAlloc {
    // This very simple &#39;struct&#39; is used purely to disambiguate types in
    // passing parameters due to the fact that &#39;Bind_TestArgNoAlloc&lt;ID1&gt;&#39; is a
    // different type than &#39;Bind_TestArgNoAlloc&lt;ID2&gt;&#39; is ID1 != ID2.  This
    // class does not take an optional allocator.

    // INSTANCE DATA
    int d_value; // value held by this object

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(Bind_TestArgNoAlloc,
                                   bslmf::IsBitwiseMoveable);

    // CREATORS
    Bind_TestArgNoAlloc(int value);                            // IMPLICIT
        // Create an object having the specified &#39;value&#39;.

    // MANIPULATORS
    Bind_TestArgNoAlloc&amp; operator=(const Bind_TestArgNoAlloc &amp;rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    // ACCESSORS
    int value() const;
};

// FREE OPERATORS
template &lt;int ID&gt;
inline
bool operator==(Bind_TestArgNoAlloc&lt;ID&gt; const&amp; lhs,
                Bind_TestArgNoAlloc&lt;ID&gt; const&amp; rhs);

template &lt;int ID&gt;
inline
bool operator!=(Bind_TestArgNoAlloc&lt;ID&gt; const&amp; lhs,
                Bind_TestArgNoAlloc&lt;ID&gt; const&amp; rhs);

                      // ==========================
                      // class Bind_TestTypeNoAlloc
                      // ==========================

class Bind_TestTypeNoAlloc {
    // This &#39;struct&#39; provides a test class capable of holding up to 14 bound
    // parameters of types &#39;TestArgNoAlloc[1--14]&#39;, with full (non-streamable)
    // value semantics defined by the &#39;operator==&#39;.  By default, a
    // &#39;Bind_TestTypeNoAlloc&#39; is constructed with nil (&#39;N1&#39;) values, but
    // instances can be constructed with actual values (e.g., for creating
    // expected values).  A &#39;Bind_TestTypeNoAlloc&#39; can be invoked with up to 14
    // parameters, via member functions &#39;testFunc[1--14]&#39;.  These functions are
    // also called by the overloaded member &#39;operator()&#39; of the same
    // signatures, and similar global functions &#39;testFunc[1--14]&#39;.  All
    // invocations support the above &#39;Bind_TestSlotsNoAlloc&#39; mechanism.
    //
    // This &#39;struct&#39; intentionally does *not* take an allocator.

    // PRIVATE TYPES
#undef  F
#define F(n) typedef Bind_TestArgNoAlloc&lt;n&gt; Arg##n;
    L14(F)
        // Argument types for shortcut.

    // PRIVATE DATA
#undef  F
#define F(n) mutable Arg##n d_a##n;
    L14(F)

    // FRIEND
    friend bool operator==(const Bind_TestTypeNoAlloc&amp; lhs,
                           const Bind_TestTypeNoAlloc&amp; rhs);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(Bind_TestTypeNoAlloc,
                                   bslmf::IsBitwiseMoveable);

    // TYPES
    typedef int ResultType;
        // Type returned by the function operator and test methods.

    enum {
        k_N1 = -1   // default value for all private data
    };

    // CREATORS
#undef  F
#define F(n) Arg##n a##n = k_N1
    explicit Bind_TestTypeNoAlloc(C14(F));
        // Create a test object having the same value as the specified
        // &#39;original&#39;.

    Bind_TestTypeNoAlloc(const Bind_TestTypeNoAlloc&amp; original);
        // Create a test object having the same value as the specified
        // &#39;original&#39;.

    // MANIPULATORS
    Bind_TestTypeNoAlloc&amp; operator=(const Bind_TestTypeNoAlloc &amp;rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    int operator()() const;
        // Test operators invoking this test type with 0 up to 14 arguments.
#undef  F
#define F(n) int operator()(C##n(P)) const;
    L14(F)

    int testFunc0() const;
        // Test methods invoking this test type with 0 up to 14 arguments.
#undef  F
#define F(n) int testFunc##n(C##n(P)) const;
    L14(F)

    // ACCESSORS
    void print() const;
        // Output the value of this instance to the standard output.
};

// FREE OPERATORS
inline
bool operator==(const Bind_TestTypeNoAlloc&amp; lhs,
                const Bind_TestTypeNoAlloc&amp; rhs);

inline
bool operator!=(const Bind_TestTypeNoAlloc&amp; lhs,
                const Bind_TestTypeNoAlloc&amp; rhs);

                        // ===============================
                        // class Bind_TestFunctionsNoAlloc
                        // ===============================

struct Bind_TestFunctionsNoAlloc {
    // Global versions of &#39;Bind_TestTypeNoAlloc&#39; member functions.

    // TYPES
#undef  F
#define F(n) typedef Bind_TestArgNoAlloc&lt;n&gt; Arg##n;
    L14(F)
        // Types for shortcut.

    // CLASS METHODS
    static int func0(Bind_TestTypeNoAlloc *object);
        // Invoke the corresponding method &#39;testFunc[0-14]&#39; on the specified
        // &#39;object&#39; with the specified arguments &#39;a[0-14]&#39;.
#undef  F
#define F(n) static int func##n(Bind_TestTypeNoAlloc *object, C##n(P));
    L14(F)
};

                      // =============================
                      // class Bind_TestSlotsAllocBase
                      // =============================

template &lt;class AllocPtr&gt;
struct Bind_TestSlotsAllocBase
{
    // The point of this base class is that we would like it to be a class
    // template, so that the class data does not pollute the library object
    // files.  Since there is no reason to make &#39;Bind_TestSlotsAlloc&#39; a
    // template, we separate the static pointers into this base class.  These
    // pointers are needed for the pretty printing in the &#39;verifySlots&#39; method.

    // PRIVATE CLASS DATA
    static AllocPtr s_Z0;
    static AllocPtr s_Z1;
    static AllocPtr s_Z2;

  public:
    // CLASS METHODS
    static void setZ0(AllocPtr Z0);
    static void setZ1(AllocPtr Z1);
    static void setZ2(AllocPtr Z2);
    static AllocPtr getZ0();
    static AllocPtr getZ1();
    static AllocPtr getZ2();
};

                      // =========================
                      // class Bind_TestSlotsAlloc
                      // =========================

class Bind_TestSlotsAlloc
: public Bind_TestSlotsBase&lt;const bslma::Allocator*&gt;
, public Bind_TestSlotsAllocBase&lt;const bslma::Allocator*&gt;
{
    // When used within the methods of &#39;Bind_TestTypeAlloc&#39;, the &#39;VALUE&#39; type
    // will be &#39;const bslma::Allocator*&#39; and will keep track of which allocator
    // is used with which argument of the &#39;Bind&#39; object.  The sole purpose of
    // deriving a new class is to use pretty printing of the allocators in
    // &#39;verifySlots&#39;.

  public:
    static bool verifySlots(const bslma::Allocator *const *EXPECTED,
                            bool                           verboseFlag = true);
        // Verify that all the slots in this instance compare equal to those in
        // the specified &#39;EXPECTED&#39; value.  If the optionally specified
        // &#39;verboseFlag&#39; is not set, output diagnostic only in case the slots
        // do not compare equal.
};

                      // =======================
                      // class Bind_TestArgAlloc
                      // =======================

template &lt;int ID&gt;
class Bind_TestArgAlloc {
    // This class is used to disambiguate types in passing parameters due to
    // the fact that &#39;Bind_TestArgAlloc&lt;ID1&gt;&#39; is a different type than
    // &#39;Bind_TestArgAlloc&lt;ID2&gt;&#39; is ID1 != ID2.  This class is used for
    // testing memory allocator issues.

    // PRIVATE DATA
    bslma::Allocator *d_allocator_p;  // memory allocator (held, not owned)
    int              *d_value;        // value allocated from &#39;d_allocator_p&#39;
        // NOTE: *Must* be declared and initialized in that order.

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(Bind_TestArgAlloc,
                                   bslma::UsesBslmaAllocator);

    // CREATORS

#if defined(BSLS_PLATFORM_CMP_IBM) &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &gt;= 0x0900
    // TBD: This is probably an IBM xlC compiler bug.  Reproduce in a small
    // test case later.
    Bind_TestArgAlloc(int value);                                   // IMPLICIT
    Bind_TestArgAlloc(int value, bslma::Allocator *allocator);
#else
    Bind_TestArgAlloc(int value, bslma::Allocator *allocator = 0);  // IMPLICIT
#endif
        // Create an object having the specified &#39;value&#39;.  Use the specified
        // &#39;allocator&#39; to supply memory.  If &#39;allocator&#39; is 0, use the
        // currently installed default allocator.

#if defined(BSLS_PLATFORM_CMP_IBM) &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &gt;= 0x0900
    Bind_TestArgAlloc(const Bind_TestArgAlloc&amp;  original);
    Bind_TestArgAlloc(const Bind_TestArgAlloc&amp;  original,
                      bslma::Allocator         *allocator);
#else
    Bind_TestArgAlloc(const Bind_TestArgAlloc&amp;  original,
                      bslma::Allocator         *allocator = 0);
#endif
        // Create a copy of the specified non-modifiable &#39;original&#39;.    Use the
        // specified &#39;allocator&#39; to supply memory.  If &#39;allocator&#39; is 0, use
        // the currently installed default allocator.

    ~Bind_TestArgAlloc();
        // Destroy this object.

    // MANIPULATORS
    Bind_TestArgAlloc&amp; operator=(const Bind_TestArgAlloc &amp;rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    // ACCESSORS
    const bslma::Allocator *allocator() const;
        // Return the allocator specified at construction of this object.

    int value() const;
        // Return the value of this object.
};

// FREE OPERATORS
template &lt;int ID&gt;
inline
bool operator==(const Bind_TestArgAlloc&lt;ID&gt;&amp; lhs,
                const Bind_TestArgAlloc&lt;ID&gt;&amp; rhs);

template &lt;int ID&gt;
inline
bool operator!=(const Bind_TestArgAlloc&lt;ID&gt;&amp; lhs,
                const Bind_TestArgAlloc&lt;ID&gt;&amp; rhs);

                      // ========================
                      // class Bind_TestTypeAlloc
                      // ========================

class Bind_TestTypeAlloc {
    // This class provides a test class capable of holding up to 14 bound
    // parameters of types &#39;Bind_TestArgAlloc[1--14]&#39;, with full
    // (non-streamable) value semantics defined by the &#39;operator==&#39;.  By
    // default, a &#39;Bind_TestTypeAlloc&#39; is constructed with nil (&#39;k_N1&#39;) values,
    // but objects can be constructed with actual values (e.g., for creating
    // expected values).  A &#39;Bind_TestTypeAlloc&#39; can be invoked with up to 14
    // parameters, via member functions &#39;testFunc[1--14]&#39;.  These functions are
    // also called by the overloaded member &#39;operator()&#39; of the same
    // signatures, and similar global functions &#39;testFunc1--14&#39;.  All
    // invocations support the above &#39;Bind_TestSlotsAlloc&#39; mechanism.
    //
    // This class intentionally *does* take an allocator.

    // PRIVATE TYPES
#undef  F
#define F(n) typedef Bind_TestArgAlloc&lt;n&gt; Arg##n;
    L14(F)
        // Argument types for shortcut.

    enum {
        k_N1 = -1   // default value for all private data
    };

    // PRIVATE DATA
#undef  F
#define F(n) mutable Arg##n d_a##n;
    L14(F)

    // FRIEND
    friend bool operator==(const Bind_TestTypeAlloc&amp; lhs,
                           const Bind_TestTypeAlloc&amp; rhs);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(Bind_TestTypeAlloc,
                                   bslma::UsesBslmaAllocator);

    // PUBLIC TYPES
    typedef int ResultType;
        // Type returned by the function operator and test methods.

    // CREATORS
#undef  F
#define F(n) Arg##n a##n = k_N1
    explicit Bind_TestTypeAlloc(bslma::Allocator *allocator = 0, C14(F));
        // This constructor does *not* participate in the
        // &#39;UsesBdemaAllocatorTraits&#39; contract, it is here simply to allow to
        // construct expected values with a specified &#39;allocator&#39; as the first
        // argument (otherwise there would need to be fourteen different
        // constructors with &#39;allocator&#39; as the last argument).

#undef  F
#define F(n) Arg##n a##n
    Bind_TestTypeAlloc(C14(F), bslma::Allocator *allocator = 0);

    Bind_TestTypeAlloc(const Bind_TestTypeAlloc&amp;  original,
                       bslma::Allocator          *allocator = 0);

    // MANIPULATORS
    Bind_TestTypeAlloc&amp; operator=(const Bind_TestTypeAlloc &amp;rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object.

    int operator()() const;
        // Test operators invoking this test type with 0 up to 14 arguments.
#undef  F
#define F(n) int operator()(C##n(P)) const;
    L14(F)

    int testFunc0() const;
        // Test methods invoking this test type with 0 up to 14 arguments.
#undef  F
#define F(n) int testFunc##n(C##n(P)) const;
    L14(F)

    void setSlots();
        // Set slots with allocator values of internal data members (as opposed
        // to with allocator value of invocation arguments as in the operators
        // and &#39;testFunc*&#39; functions above).

    // ACCESSORS
    void print() const;
        // Output the value of this object to the standard output.
};

// FREE OPERATORS
inline
bool operator==(Bind_TestTypeAlloc const&amp; lhs, Bind_TestTypeAlloc const&amp; rhs);

inline
bool operator!=(Bind_TestTypeAlloc const&amp; lhs, Bind_TestTypeAlloc const&amp; rhs);

                        // =============================
                        // class Bind_TestFunctionsAlloc
                        // =============================

struct Bind_TestFunctionsAlloc {
    // Global versions of &#39;Bind_TestTypeAlloc&#39; member functions.

    // TYPES
#undef  F
#define F(n) typedef Bind_TestArgAlloc&lt;n&gt; Arg##n;
    L14(F)

    // CLASS METHODS
    static int func0(Bind_TestTypeAlloc *o);
        // Invoke the corresponding method &#39;testFunc[0-14]&#39; on the specified
        // &#39;object&#39; with the specified arguments &#39;a[0-14]&#39;.
#undef  F
#define F(n) static int func##n(Bind_TestTypeAlloc *o, C##n(P));
    L14(F)
};
}  // close package namespace

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                      // -------------------------
                      // class bdlf::Bind_TestUtil
                      // -------------------------

template &lt;class T&gt;
inline bool bdlf::Bind_TestUtil::isBitwiseMoveableType(const T&amp;) {
    return bslmf::IsBitwiseMoveable&lt;T&gt;::VALUE;
}

                      // ------------------------------
                      // class bdlf::Bind_TestSlotsBase
                      // ------------------------------

// PRIVATE CLASS DATA
template &lt;class VALUE&gt;
VALUE bdlf::Bind_TestSlotsBase&lt;VALUE&gt;::s_slots[k_NUM_SLOTS];

namespace bdlf {

// CLASS METHODS
template &lt;class VALUE&gt;
inline
VALUE Bind_TestSlotsBase&lt;VALUE&gt;::getSlot(int index)
{
    return s_slots[index];
}

template &lt;class VALUE&gt;
void Bind_TestSlotsBase&lt;VALUE&gt;::resetSlots(VALUE value)
{
    for (int i = 0; i &lt; k_NUM_SLOTS; ++i) {
        s_slots[i] = value;
    }
}

template &lt;class VALUE&gt;
inline
void Bind_TestSlotsBase&lt;VALUE&gt;::setSlot(VALUE value, int index)
{
    s_slots[index] = value;
}

#ifdef BSLS_PLATFORM_CMP_MSVC
#pragma warning( push )
#pragma warning( disable : 4100 ) // Verify we still need separate test paths
                                  // for MSVC
#endif

template &lt;class VALUE&gt;
bool Bind_TestSlotsBase&lt;VALUE&gt;::verifySlots(const VALUE *EXPECTED,
                                            bool         verboseFlag)
{
    bool equalFlag = true;
#if !defined(BSLS_PLATFORM_CMP_MSVC)
    // Note: the calls to &#39;verifyAllocSlots&#39; are disabled on Windows.  Their
    // success depends on the &quot;Return Value Optimization&quot; (RVO) which Windows
    // does not seem to be applying.

    for (int i = 0; i &lt; k_NUM_SLOTS; ++i) {
        if (EXPECTED[i] != getSlot(i)) {
            equalFlag = false;
            break;
        }
    }
#endif // !defined(BSLS_PLATFORM_CMP_MSVC)

    if (verboseFlag || !equalFlag) {
        bsl::printf(&quot;\tSlots:&quot;);
        for (int i = 0; i &lt; k_NUM_SLOTS; ++i) {
            bsl::printf(&quot; %d&quot;, getSlot(i));
        }
        bsl::printf(&quot;\n&quot;);
    }

    return equalFlag;
}

#ifdef BSLS_PLATFORM_CMP_MSVC
#pragma warning( pop )
#endif

                      // -------------------------
                      // class Bind_TestArgNoAlloc
                      // -------------------------

// CREATORS
template &lt;int ID&gt;
inline
Bind_TestArgNoAlloc&lt;ID&gt;::Bind_TestArgNoAlloc(int value)
: d_value(value)
{
}

// MANIPULATORS
template &lt;int ID&gt;
inline
Bind_TestArgNoAlloc&lt;ID&gt;&amp;
Bind_TestArgNoAlloc&lt;ID&gt;::operator=(const Bind_TestArgNoAlloc &amp;rhs)
{
    d_value = rhs.d_value;
    return *this;
}

// ACCESSORS
template &lt;int ID&gt;
inline
int Bind_TestArgNoAlloc&lt;ID&gt;::value() const
{
    return d_value;
}
}  // close package namespace

// FREE OPERATORS
template &lt;int ID&gt;
bool bdlf::operator==(Bind_TestArgNoAlloc&lt;ID&gt; const&amp; lhs,
                      Bind_TestArgNoAlloc&lt;ID&gt; const&amp; rhs)
{
    return lhs.value() == rhs.value();
}

template &lt;int ID&gt;
bool bdlf::operator!=(Bind_TestArgNoAlloc&lt;ID&gt; const&amp; lhs,
                      Bind_TestArgNoAlloc&lt;ID&gt; const&amp; rhs)
{
    return !(lhs == rhs);
}

namespace bdlf {
                      // --------------------------
                      // class Bind_TestTypeNoAlloc
                      // --------------------------

// CREATORS
#undef  F
#define F(n) d_a##n(a##n)
inline
Bind_TestTypeNoAlloc::Bind_TestTypeNoAlloc(C14(V))
: C14(F)
{
}

#undef  F
#define F(n) d_a##n(original.d_a##n)
inline
Bind_TestTypeNoAlloc::Bind_TestTypeNoAlloc(
                                          const Bind_TestTypeNoAlloc&amp; original)
: C14(F)
{
}

// MANIPULATORS
inline
Bind_TestTypeNoAlloc&amp;
Bind_TestTypeNoAlloc::operator=(const Bind_TestTypeNoAlloc&amp; rhs)
{
#undef  F
#define F(n) d_a##n = rhs.d_a##n;
    L14(F)
    return *this;
}

// ACCESSORS
inline
int Bind_TestTypeNoAlloc::operator()() const
{
    return testFunc0();
}

#undef  F
#define F(n)                                                                  \
inline                                                                        \
int Bind_TestTypeNoAlloc::operator()(C##n(P)) const                           \
{                                                                             \
    return testFunc##n(C##n(A));                                              \
}
L14(F)

inline
int Bind_TestTypeNoAlloc::testFunc0() const
{
    return 0;
}

#undef  G
#define G(n) d_a##n = a##n; Bind_TestSlotsNoAlloc::setSlot(a##n.value(), n);
#undef  F
#define F(n)                                                                  \
inline                                                                        \
int Bind_TestTypeNoAlloc::testFunc##n(C##n(P)) const                          \
{                                                                             \
    S##n(G,)                                                                  \
    return n;                                                                 \
}
L14(F)

#undef  F
#define F(n) d_a##n.value()
inline
void Bind_TestTypeNoAlloc::print() const
{
    bsl::printf(&quot;{ %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n&quot;,
                C14(F));
}
}  // close package namespace

// FREE OPERATORS
inline
bool bdlf::operator==(const Bind_TestTypeNoAlloc&amp; lhs,
                      const Bind_TestTypeNoAlloc&amp; rhs)
{
#undef  F
#define F(n) lhs.d_a##n.value() == rhs.d_a##n.value()
    return S14(F,&amp;&amp;);
}

inline
bool bdlf::operator!=(const Bind_TestTypeNoAlloc&amp; lhs,
                      const Bind_TestTypeNoAlloc&amp; rhs)
{
    return !(lhs == rhs);
}

namespace bdlf {
                         // -------------------------------
                         // class Bind_TestFunctionsNoAlloc
                         // -------------------------------

// CLASS METHODS
inline
int Bind_TestFunctionsNoAlloc::func0(Bind_TestTypeNoAlloc *object)
{
    return object-&gt;testFunc0();
}

#undef  F
#define F(n)                                                                  \
inline                                                                        \
int Bind_TestFunctionsNoAlloc::func##n(Bind_TestTypeNoAlloc *object, C##n(P)) \
{                                                                             \
    return object-&gt;testFunc##n(C##n(A));                                      \
}
L14(F)

}  // close package namespace

                      // -----------------------------------
                      // class bdlf::Bind_TestSlotsAllocBase
                      // -----------------------------------

// CLASS DATA
template &lt;class AllocPtr&gt;
AllocPtr bdlf::Bind_TestSlotsAllocBase&lt;AllocPtr&gt;::s_Z0 = 0;

template &lt;class AllocPtr&gt;
AllocPtr bdlf::Bind_TestSlotsAllocBase&lt;AllocPtr&gt;::s_Z1 = 0;

template &lt;class AllocPtr&gt;
AllocPtr bdlf::Bind_TestSlotsAllocBase&lt;AllocPtr&gt;::s_Z2 = 0;

namespace bdlf {

// CLASS METHODS
template &lt;class AllocPtr&gt;
inline
void Bind_TestSlotsAllocBase&lt;AllocPtr&gt;::setZ0(AllocPtr Z0)
{
    s_Z0 = Z0;
}

template &lt;class AllocPtr&gt;
inline
void Bind_TestSlotsAllocBase&lt;AllocPtr&gt;::setZ1(AllocPtr Z1)
{
    s_Z1 = Z1;
}

template &lt;class AllocPtr&gt;
inline
void Bind_TestSlotsAllocBase&lt;AllocPtr&gt;::setZ2(AllocPtr Z2)
{
    s_Z2 = Z2;
}

template &lt;class AllocPtr&gt;
inline
AllocPtr Bind_TestSlotsAllocBase&lt;AllocPtr&gt;::getZ0()
{
    return s_Z0;
}

template &lt;class AllocPtr&gt;
inline
AllocPtr Bind_TestSlotsAllocBase&lt;AllocPtr&gt;::getZ1()
{
    return s_Z1;
}

template &lt;class AllocPtr&gt;
inline
AllocPtr Bind_TestSlotsAllocBase&lt;AllocPtr&gt;::getZ2()
{
    return s_Z2;
}
}  // close package namespace

                      // -----------------------------
                      // class bdlf::Bind_TestArgAlloc
                      // -----------------------------

// CREATORS

namespace bdlf {

#if defined(BSLS_PLATFORM_CMP_IBM) &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &gt;= 0x0900
template &lt;int ID&gt;
Bind_TestArgAlloc&lt;ID&gt;::Bind_TestArgAlloc(int value)
: d_allocator_p(bslma::Default::allocator(0))
, d_value(new (*d_allocator_p) int(value))
{
}
#endif

template &lt;int ID&gt;
Bind_TestArgAlloc&lt;ID&gt;::Bind_TestArgAlloc(int               value,
                                         bslma::Allocator *allocator)
: d_allocator_p(bslma::Default::allocator(allocator))
, d_value(new (*d_allocator_p) int(value))
{
}

#if defined(BSLS_PLATFORM_CMP_IBM) &amp;&amp; BSLS_PLATFORM_CMP_VER_MAJOR &gt;= 0x0900
template &lt;int ID&gt;
Bind_TestArgAlloc&lt;ID&gt;::Bind_TestArgAlloc(const Bind_TestArgAlloc&amp; original)
: d_allocator_p(bslma::Default::allocator(0))
, d_value(new (*d_allocator_p) int(original.value()))
{
}
#endif

template &lt;int ID&gt;
Bind_TestArgAlloc&lt;ID&gt;::Bind_TestArgAlloc(const Bind_TestArgAlloc&amp;  original,
                                         bslma::Allocator         *allocator)
: d_allocator_p(bslma::Default::allocator(allocator))
, d_value(new (*d_allocator_p) int(original.value()))
{
}

template &lt;int ID&gt;
Bind_TestArgAlloc&lt;ID&gt;::~Bind_TestArgAlloc()
{
    d_allocator_p-&gt;deleteObjectRaw(d_value);
}

// MANIPULATORS
template &lt;int ID&gt;
Bind_TestArgAlloc&lt;ID&gt;&amp;
Bind_TestArgAlloc&lt;ID&gt;::operator=(const Bind_TestArgAlloc&amp; rhs)
{
    if (this != &amp;rhs) {
        d_allocator_p-&gt;deleteObjectRaw(d_value);
        d_value = new (*d_allocator_p) int(rhs.value());
    }

    return *this;
}

// ACCESSORS
template &lt;int ID&gt;
const bslma::Allocator *Bind_TestArgAlloc&lt;ID&gt;::allocator() const
{
    return d_allocator_p;
}

template &lt;int ID&gt;
int Bind_TestArgAlloc&lt;ID&gt;::value() const
{
    return *d_value;
}

}  // close package namespace

// FREE OPERATORS
template &lt;int ID&gt;
inline
bool bdlf::operator==(const Bind_TestArgAlloc&lt;ID&gt;&amp; lhs,
                      const Bind_TestArgAlloc&lt;ID&gt;&amp; rhs)
{
    return lhs.value() == rhs.value();
}

template &lt;int ID&gt;
inline
bool bdlf::operator!=(const Bind_TestArgAlloc&lt;ID&gt;&amp; lhs,
                      const Bind_TestArgAlloc&lt;ID&gt;&amp; rhs)
{
    return !(lhs == rhs);
}

namespace bdlf {
                      // ------------------------
                      // class Bind_TestTypeAlloc
                      // ------------------------

// CREATORS

#undef  F
#define F(n) d_a##n(a##n, allocator)
inline
Bind_TestTypeAlloc::Bind_TestTypeAlloc(bslma::Allocator *allocator, C14(V))
: C14(F)
{
}

#undef  F
#define F(n) d_a##n(a##n, allocator)
inline
Bind_TestTypeAlloc::Bind_TestTypeAlloc(C14(V), bslma::Allocator *allocator)
: C14(F)
{
}

#undef  F
#define F(n) d_a##n(original.d_a##n, allocator)
inline
Bind_TestTypeAlloc::Bind_TestTypeAlloc(const Bind_TestTypeAlloc&amp;  original,
                                       bslma::Allocator          *allocator)
: C14(F)
{
}

// MANIPULATORS

#undef  F
#define F(n) d_a##n = rhs.d_a##n;
inline
Bind_TestTypeAlloc&amp;
Bind_TestTypeAlloc::operator=(const Bind_TestTypeAlloc&amp; rhs)
{
    L14(F)
    return *this;
}

// ACCESSORS
inline
int Bind_TestTypeAlloc::operator()() const
{
    return testFunc0();
}

#undef  F
#define F(n)                                                                  \
inline                                                                        \
int Bind_TestTypeAlloc::operator()(C##n(P)) const                             \
{                                                                             \
    return testFunc##n(C##n(A));                                              \
}
L14(F)

inline
int Bind_TestTypeAlloc::testFunc0() const
{
    return 0;
}

#undef  G
#define G(n) d_a##n = a##n; Bind_TestSlotsAlloc::setSlot(a##n.allocator(), n);
#undef  F
#define F(n)                                                                  \
inline                                                                        \
int Bind_TestTypeAlloc::testFunc##n(C##n(P)) const                            \
{                                                                             \
    S##n(G,)                                                                  \
    return n;                                                                 \
}
L14(F)

inline
void Bind_TestTypeAlloc::setSlots()
{
#undef  F
#define F(n) Bind_TestSlotsAlloc::setSlot(d_a##n.allocator(), n);
    L14(F)
}

inline
void Bind_TestTypeAlloc::print() const
{
#undef  F
#define F(n) d_a##n.value()
    bsl::printf(&quot;{ %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n&quot;,
                C14(F));
}
}  // close package namespace

// FREE OPERATORS
inline
bool bdlf::operator==(const Bind_TestTypeAlloc&amp; lhs,
                      const Bind_TestTypeAlloc&amp; rhs)
{
#undef  F
#define F(n) lhs.d_a##n.value()  == rhs.d_a##n.value()
    return S14(F,&amp;&amp;);
}

inline
bool bdlf::operator!=(const Bind_TestTypeAlloc&amp; lhs,
                      const Bind_TestTypeAlloc&amp; rhs)
{
    return !(lhs == rhs);
}

namespace bdlf {
                        // -----------------------------
                        // class Bind_TestFunctionsAlloc
                        // -----------------------------

inline
int Bind_TestFunctionsAlloc::func0(Bind_TestTypeAlloc *o)
{
    return o-&gt;testFunc0();
}

#undef  F
#define F(n)                                                                  \
inline                                                                        \
int Bind_TestFunctionsAlloc::func##n(Bind_TestTypeAlloc *o, C##n(P))          \
{                                                                             \
    return o-&gt;testFunc##n(C##n(A));                                           \
}
L14(F)

}  // close package namespace
}  // close enterprise namespace

#undef  S1
#undef  S2
#undef  S3
#undef  S4
#undef  S5
#undef  S6
#undef  S7
#undef  S8
#undef  S9
#undef  S10
#undef  S11
#undef  S12
#undef  S13
#undef  S14

#undef  C1
#undef  C2
#undef  C3
#undef  C4
#undef  C5
#undef  C6
#undef  C7
#undef  C8
#undef  C9
#undef  C10
#undef  C11
#undef  C12
#undef  C13
#undef  C14

#undef  L1
#undef  L2
#undef  L3
#undef  L4
#undef  L5
#undef  L6
#undef  L7
#undef  L8
#undef  L9
#undef  L10
#undef  L11
#undef  L12
#undef  L13
#undef  L14

#undef  A
#undef  F
#undef  G
#undef  P
#undef  V

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
