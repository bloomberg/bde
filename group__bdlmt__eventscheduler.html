<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlmt_eventscheduler Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlmt_eventscheduler<br/>
<small>
[<a class="el" href="group__bdlmt.html">Package bdlmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a thread-safe recurring and one-time event scheduler.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlmt.html">bdlmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
&nbsp; <ul>
<li>
<a href="#3.0.1">Comparison to <code>bdlmt::TimerEventScheduler</code></a> </li>
</ul>
</li>
<li>
<a href="#3.1">Thread Safety and "Raw" Event Pointers</a> </li>
<li>
<a href="#3.2">The Dispatcher Thread and the Dispatcher Functor</a> </li>
<li>
<a href="#3.3">Timer Resolution and Order of Execution</a> </li>
<li>
<a href="#3.4">Supported Clock-Types</a> </li>
<li>
<a href="#3.5">Usage</a> <ul>
<li>
<a href="#3.5.1">Example 1: Simple Clock</a> </li>
<li>
<a href="#3.5.2">Example 2: Server Timeouts</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a thread-safe recurring and one-time event scheduler. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlmt_1_1EventScheduler.html">bdlmt::EventScheduler</a> </td><td>a thread-safe event scheduler  </td></tr>
<tr>
<td><a class="el" href="classbdlmt_1_1EventSchedulerEventHandle.html">bdlmt::EventSchedulerEventHandle</a> </td><td>handle to a single scheduled event  </td></tr>
<tr>
<td><a class="el" href="classbdlmt_1_1EventSchedulerRecurringEventHandle.html">bdlmt::EventSchedulerRecurringEventHandle</a> </td><td>handle to a recurring event  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlmt__timereventscheduler.html" title="Provide a thread-safe recurring and non-recurring event scheduler.">Component bdlmt_timereventscheduler</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a thread-safe event scheduler. <code><a class="el" href="classbdlmt_1_1EventScheduler.html">bdlmt::EventScheduler</a></code>, that implements methods to schedule and cancel recurring and one-time events. All of the callbacks for these events are processed by a separate thread (called the dispatcher thread). By default the callbacks are also executed in the dispatcher thread, but that behavior can be altered by providing a dispatcher functor at creation time (see the section "The Dispatcher Thread and the Dispatcher Functor"). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Events may be referred to by <code><a class="el" href="classbdlmt_1_1EventSchedulerEventHandle.html">bdlmt::EventSchedulerEventHandle</a></code> and <code><a class="el" href="classbdlmt_1_1EventSchedulerRecurringEventHandle.html">bdlmt::EventSchedulerRecurringEventHandle</a></code> objects, which clean up after themselves when they go out of scope, or by <code>Event</code> and <code>RecurringEvent</code> pointers, which must be released using <code>releaseEventRaw</code>. Such pointers are used in the "Raw" API of this class and must be used carefully. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="comparison_to_bdlmt~3A~3Atimereventscheduler"></a> <a class="anchor" id=".comparison_to_bdlmt~3A~3Atimereventscheduler"></a> <a class="anchor" id="description..comparison_to_bdlmt~3A~3Atimereventscheduler"></a> <a class="anchor" id="comparison_to_bdlmt"></a> <a class="anchor" id=".comparison_to_bdlmt"></a> <a class="anchor" id="description..comparison_to_bdlmt"></a> <a class="anchor" id="3.0.1"></a> </dd></dl>
<dl class="user"><dt><b>Comparison to bdlmt::TimerEventScheduler: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component was written after <code>bdlmt_timereventscheduler</code>, which suffered from a couple of short-comings: 1) there was a maximum number of events it could manage, and 2) it was inefficient at dealing with large numbers of events. This component addresses both those problems -- there is no limit on the number of events it can , and it is more efficient at dealing with large numbers of events. The disadvantage of this component relative to <code>bdlmt_timereventscheduler</code> is that handles referring to managed events in a <code><a class="el" href="classbdlmt_1_1EventScheduler.html">bdlmt::EventScheduler</a></code> are reference-counted and need to be released, while handles of events in a <code><a class="el" href="classbdlmt_1_1TimerEventScheduler.html">bdlmt::TimerEventScheduler</a></code> are integral types that do not need to be released. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety_and_~22raw~22_event_pointers"></a> <a class="anchor" id="description.thread_safety_and_~22raw~22_event_pointers"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety and "Raw" Event Pointers: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlmt_1_1EventScheduler.html">bdlmt::EventScheduler</a></code> is thread-safe and thread-enabled, meaning that multiple threads may use their own instances of the class or use a shared instance without further synchronization. The thread safety and correct behavior of the component depend on the correct usage of <code>Event</code> pointers, which refer to scheduled events in the "Raw" API of this class. In particular: <br/>
<br/>
<div class="fragment"><pre class="fragment"> Every <span class="stringliteral">&#39;Event*&#39;</span>  and <span class="stringliteral">&#39;RecurringEvent*&#39;</span> populated by <span class="stringliteral">&#39;scheduleEventRaw&#39;</span>
 and <span class="stringliteral">&#39;scheduleRecurringEventRaw&#39;</span> must be released <span class="keyword">using</span> <span class="stringliteral">&#39;releaseEventRaw.&#39;</span>
       - Pointers are not released automatically when events are completed.
       - Pointers are not released automatically when events are canceled.
       - Events are not canceled when pointers to them are released.
 Pointers must not be used after being released.
 Pointers must never be shared or duplicated without <span class="keyword">using</span>
    <span class="stringliteral">&#39;addEventRefRaw&#39;</span> and <span class="stringliteral">&#39;addRecurringEventRefRaw&#39;</span> to <span class="keyword">get</span> additional
     references; *each* such added reference must be released separately.
</pre></div><br/>
<br/>
 <code><a class="el" href="classbdlmt_1_1EventSchedulerEventHandle.html">bdlmt::EventSchedulerEventHandle</a></code> and <code><a class="el" href="classbdlmt_1_1EventSchedulerRecurringEventHandle.html">bdlmt::EventSchedulerRecurringEventHandle</a></code> are <em>const</em> <em>thread-safe</em>. It is not safe for multiple threads to invoke non-const methods on the same EventHandle or RecurringEventHandle object concurrently. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="the_dispatcher_thread_and_the_dispatcher_functor"></a> <a class="anchor" id="description.the_dispatcher_thread_and_the_dispatcher_functor"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>The Dispatcher Thread and the Dispatcher Functor: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The scheduler creates a single separate thread (called the <em>dispatcher</em> <em>thread</em>) to process all the callbacks. The dispatcher thread executes the callbacks by passing them to the dispatcher functor (optionally specified at creation time). The default dispatcher functor simply invokes the passed callback, effectively executing it in the dispatcher thread. Users can alter this behavior by defining their own dispatcher functor (for example in order to use a thread pool or a separate thread to run the callbacks). Note that the user-supplied functor will still be run in the dispatcher thread. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>CAVEAT: Using a dispatcher functor such as the example above (to execute the callback in a separate thread) violates the guarantees of cancelEventAndWait(). Users who specify a dispatcher functor that transfers the event to another thread for execution should not use cancelEventAndWait(), and should instead ensure that the lifetime of any object bound to an event exceeds the lifetime of the mechanism used by the customized dispatcher functor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="timer_resolution_and_order_of_execution"></a> <a class="anchor" id="description.timer_resolution_and_order_of_execution"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Timer Resolution and Order of Execution: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is intended that recurring and one-time events are processed as closely as possible to their respective time values, and that they are processed in the order scheduled. However, this component <em>guarantees</em> only that events will not be executed before their scheduled time. Generally, events that are scheduled more than 1 microsecond apart will be executed in the order scheduled; but different behavior may be observed when events are submitted after (or shortly before) their scheduled time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When events are executed in the dispatcher thread and take longer to complete than the time between events, the dispatcher can fall behind. In this case, events will be executed in the correct order as soon as the dispatcher thread becomes available; once the backlog is worked off, events will be executed at or near their scheduled times. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="supported_clock-types"></a> <a class="anchor" id="description.supported_clock-types"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Supported Clock-Types: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The component <code><a class="el" href="structbsls_1_1SystemClockType.html">bsls::SystemClockType</a></code> supplies the enumeration indicating the system clock on which times supplied to other methods should be based. If the clock type indicated at construction is <code><a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56ba4b4f6a6781cc76138225ba163ed717a8">bsls::SystemClockType::e_REALTIME</a></code>, time should be expressed as an absolute offset since 00:00:00 UTC, January 1, 1970 (which matches the epoch used in <code>bdlt::CurrentTime::now(bsls::SystemClockType::e_REALTIME)</code>. If the clock type indicated at construction is <code><a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56ba28811e3a40d5ac56aeed9bd363c12201">bsls::SystemClockType::e_MONOTONIC</a></code>, time should be expressed as an absolute offset since the epoch of this clock (which matches the epoch used in <code>bdlt::CurrentTime::now(bsls::SystemClockType::e_MONOTONIC)</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_simple_clock"></a> <a class="anchor" id="usage.example_1~3A_simple_clock"></a> <a class="anchor" id="description.usage.example_1~3A_simple_clock"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.5.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Simple Clock: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example we wish to log some statistics periodically. We define a method to store the value of a variable into an array, and set up a scheduler to call that as a recurring event. <br/>
<br/>
<div class="fragment"><pre class="fragment">   <a class="code" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a>  g_data;  <span class="comment">// Some global data we want to track</span>
   <span class="keyword">typedef</span> pair&lt;bdlt::Datetime, int&gt; Value;

   <span class="keywordtype">void</span> saveData(vector&lt;Value&gt; *array)
   {
      array-&gt;push_back(Value(<a class="code" href="structbdlt_1_1CurrentTime.html#a42d082242c48b7445d21cabbaec1b50b">bdlt::CurrentTime::utc</a>(), g_data));
   }
</pre></div><br/>
<br/>
 We allow the scheduler to run for a short time while changing this value and observe that the callback is executed: <br/>
<br/>
<div class="fragment"><pre class="fragment">   <a class="code" href="classbdlmt_1_1EventScheduler.html">bdlmt::EventScheduler</a> scheduler;
   vector&lt;Value&gt; values;

   scheduler.<a class="code" href="classbdlmt_1_1EventScheduler.html#a451b3459cdab4b9c22a736a480ec06bc">scheduleRecurringEvent</a>(<a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>(1.5),
                                  <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;saveData, &amp;values)));
   scheduler.<a class="code" href="classbdlmt_1_1EventScheduler.html#a9948ecb3c4308017c17ea9cfb03e7743">start</a>();
   <a class="code" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a> start = <a class="code" href="structbdlt_1_1CurrentTime.html#a42d082242c48b7445d21cabbaec1b50b">bdlt::CurrentTime::utc</a>();
   <span class="keywordflow">while</span> ((<a class="code" href="structbdlt_1_1CurrentTime.html#a42d082242c48b7445d21cabbaec1b50b">bdlt::CurrentTime::utc</a>() -
                                          start).totalSeconds() &lt; 7) {
     ++g_data;
   }
   scheduler.<a class="code" href="classbdlmt_1_1EventScheduler.html#a6c97f4ab147de04cdd5aea2f74347075">stop</a>();
   assert(values.size() &gt;= 4);
   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; values.size(); ++i) {
     bsl::cout &lt;&lt; <span class="stringliteral">&quot;At &quot;</span> &lt;&lt; values[i].first &lt;&lt; <span class="stringliteral">&quot; g_data was &quot;</span>
               &lt;&lt; values[i].second &lt;&lt; bsl::endl;
   }
</pre></div><br/>
<br/>
 This will display, e.g.: <br/>
<br/>
<div class="fragment"><pre class="fragment">     At 06MAY2008_21:19:17.092 g_data was 816196
     At 06MAY2008_21:19:18.592 g_data was 1620749
     At 06MAY2008_21:19:20.092 g_data was 2443358
     At 06MAY2008_21:19:21.592 g_data was 3267721
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_server_timeouts"></a> <a class="anchor" id="usage.example_2~3A_server_timeouts"></a> <a class="anchor" id="description.usage.example_2~3A_server_timeouts"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.5.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Server Timeouts: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example shows how to use a <code><a class="el" href="classbdlmt_1_1EventScheduler.html">bdlmt::EventScheduler</a></code> to implement a timeout mechanism in a server. <code>my_Session</code> maintains several connections. It closes a connection if the data for it does not arrive before a timeout (specified at the server creation time). </dd></dl>
<dl class="user"><dt><b></b></dt><dd><br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keyword">class </span>my_Session{
        <span class="comment">// This class encapsulates the data and state associated with a</span>
        <span class="comment">// connection and provides a method &#39;processData&#39; to process the</span>
        <span class="comment">// incoming data for the connection.</span>
      <span class="keyword">public</span>:
        <span class="keywordtype">int</span> processData(<span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> length);
            <span class="comment">// Process the specified &#39;data&#39; of the specified &#39;length&#39;.  (TBD)</span>
    };

    <span class="keyword">class </span>my_Server {
     <span class="comment">// This class implements a server maintaining several connections.</span>
     <span class="comment">// A connection is closed if the data for it does not arrive</span>
     <span class="comment">// before a timeout (specified at the server creation time).</span>

     <span class="keyword">struct </span>Connection {
         <a class="code" href="classbdlmt_1_1EventSchedulerEventHandle.html">bdlmt::EventSchedulerEventHandle</a> d_timerId;   <span class="comment">// handle for timeout</span>
                                                     <span class="comment">// event</span>

         my_Session *d_session_p;                    <span class="comment">// session for this</span>
                                                     <span class="comment">// connection</span>
     };

     <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;Connection*&gt;</a> d_connections; <span class="comment">// maintained connections</span>
     <a class="code" href="classbdlmt_1_1EventScheduler.html">bdlmt::EventScheduler</a>      d_scheduler;   <span class="comment">// timeout event scheduler</span>
     <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>        d_ioTimeout;   <span class="comment">// time out</span>

     <span class="keywordtype">void</span> newConnection(Connection *connection);
         <span class="comment">// Add the specified &#39;connection&#39; to this server and schedule</span>
         <span class="comment">// the timeout event that closes this connection if the data</span>
         <span class="comment">// for this connection does not arrive before the timeout.</span>

     <span class="keywordtype">void</span> closeConnection(Connection *connection);
         <span class="comment">// Close the specified &#39;connection&#39; and remove it from this server.</span>

     <span class="keywordtype">void</span> dataAvailable(Connection *connection, <span class="keywordtype">void</span> *data, <span class="keywordtype">int</span> length);
         <span class="comment">// Return if the specified &#39;connection&#39; has already timed-out.</span>
         <span class="comment">// If not, cancel the existing timeout event for the &#39;connection&#39;,</span>
         <span class="comment">// process the specified &#39;data&#39; of the specified &#39;length&#39; and</span>
         <span class="comment">// schedule a new timeout event that closes the &#39;connection&#39; if</span>
         <span class="comment">// the data does not arrive before the timeout.</span>

   <span class="keyword">public</span>:
     my_Server(<span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp;  ioTimeout,
               <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>         *allocator = 0);
         <span class="comment">// Construct a &#39;my_Server&#39; object with a timeout value of</span>
         <span class="comment">// &#39;ioTimeout&#39; seconds.  Optionally specify a &#39;allocator&#39; used to</span>
         <span class="comment">// supply memory.  If &#39;allocator&#39; is 0, the currently installed</span>
         <span class="comment">// default allocator is used.</span>

     ~my_Server();
         <span class="comment">// Perform the required clean-up and destroy this object.</span>
 };

 my_Server::my_Server(<span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp;  ioTimeout,
                      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>          *alloc)
 : d_connections(alloc)
 , d_scheduler(alloc)
 , d_ioTimeout(ioTimeout)
 {
      <span class="comment">// TBD: logic to start monitoring the arriving connections or data</span>

      d_scheduler.start();
 }

 my_Server::~my_Server()
 {
     <span class="comment">// TBD: logic to clean up</span>

     d_scheduler.stop();
 }

 <span class="keywordtype">void</span> my_Server::newConnection(my_Server::Connection *connection)
 {
     <span class="comment">// TBD: logic to add &#39;connection&#39; to &#39;d_connections&#39;</span>

     <span class="comment">// setup the timeout for data arrival</span>
     d_scheduler.scheduleEvent(
        &amp;connection-&gt;d_timerId,
        <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + d_ioTimeout,
        <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;my_Server::closeConnection, <span class="keyword">this</span>, connection));
 }

 <span class="keywordtype">void</span> my_Server::closeConnection(my_Server::Connection *connection)
 {
     <span class="comment">// TBD: logic to close the &#39;connection&#39; and remove it from &#39;d_ioTimeout&#39;</span>
 }

 <span class="keywordtype">void</span> my_Server::dataAvailable(my_Server::Connection *connection,
                               <span class="keywordtype">void</span>                  *data,
                               <span class="keywordtype">int</span>                    length)
 {
     <span class="comment">// If connection has already timed out and closed, simply return.</span>
     <span class="keywordflow">if</span> (d_scheduler.cancelEvent(connection-&gt;d_timerId)) {
         <span class="keywordflow">return</span>;                                                    <span class="comment">// RETURN</span>
     }

     <span class="comment">// process the data</span>
     connection-&gt;d_session_p-&gt;processData(data, length);

     <span class="comment">// setup the timeout for data arrival</span>
     d_scheduler.scheduleEvent(
        &amp;connection-&gt;d_timerId,
        <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + d_ioTimeout,
        <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;my_Server::closeConnection, <span class="keyword">this</span>, connection));
 }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:46 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
