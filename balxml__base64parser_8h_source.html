<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// balxml_base64parser.h                                              -*-C++-*-
#ifndef INCLUDED_BALXML_BASE64PARSER
#define INCLUDED_BALXML_BASE64PARSER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide push parser for Base64 types.
//
//@DEPRECATED: Use bdlde_base64decoder instead.
//
//@CLASSES:
//  balxml::Base64Parser: push parser for Base64 types
//
//@DESCRIPTION: The &#39;balxml::Base64Parser&#39; class template provided by this
// component can be used to parse Base64 characters into one of the supported
// Base64 types, which are &#39;bsl::vector&lt;char&gt;&#39; and &#39;bsl::string&#39;.  The &#39;TYPE&#39;
// parameter can be one of these two types.
//
// This class template is a model of the &#39;PushParser&#39; concept, which contains
// the following methods:
//..
//  int beginParse(TYPE *object);
//      // Prepare the parser to start parsing a new value and associate the
//      // specified &#39;object&#39; with the parser.  Return 0 if successful and
//      // non-zero otherwise.
//
//  int endParse();
//      // Ends the parse operation and store the value parsed from the pushed
//      // characters into the associated object.  Return 0 if successful and
//      // non-zero otherwise.  The behavior is undefined unless an object is
//      // associated with this parser.  Upon successful completion, the parser
//      // will be disassociated with the object.
//
//  template &lt;typename INPUT_ITERATOR&gt;
//  int pushCharacters(INPUT_ITERATOR begin, INPUT_ITERATOR end);
//      // Push the characters ranging from the specified &#39;begin&#39; up to (but
//      // not including) the specified &#39;end&#39; into this parser.  Return 0 if
//      // successful and non-zero otherwise.  The parameterized
//      // &#39;INPUT_ITERATOR&#39; must be dereferenceable to a &#39;char&#39; value.  The
//      // behavior is undefined unless an object is associated with this
//      // parser.
//..
//
///Usage
///-----
// The following snippets of code illustrate the usage of this component.
// Suppose you had an input stream that contained Base64 data.  The following
// &#39;loadFromBase64Stream&#39; function loads this data into an &#39;bsl::vector&lt;char&gt;&#39;
// blob:
//..
//  #include &lt;balxml_base64parser.h&gt;
//
//  #include &lt;istream&gt;
//  #include &lt;iterator&gt;
//  #include &lt;vector&gt;
//
//  using namespace BloombergLP;
//
//  int loadFromBase64Stream(bsl::vector&lt;char&gt; *result, bsl::istream&amp; stream)
//  {
//      enum { FAILURE = -1 };
//
//      balxml::Base64Parser&lt;bsl::vector&lt;char&gt; &gt; parser;
//
//      if (0 != parser.beginParse(result)) {
//          return FAILURE;
//      }
//
//      if (0 != parser.pushCharacters(bsl::istreambuf_iterator&lt;char&gt;(stream),
//                                     bsl::istreambuf_iterator&lt;char&gt;())) {
//          return FAILURE;
//      }
//
//      return parser.endParse();
//  }
//..
// The following function demonstrates the &#39;loadFromBase64Stream&#39; function:
//..
//  #include &lt;sstream&gt;
//
//  void usageExample()
//  {
//      const char INPUT[] = &quot;YWJjZA==&quot;;  // &quot;abcd&quot; in Base64
//
//      bsl::vector&lt;char&gt;  vec;
//      bsl::istringstream iss(INPUT);
//
//      int result = loadFromBase64Stream(&amp;vec, iss);
//
//      assert(0   == result);
//      assert(4   == vec.size());
//      assert(&#39;a&#39; == vec[0]);
//      assert(&#39;b&#39; == vec[1]);
//      assert(&#39;c&#39; == vec[2]);
//      assert(&#39;d&#39; == vec[3]);
//  }
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLDE_BASE64DECODER
#include &lt;bdlde_base64decoder.h&gt;
#endif

#ifndef INCLUDED_BDLAT_VALUETYPEFUNCTIONS
#include &lt;bdlat_valuetypefunctions.h&gt;
#endif

#ifndef INCLUDED_BSL_ITERATOR
#include &lt;bsl_iterator.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

namespace BloombergLP {

namespace balxml {
                          // ========================
                          // class Base64Parser&lt;TYPE&gt;
                          // ========================

template &lt;class TYPE&gt;
class Base64Parser {
    // This is a push parser for supported Base64 types (&#39;bsl::vector&lt;char&gt;&#39; or
    // &#39;bsl::string&#39;).

    // PRIVATE DATA MEMBERS
    bdlde::Base64Decoder  d_base64Decoder;   // decoder
    TYPE                 *d_object_p;        // associated object

  private:
    // NOT IMPLEMENTED
    Base64Parser(const Base64Parser&amp;);
    Base64Parser&amp; operator=(const Base64Parser&amp;);

  public:
    // CREATORS
    Base64Parser();
        // Create a parser for parsing Base64 types.

#ifdef DOXYGEN    // Generated by compiler:

    ~Base64Parser();
        // Destroy this parser object.
#endif

    // MANIPULATORS
    int beginParse(TYPE *object);
        // Prepare the parser to start parsing a new value and associate the
        // specified &#39;object&#39; with the parser.  Return 0 if successful and
        // non-zero otherwise.

    int endParse();
        // Ends the parse operation and store the value parsed from the pushed
        // characters into the associated object.  Return 0 if successful and
        // non-zero otherwise.  The behavior is undefined unless an object is
        // associated with this parser.  Upon successful completion, the parser
        // will be disassociated with the object.

    template &lt;class INPUT_ITERATOR&gt;
    int pushCharacters(INPUT_ITERATOR begin, INPUT_ITERATOR end);
        // Push the characters ranging from the specified &#39;begin&#39; up to (but
        // not including) the specified &#39;end&#39; into this parser.  Return 0 if
        // successful and non-zero otherwise.  The parameterized
        // &#39;INPUT_ITERATOR&#39; must be dereferenceable to a &#39;char&#39; value.  The
        // behavior is undefined unless an object is associated with this
        // parser.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                          // ------------------------
                          // class Base64Parser&lt;TYPE&gt;
                          // ------------------------

// CREATORS

template &lt;class TYPE&gt;
Base64Parser&lt;TYPE&gt;::Base64Parser()
: d_base64Decoder(true)  // &#39;true&#39; indicates report errors
, d_object_p(0)
{
}

// MANIPULATORS

template &lt;class TYPE&gt;
int Base64Parser&lt;TYPE&gt;::beginParse(TYPE *object)
{
    BSLS_ASSERT_SAFE(object);

    enum { k_SUCCESS = 0 };

    d_base64Decoder.resetState();
    d_object_p = object;

    bdlat_ValueTypeFunctions::reset(d_object_p);

    return k_SUCCESS;
}

template &lt;class TYPE&gt;
int Base64Parser&lt;TYPE&gt;::endParse()
{
    BSLS_ASSERT_SAFE(d_object_p);

    enum { k_SUCCESS = 0, k_FAILURE = -1 };

    bsl::back_insert_iterator&lt;TYPE&gt; outputIterator(*d_object_p);

    int status = d_base64Decoder.endConvert(outputIterator);

    if (0 &gt; status) {
        return k_FAILURE;                                             // RETURN
    }

    BSLS_ASSERT_SAFE(0 == status);  // nothing should be retained by decoder

    d_object_p = 0;

    return k_SUCCESS;
}

template &lt;class TYPE&gt;
template &lt;class INPUT_ITERATOR&gt;
int Base64Parser&lt;TYPE&gt;::pushCharacters(INPUT_ITERATOR begin,
                                       INPUT_ITERATOR end)
{
    BSLS_ASSERT_SAFE(d_object_p);

    enum { k_SUCCESS = 0, k_FAILURE = -1 };

    bsl::back_insert_iterator&lt;TYPE&gt; outputIterator(*d_object_p);

    int status = d_base64Decoder.convert(outputIterator, begin, end);

    if (0 &gt; status) {
        return k_FAILURE;                                             // RETURN
    }

    BSLS_ASSERT_SAFE(0 == status);  // nothing should be retained by decoder

    return k_SUCCESS;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
