<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlf Package</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#groups">Components</a>  </div>
  <div class="headertitle">
<h1>Package bdlf<br/>
<small>
[<a class="el" href="group__bdl.html">Package Group bdl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide signature-specific function objects (functors).  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Components</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind.html">Component bdlf_bind</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide a signature-specific function object (functor). </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test.html"><span style="color:gray;">Component bdlf_bind_test<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test apparatus for bdlf_bind. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test0.html"><span style="color:gray;">Component bdlf_bind_test0<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with 0 arguments. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test1.html"><span style="color:gray;">Component bdlf_bind_test1<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with 1 argument. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test10.html"><span style="color:gray;">Component bdlf_bind_test10<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with 10 arguments. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test11.html"><span style="color:gray;">Component bdlf_bind_test11<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with 11 arguments. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test12.html"><span style="color:gray;">Component bdlf_bind_test12<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with 12 arguments. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test13.html"><span style="color:gray;">Component bdlf_bind_test13<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with 13 arguments. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test14.html"><span style="color:gray;">Component bdlf_bind_test14<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with 14 arguments. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test2.html"><span style="color:gray;">Component bdlf_bind_test2<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with 2 arguments. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test3.html"><span style="color:gray;">Component bdlf_bind_test3<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with 3 arguments. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test4.html"><span style="color:gray;">Component bdlf_bind_test4<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with 4 arguments. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test5.html"><span style="color:gray;">Component bdlf_bind_test5<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with 5 arguments. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test6.html"><span style="color:gray;">Component bdlf_bind_test6<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with 6 arguments. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test7.html"><span style="color:gray;">Component bdlf_bind_test7<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with 7 arguments. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test8.html"><span style="color:gray;">Component bdlf_bind_test8<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with 8 arguments. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__test9.html"><span style="color:gray;">Component bdlf_bind_test9<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with 9 arguments. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__bind__testn.html"><span style="color:gray;">Component bdlf_bind_testn<strong>: PRIVATE</strong></span></a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="color: gray;margin-top: 0; margin-bottom: 0;">Provide a test sequence for <code>bdlf_bind</code> with N arguments. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__memfn.html">Component bdlf_memfn</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide member function pointer wrapper classes and utility. </p>
</td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdlf__placeholder.html">Component bdlf_placeholder</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p style="margin-top: 0; margin-bottom: 0;">Provide a parameterized placeholder and specialized placeholders. </p>
</td></tr>
</p>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">MNEMONIC: Basic Development Environment Functors (bdlf)</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Hierarchical Synopsis</a> </li>
<li>
<a href="#3.2">Component Synopsis</a> </li>
<li>
<a href="#3.3">Related Packages in Package Group <code>bdl</code></a> </li>
<li>
<a href="#3.4">Relationship to Packages in <code>bdl</code></a> </li>
<li>
<a href="#3.5">Functors and Function Pointers</a> </li>
<li>
<a href="#3.6">Functors in the <code>bdlf</code> package</a> <ul>
<li>
<a href="#3.6.1">Signature-Specific Functors</a> </li>
<li>
<a href="#3.6.2">Envelope-Letter Idiom</a> </li>
<li>
<a href="#3.6.3">Binders</a> </li>
<li>
<a href="#3.6.4">General (Run-Time Polymorphic) Function Objects</a> </li>
<li>
<a href="#3.6.5">Functors and Binders</a> </li>
</ul>
</li>
<li>
<a href="#3.7">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide signature-specific function objects (functors). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="mnemonic~3A_basic_development_environment_functors_(bdlf)"></a> <a class="anchor" id="mnemonic"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>MNEMONIC: Basic Development Environment Functors (bdlf): </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bcef </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>bdlf</code> package provides components to implement function objects (functors) that return void and take between zero and nine arguments of arbitrary type. Function objects created by <code>bdlf</code> components can be invoked in a manner similar to that of the following free function: <br/>
<br/>
<div class="fragment"><pre class="fragment">   <span class="keywordtype">void</span> functionObject(arglist);
</pre></div><br/>
<br/>
 where <code>arglist</code> contains between zero and nine arguments. Functor classes are differentiated by the number and type of arguments they expect. The <code>bdlf</code> package contains 10 separate components that differ in the number of arguments their functors expect; within each component, templates are used to support variations in argument type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition, three components (<code>bdlf_bind</code>, <code>bdlf_memfn</code> and <code>bdlf_function</code>) provide more general functors that can conform to a specified prototype and return an arbitrary type, and that can be invoked in the same manner as before. The functors created by these two components currently support from zero up to 14 arguments. <code>bdlf_bind</code> provides compile-time polymorphism, and adapts an invocable object so that it conforms to a different interface and can be invoked with fewer arguments and/or with the arguments in a different order. This transformation is type-safe, in that type violations provoke compilation errors. <code>bdlf_memfn</code> provides a wrapper that allows a member function to be invoked like a free function, either by providing the object instance as first parameter, or by wrapping the object instance inside the function object. <code>bdlf_function</code> provides run-time polymorphism and is especially suited for callbacks because it adapts any invocable with a compatible prototype to a specified callback interface, at run-time and without the need for recompilation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="hierarchical_synopsis"></a> <a class="anchor" id="description.hierarchical_synopsis"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Hierarchical Synopsis: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>bdlf</code> package currently has 20 components having 4 levels of physical dependency. The list below shows the hierarchical ordering of the components. The order of components within each level is not architecturally significant, just alphabetical. <br/>
<br/>
<div class="fragment"><pre class="fragment">  4. bdlf_bind_test1                                                  !PRIVATE!
     bdlf_bind_test10                                                 !PRIVATE!
     bdlf_bind_test11                                                 !PRIVATE!
     bdlf_bind_test12                                                 !PRIVATE!
     bdlf_bind_test13                                                 !PRIVATE!
     bdlf_bind_test14                                                 !PRIVATE!
     bdlf_bind_test2                                                  !PRIVATE!
     bdlf_bind_test3                                                  !PRIVATE!
     bdlf_bind_test4                                                  !PRIVATE!
     bdlf_bind_test5                                                  !PRIVATE!
     bdlf_bind_test6                                                  !PRIVATE!
     bdlf_bind_test7                                                  !PRIVATE!
     bdlf_bind_test8                                                  !PRIVATE!
     bdlf_bind_test9                                                  !PRIVATE!
     bdlf_bind_testn                                                  !PRIVATE!

  3. bdlf_bind
     bdlf_bind_test0                                                  !PRIVATE!

  2. bdlf_bind_test                                                   !PRIVATE!

  1. bdlf_memfn
     bdlf_placeholder
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="component_synopsis"></a> <a class="anchor" id="description.component_synopsis"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Component Synopsis: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind</code>: <br/>
 Provide a signature-specific function object (functor).</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test</code>: <b>PRIVATE</b> <br/>
 Provide a test apparatus for bdlf_bind.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test0</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with 0 arguments.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test1</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with 1 argument.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test10</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with 10 arguments.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test11</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with 11 arguments.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test12</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with 12 arguments.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test13</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with 13 arguments.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test14</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with 14 arguments.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test2</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with 2 arguments.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test3</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with 3 arguments.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test4</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with 4 arguments.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test5</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with 5 arguments.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test6</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with 6 arguments.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test7</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with 7 arguments.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test8</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with 8 arguments.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_test9</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with 9 arguments.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_bind_testn</code>: <b>PRIVATE</b> <br/>
 Provide a test sequence for <code>bdlf_bind</code> with N arguments.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_memfn</code>: <br/>
 Provide member function pointer wrapper classes and utility.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf_placeholder</code>: <br/>
 Provide a parameterized placeholder and specialized placeholders.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="related_packages_in_package_group_bdl"></a> <a class="anchor" id="description.related_packages_in_package_group_bdl"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Related Packages in Package Group bdl: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Package <code>bdlf</code> is designed to use three other packages in <code>bdl</code>. <code>bdlf</code> provides the primary interface that a client will see, and the other packages play supporting roles. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The packages are: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlf</code>: <br/>
 Provides functors to clients in a canonical form.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlfr</code>: <br/>
 This package is <em>DEPRECATED</em>. A common reference-counted base class, used by <code>bdlfi</code>. These classes provide reference counting and object deletion for derived classes.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlfi</code>: <br/>
 This package is <em>DEPRECATED</em>. Concrete reference-counted function objects, held and managed by a <code>bdlf</code> object; classes in <code>bdlfi</code> implement behavior declared in <code>bdlfr</code>.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <code>bdlfu</code>: <br/>
 This package is <em>DEPRECATED</em>. Factory method utilities to initialize <code>bdlf</code> functors by creating a reference-counted function object (from <code>bdlfi</code>) and assigning it to a <code>bdlf</code> functor. Subsequent invocations of the <code>bdlf</code> functor will be delegated to the <code>bdlfi</code> object.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="relationship_to_packages_in_bdl"></a> <a class="anchor" id="description.relationship_to_packages_in_bdl"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Relationship to Packages in bdl: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>bdlf</code>, <code>bdlfr</code>, <code>bdlfi</code>, and <code>bdlfu</code> packages provide identical functionality to the corresponding packages in the <code>bce</code> package group: <code>bcef</code>, <code>bcefr</code>, <code>bcefi</code>, and <code>bcefu</code>, respectively. The difference between the two sets of packages is that the <code>bce</code> packages provide thread safety, whereas the <code>bdl</code> packages do not. In particular, package <code>bcefr</code> implements reference counting via atomic operators provided in package <code>bces_atomicutil</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="functors_and_function_pointers"></a> <a class="anchor" id="description.functors_and_function_pointers"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Functors and Function Pointers: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Function pointers should be familiar to both C and C++ programmers. A function pointer is a pointer to a C-style function. In C++, the function pointer is declared to point to a function with a specific return type and a specific number of arguments of specific types. For instance, <br/>
<br/>
<div class="fragment"><pre class="fragment">  void (*fp)(int, <span class="keyword">const</span> <span class="keywordtype">char</span>*);
</pre></div><br/>
<br/>
 declares a function pointer <code>fp</code> that points to a function returning <code>void</code>, and taking exactly two arguments, an <code>int</code> and a const pointer to <code>char</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Assume, then, that we have one or more functions declared with the matching signature: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> f1(<span class="keywordtype">int</span> x, <span class="keyword">const</span> <span class="keywordtype">char</span>* s);
  <span class="keywordtype">void</span> f2(<span class="keywordtype">int</span> x, <span class="keyword">const</span> <span class="keywordtype">char</span>* s);
</pre></div><br/>
<br/>
 After assigning a value to the function pointer, we can call the corresponding function: <br/>
<br/>
<div class="fragment"><pre class="fragment">  fp = f1;
       .
       .
       .
  <span class="keywordtype">int</span> my_x = 0;
  <span class="keywordtype">int</span> my_s = <span class="stringliteral">&quot;Text String&quot;</span>;
  fp(my_x, my_s);          <span class="comment">// invokes function f1</span>
</pre></div><br/>
<br/>
 Functors are objects that behave syntactically and semantically like functions. Functors implement a function-call operator (<code>operator()</code>) whose signature characterizes the particular functor's type. In this example, for instance, we could define a functor like this: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyFunctor {
 Class MyFunctor can be used like a function.
       .
       .
       .
  <span class="keyword">public</span>:
      <span class="keywordtype">void</span> operator()(<span class="keywordtype">int</span> x, <span class="keyword">const</span> <span class="keywordtype">char</span>* s);
 <span class="keyword">this</span> provides invocation semantics
       .
       .
       .
  };

  MyFunctor fn;
       .
       .
       .
  <span class="keywordtype">int</span> my_x = 0;
  <span class="keywordtype">int</span> my_s = <span class="stringliteral">&quot;Text String&quot;</span>;
  fn(my_x, my_s);          <span class="comment">// &quot;invokes&quot; functor fn via fn::operator()</span>
</pre></div><br/>
<br/>
 Functors provide some interesting advantages over simple function pointers. Unlike a function pointer, a functor may be created with one or more arbitrary objects (sometimes called "user data") to be passed (typically as trailing arguments) to the underlying function. By "pre-binding" particular arguments to the underlying function, a functor can reduce the number of arguments a caller must supply when the functor is invoked. In this way, function objects can be used to coerce functions with extra arguments of arbitrary type into a standard calling signature. Even (non-'static') <em>member</em> functions can be encapsulated within functors and treated uniformly, simply by supplying the appropriate object at construction. Both the <em>object</em> pointer and a <em>member</em> <em>function</em> pointer are stored in the functor; the given object pointer is dereferenced when the functor is invoked. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="functors_in_the_bdlf_package"></a> <a class="anchor" id="description.functors_in_the_bdlf_package"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Functors in the bdlf package: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="signature-specific_functors"></a> <a class="anchor" id="functors_in_the_bdlf_package.signature-specific_functors"></a> <a class="anchor" id="description.functors_in_the_bdlf_package.signature-specific_functors"></a> <a class="anchor" id="3.6.1"></a> </dd></dl>
<dl class="user"><dt><b>Signature-Specific Functors: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Individual components are "numbered" to indicate the number of arguments (between 0 and 6) that a particular functor accepts. Each component defines a templated class, whose template parameters correspond in number to the functor arguments. When instantiated, the template argument types match the argument types used in invoking the functor. The component name is <code>bdlf_vfunc</code> followed by 0 to 6; the letter <code>v</code> indicates that the corresponding functor will return <code>void</code>. For the example above, we would use component <code>bdlf_vfunc2</code> to create a functor object whose <code>operator()</code> member function obeys the required signature. <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;bdlf_vfunc2.h&gt;</span>

      bdlf_Vfunc2&lt;int, const char*&gt; fn;  <span class="comment">// template arguments specify arg</span>
 types
 NOTE: This example is incomplete.
       We still need code to initialize <span class="stringliteral">&#39;fn&#39;</span>
      .
      .
      .
      <span class="keywordtype">int</span> my_x = 0;
      <span class="keywordtype">int</span> my_s = <span class="stringliteral">&quot;Text String&quot;</span>;
      fn(my_x, my_s);                    <span class="comment">// &quot;invokes&quot; functor fn</span>
</pre></div><br/>
<br/>
 Before a <code>bdlf</code> functor is invoked as illustrated, the client is responsible for ensuring that it is valid; that is, it must contain a pointer to a function that will be called when the functor is invoked. The function to be called is external to the functor, and supplied by the client. This "external
 function" may be a free function, a static class method, or a (non-'static') member function for some class. The client, then, needs a canonical mechanism, regardless of the function type, to create a reference to that function, and to bind the reference to the <code>bdlf</code> functor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The most common way to accomplish this is to use a "factory method" defined in the <code>bdlfu</code> package. The <code>bdlfu</code> package contains 10 components which provide these factory methods. Parallel to <code>bdlf</code>, these components are "numbered" to support functors with different numbers of arguments. The factory methods are also templatized to support varying argument types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Each <code>bdlfu</code> component contains 4 different types of factory methods, varying by the type of function pointer required. For example, <code>bdlfu_vfunc2</code> defines the following <em>factory</em> <em>method</em> <em>families</em>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bdlfu_Vfunc2::makeF();    <span class="comment">// generate a pointer to a free function</span>
 and <a class="code" href="namespacebdlat__ValueTypeFunctions.html#a8878d14342c51302d88f1c2e8d242a5e">assign</a> it to a <span class="stringliteral">&#39;bdlf_Vfunc2&#39;</span> <span class="keywordtype">object</span>
  bdlfu_Vfunc2::makeM();    <span class="comment">// generate a pointer to a member function</span>
 and <a class="code" href="namespacebdlat__ValueTypeFunctions.html#a8878d14342c51302d88f1c2e8d242a5e">assign</a> it to a <span class="stringliteral">&#39;bdlf_Vfunc2&#39;</span> <span class="keywordtype">object</span>
  bdlfu_Vfunc2::makeC()     <span class="comment">// generate a pointer to a const member</span>
 function and <a class="code" href="namespacebdlat__ValueTypeFunctions.html#a8878d14342c51302d88f1c2e8d242a5e">assign</a> it to a  &#39;bdlf_Vfunc2&#39;
 <span class="keywordtype">object</span>
  bdlfu_Vfunc2::makeNull(); <span class="comment">// initialize a &#39;bdlf_Vfunc2&#39; object with</span>
 an empty function
</pre></div><br/>
<br/>
 These factory methods (except for <code>makeNull</code>) are templatized to support different return and argument types; in addition, each <em>factory</em> <em>method</em> <em>family</em> consists of a set of overloaded functions that support varying numbers of arguments on the underlying functions (member or free). All classes returned by functions in component <code>bdlfu_vfunc2</code> are defined in component <code>bdlfi_vfunc2</code>. See package documentation for the <a href="group__bdlfu.html" class="el"><code>bdlfu</code></a> package for details. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For the simple example above, we would use component <code>bdlfu_Vfunc2</code> as follows to initialize the <code>bdlf_Vfunc2</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;bdlf_vfunc2.h&gt;</span>
<span class="preprocessor">  #include &lt;bdlfu_vfunc2.h&gt;</span>

      <span class="keywordtype">void</span> f1(<span class="keywordtype">int</span> x, <span class="keyword">const</span> <span class="keywordtype">char</span>* s);
      <span class="keywordtype">void</span> f2(<span class="keywordtype">int</span> x, <span class="keyword">const</span> <span class="keywordtype">char</span>* s);

      bdlf_Vfunc2&lt;int, const char*&gt; fn;  <span class="comment">// template arguments define arg types</span>
      bdlfu_Vfunc2::makeF(&amp;fn,f1);       <span class="comment">// bind functor fn to function f1</span>
         .
         .
         .
      <span class="keywordtype">int</span> my_x = 0;
      <span class="keywordtype">int</span> my_s = <span class="stringliteral">&quot;Text String&quot;</span>;
      fn(my_x, my_s);                    <span class="comment">// &quot;invokes&quot; functor fn</span>
</pre></div><br/>
<br/>
 The <code>bdlfu_Vfunc2::makeF</code> <em>factory</em> <em>method</em> in the above example expects two arguments. The first is a pointer to the functor object itself, and the second is a pointer to a free function with a signature matching the functor object, that is, expecting args of <code>int</code> and <code>const char*</code>, and returning <code>void</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>makeF()</code> functions create instances of classes from the <code>bdlfi</code> component; the specific classes are determined by the number and types of arguments on the <code>bdlf</code> functor and the free function. Similarly, class member functions can be used to initialize a <code>bdlf</code> functor by invoking a <code>bdlfu_Vfunc2::makeM()</code> or <code>bdlfu_Vfunc2::makeC()</code> function. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>bdlfu</code> and <code>bdlfi</code> packages will also allow clients to match a functor to a free or member function in situations where the function requires more arguments than the functor invocation can support. See the documentation for package <a href="group__bdlfu.html" class="el"><code>bdlfu</code></a> for details describing how to do this; see package documentation for <a href="group__bdlfi.html" class="el"><code>bdlfi</code></a> for implementation details. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that because each required argument type <code>T</code> is passed by (<code>const</code> <code>T&amp;</code>), a compiler will generate an error if the user declares a callback function taking an argument via a non-'const' reference parameter. This is intended to support and enforce the rule that all modifiable arguments are passed using pointers and not using references. For rare situations where clients want to use a callback function supplied by a third party, and that callback function uses non-'const' references, a wrapper function must be declared that converts non-'const' references to <code>const</code> references or pointers as appropriate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="envelope-letter_idiom"></a> <a class="anchor" id="functors_in_the_bdlf_package.envelope-letter_idiom"></a> <a class="anchor" id="description.functors_in_the_bdlf_package.envelope-letter_idiom"></a> <a class="anchor" id="3.6.2"></a> </dd></dl>
<dl class="user"><dt><b>Envelope-Letter Idiom: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The functors in the <code>bdlf</code> package are implemented using the envelope-letter idiom. The classes in <code>bdlf</code> are <em>"envelopes"</em>; classes in <code>bdlfr</code> and <code>bdlfi</code> are <em>"letters"</em>. The use of the envelope-letter idiom allows clients to wrap arbitrary functions, whose signatures may differ from the function signatures in <code>bdlf</code>, with functors that support standard, well-known signatures. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Each <code>bdlf_Vfunc*</code> functor <em>(envelope)</em> holds a pointer to an object <em>(letter)</em> from the corresponding <code>bdlfi_vfunc*</code> component. The <code>bdlf</code> <em>envelope</em> forwards or delegates client requests to its <em>letter</em> object: in particular, the <code>operator()</code> member function used by clients to invoke the functor is delegated to the <em>letter</em> object for execution. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <em>letter</em> object is polymorphic: all <em>letter</em> classes in a given <code>bdlfi</code> component are derived from a common protocol or abstract base class (defined in <code>bdlfr</code>). The <code>bdlf</code> <em>envelope</em> uses the abstract <code>bdlfr</code> protocol to delegate invocation requests. Different polymorphic <em>letter</em> types are used to support different external function types and signatures, and the single <em>envelope</em> type is used to provide a consistent function signature to clients. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Since polymorphism is used to support different bindings to external member or free functions, clients must be able to generate a specific type of <em>letter</em> object for a given <em>envelope</em>, based upon the type and signature of the specific external function. This may be done directly through public interfaces of the corresponding <code>bdlfi</code> component, but in most cases it is simpler to use a suite of template functions provided by the corresponding <code>bdlfu</code> package. Different template functions are provided to match (1) the desired function-call-operator signature and (2) the supplied user data. Because the C++ compiler will deduce template parameters from argument types, clients need not specify them. See the <a href="group__bdlfu.html" class="el"><code>bdlfu</code></a> package for more information on populating <code>bdlf</code> functors with specific <em>letter</em> objects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>See also J.O. Coplien, "Advanced Programming Styles and Idioms", Sections 5.5-5.6, for a complete discussion of the envelope/letter idiom. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="binders"></a> <a class="anchor" id="functors_in_the_bdlf_package.binders"></a> <a class="anchor" id="description.functors_in_the_bdlf_package.binders"></a> <a class="anchor" id="3.6.3"></a> </dd></dl>
<dl class="user"><dt><b>Binders: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>bdlf_bind</code> component provides a mechanism for creating function objects different from the <code>bdlf_vfunc*</code> components. <code>bdlf_bind</code> is used to <em>adapt</em> an invocable object so that it conforms to a different interface and can be invoked with fewer arguments and/or with the arguments in a different order. It does this by <em>binding</em> some or all of the original invocable's arguments to fixed values that are known at construction time and binding the remaining arguments to placeholders for arguments that are provided at invocation time. A binder can be used as an argument for any template function that requires an invocable with compatible parameters. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>bdlf_bind</code> component defines binder objects and factory methods that can bind any arguments into a functor in any order, enabling some of the arguments of the invocable to be specified at the construction time, and leaving (via place-holders, defined in component <code>bdlf_placeholder</code>) some others to be specified (later) at invocation time. A binder is created by one of the three <em>factory</em> <em>method</em> <em>families</em> defined in component <code>bdlf_bind</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  bdlf_BindUtil::bind();   <span class="comment">// generate a binder with specified invocable and</span>
 bound arguments (invocation arguments are
 indicated by place-holders)
  bdlf_BindUtil::bindA();  <span class="comment">// same as above but also specify the allocator</span>
 used to supply memory for creating the binder
  bdlf_BindUtil::bindR();  <span class="comment">// same as &#39;bdlf_BindUtil::bind()&#39; but explicitly</span>
 specify the return type (in case it cannot be
 deduced by the compiler but should not be left
 undefined)
</pre></div><br/>
<br/>
 Binders where the signature of the invocable can be deduced are called <em>explicit</em>. Not all binders are explicit. For non-explicit binders, the signature of a <code>bdlf_Bind</code> object is not embedded in the type, and several overloads can be invoked through the same binder. Unlike <code>bdlf_Vfunc*</code> objects, different binders accepting the same signature may have different types depending on the types of the bound arguments if they are non-explicit. The return type (not necessarily void) is also part of the signature. Thus, <code>bdlf_bind</code> provides compile-time polymorphism but not run-time polymorphism. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A broad discussion of binding, along with limitations of the 'usage examples, can be found in the component documentation of component <code>bdlf_bind</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="general_(run-time_polymorphic)_function_objects"></a> <a class="anchor" id="functors_in_the_bdlf_package.general_(run-time_polymorphic)_function_objects"></a> <a class="anchor" id="description.functors_in_the_bdlf_package.general_(run-time_polymorphic)_function_objects"></a> <a class="anchor" id="3.6.4"></a> </dd></dl>
<dl class="user"><dt><b>General (Run-Time Polymorphic) Function Objects: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition to signature-specific objects and binders, the <code>bdlf</code> package provides a run-time polymorphic <code>bdlf_Function</code> template. A <code>bdlf_Function</code> instantiation is capable of holding <em>any</em> invocable object of compatible prototype, including a function pointer, <code>bdlf_MemFn</code> wrapper, any concrete implementation of the 'bdlfr_Vfunc*'protocols, any instances of the <code>bdlf_Vfunc</code> family, and any other function object having an <code>operator()</code> method including an instance of a <code>bdlf_Bind</code> instantiation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Like a binder, a <code>bdlf_Function</code> instantiation can have a return value (or return <code>void</code>). An instance does not store bound arguments directly. It accepts all its arguments at invocation time only, although using polymorphic representations and the <code>bdlfu_Vfunc*make*</code> factory methods, it is possible to bind the last arguments of an invocable and wrap this into a <code>bdlf_Function</code> object which will then accept only the remaining arguments upon invocation. As mentioned above, it is also possible to assign a <code>bdlf_Bind</code> object to a <code>bdlf_Function</code> instance to bind and route arguments to the invocable in an arbitrary manner. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Unlike a binder, the signature of a <code>bdlf_Function</code> object is part of the type and invocation arguments are cast to their corresponding type before they are passed to the invocable. Most importantly, the same functor may be assigned from various types (pointer to function, <code>bdlf_MemFn</code> wrapper, user-defined function objects, or even <code>bdlf_Bind</code> binders). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="functors_and_binders"></a> <a class="anchor" id="functors_in_the_bdlf_package.functors_and_binders"></a> <a class="anchor" id="description.functors_in_the_bdlf_package.functors_and_binders"></a> <a class="anchor" id="3.6.5"></a> </dd></dl>
<dl class="user"><dt><b>Functors and Binders: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bdlf_Function</code> objects (functors) and <code>bdlf_Bind</code> objects (binders) are both mechanisms for binding arguments and calling an invocable. They differ in their purpose, though. In the last section, we detailed the main features of the <code>bdlf_function</code> and <code>bdlf_bind</code> components. In this section we point out the differences, and how they interact. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The main difference is compile-time (for <code>bdlf_bind</code>) vs. run-time (for <code>bdlf_function</code>) polymorphism. An instantiation of <code>bdlf_Function</code> is a type of functor that can hold any invocable object with compatible prototype. Regardless of what type of (compatible) invocable is used to create the <code>bdlf_Function</code>, the type of the resulting functor does not change. Thus, <code>bdlf_Function</code> has run-time polymorphism and is ideally suited for callbacks because it <em>adapts</em> the invocable to the callback interface. Run-time polymorphism is extremely useful for defining callback types and storing callbacks, since passing a new type of callback does not require re-compilation. Compile-time polymorphism provides the ability to invoke several overloads through the same functor (binder) and to bind and route arguments to the invocable in an arbitrary manner. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In cases where both binders and functors could be used, <code>bdlf_Function</code> has certain advantages, not least of which is simplicity (leading to shorter compilation times), and the memory optimization documented below, whereby small objects are constructed in-place but larger objects are dynamically allocated. Note that binders are always constructed in-place and can have rather large footprints. Functors (including instances of <code>bdlfr_Vfunc*</code> derived types) can implement various strategies like sharing and copy-on-write to reduce the cost of copying and the footprint at the same time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>bdlf</code>-style functors provide a type-neutral, exception-safe (and <em>potentially</em>, but not yet, thread-safe) <em>properly</em> <em>managed</em> alternative to the traditional callback paradigm (where "client data" is placed in a single structure whose address is cast to type <code>void *</code>). The following example illustrates how functor callbacks can be added to a graphical object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Let's suppose that the implementor of the <code>MyGuiButton</code> class allows the client to specify a callback function that should be called whenever a button is pressed. Furthermore, the implementor agrees to provide to the callback function two arguments at its invocation: a modifiable object of type <code>MyGuiContext</code>, and a non-modifiable object of type <code>MyGuiLocation</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyGuiContext {
      <span class="keywordtype">int</span> d_changedFlag;

    <span class="keyword">public</span>:
      MyGuiContext() : d_changedFlag(0) { }
      <span class="keywordtype">int</span> isChanged() { <span class="keywordflow">return</span> d_changedFlag; }
      <span class="keywordtype">void</span> changeState() { ++d_changedFlag; }

 <span class="stringliteral">&#39;MyGuiContext&#39;</span> implementation
  };

  <span class="keyword">class </span>MyGuiLocation {
    <span class="keyword">public</span>:
      MyGuiLocation() { };

 <span class="stringliteral">&#39;MyGuiLocation&#39;</span> implementation
  };
</pre></div><br/>
<br/>
 Here is the implementation of the <code>MyGuiButton</code> class: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyGuiButton  {
      bdlf_Vfunc2&lt;MyGuiContext *, MyGuiLocation&gt; d_callback;
 Functor to execute when button is pressed.

    <span class="keyword">public</span>:
      MyGuiButton(<span class="keyword">const</span> bdlf_Vfunc2&lt;MyGuiContext *,
                  MyGuiLocation&gt;&amp; buttonPressCallback);
 Create a graphical button <span class="keywordtype">object</span> that executes the
 specified callback when <span class="stringliteral">&#39;pressButton&#39;</span> is invoked.

      <span class="keywordtype">void</span> pressButton(MyGuiContext *context,
                       <span class="keyword">const</span> MyGuiLocation&amp; location);
 Execute the callback owned by <span class="keyword">this</span> button <span class="keywordtype">object</span>.
  };

  MyGuiButton::MyGuiButton(<span class="keyword">const</span> bdlf_Vfunc2&lt;MyGuiContext *,
                           MyGuiLocation&gt;&amp; buttonPressCallback)
  : d_callback(buttonPressCallback) <span class="comment">// Retain a &quot;copy&quot; of the specified</span>
 functor.
  {
  }

  <span class="keywordtype">void</span> MyGuiButton::pressButton(MyGuiContext *context,
                                <span class="keyword">const</span> MyGuiLocation&amp; location)
  {
      d_callback(context, location);
 Execute the contained callback <span class="keywordtype">object</span>.
  }
</pre></div><br/>
<br/>
 The <code>context</code> and <code>location</code> arguments are mandatory for every function called at the press of the button (the number <code>2</code> in the name of <code>bdlf_Vfunc2</code> class specifies the number of required arguments). However, we also allow the user of <code>MyGuiButton</code> class to invoke the function with a number of additional parameters, as in the <code>buttonpressFunction</code> function presented below. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> buttonpressFunction(MyGuiContext *a,
                                  <span class="keyword">const</span> MyGuiLocation&amp; b,
                                  <span class="keywordtype">int</span> *invocationCounter)
 This function will be invoked by a functor to increment the
 specified <span class="stringliteral">&#39;invocationCounter&#39;</span>.
  {
          a-&gt;changeState();
          ++*invocationCounter;
  }
</pre></div><br/>
<br/>
 The <code>bdlf_Vfunc2&lt;MyGuiContext, MyGuiLocation&gt;</code> class used in <code>MyGuiButton</code> class has a private member of an abstract class <code>bdlfr_vfunc2</code>, whose <code>execute</code> method is called when the functor is being called. The <code>execute</code> method of the <code>bdlfr_vfunc2</code> class, the functor invocation operator of the <code>bdlf_Vfunc2</code> class, and the <code>pressButton</code> method of <code>MyGuiButton</code> class have two parameters. The <code>buttonpressFunction</code> callback function, however, has to be called with three arguments. To achieve the proper calling signature the user implements a concrete class derived from <code>bdlfr_vfunc2</code> as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> F, <span class="keyword">class</span> A1, <span class="keyword">class</span> A2, <span class="keyword">class</span> D1&gt;
  <span class="keyword">class </span>FuncRep : <span class="keyword">public</span> bdlfr_Vfunc2&lt;A1, A2&gt; {
 This <span class="keyword">class </span>defines the representation for a function object (functor),
 characterized by a function-call operator taking two arguments and
 returning &#39;void&#39;, that holds a pure procedure (i.e., free function,
 static member function, or functor) taking one additional trailing
 argument, and this argument&#39;s corresponding value.

      <a class="code" href="bdlf__bind__test_8h.html#a668ca44fb0cff177991f91ee5d5c1068">F</a>  d_f;  <span class="comment">// function pointer or function object (functor)</span>
      D1 d_d1; <span class="comment">// first embedded argument</span>

    <span class="keyword">private</span>:
 not implemented
      FuncRep(<span class="keyword">const</span> FuncRep&lt;F, A1, A2, D1&gt;&amp;);
      FuncRep&lt;F, A1, A2, D1&gt;&amp; operator=(<span class="keyword">const</span> FuncRep&lt;F, A1, A2, D1&gt;&amp;);

    <span class="keyword">private</span>:
      ~FuncRep()
 Destroy this functor.  Note that destructor can be invoked only
 through the static &#39;deleteObject&#39; method of the base class.
      {
      };

    <span class="keyword">public</span>:
 CREATORS
      FuncRep(<span class="keyword">const</span> <a class="code" href="bdlf__bind__test_8h.html#a668ca44fb0cff177991f91ee5d5c1068">F</a>&amp;         procedure,
              <span class="keyword">const</span> D1&amp;        embeddedArg1,
              bdlma_Allocator *basicAllocator)
 Create a representation <span class="keywordflow">for</span> a function object (functor) taking two
 arguments and returning &#39;<span class="keywordtype">void</span>&#39;, using the specified &#39;procedure&#39;
 taking 1 additional trailing argument, and this argument&#39;s
 specified &#39;embeddedArg1&#39; value.  Use the specified
 &#39;basicAllocator&#39; to supply memory.
      : bdlfr_Vfunc1&lt;A1, A2&gt;(basicAllocator)
      , d_f(procedure)
      , d_d1(embeddedArg1)
      {
      };

 ACCESSORS
      <span class="keywordtype">void</span> execute(<span class="keyword">const</span> A1&amp; argument1, <span class="keyword">const</span> A2&amp; argument2) <span class="keyword">const</span>
 Invoke the underlying procedure (free function, <span class="keyword">static</span> member
 function, or functor) with the specified <span class="stringliteral">&#39;argument1&#39;</span> and
 <span class="stringliteral">&#39;argument2&#39;</span> followed by the argument value specified at
 construction.
      {
          d_f(argument1, argument2, d_d1);
      };
  };
</pre></div><br/>
<br/>
 Note that the required arguments are passed in at the functor invocation, and optional arguments are passed in at the functor initialization. By BDE convention, a function signature consists of output parameters, and then input parameters. Since here we have two parameter lists (one passed in by the caller, and one passed in by the callee) we can follow this convention within each list only. We choose to pass in first the required arguments (passed by the caller) and then the optional arguments (supplied by the callee). This order allows a callee to add parameters easily at the end of the function parameter list. The number of required parameters is a part of the <code>MyGuiButton</code> interface, and hence will never change. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following code shows how we: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
Create the functor representation-(letter).  </li>
<li>
Create the functor initialized with the representation.  </li>
<li>
Register the functor as a callback with an instance of the <code>MyGuiButton</code> class.  </li>
<li>
Invoke the functor.  </li>
</ol>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The code is as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment"> (1) Create the representation.

  <span class="keyword">typedef</span> void (*BpFun)(<span class="keyword">const</span> MyGuiContext *, <span class="keyword">const</span> MyGuiLocation&amp;, <span class="keywordtype">int</span> *);
  bdlma_Allocator *myAllocator = bdlma_Default::defaultAllocator();

  <span class="keywordtype">int</span> globalCounter = 0;

  bdlfr_Vfunc2&lt;MyGuiContext *, MyGuiLocation&gt;  *rep = <span class="keyword">new</span>(myAllocator)
      FuncRep&lt;BpFun, MyGuiContext *, MyGuiLocation, int*&gt;
          (buttonpressFunction, &amp;globalCounter, myAllocator);

 (2) Create the functor <span class="keyword">using</span> the representation.

  bdlf_Vfunc2&lt;MyGuiContext *, MyGuiLocation&gt; callbackFunctor(rep);

 (3) Register the functor as a callback.

  MyGuiButton button(callbackFunctor);

 (4) Use the <span class="keywordtype">object</span>.

  MyGuiContext gc;
  <span class="keyword">const</span> MyGuiLocation gl;             assert(0 == globalCounter);
                                      assert(0 == gc.isChanged());
  button.pressButton(&amp;gc, gl);        assert(1 == globalCounter);
                                      assert(1 == gc.isChanged());
  button.pressButton(&amp;gc, gl);        assert(2 == globalCounter);
                                      assert(2 == gc.isChanged());
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:43 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
