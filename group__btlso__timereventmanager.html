<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlso_timereventmanager Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlso_timereventmanager<br/>
<small>
[<a class="el" href="group__btlso.html">Package btlso</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a protocol for multiplexing sockets events and timers.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlso.html">btlso</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Implementing a Timed Socket Multiplexer</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a protocol for multiplexing sockets events and timers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> </td><td>socket event/timer multiplexer protocol  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a></code> class provides the interface for an event manager that supports the registration of both timers and socket events, each along with an associated <code>bsl::function</code> callback functor, which is invoked when the corresponding timer expires or the socket event occurs. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Timers are single shot and are registered by specifying the (earliest) time (as a <code><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a></code>) at which the timer callback should be invoked. A unique ID for the timer is returned when the registration succeeds. Timers can be deregistered at any time before the timer expires by using this ID. When a timer expires, the associated callback is invoked and this timer is automatically deregistered. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Socket event registrations specify a socket handle and the type of event to monitor on the specified socket. Socket event registrations stay in effect until they are subsequently deregistered; the callback is invoked each time the specified socket event occurs. Note that <code><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">btlso::EventType::e_READ</a></code> and <code><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">btlso::EventType::e_WRITE</a></code> are the only events that can be registered simultaneously for a socket. Otherwise only a single socket event can be registered for a particular socket. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_implementing_a_timed_socket_multiplexer"></a> <a class="anchor" id="usage.example_1~3A_implementing_a_timed_socket_multiplexer"></a> <a class="anchor" id="description.usage.example_1~3A_implementing_a_timed_socket_multiplexer"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Implementing a Timed Socket Multiplexer: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example illustrates the implementation of periodic timed socket events using the (separate) timer and socket event registration mechanisms provided by <code><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a></code>, such that a user-specified callback is invoked with different codes depending on whether the socket event occurs before the specified timeout or not. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The interface for such functionality is provided by the class <code>my_TimedSocketMultiplexer</code>, which registers each specified socket event and an associated timer with an instance of <code><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the socket event occurs before the corresponding timer expires, <code><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a></code> invokes the socket event callback. Within this callback <code>my_TimedSocketMultiplexer</code> cancels the current timer and registers a new timer to expire after the specified period in order to wait for the next occurrence of the same socket event. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the timer expires before the socket event occurs <code><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a></code> invokes the timer callback. Within this callback <code>my_TimedSocketMultiplexer</code> registers a new timer to expire after the specified period, thus periodically rescheduling the timer until the socket event is seen (this behavior is for illustration only and real application code may handle such timeouts differently). </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>my_TimedSocketMultiplexer</code> uses the helper class <code>my_TimerInfo</code> to store the timer information associated with a socket/event pair (represented as a <code><a class="el" href="classbtlso_1_1Event.html">btlso::Event</a></code>) and internally maintains a mapping of <code><a class="el" href="classbtlso_1_1Event.html">btlso::Event</a></code> instances to <code>my_TimerInfo</code> instances (in a <code><a class="el" href="classbsl_1_1unordered__map.html">bsl::unordered_map</a></code>). <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>my_TimerInfo {
     <span class="comment">// This is a helper class that stores information about the timer</span>
     <span class="comment">// associated with a socket/event pair (an instance of &#39;btlso::Event&#39;).</span>

     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> my_TimerInfo&amp; lhs,
                            <span class="keyword">const</span> my_TimerInfo&amp; rhs);
         <span class="comment">// This class supports only in-core value semantics.</span>

   <span class="keyword">private</span>:
     <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>  d_expiryTime; <span class="comment">// current expiry time of the timer</span>
     <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>  d_period;     <span class="comment">// period of the (recurrent) timer</span>
     <span class="keywordtype">void</span>               *d_id;         <span class="comment">// unique timer identifier</span>

   <span class="keyword">public</span>:
     <span class="comment">// CREATORS</span>
     my_TimerInfo();
         <span class="comment">// Create a default &#39;my_TimerInfo&#39; instance.  Note that such a</span>
         <span class="comment">// default constructor might be required, e.g., for values stored in</span>
         <span class="comment">// &#39;bsl::unordered_map&#39;.</span>

     my_TimerInfo(<span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp;  expiryTime,
                  <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp;  period,
                  <span class="keywordtype">void</span>                      *<span class="keywordtype">id</span>);
         <span class="comment">// Create a &#39;my_TimerInfo&#39; containing the specified &#39;expiryTime&#39;,</span>
         <span class="comment">// &#39;period&#39;, and &#39;id&#39;.</span>

     ~my_TimerInfo();
         <span class="comment">// Destroy this object.</span>

     <span class="comment">// MANIPULATORS</span>
     <span class="keywordtype">void</span> setExpiryTime(<span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp; expiryTime);
         <span class="comment">// Set the specified &#39;expiryTime&#39;.</span>

     <span class="keywordtype">void</span> setPeriod(<span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp; period);
         <span class="comment">// Set the specified &#39;period&#39;.</span>

     <span class="keywordtype">void</span> setId(<span class="keywordtype">void</span> *<span class="keywordtype">id</span>);
         <span class="comment">// Set the specified &#39;id&#39;.</span>

     <span class="comment">// ACCESSORS</span>
     <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp; expiryTime() <span class="keyword">const</span>;
         <span class="comment">// Return a reference to the timer&#39;s expiry time.</span>

     <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp; period() <span class="keyword">const</span>;
         <span class="comment">// Return a reference to the timer&#39;s period.</span>

     <span class="keyword">const</span> <span class="keywordtype">void</span> *id() <span class="keyword">const</span>;
         <span class="comment">// Return the timer&#39;s ID.</span>
 };

 <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> my_TimerInfo&amp; lhs, <span class="keyword">const</span> my_TimerInfo&amp; rhs);
     <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; timer information</span>
     <span class="comment">// objects have the same value, and &#39;false&#39; otherwise.  Two timer</span>
     <span class="comment">// information objects have the same value if they have the same</span>
     <span class="comment">// respective values of expiry time, period, and ID.</span>

 my_TimerInfo::my_TimerInfo()
 {
 }

 my_TimerInfo::my_TimerInfo(<span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp;  expiryTime,
                            <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp;  period,
                            <span class="keywordtype">void</span>                      *<span class="keywordtype">id</span>)
 : d_expiryTime(expiryTime)
 , d_period(period)
 , d_id(id)
 {
 }

 my_TimerInfo::~my_TimerInfo()
 {
 }

 <span class="keywordtype">void</span> my_TimerInfo::setExpiryTime(<span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp; expiryTime)
 {
     d_expiryTime = expiryTime;
 }

 <span class="keywordtype">void</span> my_TimerInfo::setPeriod(<span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp; period)
 {
     d_period = period;
 }

 <span class="keywordtype">void</span> my_TimerInfo::setId(<span class="keywordtype">void</span> *<span class="keywordtype">id</span>)
 {
     d_id = id;
 }

 <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp; my_TimerInfo::expiryTime()<span class="keyword"> const</span>
<span class="keyword"> </span>{
     <span class="keywordflow">return</span> d_expiryTime;
 }

 <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp; my_TimerInfo::period()<span class="keyword"> const</span>
<span class="keyword"> </span>{
     <span class="keywordflow">return</span> d_period;
 }

 <span class="keyword">const</span> <span class="keywordtype">void</span> *my_TimerInfo::id()<span class="keyword"> const</span>
<span class="keyword"> </span>{
     <span class="keywordflow">return</span> d_id;
 }

 <span class="keywordtype">bool</span> <a class="code" href="namespacebalb.html#a43eb69dcb057a13f6d636c27339604e0">operator==</a>(<span class="keyword">const</span> my_TimerInfo&amp; lhs, <span class="keyword">const</span> my_TimerInfo&amp; rhs)
 {
     <span class="keywordflow">return</span> lhs.expiryTime() == rhs.expiryTime()
            &amp;&amp; lhs.period()  == rhs.period()
            &amp;&amp; lhs.id()      == rhs.id();
 }

 <span class="keyword">class </span>my_TimedSocketMultiplexer {
     <span class="comment">// This class implements a subset of a socket event multiplexer that</span>
     <span class="comment">// supports the registration of timed socket events and associated</span>
     <span class="comment">// callbacks.  Specifically, this class allows a user specified</span>
     <span class="comment">// &#39;bsl::function&lt;void(my_TimedSocketMultiplexer::CallbackCode)&gt;&#39;</span>
     <span class="comment">// functor to be registered via the &#39;registerTimedSocketEvent&#39; method.</span>
     <span class="comment">// This functor is invoked with an argument of</span>
     <span class="comment">// &#39;my_TimedSocketMultiplexer::e_SOCKET_EVENT&#39; if the socket event</span>
     <span class="comment">// occurs before the timeout interval or with an argument of</span>
     <span class="comment">// &#39;my_TimedSocketMultiplexer::e_TIMEOUT&#39; when the timeout occurs</span>
     <span class="comment">// before an occurrence of the specified socket event.  Each time the</span>
     <span class="comment">// callback is invoked, the timer is rescheduled to expire</span>
     <span class="comment">// after the specified time period.</span>

   <span class="keyword">public</span>:

     <span class="comment">// TYPES</span>
     <span class="keyword">enum</span> CallbackCode {
         <span class="comment">// Enumerations used to indicate the reason the user callback</span>
         <span class="comment">// functor is being invoked.</span>

         e_SOCKET_EVENT = 0,  <span class="comment">// The specified socket event has occurred.</span>
         e_TIMEOUT      = 1   <span class="comment">// The timer has expired before the specified</span>
                              <span class="comment">// socket event occurred.</span>
     };

   <span class="keyword">private</span>:
     <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1unordered__map.html">bsl::unordered_map&lt;btlso::Event, my_TimerInfo, btlso::EventHash&gt;</a>
                                             EventTimeMap;

     EventTimeMap                            d_eventTimeMap;

     <a class="code" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a>               *d_manager_p;

   <span class="keyword">private</span>:
     <span class="comment">// Private methods &#39;eventCb&#39; and &#39;timerCb&#39; are internal callback member</span>
     <span class="comment">// functions registered with &#39;btlso::TimerEventManager&#39;.</span>

     <span class="keywordtype">void</span> eventCb(<span class="keyword">const</span> <a class="code" href="classbtlso_1_1Event.html">btlso::Event</a>&amp;                       socketEvent,
                  <span class="keyword">const</span> bsl::function&lt;<span class="keywordtype">void</span>(CallbackCode)&gt;&amp;  userCb,
                  <span class="keyword">const</span> <a class="code" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">btlso::TimerEventManager::Callback</a>&amp; internalCb);
         <span class="comment">// Cancel the current timer and register a new timer to expire</span>
         <span class="comment">// after the specified period from the current time along with the</span>
         <span class="comment">// internal timer callback functor &#39;internalCb&#39; to be invoked when</span>
         <span class="comment">// the timer expires.  Invoke the user specified callback &#39;userCb&#39;</span>
         <span class="comment">// with the argument &#39;my_TimedSocketMultiplexer::e_SOCKET_EVENT&#39;.</span>
         <span class="comment">// Note that this method is registered as a callback with</span>
         <span class="comment">// &#39;btlso::TimerEventManager&#39; and is invoked to indicate the</span>
         <span class="comment">// occurrence of the specified socket event &#39;socketEvent&#39;.</span>

     <span class="keywordtype">void</span> timerCb(<span class="keyword">const</span> <a class="code" href="classbtlso_1_1Event.html">btlso::Event</a>&amp;                       socketEvent,
                  <span class="keyword">const</span> bsl::function&lt;<span class="keywordtype">void</span>(CallbackCode)&gt;&amp;  userCb,
                  <span class="keyword">const</span> <a class="code" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">btlso::TimerEventManager::Callback</a>&amp; internalCb);
         <span class="comment">// Register a new timer to expire after the specified time period</span>
         <span class="comment">// measured from the previous timer&#39;s expiry time along with</span>
         <span class="comment">// the internal timer callback functor &#39;internalCb&#39; to be</span>
         <span class="comment">// invoked when the new timer expires.  Invoke the user</span>
         <span class="comment">// specified callback &#39;userCb&#39; with the argument</span>
         <span class="comment">// &#39;my_TimedSocketMultiplexer::e_TIMEOUT&#39;.  Note that &#39;timerCb&#39; is</span>
         <span class="comment">// registered as a callback with &#39;btlso::TimerEventManager&#39; and is</span>
         <span class="comment">// invoked to indicate the expiry of the timer associated with the</span>
         <span class="comment">// specified socket event &#39;socketEvent&#39;.</span>

   <span class="keyword">public</span>:
     <span class="comment">// CREATORS</span>
     my_TimedSocketMultiplexer(<a class="code" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *manager_p);
         <span class="comment">// Create an empty multiplexer object.</span>

     <span class="comment">// MANIPULATORS</span>
     <span class="keywordtype">int</span> registerTimedSocketEvent(
                       <span class="keyword">const</span> <a class="code" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a>&amp;       handle,
                       <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">btlso::EventType::Type</a>                   event,
                       <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp;                period,
                       <span class="keyword">const</span> bsl::function&lt;<span class="keywordtype">void</span>(CallbackCode)&gt;&amp; userCb);
         <span class="comment">// Register the specified &#39;userCb&#39; functor to be invoked whenever</span>
         <span class="comment">// the specified &#39;event&#39; occurs on the specified &#39;handle&#39; or when</span>
         <span class="comment">// &#39;event&#39; has not occurred within the specified &#39;period&#39; of time.</span>
         <span class="comment">// Return 0 on successful registration, and a nonzero value</span>
         <span class="comment">// otherwise.</span>

     <span class="keywordtype">int</span> deregisterTimedSocketEvent(<span class="keyword">const</span> SocketHandle::Handle&amp; handle,
                                    EventType::Type             event);
         <span class="comment">// Deregister the callback associated with the specified &#39;handle&#39;</span>
         <span class="comment">// and &#39;event&#39;.  Return 0 on successful deregistration and a</span>
         <span class="comment">// nonzero value otherwise.</span>
 };

 <span class="keywordtype">void</span> my_TimedSocketMultiplexer::eventCb(
                   <span class="keyword">const</span> <a class="code" href="classbtlso_1_1Event.html">btlso::Event</a>&amp;                       socketEvent,
                   <span class="keyword">const</span> bsl::function&lt;<span class="keywordtype">void</span>(CallbackCode)&gt;&amp;  userCb,
                   <span class="keyword">const</span> <a class="code" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">btlso::TimerEventManager::Callback</a>&amp; internalCb)
 {
     <span class="comment">// Retrieve the timer information associated with &#39;socketEvent&#39;.</span>

     EventTimeMap::iterator socketEventIt = d_eventTimeMap.find(socketEvent);
     ASSERT(d_eventTimeMap.end() != socketEventIt);
     my_TimerInfo *timerInfo = &amp;socketEventIt-&gt;second;

     <span class="comment">// Deregister the current timer callback.</span>

     d_manager_p-&gt;deregisterTimer(timerInfo-&gt;id());

     <span class="comment">// Set the new timeout value.</span>

     timerInfo-&gt;setExpiryTime(<a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>()
                                                      + timerInfo-&gt;period());

     <span class="comment">// Register a new timer callback to fire at this time.</span>

     timerInfo-&gt;setId(
            d_manager_p-&gt;registerTimer(timerInfo-&gt;expiryTime(), internalCb));

     <span class="comment">// Invoke userCb with an argument of &#39;e_SOCKET_EVENT&#39; to indicate that</span>
     <span class="comment">// &#39;socketEvent&#39; has occurred.</span>

     userCb(e_SOCKET_EVENT);
 }

 <span class="keywordtype">void</span> my_TimedSocketMultiplexer::timerCb(
                   <span class="keyword">const</span> <a class="code" href="classbtlso_1_1Event.html">btlso::Event</a>&amp;                       socketEvent,
                   <span class="keyword">const</span> bsl::function&lt;<span class="keywordtype">void</span>(CallbackCode)&gt;&amp;  userCb,
                   <span class="keyword">const</span> <a class="code" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">btlso::TimerEventManager::Callback</a>&amp; internalCb)
 {
     <span class="comment">// Retrieve the timer information associated with &#39;socketEvent&#39; and set</span>
     <span class="comment">// the new expiry time.</span>

     EventTimeMap::iterator socketEventIt = d_eventTimeMap.find(socketEvent);
     ASSERT(d_eventTimeMap.end() != socketEventIt);
     my_TimerInfo *timerInfo = &amp;socketEventIt-&gt;second;
     timerInfo-&gt;setExpiryTime(timerInfo-&gt;expiryTime() + timerInfo-&gt;period());

     <span class="comment">// Register a new timer callback to fire at that time.</span>

     timerInfo-&gt;setId(d_manager_p-&gt;registerTimer(timerInfo-&gt;expiryTime(),
                                                 internalCb));

     <span class="comment">// Invoke user callback functor with an argument of &#39;e_TIMEOUT&#39; to</span>
     <span class="comment">// indicate that a timeout has occurred before &#39;socketEvent&#39;.</span>

     userCb(e_TIMEOUT);
 }

 my_TimedSocketMultiplexer::my_TimedSocketMultiplexer(
                                         <a class="code" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *manager_p)
 : d_eventTimeMap()
 , d_manager_p(manager_p)
 {
 }

 <span class="keywordtype">int</span> my_TimedSocketMultiplexer::registerTimedSocketEvent(
                        <span class="keyword">const</span> <a class="code" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a>&amp;       handle,
                        <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">btlso::EventType::Type</a>                   event,
                        <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>&amp;                period,
                        <span class="keyword">const</span> bsl::function&lt;<span class="keywordtype">void</span>(CallbackCode)&gt;&amp; userCb)
 {
     <a class="code" href="classbtlso_1_1Event.html">btlso::Event</a> socketEvent(handle, event);
     <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> expiryTime = <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + period;

     <span class="comment">// Create a timer callback.</span>

  <a class="code" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">btlso::TimerEventManager::Callback</a> myTimerCb;
  myTimerCb = <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
           <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_TimedSocketMultiplexer::timerCb, <span class="keyword">this</span>),
           socketEvent,
           userCb,
           myTimerCb);

     <span class="comment">// Create an event callback.</span>

    <a class="code" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">btlso::TimerEventManager::Callback</a> myEventCb(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
           <a class="code" href="structbdlf_1_1MemFnUtil.html#a0dcdd52df79fd790101e96068b7d4610">bdlf::MemFnUtil::memFn</a>(&amp;my_TimedSocketMultiplexer::eventCb, <span class="keyword">this</span>),
           socketEvent,
           userCb,
           myTimerCb));

     <span class="comment">// Register the event callback.</span>

     d_manager_p-&gt;registerSocketEvent(handle, event, myEventCb);

     <span class="comment">// Register the timer callback.</span>

     <span class="keywordtype">void</span> *timerHandle = d_manager_p-&gt;registerTimer(expiryTime, myTimerCb);

     <span class="comment">// Save the timer information associated with this event in the map.</span>

     my_TimerInfo timerInfo(expiryTime, period, timerHandle);
     d_eventTimeMap.insert(bsl::make_pair(socketEvent, timerInfo));

     <span class="keywordflow">return</span> 0;
 }

 <span class="keywordtype">int</span> my_TimedSocketMultiplexer::deregisterTimedSocketEvent(
                                   <span class="keyword">const</span> <a class="code" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a>&amp; handle,
                                   <a class="code" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">btlso::EventType::Type</a>             event)
 {

     <span class="comment">// Retrieve timer information for this event.</span>

     <a class="code" href="classbtlso_1_1Event.html">btlso::Event</a> socketEvent(handle, event);
     EventTimeMap::iterator socketEventIt = d_eventTimeMap.find(socketEvent);
     my_TimerInfo *timerInfo = &amp;socketEventIt-&gt;second;
     <span class="keywordflow">if</span> (d_eventTimeMap.end() != socketEventIt) {
         <span class="keywordflow">return</span> -1;                                                 <span class="comment">// RETURN</span>
     }

     <span class="comment">// Deregister this socket event.</span>

     d_manager_p-&gt;deregisterSocketEvent(handle, event);

     <span class="comment">// Deregister timer</span>

     d_manager_p-&gt;deregisterTimer(timerInfo-&gt;id());

     <span class="comment">// Remove timer information for this event from the map.</span>

     d_eventTimeMap.erase(socketEventIt);

     <span class="keywordflow">return</span> 0;
 }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:16 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
