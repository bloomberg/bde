<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlma_managedallocator.h                                           -*-C++-*-
#ifndef INCLUDED_BDLMA_MANAGEDALLOCATOR
#define INCLUDED_BDLMA_MANAGEDALLOCATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a protocol for memory allocators that support &#39;release&#39;.
//
//@CLASSES:
//   bdlma::ManagedAllocator: protocol for allocators with &#39;release&#39; capability
//
//@SEE_ALSO: bdlma_bufferedsequentialallocator
//
//@DESCRIPTION: This component provides a &#39;class&#39;, &#39;bdlma::ManagedAllocator&#39;,
// that extends the &#39;bslma::Allocator&#39; protocol to allocators that support the
// ability to &#39;release&#39; all memory currently allocated through the protocol
// back to the memory supplier of the derived concrete allocator object.
//..
//   ,-----------------------.
//  ( bdlma::ManagedAllocator )
//   `-----------------------&#39;
//               |        release
//               |
//               v
//       ,----------------.
//      ( bslma::Allocator )
//       `----------------&#39;
//                        allocate
//                        deallocate
//..
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Implementing the &#39;bdlma::ManagedAllocator&#39; Protocol
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// The &#39;bdlma::ManagedAllocator&#39; interface is especially useful for allocators
// that are based on an underlying pooling mechanism (e.g., &#39;bdlma::Multipool&#39;
// or &#39;bdlma::BufferedSequentialPool&#39;).  In particular, such an allocator that
// implements the &#39;bdlma::ManagedAllocator&#39; interface can release, via the
// &#39;release&#39; method, all outstanding (pooled) memory back to the underlying
// allocator making the memory available for subsequent reuse.  Moreover, use
// of the &#39;release&#39; method can also often render superfluous the running of
// destructors on the objects making use of a managed allocator.  In this first
// usage example, we define the &#39;my_BufferAllocator&#39; class, an allocator that
// implements the &#39;bdlma::ManagedAllocator&#39; interface.  &#39;my_BufferAllocator&#39; is
// a considerably pared down version of &#39;bdlma::BufferedSequentialAllocator&#39;,
// and is intended for illustration purposes only.  Please see the
// &#39;bdlma_bufferedsequentialallocator&#39; component for full documentation of
// &#39;bdlma::BufferedSequentialAllocator&#39;, a managed allocator meant for
// production use.
//
// First, we define the interface of the &#39;my_BufferAllocator&#39; class:
//..
//  // my_bufferallocator.h
//
//  class my_BufferAllocator : public bdlma::ManagedAllocator {
//      // This &#39;class&#39; provides a concrete buffer allocator that implements
//      // the &#39;bdlma::ManagedAllocator&#39; protocol.
//
//      // DATA
//      char *d_buffer_p;    // external buffer (held, not owned)
//      int   d_bufferSize;  // size (in bytes) of external buffer
//      int   d_cursor;      // offset to next available byte in buffer
//
//    private:
//      // NOT IMPLEMENTED
//      my_BufferAllocator(const my_BufferAllocator&amp;);
//      my_BufferAllocator&amp; operator=(const my_BufferAllocator&amp;);
//
//    public:
//      // CREATORS
//      my_BufferAllocator(char *buffer, size_type bufferSize);
//          // Create a buffer allocator for allocating maximally-aligned
//          // memory blocks from the specified external &#39;buffer&#39; having the
//          // specified &#39;bufferSize&#39; (in bytes).
//
//      ~my_BufferAllocator();
//          // Destroy this buffer allocator.
//
//      // MANIPULATORS
//      void *allocate(size_type size);
//          // Return the address of a maximally-aligned contiguous block of
//          // memory of the specified &#39;size&#39; (in bytes) on success, and 0 if
//          // the allocation request exceeds the remaining free memory space
//          // in the external buffer.
//
//      void deallocate(void *address);
//          // This method has no effect for this buffer allocator.
//
//      void release();
//          // Release all memory allocated through this object.  This
//          // allocator is reset to the state it was in immediately following
//          // construction.
//  };
//..
// Next, we define the &#39;inline&#39; methods of &#39;my_BufferAllocator&#39;.  Note that the
// &#39;release&#39; method resets the internal cursor to 0, effectively making the
// memory from the entire external buffer supplied at construction available
// for subsequent allocations, but has no effect on the contents of the buffer:
//..
//  // CREATORS
//  inline
//  my_BufferAllocator::my_BufferAllocator(char *buffer, size_type bufferSize)
//  : d_buffer_p(buffer)
//  , d_bufferSize(static_cast&lt;int&gt;(bufferSize))
//  , d_cursor(0)
//  {
//  }
//
//  // MANIPULATORS
//  inline
//  void my_BufferAllocator::deallocate(void *)
//  {
//  }
//
//  inline
//  void my_BufferAllocator::release()
//  {
//      d_cursor = 0;
//  }
//..
// Finally, we provide the implementation of the &#39;my_BufferAllocator&#39; methods
// that are defined in the &#39;.cpp&#39; file.  A &#39;static&#39; helper function,
// &#39;allocateFromBufferImp&#39;, provides the bulk of the implementation of the
// &#39;allocate&#39; method:
//..
//  // my_bufferallocator.cpp
//
//  // STATIC HELPER FUNCTIONS
//  static
//  void *allocateFromBufferImp(int  *cursor,
//                              char *buffer,
//                              int   bufferSize,
//                              int   size)
//      // Allocate a maximally-aligned memory block of the specified &#39;size&#39;
//      // (in bytes) from the specified &#39;buffer&#39; having the specified
//      // &#39;bufferSize&#39; (in bytes) at the specified &#39;cursor&#39; position.  Return
//      // the address of the allocated memory block if &#39;buffer&#39; contains
//      // sufficient available memory, and 0 otherwise.  The &#39;cursor&#39; is set
//      // to the first byte position immediately after the allocated memory if
//      // there is sufficient memory, and not modified otherwise.  The
//      // behavior is undefined unless &#39;0 &lt;= bufferSize&#39;, &#39;0 &lt; size&#39;,
//      // &#39;0 &lt;= *cursor&#39;, and &#39;*cursor &lt;= bufferSize&#39;.
//
//  {
//      const int offset = bsls::AlignmentUtil::calculateAlignmentOffset(
//                                    buffer + *cursor,
//                                    bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT);
//
//      if (*cursor + offset + size &gt; bufferSize) {  // insufficient space
//          return 0;                                                 // RETURN
//      }
//
//      void *result = &amp;buffer[*cursor + offset];
//      *cursor += offset + size;
//
//      return result;
//  }
//
//  // CREATORS
//  my_BufferAllocator::~my_BufferAllocator()
//  {
//  }
//
//  // MANIPULATORS
//  void *my_BufferAllocator::allocate(size_type size)
//  {
//      return 0 == size ? 0 : allocateFromBufferImp(&amp;d_cursor,
//                                                   d_buffer_p,
//                                                   d_bufferSize,
//                                                   static_cast&lt;int&gt;(size));
//  }
//..
//
///Example 2: Using the &#39;bdlma::ManagedAllocator&#39; Protocol
///- - - - - - - - - - - - - - - - - - - - - - - - - - - -
// In this second usage example, we illustrate how the managed allocator that
// was defined in Example 1, &#39;my_BufferAllocator&#39;, may be used.  Note that
// substantial portions of the sample implementation are elided as they would
// only add unnecessary complications to the usage example.  The portions shown
// are sufficient to illustrate the use of &#39;bdlma::ManagedAllocator&#39;.
//
// The domain of our example is financial markets.  Suppose that we are given a
// list of market indices (e.g., Dow Jones Industrial Average, S&amp;P 500, etc.),
// and we want to perform some computation on each index, in turn.  In this
// example, the essential attributes of an index are held in a &#39;bsl::pair&#39;
// consisting of the name of the index (e.g., &quot;DJIA&quot;) and the number of
// securities that comprise the index (e.g., 30 in the case of the DJIA).  The
// collection of market indices that we wish to process is given by a vector of
// such pairs.  Thus, we make use of these types related to indices:
//..
//  typedef bsl::pair&lt;const char *, int&gt; IndexAttributes;
//  typedef bsl::vector&lt;IndexAttributes&gt; IndexCollection;
//..
// In our example, a security is defined by the unconstrained attribute type
// &#39;my_SecurityAttributes&#39;, the interface and implementation of which is elided
// except we note that it uses &#39;bslma&#39; allocators:
//..
//  class my_SecurityAttributes {
//      // ...
//
//    public:
//      // TRAITS
//      BSLMF_NESTED_TRAIT_DECLARATION(my_SecurityAttributes,
//                                     bslma::UsesBslmaAllocator);
//
//      // ...
//  };
//..
// For the collection of securities comprising an index we use a vector of
// &#39;my_SecurityAttributes&#39;:
//..
//  typedef bsl::vector&lt;my_SecurityAttributes&gt; SecurityCollection;
//..
// Since some indices are quite large (e.g., Russell 3000, Wilshire 5000), for
// performance reasons it is advantageous for a &#39;SecurityCollection&#39; to use an
// efficient memory allocation strategy.  This is where &#39;my_BufferAllocator&#39;
// comes into play, which we will see shortly.
//
// The top-level function in our example takes a &#39;bdlma::ManagedAllocator *&#39;
// and the collection of market indices that we wish to process:
//..
//  static
//  void processIndices(bdlma::ManagedAllocator *managedAllocator,
//                      const IndexCollection&amp;   indices);
//      // Process the specified market &#39;indices&#39; using the specified
//      // &#39;managedAllocator&#39; to supply memory.
//..
// &#39;processIndices&#39; makes use of two helper functions to process each index:
//..
//  static
//  void loadIndex(SecurityCollection      *securities,
//                 bdlma::ManagedAllocator *managedAllocator,
//                 const IndexAttributes&amp;   index);
//      // Load into the specified collection of &#39;securities&#39; the attributes of
//      // the securities comprising the specified market &#39;index&#39; using the
//      // specified &#39;managedAllocator&#39; to supply memory.
//
//  static
//  void processIndex(const SecurityCollection&amp; securities,
//                    const IndexAttributes&amp;    index);
//      // Process the specified collection of &#39;securities&#39; that comprise the
//      // specified market &#39;index&#39;.
//..
// Since we plan to use &#39;my_BufferAllocator&#39; as our managed allocator, we need
// to supply it with an external buffer.  The &#39;calculateMaxBufferSize&#39; function
// computes the size of the buffer required to store the &#39;SecurityCollection&#39;
// corresponding to the largest index to be processed by a given call to
// &#39;processIndices&#39;:
//..
//  int calculateMaxBufferSize(const IndexCollection&amp; indices);
//      // Return the maximum buffer size (in bytes) required to process the
//      // specified collection of market &#39;indices&#39;.
//..
// Before showing the implementation of &#39;processIndices&#39;, where the most
// interesting use of our managed allocator takes place, we show the site of
// the call to &#39;processIndices&#39;.
//
// First, assume that we have been given an &#39;IndexCollection&#39; that has been
// populated with one or more &#39;IndexAttributes&#39;:
//..
//  IndexCollection indices;  // assume populated
//..
// Next, we calculate the size of the buffer that is needed, allocate the
// memory for the buffer from the default allocator, create our concrete
// managed allocator (namely, an instance of &#39;my_BufferAllocator&#39;), and call
// &#39;processIndices&#39;:
//..
//  const int bufferSize = calculateMaxBufferSize(indices);
//
//  bslma::Allocator *allocator = bslma::Default::defaultAllocator();
//  char *buffer = static_cast&lt;char *&gt;(allocator-&gt;allocate(bufferSize));
//
//  my_BufferAllocator bufferAllocator(buffer, bufferSize);
//
//  processIndices(&amp;bufferAllocator, indices);
//..
// Next, we show the implementation of &#39;processIndices&#39;, within which we
// iterate over the market &#39;indices&#39; that are passed to it:
//..
//  static
//  void processIndices(bdlma::ManagedAllocator *managedAllocator,
//                      const IndexCollection&amp;   indices)
//      // Process the specified market &#39;indices&#39; using the specified
//      // &#39;managedAllocator&#39; to supply memory.
//  {
//      for (IndexCollection::const_iterator citer = indices.begin();
//                                           citer != indices.end(); ++citer) {
//
//..
// For each index, the &#39;SecurityCollection&#39; comprising that index is created.
// All of the memory needs of the &#39;SecurityCollection&#39; are provided by the
// &#39;managedAllocator&#39;.  Note that even the memory for the footprint of the
// collection comes from the &#39;managedAllocator&#39;:
//..
//          SecurityCollection *securities =
//              new (managedAllocator-&gt;allocate(sizeof(SecurityCollection)))
//                                        SecurityCollection(managedAllocator);
//
//..
// Next, we call &#39;loadIndex&#39; to populate &#39;securities&#39;, followed by the call to
// &#39;processIndex&#39;.  &#39;loadIndex&#39; also uses the &#39;managedAllocator&#39;, the details
// of which are not shown here:
//..
//          loadIndex(securities, managedAllocator, *citer);
//
//          processIndex(*securities, *citer);
//..
// After the index is processed, &#39;release&#39; is called on the managed allocator
// making all of the buffer supplied to the allocator at construction available
// for reuse:
//..
//          managedAllocator-&gt;release();
//      }
//..
// Finally, we let the &#39;SecurityCollection&#39; used to process the index go out of
// scope intentionally without deleting &#39;securities&#39;.  The call to &#39;release&#39;
// renders superfluous the need to call the &#39;SecurityCollection&#39; destructor as
// well as the destructor of the contained &#39;my_SecurityAttributes&#39; elements.
//..
//  }
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

namespace BloombergLP {
namespace bdlma {

                          // ======================
                          // class ManagedAllocator
                          // ======================

class ManagedAllocator : public bslma::Allocator {
    // This protocol class extends &#39;bslma::Allocator&#39; for allocators with the
    // ability to &#39;release&#39; all memory currently allocated through the protocol
    // back to the memory supplier of the derived concrete allocator object.

  public:
    // MANIPULATORS
    virtual void release() = 0;
        // Release all memory currently allocated through this allocator.
        // The effect of using a pointer after this call that was obtained
        // from this allocator before this call is undefined.
};

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
