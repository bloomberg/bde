<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: Class bsl::unordered_multiset Members</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt; Member List</h1>  </div>
</div>
<div class="contents">
This is the complete list of members for <a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a>, including all inherited members.<table>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gaae360f67451062d24aaf29b12435026d">allocator_type</a> typedef</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gabcf3ccf453abb529eb6eb94a8298bd20">begin</a>()</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga2f6ec6ef03611c1d327368e372efff4f">begin</a>(size_type index)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga9da01b4e4d448a24dfdd54bdacb21f5f">begin</a>() const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gac4dc1420ef10eaf8dd6e04e7606d9a14">begin</a>(size_type index) const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gad22a0edcf6363e3ee9274ed048f0f928">BSLMF_NESTED_TRAIT_DECLARATION_IF</a>(unordered_multiset,::BloombergLP::bslmf::IsBitwiseMoveable,::BloombergLP::bslmf::IsBitwiseMoveable&lt; HashTable &gt;::value)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga15b8e3739ba5c0bd7b532b81cc6e9db4">bucket</a>(const key_type &amp;key) const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga5cee093bfcc096b13d908b69074d96c7">bucket_count</a>() const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gac7daa1447baa7526a9b266531ddf276e">bucket_size</a>(size_type index) const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga2969a1eb476105bc78c550bc36365a0c">cbegin</a>() const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gabdb73949d750c74a9c6ff63f0ba00cde">cbegin</a>(size_type index) const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gabdf1ff49beccf1dd68cfce1bf96147a8">cend</a>() const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga2dabab4d32a496d89286e5cf91933ffd">cend</a>(size_type index) const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga9bb8383caf31e8ce28e44050f48d06d2">clear</a>()</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gaaec50219f12ed6dccf0a9d3610c99212">const_iterator</a> typedef</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gae2506aae4cbd64e6cdb32a80e8b3dfad">const_local_iterator</a> typedef</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga193c43589d77aac1fd32095369db3b8b">const_pointer</a> typedef</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga58c0759062e14e969a110993c64b152a">const_reference</a> typedef</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga041cef546e2d0dc73a4fcb821f0ce907">count</a>(const key_type &amp;key) const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga2a83c53d80141e4bfd276fad15cd2c68">difference_type</a> typedef</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gab84206cf24f95031d7d5579e13d0d9b9">empty</a>() const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga20b1466c185aa184bc50f04e53b7ae2d">end</a>()</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga422727341b9f8b6033218d7039a49cc8">end</a>(size_type index)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gaad28eaba37020d055f466e0226be3859">end</a>() const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga66425a3c3945f80dd593ec18af93ab82">end</a>(size_type index) const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga60c5b73f7a685f6d38ac4713ec348db1">equal_range</a>(const key_type &amp;key)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga568005ff5479dd5f975af1c8813d4c90">equal_range</a>(const key_type &amp;key) const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga22ccf66a87c544193f31fedc8ee07030">erase</a>(const key_type &amp;key)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga4678a57f98c8e6044bb7a6e68c3a7cf9">erase</a>(const_iterator position)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga6552a8447b885db853e0c200b96b39c5">erase</a>(const_iterator first, const_iterator last)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gaf9176db44a333499c12297f1790e2e37">find</a>(const key_type &amp;key)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gae6feb2f63680850962f7d96e69bab0d7">find</a>(const key_type &amp;key) const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga4800b08398981061d5555d024d7b6ec4">get_allocator</a>() const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga5c65f0f02bba42f56eaaf6d551c5384c">hash_function</a>() const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga9440d0a963d0417b505ac78538723ff6">hasher</a> typedef</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gada2fc1827dca0d8105df43299fffe1b0">insert</a>(const value_type &amp;value)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga922e044e65efca8cf29b7af48745a570">insert</a>(const_iterator hint, const value_type &amp;value)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gaad1d261c49953523eaafaec248e069b6">insert</a>(INPUT_ITERATOR first, INPUT_ITERATOR last)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gac610e64ab4cd477466638635c4439b02">iterator</a> typedef</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga72f193ce1423c9a34fe7b2a5620afd0e">key_eq</a>() const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gaa1232a18650d36bbc04857eafc86c23f">key_equal</a> typedef</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gac224ab4e150a21c2ed661131cfa487f7">key_type</a> typedef</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga58c97fcd33e7fef69749dab83056ff5a">load_factor</a>() const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga9992d1755e1ea59f13364a4ac4801c8c">local_iterator</a> typedef</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga3aefba0c5698b92b0d97321cd3dc5a17">max_bucket_count</a>() const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga21fe5c8de29ae3777a089452af5649e7">max_load_factor</a>(float newLoadFactor)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga3f22a1939b2354121a588c7a264488e5">max_load_factor</a>() const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga2050a59b28aa1cc71956c3883f24feb7">max_size</a>() const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga6686f51f409834c441401075ca04caa5">operator=</a>(const unordered_multiset &amp;rhs)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga8fd1815e1d9cb199648873d1c0913e46">operator==</a>(const unordered_multiset&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;, const unordered_multiset&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td><code> [friend]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga8fd1815e1d9cb199648873d1c0913e46">operator==</a>(const unordered_multiset&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;, const unordered_multiset&lt; KEY2, HASH2, EQUAL2, ALLOCATOR2 &gt; &amp;)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td><code> [friend]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga6f075753682eae178706694da0f5ed1f">pointer</a> typedef</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga7a6d7b3ae4d8b19540906691478c6228">reference</a> typedef</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga7490229d445297136270d56629443a3a">rehash</a>(size_type numBuckets)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga04a79bc05088eaae96aa76d8b2593735">reserve</a>(size_type numElements)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gaf9dff7a2cfd07d6703839f1999a9a55e">size</a>() const </td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga63942086aa758ce662757507fcaa5679">size_type</a> typedef</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga13c5b72c68c73b67bcf83932ddf8f288">swap</a>(unordered_multiset &amp;other)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gae5281db8b4524854d60fcc932a21d073">unordered_multiset</a>(size_type initialNumBuckets=0, const hasher &amp;hash=hasher(), const key_equal &amp;keyEqual=key_equal(), const allocator_type &amp;allocator=allocator_type())</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td><code> [explicit]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gaef00b87c7e436b0f465d8a0fa6de1812">unordered_multiset</a>(const allocator_type &amp;allocator)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td><code> [explicit]</code></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga2df4d6dfb7bee8ce75457c4badc30eea">unordered_multiset</a>(const unordered_multiset &amp;original)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga349f384ceb67ee28e6182c04b6da24b6">unordered_multiset</a>(const unordered_multiset &amp;original, const allocator_type &amp;allocator)</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga3fa2df8bb116f037a4678b94cbc2dc17">unordered_multiset</a>(INPUT_ITERATOR first, INPUT_ITERATOR last, size_type initialNumBuckets=0, const hasher &amp;hash=hasher(), const key_equal &amp;keyEqual=key_equal(), const allocator_type &amp;allocator=allocator_type())</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#ga0f6d3b101c9a7c7e57422ddae8d0f36f">value_type</a> typedef</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
  <tr class="memlist"><td><a class="el" href="group__bslstl__unorderedmultiset.html#gaacfede2a3e65b5b8f7b1c9183b442894">~unordered_multiset</a>()</td><td><a class="el" href="classbsl_1_1unordered__multiset.html">bsl::unordered_multiset&lt; KEY, HASH, EQUAL, ALLOCATOR &gt;</a></td><td></td></tr>
</table></div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:51 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
