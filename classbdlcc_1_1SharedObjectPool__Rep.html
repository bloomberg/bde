<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlcc::SharedObjectPool_Rep</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlcc.html">bdlcc</a>      </li>
      <li><a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html">bdlcc::SharedObjectPool_Rep&lt; TYPE, RESETTER &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlcc::SharedObjectPool_Rep&lt; TYPE, RESETTER &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlcc::SharedObjectPool_Rep" --><!-- doxytag: inherits="bslma::SharedPtrRep" -->
<p><code>#include &lt;<a class="el" href="bdlcc__sharedobjectpool_8h_source.html">bdlcc_sharedobjectpool.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bdlcc::SharedObjectPool_Rep&lt; TYPE, RESETTER &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbdlcc_1_1SharedObjectPool__Rep.png" usemap="#bdlcc::SharedObjectPool_Rep&lt; TYPE, RESETTER &gt;_map" alt=""/>
  <map id="bdlcc::SharedObjectPool_Rep&lt; TYPE, RESETTER &gt;_map" name="bdlcc::SharedObjectPool_Rep&lt; TYPE, RESETTER &gt;_map">
<area href="classbslma_1_1SharedPtrRep.html" alt="bslma::SharedPtrRep" shape="rect" coords="0,0,308,24"/>
</map>
</div>

<p><a href="classbdlcc_1_1SharedObjectPool__Rep-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class CREATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html#a7e459fbadb9be4b608befd4dd2931b03">SharedObjectPool_Rep</a> (CREATOR *objectCreator, const <a class="el" href="classbslalg_1_1ConstructorProxy.html">bslalg::ConstructorProxy</a>&lt; RESETTER &gt; &amp;objectResetter, <a class="el" href="classbdlcc_1_1ObjectPool.html">PoolType</a> *pool, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html#a5a3ea66721257bc531adc655d6942809">~SharedObjectPool_Rep</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html#a5c6fe2dbf6cfbc4f89e8ec993e5f2907">disposeRep</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html#a66eff7f702ac80957d67a97c9eb51189">disposeObject</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html#a00873320ba411c955199ffd0226656db">reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html#a668a0a2c6fb6d9e195f2eb4f9fd4647c">getDeleter</a> (const std::type_info &amp;type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html#a201f05a33b1bb01d277e9ea6d13104e1">originalPtr</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html#ab7ae8fbbb2c40d781796acc521d4dbf7">ptr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#afae38768206afcee65656679fe8b8fea">acquireRef</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#aa94fa844a2bf8be733631a2791edb325">acquireWeakRef</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#a90e082cbd9cd1bf48958ed3e7c2be3b3">releaseRef</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#a51f0354415b31690a01ea69a838680f1">releaseWeakRef</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#a3aee0a92abc9accab03c14100150a1c1">resetCountsRaw</a> (int numSharedReferences, int numWeakReferences)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#a2316b2cd2fa8879d0e44b01a4ab91960">tryAcquireRef</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#a98240123b6422c2ef197a52c68f1083c">hasUniqueOwner</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#a80f93135b7154364119d3f725d957b70">numReferences</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#ab8da02bf77e7c766ee7b8fd45b79f320">numWeakReferences</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1SharedPtrRep.html#a9d4813d43e457fb13dceefdbca5a6661">managedPtrDeleter</a> (void *, void *rep)</td></tr>
</table>
<h3>template&lt;class TYPE, class RESETTER&gt;<br/>
 class bdlcc::SharedObjectPool_Rep&lt; TYPE, RESETTER &gt;</h3>

<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7e459fbadb9be4b608befd4dd2931b03"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::SharedObjectPool_Rep" ref="a7e459fbadb9be4b608befd4dd2931b03" args="(CREATOR *objectCreator, const bslalg::ConstructorProxy&lt; RESETTER &gt; &amp;objectResetter, PoolType *pool, bslma::Allocator *basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class RESETTER &gt; </div>
<div class="memtemplate">
template&lt;class CREATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html">bdlcc::SharedObjectPool_Rep</a>&lt; TYPE, RESETTER &gt;::<a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html">SharedObjectPool_Rep</a> </td>
          <td>(</td>
          <td class="paramtype">CREATOR *&nbsp;</td>
          <td class="paramname"> <em>objectCreator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1ConstructorProxy.html">bslalg::ConstructorProxy</a>&lt; RESETTER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>objectResetter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbdlcc_1_1ObjectPool.html">PoolType</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a new rep object that, upon release, will invoke the specified <code>objectResetter</code> and return itself to the specified <code>pool</code>; then invoke <code>objectCreator</code> to construct an object of <code>TYPE</code> embedded within the new rep object. Use the specified <code>basicAllocator</code> to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a5a3ea66721257bc531adc655d6942809"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::~SharedObjectPool_Rep" ref="a5a3ea66721257bc531adc655d6942809" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class RESETTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html">bdlcc::SharedObjectPool_Rep</a>&lt; TYPE, RESETTER &gt;::~<a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html">SharedObjectPool_Rep</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this representation object and the embedded instance of <code>TYPE</code>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5c6fe2dbf6cfbc4f89e8ec993e5f2907"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::disposeRep" ref="a5c6fe2dbf6cfbc4f89e8ec993e5f2907" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class RESETTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html">bdlcc::SharedObjectPool_Rep</a>&lt; TYPE, RESETTER &gt;::disposeRep </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release this representation object. This method is invoked when the number of weak references and the number of strong references reach zero. This virtual override will return the object, and this representation, to the associated pool. </p>

<p>Implements <a class="el" href="classbslma_1_1SharedPtrRep.html#ad80928f0b7b63b0e1631428e561e610f">bslma::SharedPtrRep</a>.</p>

</div>
</div>
<a class="anchor" id="a66eff7f702ac80957d67a97c9eb51189"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::disposeObject" ref="a66eff7f702ac80957d67a97c9eb51189" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class RESETTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html">bdlcc::SharedObjectPool_Rep</a>&lt; TYPE, RESETTER &gt;::disposeObject </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the object being managed by this representation. This method is invoked when the number of strong references reaches zero. Note that if there are any weak references to the shared object then this function does nothing, including not destroying the object or returning it to the pool. </p>

<p>Implements <a class="el" href="classbslma_1_1SharedPtrRep.html#ac41472460d942cf114a59f24b3d5655f">bslma::SharedPtrRep</a>.</p>

</div>
</div>
<a class="anchor" id="a00873320ba411c955199ffd0226656db"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::reset" ref="a00873320ba411c955199ffd0226656db" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class RESETTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html">bdlcc::SharedObjectPool_Rep</a>&lt; TYPE, RESETTER &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoke the object resetter specified at construction on the associated object. </p>

</div>
</div>
<a class="anchor" id="a668a0a2c6fb6d9e195f2eb4f9fd4647c"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::getDeleter" ref="a668a0a2c6fb6d9e195f2eb4f9fd4647c" args="(const std::type_info &amp;type)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class RESETTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void* <a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html">bdlcc::SharedObjectPool_Rep</a>&lt; TYPE, RESETTER &gt;::getDeleter </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return NULL. Shared object pools strictly control the delete policy for their objects, and do not expose it to end users. </p>

<p>Implements <a class="el" href="classbslma_1_1SharedPtrRep.html#a050197382203058fbecd774e633c0831">bslma::SharedPtrRep</a>.</p>

</div>
</div>
<a class="anchor" id="a201f05a33b1bb01d277e9ea6d13104e1"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::originalPtr" ref="a201f05a33b1bb01d277e9ea6d13104e1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class RESETTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void* <a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html">bdlcc::SharedObjectPool_Rep</a>&lt; TYPE, RESETTER &gt;::originalPtr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return (untyped) address of the object managed by this representation. This virtual override effectively returns "(void*)ptr()". </p>

<p>Implements <a class="el" href="classbslma_1_1SharedPtrRep.html#a71f48f2e5027c0a6619aed26e1e7b582">bslma::SharedPtrRep</a>.</p>

</div>
</div>
<a class="anchor" id="ab7ae8fbbb2c40d781796acc521d4dbf7"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::ptr" ref="ab7ae8fbbb2c40d781796acc521d4dbf7" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE , class RESETTER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE* <a class="el" href="classbdlcc_1_1SharedObjectPool__Rep.html">bdlcc::SharedObjectPool_Rep</a>&lt; TYPE, RESETTER &gt;::ptr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a pointer to the in-place object. </p>

</div>
</div>
<a class="anchor" id="a9d4813d43e457fb13dceefdbca5a6661"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::managedPtrDeleter" ref="a9d4813d43e457fb13dceefdbca5a6661" args="(void *, void *rep)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslma::SharedPtrRep::managedPtrDeleter </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>rep</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the shared reference to an object held by the <code><a class="el" href="classbslma_1_1SharedPtrRep.html">SharedPtrRep</a></code> object which is pointed to be by specified <code>rep</code>. The behavior is undefined unless <code>rep</code> points to an object whose complete type publicly and unambiguously derives from <code><a class="el" href="classbslma_1_1SharedPtrRep.html">SharedPtrRep</a></code>. Note that the first argument is ignored. Also note that this function serves as the managed ptr deleter when converting a <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> to a <code><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a></code>. </p>

</div>
</div>
<a class="anchor" id="afae38768206afcee65656679fe8b8fea"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::acquireRef" ref="afae38768206afcee65656679fe8b8fea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::SharedPtrRep::acquireRef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Atomically acquire a shared reference to the shared object referred to by this representation. The behavior is undefined unless <code>0 &lt; <a class="el" href="classbslma_1_1SharedPtrRep.html#a80f93135b7154364119d3f725d957b70">numReferences()</a></code>. </p>

</div>
</div>
<a class="anchor" id="aa94fa844a2bf8be733631a2791edb325"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::acquireWeakRef" ref="aa94fa844a2bf8be733631a2791edb325" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::SharedPtrRep::acquireWeakRef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Atomically acquire a weak reference to the shared object referred to by this representation. The behavior is undefined unless <code>0 &lt; <a class="el" href="classbslma_1_1SharedPtrRep.html#ab8da02bf77e7c766ee7b8fd45b79f320">numWeakReferences()</a> || 0 &lt; <a class="el" href="classbslma_1_1SharedPtrRep.html#a80f93135b7154364119d3f725d957b70">numReferences()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a90e082cbd9cd1bf48958ed3e7c2be3b3"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::releaseRef" ref="a90e082cbd9cd1bf48958ed3e7c2be3b3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::SharedPtrRep::releaseRef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Atomically release a shared reference to the shared object referred to by this representation, disposing of the shared object if all the shared references to that object are released, and disposing of this representation if all (shared and weak) references to that object are released. The behavior is undefined unless <code>0 &lt; <a class="el" href="classbslma_1_1SharedPtrRep.html#a80f93135b7154364119d3f725d957b70">numReferences()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a51f0354415b31690a01ea69a838680f1"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::releaseWeakRef" ref="a51f0354415b31690a01ea69a838680f1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::SharedPtrRep::releaseWeakRef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Atomically release a weak reference to the shared object referred to by this representation, disposing of this representation if all (shared and weak) references to the shared object are released. The behavior is undefined unless <code>0 &lt; <a class="el" href="classbslma_1_1SharedPtrRep.html#ab8da02bf77e7c766ee7b8fd45b79f320">numWeakReferences()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a3aee0a92abc9accab03c14100150a1c1"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::resetCountsRaw" ref="a3aee0a92abc9accab03c14100150a1c1" args="(int numSharedReferences, int numWeakReferences)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslma::SharedPtrRep::resetCountsRaw </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numSharedReferences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numWeakReferences</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the number of shared references and the number of weak references stored by this representation to the specified <code>numSharedReferences</code> and <code>numWeakReferences</code> respectively. This function is <em>not</em> thread-safe and users must ensure that they serialize access to the <code><a class="el" href="classbslma_1_1SharedPtrRep.html">SharedPtrRep</a></code> object when calling this function. Note that this function updates the counts, but does not dispose of the representation or the object irrespective of the values of <code>numSharedReferences</code> and <code>numWeakReferences</code>. </p>

</div>
</div>
<a class="anchor" id="a2316b2cd2fa8879d0e44b01a4ab91960"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::tryAcquireRef" ref="a2316b2cd2fa8879d0e44b01a4ab91960" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bslma::SharedPtrRep::tryAcquireRef </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Atomically acquire a shared reference to the shared object referred to by this representation, if the number of shared references is greater than 0, and do nothing otherwise. Return <code>true</code> if the acquire succeeds, and <code>false</code> otherwise. The behavior is undefined unless <code>0 &lt; <a class="el" href="classbslma_1_1SharedPtrRep.html#ab8da02bf77e7c766ee7b8fd45b79f320">numWeakReferences()</a> || 0 &lt; <a class="el" href="classbslma_1_1SharedPtrRep.html#a80f93135b7154364119d3f725d957b70">numReferences()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a98240123b6422c2ef197a52c68f1083c"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::hasUniqueOwner" ref="a98240123b6422c2ef197a52c68f1083c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bslma::SharedPtrRep::hasUniqueOwner </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if there is only one shared reference and no weak references to the object referred to by this representation, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a80f93135b7154364119d3f725d957b70"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::numReferences" ref="a80f93135b7154364119d3f725d957b70" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bslma::SharedPtrRep::numReferences </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "snapshot" of the current number of shared references to the shared object referred to by this representation object. </p>

</div>
</div>
<a class="anchor" id="ab8da02bf77e7c766ee7b8fd45b79f320"></a><!-- doxytag: member="bdlcc::SharedObjectPool_Rep::numWeakReferences" ref="ab8da02bf77e7c766ee7b8fd45b79f320" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bslma::SharedPtrRep::numWeakReferences </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a "snapshot" of the current number of weak references to the shared object referred to by this representation object. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlcc__sharedobjectpool_8h_source.html">bdlcc_sharedobjectpool.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:39 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
