<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslstl_hashtablebucketiterator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_hashtablebucketiterator<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL compliant iterator over hash table buckets.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslstl.html">bslstl</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Iterating a Hash Table Bucket Using <code>HashTableIterator</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL compliant iterator over hash table buckets. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>bslstl::HashBucketIterator </td><td>iterator to walk a hash-table bucket  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslstl__unorderedmultimap.html" title="Provide an STL-compliant unordered_multimap container.">Component bslstl_unorderedmultimap</a>, <a class="el" href="group__bslstl__unorderedmultiset.html" title="Provide an STL-compliant unordered_multiset container.">Component bslstl_unorderedmultiset</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a standard-conforming forward iterator, <code><a class="el" href="classbslstl_1_1HashTableBucketIterator.html">bslstl::HashTableBucketIterator</a></code>, over a list of elements (of <code>bslalg::BidirectionalLinkList</code> type) in a single bucket (of <code><a class="el" href="structbslalg_1_1HashTableBucket.html">bslalg::HashTableBucket</a></code> type) of a hashtable. The requirements of a forward iterator are outlined in the C++11 standard in section [24.2.5] under the tag [forward.iterators]. The <code><a class="el" href="classbslstl_1_1HashTableBucketIterator.html">bslstl::HashTableBucketIterator</a></code> class template has two template parameters: <code>VALUE_TYPE</code>, and <code>DIFFERENCE_TYPE</code>. <code>VALUE_TYPE</code> indicates the type of the value to which this iterator provides references, and may be const-qualified for constant iterators. <code>DIFFERENCE_TYPE</code> determines the (standard mandated) <code>difference_type</code> for the iterator, and will typically be supplied by the allocator used by the hash-table being iterated over. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_iterating_a_hash_table_bucket_using_hashtableiterator"></a> <a class="anchor" id="usage.example_1~3A_iterating_a_hash_table_bucket_using_hashtableiterator"></a> <a class="anchor" id="description.usage.example_1~3A_iterating_a_hash_table_bucket_using_hashtableiterator"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Iterating a Hash Table Bucket Using HashTableIterator: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the following example we create a simple hashtable and then use a <code>HashTableBucketIterator</code> to iterate through the elements in one of its buckets. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a typedef, <code>Node</code>, prepresenting a bidirectional node holding an integer value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbslalg_1_1BidirectionalNode.html">bslalg::BidirectionalNode&lt;int&gt;</a> Node;
</pre></div><br/>
<br/>
 Then, we construct a test allocator, and we use it to allocate an array of <code>Node</code> objects, each holding a unique integer value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> scratch(<span class="stringliteral">&quot;scratch&quot;</span>, veryVeryVeryVerbose);

  <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_NODES = 5;
  <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_BUCKETS = 3;

  Node *nodes[NUM_NODES];
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_NODES; ++i) {
      nodes[i] = <span class="keyword">static_cast&lt;</span>Node *<span class="keyword">&gt;</span>(scratch.allocate(<span class="keyword">sizeof</span>(Node)));
      nodes[i]-&gt;value() = i;
  }
</pre></div><br/>
<br/>
 Next, we create an array of <code>HashTableBuckets</code> objects, and we use the array to construct an empty hash table characterized by a <code>HashTableAnchor</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbslalg_1_1HashTableBucket.html">bslalg::HashTableBucket</a> buckets[NUM_BUCKETS];
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_BUCKETS; ++i) {
      buckets[i].<a class="code" href="structbslalg_1_1HashTableBucket.html#aee49bf0cdaa6765ea776783cc7ba53dc">reset</a>();
  }
  <a class="code" href="classbslalg_1_1HashTableAnchor.html">bslalg::HashTableAnchor</a> hashTable(buckets, NUM_BUCKETS, 0);
</pre></div><br/>
<br/>
 Then, we insert each node in the array of nodes into the hash table using <code><a class="el" href="structbslalg_1_1HashTableImpUtil.html">bslalg::HashTableImpUtil</a></code>, supplying the integer value held by each node as its hash value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_NODES; ++i) {
      <a class="code" href="structbslalg_1_1HashTableImpUtil.html#af289c0c8a875ea816b8d938b02f268be">bslalg::HashTableImpUtil::insertAtFrontOfBucket</a>(&amp;hashTable,
                                                      nodes[i],
                                                      nodes[i]-&gt;value());
  }
</pre></div><br/>
<br/>
 Next, we define a <code>typedef</code> that is an alias an instance of <code>HashTableBucketIterator</code> that can traverse buckets in a hash table holding integer values. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbslstl_1_1HashTableBucketIterator.html">bslstl::HashTableBucketIterator&lt;int, ptrdiff_t&gt;</a> Iter;
</pre></div><br/>
<br/>
 Now, we create two iterators: one pointing to the start the second bucket in the hash table, and the other representing the end sentinel. We use the iterators to navigate and print the elements in the hash table bucket: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Iter iter(&amp;hashTable.bucketArrayAddress()[1]);
  Iter end(0, &amp;hashTable.bucketArrayAddress()[1]);
  <span class="keywordflow">for</span> (;iter != end; ++iter) {
      printf(<span class="stringliteral">&quot;%d\n&quot;</span>, *iter);
  }
</pre></div><br/>
<br/>
 Then, we observe the following output: <br/>
<br/>
<div class="fragment"><pre class="fragment"> 1
 3
</pre></div><br/>
<br/>
 Finally, we deallocate the memory used by the hash table: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_NODES; ++i) {
      scratch.deallocate(nodes[i]);
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:22 for BDE Release 2.23.1 Open-Source by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
