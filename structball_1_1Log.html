<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Struct ball::Log</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceball.html">ball</a>      </li>
      <li><a class="el" href="structball_1_1Log.html">ball::Log</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>ball::Log Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="ball::Log" -->
<p><code>#include &lt;<a class="el" href="ball__log_8h_source.html">ball_log.h</a>&gt;</code></p>

<p><a href="structball_1_1Log-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1Log.html#a810476b7ab8ddb406043b429e9aceb58">format</a> (char *buffer, bsl::size_t numBytes, const char *format,...)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classball_1_1Record.html">Record</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1Log.html#a0363f06f6f1d565eb0efec74da16ce3f">getRecord</a> (const <a class="el" href="classCategory.html">Category</a> *category, const char *file, int line)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1Log.html#a9b0c8354184eba5184622118a979f5d7">logMessage</a> (const <a class="el" href="classCategory.html">Category</a> *category, int severity, const char *fileName, int lineNumber, const char *message)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1Log.html#a7cbd7c13ce2f4f0683ef3c6b1bc749ec">logMessage</a> (const <a class="el" href="classCategory.html">Category</a> *category, int severity, <a class="el" href="classball_1_1Record.html">Record</a> *record)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1Log.html#af3f94bd65c05853fef4efd12d384426a">obtainMessageBuffer</a> (<a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a> **mutex, int *bufferSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1Log.html#a816987c45a9952144223ad4fbd5dd048">releaseMessageBuffer</a> (<a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a> *mutex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classCategory.html">Category</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1Log.html#a04cca444ce33147d8df9438fdc306751">setCategory</a> (const char *categoryName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1Log.html#a86642450a502bcec7dd0e6cea80ac441">setCategory</a> (<a class="el" href="classCategoryHolder.html">CategoryHolder</a> *categoryHolder, const char *categoryName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structball_1_1Log.html#abc585b9b8338383942d387d314198ea6">isCategoryEnabled</a> (const <a class="el" href="classCategoryHolder.html">CategoryHolder</a> *categoryHolder, int severity)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This <code>struct</code> provides a namespace for a suite of utility functions that simplify usage of the <code>ball_loggermanager</code> component. The direct use of these utility functions is <em>strongly</em> discouraged. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a810476b7ab8ddb406043b429e9aceb58"></a><!-- doxytag: member="ball::Log::format" ref="a810476b7ab8ddb406043b429e9aceb58" args="(char *buffer, bsl::size_t numBytes, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ball::Log::format </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill the specified <code>buffer</code> with at most the specified <code>numBytes</code> characters produced by formatting the variable argument list according to the specified <code>printf</code>-style <code>format</code> argument; return the number of characters in the resulting formatted string. The last character placed into <code>buffer</code> is always a null terminator (leaving at most <code>numBytes - 1</code> bytes of formatted data). If <code>numBytes</code> is insufficient for the entire formatted string, this method fills <code>buffer</code> with the initial <code>numBytes - 1</code> bytes of formatted data followed by a null terminator and returns -1. Note that with the exception of the return value, the behavior of this function exactly matches that of the C99 function <code>snprintf</code>. Also note that <code>snprintf</code> is not part of standard C++-98, so its functionality is provided here. </p>

</div>
</div>
<a class="anchor" id="a0363f06f6f1d565eb0efec74da16ce3f"></a><!-- doxytag: member="ball::Log::getRecord" ref="a0363f06f6f1d565eb0efec74da16ce3f" args="(const Category *category, const char *file, int line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classball_1_1Record.html">Record</a>* ball::Log::getRecord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCategory.html">Category</a> *&nbsp;</td>
          <td class="paramname"> <em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a modifiable record having the specified <code>file</code> and <code>line</code> attributes. The memory for the record will be supplied by the allocator held by the logger manager singleton if the specified <code>category</code> is non-null, or by the currently installed default allocator otherwise. </p>

</div>
</div>
<a class="anchor" id="a9b0c8354184eba5184622118a979f5d7"></a><!-- doxytag: member="ball::Log::logMessage" ref="a9b0c8354184eba5184622118a979f5d7" args="(const Category *category, int severity, const char *fileName, int lineNumber, const char *message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ball::Log::logMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCategory.html">Category</a> *&nbsp;</td>
          <td class="paramname"> <em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>severity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lineNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="structball_1_1Log.html">Log</a> a record containing the specified <code>message</code> text, <code>fileName</code>, <code>lineNumber</code>, <code>severity</code>, and the name of the specified <code>category</code>. (See the component-level documentation of <code>ball_record</code> for more information on the additional fields that are logged.) Store the record in the buffer held by the logger if <code>severity</code> is at least as severe as the current "Record" threshold level of <code>category</code>. Pass the record directly to the registered observer if <code>severity</code> is at least as severe as the current "Pass" threshold level of <code>category</code>. Publish the entire contents of the buffer of the logger if <code>severity</code> is at least as severe as the current "Trigger" threshold level of <code>category</code>. Publish the entire contents of all buffers of all loggers if <code>severity</code> is at least as severe as the current "Trigger-All" threshold level of <code>category</code> (i.e., via the callback supplied at construction of the logger manager). Note that this method has no effect if <code>severity</code> is less severe than each of the threshold levels of <code>category</code>. The behavior is undefined unless <code>severity</code> is in the range <code>[1 .. 255]</code> and the logger manager singleton has been initialized. </p>

</div>
</div>
<a class="anchor" id="a7cbd7c13ce2f4f0683ef3c6b1bc749ec"></a><!-- doxytag: member="ball::Log::logMessage" ref="a7cbd7c13ce2f4f0683ef3c6b1bc749ec" args="(const Category *category, int severity, Record *record)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ball::Log::logMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCategory.html">Category</a> *&nbsp;</td>
          <td class="paramname"> <em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>severity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classball_1_1Record.html">Record</a> *&nbsp;</td>
          <td class="paramname"> <em>record</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="structball_1_1Log.html">Log</a> the specified <code>record</code> after setting its category attribute to the specified <code>category</code> and its severity attribute to the specified <code>severity</code>. (See the component-level documentation of <code>ball_record</code> for more information on the fields that are logged.) Store the record in the buffer held by the logger if <code>severity</code> is at least as severe as the current "Record" threshold level of <code>category</code>. Pass the record directly to the registered observer if <code>severity</code> is at least as severe as the current "Pass" threshold level of <code>category</code>. Publish the entire contents of the buffer of the logger if <code>severity</code> is at least as severe as the current "Trigger" threshold level of <code>category</code>. Publish the entire contents of all buffers of all loggers if <code>severity</code> is at least as severe as the current "Trigger-All" threshold level of <code>category</code> (i.e., via the callback supplied at construction of the logger manager). Note that this method has no effect if <code>severity</code> is less severe than each of the threshold levels of <code>category</code>. The behavior is undefined unless <code>severity</code> is in the range <code>[1 .. 255]</code>, <code>record</code> was obtained by a call to <code><a class="el" href="structball_1_1Log.html#a0363f06f6f1d565eb0efec74da16ce3f">Log::getRecord</a></code>, and the logger manager singleton has been initialized. </p>

</div>
</div>
<a class="anchor" id="af3f94bd65c05853fef4efd12d384426a"></a><!-- doxytag: member="ball::Log::obtainMessageBuffer" ref="af3f94bd65c05853fef4efd12d384426a" args="(bslmt::Mutex **mutex, int *bufferSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static char* ball::Log::obtainMessageBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a> **&nbsp;</td>
          <td class="paramname"> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Block until access to the buffer used for formatting messages in this thread of execution is available. Return the address of the modifiable buffer to which this thread of execution has exclusive access, load the address of the mutex that protects the buffer into the specified <code>*mutex</code> address, and load the size (in bytes) of the buffer into the specified <code>bufferSize</code> address. The address remains valid, and the buffer remains locked by this thread of execution, until the <code><a class="el" href="structball_1_1Log.html#a816987c45a9952144223ad4fbd5dd048">Log::releaseMessageBuffer</a></code> method is called. The behavior is undefined if this thread of execution currently holds a lock on the buffer. Note that the buffer is intended to be used <em>only</em> for formatting log messages immediately before a call to <code><a class="el" href="structball_1_1Log.html#a9b0c8354184eba5184622118a979f5d7">Log::logMessage</a></code>; other use may adversely affect performance for the entire program. </p>

</div>
</div>
<a class="anchor" id="a816987c45a9952144223ad4fbd5dd048"></a><!-- doxytag: member="ball::Log::releaseMessageBuffer" ref="a816987c45a9952144223ad4fbd5dd048" args="(bslmt::Mutex *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ball::Log::releaseMessageBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a> *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unlock the specified <code>*mutex</code> that guards the buffer used for formatting messages in this thread of execution. The behavior is undefined unless <code>*mutex</code> was obtained by a call to <code><a class="el" href="structball_1_1Log.html#af3f94bd65c05853fef4efd12d384426a">Log::obtainMessageBuffer</a></code> and has not yet been unlocked. </p>

</div>
</div>
<a class="anchor" id="a04cca444ce33147d8df9438fdc306751"></a><!-- doxytag: member="ball::Log::setCategory" ref="a04cca444ce33147d8df9438fdc306751" args="(const char *categoryName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classCategory.html">Category</a>* ball::Log::setCategory </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>categoryName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return from the logger manager's category registry the address of the non-modifiable category having the specified <code>categoryName</code> if such a category exists, or if a new category having <code>categoryName</code> can be added to the registry (i.e., if the registry has sufficient capacity to accommodate new entries); otherwise, return the address of the non-modifiable <em>Default</em> <em><a class="el" href="classCategory.html">Category</a></em>. Return 0 if the logger manager singleton has not been initialized or has been destroyed. </p>

</div>
</div>
<a class="anchor" id="a86642450a502bcec7dd0e6cea80ac441"></a><!-- doxytag: member="ball::Log::setCategory" ref="a86642450a502bcec7dd0e6cea80ac441" args="(CategoryHolder *categoryHolder, const char *categoryName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ball::Log::setCategory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCategoryHolder.html">CategoryHolder</a> *&nbsp;</td>
          <td class="paramname"> <em>categoryHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>categoryName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>categoryHolder</code> the address of the non-modifiable category having the specified <code>categoryName</code> if such a category exists, or if a new category having <code>categoryName</code> can be added to the registry (i.e., if the registry has sufficient capacity to accommodate new entries); otherwise, load the address of the non-modifiable <em>Default</em> <em><a class="el" href="classCategory.html">Category</a></em>. Also load into <code>categoryHolder</code> the maximum threshold level of the category ultimately loaded into <code>categoryHolder</code>. </p>

</div>
</div>
<a class="anchor" id="abc585b9b8338383942d387d314198ea6"></a><!-- doxytag: member="ball::Log::isCategoryEnabled" ref="abc585b9b8338383942d387d314198ea6" args="(const CategoryHolder *categoryHolder, int severity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool ball::Log::isCategoryEnabled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCategoryHolder.html">CategoryHolder</a> *&nbsp;</td>
          <td class="paramname"> <em>categoryHolder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>severity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if logging to the category associated with the specified <code>categoryHolder</code> at the specified <code>severity</code> is enabled, or if <code><a class="el" href="structball_1_1Severity.html#af49f66189615b9475c9cced03afde384a784431e47d4121459476d62efde5b97e" title="a potentially problematic condition">Severity::e_WARN</a> &gt;= severity</code> and the logger manager singleton is not initialized; return <code>false</code> otherwise. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="ball__log_8h_source.html">ball_log.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:01 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
