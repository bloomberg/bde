<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslh_spookyhashalgorithmimp.h                                      -*-C++-*-
#ifndef INCLUDED_BSLH_SPOOKYHASHALGORITHMIMP
#define INCLUDED_BSLH_SPOOKYHASHALGORITHMIMP

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide BDE style encapsulation of 3rd party SpookyHash code.
//
//@CLASSES:
//  bslh::SpookyHashAlgorithmImp: encapsulation of 3rd party SpookyHash code
//
//@SEE_ALSO: bslh_hash, bslh_spookyhashalgorithm
//
//@DESCRIPTION: &#39;bslh::SpookyHashAlgorithmImp&#39; provides BDE style encapsulation
// around Bob Jenkins&#39; canonical SpookyHash implementation.  SpookyHash
// provides a way to hash contiguous data all at once, or discontiguous data in
// pieces.  More information is available at:
// http://burtleburtle.net/bob/hash/spooky.html
//
///Usage
///-----
// This section illustrates intended usage of this component.
//
///Example: Creating 128-bit checksums
///- - - - - - - - - - - - - - - - - -
// Suppose we have a library of 4 billion pieces of data and we want to store
// checksums for this data.  For a 64-bit hash, there is a 35% chance of two of
// these checksums colliding (according to the approximation found here:
// http://en.wikipedia.org/wiki/Birthday_problem).  We want to avoid checksum
// collision, so we will use the 128-bit hashing functionality provided by
// &#39;SpookyHashAlgorithmImp&#39;.
//
// First, we will declare a class &#39;CheckedData&#39; which will store some data as
// well as the checksum associated with it.
//..
//
//  class CheckedData {
//      // This class holds a pointer to data and provides a way of verifying
//      // that the data has not changed.
//
//      // TYPES
//      typedef bsls::Types::Uint64 Uint64;
//
//      // DATA
//      size_t      d_length;
//      const char *d_data;
//      Uint64      d_checksum1;
//      Uint64      d_checksum2;
//
//    public:
//      CheckedData(const char *data, size_t length);
//          // Creates an instance of this class having the specified &#39;length&#39;
//          // bytes of &#39;data&#39;.  The behavior is undefined unless &#39;data&#39; is
//          // initialized with at least &#39;length&#39; bytes, and remains valid for
//          // the lifetime of this object.  Note that only a pointer to the
//          // data will be maintained, it will not be copied.
//
//      const char *getData();
//          // Return a pointer to the data being tracked by this class.
//
//      bool isDataValid();
//          // Return &#39;true&#39; if the data stored in this class matches the
//          // stored checksum, and &#39;false&#39; otherwise.
//  };
//
//..
// Then, we define the &#39;CheckedData&#39; constructor.  Here we will use
// &#39;SpookyHashImp&#39; to calculate a 128-bit checksum.
//..
//
//  CheckedData::CheckedData(const char *data, size_t length)
//  : d_length(length)
//  , d_data(data)
//  , d_checksum1(0)
//  , d_checksum2(0)
//  {
//      BSLS_ASSERT(data);
//
//      SpookyHashAlgorithmImp hashAlg(1, 2);
//
//      hashAlg.hash128(d_data, d_length, &amp;d_checksum1, &amp;d_checksum2);
//  }
//
//  const char *CheckedData::getData() {
//      return d_data;
//  }
//
//..
// Next, we define &#39;isDataValid&#39;.  We will generate a checksum from the
// contained data and then compare it to the checksum we generated when the
// class was created.  If the two hashes match, then we can be reasonably
// certain that the data is still in a valid state (the chance of an accidental
// collision is very low).  If the checksums do not match, we know that the
// data has been corrupted.  We will not be able to restore it, but we will
// know not to trust it.
//..
//
//  bool CheckedData::isDataValid() {
//      SpookyHashAlgorithmImp hashAlg(1, 2);
//      Uint64 checksum1 = 0;
//      Uint64 checksum2 = 0;
//
//      hashAlg.hash128(d_data, d_length, &amp;checksum1, &amp;checksum2);
//
//      return (d_checksum1 == checksum1) &amp;&amp; (d_checksum2 == checksum2);
//  }
//..
// Then, we store some data in our &#39;CheckedData&#39; class for safekeeping.
//..
//
//      char data[] = &quot;To be, or not to be--that is the question:&quot;
//                    &quot;Whether &#39;tis nobler in the mind to suffer&quot;
//                    &quot;The slings and arrows of outrageous fortune&quot;
//                    &quot;Or to take arms against a sea of troubles&quot;
//                    &quot;And by opposing end them.  To die, to sleep--&quot;
//                    &quot;No more--and by a sleep to say we end&quot;
//                    &quot;The heartache, and the thousand natural shocks&quot;
//                    &quot;That flesh is heir to.  &#39;Tis a consummation&quot;
//                    &quot;Devoutly to be wished.  To die, to sleep--&quot;
//                    &quot;To sleep--perchance to dream: ay, there&#39;s the rub,&quot;
//                    &quot;For in that sleep of death what dreams may come&quot;
//                    &quot;When we have shuffled off this mortal coil,&quot;
//                    &quot;Must give us pause.  There&#39;s the respect&quot;
//                    &quot;That makes calamity of so long life.&quot;
//                    &quot;For who would bear the whips and scorns of time,&quot;
//                    &quot;Th&#39; oppressor&#39;s wrong, the proud man&#39;s contumely&quot;
//                    &quot;The pangs of despised love, the law&#39;s delay,&quot;
//                    &quot;The insolence of office, and the spurns&quot;
//                    &quot;That patient merit of th&#39; unworthy takes,&quot;
//                    &quot;When he himself might his quietus make&quot;
//                    &quot;With a bare bodkin? Who would fardels bear,&quot;
//                    &quot;To grunt and sweat under a weary life,&quot;
//                    &quot;But that the dread of something after death,&quot;
//                    &quot;The undiscovered country, from whose bourn&quot;
//                    &quot;No traveller returns, puzzles the will,&quot;
//                    &quot;And makes us rather bear those ills we have&quot;
//                    &quot;Than fly to others that we know not of?&quot;
//                    &quot;Thus conscience does make cowards of us all,&quot;
//                    &quot;And thus the native hue of resolution&quot;
//                    &quot;Is sicklied o&#39;er with the pale cast of thought,&quot;
//                    &quot;And enterprise of great pitch and moment&quot;
//                    &quot;With this regard their currents turn awry&quot;
//                    &quot;And lose the name of action. -- Soft you now,&quot;
//                    &quot;The fair Ophelia! -- Nymph, in thy orisons&quot;
//                    &quot;Be all my sins remembered.&quot;;
//      CheckedData checkedData(data, strlen(data));
//
//..
// Now, we check that the &#39;CheckedData&#39; recognizes that it is still valid.
//..
//
//      ASSERT(checkedData.isDataValid());
//
//..
// Finally, we tamper with the data and check that our &#39;CheckedData&#39; class can
// detect this.
//..
//      data[34] = &#39;z&#39;;
//      ASSERT(!checkedData.isDataValid());
//..
//
///Changes
///-------
// The third party code begins with the &quot;SpookyHash&quot; header below, and
// continues until the BloombergLP copyright notice.  Changes made to the
// original code include:
//
//: 1 Added &#39;BloombergLP&#39; and &#39;bslh&#39; namespaces
//:
//: 2 Renamed &#39;SpookyHash&#39; to &#39;SpookyHashAlgorithmImp&#39;
//:
//: 3 Removed usage of &#39;stdint.h&#39; (which might not be available on all
//:   platforms) and updated associated &#39;typedef&#39;s
//:
//: 4 Added &#39;include&#39; guards
//:
//: 5 Made some methods private
//:
//: 6 Reformatted comments and added comments
//:
//: 7 Updated indenting to BDE style
//:
//: 8 Moved &#39;typedef&#39;s within class
//:
//: 9 Changed C-style casts to &#39;static_cast&#39;s
//:
//: 10 Reordered methods according to BDE style
//:
//: 11 Added inline to &#39;Hash32&#39; and &#39;Hash64&#39;
//:
//: 12 Changed static constants to &#39;enum&#39;s to avoid storage overhead
//:
//: 13 Added constructor in place of &#39;init&#39;
//:
//: 14 Made function names lower case (had to change &#39;Final&#39; to &#39;finalize&#39; and
//:    &#39;Short&#39; to &#39;shortHash&#39; to avoid using a keyword)
//
///Third-Party Documentation
///-------------------------
//..
// SpookyHash: a 128-bit non cryptographic hash function
//
// By Bob Jenkins, public domain
//   Oct 31 2010: alpha, framework + SpookyHash::Mix appears right
//   Oct 31 2011: alpha again, Mix only good to 2^^69 but rest appears right
//   Dec 31 2011: beta, improved Mix, tested it for 2-bit deltas
//   Feb  2 2012: production, same bits as beta
//   Feb  5 2012: adjusted definitions of uint* to be more portable
//   Mar 30 2012: 3 bytes/cycle, not 4. Alpha was 4 but wasn&#39;t thorough enough.
//   August 5 2012: SpookyV2 (different results)
//
// Up to 3 bytes/cycle for long messages.  Reasonably fast for short messages.
// All 1 or 2 bit deltas achieve avalanche within 1% bias per output bit.
//
// This was developed for and tested on 64-bit x86-compatible processors.  It
// assumes the processor is little-endian.  There is a macro controlling
// whether unaligned reads are allowed (by default they are).  This should be
// an equally good hash on big-endian machines, but it will compute different
// results on them than on little-endian machines.
//
// Google&#39;s CityHash has similar specs to SpookyHash, and CityHash is faster on
// new Intel boxes.  MD4 and MD5 also have similar specs, but they are orders
// of magnitude slower.  CRCs are two or more times slower, but unlike
// SpookyHash, they have nice math for combining the CRCs of pieces to form the
// CRCs of wholes.  There are also cryptographic hashes, but those are even
// slower than MD5.
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_STDDEF_H
#include &lt;stddef.h&gt;    // &#39;size_t&#39;
#define INCLUDED_STDDEF_H
#endif

namespace BloombergLP {

namespace bslh {


class SpookyHashAlgorithmImp {
    // This class wraps an implementation of Bob Jenkin&#39;s &quot;SpookyHash&quot; in a
    // BDE-style component.  For more information, see
    // http://burtleburtle.net/bob/hash/spooky.html .

  public:
    typedef  bsls::Types::Uint64  Uint64;
    typedef  unsigned int         Uint32;
    typedef  unsigned short       Uint16;
    typedef  unsigned char        Uint8;

  private:
    // DATA
    enum { k_NUM_VARS = 12 };
        // Number of 64-bit integers used in the internal state.

    enum { k_BLOCK_SIZE = k_NUM_VARS * 8 };
        // Size of the internal state, in bytes.

    enum { k_BUFFER_SIZE = k_BLOCK_SIZE * 2 };
        // Size of buffer of unhashed data, in bytes.

    static const Uint64 sc_const = 0xdeadbeefdeadbeefULL;
        // A non-zero, odd, constant that has an irregular distribution of 1&#39;s
        // and 0&#39;s to be used in hashing calculations.

    Uint64 m_data[2 * k_NUM_VARS]; // unhashed data, for partial messages
    Uint64 m_state[k_NUM_VARS];    // internal state of the hash
    size_t m_length;               // total length of the input so far
    Uint8  m_remainder;            // length of unhashed data stashed in m_data

    // PRIVATE CLASS METHODS
    static void end(const Uint64 *data,
                    Uint64 &amp;h0, Uint64 &amp;h1, Uint64 &amp;h2, Uint64 &amp;h3,
                    Uint64 &amp;h4, Uint64 &amp;h5, Uint64 &amp;h6, Uint64 &amp;h7,
                    Uint64 &amp;h8, Uint64 &amp;h9, Uint64 &amp;h10,Uint64 &amp;h11);
        // Incorporate the first 12 bytes of the specified &#39;data&#39; into &#39;h0&#39;,
        // &#39;h1&#39;, &#39;h2&#39;, &#39;h3&#39;, &#39;h4&#39;, &#39;h5&#39;, &#39;h6&#39;, &#39;h7&#39;, &#39;h8&#39;, &#39;h9&#39;, &#39;h10&#39;, and
        // &#39;h11&#39;, and then mix the inputs together so that &#39;h0&#39; and &#39;h1&#39; are a
        // hash of all the inputs.  Note that non-BDE-standard passing by
        // non-const reference is used here to remain consistent with the
        // cannonical implementation.  The behavior is undefined unles &#39;data&#39;
        // points at least 8 bytes of initialized memory.

    static void endPartial(Uint64 &amp;h0, Uint64 &amp;h1, Uint64 &amp;h2, Uint64 &amp;h3,
                           Uint64 &amp;h4, Uint64 &amp;h5, Uint64 &amp;h6, Uint64 &amp;h7,
                           Uint64 &amp;h8, Uint64 &amp;h9, Uint64 &amp;h10,Uint64 &amp;h11);
        // Combine the specified &#39;h0&#39;, &#39;h1&#39;, &#39;h2&#39;, &#39;h3&#39;, &#39;h4&#39;, &#39;h5&#39;, &#39;h6&#39;,
        // &#39;h7&#39;, &#39;h8&#39;, &#39;h9&#39;, &#39;h10&#39;, and &#39;h11&#39; together so that &#39;h0&#39; and &#39;h1&#39;
        // will be a hash of all the inputs.  Note that non-BDE-standard
        // passing by non-const reference is used here to remain consistent
        // with the cannonical implementation.  The behavior is undefined unles
        // &#39;data&#39; points at least 8 bytes of initialized memory.

    static void mix(const Uint64 *data,
                    Uint64 &amp;s0, Uint64 &amp;s1, Uint64 &amp;s2,  Uint64 &amp;s3,
                    Uint64 &amp;s4, Uint64 &amp;s5, Uint64 &amp;s6,  Uint64 &amp;s7,
                    Uint64 &amp;s8, Uint64 &amp;s9, Uint64 &amp;s10, Uint64 &amp;s11);
        // Thoroughly mix the first 12 bytes of the specified &#39;data&#39; into &#39;s0&#39;,
        // &#39;s1&#39;, &#39;s2&#39;, &#39;s3&#39;, &#39;s4&#39;, &#39;s5&#39;, &#39;s6&#39;, &#39;s7&#39;, &#39;s8&#39;, &#39;s9&#39;, &#39;s10&#39;, and
        // &#39;s11&#39;.  This method should be used when the input is 96 bytes or
        // longer to prevent the loss of entropy, because the internal state of
        // &#39;SpookyHashAlgorithmImp&#39; is overwritten every 96 bytes.  Note that
        // non-BDE-standard passing by non-const reference is used here to
        // remain consistent with the cannonical implementation.  The behavior
        // is undefined unles &#39;data&#39; points at least 8 bytes of initialized
        // memory.

    static Uint64 rot64(Uint64 x, int k);
        // Return the specified &#39;x&#39; left rotated by &#39;k&#39; bits.

    static void shortHash(const void *message,
                          size_t      length,
                          Uint64     *hash1,
                          Uint64     *hash2);
        // Hash the specified &#39;length&#39; bytes of &#39;message&#39; using &#39;hash1&#39; and
        // &#39;hash2&#39; as seeds.  Load the higher order bits of the resulting
        // 128-bit hash value into &#39;hash1&#39; and the lower order bits in &#39;hash2&#39;.
        // This method is meant to be used for messages less than 192 bytes in
        // length because of its lower startup cost.  The behavior is undefined
        // unless &#39;message&#39; points at least &#39;length&#39; bytes of initialized
        // memory and both &#39;hash1&#39; and &#39;hash2&#39; point to at least 8 bytes of
        // initialized, modifiable, memory.

    static void shortEnd(Uint64 &amp;h0, Uint64 &amp;h1, Uint64 &amp;h2, Uint64 &amp;h3);
        // Combine the specified &#39;h0&#39;, &#39;h1&#39;, &#39;h2&#39;, and &#39;h3&#39; together so that
        // &#39;h0&#39; and &#39;h1&#39; will be a hash of all the inputs.  Note that
        // non-BDE-standard passing by non-const reference is used here to
        // remain consistent with the cannonical implementation.

    static void shortMix(Uint64 &amp;h0, Uint64 &amp;h1, Uint64 &amp;h2, Uint64 &amp;h3);
        // Thoroughly mix the specified &#39;h0&#39;, &#39;h1&#39;, &#39;h2&#39;, and &#39;h3&#39; so that each
        // bit of input contributes entropy to every bit of the final states of
        // &#39;h0&#39;, &#39;h1&#39;, &#39;h2&#39;, and &#39;h3&#39;.  Note that non-BDE-standard passing by
        // non-const reference is used here to remain consistent with the
        // cannonical implementation.

    // NOT IMPLEMENTED
    SpookyHashAlgorithmImp(const SpookyHashAlgorithmImp&amp; original);// = delete;
        // Do not allow copy construction

    SpookyHashAlgorithmImp&amp; operator=(const SpookyHashAlgorithmImp&amp; rhs);
                                                                   // = delete;
        // Do not allow assignment

  public:
    // PUBLIC CLASS METHODS
    static Uint32 hash32(const void *message,
                         size_t      length,
                         Uint32      seed);
        // Hash the specified &#39;length&#39; bytes of &#39;message&#39; using &#39;seed&#39; as a
        // seed.  Return the resulting 32-bit hash.  The behavior is undefined
        // unless &#39;message&#39; points at least &#39;length&#39; bytes of initialized
        // memory.

    static Uint64 hash64(const void *message,
                         size_t      length,
                         Uint64      seed);
        // Hash the specified &#39;length&#39; bytes of &#39;message&#39; using &#39;seed&#39; as a
        // seed.  Return the resulting 64-bit hash.  The behavior is undefined
        // unless &#39;message&#39; points at least &#39;length&#39; bytes of initialized
        // memory.

    static void hash128(const void *message,
                        size_t      length,
                        Uint64     *hash1,
                        Uint64     *hash2);
        // Hash the specified &#39;length&#39; bytes of &#39;message&#39; using &#39;hash1&#39; and
        // &#39;hash2&#39; as seeds.  Load the higher order bits of the resulting
        // 128-bit hash value into &#39;hash1&#39; and the lower order bits in &#39;hash2&#39;.
        // The behavior is undefined unless &#39;message&#39; points at least &#39;length&#39;
        // bytes of initialized memory and both &#39;hash1&#39; and &#39;hash2&#39; point to at
        // least 8 bytes of initialized, modifiable, memory.

    // CREATORS
    SpookyHashAlgorithmImp(Uint64 seed1, Uint64 seed2);
        // Create a &#39;bslh::SpookyHashAlgorithmImp&#39;, initializing the internal
        // state of the object using the specified &#39;seed1&#39; and &#39;seed2&#39; as seeds
        // for the algorithm.

    //! ~SpookyHashAlgorithmImp() = default;
        // Destroy this object.

    // MANIPULATORS
    void update(const void *message, size_t length);
        // Accumulate the specified &#39;length&#39; bytes of &#39;message&#39; into the
        // internal state of the algorithm.  Accumulating bytes through
        // &#39;Update&#39; will produce the same result as hashing them all at once
        // through the &#39;HashXX&#39; static methods.  The behavior is undefined
        // unles &#39;message&#39; points at least &#39;length&#39; bytes of initialized
        // memory.

    void finalize(Uint64 *hash1, Uint64 *hash2);
        // Load the finalized hash into the specified &#39;hash1&#39; and &#39;hash2&#39;.
        // &#39;hash1&#39; will contain the higher order bits of the hash and &#39;hash2&#39;
        // will contain the lower order bits.  The internal state of the
        // algorithm will be modified, meaning that calling final multiple
        // times will result in different hash values being returned.  The
        // returned hash will be the same as if &#39;Hash128&#39; had been called will
        // all of the accumulated data in one block.  The behavior is
        // undefined unless both &#39;hash1&#39; and &#39;hash2&#39; point to 8 bytes of
        // modifiable memory.  Note that a value will be returned even if
        // &#39;update&#39; has not been called.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

// PUBLIC CLASS METHODS
inline
SpookyHashAlgorithmImp::Uint32 SpookyHashAlgorithmImp::hash32(
                                                           const void *message,
                                                           size_t      length,
                                                           Uint32      seed)
{
    BSLS_ASSERT(message);
    Uint64 hash1 = seed, hash2 = seed;
    hash128(message, length, &amp;hash1, &amp;hash2);
    return static_cast&lt;Uint32&gt;(hash1);
}

inline
SpookyHashAlgorithmImp::Uint64 SpookyHashAlgorithmImp::hash64(
                                                           const void *message,
                                                           size_t      length,
                                                           Uint64      seed)
{
    BSLS_ASSERT(message);
    Uint64 hash1 = seed;
    hash128(message, length, &amp;hash1, &amp;seed);
    return hash1;
}

// CREATORS
inline
SpookyHashAlgorithmImp::SpookyHashAlgorithmImp(Uint64 seed1, Uint64 seed2)
: m_length(0)
, m_remainder(0)
{
    m_state[0] = seed1;
    m_state[1] = seed2;
}

// PRIVATE CLASS METHODS
inline
void SpookyHashAlgorithmImp::end(
    const Uint64 *data,
    Uint64 &amp;h0, Uint64 &amp;h1, Uint64 &amp;h2, Uint64 &amp;h3,
    Uint64 &amp;h4, Uint64 &amp;h5, Uint64 &amp;h6, Uint64 &amp;h7,
    Uint64 &amp;h8, Uint64 &amp;h9, Uint64 &amp;h10,Uint64 &amp;h11)
{
    BSLS_ASSERT(data);
    h0 += data[0];   h1 += data[1];   h2 += data[2];   h3 += data[3];
    h4 += data[4];   h5 += data[5];   h6 += data[6];   h7 += data[7];
    h8 += data[8];   h9 += data[9];   h10 += data[10]; h11 += data[11];
    endPartial(h0,h1,h2,h3,h4,h5,h6,h7,h8,h9,h10,h11);
    endPartial(h0,h1,h2,h3,h4,h5,h6,h7,h8,h9,h10,h11);
    endPartial(h0,h1,h2,h3,h4,h5,h6,h7,h8,h9,h10,h11);
}

inline
void SpookyHashAlgorithmImp::endPartial(
    Uint64 &amp;h0, Uint64 &amp;h1, Uint64 &amp;h2, Uint64 &amp;h3,
    Uint64 &amp;h4, Uint64 &amp;h5, Uint64 &amp;h6, Uint64 &amp;h7,
    Uint64 &amp;h8, Uint64 &amp;h9, Uint64 &amp;h10,Uint64 &amp;h11)
{
    h11+= h1;    h2 ^= h11;   h1 = rot64(h1,44);
    h0 += h2;    h3 ^= h0;    h2 = rot64(h2,15);
    h1 += h3;    h4 ^= h1;    h3 = rot64(h3,34);
    h2 += h4;    h5 ^= h2;    h4 = rot64(h4,21);
    h3 += h5;    h6 ^= h3;    h5 = rot64(h5,38);
    h4 += h6;    h7 ^= h4;    h6 = rot64(h6,33);
    h5 += h7;    h8 ^= h5;    h7 = rot64(h7,10);
    h6 += h8;    h9 ^= h6;    h8 = rot64(h8,13);
    h7 += h9;    h10^= h7;    h9 = rot64(h9,38);
    h8 += h10;   h11^= h8;    h10= rot64(h10,53);
    h9 += h11;   h0 ^= h9;    h11= rot64(h11,42);
    h10+= h0;    h1 ^= h10;   h0 = rot64(h0,54);
}

inline
void SpookyHashAlgorithmImp::mix(
    const Uint64 *data,
    Uint64 &amp;s0, Uint64 &amp;s1, Uint64 &amp;s2, Uint64 &amp;s3,
    Uint64 &amp;s4, Uint64 &amp;s5, Uint64 &amp;s6, Uint64 &amp;s7,
    Uint64 &amp;s8, Uint64 &amp;s9, Uint64 &amp;s10,Uint64 &amp;s11)
{
    BSLS_ASSERT(data);
    s0 += data[0];   s2  ^= s10; s11 ^= s0;  s0  = rot64(s0,11);  s11 += s1;
    s1 += data[1];   s3  ^= s11; s0  ^= s1;  s1  = rot64(s1,32);  s0  += s2;
    s2 += data[2];   s4  ^= s0;  s1  ^= s2;  s2  = rot64(s2,43);  s1  += s3;
    s3 += data[3];   s5  ^= s1;  s2  ^= s3;  s3  = rot64(s3,31);  s2  += s4;
    s4 += data[4];   s6  ^= s2;  s3  ^= s4;  s4  = rot64(s4,17);  s3  += s5;
    s5 += data[5];   s7  ^= s3;  s4  ^= s5;  s5  = rot64(s5,28);  s4  += s6;
    s6 += data[6];   s8  ^= s4;  s5  ^= s6;  s6  = rot64(s6,39);  s5  += s7;
    s7 += data[7];   s9  ^= s5;  s6  ^= s7;  s7  = rot64(s7,57);  s6  += s8;
    s8 += data[8];   s10 ^= s6;  s7  ^= s8;  s8  = rot64(s8,55);  s7  += s9;
    s9 += data[9];   s11 ^= s7;  s8  ^= s9;  s9  = rot64(s9,54);  s8  += s10;
    s10 += data[10]; s0  ^= s8;  s9  ^= s10; s10 = rot64(s10,22); s9  += s11;
    s11 += data[11]; s1  ^= s9;  s10 ^= s11; s11 = rot64(s11,46); s10 += s0;
}

inline
SpookyHashAlgorithmImp::Uint64 SpookyHashAlgorithmImp::rot64(Uint64 x, int k)
{
    return (x &lt;&lt; k) | (x &gt;&gt; (64 - k));
}

inline
void SpookyHashAlgorithmImp::shortEnd(Uint64 &amp;h0,
                                      Uint64 &amp;h1,
                                      Uint64 &amp;h2,
                                      Uint64 &amp;h3)
{
    h3 ^= h2;  h2 = rot64(h2,15);  h3 += h2;
    h0 ^= h3;  h3 = rot64(h3,52);  h0 += h3;
    h1 ^= h0;  h0 = rot64(h0,26);  h1 += h0;
    h2 ^= h1;  h1 = rot64(h1,51);  h2 += h1;
    h3 ^= h2;  h2 = rot64(h2,28);  h3 += h2;
    h0 ^= h3;  h3 = rot64(h3,9);   h0 += h3;
    h1 ^= h0;  h0 = rot64(h0,47);  h1 += h0;
    h2 ^= h1;  h1 = rot64(h1,54);  h2 += h1;
    h3 ^= h2;  h2 = rot64(h2,32);  h3 += h2;
    h0 ^= h3;  h3 = rot64(h3,25);  h0 += h3;
    h1 ^= h0;  h0 = rot64(h0,63);  h1 += h0;
}

inline
void SpookyHashAlgorithmImp::shortMix(Uint64 &amp;h0,
                                      Uint64 &amp;h1,
                                      Uint64 &amp;h2,
                                      Uint64 &amp;h3)
{
    h2 = rot64(h2,50);  h2 += h3;  h0 ^= h2;
    h3 = rot64(h3,52);  h3 += h0;  h1 ^= h3;
    h0 = rot64(h0,30);  h0 += h1;  h2 ^= h0;
    h1 = rot64(h1,41);  h1 += h2;  h3 ^= h1;
    h2 = rot64(h2,54);  h2 += h3;  h0 ^= h2;
    h3 = rot64(h3,48);  h3 += h0;  h1 ^= h3;
    h0 = rot64(h0,38);  h0 += h1;  h2 ^= h0;
    h1 = rot64(h1,37);  h1 += h2;  h3 ^= h1;
    h2 = rot64(h2,62);  h2 += h3;  h0 ^= h2;
    h3 = rot64(h3,34);  h3 += h0;  h1 ^= h3;
    h0 = rot64(h0,5);   h0 += h1;  h2 ^= h0;
    h1 = rot64(h1,36);  h1 += h2;  h3 ^= h1;
}

}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
