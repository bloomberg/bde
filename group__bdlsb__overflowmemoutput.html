<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlsb_overflowmemoutput Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlsb_overflowmemoutput<br/>
<small>
[<a class="el" href="group__bdlsb.html">Package bdlsb</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an overflowable output <code>streambuf</code> using a client buffer.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlsb.html">bdlsb</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Overflow Buffer</a> </li>
<li>
<a href="#3.2">Streaming Architecture</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Basic Use of <code>bdlsb::OverflowMemOutput</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an overflowable output <code>streambuf</code> using a client buffer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlsb_1_1OverflowMemOutput.html">bdlsb::OverflowMemOutput</a> </td><td>overflowable output stream buffer  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlsb__fixedmemoutput.html" title="Provide a basic output stream buffer using a client buffer.">Component bdlsb_fixedmemoutput</a>, <a class="el" href="group__bdlsb__overflowmemoutstreambuf.html" title="Provide an overflowable output streambuf using a client buffer.">Component bdlsb_overflowmemoutstreambuf</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a mechanism, <code><a class="el" href="classbdlsb_1_1OverflowMemOutput.html">bdlsb::OverflowMemOutput</a></code>, that implements the output portion of the <code>bsl::basic_streambuf</code> protocol using a user-supplied memory buffer and a managed, allocator-supplied overflow buffer that is created when the client-supplied buffer runs out. Method names necessarily correspond to the protocol-specified method names. As with <code>bdlsb_overflowmemoutstreambuf</code>, clients supply the character buffer at construction. Unlike <code>bdlsb_fixedmemoutput</code>, they can no longer reinitialize the stream buffer with a different character buffer by calling the <code>pubsetbuf</code> method; instead, if that buffer runs out, the <code><a class="el" href="classbdlsb_1_1OverflowMemOutput.html">bdlsb::OverflowMemOutput</a></code> will allocate another buffer (see "Overflow Buffer" below). The only difference between this component and <code>bdlsb_overflowmemoutstreambuf</code> is that the class <code><a class="el" href="classbdlsb_1_1OverflowMemOutput.html">bdlsb::OverflowMemOutput</a></code> does <em>not</em> derive from <code>bsl::streambuf</code> and does not support locales. This is advantageous for performance reasons, as the overhead of the initialization and virtual function calls of a <code>bsl::streambuf</code> can be undesirable. The <code><a class="el" href="classbdlsb_1_1OverflowMemOutput.html">bdlsb::OverflowMemOutput</a></code> is designed to be used by generic template code that must be instantiated on a type that matches the interface of <code>bsl::streambuf</code>, but does not require an actual <code>bsl::streambuf</code>, in particular <code>bslx_genericoutstream</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="overflow_buffer"></a> <a class="anchor" id="description.overflow_buffer"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Overflow Buffer: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This output stream buffer uses the initial buffer (supplied at construction) as its output buffer. If an overflow of the initial buffer were to occur, an additional buffer (the overflow buffer) will be allocated. If this overflow buffer ever becomes full, it will be automatically grown. The overflow buffer grows geometrically (to twice the current overflow buffer size) whenever the amount of data written exceeds the amount of space available. On growth, the old overflow buffer is copied over to the newly allocated overflow buffer, and then deallocated, thus after any write one cannot assume that the overflow buffer is still the same memory. Data in the overflow buffer beyond the reach of the current write position is not guaranteed to be preserved after a growth operation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="streaming_architecture"></a> <a class="anchor" id="description.streaming_architecture"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Streaming Architecture: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Stream buffers are designed to decouple device handling from content formatting, providing the requisite device handling and possible buffering services, and leaving the formatting to the client stream. The standard C++ IOStreams library further partitions streaming into input streaming and output streaming, separating responsibilities for each at both the stream layer and the stream buffer layer. The BDE streaming library for <code>blsx</code>, including all of <code>bdlsb</code>, follows this model. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_basic_use_of_bdlsb~3A~3Aoverflowmemoutput"></a> <a class="anchor" id="usage.example_1~3A_basic_use_of_bdlsb~3A~3Aoverflowmemoutput"></a> <a class="anchor" id="description.usage.example_1~3A_basic_use_of_bdlsb~3A~3Aoverflowmemoutput"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Use of bdlsb::OverflowMemOutput: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates instantiating a template, <code><a class="el" href="classbslx_1_1GenericOutStream.html">bslx::GenericOutStream</a></code>, on a <code><a class="el" href="classbdlsb_1_1OverflowMemOutput.html">bdlsb::OverflowMemOutput</a></code> object and using the <code><a class="el" href="classbslx_1_1GenericOutStream.html">bslx::GenericOutStream</a></code> object to stream out some data. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create a stream buffer, <code>streamBuf</code>, and supply it stack allocated memory as its initial buffer: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> { k_STREAMBUF_CAPACITY = 8 };

  <span class="keywordtype">char</span>                     buffer[k_STREAMBUF_CAPACITY];
  <a class="code" href="classbdlsb_1_1OverflowMemOutput.html">bdlsb::OverflowMemOutput</a> streamBuf(buffer, k_STREAMBUF_CAPACITY);
</pre></div><br/>
<br/>
 Then, we create an instance of <code><a class="el" href="classbslx_1_1GenericOutStream.html">bslx::GenericOutStream</a></code> using <code>streamBuf</code>, with an arbitrary value for its <code>versionSelector</code>, and serialize some data: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslx_1_1GenericOutStream.html">bslx::GenericOutStream&lt;bdlsb::OverflowMemOutput&gt;</a> outStream(&amp;streamBuf,
                                                             20150707);
  <span class="keywordtype">int</span> MAGIC = 0x1812;
  outStream.putInt32(MAGIC);
  outStream.putInt32(MAGIC+1);
</pre></div><br/>
<br/>
 Next, we verify that the data was correctly serialized and completely filled initial buffer supplied at the stream buffer construction: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(outStream.isValid());
  assert(8 == streamBuf.dataLength());
  assert(0 == bsl::memcmp(streamBuf.initialBuffer(),
                          <span class="stringliteral">&quot;\x00\x00\x18\x12\x00\x00\x18\x13&quot;</span>,
                          8));
  assert(0 == bsl::memcmp(buffer, <span class="stringliteral">&quot;\x00\x00\x18\x12\x00\x00\x18\x13&quot;</span>, 8));
  assert(0 == streamBuf.overflowBuffer());
  assert(0 == streamBuf.overflowBufferSize());
</pre></div><br/>
<br/>
 Then, we serialize some more data to trigger allocation of the internal overflow buffer: <br/>
<br/>
<div class="fragment"><pre class="fragment">  outStream.putString(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>(<span class="stringliteral">&quot;test&quot;</span>));
</pre></div><br/>
<br/>
 Finally, we verify that the additional data was serialized correctly and landed into dynamically allocated overflow buffer: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(outStream.isValid());
  assert(13 == streamBuf.dataLength());
  assert(0  != streamBuf.overflowBuffer());
  assert(5  == streamBuf.dataLengthInOverflowBuffer());
  assert(0  == bsl::memcmp(streamBuf.overflowBuffer(), <span class="stringliteral">&quot;\x04test&quot;</span>, 5));
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:48 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
