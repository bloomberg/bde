<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btlsc_timedchannel Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btlsc_timedchannel<br/>
<small>
[<a class="el" href="group__btlsc.html">Package btlsc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a protocol for stream-based communication with a timeout.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtlsc.html">btlsc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Protocol Hierarchy</a> </li>
<li>
<a href="#3.2">Synchronous Stream-Based Transport</a> </li>
<li>
<a href="#3.3">Buffered Transport</a> </li>
<li>
<a href="#3.4">Partial Results</a> <ul>
<li>
<a href="#3.4.1">Asynchronous Events</a> </li>
<li>
<a href="#3.4.2">Timeouts</a> </li>
<li>
<a href="#3.4.3">Raw Transmissions Cannot Produce "Partial Results"</a> </li>
<li>
<a href="#3.4.4"><code>augStatus</code></a> </li>
</ul>
</li>
<li>
<a href="#3.5">Scatter/Gather (<code>readv</code>/<code>writev</code>)</a> </li>
<li>
<a href="#3.6">Synopsis</a> </li>
<li>
<a href="#3.7">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a protocol for stream-based communication with a timeout. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a> </td><td>synchronous stream-based channel protocol with timeout  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btlsc__timedcbchannel.html" title="Provide protocol for stream-based data communication with timeout.">Component btlsc_timedcbchannel</a>, <a class="el" href="group__btlsc__timedchannelallocator.html" title="Provide protocol for stream-based channel allocators with timeout.">Component btlsc_timedchannelallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a class, <code><a class="el" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a></code>, that defines an abstract interface for an end-point of a bi-directional synchronous (i.e., blocking) stream-based communication channel with timeout capability. The <code><a class="el" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a></code> protocol supports efficient "buffered" transport and the syntax to enable efficient vector I/O operations (i.e., Unix-style scatter/gather "readv" and "writev"). Various forms of "partial transmission" authorizations (i.e., "raw" OS-level atomic operations and interruptions due to a user-specified "timeout" or an "asynchronous event") are also supported as appropriate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="protocol_hierarchy"></a> <a class="anchor" id="description.protocol_hierarchy"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Protocol Hierarchy: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The interface hierarchy (defined by direct public inheritance) of the <code><a class="el" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a></code> protocol is as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">                        ,-------------------.
                       ( <a class="code" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a> )
                        `-------------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">                                  |</span>
<span class="stringliteral">                                  V</span>
<span class="stringliteral">                           ,--------------.</span>
<span class="stringliteral">                          ( btlsc::Channel )</span>
<span class="stringliteral">                           `--------------&#39;</span>
</pre></div><br/>
<br/>
 This protocol adds a "timeout" capability for read and write methods. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="synchronous_stream-based_transport"></a> <a class="anchor" id="description.synchronous_stream-based_transport"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Synchronous Stream-Based Transport: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This interface establishes methods for synchronous stream-based transport. Each read and write method will block until one of three possible outcomes is reached: (1) "success" -- the specified number of bytes was transmitted, (2) "partial result" -- the operation was interrupted (e.g., via a timeout), (3) "error" -- an implementation-dependent error occurred. In all cases, a "status" value is returned; an optional leading (<code>int *</code>) <code>augStatus</code> argument may be provided to enable the caller to distinguish among various reasons for a partial result (see below). The user may retry a partial-result operation (with method arguments suitably adjusted), with a reasonable expectation of success. Finally, concrete blocking stream-based channels do a "best effort" in sending and receiving the specified data, but need not guarantee successful transmission. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="buffered_transport"></a> <a class="anchor" id="description.buffered_transport"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Buffered Transport: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Non-vector read operations support a "buffered" variant that may be more efficient in some situations. For such operations, the prefix "buffered" (or infix "Buffered") appears before the basic operation name in the full method name (e.g., <code>bufferedRead</code>, <code>timedBufferedRead</code>). Note that, for synchronous channels, there is no need for buffered write operations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the buffered operations, the caller does not provide a buffer, but rather receives direct (non-modifiable) access to the implementation's buffer. In the event of a partial read (see below), the data remains buffered and subsequent reads will behave as if the buffered operation had never occurred. Once a buffered read operation succeeds (i.e., receives the requested number of bytes) the buffered contents will remain valid only as long as the channel is not modified (or deallocated). Note that "buffered" and "vector" (<code>readv</code>, see below) are incompatible read options. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="partial_results"></a> <a class="anchor" id="description.partial_results"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Partial Results: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The "simple" results of read and write operations are "success" (with a status equal to the requested number of bytes) and "error" (with a negative status). More complex behavior is also supported, some of which is at the option of the user. Specifically, the caller may authorize the possibility of another outcome via combinations of the following two mechanisms: (1) a user-requested timeout, and (2) an interruption due to an asynchronous event. These two mechanisms (discussed in more detail below) may each return with a "partial result", indicated by a non-negative status that is less than the requested number of bytes. Note that timeouts and asynchronous events may result in a return status of zero bytes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="asynchronous_events"></a> <a class="anchor" id="partial_results.asynchronous_events"></a> <a class="anchor" id="description.partial_results.asynchronous_events"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Asynchronous Events: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Methods in this protocol anticipate the possible occurrence of an "asynchronous event" (AE) during execution. A common example of an AE is a Unix signal, but note that a specific Unix signal, if not detected or implemented, <em>may</em> not result in an AE, and an AE is certainly not limited to signals, even on Unix platforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This interface cannot fully specify either the nature of or the behavior resulting from an AE, but certain restrictions can be (and are) imposed. By default, AEs are either ignored or, if that is not possible, cause an error. At the user's option, however, a concrete implementation can be authorized to return, if such occurrence is detected, a "partial result" upon occurrence of an AE. Such authorizations are made explicitly by incorporating into the optional (trailing) integer <code>flags</code> argument to a method call the <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code> value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="timeouts"></a> <a class="anchor" id="partial_results.timeouts"></a> <a class="anchor" id="description.partial_results.timeouts"></a> <a class="anchor" id="3.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Timeouts: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A timeout is registered by the caller, when a method is invoked, as a <code><a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a></code> value indicating the absolute <em>system</em> time after which the operation should be interrupted. A timeout expiration will return a "partial result" (see above). Information regarding the nature of a partial result is provided if the optional <code>augStatus</code> argument is specified (see below). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The concrete channel will make a "best effort" to honor the timeout request promptly, but no guarantee can be made as to the maximum duration of any particular I/O attempt. Any implementation of this interface will support a timeout granularity of ten milliseconds (0.01s) or less. The timeout is guaranteed <em>not</em> to occur before the specified time has passed. If a timeout is specified with a time that has already passed, the I/O operation will be attempted, but will not block. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="raw_transmissions_cannot_produce_~22partial_results~22"></a> <a class="anchor" id="partial_results.raw_transmissions_cannot_produce_~22partial_results~22"></a> <a class="anchor" id="description.partial_results.raw_transmissions_cannot_produce_~22partial_results~22"></a> <a class="anchor" id="3.4.3"></a> </dd></dl>
<dl class="user"><dt><b>Raw Transmissions Cannot Produce "Partial Results": </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>All read and unbuffered write methods support a "raw" variant in which the operation is allowed to return after transmitting at least one byte, but less than a "partial result" if (1) <em>at</em> <em>least</em> <em>one</em> <em>byte</em> has been transmitted and (2) no additional bytes are <em>immediately</em> transmittable. The "raw" mode is particularly useful to callers waiting for some read activity, who will then follow up with additional read requests after observing the initial transmission. Raw transmissions are authorized by methods whose names end in the suffix <code>Raw</code>. Note that the "raw" mode is not supported for buffered-write operations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="augstatus"></a> <a class="anchor" id="partial_results.augstatus"></a> <a class="anchor" id="description.partial_results.augstatus"></a> <a class="anchor" id="3.4.4"></a> </dd></dl>
<dl class="user"><dt><b>augStatus: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Since there are several possible reasons for a "partial result", the caller may wish to know the specific cause. A second status value, <code>augStatus</code> ("augmented status") may be requested as an optional <em>initial</em> (<code>int *</code>) argument to each transmission function. If specified, <code>augStatus</code> will be set to 0 if a user-supplied timeout interrupted the operation, and to a positive value if the interruption was due to an "asynchronous event". Note that <code>augStatus</code> will not be modified on success or error, but only on a partial result. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="scatter~2Fgather_(readv~2Fwritev)"></a> <a class="anchor" id="description.scatter~2Fgather_(readv~2Fwritev)"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Scatter/Gather (readv/writev): </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This interface supports "vector I/O" -- the simultaneous reading from or writing to multiple buffers -- via Unix-style <code>readv</code> and <code>writev</code> variants of the normal single-buffer methods. Scatter/Gather operations use either the <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> or <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> objects which use a <code>iovec</code> <code>struct</code> on Unix platforms or a <code>WSABUF</code> <code>struct</code> on Windows. In either structure, the total number of bytes to be read or written is determined by the sum of each buffer of the non-negative <code>numBuffers</code>. Note that the <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> variant enables write operations to avoid having to cast away <code>const</code> in order to hold the address of non-modifiable data to be written. The following simple example shows how to create and populate a <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> array in preparation for a <code>writev</code> operation: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> myPrintWriteStatus(<span class="keywordtype">int</span> status, <span class="keywordtype">int</span> augStatus, <span class="keywordtype">int</span> numBytes)
      <span class="comment">// Print to the user console the result of a attempting to write</span>
      <span class="comment">// the specified &#39;numBytes&#39; based on the specified write &#39;status&#39;</span>
      <span class="comment">// and the auxiliary &#39;augStatus&#39; (discussed below).  The behavior</span>
      <span class="comment">// is undefined unless &#39;0 &lt; numBytes&#39; and &#39;status &lt;= numBytes&#39;.  Note</span>
      <span class="comment">// that &#39;augStatus&#39; is ignored unless &#39;0 &lt;= status &lt; numBytes&#39;.</span>
     {
         assert(0 &lt; numBytes);
         assert(status &lt;= numBytes);

         <span class="keywordflow">if</span> (status == numBytes) {
             bsl::cout &lt;&lt; <span class="stringliteral">&quot;All requested bytes written successfully.&quot;</span>
                       &lt;&lt; bsl::endl;
         }
         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (status &gt;= 0) { <span class="comment">// PARTIAL RESULTS ARE NOT AUTHORIZED BELOW.</span>

             <span class="keywordflow">if</span> (augStatus &gt; 0) {
                 bsl::cout &lt;&lt; <span class="stringliteral">&quot;Write interrupted (not by time out) after &quot;</span>
                           &lt;&lt; <span class="stringliteral">&quot;writing &quot;</span> &lt;&lt; status &lt;&lt; <span class="stringliteral">&quot; of &quot;</span> &lt;&lt; numBytes
                           &lt;&lt; <span class="stringliteral">&quot; bytes.&quot;</span> &lt;&lt; bsl::endl;
             }
             <span class="keywordflow">else</span> (0 == augStatus) {
                 bsl::cout &lt;&lt; <span class="stringliteral">&quot;Write timed out after writing &quot;</span> &lt;&lt; status
                           &lt;&lt; <span class="stringliteral">&quot; of &quot;</span> &lt;&lt; numBytes &lt;&lt; <span class="stringliteral">&quot; bytes.&quot;</span> &lt;&lt; bsl::endl;
             }
             <span class="keywordflow">else</span> {
                 assert(0 &lt; status);
                 bsl::cout &lt;&lt; <span class="stringliteral">&quot;Write (efficiently) transmitted &quot;</span>
                           &lt;&lt; status &lt;&lt; <span class="stringliteral">&quot; of &quot;</span> &lt;&lt; numBytes &lt;&lt; bytes.<span class="stringliteral">&quot;</span>
<span class="stringliteral">                           &lt;&lt; bsl::endl;</span>
<span class="stringliteral">             }</span>
<span class="stringliteral">         }</span>
<span class="stringliteral">         else if (-1 == status) {</span>
<span class="stringliteral">             bsl::cout &lt;&lt; &quot;</span>Write failed: connection was closed by peer.<span class="stringliteral">&quot;</span>
<span class="stringliteral">                       &lt;&lt; bsl::endl;</span>
<span class="stringliteral">         }</span>
<span class="stringliteral">         else {</span>
<span class="stringliteral">             assert(-1 &gt; status);</span>
<span class="stringliteral">             bsl::cout &lt;&lt; &quot;</span>Write failed: the reason is unknown.<span class="stringliteral">&quot;</span>
<span class="stringliteral">                       &lt;&lt; bsl::endl;</span>
<span class="stringliteral">         }</span>
<span class="stringliteral">     }</span>
<span class="stringliteral"></span>
<span class="stringliteral">     void myWritevAndPrintStatusWhenAvailable(btlsc::TimedChannel *channel)</span>
<span class="stringliteral">         // Write the integer representation of the length of a character</span>
<span class="stringliteral">         // string followed by the (null-terminated) string data itself to</span>
<span class="stringliteral">         // the specified &#39;channel&#39;; upon completion, report the status</span>
<span class="stringliteral">         // of the &quot;</span>write<span class="stringliteral">&quot; operation to &#39;cout&#39;.</span>
<span class="stringliteral">     {</span>
<span class="stringliteral">         const char *const MESSAGE     = &quot;</span>Hello World!<span class="stringliteral">&quot;;</span>
<span class="stringliteral">         const int         HEADER      = strlen(MESSAGE);</span>
<span class="stringliteral">         const int         NUM_BUFFERS = 2;</span>
<span class="stringliteral"></span>
<span class="stringliteral">         btls::Ovec buffers[NUM_BUFFERS];</span>
<span class="stringliteral"></span>
<span class="stringliteral">         // Set each buffer&#39;s data and corresponding length.</span>
<span class="stringliteral"></span>
<span class="stringliteral">         buffer[0].setBuffer(&amp;HEADER, sizeof HEADER);</span>
<span class="stringliteral">         buffer[1].setBuffer(MESSAGE, HEADER);</span>
<span class="stringliteral"></span>
<span class="stringliteral">         if (0 &gt; channel-&gt;writev(buffers, NUM_BUFFERS)) {</span>
<span class="stringliteral">             bsl::cout &lt;&lt; &quot;</span>Buffered write operation failed!<span class="stringliteral">&quot; &lt;&lt; bsl::endl;</span>
<span class="stringliteral">         }</span>
<span class="stringliteral"></span>
<span class="stringliteral">         // Notice that the &#39;writev&#39; operation above does not</span>
<span class="stringliteral">         // authorize any partial write operations whatsoever.</span>
<span class="stringliteral">    }</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="synopsis"></a> <a class="anchor" id="description.synopsis"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Synopsis: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following chart summarizes the set of 20 transmission methods that are available to read and write data from and to a <code><a class="el" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a></code>; note that "buffered readv" and all "buffered write (and writev)" operations (and their "timed" counterparts) are nonsensical and, therefore, omitted from the protocol: <br/>
<br/>
<div class="fragment"><pre class="fragment">    Buffered  Re/Wr  Vec  Raw  Untimed Method Name  Timed Method Name
    --------  -----  ---  ---  -------------------  -----------------
              READ             read                 timedRead
              READ        RAW  readRaw              timedReadRaw

              READ   VEC       readv                timedReadv
              READ   VEC  RAW  readvRaw             timedReadvRaw

    BUFFERED  READ             bufferedRead         timedBufferedRead
    BUFFERED  READ        RAW  bufferedReadRaw      timedBufferedReadRaw

              WRITE            write                timedWrite
              WRITE       RAW  writeRaw             timedWriteRaw

              WRITE  VEC       writev               timedWritev
              WRITE  VEC  RAW  writevRaw            timedWritevRaw
</pre></div><br/>
<br/>
 Each of these methods supports the specification of a flag value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a>
</pre></div><br/>
<br/>
 supplied in an optional trailing integer to enable "asynchronous events" to cause partial results; by default, such events are ignored. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Each of these methods is overloaded to allow the caller to optionally specify the address of an <code>augStatus</code>, which will then be modified in the event of a partial result. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>btlsc</code> style of channel interface is used to transmit sequences of specified size across some concrete channel implementation. In this example we demonstrate how to implement a remote procedure call (RPC) to a factorial function taking an <code>int</code> and returning a <code>double</code>. For simplicity, we will assume that both the <code>int</code> and <code>double</code> formats are binary compatible across client and server platforms. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">double</span> factorial(<span class="keywordtype">int</span> number)
      <span class="comment">// Return the factorial of the specified integral &#39;number&#39; as a value</span>
      <span class="comment">// of type &#39;double&#39;.  The behavior is undefined unless &#39;0 &lt;= number&#39;.</span>
      <span class="comment">// Note that this helper function is provided for the server to</span>
      <span class="comment">// calculate the factorial value.</span>
  {
      <span class="keywordflow">if</span> (0 == number) {
          <span class="keywordflow">return</span> 1;                                                 <span class="comment">// RETURN</span>
      }
      <span class="keywordflow">else</span> {
          <span class="keywordflow">return</span> number * factorial(number - 1);                    <span class="comment">// RETURN</span>
      }
  }

  <span class="keywordtype">int</span> factorialClient(<span class="keywordtype">double</span>              *result,
                      <span class="keywordtype">int</span>                  input,
                      <a class="code" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a> *channel)
      <span class="comment">// Load into the specified &#39;result&#39; the factorial of the specified</span>
      <span class="comment">// &#39;input&#39; using the specified &#39;channel&#39; (which is assumed to be</span>
      <span class="comment">// connected to an appropriate factorial service).  Return 0 on</span>
      <span class="comment">// success, and -1, with no effect on &#39;result&#39;, on error.  The behavior</span>
      <span class="comment">// is undefined unless &#39;0 &lt;= input&#39;.</span>
  {
      ASSERT(0 &lt;= input);

      <span class="keyword">enum</span> {
          k_ERROR_STATUS   = -1,
          k_SUCCESS_STATUS =  0,
          k_TIMEOUT_STATUS =  1
      };

      <span class="keyword">enum</span> {
          k_WRITE_TIMEOUT = 1,     <span class="comment">// seconds</span>
          k_READ_TIMEOUT  = 5      <span class="comment">// seconds</span>
      };
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> timeNow = <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>();
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> writeTimeout(timeNow + k_WRITE_TIMEOUT);
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> readTimeout(timeNow + k_READ_TIMEOUT);

      <span class="keywordtype">int</span> numBytes = <span class="keyword">sizeof</span> input;
      <span class="keywordtype">int</span> writeStatus = channel-&gt;<a class="code" href="classbtlsc_1_1TimedChannel.html#adfb9b67e2675cf0bac48100380b7be46">timedWrite</a>((<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;input,
                                             numBytes,
                                             writeTimeout);
      ASSERT(0 != writeStatus);

      <span class="keywordflow">if</span> (writeStatus != numBytes) {
          <span class="keywordflow">return</span> k_ERROR_STATUS;                                    <span class="comment">// RETURN</span>
      }

      <span class="keywordtype">int</span> readStatus = channel-&gt;<a class="code" href="classbtlsc_1_1TimedChannel.html#aae95f9e919d0b410e8b98631f408f15c">timedRead</a>((<span class="keywordtype">char</span> *)result,
                                          <span class="keyword">sizeof</span> *result,
                                          readTimeout);
      <span class="keywordflow">if</span> (readStatus != <span class="keyword">sizeof</span> *result) {
          <span class="keywordflow">return</span> k_ERROR_STATUS;                                    <span class="comment">// RETURN</span>
      }

      <span class="keywordflow">return</span> k_SUCCESS_STATUS;                                      <span class="comment">// RETURN</span>
  }

  <span class="keywordtype">int</span> factorialServer(<a class="code" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a> *channel)
      <span class="comment">// Repeatedly read integer sequences from the specified &#39;channel&#39;.</span>
      <span class="comment">// When a read succeeds, interpret the byte sequence as an integer</span>
      <span class="comment">// value in host-byte order.  Return -1 if that value is negative.</span>
      <span class="comment">// Otherwise, calculate the factorial of the (non-negative) integer and</span>
      <span class="comment">// write back the result to &#39;channel&#39; as a sequence of bytes</span>
      <span class="comment">// representing a &#39;double&#39; in the host&#39;s native format.  Return a</span>
      <span class="comment">// negative value if any write operation doesn&#39;t succeed (refer to the</span>
      <span class="comment">// following &#39;enum&#39; values for specific errors).  Note that this</span>
      <span class="comment">// implementation is just to show how a channel could be used; there is</span>
      <span class="comment">// much room to improve.</span>
  {
      <span class="keyword">enum</span> {
          k_SUCCESS            =  0,
          k_INVALID_INPUT      = -1,
          k_ERROR_READ         = -2,
          k_ERROR_WRITE        = -3,
          k_ERROR_TIMEOUT      = -4,
          k_ERROR_INTERRUPTED  = -5,
          k_ERROR_UNCLASSIFIED = -6
      };

      <span class="keyword">enum</span> {
          k_READ_TIME  = 3600, <span class="comment">// an hour</span>
          k_WRITE_TIME = 2     <span class="comment">// 2 seconds</span>
      };
      <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> timeNow = <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>();
      <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> k_READ_TIMEOUT(timeNow + k_READ_TIME),
                              k_WRITE_TIMEOUT(timeNow + k_WRITE_TIME);

      <span class="keywordflow">while</span> (1) {
          <span class="keywordtype">int</span> input, augStatus;
          <span class="keywordtype">int</span> readStatus = channel-&gt;<a class="code" href="classbtlsc_1_1TimedChannel.html#aae95f9e919d0b410e8b98631f408f15c">timedRead</a>(&amp;augStatus,
                                              (<span class="keywordtype">char</span> *)&amp;input,
                                              <span class="keyword">sizeof</span> input,
                                              k_READ_TIMEOUT);
          <span class="keywordflow">if</span> (readStatus &lt; 0) {
              <span class="keywordflow">return</span> k_ERROR_READ;                                  <span class="comment">// RETURN</span>
          }
          <span class="keywordflow">if</span> (readStatus != <span class="keyword">sizeof</span> input) {
              <span class="keywordflow">if</span> (0 == augStatus) {
                  <span class="keywordflow">return</span> k_ERROR_TIMEOUT;                           <span class="comment">// RETURN</span>
              }
              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (augStatus &gt; 0) {
                  <span class="keywordflow">return</span> k_ERROR_INTERRUPTED;                       <span class="comment">// RETURN</span>
              }
              <span class="keywordflow">return</span> k_ERROR_UNCLASSIFIED;                          <span class="comment">// RETURN</span>
          }
          <span class="keywordflow">if</span> (input &lt; 0) {
              <span class="keywordflow">return</span> k_INVALID_INPUT;                               <span class="comment">// RETURN</span>
          }

          augStatus = 0;
          <span class="keywordtype">double</span> result = factorial(input);
          <span class="keywordtype">int</span> writeStatus = channel-&gt;<a class="code" href="classbtlsc_1_1TimedChannel.html#adfb9b67e2675cf0bac48100380b7be46">timedWrite</a>(&amp;augStatus,
                                                (<span class="keyword">const</span> <span class="keywordtype">char</span> *)&amp;result,
                                                <span class="keyword">sizeof</span> input,
                                                k_WRITE_TIMEOUT);
          <span class="keywordflow">if</span> (writeStatus &lt; 0) {
              <span class="keywordflow">return</span> k_ERROR_WRITE;                                 <span class="comment">// RETURN</span>
          }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (writeStatus != <span class="keyword">sizeof</span> input){
              <span class="keywordflow">if</span> (0 == augStatus) {
                  <span class="keywordflow">return</span> k_ERROR_TIMEOUT;                           <span class="comment">// RETURN</span>
              }
              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (augStatus &gt; 0) {
                  <span class="keywordflow">return</span> k_ERROR_INTERRUPTED;                       <span class="comment">// RETURN</span>
              }
              <span class="keywordflow">return</span> k_ERROR_UNCLASSIFIED;                          <span class="comment">// RETURN</span>
          }
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:14 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
