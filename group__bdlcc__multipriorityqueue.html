<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlcc_multipriorityqueue Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlcc_multipriorityqueue<br/>
<small>
[<a class="el" href="group__bdlcc.html">Package bdlcc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a thread-enabled parameterized multi-priority queue.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlcc.html">bdlcc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread-Enabled Idioms in the <code>bdlcc::MultipriorityQueue</code> Interface</a> </li>
<li>
<a href="#3.2">Possible Future Enhancements</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Example 1: Simple Thread Pool</a> </li>
<li>
<a href="#3.3.2">Example 2: Multi-Threaded Observer</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a thread-enabled parameterized multi-priority queue. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlcc_1_1MultipriorityQueue.html">bdlcc::MultipriorityQueue</a> </td><td>thread-enabled, multi-priority queue  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a thread-enabled mechanism, <code><a class="el" href="classbdlcc_1_1MultipriorityQueue.html">bdlcc::MultipriorityQueue</a></code>, implementing a special-purpose priority queue container of items of parameterized <code>TYPE</code>. Each item has a priority which, for efficiency of implementation, is limited to a relatively small number <code>N</code> of contiguous integers <code>[ 0 .. N - 1 ]</code>, with <code>N</code> indicated at construction, and 0 being the most urgent priority. This queue also takes an optional allocator, supplied at construction. Once configured, these instance parameters remain unchanged for the life of each multi-priority queue. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread-enabled_idioms_in_the_bdlcc~3A~3Amultipriorityqueue_interface"></a> <a class="anchor" id="description.thread-enabled_idioms_in_the_bdlcc~3A~3Amultipriorityqueue_interface"></a> <a class="anchor" id="thread-enabled_idioms_in_the_bdlcc"></a> <a class="anchor" id="description.thread-enabled_idioms_in_the_bdlcc"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread-Enabled Idioms in the bdlcc::MultipriorityQueue Interface: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The thread-enabled <code><a class="el" href="classbdlcc_1_1MultipriorityQueue.html">bdlcc::MultipriorityQueue</a></code> is, in many regards, similar to a value-semantic type in that there is an obvious abstract notion of "value" that can be described in terms of salient attributes, which for this type is a sequence of priority/element pairs, constrained to be in increasing order of priority. There are, however, several differences in method behavior and signature that arise due to the thread-enabled nature of the queue and its anticipated usage pattern. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, if a queue object is empty, <code>popFront</code> will block indefinitely until an element is added to the queue. Also, since dynamic instance information, such as the number of elements currently in a queue, can be out-of-date by the time it is returned, some manipulators (e.g., <code>tryPopFront</code>) are deliberately combined with an accessor operation (e.g., <code>isEmpty</code>) in order to guarantee proper behavior. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, note that although the parameterized <code>TYPE</code> is expected to at least support copy construction and assignment, the <code>bdec::MultipriorityQueue&lt;TYPE&gt;</code> type currently does not support any value-semantic operations, since different queues could have different numbers of priorities, making comparison, assignment and copy construction awkward. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="possible_future_enhancements"></a> <a class="anchor" id="description.possible_future_enhancements"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Possible Future Enhancements: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition to <code>popFront</code> and <code>tryPopFront</code>, a <code><a class="el" href="classbdlcc_1_1MultipriorityQueue.html">bdlcc::MultipriorityQueue</a></code> may some day also provide a <code>timedPopFront</code> method. This method would block until it is able to complete successfully or until the specified time limit expires. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_simple_thread_pool"></a> <a class="anchor" id="usage.example_1~3A_simple_thread_pool"></a> <a class="anchor" id="description.usage.example_1~3A_simple_thread_pool"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Simple Thread Pool: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates how we might use a <code><a class="el" href="classbdlcc_1_1MultipriorityQueue.html">bdlcc::MultipriorityQueue</a></code> to communicate between a single "producer" thread and multiple "consumer" threads. The "producer" pushes work requests of varying priority onto the queue, and each "consumer" iteratively takes the highest priority work request from the queue and services it. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We begin our example with some utility classes that define a simple "work
 item": <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> {
      k_MAX_CONSUMER_THREADS = 10
  };

  <span class="keyword">struct </span>MyWorkData {
      <span class="keywordtype">int</span> d_i;        <span class="comment">// input to work to be done</span>

      <span class="comment">// Work data...</span>
  };

  <span class="keyword">struct </span>MyWorkRequest {
      <span class="keyword">enum</span> RequestType {
          e_WORK = 1,
          e_STOP = 2
      };

      RequestType d_type;
      MyWorkData  d_data;

      <span class="comment">// Work data...</span>
  };
</pre></div><br/>
<br/>
 Next, we provide a simple function to service an individual work item, and a function to get a work item. The details are unimportant for this example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myDoWork(MyWorkData&amp; data)
  {
      <span class="comment">// Do work...</span>
      (void)data;
  }

  <span class="keywordtype">int</span> getWorkData(MyWorkData *result)
  {
      <span class="keyword">static</span> <span class="keywordtype">int</span> count = 0;
      result-&gt;d_i = rand();   <span class="comment">// Only one thread runs this routine, so it</span>
                              <span class="comment">// does not matter that &#39;rand()&#39; is not</span>
                              <span class="comment">// thread-safe, or that &#39;count&#39; is &#39;static&#39;.</span>

      <span class="keywordflow">return</span> ++count &gt;= 100;
  }
</pre></div><br/>
<br/>
 The <code>myConsumer</code> function (below) will pop elements off the queue in priority order and process them. As discussed above, note that the call to <code>queue-&gt;popFront(&amp;item)</code> will block until there is an element available on the queue. This function will be executed in multiple threads, so that each thread waits in <code>queue-&gt;popFront()</code>; <code><a class="el" href="classbdlcc_1_1MultipriorityQueue.html">bdlcc::MultipriorityQueue</a></code> guarantees that each thread gets a unique element from the queue: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myConsumer(<a class="code" href="classbdlcc_1_1MultipriorityQueue.html">bdlcc::MultipriorityQueue&lt;MyWorkRequest&gt;</a> *queue)
  {
      MyWorkRequest item;
      <span class="keywordflow">while</span> (1) {

          <span class="comment">// The &#39;popFront&#39; function will wait for a &#39;MyWorkRequest&#39; until</span>
          <span class="comment">// one is available.</span>

          queue-&gt;<a class="code" href="classbdlcc_1_1MultipriorityQueue.html#a70ff34c3f81809af872c13021907b836">popFront</a>(&amp;item);

          <span class="keywordflow">if</span> (MyWorkRequest::e_STOP == item.d_type) {
              <span class="keywordflow">break</span>;
          }

          myDoWork(item.d_data);
      }
  }
</pre></div><br/>
<br/>
 The <code>myConsumerThread</code> function below is a callback for <code><a class="el" href="structbslmt_1_1ThreadUtil.html">bslmt::ThreadUtil</a></code>, which requires a "C" signature. <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create()</a></code> expects a pointer to this function, and provides that function pointer to the newly-created thread. The new thread then executes this function. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Since <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create()</a></code> uses the familiar "C" convention of passing a <code>void</code> pointer, our function simply casts that pointer to our required type (<code><a class="el" href="classbdlcc_1_1MultipriorityQueue.html">bdlcc::MultipriorityQueue</a>&lt;MyWorkRequest&gt; *</code>), and then delegates to the queue-specific function <code>myConsumer</code> (above): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *myConsumerThread(<span class="keywordtype">void</span> *queuePtr)
  {
      myConsumer ((<a class="code" href="classbdlcc_1_1MultipriorityQueue.html">bdlcc::MultipriorityQueue&lt;MyWorkRequest&gt;</a>*) queuePtr);
      <span class="keywordflow">return</span> queuePtr;
  }
</pre></div><br/>
<br/>
 In this simple example, the <code>myProducer</code> function (below) serves multiple roles: it creates the <code><a class="el" href="classbdlcc_1_1MultipriorityQueue.html">bdlcc::MultipriorityQueue</a></code>, starts the consumer threads, and then produces and queues work items. When work requests are exhausted, this function queues one <code>e_STOP</code> item for each consumer thread. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When each consumer thread reads a <code>e_STOP</code>, it terminates its thread-handling function. Note that, although the producer cannot control which thread pops a particular work item, it can rely on the knowledge that each consumer thread will read a single <code>e_STOP</code> item and then terminate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, the <code>myProducer</code> function "joins" each consumer thread, which ensures that the thread itself will terminate correctly (see the <code>bslmt_threadutil</code> component-level documentation for details): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myProducer()
  {
      <span class="keyword">enum</span> {
          k_NUM_PRIORITIES = 8,
          k_NUM_THREADS    = 8
      };

      MyWorkRequest item;
      MyWorkData    workData;

      <span class="comment">// Create multi-priority queue with specified number of priorities.</span>

      <a class="code" href="classbdlcc_1_1MultipriorityQueue.html">bdlcc::MultipriorityQueue&lt;MyWorkRequest&gt;</a> queue(k_NUM_PRIORITIES);

      <span class="comment">// Start the specified number of threads.</span>

      assert(0 &lt; k_NUM_THREADS
          &amp;&amp; k_NUM_THREADS &lt;= static_cast&lt;int&gt;(k_MAX_CONSUMER_THREADS));
      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> consumerHandles[k_MAX_CONSUMER_THREADS];

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; k_NUM_THREADS; ++i) {
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;consumerHandles[i],
                                   myConsumerThread,
                                   &amp;queue);
      }

      <span class="comment">// Load work data into work requests and push them onto the queue with</span>
      <span class="comment">// varying priority until all work data has been exhausted.</span>

      <span class="keywordtype">int</span> count = 0;                          <span class="comment">// used to generate priorities</span>

      <span class="keywordflow">while</span> (!getWorkData(&amp;workData)) {       <span class="comment">// see declaration (above)</span>
          item.d_type = MyWorkRequest::e_WORK;
          item.d_data = workData;
          queue.<a class="code" href="classbdlcc_1_1MultipriorityQueue.html#a3ab01160056b4a6af31917a333ee8019">pushBack</a>(item, count % k_NUM_PRIORITIES);  <span class="comment">// mixed</span>
                                                           <span class="comment">// priorities</span>
          ++count;
      }

      <span class="comment">// Load as many stop requests as there are active consumer threads.</span>

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; k_NUM_THREADS; ++i) {
          item.d_type = MyWorkRequest::e_STOP;
          queue.<a class="code" href="classbdlcc_1_1MultipriorityQueue.html#a3ab01160056b4a6af31917a333ee8019">pushBack</a>(item, k_NUM_PRIORITIES - 1);  <span class="comment">// lowest priority</span>
      }

      <span class="comment">// Join all of the consumer threads back with the main thread.</span>

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; k_NUM_THREADS; ++i) {
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(consumerHandles[i]);
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_multi-threaded_observer"></a> <a class="anchor" id="usage.example_2~3A_multi-threaded_observer"></a> <a class="anchor" id="description.usage.example_2~3A_multi-threaded_observer"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Multi-Threaded Observer: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The previous example shows a simple mechanism for distributing work requests over multiple threads. This approach works well for large tasks that can be decomposed into discrete, independent tasks that can benefit from parallel execution. Note also that the various threads are synchronized only at the end of execution, when the producer "joins" the various consumer threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The simple strategy used in the first example works well for tasks that share no state, and are completely independent of one another. For instance, a web server might use a similar strategy to distribute <code>http</code> requests across multiple worker threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In more complicated examples, it is often necessary or desirable to synchronize the separate tasks during execution. The second example below shows a single "Observer" mechanism that receives event notification from the various worker threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We first create a simple <code>MyEvent</code> data type. Worker threads will use this type to report information about their work. In our example, we will report the "worker Id", the event number, and some arbitrary text. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As with the previous example, class <code>MyEvent</code> also contains an <code>EventType</code>, an enumeration that indicates whether the worker has completed all work. The "Observer" will use this enumerated value to note when a worker thread has completed its work: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> {
      k_MAX_CONSUMER_THREADS = 10,
      k_MAX_EVENT_TEXT       = 80
  };

  <span class="keyword">struct </span>MyEvent {
      <span class="keyword">enum</span> EventType {
          e_IN_PROGRESS   = 1,
          e_TASK_COMPLETE = 2
      };

      EventType d_type;
      <span class="keywordtype">int</span>       d_workerId;
      <span class="keywordtype">int</span>       d_eventNumber;
      <span class="keywordtype">char</span>      d_eventText[k_MAX_EVENT_TEXT];
  };
</pre></div><br/>
<br/>
 As noted in the previous example, <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create()</a></code> spawns a new thread, which invokes a simple "C" function taking a <code>void</code> pointer. In the previous example, we simply converted that <code>void</code> pointer into a pointer to <code><a class="el" href="classbdlcc_1_1MultipriorityQueue.html">bdlcc::MultipriorityQueue</a>&lt;MyWorkRequest&gt;</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, however, we want to pass an additional data item. Each worker thread is initialized with a unique integer value ("worker Id"), which identifies that thread. We therefore create a simple <code>struct</code> that contains both of these values: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>MyWorkerData {
      <span class="keywordtype">int</span>                               d_workerId;
      <a class="code" href="classbdlcc_1_1MultipriorityQueue.html">bdlcc::MultipriorityQueue&lt;MyEvent&gt;</a> *d_queue;
  };
</pre></div><br/>
<br/>
 Function <code>myWorker</code> (below) simulates a working thread by enqueuing multiple <code>MyEvent</code> events during execution. In a realistic application, each <code>MyEvent</code> structure would likely contain different textual information. For the sake of simplicity, however, our loop uses a constant value for the text field. Note that various priorities are generated to illustrate the multi-priority aspect of this particular queue: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myWorker(<span class="keywordtype">int</span> workerId, <a class="code" href="classbdlcc_1_1MultipriorityQueue.html">bdlcc::MultipriorityQueue&lt;MyEvent&gt;</a> *queue)
  {
      <span class="keyword">const</span> <span class="keywordtype">int</span> N = queue-&gt;<a class="code" href="classbdlcc_1_1MultipriorityQueue.html#a27a813681e89c626b6f0e30a820cb004">numPriorities</a>();
      <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_EVENTS = 5;
      <span class="keywordtype">int</span> eventNumber;    <span class="comment">// used also to generate mixed priorities</span>

      <span class="comment">// First push &#39;NUM_EVENTS&#39; events onto &#39;queue&#39; with mixed priorities.</span>

      <span class="keywordflow">for</span> (eventNumber = 0; eventNumber &lt; NUM_EVENTS; ++eventNumber) {
          MyEvent ev = {
              MyEvent::e_IN_PROGRESS,
              workerId,
              eventNumber,
              <span class="stringliteral">&quot;In-Progress Event&quot;</span>         <span class="comment">// constant (for simplicity)</span>
          };
          queue-&gt;<a class="code" href="classbdlcc_1_1MultipriorityQueue.html#a3ab01160056b4a6af31917a333ee8019">pushBack</a>(ev, eventNumber % N);       <span class="comment">// mixed priorities</span>
      }

      <span class="comment">// Now push an event to end this task.</span>

      MyEvent ev = {
          MyEvent::e_TASK_COMPLETE,
          workerId,
          eventNumber,
          <span class="stringliteral">&quot;Task Complete&quot;</span>
      };
      queue-&gt;<a class="code" href="classbdlcc_1_1MultipriorityQueue.html#a3ab01160056b4a6af31917a333ee8019">pushBack</a>(ev, N - 1);                     <span class="comment">// lowest priority</span>
  }
</pre></div><br/>
<br/>
 The callback function <code>myWorkerThread</code> (below) invoked by <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a></code> takes the traditional <code>void</code> pointer. The expected data is the composite structure <code>MyWorkerData</code>. The callback function casts the <code>void</code> pointer to the application-specific data type and then uses the referenced object to construct a call to the <code>myWorker</code> function: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *myWorkerThread(<span class="keywordtype">void</span> *vWorkerPtr)
  {
      MyWorkerData *workerPtr = (MyWorkerData *)vWorkerPtr;
      myWorker(workerPtr-&gt;d_workerId, workerPtr-&gt;d_queue);
      <span class="keywordflow">return</span> vWorkerPtr;
  }
</pre></div><br/>
<br/>
 For the sake of simplicity, we will implement the Observer behavior (below) in the main thread. The <code>void</code> function <code>myObserver</code> starts multiple threads running the <code>myWorker</code> function, reads <code>MyEvent</code> values from the queue, and logs all messages in the order of arrival. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As each <code>myWorker</code> thread terminates, it sends a <code>e_TASK_COMPLETE</code> event. Upon receiving this event, the <code>myObserver</code> function uses the <code>d_workerId</code> to find the relevant thread, and then "joins" that thread. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>myObserver</code> function determines when all tasks have completed simply by counting the number of <code>e_TASK_COMPLETE</code> messages received: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myObserver()
  {
      <span class="keyword">const</span> <span class="keywordtype">int</span> k_NUM_THREADS    = 10;
      <span class="keyword">const</span> <span class="keywordtype">int</span> k_NUM_PRIORITIES = 4;

      <a class="code" href="classbdlcc_1_1MultipriorityQueue.html">bdlcc::MultipriorityQueue&lt;MyEvent&gt;</a> queue(k_NUM_PRIORITIES);

      assert(0 &lt; k_NUM_THREADS
          &amp;&amp; k_NUM_THREADS &lt;= static_cast&lt;int&gt;(k_MAX_CONSUMER_THREADS));
      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> workerHandles[k_MAX_CONSUMER_THREADS];

      <span class="comment">// Create &#39;k_NUM_THREADS&#39; threads, each having a unique &quot;worker id&quot;.</span>

      MyWorkerData workerData[k_NUM_THREADS];
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; k_NUM_THREADS; ++i) {
          workerData[i].d_queue = &amp;queue;
          workerData[i].d_workerId = i;
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;workerHandles[i],
                                   myWorkerThread,
                                   &amp;workerData[i]);
      }

      <span class="comment">// Now print out each of the &#39;MyEvent&#39; values as the threads complete.</span>
      <span class="comment">// This function ends after a total of &#39;k_NUM_THREADS&#39;</span>
      <span class="comment">// &#39;MyEvent::e_TASK_COMPLETE&#39; events have been printed.</span>

      <span class="keywordtype">int</span> nStop = 0;
      <span class="keywordflow">while</span> (nStop &lt; k_NUM_THREADS) {
          MyEvent ev;
          queue.<a class="code" href="classbdlcc_1_1MultipriorityQueue.html#a70ff34c3f81809af872c13021907b836">popFront</a>(&amp;ev);
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; ev.d_workerId &lt;&lt; <span class="stringliteral">&quot;] &quot;</span>
                    &lt;&lt; ev.d_eventNumber &lt;&lt; <span class="stringliteral">&quot;. &quot;</span>
                    &lt;&lt; ev.d_eventText &lt;&lt; bsl::endl;
          <span class="keywordflow">if</span> (MyEvent::e_TASK_COMPLETE == ev.d_type) {
              ++nStop;
              <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(workerHandles[ev.d_workerId]);
          }
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:38 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
