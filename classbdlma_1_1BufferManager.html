<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Class bdlma::BufferManager</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlma.html">bdlma</a>      </li>
      <li><a class="el" href="classbdlma_1_1BufferManager.html">bdlma::BufferManager</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlma::BufferManager Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlma::BufferManager" -->
<p><code>#include &lt;<a class="el" href="bdlma__buffermanager_8h_source.html">bdlma_buffermanager.h</a>&gt;</code></p>

<p><a href="classbdlma_1_1BufferManager-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferManager.html#a099921433ba133adafc81e42bd28f2d7">BufferManager</a> (<a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> strategy=bsls::Alignment::BSLS_NATURAL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferManager.html#a065714e4d0df5b20dd0db1a35bc78634">BufferManager</a> (char *buffer, int bufferSize, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> strategy=bsls::Alignment::BSLS_NATURAL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferManager.html#a40e77cc850466f29b899b77896939c77">~BufferManager</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferManager.html#a149935ec37f593310f7fd8ae4138826b">allocate</a> (<a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a> size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferManager.html#abbd4e0a33f3ea929dc8a1f2fb6351bfe">allocateRaw</a> (int size)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferManager.html#acf4b17f4326f650ab466831657e7ebc3">deleteObjectRaw</a> (const TYPE *object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferManager.html#a10ec04c31ab60599d1ecccd3dcec26b3">deleteObject</a> (const TYPE *object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferManager.html#a24302b57dff93fc267fbc06207f40b5c">expand</a> (void *address, int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferManager.html#a08b80c042222f96fd4817ddf0ac43c9a">replaceBuffer</a> (char *newBuffer, int newBufferSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferManager.html#aa0f81d2c02bbd491dae239a08d36e33d">release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferManager.html#a30e237a410c1bbda3e7a3050e3abd90e">reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferManager.html#a9f6aa6fecd7c6c5b290180bdafffc9a3">truncate</a> (void *address, int originalSize, int newSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferManager.html#abe58306e42cb3f1505e7de01dbcabe55">buffer</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferManager.html#ade5b76e63a90ed53a0c80107b37019b5">bufferSize</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1BufferManager.html#a244d429824672c0aa035fda35b77c1f4">hasSufficientCapacity</a> (int size) const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements a buffer manager that dispenses heterogeneous blocks of memory (of varying, user-specified sizes) from an external buffer whose address and size are optionally supplied at construction. If an allocation request exceeds the remaining free memory space in the external buffer, the allocation request returns 0 if <code>allocate</code> is used, or results in undefined behavior if <code>allocateRaw</code> is used. Note that in no event will the buffer manager attempt to deallocate the external buffer. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a099921433ba133adafc81e42bd28f2d7"></a><!-- doxytag: member="bdlma::BufferManager::BufferManager" ref="a099921433ba133adafc81e42bd28f2d7" args="(bsls::Alignment::Strategy strategy=bsls::Alignment::BSLS_NATURAL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferManager::BufferManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>strategy</em> = <code>bsls::Alignment::BSLS_NATURAL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a buffer manager for allocating memory blocks. Optionally specify an alignment <code>strategy</code> used to align allocated memory blocks. If <code>strategy</code> is not specified, natural alignment is used. A default constructed buffer manager is unable to allocate any memory until an external buffer is provided by calling the <code>replaceBuffer</code> method. </p>

</div>
</div>
<a class="anchor" id="a065714e4d0df5b20dd0db1a35bc78634"></a><!-- doxytag: member="bdlma::BufferManager::BufferManager" ref="a065714e4d0df5b20dd0db1a35bc78634" args="(char *buffer, int bufferSize, bsls::Alignment::Strategy strategy=bsls::Alignment::BSLS_NATURAL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferManager::BufferManager </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>strategy</em> = <code>bsls::Alignment::BSLS_NATURAL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a buffer manager for allocating memory blocks from the specified external <code>buffer</code> having the specified <code>bufferSize</code> (in bytes). Optionally specify an alignment <code>strategy</code> used to align allocated memory blocks. If <code>strategy</code> is not specified, natural alignment is used. The behavior is undefined unless <code>0 &lt; bufferSize</code> and <code>buffer</code> has at least <code>bufferSize</code> bytes. </p>

</div>
</div>
<a class="anchor" id="a40e77cc850466f29b899b77896939c77"></a><!-- doxytag: member="bdlma::BufferManager::~BufferManager" ref="a40e77cc850466f29b899b77896939c77" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::BufferManager::~BufferManager </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this buffer manager. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a149935ec37f593310f7fd8ae4138826b"></a><!-- doxytag: member="bdlma::BufferManager::allocate" ref="a149935ec37f593310f7fd8ae4138826b" args="(bsls::Types::size_type size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bdlma::BufferManager::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a contiguous block of memory of the specified <code>size</code> (in bytes) on success, according to the alignment strategy specified at construction, and 0 if the allocation request exceeds the remaining free memory space in the external buffer. The behavior is undefined unless <code>0 &lt; size</code> and this object is currently managing a buffer. </p>

</div>
</div>
<a class="anchor" id="abbd4e0a33f3ea929dc8a1f2fb6351bfe"></a><!-- doxytag: member="bdlma::BufferManager::allocateRaw" ref="abbd4e0a33f3ea929dc8a1f2fb6351bfe" args="(int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bdlma::BufferManager::allocateRaw </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a contiguous block of memory of the specified <code>size</code> (in bytes) according to the alignment strategy specified at construction. The behavior is undefined unless the allocation request does not exceed the remaining free memory space in the external buffer, <code>0 &lt; size</code>, and this object is currently managing a buffer. </p>

</div>
</div>
<a class="anchor" id="acf4b17f4326f650ab466831657e7ebc3"></a><!-- doxytag: member="bdlma::BufferManager::deleteObjectRaw" ref="acf4b17f4326f650ab466831657e7ebc3" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::BufferManager::deleteObjectRaw </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code>. Note that memory associated with <code>object</code> is not deallocated because there is no <code>deallocate</code> method in <code><a class="el" href="classbdlma_1_1BufferManager.html">BufferManager</a></code>. </p>

</div>
</div>
<a class="anchor" id="a10ec04c31ab60599d1ecccd3dcec26b3"></a><!-- doxytag: member="bdlma::BufferManager::deleteObject" ref="a10ec04c31ab60599d1ecccd3dcec26b3" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::BufferManager::deleteObject </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code>. Note that this method has the same effect as the <code>deleteObjectRaw</code> method (since no deallocation is involved), and exists for consistency with a pool interface. </p>

</div>
</div>
<a class="anchor" id="a24302b57dff93fc267fbc06207f40b5c"></a><!-- doxytag: member="bdlma::BufferManager::expand" ref="a24302b57dff93fc267fbc06207f40b5c" args="(void *address, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlma::BufferManager::expand </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Increase the amount of memory allocated at the specified <code>address</code> from the original <code>size</code> (in bytes) to also include the maximum amount remaining in the buffer. Return the amount of memory available at <code>address</code> after expanding, or <code>size</code> if the memory at <code>address</code> cannot be expanded. This method can only <code>expand</code> the memory block returned by the most recent <code>allocate</code> or <code>allocateRaw</code> request from this buffer manager, and otherwise has no effect. The behavior is undefined unless the memory at <code>address</code> was originally allocated by this buffer manager, the size of the memory at <code>address</code> is <code>size</code>, and <code>release</code> was not called after allocating the memory at <code>address</code>. </p>

</div>
</div>
<a class="anchor" id="a08b80c042222f96fd4817ddf0ac43c9a"></a><!-- doxytag: member="bdlma::BufferManager::replaceBuffer" ref="a08b80c042222f96fd4817ddf0ac43c9a" args="(char *newBuffer, int newBufferSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* bdlma::BufferManager::replaceBuffer </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>newBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>newBufferSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace the buffer currently managed by this object with the specified <code>newBuffer</code> of the specified <code>newBufferSize</code> (in bytes); return the address of the previously held buffer, or 0 if this object currently manages no buffer. The replaced buffer (if any) is removed from the management of this object with no effect on the outstanding allocated memory blocks. Subsequent allocations will allocate memory from the beginning of the new external buffer. The behavior is undefined unless <code>0 &lt; newBufferSize</code> and <code>newBuffer</code> has at least <code>newBufferSize</code> bytes. </p>

</div>
</div>
<a class="anchor" id="aa0f81d2c02bbd491dae239a08d36e33d"></a><!-- doxytag: member="bdlma::BufferManager::release" ref="aa0f81d2c02bbd491dae239a08d36e33d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::BufferManager::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release all memory currently allocated through this buffer manager. After this call, the external buffer managed by this object is retained. Subsequent allocations will allocate memory from the beginning of the external buffer (if any). </p>

</div>
</div>
<a class="anchor" id="a30e237a410c1bbda3e7a3050e3abd90e"></a><!-- doxytag: member="bdlma::BufferManager::reset" ref="a30e237a410c1bbda3e7a3050e3abd90e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::BufferManager::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset this buffer manager to its default constructed state, except retain the alignment strategy in effect at the time of construction. The currently managed buffer (if any) is removed from the management of this object with no effect on the outstanding allocated memory blocks. </p>

</div>
</div>
<a class="anchor" id="a9f6aa6fecd7c6c5b290180bdafffc9a3"></a><!-- doxytag: member="bdlma::BufferManager::truncate" ref="a9f6aa6fecd7c6c5b290180bdafffc9a3" args="(void *address, int originalSize, int newSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlma::BufferManager::truncate </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>originalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>newSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reduce the amount of memory allocated at the specified <code>address</code> of the specified <code>originalSize</code> (in bytes) to the specified <code>newSize</code> (in bytes). Return <code>newSize</code> after truncating, or <code>originalSize</code> if the memory at <code>address</code> cannot be truncated. This method can only <code>truncate</code> the memory block returned by the most recent <code>allocate</code> or <code>allocateRaw</code> request from this object, and otherwise has no effect. The behavior is undefined unless the memory at <code>address</code> was originally allocated by this buffer manager, the size of the memory at <code>address</code> is <code>originalSize</code>, <code>newSize &lt;= originalSize</code>, <code>0 &lt;= newSize</code>, and <code>release</code> was not called after allocating the memory at <code>address</code>. </p>

</div>
</div>
<a class="anchor" id="abe58306e42cb3f1505e7de01dbcabe55"></a><!-- doxytag: member="bdlma::BufferManager::buffer" ref="abe58306e42cb3f1505e7de01dbcabe55" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* bdlma::BufferManager::buffer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an address providing modifiable access to the buffer currently managed by this object, or 0 if this object currently manages no buffer. </p>

</div>
</div>
<a class="anchor" id="ade5b76e63a90ed53a0c80107b37019b5"></a><!-- doxytag: member="bdlma::BufferManager::bufferSize" ref="ade5b76e63a90ed53a0c80107b37019b5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlma::BufferManager::bufferSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the size (in bytes) of the buffer currently managed by this object, or 0 if this object currently manages no buffer. </p>

</div>
</div>
<a class="anchor" id="a244d429824672c0aa035fda35b77c1f4"></a><!-- doxytag: member="bdlma::BufferManager::hasSufficientCapacity" ref="a244d429824672c0aa035fda35b77c1f4" args="(int size) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlma::BufferManager::hasSufficientCapacity </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if there is sufficient memory space in the buffer to allocate a contiguous memory block of the specified <code>size</code> (in bytes) after taking the alignment strategy into consideration, and <code>false</code> otherwise. The behavior is undefined unless <code>0 &lt; size</code>, and this object is currently managing a buffer. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlma__buffermanager_8h_source.html">bdlma_buffermanager.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:26 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
